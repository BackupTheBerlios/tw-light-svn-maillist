From yurand at sheep.berlios.de  Sun Feb 13 19:24:26 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 13 Feb 2005 19:24:26 +0100
Subject: [Tw-light-svn] r113 - in trunk: doc source source/melee
Message-ID: <200502131824.j1DIOQYR023095@sheep.berlios.de>

Author: yurand
Date: 2005-02-13 19:24:22 +0100 (Sun, 13 Feb 2005)
New Revision: 113

Modified:
   trunk/doc/Doxyfile
   trunk/source/melee/mgame.h
   trunk/source/melee/mnet1.h
   trunk/source/scp.cpp
Log:
Nothing changed


Modified: trunk/doc/Doxyfile
===================================================================
--- trunk/doc/Doxyfile	2005-01-13 02:29:56 UTC (rev 112)
+++ trunk/doc/Doxyfile	2005-02-13 18:24:22 UTC (rev 113)
@@ -140,7 +140,7 @@
 #---------------------------------------------------------------------------
 # configuration options related to the XML output
 #---------------------------------------------------------------------------
-GENERATE_XML           = NO
+GENERATE_XML           = No
 XML_OUTPUT             = xml
 XML_SCHEMA             = 
 XML_DTD                = 
@@ -171,7 +171,7 @@
 # Configuration::addtions related to external references   
 #---------------------------------------------------------------------------
 TAGFILES               = 
-GENERATE_TAGFILE       = 
+GENERATE_TAGFILE       = tw-light.xml
 ALLEXTERNALS           = NO
 EXTERNAL_GROUPS        = YES
 PERL_PATH              = /usr/bin/perl

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-01-13 02:29:56 UTC (rev 112)
+++ trunk/source/melee/mgame.h	2005-02-13 18:24:22 UTC (rev 113)
@@ -63,7 +63,7 @@
   
 };
 
-
+/// All games types should inher from this class
 class Game : public Physics 
 {
  public:
@@ -118,9 +118,9 @@
   };
 
 
-  virtual void preinit();	/**< pre-initialization (enough so that the destructor won't crash) */
-  virtual void init(Log *log);/**< initialization (loading data, creating a few game objects, whatever)*/
-  virtual ~Game();        /**< deallocating memory etc.*/
+  virtual void preinit();	///< pre-initialization (enough so that the destructor won't crash) 
+  virtual void init(Log *log);  ///< initialization (loading data, creating a few game objects, whatever)
+  virtual ~Game();              ///< deallocating memory etc.
   
   virtual void init_lag();
   
@@ -159,7 +159,7 @@
   /// sets whether the game is done, according to the rules for the
   /// gametype.
   virtual void setGameDone(const bool done);
-  
+
   /// gets if the game is done.  Will wait a few seconds for dramatic effect.
   virtual bool isGameDone();
   

Modified: trunk/source/melee/mnet1.h
===================================================================
--- trunk/source/melee/mnet1.h	2005-01-13 02:29:56 UTC (rev 112)
+++ trunk/source/melee/mnet1.h	2005-02-13 18:24:22 UTC (rev 113)
@@ -13,91 +13,90 @@
 
 
 
-class GameEvent {
-public:
-	short int size;
-	short int type;
-	GameEvent() {
-		size = sizeof(this); 
-		type = Game::event_invalid;
-	}
-	void *operator new (size_t size) {return malloc(size);}
+class GameEvent 
+{
+ public:
+  short int size;
+  short int type;
+  GameEvent() 
+    {
+      size = sizeof(this); 
+      type = Game::event_invalid;
+    }
+  void *operator new (size_t size) {return malloc(size);}
 };
-class GameEventChangeLag : public GameEvent {
-public:
-	short int old_lag;
-	short int new_lag;
-	GameEventChangeLag( int lag_frames ) {
-		size = sizeof(this);
-		type = Game::event_change_lag;
-		old_lag = game->lag_frames;
-		new_lag = lag_frames;
-	}
-	void execute ( int source );
+
+class GameEventChangeLag : public GameEvent 
+{
+ public:
+  short int old_lag;
+  short int new_lag;
+  GameEventChangeLag( int lag_frames ) 
+    {
+      size = sizeof(this);
+      type = Game::event_change_lag;
+      old_lag = game->lag_frames;
+      new_lag = lag_frames;
+    }
+  void execute ( int source );
 };
-class GameEventMessage : public GameEvent {
-public:
-	enum { max_message_length = 150 };
-	char message[max_message_length];
-	GameEventMessage( const char *text ) ;
-	void execute ( int source );
+
+class GameEventMessage : public GameEvent 
+{
+ public:
+  enum { max_message_length = 150 };
+  char message[max_message_length];
+  GameEventMessage( const char *text ) ;
+  void execute ( int source );
 };
 
-/*
-class LagHandler {
-	unsigned char lag;  //a copy of lag_frames
-	unsigned char size; //bytes per frame
-	char channel;       //channel to transmit on
-	void *data;         //serialized
-//	void log ( void *data, 
-};*/
 
+/// Logging system, usefull for networking & demo recording/playback
+class NetLog : public Log 
+{ 
+ protected:
 
-class NetLog : public Log { //Logging system, usefull for networking & demo recording/playback
-	protected:
+  int *log_transmitted;      ///<the number of bytes transmitted in each channel
+  void expand_logs(int num_channels) ; ///< intializes these extensions to the logging
+  unsigned char buffy[4096]; ///< a buffer for sending and recieving packets
+  void handle_code(unsigned int code) ;
+  void send_code(unsigned int code) ;
+  enum code 
+    {
+      NET1_CODE_QUIT         = 0x80000001,
+      NET1_CODE_PAUSE        = 0x80000002,
+      NET1_CODE_UNPAUSE      = 0x80000003,
+      NET1_CODE_INCREASE_LAG = 0x80000004,
+      NET1_CODE_DECREASE_LAG = 0x80000005,
+      NET1_CODE_MESSAGE      = 0x90000000
+    };
+  void send_message(char *string) ;
+  
+  void send_packet(); //sends a packet
+  
+ public:
+  
+  bool need_to_transmit;
+  NetTCP net;       ///< the TCP network connection to the opponent player
+  
+  enum {
+    direction_immediate = 16
+  };
+  
+  void recv_packet(); ///< recieves a packet
+  
+  int remote_time; ///< used in calculating ping
+  int ping;            ///< the most recently measured ping
+  
+  virtual void init();
+  virtual void deinit();
+  virtual ~NetLog();
+  virtual void _log(int channel, const void *data, int size);   ///< used for recording data.  this version may transmit it over the network
+  virtual void _unlog(int channel, void *data, int size); ///< used for playing back data.  this version may recieve it over the network
+  void log_file(const char *fname) ;
+  virtual int ready(int channel);
+  
+  virtual void flush() ;
+  virtual bool listen();
+};
 
-	int *log_transmitted;      //the number of bytes transmitted in each channel
-	void expand_logs(int num_channels) ; //intializes these extensions to the logging
-	unsigned char buffy[4096]; //a buffer for sending and recieving packets
-	void handle_code(unsigned int code) ;
-	void send_code(unsigned int code) ;
-	enum code {
-		NET1_CODE_QUIT    = 0x80000001,
-		NET1_CODE_PAUSE   = 0x80000002,
-		NET1_CODE_UNPAUSE = 0x80000003,
-		NET1_CODE_INCREASE_LAG = 0x80000004,
-		NET1_CODE_DECREASE_LAG = 0x80000005,
-		NET1_CODE_MESSAGE = 0x90000000
-		};
-	void send_message(char *string) ;
-
-	void send_packet(); //sends a packet
-
-	public:
-
-	bool need_to_transmit;
-	NetTCP net;       // the TCP network connection to the opponent player
-
-	enum {
-		direction_immediate = 16
-		};
-
-	void recv_packet(); //recieves a packet
-
-	int remote_time; //used in calculating ping
-	int ping;            //the most recently measured ping
-
-	virtual void init();
-	virtual void deinit();
-	virtual ~NetLog();
-	virtual void _log(int channel, const void *data, int size);   //used for recording data.  this version may transmit it over the network
-	virtual void _unlog(int channel, void *data, int size); //used for playing back data.  this version may recieve it over the network
-	void log_file(const char *fname) ;
-	virtual int ready(int channel);
-
-	virtual void flush() ;
-	virtual bool listen();
-
-
-	};
-

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-01-13 02:29:56 UTC (rev 112)
+++ trunk/source/scp.cpp	2005-02-13 18:24:22 UTC (rev 113)
@@ -1968,3 +1968,4 @@
 		 _copy_ship_ini, 0);
   return 0;
 }
+



From yurand at sheep.berlios.de  Sun Feb 13 23:23:46 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 13 Feb 2005 23:23:46 +0100
Subject: [Tw-light-svn] r114 - in trunk: gamedata source source/games source/melee source/other
Message-ID: <200502132223.j1DMNkax001763@sheep.berlios.de>

Author: yurand
Date: 2005-02-13 23:23:45 +0100 (Sun, 13 Feb 2005)
New Revision: 114

Modified:
   trunk/gamedata/ingame.txt
   trunk/source/games/gadventure.h
   trunk/source/games/glegacies.cpp
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mlog.cpp
   trunk/source/melee/mmain.cpp
   trunk/source/other/dialogs.cpp
   trunk/source/other/dialogs.h
   trunk/source/scp.cpp
Log:
Adding menu for melee


Modified: trunk/gamedata/ingame.txt
===================================================================
--- trunk/gamedata/ingame.txt	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/gamedata/ingame.txt	2005-02-13 22:23:45 UTC (rev 114)
@@ -1,20 +1,21 @@
 Global keys:
-  F1 brings up the help screen
-  F2 brings up the options menu
-  F3 switches camera focus
-  F4 is fast-forward (speeds up in-game time greatly)
-  F5 displays fleet status
+  F1 brings up this help screen
+  F2 save game
+  F3 load game
+  F4 brings up the options menu
+  F5 is fast-forward (speeds up in-game time greatly)
+  F6 displays fleet status
   F7 changes game tic rate (physics quality)
   F8 changes camera mode
-  F10 quits (so does ESCAPE)
-  F11 saves screenshots
+  F9 switches camera focus
+  F10 menu
   F12 displays framerates / performance data
   - zooms out on some viewing modes.
   + (or =) zooms in on some viewing modes.
   0 and 9 also effect the camera in some viewing modes.
   ctrl+T = toggle team indicators on/off
   ctrl+H = toggle healthbar indicators on/off
-
+  ctrl+Alt+k = kill all ships and ship-objects in the melee-game
 Melee:  
   Starts a battle with the current team settings.
 

Modified: trunk/source/games/gadventure.h
===================================================================
--- trunk/source/games/gadventure.h	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/games/gadventure.h	2005-02-13 22:23:45 UTC (rev 114)
@@ -44,6 +44,8 @@
   std::string Save();
   /// load game
   int Load(std::string);
+  /// exit game
+  void quit(const char *message);
 };
 
 

Modified: trunk/source/games/glegacies.cpp
===================================================================
--- trunk/source/games/glegacies.cpp	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/games/glegacies.cpp	2005-02-13 22:23:45 UTC (rev 114)
@@ -33,10 +33,29 @@
 #include "scp.h"
 #include "other/dialogs.h"
 
-//#include "gadventure.h"
+#include "gadventure.h"
 
 /// TW Legacies Adventure Game 
 ///
 
-//REGISTER_GAME ( LegaciesGame, "TW:Legacies" )
 
+std::string LegaciesGame::Save()
+{
+  tw_error("Save called");
+  return "";
+}
+
+int LegaciesGame::Load(std::string)
+{
+  return 0;
+};
+
+void LegaciesGame::quit(const char *message)
+{
+  STACKTRACE;
+  Save();
+  Game::quit(message);
+}
+
+REGISTER_GAME ( LegaciesGame, "TW:Legacies" )
+

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/melee/mgame.cpp	2005-02-13 22:23:45 UTC (rev 114)
@@ -44,11 +44,8 @@
 #include <stdarg.h>
 
 #include "other/twconfig.h"
+#include "other/dialogs.h"
 
-static char chat_buf[256];
-static int chat_len = 0;
-static int chat_on = 0;
-
 int random_seed[2];
 
 
@@ -430,40 +427,39 @@
   return;
 }
 
-bool Game::game_ready() {
+bool Game::game_ready() 
+{
   STACKTRACE;
-	if (CHECKSUM_CHANNEL == 0) return 1;
-	if (log->playback) {
-		return (log->ready(channel_server + Game::_channel_buffered) != 0);
-	}
-	else switch (log->type) {
-		case Log::log_normal: {
-			return true;
-		}
-		break;
-		case Log::log_net1server:
-		case Log::log_net1client: {
-			if (!log->ready(channel_client + Game::_channel_buffered)) return false;
-			if (!log->ready(channel_server + Game::_channel_buffered)) return false;
-			return true;
-		}
-	}
+  if (CHECKSUM_CHANNEL == 0) 
+    return 1;
+  if (log->playback) 
+    {
+      return (log->ready(channel_server + Game::_channel_buffered) != 0);
+    }
+  else switch (log->type) 
+    {
+    case Log::log_normal: {
+      return true;
+    }
+      break;
+    case Log::log_net1server:
+    case Log::log_net1client: 
+      {
+	if (!log->ready(channel_client + Game::_channel_buffered)) return false;
+	if (!log->ready(channel_server + Game::_channel_buffered)) return false;
 	return true;
+      }
+    }
+  return true;
 }
 
 void Game::handle_desynch(int local_checksum, int server_checksum, int client_checksum) 
 {
   STACKTRACE;
-  //  tw_error("Game Desynchronized\nTime=%d Frame=%d\nClient=%d Server=%d Local=%d", game_time, frame_number, (int)client_checksum, (int)server_checksum, (int)local_checksum);
   tw_error("Game Desynchronized");
 }
 
-//static int old_num_items;
-//static int old_rng;
-//static int old_frame;
-//static char old_checksum_buf[200][200];
 
-
 //if a game is killed due to an error, this may be executed
 void handle_game_error ( Game *game )
 {
@@ -678,7 +674,7 @@
 		calculate();
 	      log->flush();
 	      log->listen();
-	      if (key[KEY_F4])
+	      if (key[KEY_F5])
 		turbo = f4_turbo;
 	      else
 		turbo = normal_turbo;
@@ -812,9 +808,6 @@
 		message.print((int)msecs_per_fps, 12, "render time: %.3fms (that's %s)", rt, tmp);
 		message.print((int)msecs_per_fps, 12, "debug: %d", debug_value);
 	}
-
-	if (chat_on)
-		message.print((int)msecs_per_fps, 15, "say: %s", chat_buf);
 }
 
 void Game::preinit() 
@@ -1076,7 +1069,10 @@
 {
   STACKTRACE;
   if (time_paused != -1) 
-    tw_error ("can't pause -- already paused");
+    {
+      return;
+      tw_error ("can't pause -- already paused");
+    }
   time_paused = get_time();
 }
 
@@ -1084,7 +1080,10 @@
 {
   STACKTRACE;
   if (time_paused == -1) 
-    tw_error ("can't unpause -- not paused");
+    {
+      return;
+      tw_error ("can't unpause -- not paused");
+    }
   redraw();
   paused_time += get_time() - time_paused;
   time_paused = -1;
@@ -1126,53 +1125,38 @@
   STACKTRACE;
   switch (k >> 8) 
     {
-#if !defined _DEBUG
-    case KEY_F11: 
-      {
+    case KEY_F1: 
+      {// help
 	pause();
-	save_screenshot();
+	showHelpText();
 	unpause();
-      return true;
+	return true;
       }
       break;
-    case KEY_F10: 
-#endif
-    case KEY_ESC: 
+    case KEY_F2:
       {
-	//(*((int*)NULL)) = 0;
 	pause();
-	if (tw_alert("Game is paused", "&Abort game", "&Resume playing") == 1) 
-	  {
-	    game->quit("quit - Game aborted from keyboard");
-	  }
+	Save();
 	unpause();
 	return true;
       }
       break;
-    case KEY_F1: 
-      {// help
+    case KEY_F3:
+      {
 	pause();
-	showHelpText();
-	//show_file(data_full_path("ingame.txt"));
+	Load("");
 	unpause();
 	return true;
       }
       break;
-    case KEY_F3: 
-      {// switch hero
-	if (num_focuses) focus_index = (focus_index + 1) % num_focuses;
-	message.print(1000, 15, "Camera focus %d (of %d)", focus_index+1, num_focuses);
+    case KEY_F4: 
+      {
+	pause();
+	options_menu(this);
+	unpause();
 	return true;
       }
       break;
-    case KEY_F6: 
-      {// send message
-	chat_len = 0;
-	chat_buf[0] = '\0';
-	chat_on = 1;
-	return true;
-      }
-      break;
     case KEY_F7: 
       {
 	if (physics_locked) return false;
@@ -1195,63 +1179,49 @@
 	return true;
       }
       break;
-    case KEY_F8: {
-      if (view_locked) return false;
-      if (!view || !view->type) return false;
-      if (!strcmp(view->type->name, "Hero")) {
-	game->change_view("Enemy");
-	message.print(2500, 15, "View mode changed to 'Enemy'");
+    case KEY_F8: 
+      {
+	if (view_locked) 
+	  return false;
+	if (!view || !view->type) 
+	  return false;
+	if (!strcmp(view->type->name, "Hero")) 
+	  {
+	    game->change_view("Enemy");
+	    message.print(2500, 15, "View mode changed to 'Enemy'");
+	    return true;
+	  }
+	if (!strcmp(view->type->name, "Enemy")) 
+	  {
+	    game->change_view("Hero");
+	    message.print(2500, 15, "View mode changed to 'Hero'");
+	    return true;
+	  }
 	return true;
       }
-      if (!strcmp(view->type->name, "Enemy")) {
-	game->change_view("Hero");
-	message.print(2500, 15, "View mode changed to 'Hero'");
+      break;
+    case KEY_F9: 
+      {// switch hero
+	if (num_focuses) focus_index = (focus_index + 1) % num_focuses;
+	message.print(1000, 15, "Camera focus %d (of %d)", focus_index+1, num_focuses);
 	return true;
       }
-      //redraw();
-      return true;
-    }
       break;
-    default: {
-      if (chat_on) {
-	if ((k >> 8) == KEY_ENTER) {
-	  send_game_event(new GameEventMessage(chat_buf));
-	  //					player_said(0, chat_buf);
-	  chat_on = 0;
-	}
-	else if (k & 255) {
-	  if ((k & 255) == 8) {
-	    if (chat_len > 0) {
-	      chat_len -= 1;
-	      chat_buf[chat_len] = 0;
-	    }
-	  }
-	  else {
-	    chat_buf[chat_len] = k & 255;
-	    if (chat_len < 255) chat_len += 1;
-	    chat_buf[chat_len] = 0;
-	  }
-	}
+    case KEY_ESC: 
+    case KEY_F10:
+      {
+	pause();
+	GameMenu();
+	unpause();
 	return true;
       }
-    }
+    case KEY_F12: 
+      {
+	show_fps = !show_fps;
+	return true;
+      }
       break;
-    case KEY_F2: {
-      pause();
-      options_menu(this);
-      unpause();
-      return true;
     }
-      break;
-#		ifdef _DEBUG
-			case KEY_B://supposed to be F12, but the debugger isn't fond of that
-#		endif
-    case KEY_F12: {
-      show_fps = !show_fps;
-      return true;
-    }
-      break;
-    }
   return false;
 }
 
@@ -1299,4 +1269,56 @@
 }
 
 
+void Game::GameMenu()
+{
+  int mainRet = tw_do_dialog(NULL, ingameMenuDialog, INGAME_MENU_HELP);
+  switch (mainRet) 
+    {
+    case INGAME_MENU_HELP:
+      handle_key(KEY_F1<<8);
+      break;
+    case INGAME_MENU_SAVE:
+      handle_key(KEY_F2<<8);
+      break;
+    case INGAME_MENU_LOAD:
+      handle_key(KEY_F3<<8);
+      break;
+    case INGAME_MENU_OPTIONS:
+      handle_key(KEY_F4<<8);
+      break;
+    case INGAME_MENU_FAST_FORWARD:
+      handle_key(KEY_F5<<8);
+      break;
+    case INGAME_MENU_FLET_STATUS:
+      handle_key(KEY_F6<<8);
+      break;
+    case INGAME_MENU_CHANGE_TIC_RATE:
+      handle_key(KEY_F7<<8);
+      pause();
+      break;
+    case INGAME_MENU_CHANGE_CAMERA_MODE:
+      handle_key(KEY_F8<<8);
+      break;
+    case INGAME_MENU_SWITCH_CAMERA_FOCUS:
+      handle_key(KEY_F9<<8);
+      break;
+    case INGAME_MENU_DISPLAY_FRAMERATES:
+      handle_key(KEY_F12<<8);
+      break;
+    case INGAME_MENU_QUIT_GAME:
+      quit("quit - Game aborted from keyboard");
+    case INGAME_MENU_EXIT:
+      break;
+    }
+}
 
+std::string Game::Save()
+{
+  return "";
+}
+
+int Game::Load(std::string xml)
+{
+  return 0;
+}
+

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/melee/mgame.h	2005-02-13 22:23:45 UTC (rev 114)
@@ -154,7 +154,12 @@
 
 protected:  
   bool game_done;
+  /// Show ingame menu (save/load/option/quit/exit)
+  virtual void GameMenu();
 
+  virtual std::string Save();
+  virtual int Load(std::string xml);
+
 public:
   /// sets whether the game is done, according to the rules for the
   /// gametype.

Modified: trunk/source/melee/mlog.cpp
===================================================================
--- trunk/source/melee/mlog.cpp	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/melee/mlog.cpp	2005-02-13 22:23:45 UTC (rev 114)
@@ -29,58 +29,68 @@
 //				Logging stuff
 ////////////////////////////////////////////////////////////////////////
 
-void Log::init() {
+void Log::init() 
+{
   STACKTRACE;
-	log_len  = NULL;
-	log_size = NULL;
-	log_pos  = NULL;
-	log_data = NULL;
-	log_dir = NULL;
-	default_direction = direction_write | direction_read;
-	log_num = 0;
-	playback = false;
-	type = Log::log_normal;
-	return;
+  log_len  = NULL;
+  log_size = NULL;
+  log_pos  = NULL;
+  log_data = NULL;
+  log_dir = NULL;
+  default_direction = direction_write | direction_read;
+  log_num = 0;
+  playback = false;
+  type = Log::log_normal;
+  return;
 }
 
-void Log::set_direction ( int channel, char direction ) {
-	STACKTRACE;
-	if (channel < 0) { tw_error("set_direction - channel < 0"); }
-	if (channel >= log_num) {
-		expand_logs(channel+1);
-	}
-	log_dir[channel] = direction;
-	return;
+void Log::set_direction ( int channel, char direction ) 
+{
+  STACKTRACE;
+  if (channel < 0) { tw_error("set_direction - channel < 0"); }
+  if (channel >= log_num) {
+    expand_logs(channel+1);
+  }
+  log_dir[channel] = direction;
+  return;
 }
 
-char Log::get_direction ( int channel ) {
-	STACKTRACE;
-	if (channel < 0) {tw_error("get_direction - channel < 0");}
-	if (channel >= log_num) {
-		expand_logs(channel+1);
-	}
-	return (log_dir[channel]);
+char Log::get_direction ( int channel ) 
+{
+  STACKTRACE;
+  if (channel < 0) {tw_error("get_direction - channel < 0");}
+  if (channel >= log_num) 
+    {
+      expand_logs(channel+1);
+    }
+  return (log_dir[channel]);
 }
 
-void Log::set_all_directions ( char direction ) {STACKTRACE
-	default_direction = direction;
-	int i;
-	for (i = 0; i < log_num; i += 1) {
-		log_dir[i] = direction;
-	}
-	return;
+void Log::set_all_directions ( char direction ) 
+{
+  STACKTRACE;
+  default_direction = direction;
+  int i;
+  for (i = 0; i < log_num; i += 1) 
+    {
+      log_dir[i] = direction;
+    }
+  return;
 }
 
-Log::~Log() {STACKTRACE
-	if (log_data) for (int i = 0; i < log_num; i += 1) {
-		free(log_data[i]);
-	}
-	free(log_len);
-	free(log_size);
-	free(log_pos);
-	free(log_data);
-	free(log_dir);
-	log_num = 0;
+Log::~Log() 
+{
+  STACKTRACE;
+  if (log_data) for (int i = 0; i < log_num; i += 1) 
+    {
+      free(log_data[i]);
+    }
+  free(log_len);
+  free(log_size);
+  free(log_pos);
+  free(log_data);
+  free(log_dir);
+  log_num = 0;
 }
 
 void Log::log ( int channel, void *data, int size) {STACKTRACE

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/melee/mmain.cpp	2005-02-13 22:23:45 UTC (rev 114)
@@ -414,23 +414,11 @@
 			return Game::handle_key(k);
 			}
 		break;
-		case KEY_F5: {
+		case KEY_F6: {
 			display_stats();
 			return true;
 			}
 		break;
-		case KEY_F7: {
-			if (log->type == Log::log_normal) Game::handle_key(k);
-			return true;
-			}
-		break;
-		case KEY_F9: {
-			if (log->type != Log::log_normal) return false;
-			message.out("MUHAHAHAHAHA!!!!", 5000, 12);
-			add(new Planet(random(size), meleedata.planetSprite, random(meleedata.planetSprite->frames())));
-			return true;
-			}
-		break;
 		//don't use hardwired normal keys
 		case KEY_H:
 			if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;

Modified: trunk/source/other/dialogs.cpp
===================================================================
--- trunk/source/other/dialogs.cpp	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/other/dialogs.cpp	2005-02-13 22:23:45 UTC (rev 114)
@@ -28,6 +28,25 @@
 #include "melee/moptions.h"
 #include "melee/mgame.h"
 
+
+DIALOG ingameMenuDialog[] =  {
+  // (dialog proc)          (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
+  { d_agup_box_proc,        140,   40,   250,  430 ,  255,  0,     0,    0,       0,    0,    NULL, NULL, NULL },
+  { my_d_button_proc,       150,   50,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Help                  (F1) ", NULL, NULL },
+  { my_d_button_proc,       150,   85,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Save Game             (F2) ", NULL, NULL },
+  { my_d_button_proc,       150,  120,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Load Game             (F3) ", NULL, NULL },
+  { my_d_button_proc,       150,  155,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Options               (F4) ", NULL, NULL },
+  { my_d_button_proc,       150,  190,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Fast Forward          (F5) ", NULL, NULL },
+  { my_d_button_proc,       150,  225,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Fleet Status          (F6) ", NULL, NULL },
+  { my_d_button_proc,       150,  260,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Change Tic Rate       (F7) ", NULL, NULL },
+  { my_d_button_proc,       150,  295,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Change Camera Mode    (F8) ", NULL, NULL },
+  { my_d_button_proc,       150,  330,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Switches Camera Focus (F11)", NULL, NULL },
+  { my_d_button_proc,       150,  365,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Displays Framerates   (F12)", NULL, NULL },
+  { my_d_button_proc,       150,  400,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Quit game", NULL, NULL },
+  { my_d_button_proc,       150,  435,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Exit Menu", NULL, NULL },
+  { NULL,                    0,    0,     0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL }
+};
+
 DIALOG joyDialog[] = {
   // (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
   { d_agup_box_proc,        40,   40,   200,  250,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },

Modified: trunk/source/other/dialogs.h
===================================================================
--- trunk/source/other/dialogs.h	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/other/dialogs.h	2005-02-13 22:23:45 UTC (rev 114)
@@ -1,7 +1,7 @@
 /* $Id: dialogs.h,v 1.1 2004/08/03 12:02:26 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -22,6 +22,7 @@
 #ifdef WIN32
 #include <winalleg.h>
 #endif
+
 extern "C" {
 #include "libraries/agup/agup.h"
 }
@@ -47,6 +48,24 @@
 
 
 enum
+  {
+    INGAME_MENU_HELP = 1,
+    INGAME_MENU_SAVE,
+    INGAME_MENU_LOAD,
+    INGAME_MENU_OPTIONS,
+    INGAME_MENU_FAST_FORWARD,
+    INGAME_MENU_FLET_STATUS,
+    INGAME_MENU_CHANGE_TIC_RATE,
+    INGAME_MENU_CHANGE_CAMERA_MODE,
+    INGAME_MENU_SWITCH_CAMERA_FOCUS,
+    INGAME_MENU_DISPLAY_FRAMERATES,
+    INGAME_MENU_QUIT_GAME,
+    INGAME_MENU_EXIT,
+  };
+
+extern DIALOG ingameMenuDialog[];
+
+enum
 {
   JOY_DIALOG_BOX = 0,
   JOY_DIALOG_TITLE,
@@ -74,102 +93,108 @@
 extern DIALOG tw_alert_dialog4[];
 extern DIALOG tw_alert_dialog5[];
 
-enum {
-	SELECT_DIALOG_LIST = 0,
-	SELECT_DIALOG_TITLE,
-	SELECT_DIALOG_SHIP,
-	SELECT_DIALOG_RANDOM,
-	SELECT_DIALOG_ARANDOM,
-	SELECT_DIALOG_INFO,
-	SELECT_DIALOG_PIC
-};
+enum 
+  {
+    SELECT_DIALOG_LIST = 0,
+    SELECT_DIALOG_TITLE,
+    SELECT_DIALOG_SHIP,
+    SELECT_DIALOG_RANDOM,
+    SELECT_DIALOG_ARANDOM,
+    SELECT_DIALOG_INFO,
+    SELECT_DIALOG_PIC
+  };
 
 extern DIALOG selectDialog[];
 extern DIALOG help_dialog[];
 
-enum {
-	DIALOG_OPTIONS_BOX = 0,
-	DIALOG_OPTIONS_DONE,
-	DIALOG_OPTIONS_VIDEO,
-	DIALOG_OPTIONS_AUDIO,
-	DIALOG_OPTIONS_CONFIG,
-	DIALOG_OPTIONS_PHYSICS,
-	DIALOG_OPTIONS_DEFAULT
-	};
+enum 
+  {
+    DIALOG_OPTIONS_BOX = 0,
+    DIALOG_OPTIONS_DONE,
+    DIALOG_OPTIONS_VIDEO,
+    DIALOG_OPTIONS_AUDIO,
+    DIALOG_OPTIONS_CONFIG,
+    DIALOG_OPTIONS_PHYSICS,
+    DIALOG_OPTIONS_DEFAULT
+  };
 
 extern DIALOG options_dialog[];
 
-    enum { 
+    enum 
+      { 
         DIALOG_CONFIRM_VIDEO_BOX = 0,
         DIALOG_CONFIRM_VIDEO_TEXT,
         DIALOG_CONFIRM_VIDEO_YES,
         DIALOG_CONFIRM_VIDEO_NO
-    };
+      };
 
 extern DIALOG confirmVideoDialog[];
 
-enum {
-	DIALOG_VIDEO_BOX = 0,
-	DIALOG_VIDEO_FULLSCREEN,
-	DIALOG_VIDEO_CUSTOM_TEXT,
-	DIALOG_VIDEO_CUSTOM_BOX,
-	DIALOG_VIDEO_CUSTOM_EDIT,
-	DIALOG_VIDEO_RESTEXT,
-	DIALOG_VIDEO_RESLIST,
-	DIALOG_VIDEO_BPPTEXT,
-	DIALOG_VIDEO_BPPLIST,
-	DIALOG_VIDEO_EXIT,
-	DIALOG_VIDEO_GET_DEFAULT,
-	DIALOG_VIDEO_SET_DEFAULT,
-	DIALOG_VIDEO_GAMMA_TEXT,
-	DIALOG_VIDEO_GAMMA_SLIDER,
-	};
+enum 
+  {
+    DIALOG_VIDEO_BOX = 0,
+    DIALOG_VIDEO_FULLSCREEN,
+    DIALOG_VIDEO_CUSTOM_TEXT,
+    DIALOG_VIDEO_CUSTOM_BOX,
+    DIALOG_VIDEO_CUSTOM_EDIT,
+    DIALOG_VIDEO_RESTEXT,
+    DIALOG_VIDEO_RESLIST,
+    DIALOG_VIDEO_BPPTEXT,
+    DIALOG_VIDEO_BPPLIST,
+    DIALOG_VIDEO_EXIT,
+    DIALOG_VIDEO_GET_DEFAULT,
+    DIALOG_VIDEO_SET_DEFAULT,
+    DIALOG_VIDEO_GAMMA_TEXT,
+    DIALOG_VIDEO_GAMMA_SLIDER,
+  };
 extern DIALOG video_dialog[];
 
-enum {
-	DIALOG_AUDIO_BOX = 0,
-	DIALOG_AUDIO_OK,
-	DIALOG_AUDIO_CANCEL,
-	DIALOG_AUDIO_SOUND_VOL,
-	DIALOG_AUDIO_MUSIC_VOL
-	};
+enum 
+  {
+    DIALOG_AUDIO_BOX = 0,
+    DIALOG_AUDIO_OK,
+    DIALOG_AUDIO_CANCEL,
+    DIALOG_AUDIO_SOUND_VOL,
+    DIALOG_AUDIO_MUSIC_VOL
+  };
 
 extern DIALOG audio_dialog[];
 enum {
-OPTIONS_DIALOG_BOX = 0,
-OPTIONS_DIALOG_STARS_TEXT,
-OPTIONS_DIALOG_STARS_SLIDER,
-OPTIONS_DIALOG_RELATIVITY_TEXT,
-OPTIONS_DIALOG_RELATIVITY_SLIDER,
-OPTIONS_DIALOG_FRIENDLY_FIRE,
-OPTIONS_DIALOG_HIDE_CLOAKERS,
-OPTIONS_DIALOG_3DPLANET,
-OPTIONS_DIALOG_VIEW_TEXT,
-OPTIONS_DIALOG_VIEW,
-OPTIONS_DIALOG_OK,
-OPTIONS_DIALOG_CANCEL,
-
-OPTIONS_DIALOG_QUALITY_TEXT,
-OPTIONS_DIALOG_INTERPOLATION_ON,
-OPTIONS_DIALOG_AA_ON,
-OPTIONS_DIALOG_NOALIGN_ON,
-OPTIONS_DIALOG_BLEND_ON,
-OPTIONS_DIALOG_ALPHA_ON,
-
-OPTIONS_DIALOG_END
+  OPTIONS_DIALOG_BOX = 0,
+  OPTIONS_DIALOG_STARS_TEXT,
+  OPTIONS_DIALOG_STARS_SLIDER,
+  OPTIONS_DIALOG_RELATIVITY_TEXT,
+  OPTIONS_DIALOG_RELATIVITY_SLIDER,
+  OPTIONS_DIALOG_FRIENDLY_FIRE,
+  OPTIONS_DIALOG_HIDE_CLOAKERS,
+  OPTIONS_DIALOG_3DPLANET,
+  OPTIONS_DIALOG_VIEW_TEXT,
+  OPTIONS_DIALOG_VIEW,
+  OPTIONS_DIALOG_OK,
+  OPTIONS_DIALOG_CANCEL,
+  
+  OPTIONS_DIALOG_QUALITY_TEXT,
+  OPTIONS_DIALOG_INTERPOLATION_ON,
+  OPTIONS_DIALOG_AA_ON,
+  OPTIONS_DIALOG_NOALIGN_ON,
+  OPTIONS_DIALOG_BLEND_ON,
+  OPTIONS_DIALOG_ALPHA_ON,
+  
+  OPTIONS_DIALOG_END
 };
 
 extern DIALOG old_optionsDialog[];
 
-enum {
-	MAIN_DIALOG_BOX = 0,
-	MAIN_DIALOG_MELEE,
-	MAIN_DIALOG_MELEE_EXTENDED,
-	MAIN_DIALOG_TEAMS,
-	MAIN_DIALOG_OPTIONS,
-	MAIN_DIALOG_HELP,
-	MAIN_DIALOG_EXIT,
-};
+enum 
+  {
+    MAIN_DIALOG_BOX = 0,
+    MAIN_DIALOG_MELEE,
+    MAIN_DIALOG_MELEE_EXTENDED,
+    MAIN_DIALOG_TEAMS,
+    MAIN_DIALOG_OPTIONS,
+    MAIN_DIALOG_HELP,
+    MAIN_DIALOG_EXIT,
+  };
 
 extern DIALOG mainDialog[];
 
@@ -184,67 +209,68 @@
 extern DIALOG select_game_dialog[];
 
 // MELEE_EX - dialog objects
-enum {
-	MELEE_EX_DIALOG_BOX = 0,
-	MELEE_EX_DIALOG_PLAY_GAME,
-	MELEE_EX_DIALOG_PLAY_NET1SERVER,
-	MELEE_EX_DIALOG_PLAY_NET1CLIENT,
-	MELEE_EX_DIALOG_KEYTESTER,
-	MELEE_EX_DIALOG_SHIPINFO,
-	MELEE_EX_DIALOG_LICENSE,
-	MELEE_EX_DIALOG_DIAGNOSTICS,
-	MELEE_EX_DIALOG_EXIT
+enum 
+  {
+    MELEE_EX_DIALOG_BOX = 0,
+    MELEE_EX_DIALOG_PLAY_GAME,
+    MELEE_EX_DIALOG_PLAY_NET1SERVER,
+    MELEE_EX_DIALOG_PLAY_NET1CLIENT,
+    MELEE_EX_DIALOG_KEYTESTER,
+    MELEE_EX_DIALOG_SHIPINFO,
+    MELEE_EX_DIALOG_LICENSE,
+    MELEE_EX_DIALOG_DIAGNOSTICS,
+    MELEE_EX_DIALOG_EXIT
 };
 extern DIALOG melee_ex_dialog[];
 
 // TEAMS - dialog objects
 enum {
-	TEAMS_DIALOG_BOX = 0,
-	TEAMS_DIALOG_TITLE,
-	TEAMS_DIALOG_PLAYERLIST_TEXT,
-	TEAMS_DIALOG_PLAYERLIST,
-	TEAMS_DIALOG_CONTROLLIST,
-	TEAMS_DIALOG_SELECTCONTROL,
-	TEAMS_DIALOG_TEAM_NUM,
-	TEAMS_DIALOG_CONFIG_NUM,
-	TEAMS_DIALOG_SETUP,
-	TEAMS_DIALOG_FLEET,
-	TEAMS_DIALOG_MAINMENU
+  TEAMS_DIALOG_BOX = 0,
+  TEAMS_DIALOG_TITLE,
+  TEAMS_DIALOG_PLAYERLIST_TEXT,
+  TEAMS_DIALOG_PLAYERLIST,
+  TEAMS_DIALOG_CONTROLLIST,
+  TEAMS_DIALOG_SELECTCONTROL,
+  TEAMS_DIALOG_TEAM_NUM,
+  TEAMS_DIALOG_CONFIG_NUM,
+  TEAMS_DIALOG_SETUP,
+  TEAMS_DIALOG_FLEET,
+  TEAMS_DIALOG_MAINMENU
 };
 
 extern DIALOG teamsDialog[];
 
 // FLEET - dialog objects
 enum {
-    FLEET_DIALOG_AVAILABLE_SHIPS_TEXT=0,
-    FLEET_DIALOG_SHIP_CATAGORIES_TEXT,
-    FLEET_DIALOG_TW_OFFICIAL_TOGGLE,
-    FLEET_DIALOG_TW_EXP_TOGGLE,
-    FLEET_DIALOG_TW_SPECIAL_TOGGLE,
-    FLEET_DIALOG_SORTBY_TEXT1,
-    FLEET_DIALOG_SORTBY_BUTTON1,
-    FLEET_DIALOG_SORTBY_ASCENDING1,
-    FLEET_DIALOG_AVAILABLE_SHIPS_LIST,
-    FLEET_DIALOG_FLEET_SHIPS_LIST,
-    FLEET_DIALOG_PLAYER_FLEET_BUTTON,
-    FLEET_DIALOG_PLAYER_FLEET_TITLE,
-    FLEET_DIALOG_SAVE_BUTTON,
-    FLEET_DIALOG_LOAD_BUTTON,
-    FLEET_DIALOG_POINT_LIMIT_TEXT,
-    FLEET_DIALOG_POINT_LIMIT_BUTTON,
-    FLEET_DIALOG_CURRENT_POINTS_TEXT,
-    FLEET_DIALOG_CURRENT_POINTS_VALUE,
-    FLEET_DIALOG_SORTBY_TEXT2,
-    FLEET_DIALOG_SORTBY_BUTTON2,
-    FLEET_DIALOG_SORTBY_ASCENDING2,
-    FLEET_DIALOG_ADD_BUTTON,
-    FLEET_DIALOG_ADD_ALL_BUTTON,
-    FLEET_DIALOG_CLEAR,
-    FLEET_DIALOG_CLEARALL,
-    FLEET_DIALOG_SHIP_PICTURE_BITMAP,
-    FLEET_DIALOG_SHIP_SUMMARY_TEXT,
-    FLEET_DIALOG_BACK_BUTTON,
-    FLEET_DIALOG_HELP_TEXT/**/
+  FLEET_DIALOG_AVAILABLE_SHIPS_TEXT=0,
+  FLEET_DIALOG_SHIP_CATAGORIES_TEXT,
+  FLEET_DIALOG_TW_OFFICIAL_TOGGLE,
+  FLEET_DIALOG_TW_EXP_TOGGLE,
+  FLEET_DIALOG_TW_SPECIAL_TOGGLE,
+  FLEET_DIALOG_SORTBY_TEXT1,
+  FLEET_DIALOG_SORTBY_BUTTON1,
+  FLEET_DIALOG_SORTBY_ASCENDING1,
+  FLEET_DIALOG_AVAILABLE_SHIPS_LIST,
+  FLEET_DIALOG_FLEET_SHIPS_LIST,
+  FLEET_DIALOG_PLAYER_FLEET_BUTTON,
+  FLEET_DIALOG_PLAYER_FLEET_TITLE,
+  FLEET_DIALOG_SAVE_BUTTON,
+  FLEET_DIALOG_LOAD_BUTTON,
+  FLEET_DIALOG_POINT_LIMIT_TEXT,
+  FLEET_DIALOG_POINT_LIMIT_BUTTON,
+  FLEET_DIALOG_CURRENT_POINTS_TEXT,
+  FLEET_DIALOG_CURRENT_POINTS_VALUE,
+  FLEET_DIALOG_SORTBY_TEXT2,
+  FLEET_DIALOG_SORTBY_BUTTON2,
+  FLEET_DIALOG_SORTBY_ASCENDING2,
+  FLEET_DIALOG_ADD_BUTTON,
+  FLEET_DIALOG_ADD_ALL_BUTTON,
+  FLEET_DIALOG_CLEAR,
+  FLEET_DIALOG_CLEARALL,
+  FLEET_DIALOG_SHIP_PICTURE_BITMAP,
+  FLEET_DIALOG_SHIP_SUMMARY_TEXT,
+  FLEET_DIALOG_BACK_BUTTON,
+  FLEET_DIALOG_HELP_TEXT/**/
 };
 
 extern DIALOG fleetDialog[];

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-02-13 18:24:22 UTC (rev 113)
+++ trunk/source/scp.cpp	2005-02-13 22:23:45 UTC (rev 114)
@@ -1,17 +1,17 @@
 /*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
 */
 
 #include <stdlib.h>
@@ -126,28 +126,20 @@
   return tw_version_string;
 }
 
-//deprecated.  This mode of using dat files is terrible, I can't believe
-//this technique was ever created.
-#define SCPGUI_TITLE   0
-
-FILE *debug_file;
-
-/*! \brief Blits GUI background bitmap on to a video window */
+/// Blits GUI background bitmap on to a video window
 void showTitle(VideoWindow *window = &videosystem->window);
 
-/*! \brief MELEE_EX dialog - selects alternate games as opposed to standard melee. 
-  From here you can access diagnostics (DIAGNOSTICS dialog) and ship info. 
-  (SHIPVIEW dialog) You can also test key jamming from this dialog.
-*/
+/// MELEE_EX dialog - selects alternate games as opposed to standard melee. 
+///
+///  From here you can access diagnostics (DIAGNOSTICS dialog) and ship info. 
+///  (SHIPVIEW dialog) You can also test key jamming from this dialog.
 void extended_menu(int i = -1);
 
-/*! \brief TEAMS dialog - from here you can select controllers for each player, and access their respective fleets. (FLEET dialog)
- */
+/// TEAMS dialog - from here you can select controllers for each player, and access their respective fleets. (FLEET dialog)
 void change_teams();
 
-/*! \brief FLEET dialog - manages fleet compositions for an individual player.
-  \param player Player index indicating which player's fleet to edit.
- */
+/// FLEET dialog - manages fleet compositions for an individual player.
+///  \param player Player index indicating which player's fleet to edit.
 void edit_fleet(int player);
 
 /*! \brief SHIPVIEW dialog - displays statistics and text information (if available) about the currently installed ships.
@@ -237,7 +229,7 @@
 std::string titleMusic = "";
 
 /** 
-  loads up the title screen and music, and starts playing the background menu music. 
+    loads up the title screen and music, and starts playing the background menu music. 
 */
 void prepareTitleScreenAssets() 
 {
@@ -278,18 +270,18 @@
 }
 
 enum {
-	DIALOG_CONNECT_BOX = 0,
-	DIALOG_CONNECT_TITLE,
-	DIALOG_CONNECT_ADDRESS,
-	DIALOG_CONNECT_ADDRESS_BOX,
-	DIALOG_CONNECT_ADDRESS_EDIT,
-	DIALOG_CONNECT_PORT,
-	DIALOG_CONNECT_PORT_BOX,
-	DIALOG_CONNECT_PORT_EDIT,
-//	DIALOG_CONNECT_TWOLOCALS,
-	DIALOG_CONNECT_OK,
-	DIALOG_CONNECT_CANCEL,
-	DIALOG_CONNECT_BLAH
+  DIALOG_CONNECT_BOX = 0,
+  DIALOG_CONNECT_TITLE,
+  DIALOG_CONNECT_ADDRESS,
+  DIALOG_CONNECT_ADDRESS_BOX,
+  DIALOG_CONNECT_ADDRESS_EDIT,
+  DIALOG_CONNECT_PORT,
+  DIALOG_CONNECT_PORT_BOX,
+  DIALOG_CONNECT_PORT_EDIT,
+  //	DIALOG_CONNECT_TWOLOCALS,
+  DIALOG_CONNECT_OK,
+  DIALOG_CONNECT_CANCEL,
+  DIALOG_CONNECT_BLAH
 };
 
 static DIALOG connect_dialog[] = {
@@ -302,7 +294,7 @@
   { d_text_proc,       50,   220,  460,  30,   255,  0,    0,    0,       0,    0,    (void *)"Port #" , NULL, NULL },
   { d_box_proc,        48,   248,  464,  34,   255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
   { d_edit_proc,       50,   250,  460,  30,   255,  0,    0,    0,       75,   0,    dialog_string[1], NULL, NULL },
-//{ d_check_proc,      50,   290,  160,  20,   255,  0,    0,    0,       0,    0,    (void *)"Two Local Players", NULL, NULL },
+  //{ d_check_proc,      50,   290,  160,  20,   255,  0,    0,    0,       0,    0,    (void *)"Two Local Players", NULL, NULL },
   { d_button_proc,     50,   320,  160,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Connect", NULL, NULL },
   { d_button_proc,     350,  320,  160,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Abort", NULL, NULL },
   { d_tw_yield_proc,   0,    0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
@@ -310,19 +302,19 @@
 };
 
 int connect_menu(VideoWindow *window, char **address, int *port) { STACKTRACE
-	int i = 0;
+								     int i = 0;
 
-	if (*address)
-		strncpy(dialog_string[0], *address, 70);
-	if (port)
-		sprintf(dialog_string[1], "%d", *port);
+ if (*address)
+   strncpy(dialog_string[0], *address, 70);
+ if (port)
+   sprintf(dialog_string[1], "%d", *port);
 
-	i = tw_popup_dialog(window, connect_dialog, DIALOG_CONNECT_ADDRESS_EDIT);
-	if (i != DIALOG_CONNECT_OK)
-		return -1;
-	*port = atoi(dialog_string[1]);
-	*address = strdup(dialog_string[0]);
-	return 0;
+ i = tw_popup_dialog(window, connect_dialog, DIALOG_CONNECT_ADDRESS_EDIT);
+ if (i != DIALOG_CONNECT_OK)
+   return -1;
+ *port = atoi(dialog_string[1]);
+ *address = strdup(dialog_string[0]);
+ return 0;
 }
 
 //#define DIALOG_LISTEN_TWOLOCALS 4
@@ -330,31 +322,34 @@
 #define DIALOG_LISTEN_CANCEL    5
 
 static DIALOG listen_dialog[] =
-{
-  // (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)     (d1)  (d2)  (dp)
-  { d_box_proc,        120,  100,  300,  140,  255,  0,    0,    0,          0,    0,    NULL, NULL, NULL },
-  { d_text_proc,       140,  110,  240,  25,   255,  0,    0,    0,          0,    0,    (void*)"Listen on which port?", NULL, NULL },
-  { d_box_proc,        178,  138,  124,  29,   255,  0,    0,    0,          0,    0,    NULL, NULL, NULL },
-  { d_edit_proc,       180,  140,  120,  25,   255,  0,    0,    0,          5,    0,    dialog_string[1], NULL, NULL },
-//{ d_check_proc,      140,  170,  160,  20,   255,  0,    0,    0,          0,    0,    (void *)"Two Local Players", NULL, NULL },
-  { d_button_proc,     140,  200,  120,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void*) "OK", NULL, NULL },
-  { d_button_proc,     280,  200,  120,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void*) "Cancel", NULL, NULL },
-  { d_tw_yield_proc,   0,    0,    0,    0,    255,  0,    0,    0,          0,    0,    NULL, NULL, NULL },
-  { NULL,              0,    0,    0,    0,    255,  0,    0,    0,          0,    0,    NULL, NULL, NULL }
-};
+  {
+    // (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)     (d1)  (d2)  (dp)
+    { d_box_proc,        120,  100,  300,  140,  255,  0,    0,    0,          0,    0,    NULL, NULL, NULL },
+    { d_text_proc,       140,  110,  240,  25,   255,  0,    0,    0,          0,    0,    (void*)"Listen on which port?", NULL, NULL },
+    { d_box_proc,        178,  138,  124,  29,   255,  0,    0,    0,          0,    0,    NULL, NULL, NULL },
+    { d_edit_proc,       180,  140,  120,  25,   255,  0,    0,    0,          5,    0,    dialog_string[1], NULL, NULL },
+    { d_button_proc,     140,  200,  120,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void*) "OK", NULL, NULL },
+    { d_button_proc,     280,  200,  120,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void*) "Cancel", NULL, NULL },
+    { d_tw_yield_proc,   0,    0,    0,    0,    255,  0,    0,    0,          0,    0,    NULL, NULL, NULL },
+    { NULL,              0,    0,    0,    0,    255,  0,    0,    0,          0,    0,    NULL, NULL, NULL }
+  };
 
-static int listen_menu(VideoWindow *window, int port) { STACKTRACE
-	dialog_string[1][0] = '\0';
-	int p = -1;
-	sprintf(dialog_string[1], "%d", port);
-	while ((p <= 0) || (p > 65535)) {
-		if (tw_popup_dialog(window, listen_dialog, 2) != DIALOG_LISTEN_OK) {
-			//game->quit("Quit - game aborted from network \"listen\" menu");
-			return -1;
-		}
-		p = atoi(dialog_string[1]);
+static int listen_menu(VideoWindow *window, int port) 
+{
+  STACKTRACE
+    dialog_string[1][0] = '\0';
+  int p = -1;
+  sprintf(dialog_string[1], "%d", port);
+  while ((p <= 0) || (p > 65535)) 
+    {
+      if (tw_popup_dialog(window, listen_dialog, 2) != DIALOG_LISTEN_OK) 
+	{
+	  //game->quit("Quit - game aborted from network \"listen\" menu");
+	  return -1;
 	}
-	return p;
+      p = atoi(dialog_string[1]);
+    }
+  return p;
 }
 
 int is_escape_pressed() 
@@ -448,79 +443,85 @@
 }
 
 
-void play_net1client ( const char *_address, int _port ) {STACKTRACE
-	NetLog *log = new NetLog();
-	log->init();
-	log->type = Log::log_net1client;
-
-	log->set_all_directions(Log::direction_read);
-	log->set_direction(Game::channel_client , Log::direction_write | Log::direction_read | NetLog::direction_immediate);
-	log->set_direction(Game::channel_client + Game::_channel_buffered, Log::direction_write | Log::direction_read);
-	
-	set_config_file("client.ini");
-	char address[128];
-	int port, i;
-	while (!log->net.isConnected()) {
-		if (!_address) strncpy(address, get_config_string("Network", "Address", ""), 127);
-		else strncpy(address, _address, 127);
-		if (_port == -1) port = get_config_int("Network", "Port", 15515);
-		else port = _port;
-		char *addressaddress = address;
-		if (connect_menu(&videosystem->window, &addressaddress, &port) == -1) 
-			return;
-		set_config_string("Network", "Address", addressaddress);
-		message.out("...");
-		i = ((NetLog*)log)->net.connect(addressaddress, port, is_escape_pressed);
-		free(addressaddress);
-		if (i) {
-//						while (is_escape_pressed());
-			while (keypressed()) readkey();
-			tw_error("connection failed");
-		}
-	}
-
-	log->net.optimize4latency();
-	message.out("connection established");
-	
-	char *gname = detect_gametype(log);
-	log->reset();
-
-	play_game(gname, log);
-
-	free(gname);
-	return;
+void play_net1client ( const char *_address, int _port ) 
+{
+  STACKTRACE;
+  NetLog *log = new NetLog();
+  log->init();
+  log->type = Log::log_net1client;
+  
+  log->set_all_directions(Log::direction_read);
+  log->set_direction(Game::channel_client , Log::direction_write | Log::direction_read | NetLog::direction_immediate);
+  log->set_direction(Game::channel_client + Game::_channel_buffered, Log::direction_write | Log::direction_read);
+  
+  set_config_file("client.ini");
+  char address[128];
+  int port, i;
+  while (!log->net.isConnected()) {
+    if (!_address) strncpy(address, get_config_string("Network", "Address", ""), 127);
+    else strncpy(address, _address, 127);
+    if (_port == -1) port = get_config_int("Network", "Port", 15515);
+    else port = _port;
+    char *addressaddress = address;
+    if (connect_menu(&videosystem->window, &addressaddress, &port) == -1) 
+      return;
+    set_config_string("Network", "Address", addressaddress);
+    message.out("...");
+    i = ((NetLog*)log)->net.connect(addressaddress, port, is_escape_pressed);
+    free(addressaddress);
+    if (i) 
+      {
+	//						while (is_escape_pressed());
+	while (keypressed()) readkey();
+	tw_error("connection failed");
+      }
+  }
+  
+  log->net.optimize4latency();
+  message.out("connection established");
+  
+  char *gname = detect_gametype(log);
+  log->reset();
+  
+  play_game(gname, log);
+  
+  free(gname);
+  return;
 }
 
-void play_net1server(const char *_gametype_name, int _port) {STACKTRACE
-	NetLog *log = new NetLog();
-	log->init();
-
-	log->type = Log::log_net1server;
-	log->set_all_directions(Log::direction_write | Log::direction_read | NetLog::direction_immediate);
-	log->set_direction(Game::channel_client , Log::direction_read);
-	log->set_direction(Game::channel_client + Game::_channel_buffered, Log::direction_read);
-	log->set_direction(Game::channel_server + Game::_channel_buffered, Log::direction_write | Log::direction_read);
-	
-	set_config_file("client.ini");
-	int port;
-	while (!log->net.isConnected()) {
-		if (_port == -1) port = get_config_int("Network", "Port", 15515);
-		else port = _port;
-
-		port = listen_menu( &videosystem->window, port );
-		if (port == -1) return;
-
-		message.out("...");
-		log->net.listen(port, is_escape_pressed);
-		
-	}
-
-	log->net.optimize4latency();
-	message.out("connection established");
-	
-	play_game(_gametype_name, log);
-
-	return;
+void play_net1server(const char *_gametype_name, int _port) 
+{
+  STACKTRACE;
+  NetLog *log = new NetLog();
+  log->init();
+  
+  log->type = Log::log_net1server;
+  log->set_all_directions(Log::direction_write | Log::direction_read | NetLog::direction_immediate);
+  log->set_direction(Game::channel_client , Log::direction_read);
+  log->set_direction(Game::channel_client + Game::_channel_buffered, Log::direction_read);
+  log->set_direction(Game::channel_server + Game::_channel_buffered, Log::direction_write | Log::direction_read);
+  
+  set_config_file("client.ini");
+  int port;
+  while (!log->net.isConnected()) 
+    {
+      if (_port == -1) port = get_config_int("Network", "Port", 15515);
+      else port = _port;
+      
+      port = listen_menu( &videosystem->window, port );
+      if (port == -1) return;
+      
+      message.out("...");
+      log->net.listen(port, is_escape_pressed);
+      
+    }
+  
+  log->net.optimize4latency();
+  message.out("connection established");
+  
+  play_game(_gametype_name, log);
+  
+  return;
 }
 
 
@@ -538,14 +539,7 @@
 
 FONT *TW_font = NULL;
 
-// dialog results
-/*int mainRet = 0;
-int shipRet = 0;
-int keyRet = 0;
-int fleetRet = 0;
-int optionsRet= 0;*/
 
-
 char **player_type = NULL;
 int *player_config = NULL;
 int *player_team = NULL;
@@ -553,54 +547,55 @@
 Control *load_player(int i) 
 {
   STACKTRACE;
-	char tmp[32];
-	Control *r = NULL;
+  char tmp[32];
+  Control *r = NULL;
 
-	sprintf (tmp, "Config%d", player_config[i]);
-	r = getController(player_type[i], tmp, Game::channel_none);
-	if (r)
-	{
-		r->load("scp.ini", tmp);
-	}
-	return r;
+  sprintf (tmp, "Config%d", player_config[i]);
+  r = getController(player_type[i], tmp, Game::channel_none);
+  if (r)
+    {
+      r->load("scp.ini", tmp);
+    }
+  return r;
 }
 
 
 class MainMenu : public BaseClass 
 {
-	public:
-	virtual void _event(Event * e);
-	virtual void preinit();
-	virtual void deinit();
-	virtual void init(VideoWindow *parent);
-	virtual void doit();
-	virtual void enable();
-	virtual void disable();
-	int state;
-	VideoWindow *window;
+public:
+  virtual void _event(Event * e);
+  virtual void preinit();
+  virtual void deinit();
+  virtual void init(VideoWindow *parent);
+  virtual void doit();
+  virtual void enable();
+  virtual void disable();
+  int state;
+  VideoWindow *window;
 } mainmenu;
 
 void MainMenu::_event(Event *e) 
 {
   STACKTRACE;
-		   
-	if (e->type == Event::VIDEO) {
-		if (e->subtype == VideoEvent::REDRAW) if (state & 1) showTitle();
-	}
+  
+  if (e->type == Event::VIDEO) 
+    {
+      if (e->subtype == VideoEvent::REDRAW) if (state & 1) showTitle();
+    }
 }
 
 void MainMenu::enable() 
 {
   STACKTRACE;
 		   
-	if (!(state & 2)) window->add_callback(this);
-	state |= 3;
+  if (!(state & 2)) 
+    window->add_callback(this);
+  state |= 3;
 }
 
 void MainMenu::disable() 
 {
-  STACKTRACE;
-		   
+  STACKTRACE;	   
   state &=~ 1;
 }
 
@@ -614,12 +609,14 @@
 void MainMenu::init(VideoWindow *parent) 
 {
   STACKTRACE; 
-  if (window) window->init(parent);
-  else {
-		window = new VideoWindow();
-		window->preinit();
-		window->init(parent);
-	}
+  if (window) 
+    window->init(parent);
+  else 
+    {
+      window = new VideoWindow();
+      window->preinit();
+      window->init(parent);
+    }
 }
 
 void MainMenu::deinit() 
@@ -643,62 +640,66 @@
   char tmp[32];
   
   tw_set_config_file("scp.ini");
-  if (!player_type) {		
-    MAX_PLAYERS        = get_config_int("Limits", "MaxPlayers", 12);
-    MAX_CONFIGURATIONS = get_config_int("Limits", "MaxConfigurations", 4);
-    MAX_TEAMS          = get_config_int("Limits", "MaxTeams", 6);
-    player_type = new char*[MAX_PLAYERS];
-    player_config = new int[MAX_PLAYERS];
-    player_team   = new int[MAX_PLAYERS];
-  }
-  for (i = 0; i < MAX_PLAYERS; i += 1) {
-    sprintf(tmp, "Player%d", i+1);
-    player_type[i] = strdup(get_config_string(tmp, "Type", "Human"));
-    player_config[i] = get_config_int (tmp, "Config", i % MAX_CONFIGURATIONS);
-    player_team[i] = get_config_int (tmp, "Team", 0);
-  }
+  if (!player_type) 
+    {		
+      MAX_PLAYERS        = get_config_int("Limits", "MaxPlayers", 12);
+      MAX_CONFIGURATIONS = get_config_int("Limits", "MaxConfigurations", 4);
+      MAX_TEAMS          = get_config_int("Limits", "MaxTeams", 6);
+      player_type = new char*[MAX_PLAYERS];
+      player_config = new int[MAX_PLAYERS];
+      player_team   = new int[MAX_PLAYERS];
+    }
+  for (i = 0; i < MAX_PLAYERS; i += 1) 
+    {
+      sprintf(tmp, "Player%d", i+1);
+      player_type[i] = strdup(get_config_string(tmp, "Type", "Human"));
+      player_config[i] = get_config_int (tmp, "Config", i % MAX_CONFIGURATIONS);
+      player_team[i] = get_config_int (tmp, "Team", 0);
+    }
   
   prepareTitleScreenAssets();
   showTitle();
   enable();
   
   int mainRet;
-  do {
-    //mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
-    mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
-    switch (mainRet) {
-    case MAIN_DIALOG_MELEE:
-      disable();
-      play_game("Melee");
-      enable();
-      break;
-    case MAIN_DIALOG_MELEE_EXTENDED:
-      disable();
-      extended_menu();
-      enable();
-      break;
-    case MAIN_DIALOG_OPTIONS:
-      showTitle();
-      options_menu(NULL);
-      break;
-    case MAIN_DIALOG_HELP:
-      show_file(data_full_path("ingame.txt").c_str());
-      break;
-    case MAIN_DIALOG_TEAMS:
-      change_teams();
-      showTitle();
-      break;
-    }
-  } while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
+  do 
+    {
+      //mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
+      mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
+      switch (mainRet) {
+      case MAIN_DIALOG_MELEE:
+	disable();
+	play_game("Melee");
+	enable();
+	break;
+      case MAIN_DIALOG_MELEE_EXTENDED:
+	disable();
+	extended_menu();
+	enable();
+	break;
+      case MAIN_DIALOG_OPTIONS:
+	showTitle();
+	options_menu(NULL);
+	break;
+      case MAIN_DIALOG_HELP:
+	show_file(data_full_path("ingame.txt").c_str());
+	break;
+      case MAIN_DIALOG_TEAMS:
+	change_teams();
+	showTitle();
+	break;
+      }
+    } while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
   
 }
 
 int tw_main(int argc, char *argv[]);
 
-int main(int argc, char *argv[]) {
-	int r;
-	r = tw_main(argc, argv);
-	return r;
+int main(int argc, char *argv[]) 
+{
+  int r;
+  r = tw_main(argc, argv);
+  return r;
 }
 END_OF_MAIN();
 
@@ -714,23 +715,14 @@
 #endif
 
   if(argc==2&&!strcmp(argv[1],"-test"))
-      {
-	return RunTests();
-      }
+    {
+      return RunTests();
+    }
   
   int i;
   int auto_port = -1;
   const char *auto_play = NULL, *auto_param = NULL;
   
-#ifdef __BEOS__
-  // set cwd to path of exe 
-  // to allow running from icon 
-  char datapath[256];
-  for (i=strlen(argv[0]) ; argv[0][i]!='/' ; i--);
-  strncpy(datapath, argv[0], i);
-  chdir(datapath);
-#endif
-
   log_debug(NULL);
   time_t start_time = time(NULL);
   log_debug("Log started at %s\n", asctime(localtime(&start_time)));
@@ -742,211 +734,212 @@
   videosystem = &video;
   videosystem->preinit();
   
-  try {
-    init_time();
-    init_error();
+  try 
+    {
+      init_time();
+      init_error();
+      
+      set_window_title(APPLICATION_NAME);
+      tw_set_config_file("client.ini");
+      
     
-    set_window_title(APPLICATION_NAME);
-    tw_set_config_file("client.ini");
-    
-    
-    int screen_width = 640, screen_height = 480, screen_bpp = 32;
-    int fullscreen = 0;
-    
-    auto_unload = get_config_int("System", "AutoUnload", 0);
+      int screen_width = 640, screen_height = 480, screen_bpp = 32;
+      int fullscreen = 0;
+      
+      auto_unload = get_config_int("System", "AutoUnload", 0);
 		
-    const AGUP_THEME *theme = agup_theme_by_name(get_config_string("Video", "GuiTheme", "Photon"));
+      const AGUP_THEME *theme = agup_theme_by_name(get_config_string("Video", "GuiTheme", "Photon"));
+      
+      screen_bpp       = get_config_int("Video", "BitsPerPixel", 16);
+      screen_width     = get_config_int("Video", "ScreenWidth", 640);
+      screen_height    = get_config_int("Video", "ScreenHeight", 480);
+      fullscreen       = get_config_int("Video", "FullScreen", false);
+      
+      SpaceSprite::mip_bias = get_config_int ("View", "Mip_bias", 0);
+      SpaceSprite::mip_min = get_config_int ("View", "Mip_min", 0);
+      SpaceSprite::mip_max = get_config_int ("View", "Mip_max", 0);
+      
+      interpolate_frames = get_config_int("View", "InterpolateFrames", 0);
+      set_tw_aa_mode(get_config_int("Rendering", "AA_Mode", 0));
+      int gamma   = get_config_int("Video", "Gamma", 128);
+      set_gamma( gamma );
+      
+      int inputs = 7;
+      bool sound_enabled = true;
+      
+      // parse command-line arguments
+      for (i = 1; i < argc; i += 1) 
+	{
+	  if (!strcmp(argv[i], "-res") && (argc > i + 2)) 
+	    {
+	      log_debug("command-line argument -res\n");
+	      screen_width = atoi(argv[i+1]);
+	      screen_height = atoi(argv[i+2]);
+	      i += 2;
+	    }
+	  else if (!strcmp(argv[i], "-bpp") && (argc > i + 1)) 
+	    {
+	      log_debug("command-line argument -bpp\n");
+	      screen_bpp = atoi(argv[i+1]);
+	      i += 1;
+	    }
+	  else if (!strcmp(argv[i], "-fullscreen")) 
+	    {
+	      log_debug("command-line argument -fullscreen\n");
+	      fullscreen = true;
+	    }
+	  else if (!strcmp(argv[i], "-window")) 
+	    {
+	      log_debug("command-line argument -window\n");
+	      fullscreen = false;
+	    }
+	  else if(!strcmp(argv[i], "-nosound")) 
+	    {
+	      sound_enabled = false;
+	    }
+	  else if (!strcmp(argv[i], "-nokeyboard")) 
+	    {
+	      log_debug("command-line argument -nokeyboard\n");
+	      inputs &= ~1;
+	    }
+	  else if (!strcmp(argv[i], "-nomouse")) 
+	    {
+	      log_debug("command-line argument -nomouse\n");
+	      inputs &= ~2;
+	    }
+	  else if (!strcmp(argv[i], "-nojoystick")) 
+	    {
+	      log_debug("command-line argument -nojoystick\n");
+	      inputs &= ~4;
+	    }
+	  else if (!strcmp(argv[i], "-noidle")) 
+	    {
+	      log_debug("command-line argument -noidle\n");
+	      _no_idle = 1;
+	    }
+	  else if (strstr(argv[i], COMMAND_LINE_SERVER_LONG)) 
+	    {
+	      if (strlen(argv[i]) > strlen(COMMAND_LINE_SERVER_LONG)) 
+		{
+		  // users can use two formats for the address: an alphanumeric name, like
+		  // "localhost", or a dotted ip address, like a.b.c.d .  Further, users
+		  // can specify the port here as well, by adding a colon and the number to 
+		  // the end of the address.  
+		  const char * addressStart = strstr(argv[i], COMMAND_LINE_SERVER_LONG) + strlen(COMMAND_LINE_SERVER_LONG);
+		  const char * addressEnd = strstr(addressStart, ":");
+		  
+		  // user has added a colon, indicating the port.  The port starts at addressEnd
+		  // and goes to the end of argv[i]
+		  if (addressEnd && strlen(addressEnd) > 1) 
+		    { 
+		      // this is +1 to skip the ":"
+		      serverPort = atoi(addressEnd+1);
+		    }
+		  serverAddress.clear();
+		  serverAddress.append(addressStart, addressEnd-addressStart);
+		  
+		  log_debug("commandline specified server as : host=[%s], port=[%u]\n", serverAddress.c_str(), serverPort);
+		}
+	    }
+	  else if (strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG)) 
+	    {
+	      // this is the maximum number of computers that can connect to this program instance. 
+	      // Used in server mode only, no effect otherwise.
+	      if (strlen(argv[i]) > strlen(COMMAND_LINE_MAX_CLIENTS_LONG)) 
+		{
+		  const char * portStart = strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) + strlen(COMMAND_LINE_MAX_CLIENTS_LONG);
+		  if (strlen(portStart) > 1) 
+		    {
+		      serverMaxClients = atoi(portStart);
+		    }
+		  log_debug("commandline specified max clients as: serverMaxClients=[%u]\n", serverMaxClients);
+		}
+	    }
+	  else if (strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) && (argc > i + 0)) 
+	    {
+	      // this specifies the port this client will listen on.
+	      // Used in client mode only, no effect otherwise.
+	      if (strlen(argv[i]) > strlen(COMMAND_LINE_CLIENT_PORT_LONG)) 
+		{
+		  const char * clientportStart = strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) + strlen(COMMAND_LINE_CLIENT_PORT_LONG);
+		  if (strlen(clientportStart) > 1) 
+		    {
+		      clientPort = atoi(clientportStart);
+		    }
+		  log_debug("commandline specified client port as : port=[%u]\n", clientPort);
+		}
+	    }
+	  else if (!strcmp(argv[i], "-play") && (argc > i + 2)) 
+	    {
+	      log_debug("command-line argument -play\n");
+	      auto_play = argv[i+1];
+	      auto_param = argv[i+2];
+	      i += 2;
+	      if ((argc > i + 0) && (argv[i][0] != '-')) 
+		{
+		  auto_port = atoi(argv[i]);
+		  i += 1;
+		}
+	    }
+	  else 
+	    {
+	      log_debug("unrecognized command-line argument:");
+	      log_debug(argv[i]);
+	      log_debug("\n");
+	    }
+	}
     
-    screen_bpp       = get_config_int("Video", "BitsPerPixel", 16);
-    screen_width     = get_config_int("Video", "ScreenWidth", 640);
-    screen_height    = get_config_int("Video", "ScreenHeight", 480);
-    fullscreen       = get_config_int("Video", "FullScreen", false);
+      log_debug("command-line arguments parsed\n");
     
-    SpaceSprite::mip_bias = get_config_int ("View", "Mip_bias", 0);
-    SpaceSprite::mip_min = get_config_int ("View", "Mip_min", 0);
-    SpaceSprite::mip_max = get_config_int ("View", "Mip_max", 0);
+      srand(time(NULL));
+      set_color_conversion(COLORCONV_KEEP_TRANS);
     
-    interpolate_frames = get_config_int("View", "InterpolateFrames", 0);
-    set_tw_aa_mode(get_config_int("Rendering", "AA_Mode", 0));
-    int gamma   = get_config_int("Video", "Gamma", 128);
-    set_gamma( gamma );
+      videosystem->set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
+      register_bitmap_file_type("jpg", load_jpg, NULL);
     
-    int inputs = 7;
-    bool sound_enabled = true;
-    
-    // parse command-line arguments
-    for (i = 1; i < argc; i += 1) 
-      {
-	if (!strcmp(argv[i], "-res") && (argc > i + 2)) 
-	  {
-	    log_debug("command-line argument -res\n");
-	    screen_width = atoi(argv[i+1]);
-	    screen_height = atoi(argv[i+2]);
-	    i += 2;
-	  }
-	else if (!strcmp(argv[i], "-bpp") && (argc > i + 1)) 
-	  {
-	    log_debug("command-line argument -bpp\n");
-	    screen_bpp = atoi(argv[i+1]);
-	    i += 1;
-	  }
-	else if (!strcmp(argv[i], "-fullscreen")) 
-	  {
-	    log_debug("command-line argument -fullscreen\n");
-	    fullscreen = true;
-	  }
-	else if (!strcmp(argv[i], "-window")) 
-	  {
-	    log_debug("command-line argument -window\n");
-	    fullscreen = false;
-	  }
-	else if(!strcmp(argv[i], "-nosound")) 
-	  {
-	    sound_enabled = false;
-	  }
-	else if (!strcmp(argv[i], "-nokeyboard")) 
-	  {
-	    log_debug("command-line argument -nokeyboard\n");
-	    inputs &= ~1;
-	  }
-	else if (!strcmp(argv[i], "-nomouse")) 
-	  {
-	    log_debug("command-line argument -nomouse\n");
-	    inputs &= ~2;
-	  }
-	else if (!strcmp(argv[i], "-nojoystick")) 
-	  {
-	    log_debug("command-line argument -nojoystick\n");
-	    inputs &= ~4;
-	  }
-	else if (!strcmp(argv[i], "-noidle")) 
-	  {
-	    log_debug("command-line argument -noidle\n");
-	    _no_idle = 1;
-	  }
-	else if (strstr(argv[i], COMMAND_LINE_SERVER_LONG)) 
-	  {
-	    if (strlen(argv[i]) > strlen(COMMAND_LINE_SERVER_LONG)) 
-	      {
-		// users can use two formats for the address: an alphanumeric name, like
-		// "localhost", or a dotted ip address, like a.b.c.d .  Further, users
-		// can specify the port here as well, by adding a colon and the number to 
-		// the end of the address.  
-		const char * addressStart = strstr(argv[i], COMMAND_LINE_SERVER_LONG) + strlen(COMMAND_LINE_SERVER_LONG);
-		const char * addressEnd = strstr(addressStart, ":");
-		
-		// user has added a colon, indicating the port.  The port starts at addressEnd
-		// and goes to the end of argv[i]
-		if (addressEnd && strlen(addressEnd) > 1) 
-		  { 
-		    // this is +1 to skip the ":"
-		    serverPort = atoi(addressEnd+1);
-		  }
-		serverAddress.clear();
-		serverAddress.append(addressStart, addressEnd-addressStart);
-			
-		log_debug("commandline specified server as : host=[%s], port=[%u]\n", serverAddress.c_str(), serverPort);
-	      }
-	  }
-	else if (strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG)) 
-	  {
-	    // this is the maximum number of computers that can connect to this program instance. 
-	    // Used in server mode only, no effect otherwise.
-	    if (strlen(argv[i]) > strlen(COMMAND_LINE_MAX_CLIENTS_LONG)) 
-	      {
-		const char * portStart = strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) + strlen(COMMAND_LINE_MAX_CLIENTS_LONG);
-		if (strlen(portStart) > 1) 
-		  {
-		    serverMaxClients = atoi(portStart);
-		  }
-		log_debug("commandline specified max clients as: serverMaxClients=[%u]\n", serverMaxClients);
-	      }
-	  }
-	else if (strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) && (argc > i + 0)) 
-	  {
-	    // this specifies the port this client will listen on.
-	    // Used in client mode only, no effect otherwise.
-	    if (strlen(argv[i]) > strlen(COMMAND_LINE_CLIENT_PORT_LONG)) 
-	      {
-		const char * clientportStart = strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) + strlen(COMMAND_LINE_CLIENT_PORT_LONG);
-		if (strlen(clientportStart) > 1) 
-		  {
-		    clientPort = atoi(clientportStart);
-		  }
-		log_debug("commandline specified client port as : port=[%u]\n", clientPort);
-	      }
-	  }
-	else if (!strcmp(argv[i], "-play") && (argc > i + 2)) 
-	  {
-	    log_debug("command-line argument -play\n");
-	    auto_play = argv[i+1];
-	    auto_param = argv[i+2];
-	    i += 2;
-	    if ((argc > i + 0) && (argv[i][0] != '-')) 
-	      {
-		auto_port = atoi(argv[i]);
-		i += 1;
-	      }
-	  }
-	else 
-	  {
-	    log_debug("unrecognized command-line argument:");
-	    log_debug(argv[i]);
-	    log_debug("\n");
-	  }
-      }
-    
-    log_debug("command-line arguments parsed\n");
-    
-    srand(time(NULL));
-    set_color_conversion(COLORCONV_KEEP_TRANS);
-    
-    videosystem->set_resolution(screen_width, screen_height, screen_bpp, fullscreen);
-    register_bitmap_file_type("jpg", load_jpg, NULL);
-    
-    if(!theme)
+      if(!theme)
 	theme = agup_theme_by_name("Photon");
-    agup_init(theme);    
-    gui_shadow_box_proc = d_agup_shadow_box_proc;
-    gui_ctext_proc = d_agup_ctext_proc;
-    gui_button_proc = d_agup_button_proc;
-    gui_edit_proc = d_agup_edit_proc;
-    gui_list_proc = d_agup_list_proc;
-    gui_text_list_proc = d_agup_text_list_proc;
+      agup_init(theme);    
+      gui_shadow_box_proc = d_agup_shadow_box_proc;
+      gui_ctext_proc = d_agup_ctext_proc;
+      gui_button_proc = d_agup_button_proc;
+      gui_edit_proc = d_agup_edit_proc;
+      gui_list_proc = d_agup_list_proc;
+      gui_text_list_proc = d_agup_text_list_proc;
 
-    enable_input(inputs);
+      enable_input(inputs);
     
-    SoundSystem sound(sound_enabled);
-    tw_sound = &sound;
-    tw_sound->set_sound_volume(tw_sound->load_sound_volume());
-    tw_sound->set_music_volume(tw_sound->load_music_volume());
+      SoundSystem sound(sound_enabled);
+      tw_sound = &sound;
+      tw_sound->set_sound_volume(tw_sound->load_sound_volume());
+      tw_sound->set_music_volume(tw_sound->load_music_volume());
     
-    showLoadingScreen();
+      showLoadingScreen();
     
-    View *v = NULL;
-    v = get_view ( get_config_string("View", "View", NULL) , NULL );
-    if (!v) v = get_view ( "Hero", NULL );
-    set_view(v);
-    init_ships();
-    init_fleet();
+      View *v = NULL;
+      v = get_view ( get_config_string("View", "View", NULL) , NULL );
+      if (!v) v = get_view ( "Hero", NULL );
+      set_view(v);
+      init_ships();
+      init_fleet();
     
-    if (auto_play) {// FIX ME
-      if (!strcmp(auto_play, "game")) play_game(auto_param, NULL);
-    }
-    else {
-      mainmenu.preinit();
-      mainmenu.init(&videosystem->window);
-      mainmenu.doit();
-      mainmenu.deinit();
-    }
-
-    if(game)
-      {
-	delete game;
-	game = NULL;
+      if (auto_play) {// FIX ME
+	if (!strcmp(auto_play, "game")) play_game(auto_param, NULL);
       }
-    disable_input(); 
-  }
+      else {
+	mainmenu.preinit();
+	mainmenu.init(&videosystem->window);
+	mainmenu.doit();
+	mainmenu.deinit();
+      }
+
+      if(game)
+	{
+	  delete game;
+	  game = NULL;
+	}
+      disable_input(); 
+    }
   catch (int i) {
     if (i == -1) 
       throw;
@@ -974,7 +967,7 @@
     if (__error_flag & 1) throw;
     tw_error("Ack!!!\nAn error occured on startup!\nBut I don't know what error!");
     if (__error_flag & 1) throw;
-	}
+  }
   
   tw_exit(0);
   return 0;
@@ -1042,21 +1035,21 @@
   }
     break;
   case MELEE_EX_DIALOG_PLAY_NET1SERVER: {
-			const char *gname = select_game_menu();
-			if (gname) play_net1server(gname);
-		}
-		break;
-		case MELEE_EX_DIALOG_PLAY_NET1CLIENT: {
-			play_net1client();
-		}
-		break;
+    const char *gname = select_game_menu();
+    if (gname) play_net1server(gname);
+  }
+    break;
+  case MELEE_EX_DIALOG_PLAY_NET1CLIENT: {
+    play_net1client();
+  }
+    break;
   case MELEE_EX_DIALOG_DIAGNOSTICS: {
     show_diagnostics();
   }
     break;
   case MELEE_EX_DIALOG_LICENSE:
-  	  show_file(COPYING_FILE);
-  	  break;
+    show_file(COPYING_FILE);
+    break;
   case MELEE_EX_DIALOG_SHIPINFO:
     ship_view_dialog(0, reference_fleet);
     break;
@@ -1064,7 +1057,7 @@
     keyjamming_tester();
   }
     break;
-	}
+  }
   showTitle();
   return;
 }
@@ -1134,20 +1127,20 @@
 }
 
 /*
- *** TEAMS dialog section - end
- */
+*** TEAMS dialog section - end
+*/
 
 
 
 
 /*
- *** FLEET dialog section - begin
- */
+*** FLEET dialog section - begin
+*/
 
 
 char *numeric_string[] = {"Zero", "One", "Two", "Three", "Four", 
-		"Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", 
-		"Twelve"};
+			  "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", 
+			  "Twelve"};
 
 char fleetPlayer[18];
 char fleetTitleString[100];
@@ -1159,34 +1152,34 @@
 
 int d_check_proc_fleeteditor(int msg, DIALOG *d, int c)
 {
-	if (msg == MSG_CLICK)
-	{
+  if (msg == MSG_CLICK)
+    {
 		
-		/* track the mouse until it is released */
-		while (gui_mouse_b()) {
-//			state2 = ((gui_mouse_x() >= d->x) && (gui_mouse_y() >= d->y) &&
-//				(gui_mouse_x() < d->x + d->w) && (gui_mouse_y() < d->y + d->h));
+      /* track the mouse until it is released */
+      while (gui_mouse_b()) {
+	//			state2 = ((gui_mouse_x() >= d->x) && (gui_mouse_y() >= d->y) &&
+	//				(gui_mouse_x() < d->x + d->w) && (gui_mouse_y() < d->y + d->h));
 			
-			/* let other objects continue to animate */
-			broadcast_dialog_message(MSG_IDLE, 0);
-		}
+	/* let other objects continue to animate */
+	broadcast_dialog_message(MSG_IDLE, 0);
+      }
 		
-		/* should we close the dialog? */
-		// imo the following mucho better/ simplere than that messy stuff in the allegro routine
-		// ... check d_button_proc in guiproc.c in the allegro sources...
+      /* should we close the dialog? */
+      // imo the following mucho better/ simplere than that messy stuff in the allegro routine
+      // ... check d_button_proc in guiproc.c in the allegro sources...
 
-		if (d->flags & D_SELECTED)
-			d->flags &= ~D_SELECTED;
-		else
-			d->flags |= D_SELECTED;
+      if (d->flags & D_SELECTED)
+	d->flags &= ~D_SELECTED;
+      else
+	d->flags |= D_SELECTED;
 
-		if ( d->flags & D_EXIT)
-			return D_CLOSE;
+      if ( d->flags & D_EXIT)
+	return D_CLOSE;
 
-		return D_O_K; 
-	}
+      return D_O_K; 
+    }
 	
-	return d_agup_check_proc(msg, d, 0);
+  return d_agup_check_proc(msg, d, 0);
 }
 
 
@@ -1195,217 +1188,217 @@
 
 // FLEET - dialog function
 void edit_fleet(int player) {STACKTRACE
-	char tmp[40];
-	char path[80];
-    char fleetCostString[80] = "";
-    char maxFleetCostString[80] = "";
-    bool availableFleetDirty = true;
+			       char tmp[40];
+ char path[80];
+ char fleetCostString[80] = "";
+ char maxFleetCostString[80] = "";
+ bool availableFleetDirty = true;
 
-    static Fleet::SortingMethod sortMethod1 = (Fleet::SortingMethod) Fleet::SORTING_METHOD_DEFAULT,
-        sortMethod2 = (Fleet::SortingMethod) Fleet::SORTING_METHOD_DEFAULT;
-    static bool sortAscending1 = false,
-        sortAscending2 = false;
+ static Fleet::SortingMethod sortMethod1 = (Fleet::SortingMethod) Fleet::SORTING_METHOD_DEFAULT,
+   sortMethod2 = (Fleet::SortingMethod) Fleet::SORTING_METHOD_DEFAULT;
+ static bool sortAscending1 = false,
+   sortAscending2 = false;
 
 
-	sprintf (tmp, "Player%d", player+1);
-	Fleet* fleet = new Fleet();
-	fleet->load("fleets.ini", tmp);
+ sprintf (tmp, "Player%d", player+1);
+ Fleet* fleet = new Fleet();
+ fleet->load("fleets.ini", tmp);
 
-	if (player + 1 <= 12)
-		sprintf(fleetPlayer, "Player %s Fleet", numeric_string[player+1]);
-	else sprintf(fleetPlayer, "Player%d Fleet", player+1);
-	showTitle();
+ if (player + 1 <= 12)
+   sprintf(fleetPlayer, "Player %s Fleet", numeric_string[player+1]);
+ else sprintf(fleetPlayer, "Player%d Fleet", player+1);
+ showTitle();
 
-    int fleetRet;
-    int selectedSlot;
+ int fleetRet;
+ int selectedSlot;
 
-    fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].dp = fleetCostString;
-    fleetDialog[FLEET_DIALOG_POINT_LIMIT_BUTTON].dp = maxFleetCostString;
+ fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].dp = fleetCostString;
+ fleetDialog[FLEET_DIALOG_POINT_LIMIT_BUTTON].dp = maxFleetCostString;
     
-//	// the reference_fleet is used in the list in a hardcoded way, so over"load" it
-//    Fleet *old_reference_fleet = reference_fleet;
+ //	// the reference_fleet is used in the list in a hardcoded way, so over"load" it
+ //    Fleet *old_reference_fleet = reference_fleet;
 
-	do {
-		sprintf(title_str, fleet->getTitle());
-		sprintf(fleetTitleString, "%s\n%d points", fleet->getTitle(), fleet->getCost());
+ do {
+   sprintf(title_str, fleet->getTitle());
+   sprintf(fleetTitleString, "%s\n%d points", fleet->getTitle(), fleet->getCost());
         
-        fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].dp3 = fleet;
-        fleetDialog[FLEET_DIALOG_SORTBY_BUTTON1].dp = Fleet::getSortingMethodName(sortMethod1);
-        fleetDialog[FLEET_DIALOG_SORTBY_BUTTON2].dp = Fleet::getSortingMethodName(sortMethod2);
+   fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].dp3 = fleet;
+   fleetDialog[FLEET_DIALOG_SORTBY_BUTTON1].dp = Fleet::getSortingMethodName(sortMethod1);
+   fleetDialog[FLEET_DIALOG_SORTBY_BUTTON2].dp = Fleet::getSortingMethodName(sortMethod2);
 
-        sprintf(fleetCostString,"%d", fleet->getCost());
-        if (fleet->getCost() > fleet->getMaxCost())
-            fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].bg = makecol8(255,0,0);
-        else
-            fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].bg = 0;
+   sprintf(fleetCostString,"%d", fleet->getCost());
+   if (fleet->getCost() > fleet->getMaxCost())
+     fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].bg = makecol8(255,0,0);
+   else
+     fleetDialog[FLEET_DIALOG_CURRENT_POINTS_VALUE].bg = 0;
 
-        sprintf(maxFleetCostString,"%d %s", fleet->getMaxCost(), 
-                                            Fleet::getFleetCostName(fleet->getMaxCost()));
+   sprintf(maxFleetCostString,"%d %s", fleet->getMaxCost(), 
+	   Fleet::getFleetCostName(fleet->getMaxCost()));
 
-        if (sortAscending1)
-            fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"^";
-        else
-            fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"v";
+   if (sortAscending1)
+     fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"^";
+   else
+     fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"v";
         
-        if (sortAscending2)
-            fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"^";
-        else
-            fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"v";
+   if (sortAscending2)
+     fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"^";
+   else
+     fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"v";
 
-        //if the user has selected a different choice of available ships, regenerate the
-        //list of available ships
-        if (availableFleetDirty) {
-            availableFleetDirty = false;
+   //if the user has selected a different choice of available ships, regenerate the
+   //list of available ships
+   if (availableFleetDirty) {
+     availableFleetDirty = false;
             
-            //clear out the fleet
-            reference_fleet->reset();
+     //clear out the fleet
+     reference_fleet->reset();
 
-            for (int c=0; c<num_shiptypes; c++) {
-                switch (shiptypes[c].origin) { 
-                case SHIP_ORIGIN_TW:
-                    if (fleetDialog[FLEET_DIALOG_TW_OFFICIAL_TOGGLE].flags & D_SELECTED)
-                        reference_fleet->addShipType(&shiptypes[c]);
-                    break;
+     for (int c=0; c<num_shiptypes; c++) {
+       switch (shiptypes[c].origin) { 
+       case SHIP_ORIGIN_TW:
+	 if (fleetDialog[FLEET_DIALOG_TW_OFFICIAL_TOGGLE].flags & D_SELECTED)
+	   reference_fleet->addShipType(&shiptypes[c]);
+	 break;
                 
-                case SHIP_ORIGIN_UQM:
-                    if (fleetDialog[FLEET_DIALOG_TW_EXP_TOGGLE].flags & D_SELECTED)
-                        reference_fleet->addShipType(&shiptypes[c]);
-                    break;
+       case SHIP_ORIGIN_UQM:
+	 if (fleetDialog[FLEET_DIALOG_TW_EXP_TOGGLE].flags & D_SELECTED)
+	   reference_fleet->addShipType(&shiptypes[c]);
+	 break;
 
-                case SHIP_ORIGIN_TW_SPECIAL:
-                    if (fleetDialog[FLEET_DIALOG_TW_SPECIAL_TOGGLE].flags & D_SELECTED)
-                        reference_fleet->addShipType(&shiptypes[c]);
-                    break;
-                }
-            }
-            reference_fleet->Sort( sortMethod1, sortAscending1 );
-            fleetDialog[FLEET_DIALOG_AVAILABLE_SHIPS_LIST].flags |= D_DIRTY;
-        }/**/
+       case SHIP_ORIGIN_TW_SPECIAL:
+	 if (fleetDialog[FLEET_DIALOG_TW_SPECIAL_TOGGLE].flags & D_SELECTED)
+	   reference_fleet->addShipType(&shiptypes[c]);
+	 break;
+       }
+     }
+     reference_fleet->Sort( sortMethod1, sortAscending1 );
+     fleetDialog[FLEET_DIALOG_AVAILABLE_SHIPS_LIST].flags |= D_DIRTY;
+   }/**/
 
-		fleetRet = tw_do_dialog(NULL, fleetDialog, -1);
+   fleetRet = tw_do_dialog(NULL, fleetDialog, -1);
 
-        switch( fleetRet ) {
-           case FLEET_DIALOG_AVAILABLE_SHIPS_TEXT: break;
-           case FLEET_DIALOG_SHIP_CATAGORIES_TEXT: break;
+   switch( fleetRet ) {
+   case FLEET_DIALOG_AVAILABLE_SHIPS_TEXT: break;
+   case FLEET_DIALOG_SHIP_CATAGORIES_TEXT: break;
 
-           case FLEET_DIALOG_TW_OFFICIAL_TOGGLE:
-           case FLEET_DIALOG_TW_EXP_TOGGLE:
-           case FLEET_DIALOG_TW_SPECIAL_TOGGLE:
-               availableFleetDirty = true;
-			   break;
+   case FLEET_DIALOG_TW_OFFICIAL_TOGGLE:
+   case FLEET_DIALOG_TW_EXP_TOGGLE:
+   case FLEET_DIALOG_TW_SPECIAL_TOGGLE:
+     availableFleetDirty = true;
+     break;
 
-           case FLEET_DIALOG_SORTBY_TEXT1: break;
-           case FLEET_DIALOG_SORTBY_BUTTON1: 
-               sortMethod1 = Fleet::cycleSortingMethod(sortMethod1);
-               reference_fleet->Sort( sortMethod1, sortAscending1 );
-               fleetDialog[FLEET_DIALOG_SORTBY_BUTTON1].dp = Fleet::getSortingMethodName(sortMethod1);
-               break;
+   case FLEET_DIALOG_SORTBY_TEXT1: break;
+   case FLEET_DIALOG_SORTBY_BUTTON1: 
+     sortMethod1 = Fleet::cycleSortingMethod(sortMethod1);
+     reference_fleet->Sort( sortMethod1, sortAscending1 );
+     fleetDialog[FLEET_DIALOG_SORTBY_BUTTON1].dp = Fleet::getSortingMethodName(sortMethod1);
+     break;
 
-           case FLEET_DIALOG_SORTBY_ASCENDING1: 
-               sortAscending1 = 1 - sortAscending1;
-               reference_fleet->Sort( sortMethod1, sortAscending1 );
-               if (sortAscending1)
-                   fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"^";
-               else
-                   fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"v";
-               break;
+   case FLEET_DIALOG_SORTBY_ASCENDING1: 
+     sortAscending1 = 1 - sortAscending1;
+     reference_fleet->Sort( sortMethod1, sortAscending1 );
+     if (sortAscending1)
+       fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"^";
+     else
+       fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"v";
+     break;
 
            
            
 
-           case FLEET_DIALOG_AVAILABLE_SHIPS_LIST:
-           case FLEET_DIALOG_ADD_BUTTON: 
-			   int k;
-			   k = fleetDialog[FLEET_DIALOG_AVAILABLE_SHIPS_LIST].d1;
-			   if (k < 0 || k >= reference_fleet->getSize()) {tw_error("invalid ship choice - bug");}
+   case FLEET_DIALOG_AVAILABLE_SHIPS_LIST:
+   case FLEET_DIALOG_ADD_BUTTON: 
+     int k;
+     k = fleetDialog[FLEET_DIALOG_AVAILABLE_SHIPS_LIST].d1;
+     if (k < 0 || k >= reference_fleet->getSize()) {tw_error("invalid ship choice - bug");}
 
-               selectedSlot = fleet->addShipType(reference_fleet->getShipType(k));
-               if (selectedSlot != -1)
-                   fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1 = selectedSlot;
+     selectedSlot = fleet->addShipType(reference_fleet->getShipType(k));
+     if (selectedSlot != -1)
+       fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1 = selectedSlot;
                
-               break;
+     break;
 
-           case FLEET_DIALOG_PLAYER_FLEET_BUTTON: break;
+   case FLEET_DIALOG_PLAYER_FLEET_BUTTON: break;
 
-           case FLEET_DIALOG_PLAYER_FLEET_TITLE:               
-               if(do_dialog(fleet_titleDialog, FLEET_TITLE_DIALOG_BOX) == FLEET_TITLE_DIALOG_OK)
-                   sprintf(fleet->getTitle(), title_str);
-               showTitle();
-               break;
+   case FLEET_DIALOG_PLAYER_FLEET_TITLE:               
+     if(do_dialog(fleet_titleDialog, FLEET_TITLE_DIALOG_BOX) == FLEET_TITLE_DIALOG_OK)
+       sprintf(fleet->getTitle(), title_str);
+     showTitle();
+     break;
 
-           case FLEET_DIALOG_SAVE_BUTTON: 
-               sprintf(path, "fleets/");
-               if(file_select("Save Fleet", path, "scf")) fleet->save(path, "Fleet");
-               showTitle();
-               break;
+   case FLEET_DIALOG_SAVE_BUTTON: 
+     sprintf(path, "fleets/");
+     if(file_select("Save Fleet", path, "scf")) fleet->save(path, "Fleet");
+     showTitle();
+     break;
 
-           case FLEET_DIALOG_LOAD_BUTTON: 
-               sprintf(path, "fleets/");
-               if(file_select("Load Fleet", path, "scf")) fleet->load(path, "Fleet");
-               sprintf(title_str, fleet->getTitle());
-               sprintf(fleetTitleString, "%s\n%d points", fleet->getTitle(), fleet->getCost());
-               showTitle();
-               break;
+   case FLEET_DIALOG_LOAD_BUTTON: 
+     sprintf(path, "fleets/");
+     if(file_select("Load Fleet", path, "scf")) fleet->load(path, "Fleet");
+     sprintf(title_str, fleet->getTitle());
+     sprintf(fleetTitleString, "%s\n%d points", fleet->getTitle(), fleet->getCost());
+     showTitle();
+     break;
 
-           case FLEET_DIALOG_POINT_LIMIT_TEXT: break;
+   case FLEET_DIALOG_POINT_LIMIT_TEXT: break;
 
-           case FLEET_DIALOG_POINT_LIMIT_BUTTON:
-               fleet->cycleMaxFleetCost();
-               break;
+   case FLEET_DIALOG_POINT_LIMIT_BUTTON:
+     fleet->cycleMaxFleetCost();
+     break;
 
-           case FLEET_DIALOG_CURRENT_POINTS_TEXT: break;
-           case FLEET_DIALOG_CURRENT_POINTS_VALUE: break;
-           case FLEET_DIALOG_SORTBY_TEXT2: break;
+   case FLEET_DIALOG_CURRENT_POINTS_TEXT: break;
+   case FLEET_DIALOG_CURRENT_POINTS_VALUE: break;
+   case FLEET_DIALOG_SORTBY_TEXT2: break;
 
-           case FLEET_DIALOG_SORTBY_BUTTON2: 
-               sortMethod2 = Fleet::cycleSortingMethod(sortMethod2);
-               fleet->Sort( sortMethod2, sortAscending2 );
-               fleetDialog[FLEET_DIALOG_SORTBY_BUTTON2].dp = Fleet::getSortingMethodName(sortMethod2);
-               break;
+   case FLEET_DIALOG_SORTBY_BUTTON2: 
+     sortMethod2 = Fleet::cycleSortingMethod(sortMethod2);
+     fleet->Sort( sortMethod2, sortAscending2 );
+     fleetDialog[FLEET_DIALOG_SORTBY_BUTTON2].dp = Fleet::getSortingMethodName(sortMethod2);
+     break;
 
-           case FLEET_DIALOG_SORTBY_ASCENDING2: 
-               sortAscending2 = 1 - sortAscending2;
-               fleet->Sort( sortMethod2, sortAscending2 );
-               if (sortAscending2)
-                   fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"^";
-               else
-                   fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"v";
-               break;
+   case FLEET_DIALOG_SORTBY_ASCENDING2: 
+     sortAscending2 = 1 - sortAscending2;
+     fleet->Sort( sortMethod2, sortAscending2 );
+     if (sortAscending2)
+       fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"^";
+     else
+       fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING2].dp = (void *)"v";
+     break;
 
-           case FLEET_DIALOG_ADD_ALL_BUTTON: 
-               fleet->addFleet(reference_fleet);
-               break;
+   case FLEET_DIALOG_ADD_ALL_BUTTON: 
+     fleet->addFleet(reference_fleet);
+     break;
 
-	       case FLEET_DIALOG_CLEAR: 
-           case FLEET_DIALOG_FLEET_SHIPS_LIST: 
-			fleet->clear_slot(fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1);
-            if (fleet->getSize() <= 0)
-                fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1 = 0;
-               break;
+   case FLEET_DIALOG_CLEAR: 
+   case FLEET_DIALOG_FLEET_SHIPS_LIST: 
+     fleet->clear_slot(fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1);
+     if (fleet->getSize() <= 0)
+       fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1 = 0;
+     break;
 
-           case FLEET_DIALOG_CLEARALL: 
-               fleet->reset();
-               fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1 = 0;
-               break;
+   case FLEET_DIALOG_CLEARALL: 
+     fleet->reset();
+     fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1 = 0;
+     break;
 
-           case FLEET_DIALOG_SHIP_PICTURE_BITMAP: break;
+   case FLEET_DIALOG_SHIP_PICTURE_BITMAP: break;
            
-           case FLEET_DIALOG_SHIP_SUMMARY_TEXT: break;
-           case FLEET_DIALOG_BACK_BUTTON: break;
-           case FLEET_DIALOG_HELP_TEXT:/**/
-           default:
-               ;
-        }
-		/*if (fleetRet == FLEET_DIALOG_INFO) {
-			ship_view_dialog(fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1, reference_fleet);
-			showTitle();
-		}*/
+   case FLEET_DIALOG_SHIP_SUMMARY_TEXT: break;
+   case FLEET_DIALOG_BACK_BUTTON: break;
+   case FLEET_DIALOG_HELP_TEXT:/**/
+   default:
+     ;
+   }
+   /*if (fleetRet == FLEET_DIALOG_INFO) {
+     ship_view_dialog(fleetDialog[FLEET_DIALOG_FLEET_SHIPS_LIST].d1, reference_fleet);
+     showTitle();
+     }*/
 
-	} while((fleetRet != FLEET_DIALOG_BACK_BUTTON) && (fleetRet != -1));
+ } while((fleetRet != FLEET_DIALOG_BACK_BUTTON) && (fleetRet != -1));
 
-	fleet->save("fleets.ini", tmp);
-	delete fleet;
-	showTitle();
+ fleet->save("fleets.ini", tmp);
+ delete fleet;
+ showTitle();
 }
 
 
@@ -1531,20 +1524,20 @@
 }
 
 int scp_fleet_dialog_bitmap_proc(int msg, DIALOG* d, int c) {
-	//TODO address this: bitmap has to be deleted, but MSG_END does not mean the dialog isn't coming back
-    /*if (msg == MSG_END && d->dp) {
-		destroy_bitmap( (BITMAP*)d->dp );
-		d->dp = NULL;
-	}*/
+  //TODO address this: bitmap has to be deleted, but MSG_END does not mean the dialog isn't coming back
+  /*if (msg == MSG_END && d->dp) {
+    destroy_bitmap( (BITMAP*)d->dp );
+    d->dp = NULL;
+    }*/
 
-	if ((msg != MSG_DRAW || d->dp) && (safeToDrawPreview) )
-		return d_bitmap_proc(msg, d, c);
-	return D_O_K;
+  if ((msg != MSG_DRAW || d->dp) && (safeToDrawPreview) )
+    return d_bitmap_proc(msg, d, c);
+  return D_O_K;
 }
 
 /*
- *** FLEET dialog section - end
- */
+*** FLEET dialog section - end
+*/
 
 
 
@@ -1556,8 +1549,8 @@
 
 
 /*
- *** SHIPVIEW dialog section - begin
- */
+*** SHIPVIEW dialog section - begin
+*/
 void ship_view_dialog(int si, Fleet *fleet) 
 {
   int i;
@@ -1654,46 +1647,46 @@
 	      c += sprintf(c, "Name: %s\n", type->name);
 	      c += sprintf(c, "ID: %s\n", type->id);
 	      c += sprintf(c, "Cost: %d\n", type->cost);
-				c += sprintf(c, "\n\n\n\nINI file: (%s)\n", type->file);
-				c += sprintf(c, "-------------------------\n%s", inifile);
+	      c += sprintf(c, "\n\n\n\nINI file: (%s)\n", type->file);
+	      c += sprintf(c, "-------------------------\n%s", inifile);
 				
-				if (shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp &&
-					strlen((char*)(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp))>0 )
-				{
-					free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
-					shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = (char*)"";
-				}
-				shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = description;
-				
-				if (strlen(inifile) >0)
-					free(inifile);
-			}
-			shipviewDialog[SHIPVIEW_DIALOG_PICTURES+0].dp = sprite;
+	      if (shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp &&
+		  strlen((char*)(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp))>0 )
+		{
+		  free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
+		  shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = (char*)"";
 		}
+	      shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = description;
+				
+	      if (strlen(inifile) >0)
+		free(inifile);
+	    }
+	  shipviewDialog[SHIPVIEW_DIALOG_PICTURES+0].dp = sprite;
+	}
 
-		// change font size - begin
-		if (r == SHIPVIEW_DIALOG_FONT) {
-			i = shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1;
-			i = (((i/2) + 2) % 3) - 1;
-			shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1 = i*2;
-		}
-		// change font size - end
+      // change font size - begin
+      if (r == SHIPVIEW_DIALOG_FONT) {
+	i = shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1;
+	i = (((i/2) + 2) % 3) - 1;
+	shipviewDialog[SHIPVIEW_DIALOG_TWYIELD+1].d1 = i*2;
+      }
+      // change font size - end
 
-		r = tw_do_dialog(NULL, shipviewDialog, SHIPVIEW_DIALOG_LIST);
-	}
-	// main dialog loop - end
+      r = tw_do_dialog(NULL, shipviewDialog, SHIPVIEW_DIALOG_LIST);
+    }
+  // main dialog loop - end
 
-	if (sprite)
-		destroy_bitmap(sprite);
-	if (shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp &&
-		strlen((char*)(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp))>0 )
-	{
-		shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = NULL;
-		free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
-	}
+  if (sprite)
+    destroy_bitmap(sprite);
+  if (shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp &&
+      strlen((char*)(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp))>0 )
+    {
+      shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp = NULL;
+      free(shipviewDialog[SHIPVIEW_DIALOG_DESCRIPTION].dp);
+    }
 	
-	videosystem->redraw();
-	return;
+  videosystem->redraw();
+  return;
 }
 
 /*
@@ -1702,30 +1695,30 @@
 
 
 int get_diagnostics_string ( char *dest ) {//returns length of string
-	char * tmp = dest;
+  char * tmp = dest;
 
 #	if defined _DEBUG
-		tmp += sprintf(tmp, "DEBUGGING BUILD!\n");
+  tmp += sprintf(tmp, "DEBUGGING BUILD!\n");
 #	endif
-	tmp += sprintf(tmp, "ALLEGRO (.h) version   = Allegro %s, %s\n", 
-		ALLEGRO_VERSION_STR, ALLEGRO_PLATFORM_STR);
-	tmp += sprintf(tmp, "ALLEGRO (.dll) version = %s\n", allegro_id);
-	tmp += sprintf(tmp, "Compiler = ");
+  tmp += sprintf(tmp, "ALLEGRO (.h) version   = Allegro %s, %s\n", 
+		 ALLEGRO_VERSION_STR, ALLEGRO_PLATFORM_STR);
+  tmp += sprintf(tmp, "ALLEGRO (.dll) version = %s\n", allegro_id);
+  tmp += sprintf(tmp, "Compiler = ");
 #	if defined __MINGW32__
-		tmp += sprintf(tmp, "MINGW (gcc)\n");
+  tmp += sprintf(tmp, "MINGW (gcc)\n");
 #	elif defined __BORLANDC__
-		tmp += sprintf(tmp, "Borland\n");
+  tmp += sprintf(tmp, "Borland\n");
 #	elif defined _MSC_VER
-		tmp += sprintf(tmp, "Microsoft Visual C++\n");
+  tmp += sprintf(tmp, "Microsoft Visual C++\n");
 #	elif defined DJGPP
-		tmp += sprintf(tmp, "DJGPP (gcc)\n");
+  tmp += sprintf(tmp, "DJGPP (gcc)\n");
 #	elif defined __GNUC__
-		tmp += sprintf(tmp, "gcc\n");
+  tmp += sprintf(tmp, "gcc\n");
 #	else
-		tmp += sprintf(tmp, "???\n");
+  tmp += sprintf(tmp, "???\n");
 #	endif
-	tmp += sprintf(tmp, "Version = %s\n", tw_version().c_str());
-	return tmp - dest;
+  tmp += sprintf(tmp, "Version = %s\n", tw_version().c_str());
+  return tmp - dest;
 }
 
 // DIAGNOSTICS - dialog function
@@ -1816,26 +1809,26 @@
 
 
 char *playerListboxGetter(int index, int *list_size) {
-	static char buf[160];
-	char *tmp = buf;
+  static char buf[160];
+  char *tmp = buf;
 
-	tmp[0] = 0;
-	if(index < 0) {
-		*list_size = MAX_PLAYERS;
-		return NULL;
-	} else {
-		tmp += sprintf(tmp, "Player%d", index + 1);
-		if (index + 1 < 10) tmp += sprintf(tmp, " ");
-		tmp += sprintf(tmp, "   %d   %d   %s", player_team[index], player_config[index], player_type[index]);
-		if ((strlen(buf) >= 80)) tw_error("playerListboxGetter string too long");
-		return buf;
-	}
+  tmp[0] = 0;
+  if(index < 0) {
+    *list_size = MAX_PLAYERS;
+    return NULL;
+  } else {
+    tmp += sprintf(tmp, "Player%d", index + 1);
+    if (index + 1 < 10) tmp += sprintf(tmp, " ");
+    tmp += sprintf(tmp, "   %d   %d   %s", player_team[index], player_config[index], player_type[index]);
+    if ((strlen(buf) >= 80)) tw_error("playerListboxGetter string too long");
+    return buf;
+  }
 }
 
 char *controlListboxGetter(int index, int *list_size) {
-	static char tmp[40];
+  static char tmp[40];
 
-	tmp[0] = 0;
+  tmp[0] = 0;
   if(index < 0) {
     *list_size = num_controls;
     return NULL;
@@ -1847,20 +1840,20 @@
 /*
   Path Configuration
 
- */
+*/
 
 std::string home_ini_full_path(std::string path)
 {
   char * home = getenv("HOME");
   char dest[2040] = {0};
   if(home == NULL)
-   {
-     if(strstr(path.c_str(), DATAFILE_PATH))
-       return path;
-     std::string pth = append_filename(dest, DATAFILE_PATH, "default_ini", 2039);
-     append_filename(dest, pth.c_str(), path.c_str(), 2039);
-     return std::string(dest);
-   }
+    {
+      if(strstr(path.c_str(), DATAFILE_PATH))
+	return path;
+      std::string pth = append_filename(dest, DATAFILE_PATH, "default_ini", 2039);
+      append_filename(dest, pth.c_str(), path.c_str(), 2039);
+      return std::string(dest);
+    }
   else
     {
       if(strstr(path.c_str(), home))
@@ -1911,7 +1904,7 @@
   const char * ship_name = get_filename(filename);
   std::string home_file = home_ini_full_path(std::string("ships/") + ship_name);
   if(!exists(home_file.c_str()))
-     CopyFile(filename, home_file.c_str());
+    CopyFile(filename, home_file.c_str());
   
   tw_set_config_file(home_file);
   int version = get_config_int("Info", "Version", -1);



From yurand at sheep.berlios.de  Sun Feb 13 23:25:10 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 13 Feb 2005 23:25:10 +0100
Subject: [Tw-light-svn] r115 - trunk
Message-ID: <200502132225.j1DMPAKC001885@sheep.berlios.de>

Author: yurand
Date: 2005-02-13 23:25:09 +0100 (Sun, 13 Feb 2005)
New Revision: 115

Modified:
   trunk/sources.lst
Log:
Fixing source list


Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-02-13 22:23:45 UTC (rev 114)
+++ trunk/sources.lst	2005-02-13 22:25:09 UTC (rev 115)
@@ -79,8 +79,6 @@
 source/ships/shpwolmi.cpp
 source/ships/shpearc3.cpp
 source/ships/shpkahbo.cpp
-source/ships/shpkorsi.cpp
-source/ships/shpkorsn.cpp
 source/ships/shpstaba.cpp
 source/tests/testmain.cpp
 source/tests/testdatapath.cpp



From yurand at sheep.berlios.de  Tue Feb 15 00:07:06 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Tue, 15 Feb 2005 00:07:06 +0100
Subject: [Tw-light-svn] r116 - trunk/source/melee
Message-ID: <200502142307.j1EN76tY003472@sheep.berlios.de>

Author: yurand
Date: 2005-02-15 00:07:04 +0100 (Tue, 15 Feb 2005)
New Revision: 116

Modified:
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
Log:
Added help message for changing camera mode


Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-02-13 22:25:09 UTC (rev 115)
+++ trunk/source/melee/mgame.cpp	2005-02-14 23:07:04 UTC (rev 116)
@@ -1,17 +1,17 @@
 /*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
 */
 
 #include <exception>
@@ -137,17 +137,18 @@
 char **game_names = NULL;
 GameType **games = NULL;
 
-GameType::GameType(const char *name, Game *(*new_game)(), double order) {
-	this->name = strdup(name);
-	this->_new_game = new_game;
-	this->order = order;
-	::num_games += 1;
-	::game_names = (char **) realloc(::game_names, sizeof(char*) * (num_games+1));
-	::games = (GameType**) realloc(::games, sizeof(GameType*) * (num_games+1));
-	games[num_games-1] = this;
-	games[num_games] = NULL;
-	game_names[num_games-1] = this->name;
-	game_names[num_games] = NULL;
+GameType::GameType(const char *name, Game *(*new_game)(), double order) 
+{
+  this->name = strdup(name);
+  this->_new_game = new_game;
+  this->order = order;
+  ::num_games += 1;
+  ::game_names = (char **) realloc(::game_names, sizeof(char*) * (num_games+1));
+  ::games = (GameType**) realloc(::games, sizeof(GameType*) * (num_games+1));
+  games[num_games-1] = this;
+  games[num_games] = NULL;
+  game_names[num_games-1] = this->name;
+  game_names[num_games] = NULL;
 }
 
 Game *GameType::new_game() 
@@ -165,7 +166,7 @@
   for (g = games; *g; g ++)
     if (!strcmp((*g)->name, name))
       return *g;
-	return NULL;
+  return NULL;
 }
 
 void __checksync( const char *fname, int line) 
@@ -355,59 +356,59 @@
 }
 
 Control *Game::create_control (int channel, const char *type, char *config, char *file) {STACKTRACE
-	if ((channel != channel_none) && !is_local(channel)) {
-		type = "VegetableBot";
-		config = "Config0";
-		file = "scp.ini";
-	}
+											   if ((channel != channel_none) && !is_local(channel)) {
+											     type = "VegetableBot";
+											     config = "Config0";
+											     file = "scp.ini";
+											   }
 
-	Control *c = getController(type, "whatever", channel);
-	if (!c) {
-		tw_error("Game::create_control - bad control type (%s)", type);
-		return c;
-	}
-	c->load(file, config);
-	add(c);
-	return c;
+ Control *c = getController(type, "whatever", channel);
+ if (!c) {
+   tw_error("Game::create_control - bad control type (%s)", type);
+   return c;
+ }
+ c->load(file, config);
+ add(c);
+ return c;
 }
 
 void Game::log_char(int channel, char &data) {
   STACKTRACE;
-	if (!log) return;
-	log->log  (channel, &data, 1);
-	return;
+  if (!log) return;
+  log->log  (channel, &data, 1);
+  return;
 }
 
 void Game::log_short(int channel, short &data) {
   STACKTRACE;
-	if (!log) return;
-	data = intel_ordering_short(data);	
-	log->log  (channel, &data, sizeof(short));
-	data = intel_ordering_short(data);
-	return;
+  if (!log) return;
+  data = intel_ordering_short(data);	
+  log->log  (channel, &data, sizeof(short));
+  data = intel_ordering_short(data);
+  return;
 }
 
 void Game::log_int(int channel, int &data) {
   STACKTRACE;
-	if (!log) return;
-	data = intel_ordering(data);
-	log->log  (channel, &data, sizeof(int));
-	data = intel_ordering(data);
-	return;
+  if (!log) return;
+  data = intel_ordering(data);
+  log->log  (channel, &data, sizeof(int));
+  data = intel_ordering(data);
+  return;
 }
 
 void Game::log_data(int channel, void *data, int size) {
   STACKTRACE;
-	if (!log) return;
-	log->log  (channel, data, size);
-	return;
+  if (!log) return;
+  log->log  (channel, data, size);
+  return;
 }
 
 void Game::idle(int time) {
   STACKTRACE;
-	if (log->listen()) return;
-	::idle(time);
-	return;
+  if (log->listen()) return;
+  ::idle(time);
+  return;
 }
 
 void Game::animate(Frame *frame) 
@@ -553,9 +554,9 @@
       tmp = (char *)malloc(s);
       memcpy(tmp, buffy, sizeof(GameEvent));
     }
-		log->unbuffer(channel_server + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
-		handle_game_event ( channel_server, ((GameEvent*)tmp));
-		if (tmp != buffy) free(tmp);
+    log->unbuffer(channel_server + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
+    handle_game_event ( channel_server, ((GameEvent*)tmp));
+    if (tmp != buffy) free(tmp);
   }
   
   
@@ -568,7 +569,7 @@
     if (s > 1024) {
       tmp = (char *)malloc(s);
       memcpy(tmp, buffy, sizeof(GameEvent));
-		}
+    }
     log->unbuffer(channel_client + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
     handle_game_event ( channel_client, ((GameEvent*)tmp));
     if (tmp != buffy) free(tmp);
@@ -622,32 +623,32 @@
       num_focuses -= 1;
       if (focus_index == i) {
 	focus[i]->attributes &= ~ATTRIB_ACTIVE_FOCUS;
-				active_focus_destroyed = 1;
-				focus_index -= 1;
-				if (num_focuses && (focus_index < 0))
-					focus_index += 1;
-			}
-			focus[i] = focus[num_focuses];
-			i -= 1;
-		}
-	}
+	active_focus_destroyed = 1;
+	focus_index -= 1;
+	if (num_focuses && (focus_index < 0))
+	  focus_index += 1;
+      }
+      focus[i] = focus[num_focuses];
+      i -= 1;
+    }
+  }
 
 
-	if (active_focus_destroyed && (focus_index >= 0))
-		focus[focus_index]->attributes |= ATTRIB_ACTIVE_FOCUS;
+  if (active_focus_destroyed && (focus_index >= 0))
+    focus[focus_index]->attributes |= ATTRIB_ACTIVE_FOCUS;
 
 
 
-	Physics::calculate();
+  Physics::calculate();
 
-	gametargets.calculate();
+  gametargets.calculate();
 
-	view->calculate(this);
+  view->calculate(this);
 
 
-	t = get_time() - t - paused_time;
-	tic_history->add_element(pow(t, HIST_POWER));
-	return;
+  t = get_time() - t - paused_time;
+  tic_history->add_element(pow(t, HIST_POWER));
+  return;
 }
 
 void Game::play() 
@@ -702,7 +703,7 @@
     handle_game_error(this);
     if (i != 0) {
       caught_error ("%s %s caught int %d", __FILE__, __LINE__, i);
-		}
+    }
     if (__error_flag & 1) throw;
   }
   catch (const char *str) {
@@ -753,70 +754,68 @@
 void Game::object_died(SpaceObject *who, SpaceLocation *source)
 {
   STACKTRACE;
-	if (who && who->isShip())
-	{
-		ship_died((Ship*)who, source);
-	}
+  if (who && who->isShip())
+    {
+      ship_died((Ship*)who, source);
+    }
 }
 
 void Game::fps() {
   STACKTRACE;
-	if ((!log->playback) && ((log->type == Log::log_net1server) || (log->type == Log::log_net1client))) {
-		int ping = ((NetLog*)log)->ping;
-		char *tt = "good";
-		if (ping > 100) tt = "okay";
-		if (ping > 200) tt = "bad";
-		if (ping > 400) tt = "BAD!";
-		if (ping > 800) tt = "VERY BAD!";
-		message.print((int)msecs_per_fps, 12, "ping: %dms (that's %s)", ping, tt);
-	}
+  if ((!log->playback) && ((log->type == Log::log_net1server) || (log->type == Log::log_net1client))) {
+    int ping = ((NetLog*)log)->ping;
+    char *tt = "good";
+    if (ping > 100) tt = "okay";
+    if (ping > 200) tt = "bad";
+    if (ping > 400) tt = "BAD!";
+    if (ping > 800) tt = "VERY BAD!";
+    message.print((int)msecs_per_fps, 12, "ping: %dms (that's %s)", ping, tt);
+  }
 
-	if (this->show_fps) {
-/*			double a = 1.0;
+  if (this->show_fps) {
+    /*			double a = 1.0;
 			double b = 1.0;
-//			double *c = (double *)(((int)&a - (int)&b) & 0x80000000);
-//			message.print(1000, 15, "inf = %f", a + *c);
-				{
-				SpaceLocation *frog = getFirstItem(LAYER_CBODIES);
-//				const type_info *d = &typeid(*frog);
-				message.print(msecs_per_fps, 15, "%s %d %d %d", 
-						d->name(), sizeof(*frog), sizeof(Asteroid),
-						0);
-				}*/
-		double tt = pow(tic_history->get_average(0, 1000/frame_time), 1/HIST_POWER);
-		double rt = pow(render_history->get_average(0, 1000/frame_time), 1/HIST_POWER);
-		char *tmp;
+			//			double *c = (double *)(((int)&a - (int)&b) & 0x80000000);
+			//			message.print(1000, 15, "inf = %f", a + *c);
+			{
+			SpaceLocation *frog = getFirstItem(LAYER_CBODIES);
+			//				const type_info *d = &typeid(*frog);
+			message.print(msecs_per_fps, 15, "%s %d %d %d", 
+			d->name(), sizeof(*frog), sizeof(Asteroid),
+			0);
+			}*/
+    double tt = pow(tic_history->get_average(0, 1000/frame_time), 1/HIST_POWER);
+    double rt = pow(render_history->get_average(0, 1000/frame_time), 1/HIST_POWER);
+    char *tmp;
 
-		if (tt*8 < frame_time)
-			tmp = "good";
-		else if (tt*2 < frame_time)
-			tmp = "ok";
-		else if (tt < frame_time)
-			tmp = "bad";
-		else
-			tmp = "BAD!";
-		message.print((int)msecs_per_fps, 12, "tic time: %.3fms (that's %s)", tt, tmp);
+    if (tt*8 < frame_time)
+      tmp = "good";
+    else if (tt*2 < frame_time)
+      tmp = "ok";
+    else if (tt < frame_time)
+      tmp = "bad";
+    else
+      tmp = "BAD!";
+    message.print((int)msecs_per_fps, 12, "tic time: %.3fms (that's %s)", tt, tmp);
 
-		if (rt < 2)
-			tmp = "good";
-		else if (rt < 20)
-			tmp = "ok";
-		else if (rt < 50)
-			tmp = "bad";
-		else
-			tmp = "BAD!";
-		message.print((int)msecs_per_fps, 12, "render time: %.3fms (that's %s)", rt, tmp);
-		message.print((int)msecs_per_fps, 12, "debug: %d", debug_value);
-	}
+    if (rt < 2)
+      tmp = "good";
+    else if (rt < 20)
+      tmp = "ok";
+    else if (rt < 50)
+      tmp = "bad";
+    else
+      tmp = "BAD!";
+    message.print((int)msecs_per_fps, 12, "render time: %.3fms (that's %s)", rt, tmp);
+    message.print((int)msecs_per_fps, 12, "debug: %d", debug_value);
+  }
 }
 
 void Game::preinit() 
 {
   STACKTRACE;
   Physics::preinit();
-  //	meleedata.planetSprite = meleedata.asteroidSprite = meleedata.asteroidExplosionSprite = meleedata.hotspotSprite = meleedata.kaboomSprite = meleedata.panelSprite = meleedata.sparkSprite = meleedata.xpl1Sprite = NULL;
-  // you should reset it here (again), cause there can be subgames of this type.
-  //	planet_victory = NULL;
+
   log = NULL;
   tic_history = render_history = NULL;
   
@@ -827,8 +826,6 @@
   num_focuses = 0;
   focus_index = 0;
   focus = NULL;
-  //	num_targets = 0;
-  //	target = NULL;
   gametargets.reset();
   view = NULL;
   window = NULL;
@@ -884,7 +881,7 @@
       break;
     case Log::log_net1client: {
     }
-			break;
+      break;
     default: {
       tw_error("Knee!");
     }
@@ -896,9 +893,9 @@
      
   offset	size	format		data
   0		4		int			log type number
-4		4		int			size of game type name
-8		?		char[]		game type name
-?		4		int			lag frames
+  4		4		int			size of game type name
+  8		?		char[]		game type name
+  ?		4		int			lag frames
 
   */
   int tmp = log->type;
@@ -906,155 +903,159 @@
   if (log->playback) log->type = tmp;
 
   char buffy[128];
-	i = strlen(type->name);
-	memcpy(buffy, type->name, i);
-	if (i > 127) {tw_error("long gamename1");}
-	log_int (channel_init, i);
-	if (i > 127) {tw_error("long gamename2");}
-	log_data(channel_init, buffy, i);
-	buffy[i] = 0;
-	if (strcmp(buffy, type->name)) {tw_error("wrong game type");}
+  i = strlen(type->name);
+  memcpy(buffy, type->name, i);
+  if (i > 127) {tw_error("long gamename1");}
+  log_int (channel_init, i);
+  if (i > 127) {tw_error("long gamename2");}
+  log_data(channel_init, buffy, i);
+  buffy[i] = 0;
+  if (strcmp(buffy, type->name)) {tw_error("wrong game type");}
 
-	i = rand();
-//	i = 9223;
-	log_int(channel_server, i);
-	random_seed[0] = i;
-	rng.seed(i);
-	i = rand();
-//	i = 7386;
-	log_int(channel_server, i);
-	random_seed[1] = i;
-	rng.seed_more(i);
+  i = rand();
+  //	i = 9223;
+  log_int(channel_server, i);
+  random_seed[0] = i;
+  rng.seed(i);
+  i = rand();
+  //	i = 7386;
+  log_int(channel_server, i);
+  random_seed[1] = i;
+  rng.seed_more(i);
 
-	if (!is_paused()) pause();
+  if (!is_paused()) pause();
 
-	text_mode(-1);
+  text_mode(-1);
 
-	tw_set_config_file("client.ini");
-	msecs_per_fps = get_config_int("View", "FPS_Time", 200);
-	msecs_per_render = (int)(1000. / get_config_float("View", "MinimumFrameRate", 10) + 0.5);
+  tw_set_config_file("client.ini");
+  msecs_per_fps = get_config_int("View", "FPS_Time", 200);
+  msecs_per_render = (int)(1000. / get_config_float("View", "MinimumFrameRate", 10) + 0.5);
 	
-	log_file("server.ini");
-	camera_hides_cloakers = get_config_int("View", "CameraHidesCloakers", 1);
-	time_ratio = (int)(1000. / get_config_float ("Game", "SC2FrameRate", 20));
-	distance_ratio = (3840. / get_config_float ("Game", "SC2TotalDistance", 8000));
-	frame_time = (int)(1000. / get_config_float ("Game", "TicRate", 40) + 0.5);
-	normal_turbo = get_config_float("Game", "Turbo", 1.0);
-	f4_turbo = get_config_float("Game", "F4Turbo", 10.0);	
-	turbo = normal_turbo;
-	friendly_fire = get_config_int("Game", "FriendlyFire", 0) == 0 ? 0 : 1; //MSVC sucks also
-	shot_relativity = get_config_float("Game", "ShotRelativity", 0);
-	size = Vector2 (
-		get_config_float("Game", "MapWidth", 0),
-		get_config_float("Game", "MapHeight", 0)
-	);
+  log_file("server.ini");
+  camera_hides_cloakers = get_config_int("View", "CameraHidesCloakers", 1);
+  time_ratio = (int)(1000. / get_config_float ("Game", "SC2FrameRate", 20));
+  distance_ratio = (3840. / get_config_float ("Game", "SC2TotalDistance", 8000));
+  frame_time = (int)(1000. / get_config_float ("Game", "TicRate", 40) + 0.5);
+  normal_turbo = get_config_float("Game", "Turbo", 1.0);
+  f4_turbo = get_config_float("Game", "F4Turbo", 10.0);	
+  turbo = normal_turbo;
+  friendly_fire = get_config_int("Game", "FriendlyFire", 0) == 0 ? 0 : 1; //MSVC sucks also
+  shot_relativity = get_config_float("Game", "ShotRelativity", 0);
+  size = Vector2 (
+		  get_config_float("Game", "MapWidth", 0),
+		  get_config_float("Game", "MapHeight", 0)
+		  );
 
-	init_lag();
-	log_int(channel_server, lag_frames);
-	log_int(channel_init, lag_frames);
+  init_lag();
+  log_int(channel_server, lag_frames);
+  log_int(channel_init, lag_frames);
 
-	tic_history = new Histograph(128);
-	render_history = new Histograph(128);
+  tic_history = new Histograph(128);
+  render_history = new Histograph(128);
 
-	prepare();
+  prepare();
 
-	return;
+  return;
 }
 
-void Game::init_lag() {
+void Game::init_lag() 
+{
   STACKTRACE;
-	if ((log->type == Log::log_net1server) || (log->type == Log::log_net1client)) {
-		int lag_time = 0;//get_config_int("Network", "Lag", 200);
-		char blah = 0;
-		log_char(channel_server, blah);
-		log->flush();
-		log_char(channel_client, blah);
-		log->flush();
-		log_char(channel_server, blah);
-		log->flush();
-		log_char(channel_client, blah);
-		log->flush();
-		log_char(channel_server, blah);
-		log->flush();
-		lag_time = ((NetLog*)log)->ping;
-		log_int(channel_server, lag_time);
-		int lag_frames = (int) (1.5 + lag_time * normal_turbo / (double) frame_time );
+  if ((log->type == Log::log_net1server) || (log->type == Log::log_net1client)) 
+    {
+      int lag_time = 0;//get_config_int("Network", "Lag", 200);
+      char blah = 0;
+      log_char(channel_server, blah);
+      log->flush();
+      log_char(channel_client, blah);
+      log->flush();
+      log_char(channel_server, blah);
+      log->flush();
+      log_char(channel_client, blah);
+      log->flush();
+      log_char(channel_server, blah);
+      log->flush();
+      lag_time = ((NetLog*)log)->ping;
+      log_int(channel_server, lag_time);
+      int lag_frames = (int) (1.5 + lag_time * normal_turbo / (double) frame_time );
 #		ifdef _DEBUG
-//			lag_frames += 5;
+    //			lag_frames += 5;
 #		endif
-//			lag_frames += 5;
-		message.print(15000, 15, "target ping set to: %d ms (pessimistically: %d ms)", lag_time, iround(lag_frames * frame_time / normal_turbo));
-		for (int i = 0; i < lag_frames; i += 1)
-			increase_latency();
-	}
-	else {
-		int lag_frames = 0;//10;//0;
-		for (int i = 0; i < lag_frames; i += 1)
-			increase_latency();//*/
-	}
+    //			lag_frames += 5;
+      message.print(15000, 15, "target ping set to: %d ms (pessimistically: %d ms)", lag_time, iround(lag_frames * frame_time / normal_turbo));
+      for (int i = 0; i < lag_frames; i += 1)
+	increase_latency();
+    }
+  else 
+    {
+      int lag_frames = 0;//10;//0;
+      for (int i = 0; i < lag_frames; i += 1)
+	increase_latency();//*/
+    }
 }
 
 void Game::change_view(View *new_view) {
   STACKTRACE;//this function looks wrong to me
-	View *v = new_view;
-	v->preinit();
-	v->init(view);
-	if (view)
-		v->replace(view);
-	else {
-		v->window->init(window);
-		v->window->locate(
-			0, 0,
-			0, 0,
-			0, 1,
-			0, 1
-			);
-	}
-	view = v;
-	return;
+  View *v = new_view;
+  v->preinit();
+  v->init(view);
+  if (view)
+    v->replace(view);
+  else {
+    v->window->init(window);
+    v->window->locate(
+		      0, 0,
+		      0, 0,
+		      0, 1,
+		      0, 1
+		      );
+  }
+  view = v;
+  return;
 }
 
-void Game::change_view(const char * name) {
+void Game::change_view(const char * name) 
+{
   STACKTRACE;
-	View *v = get_view(name, view);
-	if (!v)	{tw_error("Game::change_view - invalid view name");}
-	if (view)
-		v->replace(view);
-	else 
-	{
-		v->window->init(window);
-		v->window->locate(
+  View *v = get_view(name, view);
+  if (!v)	{tw_error("Game::change_view - invalid view name");}
+  if (view)
+    v->replace(view);
+  else 
+    {
+      v->window->init(window);
+      v->window->locate(
 			0, 0,
 			0, 0,
 			0, 1,
 			0, 1
 			);
-	}
-	view = v;
-	return;
+    }
+  view = v;
+  return;
 }
 
 Game::~Game() {STACKTRACE
-	message.out("deleteing GameEvents");
-	int i;
-	for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
-	delete[] waiting_events;
+		 message.out("deleteing GameEvents");
+ int i;
+ for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
+ delete[] waiting_events;
 
-	message.out("deleteing histographs");
-	delete tic_history; tic_history = NULL;
-	delete render_history; render_history = NULL;
+ message.out("deleteing histographs");
+ delete tic_history; tic_history = NULL;
+ delete render_history; render_history = NULL;
 
-	tw_sound->play_music(std::string(""));
+ tw_sound->play_music(std::string(""));
 
-	message.out("deleteing game objects");
-	destroy_all();
+ message.out("deleteing game objects");
+ destroy_all();
 
-	message.out("other shit");
-	message.flush();
+ message.out("other shit");
+ message.flush();
 
-	delete view;
-	window->remove_callback(this);
-	delete window;
+ delete view;
+ window->remove_callback(this);
+ delete window;
 }
 
 bool Game::is_paused() 
@@ -1195,6 +1196,7 @@
 	  {
 	    game->change_view("Hero");
 	    message.print(2500, 15, "View mode changed to 'Hero'");
+	    message.print(3000, 15, "Use '+'/'-' for zoom in/out");
 	    return true;
 	  }
 	return true;
@@ -1227,9 +1229,9 @@
 
 int Game::set_frame_time(int t) {
   STACKTRACE;
-	this->frame_time = t;
-	prepare();
-	return 1;
+  this->frame_time = t;
+  prepare();
+  return 1;
 }
 
 int Game::set_turbo(double t) 
@@ -1260,12 +1262,12 @@
 }
 
 bool Game::isGameDone() { 
-    return game_done;
+  return game_done;
 }
 
 void Game::setGameDone(const bool done)
 { 
-    game_done = done; 
+  game_done = done; 
 }
 
 

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-02-13 22:25:09 UTC (rev 115)
+++ trunk/source/melee/mgame.h	2005-02-14 23:07:04 UTC (rev 116)
@@ -1,17 +1,17 @@
 /*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
 */
 
 
@@ -73,28 +73,28 @@
   
   enum 
     {
-      channel_none = -1,    /**< not a valid channel */
-      channel_init = 4,     /**< game type, version, length, etc.. things that need to read by a reader independant of a particular game type */
-      channel_playback = 8, /**<  used for demo playbacks only */
-      channel_server  = 12, /**< data originating on the server */
-      channel_client  = 16, /**< data originating on the client */
+      channel_none = -1,    ///< not a valid channel 
+      channel_init = 4,     ///< game type, version, length, etc.. things that need to read by a reader independant of a particular game type
+      channel_playback = 8, ///<  used for demo playbacks only 
+      channel_server  = 12, ///< data originating on the server 
+      channel_client  = 16, ///< data originating on the client 
       _channel_buffered = 1
     };
   
-  Log *log; /**< logging system for networking, demo recording/playback, etc. */
-  void log_char (int channel, char &data); /**< helper for using the logging system */
-  void log_char (int channel, unsigned char &data) 
+  Log *log; ///< logging system for networking, demo recording/playback, etc.
+  void log_char (int channel, char &data); ///< helper for using the logging system 
+  void log_char (int channel, unsigned char &data) ///< helper for using the logging system 
     {
       log_char (channel,*(char*)&data);
     }
-  void log_short(int channel, short &data);    /**< helper for using the logging system */
+  void log_short(int channel, short &data);    ///< helper for using the logging system 
   void log_short(int channel, unsigned short &data) 
     {
       log_short (channel,*(short*)&data);
     }
-  void log_int  (int channel, int &data);      /**< helper for using the logging system */
+  void log_int  (int channel, int &data);      ///< helper for using the logging system 
   void log_int  (int channel, unsigned int &data) {log_int (channel,*(int*)&data);}
-  void log_data (int channel, void *data, int length); /**< helper for using the logging system */
+  void log_data (int channel, void *data, int length); ///< helper for using the logging system 
   virtual void log_file (const char *fname);
   void log_fleet(int channel, class Fleet *fleet);
   int is_local ( int channel ) ;
@@ -132,9 +132,10 @@
   View *view;
   VideoWindow *window;
   
-  virtual void prepare();   //called before doing anything with game objects contained within you.  
-  //This is particularly necessary if you are working with multiple Games simultaneously
-  
+  /// called before doing anything with game objects contained within you.  
+  /// This is particularly necessary if you are working with multiple Games simultaneously
+  virtual void prepare();   
+
   virtual void calculate();
   virtual void play();
   virtual void animate(Frame *frame); // stupid C++
@@ -152,7 +153,7 @@
   virtual void set_resolution (int screen_x, int screen_y);
   virtual void redraw();
 
-protected:  
+ protected:  
   bool game_done;
   /// Show ingame menu (save/load/option/quit/exit)
   virtual void GameMenu();
@@ -160,7 +161,7 @@
   virtual std::string Save();
   virtual int Load(std::string xml);
 
-public:
+ public:
   /// sets whether the game is done, according to the rules for the
   /// gametype.
   virtual void setGameDone(const bool done);
@@ -187,7 +188,6 @@
   Targets gametargets;
   
   
-  
   virtual Control *create_control (int channel, const char *type, char *config = "Config0", char *file = "scp.ini") ;
   virtual Ship    *create_ship (const char *id, Control *c, Vector2 pos, double angle, int team=0);
   virtual Ship    *create_ship (int channel, const char *id, const char *control, Vector2 pos, double angle, int team=0);



From yurand at sheep.berlios.de  Wed Feb 16 21:27:47 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Wed, 16 Feb 2005 21:27:47 +0100
Subject: [Tw-light-svn] r117 - trunk/source/util
Message-ID: <200502162027.j1GKRlN3021999@sheep.berlios.de>

Author: yurand
Date: 2005-02-16 21:27:45 +0100 (Wed, 16 Feb 2005)
New Revision: 117

Modified:
   trunk/source/util/aastr.c
   trunk/source/util/aautil.c
Log:
Fixed bug in "bit" macros


Modified: trunk/source/util/aastr.c
===================================================================
--- trunk/source/util/aastr.c	2005-02-14 23:07:04 UTC (rev 116)
+++ trunk/source/util/aastr.c	2005-02-16 20:27:45 UTC (rev 117)
@@ -29,7 +29,7 @@
 #include "aastr.h"
 #include "aautil.h"
 
-#define bit(a) (1<<a)
+#define bit(a) (1<<(a))
 #define bitn(a) (bit(a)-1)
 
 int _aa_mode = 0;

Modified: trunk/source/util/aautil.c
===================================================================
--- trunk/source/util/aautil.c	2005-02-14 23:07:04 UTC (rev 116)
+++ trunk/source/util/aautil.c	2005-02-16 20:27:45 UTC (rev 117)
@@ -51,7 +51,7 @@
  * Some macros for making our put-pixel functions
  */
 
-#define bit(a)   (1 << a)
+#define bit(a)   (1 << (a))
 #define bitn(a)  (bit(a)-1)
 
 //bpp is output size



From yurand at sheep.berlios.de  Wed Feb 16 21:31:50 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Wed, 16 Feb 2005 21:31:50 +0100
Subject: [Tw-light-svn] r118 - in trunk: . source source/games source/melee
Message-ID: <200502162031.j1GKVoOZ022555@sheep.berlios.de>

Author: yurand
Date: 2005-02-16 21:31:49 +0100 (Wed, 16 Feb 2005)
New Revision: 118

Modified:
   trunk/makefile
   trunk/source/games/gdefender.cpp
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mmain.h
   trunk/source/scp.cpp
Log:
1) Adding new string argument for init function in Game class, it must 
be used for loading game state

2) gamedata folder is set to 'damedata' for debug configuration by 
default now



Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/makefile	2005-02-16 20:31:49 UTC (rev 118)
@@ -49,12 +49,16 @@
 endif
 
 ifndef DATAPATH
-ifdef win32
+ifdef win32 
 DATAPATH=gamedata
 else
+ifdef debug
+DATAPATH=gamedata
+else
 DATAPATH=/usr/local/share/games/tw-light
 endif
 endif
+endif
 
 ifndef EXECPATH
 ifndef win32

Modified: trunk/source/games/gdefender.cpp
===================================================================
--- trunk/source/games/gdefender.cpp	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/games/gdefender.cpp	2005-02-16 20:31:49 UTC (rev 118)
@@ -74,7 +74,7 @@
   
   virtual ~DefenderGame();
   
-  virtual void init ( Log *_log ) ;
+  virtual void init ( Log *_log, const std::string& save ) ;
 
   //begin the game
   void restart();
@@ -251,9 +251,9 @@
 
 }
 
-void DefenderGame::init( Log * _log) 
+void DefenderGame::init( Log * _log, const std::string& save) 
 {
-  Game::init(_log);
+  Game::init(_log, save);
   
   prepare();
   add ( new Stars() );

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/games/ggob.cpp	2005-02-16 20:31:49 UTC (rev 118)
@@ -160,11 +160,11 @@
 }
 
 
-void GobGame::init(Log *_log) 
+void GobGame::init(Log *_log, const std::string& save) 
 {
   STACKTRACE;
   int i;
-  Game::init(_log);
+  Game::init(_log, save);
   
   log_file("server.ini");
   max_enemies = get_config_int("Gob", "MaxEnemies", 32);

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/games/ggob.h	2005-02-16 20:31:49 UTC (rev 118)
@@ -90,7 +90,7 @@
   virtual bool isGameDone();
   virtual void ship_died(Ship *who, SpaceLocation *source);
   virtual void preinit();
-  virtual void init (Log *log);
+  virtual void init (Log *log, const std::string& save);
 
   virtual void play_sound (SAMPLE *sample, SpaceLocation *source, int vol = 256, int freq = 1000);
 	

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/melee/mgame.cpp	2005-02-16 20:31:49 UTC (rev 118)
@@ -832,7 +832,7 @@
   music = "";
 }
 
-void Game::init(Log *_log) 
+void Game::init(Log *_log, const std::string& save) 
 {
   STACKTRACE;
   int i;

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/melee/mgame.h	2005-02-16 20:31:49 UTC (rev 118)
@@ -119,7 +119,7 @@
 
 
   virtual void preinit();	///< pre-initialization (enough so that the destructor won't crash) 
-  virtual void init(Log *log);  ///< initialization (loading data, creating a few game objects, whatever)
+  virtual void init(Log *log, const std::string& save);  ///< initialization (loading data, creating a few game objects, whatever)
   virtual ~Game();              ///< deallocating memory etc.
   
   virtual void init_lag();

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/melee/mmain.cpp	2005-02-16 20:31:49 UTC (rev 118)
@@ -223,9 +223,9 @@
 	kills = NULL;
 	num_players = 0;
 	}
-void NormalGame::init(Log *_log) {
+void NormalGame::init(Log *_log, const std::string& save) {
   STACKTRACE;
-	Game::init(_log);
+	Game::init(_log, save);
 
 	team_table_size = 0;
 

Modified: trunk/source/melee/mmain.h
===================================================================
--- trunk/source/melee/mmain.h	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/melee/mmain.h	2005-02-16 20:31:49 UTC (rev 118)
@@ -1,17 +1,17 @@
 /*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
 */
 
 #ifndef __MMAIN_H__
@@ -20,61 +20,62 @@
 #include "melee.h"
 #include "mgame.h"
 
-
-class NormalGame : public Game {
-	public:
-	enum { 
-		num_asteroids = 4 
-		};
+/// Melee type game
+class NormalGame : public Game 
+{
+ public:
+  enum { 
+    num_asteroids = 4 
+  };
 		
-	~NormalGame();
+  ~NormalGame();
 
-	virtual void calculate();
-	virtual void preinit();	
-	virtual void init (Log *_log = NULL);
-	virtual void set_resolution(int screen_x, int screen_y);
+  virtual void calculate();
+  virtual void preinit();	
+  virtual void init (Log *_log, const std::string& save);
+  virtual void set_resolution(int screen_x, int screen_y);
 
-	virtual void init_players();
-	virtual void init_objects();
+  virtual void init_players();
+  virtual void init_objects();
 
-	virtual void ship_died(Ship *who, SpaceLocation *source);
-	//kill history stuff
-	int num_kills;
-	struct ShipKill {
-		int time;
-		struct Party {
-			unsigned int ally_flag;
-			ShipData *data;
-			ShipType *type;
-		};
-		Party victim, killer;
-		} *kills;
-	void display_stats();
+  virtual void ship_died(Ship *who, SpaceLocation *source);
+  //kill history stuff
+  int num_kills;
+  struct ShipKill {
+    int time;
+    struct Party {
+      unsigned int ally_flag;
+      ShipData *data;
+      ShipType *type;
+    };
+    Party victim, killer;
+  } *kills;
+  void display_stats();
 
-	virtual int add_player (Control *c, int team_index, const char *name, const char *fleet, const char *fleet_file = "fleets.ini") ;
-	virtual bool isGameDone();
-	int num_players;
-	Control **player_control;
-//	ShipPanel **player_panel;
-	Fleet **player_fleet;
-	char **player_name;
-	char *player_attributes;
-	TeamCode *player_team;
-	TeamCode *team_table;
-	int team_table_size;
-//	virtual void player_said(int who, const char *what);
+  virtual int add_player (Control *c, int team_index, const char *name, const char *fleet, const char *fleet_file = "fleets.ini") ;
+  virtual bool isGameDone();
+  int num_players;
+  Control **player_control;
+  //	ShipPanel **player_panel;
+  Fleet **player_fleet;
+  char **player_name;
+  char *player_attributes;
+  TeamCode *player_team;
+  TeamCode *team_table;
+  int team_table_size;
+  //	virtual void player_said(int who, const char *what);
 
-	protected:
-	virtual bool handle_key(int k);
+ protected:
+  virtual bool handle_key(int k);
 	
-	virtual void showHelpText();
+  virtual void showHelpText();
 	
-	int next_choose_new_ships_time;
-	virtual void choose_new_ships() ;
+  int next_choose_new_ships_time;
+  virtual void choose_new_ships() ;
 
-	int indhealthtoggle, indteamtoggle;
+  int indhealthtoggle, indteamtoggle;
 
-	};
+};
 
 
 #endif // __MMAIN_H__

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-02-16 20:27:45 UTC (rev 117)
+++ trunk/source/scp.cpp	2005-02-16 20:31:49 UTC (rev 118)
@@ -158,7 +158,7 @@
 
 
 void play_demo(const char *file_name = "demo.dmo") ;
-void play_game(const char *_gametype_name, Log *_log = NULL) ;
+void play_game(const char *_gametype_name, const std::string& save, Log *_log = NULL) ;
 void play_net1client ( const char * address = NULL, int port = -1 ) ;
 void play_net1server ( const char *_gametype_name, int port = -1 ) ;
 
@@ -359,7 +359,7 @@
   return key[KEY_ESC];
 }
 
-void play_game(const char *_gametype_name, Log *_log) 
+void play_game(const char *_gametype_name,  const std::string& save, Log *_log ) 
 {
   STACKTRACE;
   char gametype_name[1024];
@@ -397,7 +397,7 @@
       new_game->window->preinit();
       new_game->window->init(&videosystem->window);
       new_game->window->locate(0,0,0,0,0,1,0,1);
-      new_game->init(_log);
+      new_game->init(_log, save );
       new_game->play();
       new_game->log->deinit();
       new_game->setGameDone(true);
@@ -483,7 +483,7 @@
   char *gname = detect_gametype(log);
   log->reset();
   
-  play_game(gname, log);
+  play_game(gname, "", log );
   
   free(gname);
   return;
@@ -519,7 +519,7 @@
   log->net.optimize4latency();
   message.out("connection established");
   
-  play_game(_gametype_name, log);
+  play_game(_gametype_name, "", log);
   
   return;
 }
@@ -669,7 +669,7 @@
       switch (mainRet) {
       case MAIN_DIALOG_MELEE:
 	disable();
-	play_game("Melee");
+	play_game("Melee", "", NULL);
 	enable();
 	break;
       case MAIN_DIALOG_MELEE_EXTENDED:
@@ -1024,15 +1024,17 @@
     i = tw_popup_dialog(NULL, melee_ex_dialog, MELEE_EX_DIALOG_PLAY_GAME);
   switch (i) {
   case -1:
-  case MELEE_EX_DIALOG_EXIT: {
-    return;
-  }
+  case MELEE_EX_DIALOG_EXIT: 
+    {
+      return;
+    }
     break;
-  case MELEE_EX_DIALOG_PLAY_GAME: {
-    const char *gname = select_game_menu();
-    if (gname) play_game(gname);
-    //			play_game(game_names[melee_ex_dialog[MELEE_EX_DIALOG_GAMELIST].d1], log_types[melee_ex_dialog[MELEE_EX_DIALOG_LOGLIST].d1]);
-  }
+  case MELEE_EX_DIALOG_PLAY_GAME: 
+    {
+      const char *gname = select_game_menu();
+      if (gname)
+	play_game(gname, "", NULL);
+    }
     break;
   case MELEE_EX_DIALOG_PLAY_NET1SERVER: {
     const char *gname = select_game_menu();



From yurand at sheep.berlios.de  Wed Feb 16 21:39:01 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Wed, 16 Feb 2005 21:39:01 +0100
Subject: [Tw-light-svn] r119 - in trunk: . source/libraries
Message-ID: <200502162039.j1GKd1Ei024611@sheep.berlios.de>

Author: yurand
Date: 2005-02-16 21:38:59 +0100 (Wed, 16 Feb 2005)
New Revision: 119

Removed:
   trunk/source/libraries/lua/
   trunk/source/libraries/raknet/
Modified:
   trunk/sources.lst
Log:
removing unused libraries from sources, they will be readd when/if they 
need


Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-02-16 20:31:49 UTC (rev 118)
+++ trunk/sources.lst	2005-02-16 20:38:59 UTC (rev 119)
@@ -82,34 +82,6 @@
 source/ships/shpstaba.cpp
 source/tests/testmain.cpp
 source/tests/testdatapath.cpp
-source/libraries/lua/lib/ldblib.c
-source/libraries/lua/lib/lauxlib.c
-source/libraries/lua/lib/lbaselib.c
-source/libraries/lua/lib/loadlib.c
-source/libraries/lua/lib/ltablib.c
-source/libraries/lua/lib/lmathlib.c
-source/libraries/lua/lib/lstrlib.c
-source/libraries/lua/lib/liolib.c
-source/libraries/lua/lundump.c
-source/libraries/lua/ldebug.c
-source/libraries/lua/ldo.c
-source/libraries/lua/lgc.c
-source/libraries/lua/ltm.c
-source/libraries/lua/lvm.c
-source/libraries/lua/lcode.c
-source/libraries/lua/ldump.c
-source/libraries/lua/lfunc.c
-source/libraries/lua/lparser.c
-source/libraries/lua/ltable.c
-source/libraries/lua/ltests.c
-source/libraries/lua/lstate.c
-source/libraries/lua/lapi.c
-source/libraries/lua/llex.c
-source/libraries/lua/lmem.c
-source/libraries/lua/lzio.c
-source/libraries/lua/lopcodes.c
-source/libraries/lua/lobject.c
-source/libraries/lua/lstring.c
 source/libraries/agup/aphoton.c
 source/libraries/agup/ans.c
 source/libraries/agup/awin95.c
@@ -119,38 +91,6 @@
 source/libraries/agup/agup.c
 source/libraries/agup/abeos.c
 source/libraries/agup/abitmap.c
-source/libraries/raknet/AES128.cpp
-source/libraries/raknet/PacketPool.cpp
-source/libraries/raknet/RakNetStatistics.cpp
-source/libraries/raknet/ExtendedOverlappedPool.cpp
-source/libraries/raknet/RakServer.cpp
-source/libraries/raknet/RPCNode.cpp
-source/libraries/raknet/RSA.cpp
-source/libraries/raknet/RakClient.cpp
-source/libraries/raknet/HuffmanEncodingTreeFactory.cpp
-source/libraries/raknet/RakPeer.cpp
-source/libraries/raknet/SocketLayer.cpp
-source/libraries/raknet/StringCompressor.cpp
-source/libraries/raknet/DataBlockEncryptor.cpp
-source/libraries/raknet/InternalPacketPool.cpp
-source/libraries/raknet/SHA1.cpp
-source/libraries/raknet/rand.cpp
-source/libraries/raknet/GetTime.cpp
-source/libraries/raknet/EncodeClassName.cpp
-source/libraries/raknet/NetworkObject.cpp
-source/libraries/raknet/SimpleMutex.cpp
-source/libraries/raknet/Euclid.cpp
-source/libraries/raknet/DistributedNetworkObjectStub.cpp
-source/libraries/raknet/ReliabilityLayer.cpp
-source/libraries/raknet/AsynchronousFileIO.cpp
-source/libraries/raknet/HuffmanEncodingTree.cpp
-source/libraries/raknet/BitStream.cpp
-source/libraries/raknet/RakNetworkFactory.cpp
-source/libraries/raknet/DistributedNetworkObject.cpp
-source/libraries/raknet/MPUInt.cpp
-source/libraries/raknet/CheckSum.cpp
-source/libraries/raknet/DistributedNetworkObjectManager.cpp
-source/libraries/raknet/NetworkTypes.cpp
 source/libraries/jpgalleg/io.c
 source/libraries/jpgalleg/encode.c
 source/libraries/jpgalleg/decode.c



From yurand at sheep.berlios.de  Sat Feb 19 13:15:02 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 19 Feb 2005 13:15:02 +0100
Subject: [Tw-light-svn] r120 - in trunk: . source/games
Message-ID: <200502191215.j1JCF2ai031116@sheep.berlios.de>

Author: yurand
Date: 2005-02-19 13:14:45 +0100 (Sat, 19 Feb 2005)
New Revision: 120

Added:
   trunk/source/games/gamehierarchy.cpp
   trunk/source/games/gamehierarchy.h
Modified:
   trunk/sources.lst
Log:
Adding gamehierarchy code based on Geoman TW code

Added: trunk/source/games/gamehierarchy.cpp
===================================================================
--- trunk/source/games/gamehierarchy.cpp	2005-02-16 20:38:59 UTC (rev 119)
+++ trunk/source/games/gamehierarchy.cpp	2005-02-19 12:14:45 UTC (rev 120)
@@ -0,0 +1,223 @@
+/*
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+*/
+
+
+#include <allegro.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "melee.h"
+
+#include "melee/mlog.h"
+#include "melee/mcontrol.h"
+#include "melee/mframe.h"
+#include "melee/mview.h"
+#include "melee/mitems.h"
+
+#include "scp.h"
+#include "util/history.h"
+
+
+#include "gamehierarchy.h"
+
+
+void SubGame::play()
+{
+  prepare();
+  Game::play();
+};
+
+void SubGame::stop()
+{
+};
+
+
+SubGame::SubGame()
+{
+ 
+}
+
+SubGame::~SubGame()
+{
+
+}
+
+void SubGame::init(Log *_log, const std::string& save)
+{
+  STACKTRACE;
+
+  game_done = false;
+  log = _log;
+  if (!log) {
+    log = new Log();
+    log->init();
+  }
+
+  lag_frames = 0;
+  show_fps = 0;
+  game_time = 0;
+  frame_time = 1;
+  frame_number = 0;
+  hiccup_margin = 100;
+  next_tic_time = get_time();
+  next_render_time = game_time;
+  next_fps_time = game_time;
+  view_locked = false;
+  local_checksum = client_checksum = server_checksum = 0;
+
+  Physics::init();
+  prepare();
+
+  if (!window) {
+    window = new VideoWindow();
+    window->preinit();
+  }
+
+  //set_config_file("client.ini");
+  change_view(get_config_string("View", "View", "Hero")); 
+
+  //window->add_callback(this);				// so .. a window can handle >2 games ??
+
+
+  if (!is_paused()) pause();
+
+  text_mode(-1);
+	
+
+	
+  msecs_per_fps		= maingame->msecs_per_fps;
+  msecs_per_render	= maingame->msecs_per_render;
+  frame_time				= maingame->frame_time;
+  normal_turbo			= maingame->normal_turbo;
+  f4_turbo				= maingame->f4_turbo;
+  turbo = normal_turbo;
+  friendly_fire			= maingame->friendly_fire;
+  shot_relativity			= maingame->shot_relativity;
+
+  
+  lag_frames = maingame->lag_frames;
+
+  tic_history = new Histograph(128);
+  render_history = new Histograph(128);
+
+  prepare();
+
+  return;
+}
+
+void MainGame::addsubgame(SubGame *asubgame)
+{
+  STACKTRACE;
+
+  asubgame->maingame = this;
+
+  asubgame->preinit();
+  asubgame->window = new VideoWindow;
+  asubgame->window->preinit();
+  asubgame->window->init(&videosystem->window);
+  asubgame->window->locate(0,0,0,0,0,1,0,1);
+
+  asubgame->init(log, "");	// all subgames share the same log (is this ok?)
+  // this init should reference the already-initialized melee-data of the maingame
+
+  subgame.insert(asubgame);
+}
+
+
+void MainGame::removesubgame(SubGame* g)
+{
+  STACKTRACE;
+
+  subgame.erase(g);
+  g->log->deinit();	// this is empty, dunno why
+  
+  game = NULL;
+
+  delete g;	// this _must_ be deleted completely, otherwise the gamedata aren't removed  
+}
+
+
+void MainGame::play()
+{
+  STACKTRACE;
+
+  set_resolution(window->w, window->h);
+
+  prepare();
+  if (is_paused()) unpause();
+
+
+  while(!isGameDone())
+    {
+      //unsigned int time = get_time();
+      poll_input();
+      
+      videosystem->poll_redraw();
+
+      for (std::set<SubGame*>::iterator i = subgame.begin();
+	   i!= subgame.end(); i++)
+	{
+	  (*i)->play();
+	}
+      break;
+    }
+	
+}
+
+
+
+
+#include "melee/mgame.h"    //Game stuff
+#include "melee/mcbodies.h" //asteroids & planets
+#include "melee/mship.h"    //ships
+#include "melee/mlog.h"     //networking / demo recording / demo playback
+#include "melee/mcontrol.h" //controllers & AIs
+#include "melee/mview.h"    //Views & text messages
+#include "melee/mshppan.h"  //ship panels...
+#include "melee/mitems.h"   //indicators...
+#include "melee/mfleet.h"   //fleets...
+
+class TestGame1 : public SubGame
+{
+public:
+  virtual void 	init (Log *log, const std::string& save);
+};
+
+void TestGame1::init (Log *log, const std::string& save)
+{
+  //you need to call Game::init very early on, to set stuff up... rarely do you want to do anything before that
+  SubGame::init(log, save);
+
+  //add the starscape background
+  add(new Stars());
+  add(new Asteroid()); //this adds an asteroid to the game
+}
+
+REGISTER_GAME(TestGame1, "TestGame1");
+
+class TestGame : public MainGame
+{
+public:
+  virtual void 	init (Log *log, const std::string& save)
+  {
+    MainGame::init(log,save);
+    addsubgame(new TestGame1);
+    addsubgame(new TestGame1);
+  }	
+};
+
+REGISTER_GAME(TestGame,"TestGame");
+

Added: trunk/source/games/gamehierarchy.h
===================================================================
--- trunk/source/games/gamehierarchy.h	2005-02-16 20:38:59 UTC (rev 119)
+++ trunk/source/games/gamehierarchy.h	2005-02-19 12:14:45 UTC (rev 120)
@@ -0,0 +1,65 @@
+/*
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+*/
+
+#ifndef __TW_LIGHT_GAME_HIERARCHY_H__
+#define __TW_LIGHT_GAME_HIERARCHY_H__
+
+#include "melee/mgame.h"
+#include <set>
+
+
+
+class MainGame;
+
+/// an extended game class, which can be embedded in a sequence
+/// of initiated games ...
+class SubGame : public Game
+{
+ public:
+
+  MainGame	*maingame;		///< the first game (contains the melee data ?)
+
+  SubGame();
+  ~SubGame();
+
+  virtual void init(Log *_log, const std::string& save);
+  virtual void play();
+  /// Suspend game (return to maingame)
+  virtual void stop();
+};
+
+
+
+
+///  This class should allow you to start, play, end a game from within a game (while the
+///  other games are also running in the background). Games and their physics are independent.
+class MainGame : public Game
+{
+ public:
+  
+  std::set<SubGame*> subgame;
+  
+
+  virtual void addsubgame(SubGame *asubgame);
+  virtual void removesubgame(SubGame* g);
+
+  virtual void play();
+};
+
+
+#endif
+
+

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-02-16 20:38:59 UTC (rev 119)
+++ trunk/sources.lst	2005-02-19 12:14:45 UTC (rev 120)
@@ -18,6 +18,7 @@
 source/util/endian.cpp
 source/util/pmask.c
 source/util/base.cpp
+source/games/gamehierarchy.cpp
 source/games/ggob.cpp
 source/games/gflmelee.cpp
 source/games/gdefender.cpp



From yurand at sheep.berlios.de  Sun Feb 20 14:21:00 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 20 Feb 2005 14:21:00 +0100
Subject: [Tw-light-svn] r121 - in trunk: . source source/games source/melee source/other
Message-ID: <200502201321.j1KDL0gR004135@sheep.berlios.de>

Author: yurand
Date: 2005-02-20 14:20:59 +0100 (Sun, 20 Feb 2005)
New Revision: 121

Removed:
   trunk/source/games/gadventure.h
   trunk/source/games/glegacies.cpp
Modified:
   trunk/source/games/gamehierarchy.cpp
   trunk/source/games/gamehierarchy.h
   trunk/source/games/gdefender.cpp
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mmain.h
   trunk/source/other/dialogs.cpp
   trunk/source/scp.cpp
   trunk/sources.lst
Log:
1) Gob game is subclass of SubGame now, you can switch two gob game by 
pressing F6

2) Network game is available only for melee now



Deleted: trunk/source/games/gadventure.h
===================================================================
--- trunk/source/games/gadventure.h	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/games/gadventure.h	2005-02-20 13:20:59 UTC (rev 121)
@@ -1,51 +0,0 @@
-/*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-*/
-
-
-#include <stdio.h>   //standard io libary (needed for sprintf)
-#include <allegro.h> //allegro library header
-
-#include "melee.h"          //used by all TW source files.  well, mostly. 
-#include "melee/mgame.h"    //Game stuff
-#include "melee/mcbodies.h" //asteroids & planets
-#include "melee/mship.h"    //ships
-#include "melee/mshot.h"   //shots, missiles, lasers
-#include "melee/mlog.h"     //networking / demo recording / demo playback
-#include "melee/mcontrol.h" //controllers & AIs
-#include "melee/mview.h"    //Views & messages
-#include "melee/mshppan.h"  //ship panels...
-
-#include "melee/mitems.h"  //ship panels...
-#include "melee/manim.h"  //ship panels...
-#include "scp.h"
-#include "other/dialogs.h"
-
-
-/// TW Legacies Adventure Game 
-///
-
-class LegaciesGame : public Game 
-{
-public:
-  /// save game in XML format;
-  std::string Save();
-  /// load game
-  int Load(std::string);
-  /// exit game
-  void quit(const char *message);
-};
-
-

Modified: trunk/source/games/gamehierarchy.cpp
===================================================================
--- trunk/source/games/gamehierarchy.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/games/gamehierarchy.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -34,17 +34,6 @@
 #include "gamehierarchy.h"
 
 
-void SubGame::play()
-{
-  prepare();
-  Game::play();
-};
-
-void SubGame::stop()
-{
-};
-
-
 SubGame::SubGame()
 {
  
@@ -59,7 +48,6 @@
 {
   STACKTRACE;
 
-  game_done = false;
   log = _log;
   if (!log) {
     log = new Log();
@@ -100,12 +88,12 @@
 	
   msecs_per_fps		= maingame->msecs_per_fps;
   msecs_per_render	= maingame->msecs_per_render;
-  frame_time				= maingame->frame_time;
-  normal_turbo			= maingame->normal_turbo;
-  f4_turbo				= maingame->f4_turbo;
-  turbo = normal_turbo;
-  friendly_fire			= maingame->friendly_fire;
-  shot_relativity			= maingame->shot_relativity;
+  frame_time		= maingame->frame_time;
+  normal_turbo		= maingame->normal_turbo;
+  f4_turbo		= maingame->f4_turbo;
+  turbo                 = normal_turbo;
+  friendly_fire		= maingame->friendly_fire;
+  shot_relativity	= maingame->shot_relativity;
 
   
   lag_frames = maingame->lag_frames;
@@ -150,74 +138,47 @@
 }
 
 
-void MainGame::play()
+int MainGame::isGameDone()
 {
-  STACKTRACE;
+  for (std::set<SubGame*>::iterator i = subgame.begin();
+       i!= subgame.end(); i++)
+    {
+      if ((*i)->isGameDone() != GAME_STATE_FINISHED)
+	{
+	  return GAME_STATE_PLAYING;
+	}
+    }
+  return GAME_STATE_FINISHED;
+}
 
+int MainGame::play()
+{
+  STACKTRACE;
+  
   set_resolution(window->w, window->h);
-
+  
   prepare();
   if (is_paused()) unpause();
-
-
-  while(!isGameDone())
+  
+  
+  while(isGameDone() == GAME_STATE_PLAYING)
     {
       //unsigned int time = get_time();
       poll_input();
       
       videosystem->poll_redraw();
-
+      
       for (std::set<SubGame*>::iterator i = subgame.begin();
 	   i!= subgame.end(); i++)
 	{
+	  if ((*i)->isGameDone() != GAME_STATE_FINISHED)
+	    {
+	      (*i)->setGameDone(GAME_STATE_PLAYING);
+	    }
 	  (*i)->play();
 	}
-      break;
     }
-	
+  return isGameDone();
 }
 
 
-
-
-#include "melee/mgame.h"    //Game stuff
-#include "melee/mcbodies.h" //asteroids & planets
-#include "melee/mship.h"    //ships
-#include "melee/mlog.h"     //networking / demo recording / demo playback
-#include "melee/mcontrol.h" //controllers & AIs
-#include "melee/mview.h"    //Views & text messages
-#include "melee/mshppan.h"  //ship panels...
-#include "melee/mitems.h"   //indicators...
-#include "melee/mfleet.h"   //fleets...
-
-class TestGame1 : public SubGame
-{
-public:
-  virtual void 	init (Log *log, const std::string& save);
-};
-
-void TestGame1::init (Log *log, const std::string& save)
-{
-  //you need to call Game::init very early on, to set stuff up... rarely do you want to do anything before that
-  SubGame::init(log, save);
-
-  //add the starscape background
-  add(new Stars());
-  add(new Asteroid()); //this adds an asteroid to the game
-}
-
-REGISTER_GAME(TestGame1, "TestGame1");
-
-class TestGame : public MainGame
-{
-public:
-  virtual void 	init (Log *log, const std::string& save)
-  {
-    MainGame::init(log,save);
-    addsubgame(new TestGame1);
-    addsubgame(new TestGame1);
-  }	
-};
-
-REGISTER_GAME(TestGame,"TestGame");
-

Modified: trunk/source/games/gamehierarchy.h
===================================================================
--- trunk/source/games/gamehierarchy.h	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/games/gamehierarchy.h	2005-02-20 13:20:59 UTC (rev 121)
@@ -36,9 +36,6 @@
   ~SubGame();
 
   virtual void init(Log *_log, const std::string& save);
-  virtual void play();
-  /// Suspend game (return to maingame)
-  virtual void stop();
 };
 
 
@@ -55,8 +52,8 @@
 
   virtual void addsubgame(SubGame *asubgame);
   virtual void removesubgame(SubGame* g);
-
-  virtual void play();
+  virtual int isGameDone();
+  virtual int play();
 };
 
 

Modified: trunk/source/games/gdefender.cpp
===================================================================
--- trunk/source/games/gdefender.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/games/gdefender.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -1,17 +1,17 @@
 /*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
 */
 
 
@@ -82,7 +82,7 @@
   /// here we check to see if the player lost the game and we add new enemies if it's time for that
   virtual void calculate ( ) ;
   
-  virtual bool isGameDone();
+  virtual int isGameDone();
   
   /// this is used to display the starbases current health
   virtual void fps();
@@ -99,7 +99,7 @@
   int time_between_attacks;
   
 protected:
-	bool lostGame;
+  bool lostGame;
 
 };
 
@@ -120,7 +120,7 @@
 }
 
 DefenderStation::DefenderStation( SpaceSprite *sprite, SpaceLocation *orbit)
-: Orbiter ( sprite, orbit, 600 ) 
+  : Orbiter ( sprite, orbit, 600 ) 
 {
   health = maxhealth = 30;
   regentime = 6000;
@@ -179,17 +179,18 @@
   return;
 }
 
-bool DefenderGame::isGameDone() {
-	if (lostGame || 
-	    defendergame->player->ship == NULL || 
-	    !defendergame->player->ship->exists()) 
-	{
-		game_done = true;
-		char buffy[500] = "";
-		sprintf(buffy, "Game Over!\n\nYou Defended the base for %d seconds.", game_time/1000);
-		tw_alert(buffy, "Ok!");
-	}
-	return Game::isGameDone();
+int DefenderGame::isGameDone() 
+{
+  if (lostGame || 
+      defendergame->player->ship == NULL || 
+      !defendergame->player->ship->exists()) 
+    {
+      setGameDone(GAME_STATE_FINISHED);
+      char buffy[500] = "";
+      sprintf(buffy, "Game Over!\n\nYou Defended the base for %d seconds.", game_time/1000);
+      tw_alert(buffy, "Ok!");
+    }
+  return Game::isGameDone();
 }
 
 void DefenderGame::preinit() 

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/games/ggob.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -83,7 +83,7 @@
 void GobGame::preinit() 
 {
   STACKTRACE;
-  Game::preinit();
+  GobGameBase::preinit();
 
   gobplayers = 0;
   gobplayer = NULL;
@@ -101,7 +101,7 @@
   defenderSprite = NULL;
 }
 
-bool GobGame::isGameDone() 
+int GobGame::isGameDone() 
 {
   bool done = true;
   for (int i = 0; i < gobplayers; i += 1) 
@@ -111,10 +111,10 @@
     }
   if (done) 
     {
-      game_done = true;
+      setGameDone(GAME_STATE_FINISHED );
       tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
     }
-  return Game::isGameDone();
+  return GobGameBase::isGameDone();
 }
 
 void GobGame::add_gobplayer(Control *control) 
@@ -164,7 +164,7 @@
 {
   STACKTRACE;
   int i;
-  Game::init(_log, save);
+  GobGameBase::init(_log, save);
   
   log_file("server.ini");
   max_enemies = get_config_int("Gob", "MaxEnemies", 32);
@@ -319,7 +319,7 @@
 void GobGame::fps() 
 {
   STACKTRACE;
-  Game::fps();
+  GobGameBase::fps();
   
   message.print((int)msecs_per_fps, 15, "enemies: %d", (int)gobenemies);
   message.print((int)msecs_per_fps, 15, "time: %d", (int)(game_time / 1000));
@@ -405,7 +405,7 @@
       p = get_player(source);
     }
 
-  Game::ship_died(who, source);
+  GobGameBase::ship_died(who, source);
   return;
 }
 
@@ -421,6 +421,35 @@
   return NULL;
 }
 
+bool GobGame::handle_key(int k)
+{
+  STACKTRACE;
+  switch (k >> 8) 
+    {
+    case KEY_F6: 
+      {
+	setGameDone(GAME_STATE_SUSPENDED);
+	return true;
+      }
+      break;
+    //don't use hardwired normal keys
+      /*
+    case KEY_H:
+      if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;
+      break;
+    case KEY_T:
+      if ((k & 255) == 'T'-'A'+1) indteamtoggle = ~indteamtoggle;
+      break;
+      */
+    default: 
+      {
+	return GobGameBase::handle_key(k);
+      }
+      break;
+    }
+  return false;
+}
+
 void GobGame::add_new_enemy() 
 {
   STACKTRACE;
@@ -1062,7 +1091,8 @@
 }
 
 
-REGISTER_GAME(GobGame, "GOB")
+//REGISTER_GAME(GobGame, "GOB")
+REGISTER_GAME(MainGobGame, "GOB")
 
 
 

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/games/ggob.h	2005-02-20 13:20:59 UTC (rev 121)
@@ -22,6 +22,8 @@
 #include "melee/mgame.h"
 #include "melee/mitems.h"
 
+#include "gamehierarchy.h"
+
 class Upgrade;
 class GobStation;
 
@@ -78,8 +80,9 @@
   virtual void death();
 };
 
-/// Full future adventure game
-class GobGame : public Game 
+typedef SubGame GobGameBase;
+/// GOB class adventure game
+class GobGame : public  GobGameBase
 {
  public:
   virtual ~GobGame();
@@ -87,7 +90,7 @@
   TeamCode enemy_team;
 
   virtual void calculate();
-  virtual bool isGameDone();
+  virtual int isGameDone();
   virtual void ship_died(Ship *who, SpaceLocation *source);
   virtual void preinit();
   virtual void init (Log *log, const std::string& save);
@@ -113,7 +116,10 @@
   char *station_pic_name[3];
   char *station_build_name[3];
   SpaceSprite *defenderSprite;
-  
+
+ protected:
+  virtual bool handle_key(int k);
+
  public:
   int num_planets;
   Planet *planet[16];
@@ -168,5 +174,17 @@
   void squiggle();
 };
 
+class MainGobGame : public MainGame
+{
+ public:
+  virtual void 	init (Log *log, const std::string& save)
+    {
+      MainGame::init(log,save);
+      addsubgame(new GobGame);
+      addsubgame(new GobGame);
+      //      addsubgame(new GobGame);
+    }	
+};
+
 #endif // TW_GOB_H_INCLUDES
 

Deleted: trunk/source/games/glegacies.cpp
===================================================================
--- trunk/source/games/glegacies.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/games/glegacies.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -1,61 +0,0 @@
-/*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-*/
-
-
-#include <stdio.h>   //standard io libary (needed for sprintf)
-#include <allegro.h> //allegro library header
-
-#include "melee.h"          //used by all TW source files.  well, mostly. 
-#include "melee/mgame.h"    //Game stuff
-#include "melee/mcbodies.h" //asteroids & planets
-#include "melee/mship.h"    //ships
-#include "melee/mshot.h"   //shots, missiles, lasers
-#include "melee/mlog.h"     //networking / demo recording / demo playback
-#include "melee/mcontrol.h" //controllers & AIs
-#include "melee/mview.h"    //Views & messages
-#include "melee/mshppan.h"  //ship panels...
-
-#include "melee/mitems.h"  //ship panels...
-#include "melee/manim.h"  //ship panels...
-#include "scp.h"
-#include "other/dialogs.h"
-
-#include "gadventure.h"
-
-/// TW Legacies Adventure Game 
-///
-
-
-std::string LegaciesGame::Save()
-{
-  tw_error("Save called");
-  return "";
-}
-
-int LegaciesGame::Load(std::string)
-{
-  return 0;
-};
-
-void LegaciesGame::quit(const char *message)
-{
-  STACKTRACE;
-  Save();
-  Game::quit(message);
-}
-
-REGISTER_GAME ( LegaciesGame, "TW:Legacies" )
-

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/melee/mframe.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -1348,9 +1348,12 @@
 	::MAX_SPEED  = this->max_speed;
 	return;
 }
-int Physics::checksum() {
+int Physics::checksum() 
+{
   STACKTRACE;
   Uint32 g = 0;
+  return g;
+
   for(std::list<SpaceLocation*>::iterator i=item.begin();i!=item.end();i++)
     {
       //if (!item[i]->detectable()) continue;
@@ -1363,6 +1366,7 @@
     }
   return g;// + (tw_random_state_checksum()) & 255));
 }
+
 void Physics::dump_state ( const char *file_name ) 
 {
 }

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/melee/mgame.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -126,7 +126,6 @@
 #define HIST_POWER 4.0
 
 #define CHECKSUM_CHANNEL Game::_channel_buffered
-//#define CHECKSUM_CHANNEL 0
 
 #ifdef _MSC_VER
 #	pragma warning( disable : 4800 ) //int -> bool, performance warning
@@ -411,12 +410,14 @@
   return;
 }
 
+
 void Game::animate(Frame *frame) 
 {
   STACKTRACE;
   Physics::animate(frame);
 }
 
+
 void Game::animate() 
 {
   STACKTRACE;
@@ -637,8 +638,6 @@
   if (active_focus_destroyed && (focus_index >= 0))
     focus[focus_index]->attributes |= ATTRIB_ACTIVE_FOCUS;
 
-
-
   Physics::calculate();
 
   gametargets.calculate();
@@ -651,7 +650,7 @@
   return;
 }
 
-void Game::play() 
+int Game::play() 
 {
   STACKTRACE;
   set_resolution(window->w, window->h);
@@ -661,38 +660,51 @@
   try 
     {
       play_music();
-      while(!isGameDone()) 
+      while(isGameDone() == GAME_STATE_PLAYING) 
 	{
 	  if(!tw_sound->playing_music())
-	    play_music();
+	    {
+	      play_music();
+	    }
 	  
 	  unsigned int time = get_time();
 	  poll_input();
 	  videosystem->poll_redraw();
 	  if ((next_tic_time <= time) && (next_render_time > game_time) && game_ready()) 
 	    {
-	      _STACKTRACE("Game::play - Game physics")
-		calculate();
+	      _STACKTRACE("Game::play - Game physics");
+	      calculate();
 	      log->flush();
 	      log->listen();
 	      if (key[KEY_F5])
-		turbo = f4_turbo;
+		{
+		  turbo = f4_turbo;
+		}
 	      else
-		turbo = normal_turbo;
+		{
+		  turbo = normal_turbo;
+		}
 	      next_tic_time += (frame_time / turbo);
 	      if ((hiccup_margin >= 0) && (next_tic_time + hiccup_margin < get_time()))
-		next_tic_time = get_time();
-	      if (next_fps_time <= game_time) {
-		next_fps_time += msecs_per_fps;
-		fps();
-	      }
+		{
+		  next_tic_time = get_time();
+		}
+	      if (next_fps_time <= game_time) 
+		{
+		  next_fps_time += msecs_per_fps;
+		  fps();
+		}
 	    }
-	  else if (interpolate_frames || (game_time > next_render_time - msecs_per_render)) {
-	    _STACKTRACE("Game::play - Game rendering")
-	      animate();
-	    next_render_time = game_time + msecs_per_render;
-	  }
-	  else idle();
+	  else if (interpolate_frames || (game_time > next_render_time - msecs_per_render)) 
+	    {
+	      _STACKTRACE("Game::play - Game rendering")
+		animate();
+	      next_render_time = game_time + msecs_per_render;
+	    }
+	  else 
+	    {
+	      idle();
+	    }
 	  while (keypressed())
 	    handle_key(readkey());
 	}
@@ -726,7 +738,7 @@
       caught_error("Ack(1)!!!\nAn error occured in the game!\nBut I don't know what error (check error log)!");
       if (__error_flag & 1) throw;
     }
-  return;
+  return isGameDone();
 }
 
 
@@ -837,7 +849,6 @@
   STACKTRACE;
   int i;
 
-  game_done = false;
   log = _log;
   if (!log) {
     log = new Log();
@@ -1035,27 +1046,34 @@
   return;
 }
 
-Game::~Game() {STACKTRACE
-		 message.out("deleteing GameEvents");
- int i;
- for (i = 0; i < events_waiting; i += 1) free(waiting_events[i]);
- delete[] waiting_events;
+Game::Game()
+{
+  _game_state = GAME_STATE_PLAYING;
+}
 
- message.out("deleteing histographs");
- delete tic_history; tic_history = NULL;
- delete render_history; render_history = NULL;
-
- tw_sound->play_music(std::string(""));
-
- message.out("deleteing game objects");
- destroy_all();
-
- message.out("other shit");
- message.flush();
-
- delete view;
- window->remove_callback(this);
- delete window;
+Game::~Game() {
+  STACKTRACE;
+  message.out("deleteing GameEvents");
+  int i;
+  for (i = 0; i < events_waiting; i += 1) 
+    free(waiting_events[i]);
+  delete[] waiting_events;
+  
+  message.out("deleteing histographs");
+  delete tic_history; tic_history = NULL;
+  delete render_history; render_history = NULL;
+  
+  tw_sound->play_music(std::string(""));
+  
+  message.out("deleteing game objects");
+  destroy_all();
+  
+  message.out("other shit");
+  message.flush();
+  
+  delete view;
+  window->remove_callback(this);
+  delete window;
 }
 
 bool Game::is_paused() 
@@ -1258,16 +1276,17 @@
 void Game::quit(const char *message) 
 {
   STACKTRACE; 
-  game_done = true;
+  setGameDone(GAME_STATE_FINISHED);
 }
 
-bool Game::isGameDone() { 
-  return game_done;
+int Game::isGameDone() 
+{ 
+  return _game_state;
 }
 
-void Game::setGameDone(const bool done)
+void Game::setGameDone(const int done)
 { 
-  game_done = done; 
+  _game_state = done; 
 }
 
 

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/melee/mgame.h	2005-02-20 13:20:59 UTC (rev 121)
@@ -63,6 +63,13 @@
   
 };
 
+enum GameStateCode
+  {
+    GAME_STATE_PLAYING = 0,
+    GAME_STATE_FINISHED,
+    GAME_STATE_SUSPENDED,
+  };
+
 /// All games types should inher from this class
 class Game : public Physics 
 {
@@ -120,6 +127,7 @@
 
   virtual void preinit();	///< pre-initialization (enough so that the destructor won't crash) 
   virtual void init(Log *log, const std::string& save);  ///< initialization (loading data, creating a few game objects, whatever)
+  Game::Game();
   virtual ~Game();              ///< deallocating memory etc.
   
   virtual void init_lag();
@@ -137,10 +145,10 @@
   virtual void prepare();   
 
   virtual void calculate();
-  virtual void play();
-  virtual void animate(Frame *frame); // stupid C++
+  /// \return game state
+  virtual int play();
+  virtual void animate(Frame *frame);
   virtual void animate();
-  //	using Physics::animate;
   
   virtual void object_died(SpaceObject *who, SpaceLocation *source);
   virtual void ship_died(Ship *who, SpaceLocation *source);
@@ -154,7 +162,8 @@
   virtual void redraw();
 
  protected:  
-  bool game_done;
+  int _game_state;
+
   /// Show ingame menu (save/load/option/quit/exit)
   virtual void GameMenu();
 
@@ -164,10 +173,10 @@
  public:
   /// sets whether the game is done, according to the rules for the
   /// gametype.
-  virtual void setGameDone(const bool done);
+  virtual void setGameDone(const int done);
 
   /// gets if the game is done.  Will wait a few seconds for dramatic effect.
-  virtual bool isGameDone();
+  virtual int isGameDone();
   
   virtual void quit(const char *message);
     

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/melee/mmain.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -1,17 +1,17 @@
 /*
-This file is part of "TW-Light" 
-                    http://tw-light.berlios.de/
-Copyright (C) 2001-2004  TimeWarp development team
+  This file is part of "TW-Light" 
+  http://tw-light.berlios.de/
+  Copyright (C) 2001-2004  TimeWarp development team
 
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
 
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
 */
 
 #include <stdlib.h>
@@ -42,393 +42,395 @@
 	
 #include "ais.h"
 
-int NormalGame::add_player (Control *c, int team_index, const char *name, const char *fleet_section, const char *fleet_file) {STACKTRACE
-	int i = num_players;
-	num_players += 1;
-	player_control = (Control**) realloc(player_control,   sizeof(Control*)   * num_players);
-	player_name    =    (char**) realloc(player_name,      sizeof(char*)      * num_players);
-//	player_panel = (ShipPanel**) realloc(player_panel,     sizeof(ShipPanel*) * num_players);
-	player_fleet =     (Fleet**) realloc(player_fleet,     sizeof(Fleet *)    * num_players);
-	player_team =    (TeamCode*) realloc(player_team,      sizeof(TeamCode)   * num_players);
-	player_control[i] = c;
-	add_focus(c, c->channel);
-//	player_panel[i] = NULL;
-	player_fleet[i] = new Fleet();
-	player_fleet[i]->reset();
-	player_name[i] = strdup(name);
-	if (team_index >= team_table_size) {
-		int i = team_table_size;
-		team_table_size = team_index + 1;
-		team_table = (TeamCode*) realloc(team_table, sizeof(TeamCode) * team_table_size);
-		for (; i < team_table_size; i += 1) {
-			if (i) team_table[i] = new_team();
-			else team_table[i] = 0;
-		}
-	}
-	if (team_index) player_team[i] = team_table[team_index];
-	else player_team[i] = new_team();
-	char sect[40];
-	sprintf(sect, "Player%d", i+1);
-	if (c->channel == channel_none) {
-		tw_error("channel_none not allowed here");
-		//log_file(fleet_file);
-		//::fleet->load(NULL, fleet_section);
-		}
-	else if (log->get_direction(c->channel) & Log::direction_write) {
-		player_fleet[i]->load(fleet_file, fleet_section);
-		log_fleet(c->channel, player_fleet[i]);
-		c->target_sign_color = ((3+i) % 7) + 1;
-		}
-	else {
-		log_fleet(c->channel, player_fleet[i]);
-		}
-	tw_set_config_file("tmp.ini");
-	set_config_string(sect, "Name", name);
-	set_config_string(sect, "Type", c->getTypeName());
-	set_config_int(sect, "Team", team_index);
-	set_config_int(sect, "Channel", c->channel);
-	set_config_int(sect, "StartingFleetCost", player_fleet[i]->getCost());
-	set_config_int(sect, "StartingFleetSize", player_fleet[i]->getSize());
-	player_fleet[i]->save(NULL, sect);
-	player_fleet[i]->save("fleets.tmp", sect);
-	return i;
-	}
+int NormalGame::add_player (Control *c, int team_index, const char *name, const char *fleet_section, const char *fleet_file) 
+{
+  STACKTRACE;
+  int i = num_players;
+  num_players += 1;
+  player_control = (Control**) realloc(player_control,   sizeof(Control*)   * num_players);
+  player_name    =    (char**) realloc(player_name,      sizeof(char*)      * num_players);
+  //	player_panel = (ShipPanel**) realloc(player_panel,     sizeof(ShipPanel*) * num_players);
+  player_fleet =     (Fleet**) realloc(player_fleet,     sizeof(Fleet *)    * num_players);
+  player_team =    (TeamCode*) realloc(player_team,      sizeof(TeamCode)   * num_players);
+  player_control[i] = c;
+  add_focus(c, c->channel);
+  //	player_panel[i] = NULL;
+  player_fleet[i] = new Fleet();
+  player_fleet[i]->reset();
+  player_name[i] = strdup(name);
+  if (team_index >= team_table_size) {
+    int i = team_table_size;
+    team_table_size = team_index + 1;
+    team_table = (TeamCode*) realloc(team_table, sizeof(TeamCode) * team_table_size);
+    for (; i < team_table_size; i += 1) {
+      if (i) team_table[i] = new_team();
+      else team_table[i] = 0;
+    }
+  }
+  if (team_index) player_team[i] = team_table[team_index];
+  else player_team[i] = new_team();
+  char sect[40];
+  sprintf(sect, "Player%d", i+1);
+  if (c->channel == channel_none) {
+    tw_error("channel_none not allowed here");
+    //log_file(fleet_file);
+    //::fleet->load(NULL, fleet_section);
+  }
+  else if (log->get_direction(c->channel) & Log::direction_write) {
+    player_fleet[i]->load(fleet_file, fleet_section);
+    log_fleet(c->channel, player_fleet[i]);
+    c->target_sign_color = ((3+i) % 7) + 1;
+  }
+  else {
+    log_fleet(c->channel, player_fleet[i]);
+  }
+  tw_set_config_file("tmp.ini");
+  set_config_string(sect, "Name", name);
+  set_config_string(sect, "Type", c->getTypeName());
+  set_config_int(sect, "Team", team_index);
+  set_config_int(sect, "Channel", c->channel);
+  set_config_int(sect, "StartingFleetCost", player_fleet[i]->getCost());
+  set_config_int(sect, "StartingFleetSize", player_fleet[i]->getSize());
+  player_fleet[i]->save(NULL, sect);
+  player_fleet[i]->save("fleets.tmp", sect);
+  return i;
+}
 
 void NormalGame::init_objects() {
   STACKTRACE;
-	int i;
-	add(new Stars());
-	Planet *planet = create_planet();
-	//Planet *planet = new Planet (size/2, planetSprite, random(planetSprite->frames()));
-	//add (planet);
-	if (view) view->camera.pos = size/2;
-	add(new WedgeIndicator(planet, 75, 4));
-	for (i = 0; i < num_asteroids; i += 1) add(new Asteroid());
-	}
+  int i;
+  add(new Stars());
+  Planet *planet = create_planet();
+  //Planet *planet = new Planet (size/2, planetSprite, random(planetSprite->frames()));
+  //add (planet);
+  if (view) view->camera.pos = size/2;
+  add(new WedgeIndicator(planet, 75, 4));
+  for (i = 0; i < num_asteroids; i += 1) add(new Asteroid());
+}
 
 void NormalGame::init_players() {
   STACKTRACE;
-	switch (log->type) {
-		case Log::log_normal: {
-			for (int i = 0; true; i += 1) {
-				char buffy[64];
-				sprintf(buffy, "Player%d", i + 1);
-				tw_set_config_file("scp.ini");
-				const char *type = get_config_string(buffy, "Type", NULL);
-				if (!type) break;
-				if (strcmp(type, "none") == 0) continue;
-				const char *name = get_config_string(buffy, "Name", buffy);
-				char config[64];
-				sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
-				//int channel = channel_server;
-				//if (strcmp(type, "WussieBot") == 0) channel = channel_none;
-				//if (strcmp(type, "MoronBot") == 0) channel = channel_none;
-				int ti = get_config_int(buffy, "Team", 0);
-				add_player(create_control(channel_server, type, config), ti, name, buffy);
-			}
-		}
-		break;
-		case Log::log_net1client:
-		case Log::log_net1server: {
-			log_file("server.ini");
-			//int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
-			//if (use_teams_menu) {
-			if (1) {
-				int j;
-				for (j = 0; j < 2; j += 1) {
-					int ch;
-					if (j == 0) ch = channel_server;
-					else ch = channel_client;
-					if (is_local(ch)) {
-						tw_set_config_file("client.ini");//each side determines whether they are using manually specified teams
-						int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
-						const char *simple_config = 
-							"[Player1]\nType=Human\nConfig=0\nTeam=0\n";
-						for (int i = 0; true; i += 1) {
-							char buffy[64];
-							sprintf(buffy, "Player%d", i + 1);
-							if (use_teams_menu) tw_set_config_file("scp.ini");
-							else set_config_data(simple_config, strlen(simple_config));
-							const char *type = get_config_string(buffy, "Type", NULL);
-							if (!type) {
-								int tmp = 0;
-								log_int(ch, tmp);
-								break;
-							}
-							if (strcmp(type, "none") == 0) continue;
-							const char *name = get_config_string(buffy, "Name", buffy);
-							char config[64];
-							sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
-							//int channel = channel_server;
-							//if (strcmp(type, "WussieBot") == 0) channel = channel_none;
-							//if (strcmp(type, "MoronBot") == 0) channel = channel_none;
-							int ti = get_config_int(buffy, "Team", 0);
-							{int tmp = 1; log_int(ch, tmp);}
-							log_int(ch, ti);
-							int name_length = strlen(name);
-							log_int(ch, name_length);
-							log_data(ch, (char*)name, name_length);
-							add_player(create_control(ch, type, config), ti, name, buffy);
-						}
-					}
-					else {
-						for (int i = 0; true; i += 1) {
-							int tmp;
-							log_int(ch, tmp);
-							if (tmp == 0) break;
-							int team;
-							char *name;
-							log_int(ch, team);
-							int name_length;
-							log_int(ch, name_length);
-							name = (char*)malloc((name_length+1)*sizeof(char));
-							log_data(ch, name, name_length);
-							name[name_length] = 0;
-							add_player(create_control(ch, "Whatever"), team, name, NULL);
-						}
-					}
-				}
-			}
-		}
-		break;
+  switch (log->type) {
+  case Log::log_normal: {
+    for (int i = 0; true; i += 1) {
+      char buffy[64];
+      sprintf(buffy, "Player%d", i + 1);
+      tw_set_config_file("scp.ini");
+      const char *type = get_config_string(buffy, "Type", NULL);
+      if (!type) break;
+      if (strcmp(type, "none") == 0) continue;
+      const char *name = get_config_string(buffy, "Name", buffy);
+      char config[64];
+      sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
+      //int channel = channel_server;
+      //if (strcmp(type, "WussieBot") == 0) channel = channel_none;
+      //if (strcmp(type, "MoronBot") == 0) channel = channel_none;
+      int ti = get_config_int(buffy, "Team", 0);
+      add_player(create_control(channel_server, type, config), ti, name, buffy);
+    }
+  }
+    break;
+  case Log::log_net1client:
+  case Log::log_net1server: {
+    log_file("server.ini");
+    //int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
+    //if (use_teams_menu) {
+    if (1) {
+      int j;
+      for (j = 0; j < 2; j += 1) {
+	int ch;
+	if (j == 0) ch = channel_server;
+	else ch = channel_client;
+	if (is_local(ch)) {
+	  tw_set_config_file("client.ini");//each side determines whether they are using manually specified teams
+	  int use_teams_menu = get_config_int("Network", "NetworkMeleeUseTeams", 0);
+	  const char *simple_config = 
+	    "[Player1]\nType=Human\nConfig=0\nTeam=0\n";
+	  for (int i = 0; true; i += 1) {
+	    char buffy[64];
+	    sprintf(buffy, "Player%d", i + 1);
+	    if (use_teams_menu) tw_set_config_file("scp.ini");
+	    else set_config_data(simple_config, strlen(simple_config));
+	    const char *type = get_config_string(buffy, "Type", NULL);
+	    if (!type) {
+	      int tmp = 0;
+	      log_int(ch, tmp);
+	      break;
+	    }
+	    if (strcmp(type, "none") == 0) continue;
+	    const char *name = get_config_string(buffy, "Name", buffy);
+	    char config[64];
+	    sprintf(config, "Config%d", get_config_int(buffy, "Config", 0));
+	    //int channel = channel_server;
+	    //if (strcmp(type, "WussieBot") == 0) channel = channel_none;
+	    //if (strcmp(type, "MoronBot") == 0) channel = channel_none;
+	    int ti = get_config_int(buffy, "Team", 0);
+	    {int tmp = 1; log_int(ch, tmp);}
+	    log_int(ch, ti);
+	    int name_length = strlen(name);
+	    log_int(ch, name_length);
+	    log_data(ch, (char*)name, name_length);
+	    add_player(create_control(ch, type, config), ti, name, buffy);
+	  }
 	}
-	return;
+	else {
+	  for (int i = 0; true; i += 1) {
+	    int tmp;
+	    log_int(ch, tmp);
+	    if (tmp == 0) break;
+	    int team;
+	    char *name;
+	    log_int(ch, team);
+	    int name_length;
+	    log_int(ch, name_length);
+	    name = (char*)malloc((name_length+1)*sizeof(char));
+	    log_data(ch, name, name_length);
+	    name[name_length] = 0;
+	    add_player(create_control(ch, "Whatever"), team, name, NULL);
+	  }
+	}
+      }
+    }
+  }
+    break;
+  }
+  return;
 }
 
 void NormalGame::set_resolution(int screen_x, int screen_y) {
   STACKTRACE;
-	int view_x, view_y;
-	view_x = screen_x;
-	view_y = screen_y;
-	int n, m;
-	n = 99;//int(ceil(double(num_players) / int(view_y / PANEL_HEIGHT)));
-	if (n) m = int(ceil(num_players / (double)n));
-	else m = 0;
-	//view->set_window(screen, 0, 0, view_x - PANEL_WIDTH * m, view_y);
-	redraw();
-	return;
-	}
+  int view_x, view_y;
+  view_x = screen_x;
+  view_y = screen_y;
+  int n, m;
+  n = 99;//int(ceil(double(num_players) / int(view_y / PANEL_HEIGHT)));
+  if (n) m = int(ceil(num_players / (double)n));
+  else m = 0;
+  //view->set_window(screen, 0, 0, view_x - PANEL_WIDTH * m, view_y);
+  redraw();
+  return;
+}
 
 void NormalGame::preinit() {
   STACKTRACE;
-	Game::preinit();
-	player_control = NULL;
-	player_name = NULL;
-//	player_panel = NULL;
-	player_fleet = NULL;
+  Game::preinit();
+  player_control = NULL;
+  player_name = NULL;
+  //	player_panel = NULL;
+  player_fleet = NULL;
 
-	player_team = NULL;
-	team_table = NULL;
-	num_kills = 0;
-	kills = NULL;
-	num_players = 0;
-	}
+  player_team = NULL;
+  team_table = NULL;
+  num_kills = 0;
+  kills = NULL;
+  num_players = 0;
+}
 void NormalGame::init(Log *_log, const std::string& save) {
   STACKTRACE;
-	Game::init(_log, save);
+  Game::init(_log, save);
 
-	team_table_size = 0;
+  team_table_size = 0;
 
-	view->window->locate(0,0,0,0,0,0.9,0,1);
+  view->window->locate(0,0,0,0,0,0.9,0,1);
 
-	tw_delete_file("tmp.ini");
-	tw_delete_file("fleets.tmp");
-	tw_set_config_file ("tmp.ini");
-	set_config_string (NULL, "Ignorethis", "");
-	if (!log->playback) init_players();
-	log_file("tmp.ini");
-	if (log->playback) {
-		for (int i = 0; true; i += 1) {
-			char buffy[64];
-			sprintf(buffy, "Player%d", i + 1);
-			log_file("tmp.ini");
-			const char *type = get_config_string(buffy, "Type", NULL);
-			if (!type) break;
-			const char *name = get_config_string(buffy, "Name", buffy);
-			int channel = get_config_int(buffy, "Channel", -2);
-			int ti = get_config_int(buffy, "Team", 0);
-			add_player(create_control(channel, type), ti, name, buffy);
-			player_fleet[i]->load(NULL, buffy);
-			player_fleet[i]->save("fleets.tmp", buffy);
-			}
-		}
+  tw_delete_file("tmp.ini");
+  tw_delete_file("fleets.tmp");
+  tw_set_config_file ("tmp.ini");
+  set_config_string (NULL, "Ignorethis", "");
+  if (!log->playback) init_players();
+  log_file("tmp.ini");
+  if (log->playback) {
+    for (int i = 0; true; i += 1) {
+      char buffy[64];
+      sprintf(buffy, "Player%d", i + 1);
+      log_file("tmp.ini");
+      const char *type = get_config_string(buffy, "Type", NULL);
+      if (!type) break;
+      const char *name = get_config_string(buffy, "Name", buffy);
+      int channel = get_config_int(buffy, "Channel", -2);
+      int ti = get_config_int(buffy, "Team", 0);
+      add_player(create_control(channel, type), ti, name, buffy);
+      player_fleet[i]->load(NULL, buffy);
+      player_fleet[i]->save("fleets.tmp", buffy);
+    }
+  }
 
 
-	prepare();
-	init_objects();
+  prepare();
+  init_objects();
 
-	next_choose_new_ships_time = game_time + 200;
+  next_choose_new_ships_time = game_time + 200;
 
-	// team and health indicators.
-	indteamtoggle = 0;
-	indhealthtoggle = 0;
+  // team and health indicators.
+  indteamtoggle = 0;
+  indhealthtoggle = 0;
 
-	return;
-	}
+  return;
+}
 
 NormalGame::~NormalGame() {STACKTRACE
-	if (player_control) free (player_control);
-	int i;
-	if (player_name) {
-		for (i = 0; i < num_players; i += 1) {
-			free(player_name[i]);
-			}
-		free(player_name);
-		}
-//	if (player_panel) free (player_panel);
+			     if (player_control) free (player_control);
+ int i;
+ if (player_name) {
+   for (i = 0; i < num_players; i += 1) {
+     free(player_name[i]);
+   }
+   free(player_name);
+ }
+ //	if (player_panel) free (player_panel);
 
-	if (player_team) free(player_team);
-	if (kills) free(kills);
-	}
+ if (player_team) free(player_team);
+ if (kills) free(kills);
+}
 
 static int kill_all_delay_counter = 0;
 void NormalGame::calculate() {
   STACKTRACE;
-	Game::calculate();
-	if (next_choose_new_ships_time <= game_time) {
-		choose_new_ships();
-		next_choose_new_ships_time = game_time + 24*60*60*1000;
-	}
+  Game::calculate();
+  if (next_choose_new_ships_time <= game_time) {
+    choose_new_ships();
+    next_choose_new_ships_time = game_time + 24*60*60*1000;
+  }
 
-	// specially for play-testers:
-	// kill all ships and ship-objects in the melee-game
-	if (kill_all_delay_counter > 0)
+  // specially for play-testers:
+  // kill all ships and ship-objects in the melee-game
+  if (kill_all_delay_counter > 0)
+    {
+      kill_all_delay_counter -= frame_time;
+    } else {
+
+      if (key[KEY_LCONTROL] && key[KEY_ALT] && key[KEY_K])
 	{
-		kill_all_delay_counter -= frame_time;
-	} else {
+	  kill_all_delay_counter += 1000;	// 1 second delay
 
-		if (key[KEY_LCONTROL] && key[KEY_ALT] && key[KEY_K])
-		{
-			kill_all_delay_counter += 1000;	// 1 second delay
-
 			
-			for(std::list<SpaceLocation*>::iterator i=physics->item.begin();i!=physics->item.end();i++)
-			  {
-			    SpaceLocation *o;
-			    o = *i;
-			    if (!(o && o->exists()))
-			      continue;
-			    if (o->isPlanet() || o->isAsteroid())
-			      continue;
-			    o->die();
-			  }
-		}
+	  for(std::list<SpaceLocation*>::iterator i=physics->item.begin();i!=physics->item.end();i++)
+	    {
+	      SpaceLocation *o;
+	      o = *i;
+	      if (!(o && o->exists()))
+		continue;
+	      if (o->isPlanet() || o->isAsteroid())
+		continue;
+	      o->die();
+	    }
 	}
+    }
 
 
-	return;
-	}
+  return;
+}
 
 void NormalGame::ship_died(Ship *who, SpaceLocation *source) {
   STACKTRACE;
-	char victimName[80] = "";
-	char killerName[80] = "";
-	int victimID = -1;
-	int killerID = -1;
+  char victimName[80] = "";
+  char killerName[80] = "";
+  int victimID = -1;
+  int killerID = -1;
 
-	// determine who died.
-	if (who && who->control) {
-		for (int i=0; i<num_players; i++) {
-			if (player_control[i] == who->control) {
-				victimID = i;
-				break;
-			}
-		}
-		strcpy(victimName, player_name[victimID]);
-	}
+  // determine who died.
+  if (who && who->control) {
+    for (int i=0; i<num_players; i++) {
+      if (player_control[i] == who->control) {
+	victimID = i;
+	break;
+      }
+    }
+    strcpy(victimName, player_name[victimID]);
+  }
 	
-	// determine who killed, but skip it if nobody died.
-	if (strlen(victimName)>0 && source) {
+  // determine who killed, but skip it if nobody died.
+  if (strlen(victimName)>0 && source) {
 		
-		if ( ! source->isPlanet())
-		{
-			if (source->ship && source->ship->control) {
-				for (int i=0; i<num_players; i++) {
-					if (player_control[i] == source->ship->control) {
-						killerID = i;
-						break;
-					}
-				}
-				strcpy(killerName, player_name[killerID]);
-			}
-		}
+    if ( ! source->isPlanet())
+      {
+	if (source->ship && source->ship->control) {
+	  for (int i=0; i<num_players; i++) {
+	    if (player_control[i] == source->ship->control) {
+	      killerID = i;
+	      break;
+	    }
+	  }
+	  strcpy(killerName, player_name[killerID]);
 	}
+      }
+  }
 	
-	if (killerID == victimID) {
-		message.print(5000,15,"%s killed itself.", victimName);
-	}
-	else { 
-		if (source && source->isPlanet())
-			message.print(5000,15,"%s dove into a planet.", victimName);
-		else {
-			if (strlen(killerName) > 0) {
-				message.print(5000,15,"%s killed %s.", killerName, victimName);
-			}
-			else {
-				message.print(5000,15,"%s died.", victimName);
-			}
-		}
-	}
+  if (killerID == victimID) {
+    message.print(5000,15,"%s killed itself.", victimName);
+  }
+  else { 
+    if (source && source->isPlanet())
+      message.print(5000,15,"%s dove into a planet.", victimName);
+    else {
+      if (strlen(killerName) > 0) {
+	message.print(5000,15,"%s killed %s.", killerName, victimName);
+      }
+      else {
+	message.print(5000,15,"%s died.", victimName);
+      }
+    }
+  }
 	
-	if ( (victimID != -1) &&  
-		 (player_fleet[victimID]->getSize() <= 0) )
-	{
-		message.print(8000,15,"%s has been eliminated!", victimName);
-	}
+  if ( (victimID != -1) &&  
+       (player_fleet[victimID]->getSize() <= 0) )
+    {
+      message.print(8000,15,"%s has been eliminated!", victimName);
+    }
 	
-	int n = game_time + 4000;
-	if (next_choose_new_ships_time > n) next_choose_new_ships_time = n;
-	Game::ship_died(who, source);
-	return;
-	}
+  int n = game_time + 4000;
+  if (next_choose_new_ships_time > n) next_choose_new_ships_time = n;
+  Game::ship_died(who, source);
+  return;
+}
 
 void NormalGame::display_stats() {
   STACKTRACE;
-	pause();
-	int i;
-	for (i = 0; i < num_players; i += 1) {
-		Fleet *fleet = player_fleet[i];
-		switch (log->type) {
-			case Log::log_net1client:
-			case Log::log_net1server: {
-//				if (log->get_direction(player_control[i]->channel) & Log::direction_write) 
-					message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
-//				else
-//					message.print(6000, 15, "%s status: : %d / %d points", buffy, fleet->cost, player_total_fleet[i]);
-			}
-			break;
-			default: {
-				message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
-			}
-			break;
-		}
-	}
-	unpause();
-	return;
+  pause();
+  int i;
+  for (i = 0; i < num_players; i += 1) {
+    Fleet *fleet = player_fleet[i];
+    switch (log->type) {
+    case Log::log_net1client:
+    case Log::log_net1server: {
+      //				if (log->get_direction(player_control[i]->channel) & Log::direction_write) 
+      message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
+      //				else
+      //					message.print(6000, 15, "%s status: : %d / %d points", buffy, fleet->cost, player_total_fleet[i]);
+    }
+      break;
+    default: {
+      message.print(6000, 15, "%s status: : %d / ?? Ships, %d / ??? points", player_name[i], fleet->getSize(), fleet->getCost());
+    }
+      break;
+    }
+  }
+  unpause();
+  return;
 }
 bool NormalGame::handle_key(int k)
 {
   STACKTRACE;
-	switch (k >> 8) {
-		default: {
-			return Game::handle_key(k);
-			}
-		break;
-		case KEY_F6: {
-			display_stats();
-			return true;
-			}
-		break;
-		//don't use hardwired normal keys
-		case KEY_H:
-			if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;
-			break;
-		case KEY_T:
-			if ((k & 255) == 'T'-'A'+1) indteamtoggle = ~indteamtoggle;
-			break;
-		}
-	return false;
-	}
+  switch (k >> 8) {
+  default: {
+    return Game::handle_key(k);
+  }
+    break;
+  case KEY_F6: {
+    display_stats();
+    return true;
+  }
+    break;
+    //don't use hardwired normal keys
+  case KEY_H:
+    if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;
+    break;
+  case KEY_T:
+    if ((k & 255) == 'T'-'A'+1) indteamtoggle = ~indteamtoggle;
+    break;
+  }
+  return false;
+}
 
 
 
@@ -436,12 +438,12 @@
 class TeamIndicator : public Presence
 {
 public:
-	int		*indtoggle;
-	Ship	*mother;
-	TeamIndicator(Ship *creator, int *toggle);
+  int		*indtoggle;
+  Ship	*mother;
+  TeamIndicator(Ship *creator, int *toggle);
 
-	virtual void calculate();
-	virtual void animate(Frame *space);
+  virtual void calculate();
+  virtual void animate(Frame *space);
 };
 
 
@@ -548,7 +550,7 @@
   return;
 }
 
-bool NormalGame::isGameDone() 
+int NormalGame::isGameDone() 
 {
   STACKTRACE;
   enum {MAX_VICTORY_MESSAGE=500};
@@ -588,7 +590,7 @@
     //either there's one team left standing, or none. :)
     // either way, the game is over.
     if (numAliveTeams <= 1) {
-      game_done = true;
+      setGameDone( GAME_STATE_FINISHED);
       if (numAliveTeams==1) {
 	for (int i=0; i<num_players; i++) {
 	  if ( ( player_fleet[i] && 
@@ -598,21 +600,21 @@
 		player_control[i]->ship) )
 	    {
 	      if (player_control[i]->isHuman()) {
-			message.print(8000,15,"%s won the match!", player_name[i]);
-			sprintf(victoryMessage, "%s won the match!", player_name[i]);
-			sprintf(victoryAcknowledgeText, "Woohoo!");
+		message.print(8000,15,"%s won the match!", player_name[i]);
+		sprintf(victoryMessage, "%s won the match!", player_name[i]);
+		sprintf(victoryAcknowledgeText, "Woohoo!");
 	      } else {
-			message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
-			sprintf(victoryMessage, "%s won the match!", control_name[ player_control[i]->getControlType() ]);
-			sprintf(victoryAcknowledgeText, "Awww...");
-		  }
+		message.print(8000,15,"%s won the match!", control_name[ player_control[i]->getControlType() ]);
+		sprintf(victoryMessage, "%s won the match!", control_name[ player_control[i]->getControlType() ]);
+		sprintf(victoryAcknowledgeText, "Awww...");
+	      }
 	      break;
 	    }
 	}
       } else {
-	     message.print(8000,15,"Match ends in a draw!");
-	     sprintf(victoryMessage, "Match ends in a draw!");
-	     sprintf(victoryAcknowledgeText, "Darn, maybe next time!");
+	message.print(8000,15,"Match ends in a draw!");
+	sprintf(victoryMessage, "Match ends in a draw!");
+	sprintf(victoryAcknowledgeText, "Darn, maybe next time!");
       }
     }
     free(teams);
@@ -621,7 +623,7 @@
   bool done = Game::isGameDone();
   
   if (done && strlen(victoryMessage)>0) {
-  	  tw_alert(victoryMessage, victoryAcknowledgeText);
+    tw_alert(victoryMessage, victoryAcknowledgeText);
   }
 
   return done;
@@ -631,19 +633,19 @@
 TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
 {
   STACKTRACE;
-	indtoggle = atoggle;
-	mother = s;
+  indtoggle = atoggle;
+  mother = s;
 }
 
 void TeamIndicator::calculate()
 {
   STACKTRACE;
-	if ( !(mother && mother->exists()) )
-	{
-		mother = 0;
-		state = 0;
-		return;
-	}
+  if ( !(mother && mother->exists()) )
+    {
+      mother = 0;
+      state = 0;
+      return;
+    }
 }
 
 void TeamIndicator::animate(Frame *space) {
@@ -673,41 +675,41 @@
 }
 void NormalGame::showHelpText() {
   STACKTRACE;
-	const char * file = data_full_path("ingame.txt").c_str();
-	char text[10000] = "";
-	char controlHelp[3000] = "";
+  const char * file = data_full_path("ingame.txt").c_str();
+  char text[10000] = "";
+  char controlHelp[3000] = "";
 	
-	sprintf(text, "In-Game Keys:\n");
-	for (int i=0; i<num_players; i++) {
-		if (player_control[i])// && player_control[i]->isHuman() ) {
-		{
-			strcpy(controlHelp, "");
-			player_control[i]->getHelpText(controlHelp);
-			strcat(controlHelp, "\n");
+  sprintf(text, "In-Game Keys:\n");
+  for (int i=0; i<num_players; i++) {
+    if (player_control[i])// && player_control[i]->isHuman() ) {
+      {
+	strcpy(controlHelp, "");
+	player_control[i]->getHelpText(controlHelp);
+	strcat(controlHelp, "\n");
 			
-			strcat(text, controlHelp);
-		}
-	}
+	strcat(text, controlHelp);
+      }
+  }
 	
-	int i;
-	PACKFILE *f;
-	char * willy = NULL;
-	f = pack_fopen (file, F_READ);
-	if (!f) {
-		willy = (char*) malloc(strlen(file)+strlen("Failed to load file \"\"")+1);
-		sprintf(text, "Failed to load file \"%s\"",file);
-	}
-	else {
-		i = file_size(file);
-		willy = (char*)malloc(i+1);
-		i = pack_fread (willy, i, f);
-		pack_fclose(f);
-		willy[i] = 0;
-	}
-	strcat(text, willy);
-	show_text(text);
-	free(willy); // now this is funny :)
-	return;
+  int i;
+  PACKFILE *f;
+  char * willy = NULL;
+  f = pack_fopen (file, F_READ);
+  if (!f) {
+    willy = (char*) malloc(strlen(file)+strlen("Failed to load file \"\"")+1);
+    sprintf(text, "Failed to load file \"%s\"",file);
+  }
+  else {
+    i = file_size(file);
+    willy = (char*)malloc(i+1);
+    i = pack_fread (willy, i, f);
+    pack_fclose(f);
+    willy[i] = 0;
+  }
+  strcat(text, willy);
+  show_text(text);
+  free(willy); // now this is funny :)
+  return;
 }
 
 

Modified: trunk/source/melee/mmain.h
===================================================================
--- trunk/source/melee/mmain.h	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/melee/mmain.h	2005-02-20 13:20:59 UTC (rev 121)
@@ -53,7 +53,7 @@
   void display_stats();
 
   virtual int add_player (Control *c, int team_index, const char *name, const char *fleet, const char *fleet_file = "fleets.ini") ;
-  virtual bool isGameDone();
+  virtual int isGameDone();
   int num_players;
   Control **player_control;
   //	ShipPanel **player_panel;

Modified: trunk/source/other/dialogs.cpp
===================================================================
--- trunk/source/other/dialogs.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/other/dialogs.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -289,6 +289,7 @@
 };
 
 // MELEE_EX - dialog structure
+
 DIALOG melee_ex_dialog[] = {
   // (dialog proc)     (x)  (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
   { d_shadow_box_proc, 40,  40,   240,  185,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/source/scp.cpp	2005-02-20 13:20:59 UTC (rev 121)
@@ -160,7 +160,7 @@
 void play_demo(const char *file_name = "demo.dmo") ;
 void play_game(const char *_gametype_name, const std::string& save, Log *_log = NULL) ;
 void play_net1client ( const char * address = NULL, int port = -1 ) ;
-void play_net1server ( const char *_gametype_name, int port = -1 ) ;
+void play_net1server ( int port = -1 ) ;
 
 int getKey();
 
@@ -453,8 +453,8 @@
   log->set_all_directions(Log::direction_read);
   log->set_direction(Game::channel_client , Log::direction_write | Log::direction_read | NetLog::direction_immediate);
   log->set_direction(Game::channel_client + Game::_channel_buffered, Log::direction_write | Log::direction_read);
-  
-  set_config_file("client.ini");
+
+  tw_set_config_file("client.ini");
   char address[128];
   int port, i;
   while (!log->net.isConnected()) {
@@ -489,7 +489,7 @@
   return;
 }
 
-void play_net1server(const char *_gametype_name, int _port) 
+void play_net1server( int _port) 
 {
   STACKTRACE;
   NetLog *log = new NetLog();
@@ -501,7 +501,7 @@
   log->set_direction(Game::channel_client + Game::_channel_buffered, Log::direction_read);
   log->set_direction(Game::channel_server + Game::_channel_buffered, Log::direction_write | Log::direction_read);
   
-  set_config_file("client.ini");
+  tw_set_config_file("client.ini");
   int port;
   while (!log->net.isConnected()) 
     {
@@ -519,7 +519,7 @@
   log->net.optimize4latency();
   message.out("connection established");
   
-  play_game(_gametype_name, "", log);
+  play_game("Melee", "", log);
   
   return;
 }
@@ -1037,8 +1037,7 @@
     }
     break;
   case MELEE_EX_DIALOG_PLAY_NET1SERVER: {
-    const char *gname = select_game_menu();
-    if (gname) play_net1server(gname);
+    play_net1server();
   }
     break;
   case MELEE_EX_DIALOG_PLAY_NET1CLIENT: {

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-02-19 12:14:45 UTC (rev 120)
+++ trunk/sources.lst	2005-02-20 13:20:59 UTC (rev 121)
@@ -22,7 +22,6 @@
 source/games/ggob.cpp
 source/games/gflmelee.cpp
 source/games/gdefender.cpp
-source/games/glegacies.cpp
 source/melee/mlog.cpp
 source/melee/mitems.cpp
 source/melee/mnet1.cpp



From yurand at sheep.berlios.de  Sat Feb 26 12:50:48 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 26 Feb 2005 12:50:48 +0100
Subject: [Tw-light-svn] r122 - in trunk: . gamedata gamedata/xml gamedata/xml/GOB gamedata/xslt source source/games source/melee source/other
Message-ID: <200502261150.j1QBom9A002090@sheep.berlios.de>

Author: yurand
Date: 2005-02-26 12:50:40 +0100 (Sat, 26 Feb 2005)
New Revision: 122

Added:
   trunk/gamedata/xml/
   trunk/gamedata/xml/GOB/
   trunk/gamedata/xml/GOB/start.xml
   trunk/gamedata/xslt/
   trunk/gamedata/xslt/load.xsl
Modified:
   trunk/makefile
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee/mgame.cpp
   trunk/source/other/gup.cpp
   trunk/source/scp.cpp
   trunk/sources.lst
Log:
Adding XSLT support, linux only version for now,
It is possible to customize GOB game object using
gamedata/xml/GOB/start.xml now.
 


Added: trunk/gamedata/xml/GOB/start.xml
===================================================================
--- trunk/gamedata/xml/GOB/start.xml	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/gamedata/xml/GOB/start.xml	2005-02-26 11:50:40 UTC (rev 122)
@@ -0,0 +1,55 @@
+<GOB>
+  <Area x="24000" y="24000">
+  <SpaceObjects>
+    <Planet_with_station
+      planet_index="0"
+      datafile="gob.dat"
+      stationSprite="station0sprite"
+      station_pic_name="gob.dat#station0picture.bmp"
+      station_build_name="supbl"
+    />
+    <Planet_with_station
+      planet_index="1"
+      datafile="gob.dat"
+      stationSprite="station1sprite"
+      station_pic_name="gob.dat#station1picture.bmp"
+      station_build_name="orzne"
+    />
+    <Planet_with_station
+      planet_index="2"
+      datafile="gob.dat"
+      stationSprite="station2sprite"
+      station_pic_name="gob.dat#station2picture.bmp"
+      station_build_name="kohma"
+    />
+    <Planet_with_station
+      planet_index="1"
+      datafile="gob.dat"
+      stationSprite="station1sprite"
+      station_pic_name="gob.dat#station1picture.bmp"
+      station_build_name="utwju"
+    />
+    <NEW_ENEMY/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+    <GobAsteroid/>
+  </SpaceObjects>
+  </Area>
+</GOB>
\ No newline at end of file

Added: trunk/gamedata/xslt/load.xsl
===================================================================
--- trunk/gamedata/xslt/load.xsl	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/gamedata/xslt/load.xsl	2005-02-26 11:50:40 UTC (rev 122)
@@ -0,0 +1,38 @@
+<xsl:stylesheet version="1.0"
+  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+  xmlns:tw="http://tw-light.berlios.de">
+
+
+<xsl:template match="*">
+  <xsl:apply-templates/>
+</xsl:template>
+
+<xsl:template match="Area">
+  <xsl:value-of select="tw:SetMapSize(@x, at y)"/>
+  <xsl:apply-templates/>    
+</xsl:template>
+
+<!-- Call game::prepare before adding space objects -->
+<xsl:template match="SpaceObjects">
+    <xsl:value-of select="tw:prepare()"/> 
+    <xsl:value-of select="tw:AddStars()"/>	
+    <xsl:apply-templates/>
+</xsl:template>
+
+<xsl:template match="GobAsteroid">
+   <xsl:value-of select="tw:AddGobAsteroid()"/>
+</xsl:template>
+
+<xsl:template match="NEW_ENEMY">
+    <xsl:value-of select="tw:AddNewEnemy()"/>
+</xsl:template>
+
+<xsl:template match="Planet_with_station">
+    <xsl:value-of select="tw:AddPlanetWithStation(@planet_index,
+                                                  @datafile,
+						  @stationSprite,
+						  @station_pic_name,
+						  @station_build_name)"/>
+</xsl:template>
+
+</xsl:stylesheet>

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/makefile	2005-02-26 11:50:40 UTC (rev 122)
@@ -76,7 +76,7 @@
 CFLAGS += -DTW_SVNVERSION=\"$(SVNVERSION)\"
 
 VPATH = tests source source/libraries/agup source/ais source/games \
-        source/melee source/tests \
+        source/melee source/tests source/xslt \
         source/other source/ships source/sc1ships source/sc2ships \
         source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
@@ -121,9 +121,9 @@
 	TIMESTAMP = ${shell LC_TIME="POSIX" date +%c}
 	EXPDIR=tw-light-$(PRODUCTVERSION)r$(SVNVERSION)
 	CFLAGS += -DLINUX
-	INCLUDES := ${shell allegro-config --cflags} ${shell sdl-config --cflags} 
+	INCLUDES := ${shell allegro-config --cflags} ${shell sdl-config --cflags} ${shell xslt-config --cflags} ${shell xmlwrapp-config --cflags} 
 	CFLAGS += $(INCLUDES)
-	LIBS_CONFIG := ${shell allegro-config --libs} -pthread ${shell sdl-config --libs} 
+	LIBS_CONFIG := ${shell allegro-config --libs} -pthread ${shell sdl-config --libs} ${shell xslt-config --libs}  ${shell xmlwrapp-config --libs} 
 	LIBS += $(LIBS_CONFIG)
 endif
 

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/source/games/ggob.cpp	2005-02-26 11:50:40 UTC (rev 122)
@@ -91,13 +91,6 @@
   max_enemies = 0;
   gobenemy = NULL;
 
-  int i;
-  for (i = 0; i < 3; i += 1)
-    stationSprite[i] = NULL;
-  for (i = 0; i < 3; i += 1)
-    station_pic_name[i] = NULL;
-  for (i = 0; i < 3; i += 1)
-    station_build_name[i] = NULL;
   defenderSprite = NULL;
 }
 
@@ -111,8 +104,11 @@
     }
   if (done) 
     {
-      setGameDone(GAME_STATE_FINISHED );
-      tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
+      if(_game_state != GAME_STATE_FINISHED)
+	{
+	  setGameDone(GAME_STATE_FINISHED );
+	  tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
+	}
     }
   return GobGameBase::isGameDone();
 }
@@ -159,6 +155,19 @@
   */
 }
 
+SpaceSprite* GobGame::LoadStationSprite(std::string datafile, std::string name)
+{
+  DATAFILE *tmpdata; 
+  tmpdata = load_datafile_object(datafile.c_str(), name.c_str());
+  if (!tmpdata) 
+    {
+      tw_error( (std::string("couldn't find ") + datafile +  " " + name).c_str() );
+    }
+  SpaceSprite* ss = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
+  unload_datafile_object(tmpdata);
+  ss->permanent_phase_shift(8);  
+  return ss;
+}
 
 void GobGame::init(Log *_log, const std::string& save) 
 {
@@ -169,64 +178,16 @@
   log_file("server.ini");
   max_enemies = get_config_int("Gob", "MaxEnemies", 32);
   gobenemy = (GobEnemy**) malloc(sizeof(GobEnemy*) * max_enemies);
-  
-  size = Vector2(24000, 24000);
-  
-  enemy_team = new_team();
-  
-  DATAFILE *tmpdata; 
-  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station0sprite");
-  if (!tmpdata) 
-    tw_error( "couldn't find gob.dat#station0sprite");
-  stationSprite[0] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
-  unload_datafile_object(tmpdata);
-  stationSprite[0]->permanent_phase_shift(8);
 
-  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station1sprite");
-  if (!tmpdata) 
-    tw_error ("couldn't find gob.dat#station1sprite");
-  stationSprite[1] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
-  unload_datafile_object(tmpdata);
-  stationSprite[1]->permanent_phase_shift(8);
-  
-  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "station2sprite");
-  if (!tmpdata) 
-    tw_error ("couldn't find gob.dat#station2sprite");
-  stationSprite[2] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
-  unload_datafile_object(tmpdata);
-  stationSprite[2]->permanent_phase_shift(8);
-  
-  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "defender");
-  if (!tmpdata) 
-    tw_error ("couldn't find gob.dat#defender");
-  defenderSprite = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED);
-  unload_datafile_object(tmpdata);
-  
+  enemy_team = new_team();
 	
-  station_pic_name[0] = "gob.dat#station0picture.bmp";
-  station_pic_name[1] = "gob.dat#station1picture.bmp";
-  station_pic_name[2] = "gob.dat#station2picture.bmp";
-  station_build_name[0] = "supbl";
-  station_build_name[1] = "orzne";
-  station_build_name[2] = "kohma";
-  
-  prepare();
+   if(Load(data_full_path("xml/GOB/start.xml")) == 1)
+    {
+      tw_error("unable to locate start.xml");
+    };
+       
+   //  for (i = 0; i < 19; i += 1) add(new GobAsteroid());
 
-  add(new Stars());
-	
-  num_planets = 0;
-  i = 0;
-  add_planet_and_station(meleedata.planetSprite, i, 
-			 stationSprite[i], station_build_name[i], station_pic_name[i]);
-  i = 1;
-  add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
-  i = 2;
-  add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
-  i = random() % 3;
-  add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], "utwju", station_pic_name[i]);
-  
-  for (i = 0; i < 19; i += 1) add(new GobAsteroid());
-
   int server_players, client_players;
   tw_set_config_file("client.ini");
   server_players = client_players = get_config_int("Gob", "NumPlayers", 1);
@@ -257,11 +218,13 @@
       s->translate(rotate(Vector2(260, 120), angle));
       s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
     }
-  
+
   for (i = 0; i < gobplayers; i += 1) add ( new RainbowRift() );
   
   next_add_new_enemy_time = 1000;
-  add_new_enemy();
+
+       //  add_new_enemy();
+
   this->change_view("Hero");
   view->window->locate(
 		       0,0,
@@ -271,10 +234,20 @@
 		       );
   return;
 }
+
+GobGame::GobGame()
+{
+  DATAFILE *tmpdata; 
+  tmpdata = load_datafile_object(data_full_path("gob.dat").c_str(), "defender");
+  if (!tmpdata) 
+    tw_error ("couldn't find gob.dat#defender");
+  defenderSprite = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED);
+  unload_datafile_object(tmpdata);  
+
+  num_planets = 0;
+}
+
 GobGame::~GobGame() {
-  delete stationSprite[0];
-  delete stationSprite[1];
-  delete stationSprite[2];
   delete defenderSprite;
   int i;
   for (i = 0; i < gobplayers; i += 1) 
@@ -290,11 +263,14 @@
   return;
 }
 
-void GobGame::add_planet_and_station ( SpaceSprite *planet_sprite, 
-				       int planet_index, SpaceSprite *station_sprite, 
-				       const char *builds, const char *background) 
+void GobGame::add_planet_and_station ( int planet_index, 
+				       std::string datafile,
+				       std::string stationSprite,
+				       std::string station_pic_name,
+				       std::string station_build_name
+				       )
 {
-  Planet *p = new Planet (size/2, planet_sprite, planet_index);
+  Planet *p = new Planet (size/2, meleedata.planetSprite, planet_index);
   if (num_planets) while (true) 
     {
       SpaceLocation *n;
@@ -305,7 +281,8 @@
     }
   add ( p );
   
-  GobStation *gs = new GobStation(station_sprite, p, builds, background);
+  SpaceSprite *station_sprite = LoadStationSprite(data_full_path(datafile), stationSprite);
+  GobStation *gs = new GobStation(station_sprite, p, station_build_name.c_str(), station_pic_name.c_str());
   gs->collide_flag_sameship = ALL_LAYERS;
   gs->collide_flag_sameteam = ALL_LAYERS;
   gs->collide_flag_anyone = ALL_LAYERS;
@@ -727,7 +704,7 @@
 
   char buffy1[512], buffy2[512];
   ShipType *otype = s->ship->type;
-  ShipType *ntype = shiptype(build_type);
+  ShipType *ntype = shiptype(_build_type.c_str());
   if (otype == ntype) 
     {
       sprintf (buffy1, "You already have a %s", ntype->name);
@@ -762,12 +739,12 @@
   return;
 }
 
-GobStation::GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, 
-			 const char *background) : 
+GobStation::GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const std::string& ship, 
+			 const std::string& background) : 
   Orbiter(pic, orbit_me, random() % 200 + 500) 
 {
-  build_type = ship;
-  background_pic = background;
+  _build_type = ship;
+  _background_pic = background;
   layer = LAYER_CBODIES;
   mass = 99;
 }
@@ -789,10 +766,10 @@
 void GobStation::station_screen(GobPlayer *s) 
 {
   STACKTRACE;
-  BITMAP *background = load_bitmap(data_full_path(background_pic).c_str(), NULL);
+  BITMAP *background = load_bitmap(data_full_path(_background_pic).c_str(), NULL);
   if (!background) {
-    message.print(1000, 15, "%s", background_pic);
-    tw_error ("couldn't load station background");
+    message.print(1000, 15, "%s", _background_pic.c_str());
+    tw_error ((std::string("couldn't load station background") + data_full_path(_background_pic).c_str()).c_str());
   }
   game->window->lock();
   aa_set_mode(AA_DITHER);
@@ -875,10 +852,10 @@
 	gobgame->pause();
 	char buffy[256];
 	int a;
-	sprintf(buffy, "First visited station %s at time", build_type);
+	sprintf(buffy, "First visited station %s at time", _build_type.c_str());
 	a = p->read_pair(buffy);
 	if (a == -1) p->write_pair(buffy, game->game_time);
-	sprintf(buffy, "Visited station %s N times", build_type);
+	sprintf(buffy, "Visited station %s N times", _build_type.c_str());
 	a = p->read_pair(buffy);
 	if (a == -1) a = 0;
 	p->write_pair(buffy, a+1);

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/source/games/ggob.h	2005-02-26 11:50:40 UTC (rev 122)
@@ -85,6 +85,7 @@
 class GobGame : public  GobGameBase
 {
  public:
+  GobGame();
   virtual ~GobGame();
 
   TeamCode enemy_team;
@@ -112,27 +113,34 @@
   
   int next_add_new_enemy_time;
   
-  SpaceSprite *stationSprite[3];
-  char *station_pic_name[3];
-  char *station_build_name[3];
   SpaceSprite *defenderSprite;
 
  protected:
+  SpaceSprite* LoadStationSprite(std::string datafile, std::string name);
   virtual bool handle_key(int k);
 
  public:
   int num_planets;
   Planet *planet[16];
   GobStation *station[16];
-  void add_planet_and_station ( SpaceSprite *planet_sprite, int planet_index, SpaceSprite *station_sprite, const char *builds, const char *background);
+  //  void add_planet_and_station ( SpaceSprite *planet_sprite, int planet_index, SpaceSprite *station_sprite, const char *builds, const char *background);
+  void add_planet_and_station ( 
+				       int planet_index, 
+				       std::string datafile,
+				       std::string stationSprite,
+				       std::string station_pic_name,
+				       std::string station_build_name
+				);
+
 };
 
 /// Station where player can buy upgrades and repair his ship
 class GobStation : public Orbiter {
  public:
-  const char *build_type;
-  const char *background_pic;
-  GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, const char *background);
+  std::string _build_type;
+  std::string _background_pic;
+
+  GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const std::string& ship, const std::string& background);
   virtual void buy_new_ship_menu(GobPlayer *s) ;
   virtual void inflict_damage(SpaceObject *other);
   virtual void station_screen (GobPlayer *s);

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/source/melee/mgame.cpp	2005-02-26 11:50:40 UTC (rev 122)
@@ -45,6 +45,7 @@
 
 #include "other/twconfig.h"
 #include "other/dialogs.h"
+#include "xslt/twexslt.h"
 
 int random_seed[2];
 
@@ -1163,7 +1164,7 @@
     case KEY_F3:
       {
 	pause();
-	Load("");
+	Load(home_ini_full_path("save.xml"));
 	unpause();
 	return true;
       }
@@ -1340,6 +1341,21 @@
 
 int Game::Load(std::string xml)
 {
+  if(!exists(xml.c_str()))
+    return 1;
+
+  // parse the input XML document
+  xml::tree_parser parser(xml.c_str());
+  xml::document &doc = parser.get_document();
+  
+  // parse the stylesheet
+  xslt::stylesheet style(data_full_path("xslt/load.xsl").c_str());
+  
+  // transform the XML document using the stylesheet
+  //xml::document &result = style.apply(doc);
+  style.apply(doc);
+
+  //  std::cout << result;
   return 0;
 }
 

Modified: trunk/source/other/gup.cpp
===================================================================
--- trunk/source/other/gup.cpp	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/source/other/gup.cpp	2005-02-26 11:50:40 UTC (rev 122)
@@ -372,25 +372,30 @@
 */
 
 class UpDivineFavor : public Upgrade {
-	UPGRADE(UpDivineFavor)
-	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
-		name = "Divine Favor (unique)";
-		if (strcmp(station->build_type, "orzne")) return false;
-		if (num) return false;
-		starbucks = 150;
-		buckazoids = 0;
-		return true;
-		}
-	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
-		}
-	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
-		if (!oship) num = 0;
-		return;
-		}
-	void charge(GobPlayer *gs) {
-		num += 1;
-		}
-	} divinefavor;
+  UPGRADE(UpDivineFavor)
+    bool update(Ship *ship, GobStation *station, GobPlayer *gs) 
+  {
+    name = "Divine Favor (unique)";
+    if (station->_build_type != "orzne") 
+      return false;
+    if (num) return false;
+    starbucks = 150;
+    buckazoids = 0;
+    return true;
+  }
+  void execute(Ship *ship, GobStation *station, GobPlayer *gs) 
+  {
+  }
+  void clear(Ship *oship, Ship *nship, GobPlayer *gs) 
+  {
+    if (!oship) num = 0;
+    return;
+  }
+  void charge(GobPlayer *gs) 
+  {
+    num += 1;
+  }
+} divinefavor;
 
 class UpUnholyAura : public Upgrade {
 	UPGRADE(UpUnholyAura)
@@ -426,7 +431,8 @@
 	GobDefender *def[6];
 	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
 		name = "External Defense System";
-		if (strcmp(station->build_type, "kohma")) return false;
+		if (station->_build_type != "kohma") 
+		  return false;
 		if (num >= 6) return false;
 		starbucks = 5 + 5 * (num+1) * num;
 		buckazoids = 12;
@@ -462,7 +468,8 @@
 	Presence **locater;
 	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
 		name = "Planet Locater";
-		if (strcmp(station->build_type, "supbl")) return false;
+		if (station->_build_type != "supbl") 
+		  return false;
 		if (num) return false;
 		starbucks = 4;
 		buckazoids = 5;

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/source/scp.cpp	2005-02-26 11:50:40 UTC (rev 122)
@@ -36,6 +36,13 @@
 
 #include "tests/testmain.h"
 
+#include <xsltwrapp/xsltwrapp.h>
+
+// standard includes
+#include <iostream>
+#include <exception>
+#include "xslt/twexslt.h"
+
 #ifdef ALLEGRO_MSVC
 #pragma warning (disable:4786)
 #endif
@@ -719,6 +726,10 @@
       return RunTests();
     }
   
+  // prepare the XSLT engine and XML parser
+  xslt::init init;
+  exsltTW_LIGHTRegister();
+
   int i;
   int auto_port = -1;
   const char *auto_play = NULL, *auto_param = NULL;

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-02-20 13:20:59 UTC (rev 121)
+++ trunk/sources.lst	2005-02-26 11:50:40 UTC (rev 122)
@@ -124,3 +124,4 @@
 source/sc2ships/shpslypr.cpp
 source/sc2ships/shpzfpst.cpp
 source/gui.cpp
+source/xslt/twexslt.cpp



From yurand at sheep.berlios.de  Sat Feb 26 19:52:41 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 26 Feb 2005 19:52:41 +0100
Subject: [Tw-light-svn] r123 - in trunk: gamedata/xml/GOB gamedata/xslt source/games
Message-ID: <200502261852.j1QIqfJ9020098@sheep.berlios.de>

Author: yurand
Date: 2005-02-26 19:52:40 +0100 (Sat, 26 Feb 2005)
New Revision: 123

Modified:
   trunk/gamedata/xml/GOB/start.xml
   trunk/gamedata/xslt/load.xsl
   trunk/source/games/gamehierarchy.cpp
   trunk/source/games/gamehierarchy.h
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
Log:
You can specify any number of star system in start.xml for GOB game


Modified: trunk/gamedata/xml/GOB/start.xml
===================================================================
--- trunk/gamedata/xml/GOB/start.xml	2005-02-26 11:50:40 UTC (rev 122)
+++ trunk/gamedata/xml/GOB/start.xml	2005-02-26 18:52:40 UTC (rev 123)
@@ -1,55 +1,108 @@
 <GOB>
-  <Area x="24000" y="24000">
-  <SpaceObjects>
-    <Planet_with_station
-      planet_index="0"
-      datafile="gob.dat"
-      stationSprite="station0sprite"
-      station_pic_name="gob.dat#station0picture.bmp"
-      station_build_name="supbl"
-    />
-    <Planet_with_station
-      planet_index="1"
-      datafile="gob.dat"
-      stationSprite="station1sprite"
-      station_pic_name="gob.dat#station1picture.bmp"
-      station_build_name="orzne"
-    />
-    <Planet_with_station
-      planet_index="2"
-      datafile="gob.dat"
-      stationSprite="station2sprite"
-      station_pic_name="gob.dat#station2picture.bmp"
-      station_build_name="kohma"
-    />
-    <Planet_with_station
-      planet_index="1"
-      datafile="gob.dat"
-      stationSprite="station1sprite"
-      station_pic_name="gob.dat#station1picture.bmp"
-      station_build_name="utwju"
-    />
-    <NEW_ENEMY/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-    <GobAsteroid/>
-  </SpaceObjects>
-  </Area>
+  <System name="Arix" x="24000" y="24000">
+      <SpaceObjects>
+	<Planet_with_station
+	    planet_index="0"
+	    datafile="gob.dat"
+	    stationSprite="station0sprite"
+	    station_pic_name="gob.dat#station0picture.bmp"
+	    station_build_name="supbl"
+	    />
+	<Planet_with_station
+	    planet_index="1"
+	    datafile="gob.dat"
+	    stationSprite="station1sprite"
+	    station_pic_name="gob.dat#station1picture.bmp"
+	    station_build_name="orzne"
+	    />
+	<Planet_with_station
+	    planet_index="2"
+	    datafile="gob.dat"
+	    stationSprite="station2sprite"
+	    station_pic_name="gob.dat#station2picture.bmp"
+	    station_build_name="kohma"
+	    />
+	<Planet_with_station
+	    planet_index="1"
+	    datafile="gob.dat"
+	    stationSprite="station1sprite"
+	    station_pic_name="gob.dat#station1picture.bmp"
+	    station_build_name="utwju"
+	    />
+	<NEW_ENEMY/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+      </SpaceObjects>
+  </System>
+  <System name="Beta" x="24000" y="24000">
+      <SpaceObjects>
+	<Planet_with_station
+	    planet_index="0"
+	    datafile="gob.dat"
+	    stationSprite="station0sprite"
+	    station_pic_name="gob.dat#station0picture.bmp"
+	    station_build_name="supbl"
+	    />
+	<Planet_with_station
+	    planet_index="1"
+	    datafile="gob.dat"
+	    stationSprite="station1sprite"
+	    station_pic_name="gob.dat#station1picture.bmp"
+	    station_build_name="orzne"
+	    />
+	<Planet_with_station
+	    planet_index="2"
+	    datafile="gob.dat"
+	    stationSprite="station2sprite"
+	    station_pic_name="gob.dat#station2picture.bmp"
+	    station_build_name="kohma"
+	    />
+	<Planet_with_station
+	    planet_index="1"
+	    datafile="gob.dat"
+	    stationSprite="station1sprite"
+	    station_pic_name="gob.dat#station1picture.bmp"
+	    station_build_name="utwju"
+	    />
+	<NEW_ENEMY/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+	<GobAsteroid/>
+      </SpaceObjects>
+  </System>
 </GOB>
\ No newline at end of file

Modified: trunk/gamedata/xslt/load.xsl
===================================================================
--- trunk/gamedata/xslt/load.xsl	2005-02-26 11:50:40 UTC (rev 122)
+++ trunk/gamedata/xslt/load.xsl	2005-02-26 18:52:40 UTC (rev 123)
@@ -7,8 +7,8 @@
   <xsl:apply-templates/>
 </xsl:template>
 
-<xsl:template match="Area">
-  <xsl:value-of select="tw:SetMapSize(@x, at y)"/>
+<xsl:template match="System">
+  <xsl:value-of select="tw:AddSystem(@name, at x, at y)"/>
   <xsl:apply-templates/>    
 </xsl:template>
 

Modified: trunk/source/games/gamehierarchy.cpp
===================================================================
--- trunk/source/games/gamehierarchy.cpp	2005-02-26 11:50:40 UTC (rev 122)
+++ trunk/source/games/gamehierarchy.cpp	2005-02-26 18:52:40 UTC (rev 123)
@@ -36,7 +36,6 @@
 
 SubGame::SubGame()
 {
- 
 }
 
 SubGame::~SubGame()
@@ -44,7 +43,7 @@
 
 }
 
-void SubGame::init(Log *_log, const std::string& save)
+void SubGame::init(Log *_log,  const std::string& save)
 {
   STACKTRACE;
 
@@ -53,7 +52,7 @@
     log = new Log();
     log->init();
   }
-
+  
   lag_frames = 0;
   show_fps = 0;
   game_time = 0;
@@ -106,10 +105,19 @@
   return;
 }
 
-void MainGame::addsubgame(SubGame *asubgame)
+MainGame* g_maingame = NULL;
+
+
+MainGame::MainGame()
 {
+  g_maingame = this;
+}
+
+void MainGame::addsubgame(SubGame *asubgame, const std::string& name)
+{
   STACKTRACE;
 
+  asubgame->_name = name;
   asubgame->maingame = this;
 
   asubgame->preinit();
@@ -119,7 +127,6 @@
   asubgame->window->locate(0,0,0,0,0,1,0,1);
 
   asubgame->init(log, "");	// all subgames share the same log (is this ok?)
-  // this init should reference the already-initialized melee-data of the maingame
 
   subgame.insert(asubgame);
 }

Modified: trunk/source/games/gamehierarchy.h
===================================================================
--- trunk/source/games/gamehierarchy.h	2005-02-26 11:50:40 UTC (rev 122)
+++ trunk/source/games/gamehierarchy.h	2005-02-26 18:52:40 UTC (rev 123)
@@ -31,11 +31,13 @@
  public:
 
   MainGame	*maingame;		///< the first game (contains the melee data ?)
-
+  std::string _name;                    ///< Every SubGame has name which can be used in MainGame to manipulate it
   SubGame();
   ~SubGame();
 
   virtual void init(Log *_log, const std::string& save);
+ protected:
+
 };
 
 
@@ -46,11 +48,12 @@
 class MainGame : public Game
 {
  public:
-  
+ 
+  MainGame();
   std::set<SubGame*> subgame;
   
 
-  virtual void addsubgame(SubGame *asubgame);
+  virtual void addsubgame(SubGame *asubgame,  const std::string& save);
   virtual void removesubgame(SubGame* g);
   virtual int isGameDone();
   virtual int play();

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-26 11:50:40 UTC (rev 122)
+++ trunk/source/games/ggob.cpp	2005-02-26 18:52:40 UTC (rev 123)
@@ -175,17 +175,13 @@
   int i;
   GobGameBase::init(_log, save);
   
+  size = Vector2(24000, 24000);
   log_file("server.ini");
   max_enemies = get_config_int("Gob", "MaxEnemies", 32);
   gobenemy = (GobEnemy**) malloc(sizeof(GobEnemy*) * max_enemies);
 
   enemy_team = new_team();
-	
-   if(Load(data_full_path("xml/GOB/start.xml")) == 1)
-    {
-      tw_error("unable to locate start.xml");
-    };
-       
+	       
    //  for (i = 0; i < 19; i += 1) add(new GobAsteroid());
 
   int server_players, client_players;
@@ -298,6 +294,7 @@
   STACKTRACE;
   GobGameBase::fps();
   
+  message.print((int)msecs_per_fps, 15, "System: %s", _name.c_str());
   message.print((int)msecs_per_fps, 15, "enemies: %d", (int)gobenemies);
   message.print((int)msecs_per_fps, 15, "time: %d", (int)(game_time / 1000));
 
@@ -1068,7 +1065,19 @@
 }
 
 
-//REGISTER_GAME(GobGame, "GOB")
+void MainGobGame::init (Log *log, const std::string& save)
+{
+  MainGame::init(log,save);
+  
+  if(Load(data_full_path("xml/GOB/start.xml")) == 1)
+    {
+      tw_error("unable to locate start.xml");
+    };
+  
+  //  addsubgame(new GobGame, );
+}	
+
+
 REGISTER_GAME(MainGobGame, "GOB")
 
 

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-26 11:50:40 UTC (rev 122)
+++ trunk/source/games/ggob.h	2005-02-26 18:52:40 UTC (rev 123)
@@ -185,13 +185,7 @@
 class MainGobGame : public MainGame
 {
  public:
-  virtual void 	init (Log *log, const std::string& save)
-    {
-      MainGame::init(log,save);
-      addsubgame(new GobGame);
-      addsubgame(new GobGame);
-      //      addsubgame(new GobGame);
-    }	
+  virtual void 	init (Log *log, const std::string& save);
 };
 
 #endif // TW_GOB_H_INCLUDES



From yurand at sheep.berlios.de  Sun Feb 27 10:45:20 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 27 Feb 2005 10:45:20 +0100
Subject: [Tw-light-svn] r124 - in trunk: gamedata/xml/GOB gamedata/xslt source source/games source/melee
Message-ID: <200502270945.j1R9jKNU000434@sheep.berlios.de>

Author: yurand
Date: 2005-02-27 10:45:19 +0100 (Sun, 27 Feb 2005)
New Revision: 124

Modified:
   trunk/gamedata/xml/GOB/start.xml
   trunk/gamedata/xslt/load.xsl
   trunk/source/games/gamehierarchy.cpp
   trunk/source/games/gamehierarchy.h
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mitems.cpp
   trunk/source/melee/mitems.h
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mmain.h
Log:
Healthbar is available in any type of game now.
You can jump to other system using F6 key in GOB. 
Panel still doesn't work



Modified: trunk/gamedata/xml/GOB/start.xml
===================================================================
--- trunk/gamedata/xml/GOB/start.xml	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/gamedata/xml/GOB/start.xml	2005-02-27 09:45:19 UTC (rev 124)
@@ -105,4 +105,5 @@
 	<GobAsteroid/>
       </SpaceObjects>
   </System>
+  <Player system="Arix" x="0" y="0"/>
 </GOB>
\ No newline at end of file

Modified: trunk/gamedata/xslt/load.xsl
===================================================================
--- trunk/gamedata/xslt/load.xsl	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/gamedata/xslt/load.xsl	2005-02-27 09:45:19 UTC (rev 124)
@@ -7,6 +7,11 @@
   <xsl:apply-templates/>
 </xsl:template>
 
+<xsl:template match="Player">
+  <xsl:value-of select="tw:AddPlayer(@system, at x, at y)"/>
+  <xsl:apply-templates/>    
+</xsl:template>
+
 <xsl:template match="System">
   <xsl:value-of select="tw:AddSystem(@name, at x, at y)"/>
   <xsl:apply-templates/>    

Modified: trunk/source/games/gamehierarchy.cpp
===================================================================
--- trunk/source/games/gamehierarchy.cpp	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/games/gamehierarchy.cpp	2005-02-27 09:45:19 UTC (rev 124)
@@ -32,79 +32,10 @@
 
 
 #include "gamehierarchy.h"
+#include "ggob.h"
 
+#include <algorithm>
 
-SubGame::SubGame()
-{
-}
-
-SubGame::~SubGame()
-{
-
-}
-
-void SubGame::init(Log *_log,  const std::string& save)
-{
-  STACKTRACE;
-
-  log = _log;
-  if (!log) {
-    log = new Log();
-    log->init();
-  }
-  
-  lag_frames = 0;
-  show_fps = 0;
-  game_time = 0;
-  frame_time = 1;
-  frame_number = 0;
-  hiccup_margin = 100;
-  next_tic_time = get_time();
-  next_render_time = game_time;
-  next_fps_time = game_time;
-  view_locked = false;
-  local_checksum = client_checksum = server_checksum = 0;
-
-  Physics::init();
-  prepare();
-
-  if (!window) {
-    window = new VideoWindow();
-    window->preinit();
-  }
-
-  //set_config_file("client.ini");
-  change_view(get_config_string("View", "View", "Hero")); 
-
-  //window->add_callback(this);				// so .. a window can handle >2 games ??
-
-
-  if (!is_paused()) pause();
-
-  text_mode(-1);
-	
-
-	
-  msecs_per_fps		= maingame->msecs_per_fps;
-  msecs_per_render	= maingame->msecs_per_render;
-  frame_time		= maingame->frame_time;
-  normal_turbo		= maingame->normal_turbo;
-  f4_turbo		= maingame->f4_turbo;
-  turbo                 = normal_turbo;
-  friendly_fire		= maingame->friendly_fire;
-  shot_relativity	= maingame->shot_relativity;
-
-  
-  lag_frames = maingame->lag_frames;
-
-  tic_history = new Histograph(128);
-  render_history = new Histograph(128);
-
-  prepare();
-
-  return;
-}
-
 MainGame* g_maingame = NULL;
 
 
@@ -113,12 +44,12 @@
   g_maingame = this;
 }
 
-void MainGame::addsubgame(SubGame *asubgame, const std::string& name)
+void MainGame::addsubgame(Game *asubgame, const std::string& name)
 {
   STACKTRACE;
 
   asubgame->_name = name;
-  asubgame->maingame = this;
+  ((SubGame<MainGame>*)asubgame)->maingame = this;
 
   asubgame->preinit();
   asubgame->window = new VideoWindow;
@@ -132,7 +63,7 @@
 }
 
 
-void MainGame::removesubgame(SubGame* g)
+void MainGame::removesubgame(Game* g)
 {
   STACKTRACE;
 
@@ -147,7 +78,7 @@
 
 int MainGame::isGameDone()
 {
-  for (std::set<SubGame*>::iterator i = subgame.begin();
+  for (std::set<Game*>::iterator i = subgame.begin();
        i!= subgame.end(); i++)
     {
       if ((*i)->isGameDone() != GAME_STATE_FINISHED)
@@ -175,7 +106,7 @@
       
       videosystem->poll_redraw();
       
-      for (std::set<SubGame*>::iterator i = subgame.begin();
+      for (std::set<Game*>::iterator i = subgame.begin();
 	   i!= subgame.end(); i++)
 	{
 	  if ((*i)->isGameDone() != GAME_STATE_FINISHED)
@@ -189,3 +120,25 @@
 }
 
 
+
+struct SubGameP : public std::binary_function<Game*,std::string,bool>
+{
+  bool operator ()(Game* g, std::string name) const
+  {
+    if(g->_name == name)
+      return true;
+    return false;
+  }
+};
+
+bool MainGame::switch_to(const std::string& name)
+{
+  std::set<Game*>::iterator i = std::find_if(subgame.begin(), subgame.end(), std::bind2nd(SubGameP(), name));
+
+  if(i!=subgame.end())
+    {
+      (*i)->prepare();
+      return true;
+    }
+  return false;
+}

Modified: trunk/source/games/gamehierarchy.h
===================================================================
--- trunk/source/games/gamehierarchy.h	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/games/gamehierarchy.h	2005-02-27 09:45:19 UTC (rev 124)
@@ -20,24 +20,90 @@
 #include "melee/mgame.h"
 #include <set>
 
+#include "util/history.h"
 
-
 class MainGame;
 
+
 /// an extended game class, which can be embedded in a sequence
 /// of initiated games ...
+template<class TMainGame>
 class SubGame : public Game
 {
  public:
 
-  MainGame	*maingame;		///< the first game (contains the melee data ?)
-  std::string _name;                    ///< Every SubGame has name which can be used in MainGame to manipulate it
-  SubGame();
-  ~SubGame();
+  TMainGame	*maingame;		///< Main game handle multiple game subgames
 
-  virtual void init(Log *_log, const std::string& save);
+  SubGame()
+  {
+  }
+  
+  ~SubGame()
+  {
+  }
+
+  /// This init is cutted so it can be called safe several times by different subgames
+  virtual void init(Log *_log, const std::string& save)
+    {
+      STACKTRACE;
+      
+      log = _log;
+      if (!log) 
+	{
+	  log = new Log();
+	  log->init();
+	}
+  
+      lag_frames = 0;
+      show_fps = 0;
+      game_time = 0;
+      frame_time = 1;
+      frame_number = 0;
+      hiccup_margin = 100;
+      next_tic_time = get_time();
+      next_render_time = game_time;
+      next_fps_time = game_time;
+      view_locked = false;
+      local_checksum = client_checksum = server_checksum = 0;
+      
+      Physics::init();
+      prepare();
+      
+      if (!window) 
+	{
+	  window = new VideoWindow();
+	  window->preinit();
+	}
+      
+      change_view(get_config_string("View", "View", "Hero")); 
+      
+      
+      if (!is_paused()) pause();
+      
+      text_mode(-1);
+      
+      
+      msecs_per_fps	= maingame->msecs_per_fps;
+      msecs_per_render	= maingame->msecs_per_render;
+      frame_time	= maingame->frame_time;
+      normal_turbo	= maingame->normal_turbo;
+      f4_turbo		= maingame->f4_turbo;
+      turbo             = normal_turbo;
+      friendly_fire	= maingame->friendly_fire;
+      shot_relativity	= maingame->shot_relativity;
+      
+      
+      lag_frames = maingame->lag_frames;
+      
+      tic_history = new Histograph(128);
+      render_history = new Histograph(128);
+      
+      prepare();
+      
+      return;
+      }
  protected:
-
+  
 };
 
 
@@ -50,12 +116,15 @@
  public:
  
   MainGame();
-  std::set<SubGame*> subgame;
+  std::set<Game*> subgame;
   
 
-  virtual void addsubgame(SubGame *asubgame,  const std::string& save);
-  virtual void removesubgame(SubGame* g);
+  virtual void addsubgame(Game *asubgame,  const std::string& save);
+  virtual void removesubgame(Game* g);
   virtual int isGameDone();
+
+  /// Switch to subgame by name
+  bool switch_to(const std::string& name);
   virtual int play();
 };
 

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/games/ggob.cpp	2005-02-27 09:45:19 UTC (rev 124)
@@ -85,8 +85,6 @@
   STACKTRACE;
   GobGameBase::preinit();
 
-  gobplayers = 0;
-  gobplayer = NULL;
   gobenemies = 0;
   max_enemies = 0;
   gobenemy = NULL;
@@ -94,14 +92,30 @@
   defenderSprite = NULL;
 }
 
-int GobGame::isGameDone() 
+void GobGame::prepare()
 {
-  bool done = true;
-  for (int i = 0; i < gobplayers; i += 1) 
+  GobGameBase::prepare();
+  if(maingame->gobplayer._teleport)
     {
-      if (gobplayer[i]->ship != NULL)
-	done = false;
+      maingame->gobplayer.ship = 
+	create_ship(maingame->gobplayer.ship->type->id,
+		    _player_control,
+		    0,//maingame->gobplayer.ship->pos(),
+		    maingame->gobplayer.ship->get_angle(),
+		    maingame->gobplayer.team);
+      add(maingame->gobplayer.ship);
+      add_focus(_player_control, _player_control->channel);
+      maingame->gobplayer._teleport = 0;
     }
+}
+
+int GobGame::isGameDone() 
+{
+  bool done = true;
+
+  if (maingame->gobplayer.ship != NULL)
+    done = false;
+
   if (done) 
     {
       if(_game_state != GAME_STATE_FINISHED)
@@ -116,12 +130,8 @@
 void GobGame::add_gobplayer(Control *control) 
 {
   STACKTRACE;
-  int i = gobplayers;
-  gobplayers += 1;
-  gobplayer = (GobPlayer**) realloc(gobplayer, sizeof(GobPlayer*) * gobplayers);
-  gobplayer[i] = new GobPlayer();
-  gobplayer[i]->init(control, new_team());
-  add_focus(control, control->channel);
+  maingame->gobplayer.init( new_team());
+  add_focus(_player_control, _player_control->channel);
   return;
 }
 
@@ -172,7 +182,6 @@
 void GobGame::init(Log *_log, const std::string& save) 
 {
   STACKTRACE;
-  int i;
   GobGameBase::init(_log, save);
   
   size = Vector2(24000, 24000);
@@ -184,38 +193,13 @@
 	       
    //  for (i = 0; i < 19; i += 1) add(new GobAsteroid());
 
-  int server_players, client_players;
+  int server_players;
   tw_set_config_file("client.ini");
-  server_players = client_players = get_config_int("Gob", "NumPlayers", 1);
-  if (!lag_frames) client_players = 0;
+  server_players = 1;
   log_int(channel_server, server_players);
-  log_int(channel_client, client_players);
-  for (i = 0; i < server_players; i += 1) 
-    {
-      char buffy[256];
-      sprintf(buffy, "Config%d", i);
-      add_gobplayer(create_control(channel_server, "Human", buffy));
-      gobplayer[i]->new_ship(shiptype("supbl"));
-      Ship *s = gobplayer[i]->ship;
-      s->translate(size/2-s->normal_pos());
-      double angle = PI2 * i / (client_players + server_players);
-      s->translate(rotate(Vector2(260, 120), angle));
-      s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
-    }
-  for (i = server_players; i < client_players + server_players; i += 1) 
-    {
-      char buffy[256];
-      sprintf(buffy, "Config%d", i - server_players);
-      add_gobplayer(create_control(channel_client, "Human", buffy));
-      gobplayer[i]->new_ship(shiptype("supbl"));
-      Ship *s = gobplayer[i]->ship;
-      s->translate(size/2-s->normal_pos());
-      double angle = PI2 * i / (client_players + server_players);
-      s->translate(rotate(Vector2(260, 120), angle));
-      s->accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
-    }
+  _player_control = create_control(channel_server, "Human", "Config0");
 
-  for (i = 0; i < gobplayers; i += 1) add ( new RainbowRift() );
+  add ( new RainbowRift() );
   
   next_add_new_enemy_time = 1000;
 
@@ -228,6 +212,7 @@
 		       0,0.9,
 		       0,1
 		       );
+
   return;
 }
 
@@ -246,11 +231,6 @@
 GobGame::~GobGame() {
   delete defenderSprite;
   int i;
-  for (i = 0; i < gobplayers; i += 1) 
-    {
-      delete gobplayer[i];
-    }
-  free(gobplayer);
   for (i = 0; i < gobenemies; i += 1) 
     {
       delete gobenemy[i];
@@ -299,21 +279,17 @@
   message.print((int)msecs_per_fps, 15, "time: %d", (int)(game_time / 1000));
 
   int i = 0;
-  for (i = 0; i < gobplayers; i += 1) 
-    {
-      if (!is_local(gobplayer[i]->channel)) 
-	continue;
       
-      if (gobplayer[i]->ship) 
-	{
-	  message.print((int)msecs_per_fps, 15-i, "coordinates: %d x %d", 
-			iround(gobplayer[i]->ship->normal_pos().x), 
-			iround(gobplayer[i]->ship->normal_pos().y));
-	}
-      message.print((int)msecs_per_fps, 15-i, "starbucks: %d", gobplayer[i]->starbucks);
-      message.print((int)msecs_per_fps, 15-i, "buckazoids: %d", gobplayer[i]->buckazoids);
-      message.print((int)msecs_per_fps, 15-i, "kills: %d", gobplayer[i]->kills);
+  if (maingame->gobplayer.ship) 
+    {
+      message.print((int)msecs_per_fps, 15-i, "coordinates: %d x %d", 
+		    iround(maingame->gobplayer.ship->normal_pos().x), 
+		    iround(maingame->gobplayer.ship->normal_pos().y));
     }
+  message.print((int)msecs_per_fps, 15-i, "starbucks: %d", maingame->gobplayer.starbucks);
+  message.print((int)msecs_per_fps, 15-i, "buckazoids: %d", maingame->gobplayer.buckazoids);
+  message.print((int)msecs_per_fps, 15-i, "kills: %d", maingame->gobplayer.kills);
+  
   return;
 }
 
@@ -386,12 +362,8 @@
 GobPlayer *GobGame::get_player(SpaceLocation *what) 
 {
   STACKTRACE;
-  int i;
-  for (i = 0; i < gobplayers; i += 1) 
-    {		
-      if (what->get_team() == gobplayer[i]->team) 
-	return gobplayer[i];
-    }
+  if (what->get_team() == maingame->gobplayer.team) 
+    return &(maingame->gobplayer);
   return NULL;
 }
 
@@ -403,18 +375,13 @@
     case KEY_F6: 
       {
 	setGameDone(GAME_STATE_SUSPENDED);
+	maingame->gobplayer._teleport = 1;
+	maingame->gobplayer.ship->state = 0;
 	return true;
       }
       break;
     //don't use hardwired normal keys
-      /*
-    case KEY_H:
-      if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;
-      break;
-    case KEY_T:
-      if ((k & 255) == 'T'-'A'+1) indteamtoggle = ~indteamtoggle;
-      break;
-      */
+            
     default: 
       {
 	return GobGameBase::handle_key(k);
@@ -532,16 +499,22 @@
   return;
 }
 
+GobPlayer::GobPlayer()
+{
+  _teleport = 0;
+  _teleport_to = "";
 
+}
+
 GobPlayer::~GobPlayer() 
 {
   free (pair_list);
 }
 
-void GobPlayer::init(Control *c, TeamCode team) 
+void GobPlayer::init(TeamCode team) 
 {
   STACKTRACE;
-  channel = c->channel;
+  //  channel = c->channel;
   starbucks = 0;
   buckazoids = 0;
   kills = 0;
@@ -551,8 +524,8 @@
   pair_list = NULL;
   ship = NULL;
   panel = NULL;
-  control = c;
   total = 0;
+  
   this->team = team;
   int i, j;
   for (i = 0; ::upgrade_list[i]; i += 1) ::upgrade_list[i]->index = i;
@@ -621,14 +594,14 @@
   sprintf(buffy1, "Price: %d starbucks plus %d buckazoids", price_starbucks, price_buckazoids);
   if ((starbucks < price_starbucks) || (buckazoids < price_buckazoids)) 
     {
-      if (game->is_local(channel)) 
+      if (game->is_local(gobgame->_player_control->channel)) 
 	alert("You don't have enough.", name, buffy1, "Cancel", NULL, 0, 0);
       return 0;
     }
   int r = 0;
-  if (game->is_local(channel)) 
+  if (game->is_local(gobgame->_player_control->channel)) 
     r = alert ("Do you wish to make this purchase?", name, buffy1, "&No", "&Yes", 'n', 'y');
-  game->log_int(channel, r);
+  game->log_int(gobgame->_player_control->channel, r);
   if (r == 2) 
     {
       starbucks -= price_starbucks;
@@ -651,7 +624,7 @@
       a = old->get_angle();
     }
   
-  ship = game->create_ship ( type->id, control, pos, a, team);
+  ship = game->create_ship ( type->id, gobgame->_player_control, pos, a, team);
   
   
   if (panel) 
@@ -660,7 +633,7 @@
   panel = new ShipPanel(ship);
   panel->always_redraw = true;
   panel->window->init(game->window);
-  if (game->is_local(control->channel)) 
+  if (game->is_local(gobgame->_player_control->channel)) 
     {
       panel->window->locate(
 			    0,0.9,
@@ -705,7 +678,7 @@
   if (otype == ntype) 
     {
       sprintf (buffy1, "You already have a %s", ntype->name);
-      if (game->is_local(s->channel)) 
+      if (game->is_local(gobgame->_player_control->channel)) 
 	alert(buffy1, NULL, NULL, "&Cancel", NULL, 'c', 0);
       return;
     }
@@ -718,9 +691,9 @@
   if ((nssb <= (ossb + s->starbucks)) && (nsbz <= (osbz + s->buckazoids))) 
     {
       int i = 0;
-      if (game->is_local(s->channel))
+      if (game->is_local(gobgame->_player_control->channel))
 	i = alert(buffy1, buffy2, "Do you wish to buy it?", "Yeah!", "No", 'y', 'n');
-      game->log_int(s->channel, i);
+      game->log_int(gobgame->_player_control->channel, i);
       if (i == 1) 
 	{
 	  s->starbucks -= nssb - ossb;
@@ -730,7 +703,7 @@
     }
   else 
     {
-      if (game->is_local(s->channel)) 
+      if (game->is_local(gobgame->_player_control->channel)) 
 	alert (buffy1, buffy2, "You don't have enough to buy it", "Cancel", NULL, 0, 0);
     }
   return;
@@ -777,9 +750,9 @@
   while (true) {
     sprintf(dialog_string[0], "%03d Starbucks  %03d Buckazoids", s->starbucks, s->buckazoids);
     int r = 0;
-    if (game->is_local(s->channel)) 
+    if (game->is_local(gobgame->_player_control->channel)) 
       r = tw_do_dialog(game->window, station_dialog, STATION_DIALOG_DEPART);
-		game->log_int(s->channel, r);
+		game->log_int(gobgame->_player_control->channel, r);
 		switch (r) {
 		case STATION_DIALOG_UPGRADE: {
 		  upgrade_menu(this, s);
@@ -796,15 +769,15 @@
 			break;
 		case STATION_DIALOG_REPAIR: {
 		  if (s->ship->crew == s->ship->crew_max) {
-		    if (game->is_local(s->channel)) 
+		    if (game->is_local(gobgame->_player_control->channel)) 
 		      alert("You don't need repairs", "", "", "Oh, okay", "I knew that", 0, 0);
 		    
 		    break;
 		  }
 		  int p = 0;
-		  if (game->is_local(s->channel)) 
+		  if (game->is_local(gobgame->_player_control->channel)) 
 		    p = alert3("Which would you prefer", "to pay for your repairs", "", "1 &Starbuck", "1 &Buckazoid", "&Nothing!", 's', 'b', 'n');
-		  game->log_int(s->channel, p);
+		  game->log_int(gobgame->_player_control->channel, p);
 		  switch (p) {
 		  case 1: {
 		    if (s->starbucks) {
@@ -812,7 +785,7 @@
 		      s->ship->crew = s->ship->crew_max;
 		    }
 		    else {
-		      if (game->is_local(s->channel)) 
+		      if (game->is_local(gobgame->_player_control->channel)) 
 			alert("You don't have enough!", NULL, NULL, "&Shit", NULL, 's', 0);
 		    }
 						}
@@ -823,7 +796,7 @@
 		      s->ship->crew = s->ship->crew_max;
 		    }
 		    else {
-							if (game->is_local(s->channel)) 
+							if (game->is_local(gobgame->_player_control->channel)) 
 							  alert("You don't have enough!", NULL, NULL, "&Shit", NULL, 's', 0);
 		    }
 		  }
@@ -905,15 +878,15 @@
     }
     num_upgrade_indexes = j;
     int m = 0;
-    if (game->is_local(gs->channel))
+    if (game->is_local(gobgame->_player_control->channel))
       m = tw_do_dialog(game->window, upgrade_dialog, UPGRADE_DIALOG_EXIT);
-    game->log_int(gs->channel, m);
+    game->log_int(gobgame->_player_control->channel, m);
 		if (m == UPGRADE_DIALOG_EXIT) return;
 		if (m == UPGRADE_DIALOG_LIST) {
 			int i = 0;
-			if (game->is_local(gs->channel))
+			if (game->is_local(gobgame->_player_control->channel))
 				i = upgrade_dialog[UPGRADE_DIALOG_LIST].d1;
-			game->log_int(gs->channel, i);
+			game->log_int(gobgame->_player_control->channel, i);
 			i = upgrade_index[i];
 			Upgrade *u = gs->upgrade_list[i];
 			if (gs->charge(u->name, u->starbucks, u->buckazoids)) {
@@ -1042,8 +1015,8 @@
 			GobPlayer *p = gobgame->get_player(q.currento);
 			if (q.currento == p->ship) {
 				int i = 0;
-				i = p->control->choose_ship(game->window, "You found the Rainbow Rift!", reference_fleet);
-				game->log_int(p->channel, i);
+				i = gobgame->_player_control->choose_ship(game->window, "You found the Rainbow Rift!", reference_fleet);
+				game->log_int(gobgame->_player_control->channel, i);
 				if (i == -1) 
 				  i = random(reference_fleet->getSize());
 				game->redraw();
@@ -1072,11 +1045,18 @@
   if(Load(data_full_path("xml/GOB/start.xml")) == 1)
     {
       tw_error("unable to locate start.xml");
-    };
-  
+    };  
   //  addsubgame(new GobGame, );
 }	
 
+void MainGobGame::add_gobplayer(const std::string& system)
+{
+  STACKTRACE;
+   switch_to(system);
+   gobplayer.init(game->new_team());
+   game->add_focus(gobgame->_player_control, gobgame->_player_control->channel);
+   gobplayer.new_ship(shiptype("supbl"));
+}
 
 REGISTER_GAME(MainGobGame, "GOB")
 

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/games/ggob.h	2005-02-27 09:45:19 UTC (rev 124)
@@ -21,9 +21,11 @@
 #include "melee/mframe.h"
 #include "melee/mgame.h"
 #include "melee/mitems.h"
+#include "melee/mcbodies.h"
 
 #include "gamehierarchy.h"
 
+
 class Upgrade;
 class GobStation;
 
@@ -31,10 +33,10 @@
 class GobPlayer 
 {
  public:
-  int channel;
-  ~GobPlayer();
+  GobPlayer();
+  ~GobPlayer()
+;
   Ship *ship;
-  Control *control;
   ShipPanel *panel;
   struct pair 
   {
@@ -54,11 +56,14 @@
   int value_starbucks;
   int value_buckazoids;
   TeamCode team;
-  void init(Control *c, TeamCode team);
+  void init(TeamCode team);
   void died(SpaceLocation *killer);
   void new_ship(ShipType *type);
   int charge (char *name, int price_starbucks, int price_buckazoids) ;
   Upgrade **upgrade_list;
+
+  int _teleport;
+  std::string _teleport_to;
 } ;
 
 /// Enemy starship, reward for it
@@ -80,16 +85,28 @@
   virtual void death();
 };
 
-typedef SubGame GobGameBase;
+/////////////////////////////////////////////////////////////////////////////////
+
+class MainGobGame : public MainGame
+{
+ public:
+  GobPlayer gobplayer;
+  virtual void 	init (Log *log, const std::string& save);
+  void add_gobplayer(const std::string& system);
+};
+
+typedef SubGame<MainGobGame> GobGameBase;
+
 /// GOB class adventure game
 class GobGame : public  GobGameBase
 {
+  //  int _player_channel;
  public:
   GobGame();
   virtual ~GobGame();
 
+  Control * _player_control;
   TeamCode enemy_team;
-
   virtual void calculate();
   virtual int isGameDone();
   virtual void ship_died(Ship *who, SpaceLocation *source);
@@ -97,15 +114,14 @@
   virtual void init (Log *log, const std::string& save);
 
   virtual void play_sound (SAMPLE *sample, SpaceLocation *source, int vol = 256, int freq = 1000);
-	
-  int gobplayers;
-  GobPlayer **gobplayer;
+
   virtual void add_gobplayer(Control *control);
   virtual GobPlayer *get_player(SpaceLocation *what);
   int gobenemies, max_enemies;
   GobEnemy **gobenemy;
   virtual int get_enemy_index(SpaceLocation *what);
   
+  virtual void prepare();
   //	protected:
   virtual void fps ();
   
@@ -182,11 +198,6 @@
   void squiggle();
 };
 
-class MainGobGame : public MainGame
-{
- public:
-  virtual void 	init (Log *log, const std::string& save);
-};
 
 #endif // TW_GOB_H_INCLUDES
 

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/melee/mgame.cpp	2005-02-27 09:45:19 UTC (rev 124)
@@ -39,6 +39,7 @@
 #include "mnet1.h"
 #include "mfleet.h"
 #include "util/sound.h"
+#include "mitems.h"
 
 #include <typeinfo>
 #include <stdarg.h>
@@ -290,6 +291,8 @@
     c->select_ship(s, id);
   gametargets.add(s);
   s->attributes |= ATTRIB_NOTIFY_ON_DEATH;
+  add(new HealthBar(s, &indhealthtoggle));
+  add(new TeamIndicator(s, &indteamtoggle));
   return s;
 }
 
@@ -843,6 +846,9 @@
   view = NULL;
   window = NULL;
   music = "";
+  indteamtoggle = 0;
+  indhealthtoggle = 0;
+  indhealthtoggle = ~indhealthtoggle;
 }
 
 void Game::init(Log *_log, const std::string& save) 
@@ -1145,6 +1151,12 @@
   STACKTRACE;
   switch (k >> 8) 
     {
+    case KEY_H:
+	  indhealthtoggle = ~indhealthtoggle;
+      break;
+    case KEY_T:
+	  indteamtoggle = ~indteamtoggle;
+      break;
     case KEY_F1: 
       {// help
 	pause();

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/melee/mgame.h	2005-02-27 09:45:19 UTC (rev 124)
@@ -75,7 +75,8 @@
 {
  public:
   GameType *type;
-  
+  std::string _name;                    ///< Every Game has name which can be used in MainGame to manipulate it
+
   MeleeData meleedata;
   
   enum 
@@ -231,6 +232,7 @@
   virtual void save_screenshot();
   int show_fps;
   unsigned char local_checksum, client_checksum, server_checksum;
+  int indhealthtoggle, indteamtoggle;
 };
 
 

Modified: trunk/source/melee/mitems.cpp
===================================================================
--- trunk/source/melee/mitems.cpp	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/melee/mitems.cpp	2005-02-27 09:45:19 UTC (rev 124)
@@ -264,3 +264,47 @@
 	vel.y = va * sin(angle) - vb * cos(angle);
 	return;
 	}
+// this should be places elsewhere I think ...
+TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
+{
+  STACKTRACE;
+  indtoggle = atoggle;
+  mother = s;
+}
+
+void TeamIndicator::calculate()
+{
+  STACKTRACE;
+  if ( !(mother && mother->exists()) )
+    {
+      mother = 0;
+      state = 0;
+      return;
+    }
+}
+
+void TeamIndicator::animate(Frame *space) {
+  STACKTRACE;
+  if (!*indtoggle)
+    return;
+  
+  if (mother->isInvisible())
+    return;
+  
+  Vector2i co1, co2;
+  
+  co1 = corner(mother->pos - 0.5 * mother->size).round();
+  co2 = corner(mother->pos + 0.5 * mother->size).round();
+  
+  if (co2.x < 0) return;
+  if (co2.y < 0) return;
+  if (co1.x >= space->surface->w) return;
+  if (co1.y >= space->surface->h) return;
+  
+  int col;
+  col = palette_color[mother->get_team() + 1];	// team 0 is black ...
+  
+  rect(space->surface, co1.x, co1.y, co2.x, co2.y, col);
+  space->add_box(co1.x, co1.y, co2.x, co2.y);
+  
+}

Modified: trunk/source/melee/mitems.h
===================================================================
--- trunk/source/melee/mitems.h	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/melee/mitems.h	2005-02-27 09:45:19 UTC (rev 124)
@@ -65,5 +65,17 @@
 	Orbiter ( SpaceSprite *sprite, SpaceLocation *orbit, double distance);
 };
 
+// added ROB
+class TeamIndicator : public Presence
+{
+public:
+  int		*indtoggle;
+  Ship	*mother;
+  TeamIndicator(Ship *creator, int *toggle);
+
+  virtual void calculate();
+  virtual void animate(Frame *space);
+};
+
 #endif
 

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/melee/mmain.cpp	2005-02-27 09:45:19 UTC (rev 124)
@@ -261,10 +261,6 @@
 
   next_choose_new_ships_time = game_time + 200;
 
-  // team and health indicators.
-  indteamtoggle = 0;
-  indhealthtoggle = 0;
-
   return;
 }
 
@@ -421,33 +417,12 @@
     return true;
   }
     break;
-    //don't use hardwired normal keys
-  case KEY_H:
-    if ((k & 255) == 'H'-'A'+1) indhealthtoggle = ~indhealthtoggle;
-    break;
-  case KEY_T:
-    if ((k & 255) == 'T'-'A'+1) indteamtoggle = ~indteamtoggle;
-    break;
   }
   return false;
 }
 
 
 
-// added ROB
-class TeamIndicator : public Presence
-{
-public:
-  int		*indtoggle;
-  Ship	*mother;
-  TeamIndicator(Ship *creator, int *toggle);
-
-  virtual void calculate();
-  virtual void animate(Frame *space);
-};
-
-
-
 void NormalGame::choose_new_ships() 
 {
   STACKTRACE;
@@ -522,8 +497,8 @@
       add(s->get_ship_phaser());
       
       // add a healthbar for the ship, and also a team indicator.
-      add(new HealthBar(s, &indhealthtoggle));
-      add(new TeamIndicator(s, &indteamtoggle));
+      //      add(new HealthBar(s, &indhealthtoggle));
+      //      add(new TeamIndicator(s, &indteamtoggle));
       
       
       // CHECK FILE SIZES !! to intercept desynch before they happen.
@@ -629,50 +604,6 @@
   return done;
 }
 
-// this should be places elsewhere I think ...
-TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
-{
-  STACKTRACE;
-  indtoggle = atoggle;
-  mother = s;
-}
-
-void TeamIndicator::calculate()
-{
-  STACKTRACE;
-  if ( !(mother && mother->exists()) )
-    {
-      mother = 0;
-      state = 0;
-      return;
-    }
-}
-
-void TeamIndicator::animate(Frame *space) {
-  STACKTRACE;
-  if (!*indtoggle)
-    return;
-  
-  if (mother->isInvisible())
-    return;
-  
-  Vector2i co1, co2;
-  
-  co1 = corner(mother->pos - 0.5 * mother->size).round();
-  co2 = corner(mother->pos + 0.5 * mother->size).round();
-  
-  if (co2.x < 0) return;
-  if (co2.y < 0) return;
-  if (co1.x >= space->surface->w) return;
-  if (co1.y >= space->surface->h) return;
-  
-  int col;
-  col = palette_color[mother->get_team() + 1];	// team 0 is black ...
-  
-  rect(space->surface, co1.x, co1.y, co2.x, co2.y, col);
-  space->add_box(co1.x, co1.y, co2.x, co2.y);
-  
-}
 void NormalGame::showHelpText() {
   STACKTRACE;
   const char * file = data_full_path("ingame.txt").c_str();

Modified: trunk/source/melee/mmain.h
===================================================================
--- trunk/source/melee/mmain.h	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/melee/mmain.h	2005-02-27 09:45:19 UTC (rev 124)
@@ -73,8 +73,6 @@
   int next_choose_new_ships_time;
   virtual void choose_new_ships() ;
 
-  int indhealthtoggle, indteamtoggle;
-
 };
 
 

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2005-02-26 18:52:40 UTC (rev 123)
+++ trunk/source/melee.h	2005-02-27 09:45:19 UTC (rev 124)
@@ -539,7 +539,7 @@
 #define REGISTER_SHIP_EX(ship,func) static void __register_ship_ex ## ship ## _ ## func () { register_ship( ship, __FILE__, func);} CALL_BEFORE_MAIN(__register_shipclass_ex ## ship ## _ ## func);
 #define REGISTER_SHIP(ship) static Ship *get_shipclass_ ## ship (Vector2 pos, double a, ShipData *d, unsigned int c){return(new ship(pos,a,d,c));} static void __register_shipclass_ ## ship () {register_shipclass(#ship, __FILE__, &get_shipclass_ ## ship);} CALL_BEFORE_MAIN(__register_shipclass_ ## ship);
 
-
+/// Used to define type of the ship and store data for this class ships
 struct ShipType {
   const char *id;
   const char *file;



From yurand at sheep.berlios.de  Sun Feb 27 12:04:40 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 27 Feb 2005 12:04:40 +0100
Subject: [Tw-light-svn] r125 - trunk/source/games
Message-ID: <200502271104.j1RB4e4u003523@sheep.berlios.de>

Author: yurand
Date: 2005-02-27 12:04:36 +0100 (Sun, 27 Feb 2005)
New Revision: 125

Modified:
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
Log:
Fixed panel when jumping between systems


Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-27 09:45:19 UTC (rev 124)
+++ trunk/source/games/ggob.cpp	2005-02-27 11:04:36 UTC (rev 125)
@@ -90,6 +90,7 @@
   gobenemy = NULL;
 
   defenderSprite = NULL;
+  _player_panel = NULL;
 }
 
 void GobGame::prepare()
@@ -104,6 +105,7 @@
 		    maingame->gobplayer.ship->get_angle(),
 		    maingame->gobplayer.team);
       add(maingame->gobplayer.ship);
+      AddPanel();
       add_focus(_player_control, _player_control->channel);
       maingame->gobplayer._teleport = 0;
     }
@@ -523,7 +525,6 @@
   num_pairs = 0;
   pair_list = NULL;
   ship = NULL;
-  panel = NULL;
   total = 0;
   
   this->team = team;
@@ -624,36 +625,9 @@
       a = old->get_angle();
     }
   
-  ship = game->create_ship ( type->id, gobgame->_player_control, pos, a, team);
-  
-  
-  if (panel) 
-    panel->die();
-  panel = NULL;
-  panel = new ShipPanel(ship);
-  panel->always_redraw = true;
-  panel->window->init(game->window);
-  if (game->is_local(gobgame->_player_control->channel)) 
-    {
-      panel->window->locate(
-			    0,0.9,
-			    0,0,
-			    0,0.1,
-			    0,0.25
-			    );
-    }
-  else 
-    {
-      panel->window->locate(
-			    0,0.9,
-			    0,0.25,
-			    0,0.1,
-			    0,0.25
-			    );
-    }
-  panel->set_depth(10);
-  game->add(panel);
-  
+  ship = game->create_ship ( type->id, gobgame->_player_control, pos, a, team);    
+  gobgame->AddPanel();
+
   for (i = 0; upgrade_list[i]; i += 1) 
     {
       upgrade_list[i]->clear(old, ship, this);
@@ -1049,6 +1023,25 @@
   //  addsubgame(new GobGame, );
 }	
 
+void GobGame::AddPanel()
+{
+  if (_player_panel) 
+    _player_panel->die();
+  _player_panel = NULL;
+  _player_panel = new ShipPanel(maingame->gobplayer.ship);
+  _player_panel->always_redraw = true;
+  _player_panel->window->init(window);
+  
+  _player_panel->window->locate(
+			0,0.9,
+			0,0,
+			0,0.1,
+			0,0.25
+			);
+  _player_panel->set_depth(10);
+  add(_player_panel);
+}
+
 void MainGobGame::add_gobplayer(const std::string& system)
 {
   STACKTRACE;
@@ -1056,6 +1049,7 @@
    gobplayer.init(game->new_team());
    game->add_focus(gobgame->_player_control, gobgame->_player_control->channel);
    gobplayer.new_ship(shiptype("supbl"));
+
 }
 
 REGISTER_GAME(MainGobGame, "GOB")

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-27 09:45:19 UTC (rev 124)
+++ trunk/source/games/ggob.h	2005-02-27 11:04:36 UTC (rev 125)
@@ -37,7 +37,6 @@
   ~GobPlayer()
 ;
   Ship *ship;
-  ShipPanel *panel;
   struct pair 
   {
     char *id;
@@ -105,8 +104,13 @@
   GobGame();
   virtual ~GobGame();
 
-  Control * _player_control;
+  ShipPanel *_player_panel;
+  Control   * _player_control;
+
   TeamCode enemy_team;
+
+  virtual void AddPanel();
+
   virtual void calculate();
   virtual int isGameDone();
   virtual void ship_died(Ship *who, SpaceLocation *source);



From yurand at sheep.berlios.de  Sun Feb 27 12:19:18 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 27 Feb 2005 12:19:18 +0100
Subject: [Tw-light-svn] r126 - trunk/source/games
Message-ID: <200502271119.j1RBJIRr004170@sheep.berlios.de>

Author: yurand
Date: 2005-02-27 12:19:17 +0100 (Sun, 27 Feb 2005)
New Revision: 126

Modified:
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
Log:
Fixed game done condition and actions


Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-27 11:04:36 UTC (rev 125)
+++ trunk/source/games/ggob.cpp	2005-02-27 11:19:17 UTC (rev 126)
@@ -117,13 +117,12 @@
 
   if (maingame->gobplayer.ship != NULL)
     done = false;
-
+  
   if (done) 
     {
       if(_game_state != GAME_STATE_FINISHED)
 	{
 	  setGameDone(GAME_STATE_FINISHED );
-	  tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
 	}
     }
   return GobGameBase::isGameDone();
@@ -137,6 +136,25 @@
   return;
 }
 
+void GobGame::AddPanel()
+{
+  if (_player_panel) 
+    _player_panel->die();
+  _player_panel = NULL;
+  _player_panel = new ShipPanel(maingame->gobplayer.ship);
+  _player_panel->always_redraw = true;
+  _player_panel->window->init(window);
+  
+  _player_panel->window->locate(
+			0,0.9,
+			0,0,
+			0,0.1,
+			0,0.25
+			);
+  _player_panel->set_depth(10);
+  add(_player_panel);
+}
+
 void GobPlayer::died(SpaceLocation *killer) 
 {
   STACKTRACE;
@@ -378,7 +396,7 @@
       {
 	setGameDone(GAME_STATE_SUSPENDED);
 	maingame->gobplayer._teleport = 1;
-	maingame->gobplayer.ship->state = 0;
+	maingame->gobplayer.ship->die();
 	return true;
       }
       break;
@@ -1012,6 +1030,23 @@
 }
 
 
+int MainGobGame::isGameDone()
+{
+  bool done = true;
+  if (gobplayer.ship != NULL)
+    done = false;
+
+  if (done) 
+    {
+      if(_game_state != GAME_STATE_FINISHED)
+	{
+	  setGameDone(GAME_STATE_FINISHED );
+	  tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
+	}
+    }
+  return Game::isGameDone();
+}
+
 void MainGobGame::init (Log *log, const std::string& save)
 {
   MainGame::init(log,save);
@@ -1023,25 +1058,6 @@
   //  addsubgame(new GobGame, );
 }	
 
-void GobGame::AddPanel()
-{
-  if (_player_panel) 
-    _player_panel->die();
-  _player_panel = NULL;
-  _player_panel = new ShipPanel(maingame->gobplayer.ship);
-  _player_panel->always_redraw = true;
-  _player_panel->window->init(window);
-  
-  _player_panel->window->locate(
-			0,0.9,
-			0,0,
-			0,0.1,
-			0,0.25
-			);
-  _player_panel->set_depth(10);
-  add(_player_panel);
-}
-
 void MainGobGame::add_gobplayer(const std::string& system)
 {
   STACKTRACE;

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-27 11:04:36 UTC (rev 125)
+++ trunk/source/games/ggob.h	2005-02-27 11:19:17 UTC (rev 126)
@@ -92,6 +92,8 @@
   GobPlayer gobplayer;
   virtual void 	init (Log *log, const std::string& save);
   void add_gobplayer(const std::string& system);
+ protected:
+  virtual int isGameDone();
 };
 
 typedef SubGame<MainGobGame> GobGameBase;



From yurand at sheep.berlios.de  Sun Feb 27 13:46:52 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 27 Feb 2005 13:46:52 +0100
Subject: [Tw-light-svn] r127 - in trunk/source: . melee sc1ships
Message-ID: <200502271246.j1RCkqGh002336@sheep.berlios.de>

Author: yurand
Date: 2005-02-27 13:46:51 +0100 (Sun, 27 Feb 2005)
New Revision: 127

Modified:
   trunk/source/melee/mfleet.cpp
   trunk/source/melee/mfleet.h
   trunk/source/melee/mframe.cpp
   trunk/source/sc1ships/shparisk.cpp
   trunk/source/scp.cpp
Log:
Fixed  issue 0000018: Stars are drawn on the wrong layer 


Modified: trunk/source/melee/mfleet.cpp
===================================================================
--- trunk/source/melee/mfleet.cpp	2005-02-27 11:19:17 UTC (rev 126)
+++ trunk/source/melee/mfleet.cpp	2005-02-27 12:46:51 UTC (rev 127)
@@ -38,89 +38,96 @@
 static char _fleetsort_ini_item[80] = "";
 
 
-
-char * Fleet::sortingMethodName[] = {
+char * Fleet::sortingMethodName[] = 
+  {
     "Name",
     "Cost", 
     "Species",
     "Ship Name",
     "Coders",
     "Origin"
-};
+  };
 
-char * Fleet::fleetCostName[] = {
+char * Fleet::fleetCostName[] = 
+  {
     "Small",//FLEET_SIZE_SMALL = 100,
     "Medium",//FLEET_SIZE_MEDIUM = 250,
     "Large",//FLEET_SIZE_LARGE = 500,
     "Huge",//FLEET_SIZE_HUGE = 1000,
     "Massive"//FLEET_SIZE_MASSIVE = 10000
-};
+  };
 
 
-//global variable used in at least 42 places. 
-//TODO remove this global variable and use proper Object-oriented techinques.
+///global variable used in at least 42 places. 
+///TODO remove this global variable and use proper Object-oriented techinques.
 Fleet* reference_fleet = NULL;
 
-//global function to initialize reference_fleet
-//TODO remove this global function and use proper Object-oriented techinques.
+///global function to initialize reference_fleet
+///TODO remove this global function and use proper Object-oriented techinques.
+void init_fleet() 
+{
+  STACKTRACE
+    if(reference_fleet)
+      return;
+  reference_fleet = new Fleet();
+  int i;
+  for(i = 0; i < num_shiptypes; i++)
+    reference_fleet->addShipType( &shiptypes[i] );
 
-void init_fleet() {STACKTRACE
-	if(reference_fleet)
-		return;
-	reference_fleet = new Fleet();
-	int i;
-	for(i = 0; i < num_shiptypes; i++)
-        reference_fleet->addShipType( &shiptypes[i] );
-
-	reference_fleet->Sort();
+  reference_fleet->Sort();
 }
 
-    Fleet::Fleet() {
+Fleet::Fleet() 
+{
   STACKTRACE;
-        cost = 0;
-        maxFleetCost = (FleetCost)FLEET_COST_DEFAULT;
-        memset(title, '\0', MAX_TITLE_LENGTH);
-    };
+  cost = 0;
+  maxFleetCost = (FleetCost)FLEET_COST_DEFAULT;
+  memset(title, '\0', MAX_TITLE_LENGTH);
+};
 
-    void Fleet::reset() {
+void Fleet::reset() 
+{
   STACKTRACE;
-        ships.clear();
-        this->cost = 0;
-        memset(title, '\0', MAX_TITLE_LENGTH);
-    }
+  ships.clear();
+  this->cost = 0;
+  memset(title, '\0', MAX_TITLE_LENGTH);
+}
 
-    void * Fleet::serialize (int *psize) {STACKTRACE
-        unsigned char buffy[65536];
-        int s = 0;
-        int j;
-        j = intel_ordering(getSize());
-        memcpy(&buffy[s], &j, sizeof(j)); s += sizeof(j);
+void * Fleet::serialize (int *psize) 
+{
+  STACKTRACE;
+  unsigned char buffy[65536];
+  int s = 0;
+  int j;
+  j = intel_ordering(getSize());
+  memcpy(&buffy[s], &j, sizeof(j)); s += sizeof(j);
 
-        MyFleetListType::iterator iter;
+  MyFleetListType::iterator iter;
 
-        for (iter = ships.begin(); iter != ships.end(); iter++) {
-            char k = strlen((*iter)->id);
-            if (k > 64)
-				{tw_error("serialize_fleet - that's a hell of a long ship id");}
-            memcpy(&buffy[s], &k, sizeof(k)); s += sizeof(k);
-        }
+  for (iter = ships.begin(); iter != ships.end(); iter++) {
+    char k = strlen((*iter)->id);
+    if (k > 64)
+      {tw_error("serialize_fleet - that's a hell of a long ship id");}
+    memcpy(&buffy[s], &k, sizeof(k)); s += sizeof(k);
+  }
 
-        for (iter = ships.begin(); iter != ships.end(); iter++) {
-            memcpy(&buffy[s], (*iter)->id, strlen((*iter)->id)); s += strlen((*iter)->id); 
-        }
+  for (iter = ships.begin(); iter != ships.end(); iter++) {
+    memcpy(&buffy[s], (*iter)->id, strlen((*iter)->id)); s += strlen((*iter)->id); 
+  }
 
-        unsigned char *holder = (unsigned char *) malloc(s);
-        memcpy(holder, buffy, s);
-        *psize = s;
-        return holder;    
-    }
+  unsigned char *holder = (unsigned char *) malloc(s);
+  memcpy(holder, buffy, s);
+  *psize = s;
+  return holder;    
+}
 
 
 
 #define READ(a) if (int(s+sizeof(a))>psize) {delete k;tw_error ("deserialize_fleet - bad!");}memcpy(&a, &buffy[s], sizeof(a)); s += sizeof(a);
 #define READ2(a,b) if (b+s>psize) {delete k;tw_error ("deserialize_fleet - bad!");}memcpy(&a, &buffy[s], b); s += b;
 
-void Fleet::deserialize(void *data, int psize) {
+void Fleet::deserialize(void *data, int psize) 
+{
   STACKTRACE;        
   unsigned char *buffy = (unsigned char *) data;
   int s = 0;
@@ -176,90 +183,95 @@
 #undef READ2
        
 
-    int Fleet::addShipType(ShipType * type) {
+int Fleet::addShipType(ShipType * type) 
+{
   STACKTRACE;
-        if ( (getSize() >= MAX_FLEET_SIZE) || (type == NULL))
-            return -1;
+  if ( (getSize() >= MAX_FLEET_SIZE) || (type == NULL))
+    return -1;
 
-        cost += type->cost;
-        ships.push_back(type);
+  cost += type->cost;
+  ships.push_back(type);
 
-        return ships.size()-1;
-    }
+  return ships.size()-1;
+}
 
-    void Fleet::addFleet(Fleet * fleetToAdd) {
+void Fleet::addFleet(Fleet * fleetToAdd) 
+{
   STACKTRACE;
-        for (int i=0; i<fleetToAdd->getSize(); i++)
-            addShipType(fleetToAdd->getShipType(i));
-    }
+  for (int i=0; i<fleetToAdd->getSize(); i++)
+    addShipType(fleetToAdd->getShipType(i));
+}
 
-    void Fleet::clear_slot (int slot) {STACKTRACE
-        if ( (slot >= getSize()) || (slot<0) )
-            return;
-        cost -= ships[slot]->cost;
-        ships.erase( ships.begin() + slot );
+void Fleet::clear_slot (int slot) {STACKTRACE
+				     if ( (slot >= getSize()) || (slot<0) )
+				       return;
+ cost -= ships[slot]->cost;
+ ships.erase( ships.begin() + slot );
     
-    }
+}
 
-    ShipType * Fleet::getShipType(int slot) {
+ShipType * Fleet::getShipType(int slot) 
+{
   STACKTRACE;
-        if ( (slot<0) || (slot>=(int)ships.size()))
-            return NULL;
+  if ( (slot<0) || (slot>=(int)ships.size()))
+    return NULL;
 
-        return ships[slot];
-    }
+  return ships[slot];
+}
 
-    void Fleet::save(const char *filename, const char *section) {
+void Fleet::save(const char *filename, const char *section) 
+{
   STACKTRACE;
-        int count = 0;
-        char slot_str[8];
+  int count = 0;
+  char slot_str[8];
     
-		std::sort(ships.begin(), ships.end());
+  std::sort(ships.begin(), ships.end());
 
         
-        if (filename) 
-            tw_set_config_file(filename);
+  if (filename) 
+    tw_set_config_file(filename);
 
-        for (MyFleetListType::iterator iter = ships.begin(); iter != ships.end(); iter++) {
-			if (!(*iter)) {tw_error("trying to save invalid ship type in fleet");}
-            sprintf(slot_str, "Slot%d", count);
-            set_config_string(section, slot_str, (*iter)->id);
-            count ++;
-        }
+  for (MyFleetListType::iterator iter = ships.begin(); iter != ships.end(); iter++) {
+    if (!(*iter)) {tw_error("trying to save invalid ship type in fleet");}
+    sprintf(slot_str, "Slot%d", count);
+    set_config_string(section, slot_str, (*iter)->id);
+    count ++;
+  }
 
-        set_config_int(section, "Size", count);
-        set_config_string(section, "Title", title);
-        set_config_int(section, "MaxFleetCost", getMaxCost());
-    }
+  set_config_int(section, "Size", count);
+  set_config_string(section, "Title", title);
+  set_config_int(section, "MaxFleetCost", getMaxCost());
+}
 
-    void Fleet::load(const char *filename, const char *section) {
+void Fleet::load(const char *filename, const char *section) 
+{
   STACKTRACE;
-        int i, count;
-        ShipType *type;
-        char slot_str[8];
-        const char *slot_id, *_fleet_title;
+  int i, count;
+  ShipType *type;
+  char slot_str[8];
+  const char *slot_id, *_fleet_title;
     
-        reset();
+  reset();
     
-        if (filename) tw_set_config_file(filename);
-        int _fleet_size = get_config_int(section, "Size", 0);
-        _fleet_title = get_config_string(section, "Title", "");
-        //sprintf(title, _fleet_title);	this is a bit dangerous
-		strcpy(title, _fleet_title);
-        maxFleetCost = (FleetCost) get_config_int(section, "MaxFleetCost", FLEET_COST_DEFAULT);
+  if (filename) tw_set_config_file(filename);
+  int _fleet_size = get_config_int(section, "Size", 0);
+  _fleet_title = get_config_string(section, "Title", "");
+  //sprintf(title, _fleet_title);	this is a bit dangerous
+  strcpy(title, _fleet_title);
+  maxFleetCost = (FleetCost) get_config_int(section, "MaxFleetCost", FLEET_COST_DEFAULT);
     
-        count = 0;
-        for(i = 0; i < _fleet_size; i++) {
-            sprintf(slot_str, "Slot%d", i);
-            slot_id = get_config_string(section, slot_str, "?????");
-            type = shiptype(slot_id);
-            if (type) {
-                addShipType(type);
-                count++;
-            }
-        }
-        return;
+  count = 0;
+  for(i = 0; i < _fleet_size; i++) {
+    sprintf(slot_str, "Slot%d", i);
+    slot_id = get_config_string(section, slot_str, "?????");
+    type = shiptype(slot_id);
+    if (type) {
+      addShipType(type);
+      count++;
     }
+  }
+  return;
+}
 
 /// \brief Config Sort function
 static bool _CharConfigAscendingP(ShipType * x, ShipType * y)
@@ -269,12 +281,12 @@
   
   tw_set_config_file(x->file);
   char * tmp1 = strdup(get_config_string(_fleetsort_ini_section,
-					_fleetsort_ini_item, 
-					_fleetsort_ini_alphabetical_default));
+					 _fleetsort_ini_item, 
+					 _fleetsort_ini_alphabetical_default));
   tw_set_config_file(y->file);
   char * tmp2 = strdup(get_config_string(_fleetsort_ini_section,
-					_fleetsort_ini_item, 
-					_fleetsort_ini_alphabetical_default));
+					 _fleetsort_ini_item, 
+					 _fleetsort_ini_alphabetical_default));
   if (!tmp1 || !tmp2)
     return false;
   
@@ -305,28 +317,32 @@
 }
 /// \brief Sort object
 struct _NumericConfigAscending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     return _IntConfigAscendingP(x, y);
   }
 };
 
 /// \brief Sort Object
 struct _NumericConfigDescending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     return !_IntConfigAscendingP(x, y);
   }
 };
 
 /// \brief Sort object
 struct _AlphabeticConfigAscending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     return _CharConfigAscendingP(x, y);
   }
 };
 
 /// \brief Sort object
 struct _AlphabeticConfigDescending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     return !_CharConfigAscendingP(x, y);   
   }
 };
@@ -341,8 +357,10 @@
 };
 
 /// \brief Sort object
-struct _nameDecending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+struct _nameDecending : public std::binary_function<ShipType *, ShipType *, bool> 
+{
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     if ((x) && (y))
       return strcmp(x->name, y->name) < 0; 
     else 
@@ -351,8 +369,10 @@
 };
 
 /// \brief Sort object
-struct _costAscending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+struct _costAscending : public std::binary_function<ShipType *, ShipType *, bool> 
+{
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     if (x && y)
       return (x->cost < y->cost); 
     else 
@@ -361,8 +381,10 @@
 };
 
 /// \brief Sort object
-struct _costDecending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+struct _costDecending : public std::binary_function<ShipType *, ShipType *, bool> 
+{
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     if (x && y)
       return (x->cost > y->cost);  
     else
@@ -371,8 +393,10 @@
 };
 
 /// \brief Sort object
-struct _originAscending : public std::binary_function<ShipType *, ShipType *, bool> {
-  bool operator()(ShipType * x, ShipType * y) { 
+struct _originAscending : public std::binary_function<ShipType *, ShipType *, bool> 
+{
+  bool operator()(ShipType * x, ShipType * y) 
+  { 
     if (x && y)
       return (x->origin < y->origin); 
     else 
@@ -381,7 +405,8 @@
 };
 
 /// \brief Sort object    
-struct _originDecending : public std::binary_function<ShipType *, ShipType *, bool> {
+struct _originDecending : public std::binary_function<ShipType *, ShipType *, bool> 
+{
   bool operator()(ShipType * x, ShipType * y) { 
     if (x && y)
       return (x->origin > y->origin);  
@@ -390,7 +415,8 @@
   }
 };
 
-void Fleet::Sort(SortingMethod sortMethod, bool ascending, int startIndex, int endIndex) {
+void Fleet::Sort(SortingMethod sortMethod, bool ascending, int startIndex, int endIndex) 
+{
   STACKTRACE;
   MyFleetListType::iterator _begin, _end;
   int _size = ships.size();
@@ -427,14 +453,14 @@
       std::sort(_begin, _end, _costAscending());
     else
       std::sort(_begin, _end, _costDecending());
-                break;
+    break;
 		
   case SORTING_METHOD_NAME1:                
     strcpy(_fleetsort_ini_item, "Name1");
     if (ascending)
       std::sort(_begin, _end, _AlphabeticConfigAscending());
-                else
-		  std::sort(_begin, _end, _AlphabeticConfigDescending());
+    else
+      std::sort(_begin, _end, _AlphabeticConfigDescending());
     break;
     
   case SORTING_METHOD_NAME2:
@@ -470,33 +496,34 @@
   }
 }
 
-int Fleet::getNextFleetEntryByCharacter(unsigned int currentShip, char c) {
+int Fleet::getNextFleetEntryByCharacter(unsigned int currentShip, char c) 
+{
   STACKTRACE;
         
-        ASSERT(ships.at(currentShip) != NULL);
-        ASSERT(currentShip < ships.size());
-        ASSERT(currentShip >=0);
-        c = toupper(c);
+  ASSERT(ships.at(currentShip) != NULL);
+  ASSERT(currentShip < ships.size());
+  ASSERT(currentShip >=0);
+  c = toupper(c);
 	
-	unsigned int i;
-        for (i=currentShip+1; i<ships.size(); i++) {
-            MyFleetShipType temp = ships.at(i);
-            ASSERT(temp!=NULL);
-            ASSERT(temp->name != NULL);
+  unsigned int i;
+  for (i=currentShip+1; i<ships.size(); i++) {
+    MyFleetShipType temp = ships.at(i);
+    ASSERT(temp!=NULL);
+    ASSERT(temp->name != NULL);
 
-            if (toupper(temp->name[0]) == c) {
-                return i;
-            }
-        }
+    if (toupper(temp->name[0]) == c) {
+      return i;
+    }
+  }
 
-        for (i=0; i<currentShip; i++) {
-            MyFleetShipType temp = ships.at(i);
-            ASSERT(temp!=NULL);
-            ASSERT(temp->name != NULL);
+  for (i=0; i<currentShip; i++) {
+    MyFleetShipType temp = ships.at(i);
+    ASSERT(temp!=NULL);
+    ASSERT(temp->name != NULL);
 
-            if (temp->name[0] == c) {
-                return i;
-            }
-        }
-        return currentShip;
+    if (temp->name[0] == c) {
+      return i;
     }
+  }
+  return currentShip;
+}

Modified: trunk/source/melee/mfleet.h
===================================================================
--- trunk/source/melee/mfleet.h	2005-02-27 11:19:17 UTC (rev 126)
+++ trunk/source/melee/mfleet.h	2005-02-27 12:46:51 UTC (rev 127)
@@ -30,9 +30,9 @@
 void init_fleet();	// inits reference_fleet [former shiptype array]
 
 /**	\brief	Contains a list of ships. */
-class Fleet{
+class Fleet
+{
 
-
 protected:
     typedef unsigned int Index;
     typedef ShipType * MyFleetShipType;

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2005-02-27 11:19:17 UTC (rev 126)
+++ trunk/source/melee/mframe.cpp	2005-02-27 12:46:51 UTC (rev 127)
@@ -1269,8 +1269,7 @@
   
   std::copy(item.begin(),item.end(),back_inserter(animate_buffer));
   animate_buffer2 = presence;
-  animate_buffer.merge(animate_buffer2);
-  //animate_buffer.merge(presence);
+  animate_buffer.merge(animate_buffer2,presence_cmp);
 
   prepare();
   RGB back = { frame->background_red, frame->background_green, frame->background_blue };

Modified: trunk/source/sc1ships/shparisk.cpp
===================================================================
--- trunk/source/sc1ships/shparisk.cpp	2005-02-27 11:19:17 UTC (rev 126)
+++ trunk/source/sc1ships/shparisk.cpp	2005-02-27 12:46:51 UTC (rev 127)
@@ -1,7 +1,7 @@
 /* $Id$ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -20,96 +20,105 @@
 #include "sc1ships.h"
 
 ArilouSkiff::ArilouSkiff(Vector2 opos, double angle, ShipData *data, unsigned int code) 
-	:
-	Ship(opos, angle, data, code)
-	{
+  :
+  Ship(opos, angle, data, code)
+{
   STACKTRACE;
-	specialSprite = data->spriteSpecial;
+  specialSprite = data->spriteSpecial;
+  
+  weaponColor  = get_config_int("Weapon", "Color", 0);
+  weaponDamage = get_config_int("Weapon", "Damage", 0);
+  weaponRange  = scale_range(get_config_float("Weapon", "Range", 0));
+  weaponFrames = get_config_int("Weapon", "Frames", 0);
+  
+  specialFrames = get_config_float("Special", "Frames", 0);
+  
+  just_teleported = 0;
+}
 
-	weaponColor  = get_config_int("Weapon", "Color", 0);
-	weaponDamage = get_config_int("Weapon", "Damage", 0);
-	weaponRange  = scale_range(get_config_float("Weapon", "Range", 0));
-	weaponFrames = get_config_int("Weapon", "Frames", 0);
-
-	specialFrames = get_config_float("Special", "Frames", 0);
-
-	just_teleported = 0;
-	}
-
 void ArilouSkiff::inflict_damage(SpaceObject *other) {
   STACKTRACE;
-	if (just_teleported && other->mass) {
-		damage(this, 0, 999);
-		}
-	else Ship::inflict_damage(other);
-	return;
-	}
+  if (just_teleported && other->mass) {
+    damage(this, 0, 999);
+  }
+  else Ship::inflict_damage(other);
+  return;
+}
 
-int ArilouSkiff::activate_weapon() {
+int ArilouSkiff::activate_weapon() 
+{
   STACKTRACE;
-	SpaceObject *o = NULL;
+  SpaceObject *o = NULL;
+  
+  double r = 99999;  
 
-	double r = 99999;  
+  Query a;
+  for (a.begin(this, bit(LAYER_SHIPS), weaponRange + 200); a.current; a.next()) {
+    if ((distance(a.current) < r) && !a.current->isInvisible()) 
+      {
+	o = a.currento;
+	r = distance(o);
+      }
+  }
+  
+  if (o) r = trajectory_angle(o); else r = angle;
+  game->add(new Laser(this, r, pallete_color[weaponColor], 
+		      weaponRange, weaponDamage, weaponFrames, this));
+  return TRUE;
+}
 
-	Query a;
-	for (a.begin(this, bit(LAYER_SHIPS), weaponRange + 200); a.current; a.next()) {
-		if ((distance(a.current) < r) && !a.current->isInvisible()) {
-			o = a.currento;
-			r = distance(o);
-			}
-		}
+int ArilouSkiff::activate_special() 
+{
+  STACKTRACE;
+  
+  game->add(new Animation(this, pos,
+			  specialSprite, 0, 40, iround(specialFrames/40), DEPTH_HOTSPOTS-0.1));
+  
+  Vector2 d = Vector2 ( 
+		       random(-1500.0, 1500.0),
+		       random(-1500.0, 1500.0)
+		       );
+  translate(d);
+  just_teleported = 1;
+  
+  game->add(new Animation(this, pos,
+			  specialSprite, 0, 40, iround(specialFrames/40), DEPTH_HOTSPOTS-0.1));
+  return(TRUE);
+}
 
-	if (o) r = trajectory_angle(o); else r = angle;
-	game->add(new Laser(this, r, pallete_color[weaponColor], 
-		weaponRange, weaponDamage, weaponFrames, this));
-	return TRUE;
-	}
-
-int ArilouSkiff::activate_special() {
+void ArilouSkiff::calculate() 
+{
   STACKTRACE;
+  just_teleported = 0;
+  Ship::calculate();
+  
+  if(!thrust) 
+    {
+    vel *= 1 - frame_time * 0.02;
+    }
+}
 
-	game->add(new Animation(this, pos,
-			specialSprite, 0, 40, iround(specialFrames/40), DEPTH_HOTSPOTS-0.1));
-	
-	Vector2 d = Vector2 ( 
-		random(-1500.0, 1500.0),
-		random(-1500.0, 1500.0)
-	);
-	translate(d);
-	just_teleported = 1;
-
-	game->add(new Animation(this, pos,
-			specialSprite, 0, 40, iround(specialFrames/40), DEPTH_HOTSPOTS-0.1));
-	return(TRUE);
-	}
-
-void ArilouSkiff::calculate() {
+void ArilouSkiff::calculate_gravity() 
+{
   STACKTRACE;
-	just_teleported = 0;
-	Ship::calculate();
+}
 
-	if(!thrust) {
-		vel *= 1 - frame_time * 0.02;
-		}
-	}
-
-void ArilouSkiff::calculate_gravity() {
-  STACKTRACE;}
-
 int ArilouSkiff::accelerate(SpaceLocation *source, double angle, double velocity, 
-		double max_speed) {
+		double max_speed) 
+{
   STACKTRACE;
-	if (source == this) 
-		return Ship::accelerate(source, angle, velocity, max_speed);
-	return false;
-	}
+  if (source == this) 
+    return Ship::accelerate(source, angle, velocity, max_speed);
+  return false;
+}
 
 int ArilouSkiff::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
-		double max_speed) {
+		double max_speed) 
+{
   STACKTRACE;
-	if (source == this) 
-		return Ship::accelerate(source, angle, velocity, max_speed);
-	return false;
-	}
+  if (source == this) 
+    return Ship::accelerate(source, angle, velocity, max_speed);
+  return false;
+}
 
 REGISTER_SHIP(ArilouSkiff)

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-02-27 11:19:17 UTC (rev 126)
+++ trunk/source/scp.cpp	2005-02-27 12:46:51 UTC (rev 127)
@@ -1315,9 +1315,6 @@
        fleetDialog[FLEET_DIALOG_SORTBY_ASCENDING1].dp = (void *)"v";
      break;
 
-           
-           
-
    case FLEET_DIALOG_AVAILABLE_SHIPS_LIST:
    case FLEET_DIALOG_ADD_BUTTON: 
      int k;



From yurand at sheep.berlios.de  Sun Feb 27 16:15:32 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 27 Feb 2005 16:15:32 +0100
Subject: [Tw-light-svn] r128 - in trunk: gamedata source source/ais source/melee source/sc1ships source/sc2ships source/ships
Message-ID: <200502271515.j1RFFWYj009931@sheep.berlios.de>

Author: yurand
Date: 2005-02-27 16:15:31 +0100 (Sun, 27 Feb 2005)
New Revision: 128

Modified:
   trunk/gamedata/ingame.txt
   trunk/source/ais/c_other.cpp
   trunk/source/ais/c_wussie.cpp
   trunk/source/doxygen.cpp
   trunk/source/melee/mcontrol.h
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mframe.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/mitems.cpp
   trunk/source/melee/mship.cpp
   trunk/source/melee/mship.h
   trunk/source/melee/mshot.cpp
   trunk/source/melee/mview.cpp
   trunk/source/sc1ships/shpchebr.cpp
   trunk/source/sc1ships/shpearcr.cpp
   trunk/source/sc1ships/shpilwav.cpp
   trunk/source/sc1ships/shpkzedr.cpp
   trunk/source/sc1ships/shpmmrxf.cpp
   trunk/source/sc1ships/shpmycpo.cpp
   trunk/source/sc1ships/shpspael.cpp
   trunk/source/sc1ships/shpvuxin.cpp
   trunk/source/sc2ships/shpchmav.cpp
   trunk/source/sc2ships/shporzne.cpp
   trunk/source/ships/shpalabc.cpp
   trunk/source/ships/shpchoex.cpp
   trunk/source/ships/shpconho.cpp
   trunk/source/ships/shpdragr.cpp
   trunk/source/ships/shpearc3.cpp
   trunk/source/ships/shprogsq.cpp
   trunk/source/ships/shpstaba.cpp
   trunk/source/ships/shptauda.cpp
   trunk/source/ships/shptaust.cpp
Log:
Implemented issue  0000013: add targeting square
Use 'O' key to toggle targets


Modified: trunk/gamedata/ingame.txt
===================================================================
--- trunk/gamedata/ingame.txt	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/gamedata/ingame.txt	2005-02-27 15:15:31 UTC (rev 128)
@@ -13,8 +13,9 @@
   - zooms out on some viewing modes.
   + (or =) zooms in on some viewing modes.
   0 and 9 also effect the camera in some viewing modes.
-  ctrl+T = toggle team indicators on/off
-  ctrl+H = toggle healthbar indicators on/off
+  T = toggle team indicators on/off
+  H = toggle healthbar indicators on/off
+  O = toggle track target indicator
   ctrl+Alt+k = kill all ships and ship-objects in the melee-game
 Melee:  
   Starts a battle with the current team settings.

Modified: trunk/source/ais/c_other.cpp
===================================================================
--- trunk/source/ais/c_other.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ais/c_other.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -61,14 +61,14 @@
     {
       int r = 0;
       double a;
-      if (!ship->target) 
+      if (!ship->get_target()) 
 	return 0;
-      if (!ship->target->exists()) 
+      if (!ship->get_target()->exists()) 
 	{
-	  ship->target = NULL;
+	  ship->set_target(NULL);
 	  return 0;
 	}
-      a = ship->trajectory_angle(ship->target) - ship->get_angle();
+      a = ship->trajectory_angle(ship->get_target()) - ship->get_angle();
       a = fmod(a + PI2, PI2);
       if (a < PI) 
 	{
@@ -79,7 +79,7 @@
 	  r |= keyflag::left;
 	  return r;
 	}
-      a = int(ship->distance(ship->target));
+      a = int(ship->distance(ship->get_target()));
       if (a > 2000) 
 	{
 	  r |= keyflag::thrust;

Modified: trunk/source/ais/c_wussie.cpp
===================================================================
--- trunk/source/ais/c_wussie.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ais/c_wussie.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -198,7 +198,7 @@
   int avoid_planet = FALSE;
   Query ap;
   SpaceObject *p;
-  if (ship->target && !ship->target->isInvisible ())
+  if (ship->get_target() && !ship->get_target()->isInvisible ())
     last_seen_time = game->game_time;
   else if ((rand () & 32767) < frame_time)
     last_seen_time = game->game_time - 1000;
@@ -227,7 +227,7 @@
     }
   if (!avoid_planet)
     {
-      if (!ship->target || (last_seen_time < game->game_time - 3000)) 
+      if (!ship->get_target() || (last_seen_time < game->game_time - 3000)) 
 	{
 	  if ((rand() & 4095) < frame_time) 
 	    {
@@ -236,12 +236,12 @@
 	    }
 	  return 0;
 	}
-      if (!ship->target->exists ())
+      if (!ship->get_target()->exists ())
 	{
-	  ship->target = NULL;
+	  ship->set_target(NULL);
 	  return 0;
 	}
-      distance = ship->distance (ship->target);
+      distance = ship->distance (ship->get_target());
       switch (tactic[state])
 	{
 	default:
@@ -258,24 +258,24 @@
 	    {
 	      velocity = ship->speed_max;
 	    }
-	  angle = intercept_angle2( ship->normal_pos(), ship->get_vel() * rel, velocity, ship->target->normal_pos(),
-				    ship->target->get_vel() ) - ship->get_angle();
+	  angle = intercept_angle2( ship->normal_pos(), ship->get_vel() * rel, velocity, ship->get_target()->normal_pos(),
+				    ship->get_target()->get_vel() ) - ship->get_angle();
 	}break;
 	
 	case TACTIC_DIRECT_INTERCEPT:
-	  angle = ship->trajectory_angle (ship->target) - ship->get_angle ();
+	  angle = ship->trajectory_angle (ship->get_target()) - ship->get_angle ();
 	  break;
 	  
 	case TACTIC_RANGE:
 	  if (tactic_state == STATE_TOO_FAR)
 	    {
-	      angle = ship->trajectory_angle (ship->target) - ship->get_angle ();
+	      angle = ship->trajectory_angle (ship->get_target()) - ship->get_angle ();
 	      if (distance < min_range[state])
 		tactic_state = STATE_TOO_CLOSE;
 	    }
 	  else
 	    {
-	      angle = ship->trajectory_angle (ship->target) - ship->get_angle () + PI;
+	      angle = ship->trajectory_angle (ship->get_target()) - ship->get_angle () + PI;
 	      if (distance > max_range[state])
 		tactic_state = STATE_TOO_FAR;
 	    }
@@ -302,15 +302,15 @@
     }
   action |= keyflag::thrust;
   int i, j;
-  if (!ship->target)
+  if (!ship->get_target())
     return action;
-  if (!ship->target->exists ())
+  if (!ship->get_target()->exists ())
     {
-      ship->target = NULL;
+      ship->set_target(NULL);
       return action;
     }
   
-  distance = ship->distance (ship->target);
+  distance = ship->distance (ship->get_target());
   for (j = 0; j < 2; j++)
     {
       fireoption[j] = FALSE;
@@ -409,10 +409,10 @@
 	      break;
 	      
 	    case OPTION_MINE:
-	      a = atan(ship->target->get_vel ());
+	      a = atan(ship->get_target()->get_vel ());
 	      if (fabs
 		  (normalize
-		   (ship->target->trajectory_angle (ship) + PI/2,
+		   (ship->get_target()->trajectory_angle (ship) + PI/2,
 		    PI2) - a) < sweep[j])
 		fireoption[j] = TRUE;
 	      field_fire = FALSE;
@@ -453,14 +453,14 @@
 		  normalize (bomby[j], map_size.y);
 		  bomb =
 		    new SpaceLocation (NULL, Vector2(bombx[j], bomby[j]), 0);
-		  if (ship->target->distance (bomb) > bombdistance[j])
+		  if (ship->get_target()->distance (bomb) > bombdistance[j])
 		    {
 		      option_held[j] = FALSE;
 		      dontfireoption[j] = TRUE;
 		    }
 		  else
 		    {
-		      bombdistance[j] = ship->target->distance (bomb);
+		      bombdistance[j] = ship->get_target()->distance (bomb);
 		    }
 		  delete bomb;
 		}
@@ -500,7 +500,7 @@
 		  (ship->get_vel().y * rel[state][j]) +
 		  (option_velocity[state][j] *
 		   sin (ship->get_angle ()));
-		bombdistance[j] = ship->distance (ship->target);
+		bombdistance[j] = ship->distance (ship->get_target());
 	      }
 	  }
 	if (option_type[state][j][i] == OPTION_HOLD)

Modified: trunk/source/doxygen.cpp
===================================================================
--- trunk/source/doxygen.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/doxygen.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -39,8 +39,10 @@
  *       - - zooms out on some viewing modes.
  *       - + (or =) zooms in on some viewing modes.
  *       - 0 also effect the camera in some viewing modes.
- *       - ctrl+T = toggle team indicators on/off
- *       - ctrl+H = toggle healthbar indicators on/off
+ *       - T = toggle team indicators on/off
+ *       - H = toggle healthbar indicators on/off
+ *       - O = toggle track target indicator
+ *       - ctrl+Alt+k = kill all ships and ship-objects in the melee-game
  *       - Also, if some controllers are set to keyboard, customizable
  *	 - buttons may cause ship actions.  Be default these are:
  *       - Config 0:
@@ -68,9 +70,7 @@
  * 
  *   - Introduce the most interesting and cool TimeWarp ships
  *   - Simplify and fix melee engine
- *   - Add TimeWarp Markup Language (TML) support
  *   - Write plot
- *   - Implement plot with TML
  *
  * \subsection intoro Introduce the most interesting and cool TimeWarp ships
  * 
@@ -99,17 +99,11 @@
  * 
  *  Almost done.
  * 
- * \subsection TML_subsec Add TimeWarp Markup Language (TML) support
  * 
- *  No progress.
- * 
  * \subsection plot_subsec Write plot
  * 
  *  The Plot is fully writen.
  *
- * \subsection plot_impl_subsec  Implement plot with TML
- * 
- *  No progress.
  *
  * \section licene_sec License
  *

Modified: trunk/source/melee/mcontrol.h
===================================================================
--- trunk/source/melee/mcontrol.h	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mcontrol.h	2005-02-27 15:15:31 UTC (rev 128)
@@ -34,6 +34,7 @@
 extern char **control_name;
 Control *getController(const char *type, const char *name, int channel);
 
+/// Exactly as it say 
 class Control : public Presence {	
 	public:
 
@@ -45,7 +46,7 @@
 	unsigned char target_sign_color;
   /*! \brief this pertains to network traffic - see comment above calculate() in mcontrol.cpp */
   int already;
-	int channel;
+  int channel;
 
 
   /*! \brief points at the current ship being controlled */

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mframe.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -397,33 +397,45 @@
 		ship = creator->ship;
 		data = creator->data;
 		if (data) data->lock();
-		target = creator->target;
+		set_target( creator->get_target());
 		}
 	else {
 		ally_flag = 0;
 		ship = NULL;
 		data = NULL;
-		target = NULL;
+		set_target(NULL);
 		}
 }
 
 
-SpaceLocation::~SpaceLocation() {STACKTRACE
-	if (data) data->unlock();
+SpaceLocation::~SpaceLocation() 
+{
+  STACKTRACE;
+  if (data) 
+    data->unlock();
+}
 
-	}
+SpaceObject* SpaceLocation::get_target()
+{
+  return _target;
+}
 
+void SpaceLocation::set_target(SpaceObject* target)
+{
+  _target = target;
+}
+
 bool SpaceLocation::change_owner(SpaceLocation *new_owner) {
   STACKTRACE;
 	if (new_owner) {
 		ally_flag = new_owner->ally_flag;
 		ship = new_owner->ship;
-		target = new_owner->target;
+		set_target( new_owner->get_target());
 		}
 	else {
 		ally_flag = 0;
 		ship = NULL;
-		target = NULL;
+		set_target( NULL);
 		}
 	return true;
 	}
@@ -506,9 +518,10 @@
   STACKTRACE;
 	ship = NULL;
 }
-void SpaceLocation::target_died() {
+void SpaceLocation::target_died() 
+{
   STACKTRACE;
-	target = NULL;
+  set_target(NULL);
 }
 
 double SpaceLocation::trajectory_angle(SpaceLocation *l) {
@@ -682,7 +695,7 @@
 void SpaceLocation::calculate() 
 {
   STACKTRACE;
-  if (target && !target->exists()) 
+  if (get_target() && !get_target()->exists()) 
     {
       target_died();
     }

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mframe.h	2005-02-27 15:15:31 UTC (rev 128)
@@ -176,10 +176,18 @@
 /// \brief any item in the game that has a location, base class for all items in game
 class SpaceLocation : public Presence 
 { 
+
+ private:
   friend class Physics;
   friend struct Query;
+  
+ protected:
+  SpaceObject *_target; ///< it's target, if it has one
+ public: 
+  
+  virtual SpaceObject* get_target();
+  virtual void set_target(SpaceObject*);
 
- protected: public: 
   //aught to be protected, but we're lazy
   Vector2 pos;
   union 
@@ -206,7 +214,6 @@
 
   Ship *ship;          ///< the ship it's associated with
   ShipData *data;      ///< the data module it depends upon
-  SpaceObject *target; ///< it's target, if it has one
 
   inline  bool sameShip (const SpaceLocation *other) {return ally_flag == other->ally_flag;}
   virtual bool sameTeam (const SpaceLocation *other) const;

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mgame.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -848,6 +848,7 @@
   music = "";
   indteamtoggle = 0;
   indhealthtoggle = 0;
+  _targrettrack = 0;
   indhealthtoggle = ~indhealthtoggle;
 }
 
@@ -1157,6 +1158,9 @@
     case KEY_T:
 	  indteamtoggle = ~indteamtoggle;
       break;
+    case KEY_O:
+	  _targrettrack = ~_targrettrack;
+	  break;
     case KEY_F1: 
       {// help
 	pause();

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mgame.h	2005-02-27 15:15:31 UTC (rev 128)
@@ -233,6 +233,7 @@
   int show_fps;
   unsigned char local_checksum, client_checksum, server_checksum;
   int indhealthtoggle, indteamtoggle;
+  int _targrettrack;
 };
 
 

Modified: trunk/source/melee/mitems.cpp
===================================================================
--- trunk/source/melee/mitems.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mitems.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -264,7 +264,7 @@
 	vel.y = va * sin(angle) - vb * cos(angle);
 	return;
 	}
-// this should be places elsewhere I think ...
+
 TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
 {
   STACKTRACE;

Modified: trunk/source/melee/mship.cpp
===================================================================
--- trunk/source/melee/mship.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mship.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -33,6 +33,7 @@
 #include "mview.h"
 #include "other/twconfig.h"
 #include "scp.h"
+#include "mitems.h"
 
 /*------------------------------*
  *		Ship Class Registration *
@@ -237,25 +238,26 @@
 }
 
 void init_ships() {
-     _register_shiptype_dir ( home_ini_full_path("ships").c_str(), FA_DIREC|FA_RDONLY, 3 );
- return;
+  _register_shiptype_dir ( home_ini_full_path("ships").c_str(), FA_DIREC|FA_RDONLY, 3 );
+  return;
 }
 
 
 
 int hot_color[HOT_COLORS] =
-{
-  122, 123, 124, 125, 126, 127,
-  42,  43,  44,  45,  46,  47
-};
+  {
+    122, 123, 124, 125, 126, 127,
+    42,  43,  44,  45,  46,  47
+  };
 
 
 Ship::Ship(SpaceLocation *creator, Vector2 opos, double oangle, SpaceSprite *osprite) :
-	SpaceObject(creator, opos, oangle, osprite),
-	death_counter(-1),
-	update_panel(false),
-	target_pressed(false),
-	control(NULL)
+  SpaceObject(creator, opos, oangle, osprite),
+  death_counter(-1),
+  update_panel(false),
+  target_pressed(false),
+  control(NULL),
+  _target_TeamIndicator(NULL)
 {
   STACKTRACE;
   attributes |= ATTRIB_SHIP;
@@ -296,7 +298,8 @@
   death_counter(-1),
   update_panel(false),
   target_pressed(false),
-  control(NULL)
+  control(NULL),
+  _target_TeamIndicator(NULL)
 {
   STACKTRACE;
   shipData->lock();
@@ -379,7 +382,7 @@
 			30, 51, 
 			pallete_color[0], 
 			captain_name
-		);
+			);
       spritePanel->unlock();
     }
   
@@ -389,6 +392,23 @@
   hashotspots = true;
 }
 
+
+void Ship::set_target(SpaceObject* target)
+{
+  if(_target_TeamIndicator && _target_TeamIndicator->exists())
+    {
+      _target_TeamIndicator->die();
+    }
+  _target_TeamIndicator = NULL;
+  if(target && !strcmp(control->getTypeName(),"Keyboard/Joystick"))
+    {
+      /// dangerous stuff
+      _target_TeamIndicator = new TeamIndicator((Ship*)target, &(game->_targrettrack));
+	game->add(_target_TeamIndicator);
+    }
+  SpaceObject::set_target(target);
+}
+
 void Ship::death() 
 {
   STACKTRACE;
@@ -397,6 +417,14 @@
       game->ship_died(this, NULL);
       attributes &= ~ATTRIB_NOTIFY_ON_DEATH;
     }
+    if(_target_TeamIndicator)
+    {
+      if(_target_TeamIndicator->exists())
+	{
+	  _target_TeamIndicator->die();
+	}
+      _target_TeamIndicator = NULL;
+    }
   return;
 }
 
@@ -420,8 +448,8 @@
 RGB Ship::crewPanelColor(int k)
 {
   STACKTRACE;
-	RGB c = {0,225,0};
-	return c;
+  RGB c = {0,225,0};
+  return c;
 }
 
 RGB Ship::battPanelColor(int k)
@@ -653,7 +681,7 @@
   
   target_pressed = target_next | target_prev | target_closest;
   if (control)
-    target = control->target;
+    set_target(control->target);
   
   calculate_turn_left();
   calculate_turn_right();
@@ -779,59 +807,59 @@
 void Ship::assigntarget(SpaceObject *otarget)
 {
   STACKTRACE;
-	target = otarget;
+  set_target(otarget);
 }
 
 
 void Ship::calculate_thrust() {
   STACKTRACE;
-	if (thrust)
-		accelerate_gravwhip(this, angle, accel_rate * frame_time, speed_max);
-	return;
+  if (thrust)
+    accelerate_gravwhip(this, angle, accel_rate * frame_time, speed_max);
+  return;
 }
 
 void Ship::calculate_turn_left()
 {
   STACKTRACE;
   if(turn_left)
-		turn_step -= turn_rate * frame_time;
+    turn_step -= turn_rate * frame_time;
 }
 
 void Ship::calculate_turn_right()
 {
   STACKTRACE;
   if(turn_right)
-		turn_step += turn_rate * frame_time;
+    turn_step += turn_rate * frame_time;
 }
 
 void Ship::calculate_fire_weapon() {
   STACKTRACE;
-	weapon_low = FALSE;
+  weapon_low = FALSE;
 
-	if (fire_weapon) {
-		if (batt < weapon_drain) {
-			weapon_low = true;
-			return;
-		}
+  if (fire_weapon) {
+    if (batt < weapon_drain) {
+      weapon_low = true;
+      return;
+    }
 
-		if (weapon_recharge > 0)
-			return;
+    if (weapon_recharge > 0)
+      return;
 
-		if (!activate_weapon())
-			return;
+    if (!activate_weapon())
+      return;
 
-		batt -= weapon_drain;
-		if (recharge_amount > 1)
-			recharge_step = recharge_rate;
-		weapon_recharge += weapon_rate;
+    batt -= weapon_drain;
+    if (recharge_amount > 1)
+      recharge_step = recharge_rate;
+    weapon_recharge += weapon_rate;
 
-		if (weapon_sample >= 0)
-		  {
-		    tw_sound->stop_sound(data_full_path(data->sampleWeapon[weapon_sample]));
-		    tw_sound->play_sound(data_full_path(data->sampleWeapon[weapon_sample]));
-		  }
-	}
-	return;
+    if (weapon_sample >= 0)
+      {
+	tw_sound->stop_sound(data_full_path(data->sampleWeapon[weapon_sample]));
+	tw_sound->play_sound(data_full_path(data->sampleWeapon[weapon_sample]));
+      }
+  }
+  return;
 }
 
 void Ship::calculate_fire_special()
@@ -891,99 +919,99 @@
 
 void Ship::animate(Frame *frame) {
   STACKTRACE;
-	SpaceObject::animate(frame);
+  SpaceObject::animate(frame);
 }
 
 double Ship::get_angle_ex() const
 {
-	return normalize(angle + turn_step, PI2);
+  return normalize(angle + turn_step, PI2);
 }
 
 ShipType *Ship::get_shiptype()
 {
   STACKTRACE;
-	return type;
+  return type;
 }
 
 
 Phaser::Phaser(
-	SpaceLocation *creator, Vector2 opos, Vector2 _rpos, 
-	Ship *ship, SpaceSprite *sprite, int osprite_index, int *ocolors, 
-	int onum_colors, int ofsize, int steps, int step_size) :
-	SpaceObject(creator, opos, 0.0, sprite),
-	rel_pos(_rpos),
-	ship(ship),
-	sprite_index(osprite_index),
-	colors(ocolors),
-	num_colors(onum_colors),
-	color_index(0),
-	frame_size(ofsize),
-	frame_step(ofsize),
-	phaser_step_position(0),
-	phaser_steps(steps),
-	phaser_step_size(step_size)
+	       SpaceLocation *creator, Vector2 opos, Vector2 _rpos, 
+	       Ship *ship, SpaceSprite *sprite, int osprite_index, int *ocolors, 
+	       int onum_colors, int ofsize, int steps, int step_size) :
+  SpaceObject(creator, opos, 0.0, sprite),
+  rel_pos(_rpos),
+  ship(ship),
+  sprite_index(osprite_index),
+  colors(ocolors),
+  num_colors(onum_colors),
+  color_index(0),
+  frame_size(ofsize),
+  frame_step(ofsize),
+  phaser_step_position(0),
+  phaser_steps(steps),
+  phaser_step_size(step_size)
 {
   STACKTRACE;
-	layer = LAYER_HOTSPOTS;
-	set_depth(DEPTH_HOTSPOTS);
-	collide_flag_anyone = 0;
-	mass = 0;
+  layer = LAYER_HOTSPOTS;
+  set_depth(DEPTH_HOTSPOTS);
+  collide_flag_anyone = 0;
+  mass = 0;
 
-	attributes |= ATTRIB_UNDETECTABLE;
+  attributes |= ATTRIB_UNDETECTABLE;
 
-	// extra check
-	// note that if this happens, there's something wrong in the ships' constructor...
-	if (sprite_index >= sprite->frames())
-		sprite_index = 0;
+  // extra check
+  // note that if this happens, there's something wrong in the ships' constructor...
+  if (sprite_index >= sprite->frames())
+    sprite_index = 0;
 
-	return;
+  return;
 }
 
 void Phaser::animate(Frame *space) {
   STACKTRACE;
-	sprite->animate_character(pos, 
-		sprite_index, pallete_color[colors[color_index]], space);
-	return;
+  sprite->animate_character(pos, 
+			    sprite_index, pallete_color[colors[color_index]], space);
+  return;
 }
 
 void Phaser::calculate() {
   STACKTRACE;
-	if (!exists())
-		return;
-	frame_step -= frame_time;
+  if (!exists())
+    return;
+  frame_step -= frame_time;
 
-	while (frame_step < 0) {
-		frame_step += frame_size;
-		color_index++;
-		if (color_index == num_colors)
-			state = 0;
-	}
+  while (frame_step < 0) {
+    frame_step += frame_size;
+    color_index++;
+    if (color_index == num_colors)
+      state = 0;
+  }
 
-	if (phaser_step_position < phaser_step_size) {
-		if (ship && !ship->exists())
-			ship = NULL;
-		phaser_step_position += frame_time;
-		if (phaser_step_position >= phaser_step_size) {
-			if (phaser_steps > 1) {
-				Vector2 d = rel_pos / phaser_steps;
-				game->add(new Phaser(this, pos + d, rel_pos-d, ship, sprite, sprite_index, colors, num_colors, frame_size, phaser_steps-1, phaser_step_size));
-			}
-			else if (ship) {
-				game->add(ship);
-				ship->materialize();
-				ship = NULL;
-			}
-		}
-	}
-	SpaceObject::calculate();
+  if (phaser_step_position < phaser_step_size) {
+    if (ship && !ship->exists())
+      ship = NULL;
+    phaser_step_position += frame_time;
+    if (phaser_step_position >= phaser_step_size) {
+      if (phaser_steps > 1) {
+	Vector2 d = rel_pos / phaser_steps;
+	game->add(new Phaser(this, pos + d, rel_pos-d, ship, sprite, sprite_index, colors, num_colors, frame_size, phaser_steps-1, phaser_step_size));
+      }
+      else if (ship) {
+	game->add(ship);
+	ship->materialize();
+	ship = NULL;
+      }
+    }
+  }
+  SpaceObject::calculate();
 }
 
 SpaceLocation *Ship::get_ship_phaser() {
   STACKTRACE;
-	return new Phaser(this,
-		pos - unit_vector(angle ) * PHASE_MAX * size.x,
-		unit_vector(angle ) * PHASE_MAX * size.x,
-		this, sprite, sprite_index, hot_color, HOT_COLORS,
-		PHASE_DELAY, PHASE_MAX, PHASE_DELAY
-	);
+  return new Phaser(this,
+		    pos - unit_vector(angle ) * PHASE_MAX * size.x,
+		    unit_vector(angle ) * PHASE_MAX * size.x,
+		    this, sprite, sprite_index, hot_color, HOT_COLORS,
+		    PHASE_DELAY, PHASE_MAX, PHASE_DELAY
+		    );
 }

Modified: trunk/source/melee/mship.h
===================================================================
--- trunk/source/melee/mship.h	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mship.h	2005-02-27 15:15:31 UTC (rev 128)
@@ -97,6 +97,8 @@
   virtual double get_angle_ex() const; ///< stupid helper for camera
   
  public:
+  virtual void set_target(SpaceObject* target);
+
   ShipType *type;
   virtual ShipType *get_shiptype();
   
@@ -175,6 +177,9 @@
   virtual double handle_speed_loss(SpaceLocation *source, double normal);
   
   virtual void animate(Frame *frame);
+
+ protected:
+    Presence* _target_TeamIndicator;
 };
 
 

Modified: trunk/source/melee/mshot.cpp
===================================================================
--- trunk/source/melee/mshot.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mshot.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -237,15 +237,15 @@
 	turn_step(0.0)
 {
   STACKTRACE;
-	target = otarget;
+	set_target( otarget);
 	id = SPACE_HOMING_MISSILE;
 }
 
 void HomingMissile::calculate() {
   STACKTRACE;
 	Missile::calculate();
-	if (target && !target->isInvisible()) {
-		double d_a = normalize(trajectory_angle(target) - (angle + turn_step), PI2);
+	if (get_target() && !get_target()->isInvisible()) {
+		double d_a = normalize(trajectory_angle(get_target()) - (angle + turn_step), PI2);
 		if (d_a > PI) d_a -= PI2;
 		double ta = turn_rate * frame_time;
 		if (fabs(d_a) < ta) ta = fabs(d_a);
@@ -277,8 +277,8 @@
 	Vector2 old_vel = vel;
 
 	double ta = 0;
-	if (target && !target->isInvisible()) {
-		Vector2 tpos = target->normal_pos() + target->vel * 0;
+	if (get_target() && !get_target()->isInvisible()) {
+		Vector2 tpos = get_target()->normal_pos() + get_target()->vel * 0;
 		double da = normalize(atan3(min_delta(tpos,pos)) - (angle + turn_step));
 		if (da > PI) da -= PI2;
 		double ta = turn_rate * 0;

Modified: trunk/source/melee/mview.cpp
===================================================================
--- trunk/source/melee/mview.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/melee/mview.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -557,9 +557,9 @@
 	if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
 	if (!c) return;
 	CameraPosition n = camera;
-	if (c->target && !(camera_hides_cloakers && c->target->isInvisible())) {
-		if (c->distance(c->target) < 3000) {
-			focus(&n, c, c->target);
+	if (c->get_target() && !(camera_hides_cloakers && c->get_target()->isInvisible())) {
+		if (c->distance(c->get_target()) < 3000) {
+			focus(&n, c, c->get_target());
 			n.z *= 1.4;
 		}
 		else focus(&n, c);
@@ -582,8 +582,8 @@
 	if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
 	if (!c) return;
 	CameraPosition n = camera;
-	if (c->target && !(camera_hides_cloakers && c->target->isInvisible())) {
-		focus(&n, c, c->target);
+	if (c->get_target() && !(camera_hides_cloakers && c->get_target()->isInvisible())) {
+		focus(&n, c, c->get_target());
 		n.z *= 1.4;
 		}
 	else

Modified: trunk/source/sc1ships/shpchebr.cpp
===================================================================
--- trunk/source/sc1ships/shpchebr.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpchebr.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -181,16 +181,18 @@
   STACKTRACE;
 	AnimatedShot::calculate();
 
-	if (ship && ship->exists()) {
-		target = ship->target; }
+	if (ship && ship->exists()) 
+	  {
+		set_target( ship->get_target()); 
+	}
 	else {
 		state = 0;
 		return;  }
 
-	if (target && !target->isInvisible()) {
-		angle = trajectory_angle(target);
+	if (get_target() && !get_target()->isInvisible()) {
+		angle = trajectory_angle(get_target());
 
-		double ra = normalize(target->get_angle() - (angle - PI), PI2);
+		double ra = normalize(get_target()->get_angle() - (angle - PI), PI2);
 		if (ra > PI) ra -= PI2;
 
 		if (fabs(ra) < avoidanceAngle)

Modified: trunk/source/sc1ships/shpearcr.cpp
===================================================================
--- trunk/source/sc1ships/shpearcr.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpearcr.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -91,7 +91,7 @@
   double ov, int odamage, double orange, int oarmour, double otrate,
   Ship *oship, SpaceSprite *osprite) :
   HomingMissile(oship, opos, oangle, ov, odamage, orange, oarmour, otrate, 
-		oship, osprite, oship->target)
+		oship, osprite, oship->get_target())
 {
   STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);

Modified: trunk/source/sc1ships/shpilwav.cpp
===================================================================
--- trunk/source/sc1ships/shpilwav.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpilwav.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -45,13 +45,13 @@
   STACKTRACE;
 	// note that target=0 is only set after this routine is called in ship::calculate
 	// so we need to check if it exists ...
-	if (cloak && target && target->exists()) {
-		if (distance(target) < weaponRange * 3) {
+	if (cloak && get_target() && get_target()->exists()) {
+		if (distance(get_target()) < weaponRange * 3) {
 			angle = 
 				intercept_angle2(pos, vel * 1.0, weaponVelocity, 
-					target->normal_pos(), target->get_vel() );
+					get_target()->normal_pos(), get_target()->get_vel() );
 			}
-		else angle = trajectory_angle(target);
+		else angle = trajectory_angle(get_target());
 		}
 	cloak = FALSE;
 	game->add(new AnimatedShot(this, Vector2(0.0, size.y / 2.0),

Modified: trunk/source/sc1ships/shpkzedr.cpp
===================================================================
--- trunk/source/sc1ships/shpkzedr.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpkzedr.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -149,8 +149,8 @@
   if (air_frames > max_air_frames - 350) 
     return;
   
-  target = ship->target;
-  if((target == NULL) || (air_frames < (max_air_frames / 2)) || target->isInvisible()) 
+  set_target( ship->get_target());
+  if((get_target() == NULL) || (air_frames < (max_air_frames / 2)) || get_target()->isInvisible()) 
     {
       collide_flag_sameship |= bit(LAYER_SHIPS);
       changeDirection(trajectory_angle(ship));
@@ -158,23 +158,23 @@
     }
   collide_flag_sameship &= ~bit(LAYER_SHIPS);
   
-  if ((distance(target) < laser_range) && (batt <= 0)) 
+  if ((distance(get_target()) < laser_range) && (batt <= 0)) 
     {
       collide_flag_sameship = 0;
       vel = 0;
       tw_sound->stop_sound(data_full_path(data->sampleExtra[0]));
       tw_sound->play_sound(data_full_path(data->sampleExtra[0]));
       
-      add(new Laser(this, trajectory_angle(target),
+      add(new Laser(this, trajectory_angle(get_target()),
 		    pallete_color[laser_color], laser_range, laser_damage,
 		    laser_frames, this, Vector2(0.0, -size.y / 2.0)));
       batt = recharge_frames;
     }
   else 
     {
-      Vector2 t = target->normal_pos();
-      double ta = target->get_angle();
-      double a = target->trajectory_angle(this) - target->get_angle();
+      Vector2 t = get_target()->normal_pos();
+      double ta = get_target()->get_angle();
+      double a = get_target()->trajectory_angle(this) - get_target()->get_angle();
       a = normalize(a,PI2);
       Vector2 l = t + unit_vector(ta+PI/2) * laser_range * 0.8;
       Vector2 r = t + unit_vector(ta+PI*3/2) * laser_range * 0.8;

Modified: trunk/source/sc1ships/shpmmrxf.cpp
===================================================================
--- trunk/source/sc1ships/shpmmrxf.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpmmrxf.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -110,10 +110,10 @@
   else if(form == Y_FORM) {
     add(new HomingMissile(this, Vector2(-13.0, 2.0),
       angle - 25.0 * ANGLE_RATIO, missileVelocity, missileDamage, missileRange,
-      missileArmour, missileTurnRate, this, data->spriteWeapon, target));
+      missileArmour, missileTurnRate, this, data->spriteWeapon, get_target()));
     add(new HomingMissile(this, Vector2(13.0, 2.0),
       angle + 25.0 * ANGLE_RATIO, missileVelocity, missileDamage, missileRange,
-      missileArmour, missileTurnRate, this, data->spriteWeapon, target));
+      missileArmour, missileTurnRate, this, data->spriteWeapon, get_target()));
   }
   return(TRUE);
 }

Modified: trunk/source/sc1ships/shpmycpo.cpp
===================================================================
--- trunk/source/sc1ships/shpmycpo.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpmycpo.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -72,7 +72,7 @@
     int odamage, double orange, double otrate, Ship *oship,
     SpaceSprite *osprite, int ofcount) :
   HomingMissile( oship, opos, oangle, ov, odamage, orange, 0, otrate, oship, 
-      osprite, oship->target),
+      osprite, oship->get_target()),
 //  v(ov),
   frame_count(ofcount),
   max_damage(odamage)

Modified: trunk/source/sc1ships/shpspael.cpp
===================================================================
--- trunk/source/sc1ships/shpspael.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpspael.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -51,7 +51,7 @@
   STACKTRACE;
 	SpaceLocation *tmp = new HomingMissile( this, 
 		Vector2(0.0, -size.y / 1.5), angle + PI, specialVelocity, specialDamage, specialRange, 
-		specialArmour, specialTurnRate, this, data->spriteSpecial, target);
+		specialArmour, specialTurnRate, this, data->spriteSpecial, get_target());
 		tmp->collide_flag_sameship |= bit(LAYER_SHIPS);
 		tmp->collide_flag_sameteam |= bit(LAYER_SHIPS);
 	add(tmp);

Modified: trunk/source/sc1ships/shpvuxin.cpp
===================================================================
--- trunk/source/sc1ships/shpvuxin.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc1ships/shpvuxin.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -72,8 +72,8 @@
   slowdown_factor(slowdown)
 {
   STACKTRACE;
-  if((ship->target) && (!ship->target->isInvisible()))
-    angle = trajectory_angle(ship->target);
+  if((ship->get_target()) && (!ship->get_target()->isInvisible()))
+    angle = trajectory_angle(ship->get_target());
   else
     angle = ship->get_angle() - PI;
 
@@ -94,8 +94,8 @@
 		return;
 		}
 
-	if((ship->target) && (!ship->target->isInvisible())) {
-		angle = trajectory_angle(ship->target);
+	if((ship->get_target()) && (!ship->get_target()->isInvisible())) {
+		angle = trajectory_angle(ship->get_target());
 		vel = v * unit_vector(angle);
 		}
 	AnimatedShot::calculate();
@@ -149,10 +149,10 @@
 void VuxIntruder::relocate() 
 {
   STACKTRACE;
-  if ( control ) target = control->target; 
-  if (target && (distance(target) > 500)) {
-    pos = target->normal_pos() + (unit_vector(angle) * 125.0);
-    angle = trajectory_angle(target);
+  if ( control ) set_target( control->target); 
+  if (get_target() && (distance(get_target()) > 500)) {
+    pos = get_target()->normal_pos() + (unit_vector(angle) * 125.0);
+    angle = trajectory_angle(get_target());
     if (angle > PI2) angle -= PI2;
     if (angle < 0) angle += PI2;
   }

Modified: trunk/source/sc2ships/shpchmav.cpp
===================================================================
--- trunk/source/sc2ships/shpchmav.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc2ships/shpchmav.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -126,9 +126,9 @@
 int ChmmrAvatar::activate_special()
 {
   STACKTRACE;
-	if (target && target->exists() && (!target->isInvisible()) && (target->mass > 0) && (distance(target) < specialRange)) {
+	if (get_target() && get_target()->exists() && (!get_target()->isInvisible()) && (get_target()->mass > 0) && (distance(get_target()) < specialRange)) {
 		add(new ChmmrBeam(this, special_rate));
-		target->accelerate(this, target->trajectory_angle(this), specialForce / target->mass, MAX_SPEED);
+		get_target()->accelerate(this, get_target()->trajectory_angle(this), specialForce / get_target()->mass, MAX_SPEED);
 		return (true);
 		}
 	return false;
@@ -164,7 +164,7 @@
 	frame(0),
 	frame_count(oframes),
 	ship(oship),
-	target(oship->target)
+	target(oship->get_target())
 {
   STACKTRACE;
 	set_depth(DEPTH_HOTSPOTS);
@@ -174,8 +174,8 @@
 		return;
 	}
 
-	target = ship->target;
-	if(!(target && target->exists()) || (target->isInvisible())) {
+	set_target( ship->get_target());
+	if(!(get_target() && get_target()->exists()) || (get_target()->isInvisible())) {
 		state = 0;
 		return;
 	}
@@ -193,15 +193,13 @@
 		state = 0;
 		return;
 	}
-	target = ship->target;
+	set_target(ship->get_target());
 
 	if((!(target && target->exists())) || (target->isInvisible())) {
 		state = 0;
 		return;
 	}
 
-//	x = ship->normal_x();
-//	y = ship->normal_y();
 	pos = ship->normal_pos();
 	frame += frame_time;
 	if (frame > frame_count) state = 0;

Modified: trunk/source/sc2ships/shporzne.cpp
===================================================================
--- trunk/source/sc2ships/shporzne.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/sc2ships/shporzne.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -328,8 +328,8 @@
 	angle = trajectory_angle(ship);
       else 
 	{
-	  if(ship->target && ship->target->exists() && (!ship->target->isInvisible()))
-                                angle = trajectory_angle(ship->target);
+	  if(ship->get_target() && ship->get_target()->exists() && (!ship->get_target()->isInvisible()))
+                                angle = trajectory_angle(ship->get_target());
 	  else 
 	    {  
 	      returning = true;

Modified: trunk/source/ships/shpalabc.cpp
===================================================================
--- trunk/source/ships/shpalabc.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shpalabc.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -130,7 +130,7 @@
   AlaryBCTurret (AlaryBC *oship, double blah_or, double oa, double oangle,
 		 double omin_angle, double omax_angle, int team);
   double get_aim(SpaceObject *tgt);
-  SpaceObject *get_target(SpaceObject *tgt);
+  SpaceObject *get_turret_target(SpaceObject *tgt);
   virtual void calculate();
   void sinc_it();
 };
@@ -331,7 +331,7 @@
   game->add(new AlaryBCTorpedo(this, 30*side, 0, angle, 
 			       350/*oinactive*/, weaponAccel, weaponVelocity,
 			       weaponLifetime, weaponProximity, weaponArmour, 
-			       weaponTR, target,
+			       weaponTR, get_target(),
 			       data->spriteWeapon, warheadDamage,  warheadRange, 
 			       warheadArmour, warheadVelocity, warheadTR));
   
@@ -636,7 +636,7 @@
   wh_turn_rate(wtr), wh_range(wrange)
 {
   STACKTRACE;
-  target = otarget;
+  set_target( otarget);
   layer = LAYER_SHOTS;
   set_depth(DEPTH_SHOTS);
 
@@ -666,9 +666,9 @@
   
   if (inactive > 0) inactive -= frame_time;
   
-  if (target) if ((!target->isInvisible()) && (inactive <=0)) 
+  if (get_target()) if ((!get_target()->isInvisible()) && (inactive <=0)) 
     {
-      double d_a = normalize(trajectory_angle(target) - angle, PI2);
+      double d_a = normalize(trajectory_angle(get_target()) - angle, PI2);
       if (d_a > PI) d_a -= PI2;
       double ta = turn_rate * frame_time;
       if (fabs(d_a) < ta) ta = fabs(d_a);
@@ -676,32 +676,32 @@
       else angle -= ta;
       angle = normalize(angle, PI2);
       
-      if (distance(target) < proximity) 
+      if (distance(get_target()) < proximity) 
 	{
 	  game->add(new Animation(this, pos, data->spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
 	  
 	  game->add(new AlaryBCWarhead(this, 0, 10, angle,
 				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
-				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+				       wh_armour, wh_turn_rate, data->spriteExtra, get_target()));
 	  game->add(new AlaryBCWarhead(this, 0, 10, angle - 50*PI/180,
 				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
-				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+				       wh_armour, wh_turn_rate, data->spriteExtra, get_target()));
 	  game->add(new AlaryBCWarhead(this, 0, 10, angle + 50*PI/180,
 				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
-				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+				       wh_armour, wh_turn_rate, data->spriteExtra, get_target()));
 	  game->add(new AlaryBCWarhead(this, 0, 10, angle - 75*PI/180,
 				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
-				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+				       wh_armour, wh_turn_rate, data->spriteExtra, get_target()));
 	  game->add(new AlaryBCWarhead(this, 0, 10, angle + 75*PI/180,
 				       wh_v, wh_damage, wh_range*(1+0.0025*(tw_random()%101)), 
-				       wh_armour, wh_turn_rate, data->spriteExtra, target));
+				       wh_armour, wh_turn_rate, data->spriteExtra, get_target()));
 			
 	  state = 0;
 	}
     }
   else 
     {
-      if (inactive <= 0) target = NULL;
+      if (inactive <= 0) set_target( NULL);
       
       //find another target???????
       
@@ -792,7 +792,7 @@
 				double omin_angle, double omax_angle, int team) :
   SpaceLocation(oship,0,oangle)
 {
-  target = NULL;
+  set_target(NULL);
   shots_fired = 0;
   barrel = 0;
   ship = oship;
@@ -871,7 +871,7 @@
   return (-1);
 }
 
-SpaceObject *AlaryBCTurret::get_target(SpaceObject *tgt)
+SpaceObject *AlaryBCTurret::get_turret_target(SpaceObject *tgt)
 {
   STACKTRACE;
   double d_a, prix=-1, prix_c, aim; //!!!
@@ -893,7 +893,7 @@
 	    
 	    if (q.currento->isShip()) 
 	      {
-		if (q.currento == ship->target) prix_c = 4;
+		if (q.currento == ship->get_target()) prix_c = 4;
 	      else
 		prix_c = 3; 
 	      }
@@ -963,30 +963,31 @@
 
   if (ship->turrets_on) 
     {
-      if (target) 
+      if (get_target()) 
 	{
-	  if (!target->exists()) 
+	  if (!get_target()->exists()) 
 	    {
 	      shots_fired = 0;
-	      target = get_target(NULL); 
+	      set_target(get_turret_target(NULL)); 
 	    }
 	}
       else 
 	{
 	  shots_fired = 0;
-	  target = get_target(NULL); }
+	  set_target( get_turret_target(NULL)); 
+	}
       
-      aim = get_aim(target);
+      aim = get_aim(get_target());
 
       if (aim < 0) 
 	{
 	  shots_fired = 0;
-	  target = get_target(NULL); 
+	  set_target(get_turret_target(NULL)); 
 	}
     }
   else 
     {
-    target = NULL;
+    set_target(NULL);
     shots_fired = 0;
     aim = -1; 
   }
@@ -1009,9 +1010,9 @@
     angle -= delta;
   
   if (recharge > 0) recharge -= frame_time;
-  if (target && (recharge <= 0)) 
+  if (get_target() && (recharge <= 0)) 
     {
-      if (fabs(d_a) <= (0.25 * (target->size.x+target->size.y)/2.0) / distance(target)) 
+      if (fabs(d_a) <= (0.25 * (get_target()->size.x+get_target()->size.y)/2.0) / distance(get_target())) 
 	{
 	  if (ship->batt >= ship->special_drain) 
 	    {

Modified: trunk/source/ships/shpchoex.cpp
===================================================================
--- trunk/source/ships/shpchoex.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shpchoex.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -260,7 +260,7 @@
   Ship *oship, SpaceSprite *osprite, int oframe_count,
     int R, int Rm, int G, int Gm, int B, int Bm) :
   HomingMissile(oship, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, otrate, 
-		oship, osprite, oship->target), 
+		oship, osprite, oship->get_target()), 
   explosion(game->meleedata.asteroidExplosionSprite), frame_count(oframe_count) 
 {
   STACKTRACE;

Modified: trunk/source/ships/shpconho.cpp
===================================================================
--- trunk/source/ships/shpconho.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shpconho.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -128,7 +128,7 @@
 {
   STACKTRACE;
   add(new TorpedoMissile(0.0, (size.y / 2.0),
-    angle, specialVelocity, specialDamage, specialDDamage, specialRange, specialArmour, specialTurnRate, this, this, data->spriteSpecial, target));
+    angle, specialVelocity, specialDamage, specialDDamage, specialRange, specialArmour, specialTurnRate, this, this, data->spriteSpecial, get_target()));
   return(TRUE);
 }
 

Modified: trunk/source/ships/shpdragr.cpp
===================================================================
--- trunk/source/ships/shpdragr.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shpdragr.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -199,7 +199,7 @@
 			o = (Shot *) a.currento;
 			if ((distance(o) < MineRadius) && (o->canCollide(this))
 					&& (o->isHomingMissile()))
-				((HomingMissile *) o)->target = this;
+				((HomingMissile *) o)->set_target(this);
 			}
 		}
 	

Modified: trunk/source/ships/shpearc3.cpp
===================================================================
--- trunk/source/ships/shpearc3.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shpearc3.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -127,7 +127,7 @@
 				if (s > PI) s -= PI2;
 				if (fabs(s) <= weaponTrackingAngle) {
 					d_a = s - launch_angle;
-					if (tgt == target) {
+					if (tgt == get_target()) {
 						track_angle = s;
 						break; }
 					if (fabs(d_a) < track_min) {
@@ -231,15 +231,15 @@
 {
   STACKTRACE;
 	set_depth(DEPTH_EXPLOSIONS);
-	target = tgt;
+	set_target(tgt);
 	base_length = length;
 	rel_pos.x *= -1;
 	pos = normalize(pos + rotate(rel_pos, -PI/2+lpos->get_angle()));
 	vel = lpos->get_vel();
 	id |= SPACE_LASER;
 	damage_factor = ldamage;
-	angle = trajectory_angle(target);
-	if (!target->canCollide(this) || !canCollide(target)) state = 0;
+	angle = trajectory_angle(get_target());
+	if (!get_target()->canCollide(this) || !canCollide(get_target())) state = 0;
 
 	if(!(lpos && lpos->exists()))
 	{
@@ -269,7 +269,7 @@
 	else 
 		state = 0;
 
-	if ((!target) && (switch_counter <= 0)) {
+	if ((!get_target()) && (switch_counter <= 0)) {
 		SpaceObject *o;
 		double rng = 1e40;
 		SpaceObject *tgt = NULL;
@@ -284,18 +284,18 @@
 			}
 		}
 		if (tgt) {
-			target = tgt;
+			set_target(tgt);
 //			switch_counter = 55;
 			got_spark = false; }
 	}
 
-	if (target && (distance(target) <= base_length)) {
+	if (get_target() && (distance(get_target()) <= base_length)) {
 		length = base_length;
-		if (target->exists() && canCollide(target) && target->canCollide(this)) {
-			angle = trajectory_angle(target); }
-		if (!target->exists()) target = NULL; }
+		if (get_target()->exists() && canCollide(get_target()) && get_target()->canCollide(this)) {
+			angle = trajectory_angle(get_target()); }
+		if (!get_target()->exists()) set_target( NULL); }
 	else {
-		target = NULL;
+		set_target( NULL);
 		if (switch_counter <= 0)
 //			die();
 			length = 0;
@@ -330,7 +330,7 @@
   STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
-	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (target)) {
+	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (get_target())) {
 		int	_old_trans = aa_get_trans();
 		aa_set_trans(rand()%156);
 		data->spriteSpecial->animate(pos, 0, space);

Modified: trunk/source/ships/shprogsq.cpp
===================================================================
--- trunk/source/ships/shprogsq.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shprogsq.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -422,14 +422,14 @@
 	for (a.begin(this, bit(LAYER_SHIPS), 999999.0); a.current; a.next())
 	{
 		o = a.currento;
-		if (o->target == this )
+		if (o->get_target() ==  this )
 		{
 			for ( i = 0; i < crew_max; ++i )
 			{
 				if ( !fighter[i] )
 					continue;
 
-				o->target = fighter[i];
+				o->set_target ( fighter[i]);
 				break;
 			}
 

Modified: trunk/source/ships/shpstaba.cpp
===================================================================
--- trunk/source/ships/shpstaba.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shpstaba.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -71,16 +71,16 @@
   STACKTRACE;
    
 	double a;
-	if (target) {
-		double r = distance(target);
+	if (get_target()) {
+		double r = distance(get_target());
 		r = r / weaponVelocity;
 //		double x = min_delta( normal_x() , target->normal_x() - 
 //				-target->get_vx() * r, X_MAX);
 //		double y = min_delta( normal_y() , target->normal_y() - 
 //				-target->get_vy() * r, Y_MAX);
 		Vector2 tmppos;
-		tmppos = min_delta( normal_pos() , target->normal_pos() - 
-				-target->get_vel() * r, map_size);
+		tmppos = min_delta( normal_pos() , get_target()->normal_pos() - 
+				-get_target()->get_vel() * r, map_size);
 
 //		a = atan3(y, x) - PI;
 		a = atan(tmppos) - PI;

Modified: trunk/source/ships/shptauda.cpp
===================================================================
--- trunk/source/ships/shptauda.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shptauda.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -168,7 +168,7 @@
   STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
-	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (target)) {
+	if ((aa & AA_BLEND) && (aa & AA_ALPHA) && !(aa & AA_NO_AA) && (length < base_length*0.9999) && (get_target())) {
 		int	_old_trans = aa_get_trans();
 		// changed tw_random into rand - GEO - so that physics are not affected by the animation
 		aa_set_trans(rand()%136);	//graphics

Modified: trunk/source/ships/shptaust.cpp
===================================================================
--- trunk/source/ships/shptaust.cpp	2005-02-27 12:46:51 UTC (rev 127)
+++ trunk/source/ships/shptaust.cpp	2005-02-27 15:15:31 UTC (rev 128)
@@ -113,7 +113,7 @@
   else rx = 13;
   if (slot%2)	rx = -rx;
   game->add(new TauStormMissile (this, rx, 10, angle, weaponAccel,
-				 weaponVelocity, weaponTurnRate, target,
+				 weaponVelocity, weaponTurnRate, get_target(),
 				 iround(weaponFuel*(1+weaponRandom*(100-random()%201)/100.0)), 
 				 weaponThrust, weaponMass,
 				 weaponBoosterSpeed, data->spriteWeapon,
@@ -131,7 +131,7 @@
   else rx = 13;
   if (slot%2)	rx = -rx;
   game->add(new TauStormMissile (this, rx, 10, angle, specialAccel,
-				 specialVelocity, specialTurnRate, target,
+				 specialVelocity, specialTurnRate, get_target(),
 				 iround(specialFuel*(1+specialRandom*(100-random()%201)/100.0)), 
 				 specialThrust, weaponMass,
 				 specialBoosterSpeed, data->spriteSpecial,



