<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r136 - in trunk: . gamedata gamedata/python mingw-libs/include mingw-libs/lib source source/games source/generated source/melee source/other source/python source/util
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2005-March/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r136%20-%20in%20trunk%3A%20.%20gamedata%20gamedata/python%20mingw-libs/include%20mingw-libs/lib%20source%20source/games%20source/generated%20source/melee%20source/other%20source/python%20source/util&In-Reply-To=%3C200503121913.j2CJD2Dw026348%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000081.html">
   <LINK REL="Next"  HREF="000083.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r136 - in trunk: . gamedata gamedata/python mingw-libs/include mingw-libs/lib source source/games source/generated source/melee source/other source/python source/util</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r136%20-%20in%20trunk%3A%20.%20gamedata%20gamedata/python%20mingw-libs/include%20mingw-libs/lib%20source%20source/games%20source/generated%20source/melee%20source/other%20source/python%20source/util&In-Reply-To=%3C200503121913.j2CJD2Dw026348%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r136 - in trunk: . gamedata gamedata/python mingw-libs/include mingw-libs/lib source source/games source/generated source/melee source/other source/python source/util">yurand at sheep.berlios.de
       </A><BR>
    <I>Sat Mar 12 20:13:02 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000081.html">[Tw-light-svn] r135 - in trunk: . gamedata/xml/GOB source source/games source/melee source/other
</A></li>
        <LI>Next message: <A HREF="000083.html">[Tw-light-svn] r137 - trunk/source/games
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#82">[ date ]</a>
              <a href="thread.html#82">[ thread ]</a>
              <a href="subject.html#82">[ subject ]</a>
              <a href="author.html#82">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2005-03-12 20:12:58 +0100 (Sat, 12 Mar 2005)
New Revision: 136

Added:
   trunk/gamedata/python/
   trunk/gamedata/python/ggob.py
   trunk/gamedata/python/start.py
   trunk/mingw-libs/include/Python.h
   trunk/mingw-libs/include/abstract.h
   trunk/mingw-libs/include/bitset.h
   trunk/mingw-libs/include/boolobject.h
   trunk/mingw-libs/include/bufferobject.h
   trunk/mingw-libs/include/cStringIO.h
   trunk/mingw-libs/include/cellobject.h
   trunk/mingw-libs/include/ceval.h
   trunk/mingw-libs/include/classobject.h
   trunk/mingw-libs/include/cobject.h
   trunk/mingw-libs/include/codecs.h
   trunk/mingw-libs/include/compile.h
   trunk/mingw-libs/include/complexobject.h
   trunk/mingw-libs/include/datetime.h
   trunk/mingw-libs/include/descrobject.h
   trunk/mingw-libs/include/dictobject.h
   trunk/mingw-libs/include/enumobject.h
   trunk/mingw-libs/include/errcode.h
   trunk/mingw-libs/include/eval.h
   trunk/mingw-libs/include/fileobject.h
   trunk/mingw-libs/include/floatobject.h
   trunk/mingw-libs/include/frameobject.h
   trunk/mingw-libs/include/funcobject.h
   trunk/mingw-libs/include/genobject.h
   trunk/mingw-libs/include/graminit.h
   trunk/mingw-libs/include/grammar.h
   trunk/mingw-libs/include/import.h
   trunk/mingw-libs/include/intobject.h
   trunk/mingw-libs/include/intrcheck.h
   trunk/mingw-libs/include/iterobject.h
   trunk/mingw-libs/include/listobject.h
   trunk/mingw-libs/include/longintrepr.h
   trunk/mingw-libs/include/longobject.h
   trunk/mingw-libs/include/marshal.h
   trunk/mingw-libs/include/metagrammar.h
   trunk/mingw-libs/include/methodobject.h
   trunk/mingw-libs/include/modsupport.h
   trunk/mingw-libs/include/moduleobject.h
   trunk/mingw-libs/include/node.h
   trunk/mingw-libs/include/object.h
   trunk/mingw-libs/include/objimpl.h
   trunk/mingw-libs/include/opcode.h
   trunk/mingw-libs/include/osdefs.h
   trunk/mingw-libs/include/parsetok.h
   trunk/mingw-libs/include/patchlevel.h
   trunk/mingw-libs/include/pgen.h
   trunk/mingw-libs/include/pgenheaders.h
   trunk/mingw-libs/include/py_curses.h
   trunk/mingw-libs/include/pyconfig.h
   trunk/mingw-libs/include/pydebug.h
   trunk/mingw-libs/include/pyerrors.h
   trunk/mingw-libs/include/pyfpe.h
   trunk/mingw-libs/include/pygetopt.h
   trunk/mingw-libs/include/pymactoolbox.h
   trunk/mingw-libs/include/pymem.h
   trunk/mingw-libs/include/pyport.h
   trunk/mingw-libs/include/pystate.h
   trunk/mingw-libs/include/pystrtod.h
   trunk/mingw-libs/include/pythonrun.h
   trunk/mingw-libs/include/pythread.h
   trunk/mingw-libs/include/rangeobject.h
   trunk/mingw-libs/include/setobject.h
   trunk/mingw-libs/include/sliceobject.h
   trunk/mingw-libs/include/stringobject.h
   trunk/mingw-libs/include/structmember.h
   trunk/mingw-libs/include/structseq.h
   trunk/mingw-libs/include/symtable.h
   trunk/mingw-libs/include/sysmodule.h
   trunk/mingw-libs/include/timefuncs.h
   trunk/mingw-libs/include/token.h
   trunk/mingw-libs/include/traceback.h
   trunk/mingw-libs/include/tupleobject.h
   trunk/mingw-libs/include/ucnhash.h
   trunk/mingw-libs/include/unicodeobject.h
   trunk/mingw-libs/include/weakrefobject.h
   trunk/mingw-libs/include/zconf.h
   trunk/mingw-libs/include/zlib.h
   trunk/mingw-libs/lib/libpython24.a
   trunk/mingw-libs/lib/libz.a
   trunk/python24.dll
   trunk/source/generated/
   trunk/source/generated/ggob.py
   trunk/source/generated/ggob_wrap.cpp
   trunk/source/python/
   trunk/source/python/fileops.cpp
   trunk/source/python/fileops.h
   trunk/source/python/game.cpp
   trunk/source/python/game.h
   trunk/source/python/python_class.cpp
   trunk/source/python/python_class.h
   trunk/source/python/types.h
Removed:
   trunk/gamedata/xml/
   trunk/gamedata/xslt/
Modified:
   trunk/makefile
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee.h
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mframe.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mhelpers.cpp
   trunk/source/melee/mitems.cpp
   trunk/source/melee/msprite.cpp
   trunk/source/other/starmap.cpp
   trunk/source/scp.cpp
   trunk/source/util/vector2.h
   trunk/sources.lst
Log:
Python support added


Added: trunk/gamedata/python/ggob.py
===================================================================
--- trunk/gamedata/python/ggob.py	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/gamedata/python/ggob.py	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,380 @@
+# This file was created automatically by SWIG.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _ggob
+
+def _swig_setattr(self,class_type,name,value):
+    if (name == &quot;this&quot;):
+        if isinstance(value, class_type):
+            self.__dict__[name] = value.this
+            if hasattr(value,&quot;thisown&quot;): self.__dict__[&quot;thisown&quot;] = value.thisown
+            del value.thisown
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    self.__dict__[name] = value
+
+def _swig_getattr(self,class_type,name):
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class pair(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, pair, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, pair, name)
+    def __repr__(self):
+        return &quot;&lt;C pair instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;id&quot;] = _ggob.pair_id_set
+    __swig_getmethods__[&quot;id&quot;] = _ggob.pair_id_get
+    if _newclass:id = property(_ggob.pair_id_get, _ggob.pair_id_set)
+    __swig_setmethods__[&quot;value&quot;] = _ggob.pair_value_set
+    __swig_getmethods__[&quot;value&quot;] = _ggob.pair_value_get
+    if _newclass:value = property(_ggob.pair_value_get, _ggob.pair_value_set)
+    def __init__(self, *args):
+        _swig_setattr(self, pair, 'this', _ggob.new_pair(*args))
+        _swig_setattr(self, pair, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_pair):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class pairPtr(pair):
+    def __init__(self, this):
+        _swig_setattr(self, pair, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, pair, 'thisown', 0)
+        _swig_setattr(self, pair,self.__class__,pair)
+_ggob.pair_swigregister(pairPtr)
+
+class GobPlayer(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobPlayer, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobPlayer, name)
+    def __repr__(self):
+        return &quot;&lt;C GobPlayer instance at %s&gt;&quot; % (self.this,)
+    def __init__(self, *args):
+        _swig_setattr(self, GobPlayer, 'this', _ggob.new_GobPlayer(*args))
+        _swig_setattr(self, GobPlayer, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobPlayer):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__[&quot;ship&quot;] = _ggob.GobPlayer_ship_set
+    __swig_getmethods__[&quot;ship&quot;] = _ggob.GobPlayer_ship_get
+    if _newclass:ship = property(_ggob.GobPlayer_ship_get, _ggob.GobPlayer_ship_set)
+    __swig_setmethods__[&quot;pair_list&quot;] = _ggob.GobPlayer_pair_list_set
+    __swig_getmethods__[&quot;pair_list&quot;] = _ggob.GobPlayer_pair_list_get
+    if _newclass:pair_list = property(_ggob.GobPlayer_pair_list_get, _ggob.GobPlayer_pair_list_set)
+    __swig_setmethods__[&quot;num_pairs&quot;] = _ggob.GobPlayer_num_pairs_set
+    __swig_getmethods__[&quot;num_pairs&quot;] = _ggob.GobPlayer_num_pairs_get
+    if _newclass:num_pairs = property(_ggob.GobPlayer_num_pairs_get, _ggob.GobPlayer_num_pairs_set)
+    def _add_pair(*args): return _ggob.GobPlayer__add_pair(*args)
+    def _get_pair(*args): return _ggob.GobPlayer__get_pair(*args)
+    def write_pair(*args): return _ggob.GobPlayer_write_pair(*args)
+    def read_pair(*args): return _ggob.GobPlayer_read_pair(*args)
+    __swig_setmethods__[&quot;total&quot;] = _ggob.GobPlayer_total_set
+    __swig_getmethods__[&quot;total&quot;] = _ggob.GobPlayer_total_get
+    if _newclass:total = property(_ggob.GobPlayer_total_get, _ggob.GobPlayer_total_set)
+    __swig_setmethods__[&quot;starbucks&quot;] = _ggob.GobPlayer_starbucks_set
+    __swig_getmethods__[&quot;starbucks&quot;] = _ggob.GobPlayer_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobPlayer_starbucks_get, _ggob.GobPlayer_starbucks_set)
+    __swig_setmethods__[&quot;buckazoids&quot;] = _ggob.GobPlayer_buckazoids_set
+    __swig_getmethods__[&quot;buckazoids&quot;] = _ggob.GobPlayer_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobPlayer_buckazoids_get, _ggob.GobPlayer_buckazoids_set)
+    __swig_setmethods__[&quot;kills&quot;] = _ggob.GobPlayer_kills_set
+    __swig_getmethods__[&quot;kills&quot;] = _ggob.GobPlayer_kills_get
+    if _newclass:kills = property(_ggob.GobPlayer_kills_get, _ggob.GobPlayer_kills_set)
+    __swig_setmethods__[&quot;value_starbucks&quot;] = _ggob.GobPlayer_value_starbucks_set
+    __swig_getmethods__[&quot;value_starbucks&quot;] = _ggob.GobPlayer_value_starbucks_get
+    if _newclass:value_starbucks = property(_ggob.GobPlayer_value_starbucks_get, _ggob.GobPlayer_value_starbucks_set)
+    __swig_setmethods__[&quot;value_buckazoids&quot;] = _ggob.GobPlayer_value_buckazoids_set
+    __swig_getmethods__[&quot;value_buckazoids&quot;] = _ggob.GobPlayer_value_buckazoids_get
+    if _newclass:value_buckazoids = property(_ggob.GobPlayer_value_buckazoids_get, _ggob.GobPlayer_value_buckazoids_set)
+    __swig_setmethods__[&quot;team&quot;] = _ggob.GobPlayer_team_set
+    __swig_getmethods__[&quot;team&quot;] = _ggob.GobPlayer_team_get
+    if _newclass:team = property(_ggob.GobPlayer_team_get, _ggob.GobPlayer_team_set)
+    def init(*args): return _ggob.GobPlayer_init(*args)
+    def died(*args): return _ggob.GobPlayer_died(*args)
+    def new_ship(*args): return _ggob.GobPlayer_new_ship(*args)
+    def charge(*args): return _ggob.GobPlayer_charge(*args)
+    __swig_setmethods__[&quot;upgrade_list&quot;] = _ggob.GobPlayer_upgrade_list_set
+    __swig_getmethods__[&quot;upgrade_list&quot;] = _ggob.GobPlayer_upgrade_list_get
+    if _newclass:upgrade_list = property(_ggob.GobPlayer_upgrade_list_get, _ggob.GobPlayer_upgrade_list_set)
+
+class GobPlayerPtr(GobPlayer):
+    def __init__(self, this):
+        _swig_setattr(self, GobPlayer, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobPlayer, 'thisown', 0)
+        _swig_setattr(self, GobPlayer,self.__class__,GobPlayer)
+_ggob.GobPlayer_swigregister(GobPlayerPtr)
+
+class GobEnemy(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobEnemy, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobEnemy, name)
+    def __repr__(self):
+        return &quot;&lt;C GobEnemy instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;ship&quot;] = _ggob.GobEnemy_ship_set
+    __swig_getmethods__[&quot;ship&quot;] = _ggob.GobEnemy_ship_get
+    if _newclass:ship = property(_ggob.GobEnemy_ship_get, _ggob.GobEnemy_ship_set)
+    __swig_setmethods__[&quot;starbucks&quot;] = _ggob.GobEnemy_starbucks_set
+    __swig_getmethods__[&quot;starbucks&quot;] = _ggob.GobEnemy_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobEnemy_starbucks_get, _ggob.GobEnemy_starbucks_set)
+    __swig_setmethods__[&quot;buckazoids&quot;] = _ggob.GobEnemy_buckazoids_set
+    __swig_getmethods__[&quot;buckazoids&quot;] = _ggob.GobEnemy_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobEnemy_buckazoids_get, _ggob.GobEnemy_buckazoids_set)
+    def init(*args): return _ggob.GobEnemy_init(*args)
+    def died(*args): return _ggob.GobEnemy_died(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobEnemy, 'this', _ggob.new_GobEnemy(*args))
+        _swig_setattr(self, GobEnemy, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobEnemy):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobEnemyPtr(GobEnemy):
+    def __init__(self, this):
+        _swig_setattr(self, GobEnemy, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobEnemy, 'thisown', 0)
+        _swig_setattr(self, GobEnemy,self.__class__,GobEnemy)
+_ggob.GobEnemy_swigregister(GobEnemyPtr)
+
+class GobAsteroid(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobAsteroid, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobAsteroid, name)
+    def __repr__(self):
+        return &quot;&lt;C GobAsteroid instance at %s&gt;&quot; % (self.this,)
+    def handle_damage(*args): return _ggob.GobAsteroid_handle_damage(*args)
+    def death(*args): return _ggob.GobAsteroid_death(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobAsteroid, 'this', _ggob.new_GobAsteroid(*args))
+        _swig_setattr(self, GobAsteroid, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobAsteroid):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobAsteroidPtr(GobAsteroid):
+    def __init__(self, this):
+        _swig_setattr(self, GobAsteroid, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobAsteroid, 'thisown', 0)
+        _swig_setattr(self, GobAsteroid,self.__class__,GobAsteroid)
+_ggob.GobAsteroid_swigregister(GobAsteroidPtr)
+
+class GobGame(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobGame, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobGame, name)
+    def __repr__(self):
+        return &quot;&lt;C GobGame instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;_galaxy&quot;] = _ggob.GobGame__galaxy_set
+    __swig_getmethods__[&quot;_galaxy&quot;] = _ggob.GobGame__galaxy_get
+    if _newclass:_galaxy = property(_ggob.GobGame__galaxy_get, _ggob.GobGame__galaxy_set)
+    __swig_setmethods__[&quot;gobplayer&quot;] = _ggob.GobGame_gobplayer_set
+    __swig_getmethods__[&quot;gobplayer&quot;] = _ggob.GobGame_gobplayer_get
+    if _newclass:gobplayer = property(_ggob.GobGame_gobplayer_get, _ggob.GobGame_gobplayer_set)
+    def switch_system(*args): return _ggob.GobGame_switch_system(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobGame, 'this', _ggob.new_GobGame(*args))
+        _swig_setattr(self, GobGame, 'thisown', 1)
+    __swig_getmethods__[&quot;get_this&quot;] = lambda x: _ggob.GobGame_get_this
+    if _newclass:get_this = staticmethod(_ggob.GobGame_get_this)
+    def __del__(self, destroy=_ggob.delete_GobGame):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__[&quot;_player_panel&quot;] = _ggob.GobGame__player_panel_set
+    __swig_getmethods__[&quot;_player_panel&quot;] = _ggob.GobGame__player_panel_get
+    if _newclass:_player_panel = property(_ggob.GobGame__player_panel_get, _ggob.GobGame__player_panel_set)
+    __swig_setmethods__[&quot;_player_control&quot;] = _ggob.GobGame__player_control_set
+    __swig_getmethods__[&quot;_player_control&quot;] = _ggob.GobGame__player_control_get
+    if _newclass:_player_control = property(_ggob.GobGame__player_control_get, _ggob.GobGame__player_control_set)
+    __swig_setmethods__[&quot;enemy_team&quot;] = _ggob.GobGame_enemy_team_set
+    __swig_getmethods__[&quot;enemy_team&quot;] = _ggob.GobGame_enemy_team_get
+    if _newclass:enemy_team = property(_ggob.GobGame_enemy_team_get, _ggob.GobGame_enemy_team_set)
+    def AddPanel(*args): return _ggob.GobGame_AddPanel(*args)
+    def calculate(*args): return _ggob.GobGame_calculate(*args)
+    def setGameDone(*args): return _ggob.GobGame_setGameDone(*args)
+    def ship_died(*args): return _ggob.GobGame_ship_died(*args)
+    def preinit(*args): return _ggob.GobGame_preinit(*args)
+    def init(*args): return _ggob.GobGame_init(*args)
+    def play_sound(*args): return _ggob.GobGame_play_sound(*args)
+    def add_gobplayer(*args): return _ggob.GobGame_add_gobplayer(*args)
+    def get_player(*args): return _ggob.GobGame_get_player(*args)
+    __swig_setmethods__[&quot;gobenemies&quot;] = _ggob.GobGame_gobenemies_set
+    __swig_getmethods__[&quot;gobenemies&quot;] = _ggob.GobGame_gobenemies_get
+    if _newclass:gobenemies = property(_ggob.GobGame_gobenemies_get, _ggob.GobGame_gobenemies_set)
+    __swig_setmethods__[&quot;max_enemies&quot;] = _ggob.GobGame_max_enemies_set
+    __swig_getmethods__[&quot;max_enemies&quot;] = _ggob.GobGame_max_enemies_get
+    if _newclass:max_enemies = property(_ggob.GobGame_max_enemies_get, _ggob.GobGame_max_enemies_set)
+    __swig_setmethods__[&quot;gobenemy&quot;] = _ggob.GobGame_gobenemy_set
+    __swig_getmethods__[&quot;gobenemy&quot;] = _ggob.GobGame_gobenemy_get
+    if _newclass:gobenemy = property(_ggob.GobGame_gobenemy_get, _ggob.GobGame_gobenemy_set)
+    def get_enemy_index(*args): return _ggob.GobGame_get_enemy_index(*args)
+    def prepare(*args): return _ggob.GobGame_prepare(*args)
+    def fps(*args): return _ggob.GobGame_fps(*args)
+    def add_new_enemy(*args): return _ggob.GobGame_add_new_enemy(*args)
+    def add_stars(*args): return _ggob.GobGame_add_stars(*args)
+    def add_asteroid(*args): return _ggob.GobGame_add_asteroid(*args)
+    def add_system(*args): return _ggob.GobGame_add_system(*args)
+    def add_player(*args): return _ggob.GobGame_add_player(*args)
+    __swig_setmethods__[&quot;next_add_new_enemy_time&quot;] = _ggob.GobGame_next_add_new_enemy_time_set
+    __swig_getmethods__[&quot;next_add_new_enemy_time&quot;] = _ggob.GobGame_next_add_new_enemy_time_get
+    if _newclass:next_add_new_enemy_time = property(_ggob.GobGame_next_add_new_enemy_time_get, _ggob.GobGame_next_add_new_enemy_time_set)
+    __swig_setmethods__[&quot;defenderSprite&quot;] = _ggob.GobGame_defenderSprite_set
+    __swig_getmethods__[&quot;defenderSprite&quot;] = _ggob.GobGame_defenderSprite_get
+    if _newclass:defenderSprite = property(_ggob.GobGame_defenderSprite_get, _ggob.GobGame_defenderSprite_set)
+    __swig_setmethods__[&quot;num_planets&quot;] = _ggob.GobGame_num_planets_set
+    __swig_getmethods__[&quot;num_planets&quot;] = _ggob.GobGame_num_planets_get
+    if _newclass:num_planets = property(_ggob.GobGame_num_planets_get, _ggob.GobGame_num_planets_set)
+    __swig_setmethods__[&quot;planet&quot;] = _ggob.GobGame_planet_set
+    __swig_getmethods__[&quot;planet&quot;] = _ggob.GobGame_planet_get
+    if _newclass:planet = property(_ggob.GobGame_planet_get, _ggob.GobGame_planet_set)
+    __swig_setmethods__[&quot;station&quot;] = _ggob.GobGame_station_set
+    __swig_getmethods__[&quot;station&quot;] = _ggob.GobGame_station_get
+    if _newclass:station = property(_ggob.GobGame_station_get, _ggob.GobGame_station_set)
+    def add_planet_and_station(*args): return _ggob.GobGame_add_planet_and_station(*args)
+
+class GobGamePtr(GobGame):
+    def __init__(self, this):
+        _swig_setattr(self, GobGame, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobGame, 'thisown', 0)
+        _swig_setattr(self, GobGame,self.__class__,GobGame)
+_ggob.GobGame_swigregister(GobGamePtr)
+
+GobGame_get_this = _ggob.GobGame_get_this
+
+class GobStation(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobStation, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobStation, name)
+    def __repr__(self):
+        return &quot;&lt;C GobStation instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;_build_type&quot;] = _ggob.GobStation__build_type_set
+    __swig_getmethods__[&quot;_build_type&quot;] = _ggob.GobStation__build_type_get
+    if _newclass:_build_type = property(_ggob.GobStation__build_type_get, _ggob.GobStation__build_type_set)
+    __swig_setmethods__[&quot;_background_pic&quot;] = _ggob.GobStation__background_pic_set
+    __swig_getmethods__[&quot;_background_pic&quot;] = _ggob.GobStation__background_pic_get
+    if _newclass:_background_pic = property(_ggob.GobStation__background_pic_get, _ggob.GobStation__background_pic_set)
+    def __init__(self, *args):
+        _swig_setattr(self, GobStation, 'this', _ggob.new_GobStation(*args))
+        _swig_setattr(self, GobStation, 'thisown', 1)
+    def buy_new_ship_menu(*args): return _ggob.GobStation_buy_new_ship_menu(*args)
+    def inflict_damage(*args): return _ggob.GobStation_inflict_damage(*args)
+    def station_screen(*args): return _ggob.GobStation_station_screen(*args)
+    def upgrade_menu(*args): return _ggob.GobStation_upgrade_menu(*args)
+    def __del__(self, destroy=_ggob.delete_GobStation):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobStationPtr(GobStation):
+    def __init__(self, this):
+        _swig_setattr(self, GobStation, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobStation, 'thisown', 0)
+        _swig_setattr(self, GobStation,self.__class__,GobStation)
+_ggob.GobStation_swigregister(GobStationPtr)
+
+class Upgrade(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, Upgrade, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, Upgrade, name)
+    def __init__(self): raise RuntimeError, &quot;No constructor defined&quot;
+    def __repr__(self):
+        return &quot;&lt;C Upgrade instance at %s&gt;&quot; % (self.this,)
+    active = _ggob.Upgrade_active
+    inactive = _ggob.Upgrade_inactive
+    __swig_setmethods__[&quot;name&quot;] = _ggob.Upgrade_name_set
+    __swig_getmethods__[&quot;name&quot;] = _ggob.Upgrade_name_get
+    if _newclass:name = property(_ggob.Upgrade_name_get, _ggob.Upgrade_name_set)
+    __swig_setmethods__[&quot;starbucks&quot;] = _ggob.Upgrade_starbucks_set
+    __swig_getmethods__[&quot;starbucks&quot;] = _ggob.Upgrade_starbucks_get
+    if _newclass:starbucks = property(_ggob.Upgrade_starbucks_get, _ggob.Upgrade_starbucks_set)
+    __swig_setmethods__[&quot;buckazoids&quot;] = _ggob.Upgrade_buckazoids_set
+    __swig_getmethods__[&quot;buckazoids&quot;] = _ggob.Upgrade_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.Upgrade_buckazoids_get, _ggob.Upgrade_buckazoids_set)
+    __swig_setmethods__[&quot;status&quot;] = _ggob.Upgrade_status_set
+    __swig_getmethods__[&quot;status&quot;] = _ggob.Upgrade_status_get
+    if _newclass:status = property(_ggob.Upgrade_status_get, _ggob.Upgrade_status_set)
+    __swig_setmethods__[&quot;num&quot;] = _ggob.Upgrade_num_set
+    __swig_getmethods__[&quot;num&quot;] = _ggob.Upgrade_num_get
+    if _newclass:num = property(_ggob.Upgrade_num_get, _ggob.Upgrade_num_set)
+    __swig_setmethods__[&quot;index&quot;] = _ggob.Upgrade_index_set
+    __swig_getmethods__[&quot;index&quot;] = _ggob.Upgrade_index_get
+    if _newclass:index = property(_ggob.Upgrade_index_get, _ggob.Upgrade_index_set)
+    def update(*args): return _ggob.Upgrade_update(*args)
+    def execute(*args): return _ggob.Upgrade_execute(*args)
+    def charge(*args): return _ggob.Upgrade_charge(*args)
+    def clear(*args): return _ggob.Upgrade_clear(*args)
+    def duplicate(*args): return _ggob.Upgrade_duplicate(*args)
+    def __del__(self, destroy=_ggob.delete_Upgrade):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class UpgradePtr(Upgrade):
+    def __init__(self, this):
+        _swig_setattr(self, Upgrade, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, Upgrade, 'thisown', 0)
+        _swig_setattr(self, Upgrade,self.__class__,Upgrade)
+_ggob.Upgrade_swigregister(UpgradePtr)
+
+class RainbowRift(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, RainbowRift, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, RainbowRift, name)
+    def __repr__(self):
+        return &quot;&lt;C RainbowRift instance at %s&gt;&quot; % (self.this,)
+    n = _ggob.RainbowRift_n
+    __swig_setmethods__[&quot;p&quot;] = _ggob.RainbowRift_p_set
+    __swig_getmethods__[&quot;p&quot;] = _ggob.RainbowRift_p_get
+    if _newclass:p = property(_ggob.RainbowRift_p_get, _ggob.RainbowRift_p_set)
+    __swig_setmethods__[&quot;c&quot;] = _ggob.RainbowRift_c_set
+    __swig_getmethods__[&quot;c&quot;] = _ggob.RainbowRift_c_get
+    if _newclass:c = property(_ggob.RainbowRift_c_get, _ggob.RainbowRift_c_set)
+    __swig_setmethods__[&quot;next_time&quot;] = _ggob.RainbowRift_next_time_set
+    __swig_getmethods__[&quot;next_time&quot;] = _ggob.RainbowRift_next_time_get
+    if _newclass:next_time = property(_ggob.RainbowRift_next_time_get, _ggob.RainbowRift_next_time_set)
+    __swig_setmethods__[&quot;next_time2&quot;] = _ggob.RainbowRift_next_time2_set
+    __swig_getmethods__[&quot;next_time2&quot;] = _ggob.RainbowRift_next_time2_get
+    if _newclass:next_time2 = property(_ggob.RainbowRift_next_time2_get, _ggob.RainbowRift_next_time2_set)
+    def __init__(self, *args):
+        _swig_setattr(self, RainbowRift, 'this', _ggob.new_RainbowRift(*args))
+        _swig_setattr(self, RainbowRift, 'thisown', 1)
+    def animate(*args): return _ggob.RainbowRift_animate(*args)
+    def calculate(*args): return _ggob.RainbowRift_calculate(*args)
+    def squiggle(*args): return _ggob.RainbowRift_squiggle(*args)
+    def __del__(self, destroy=_ggob.delete_RainbowRift):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class RainbowRiftPtr(RainbowRift):
+    def __init__(self, this):
+        _swig_setattr(self, RainbowRift, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, RainbowRift, 'thisown', 0)
+        _swig_setattr(self, RainbowRift,self.__class__,RainbowRift)
+_ggob.RainbowRift_swigregister(RainbowRiftPtr)
+
+

Added: trunk/gamedata/python/start.py
===================================================================
--- trunk/gamedata/python/start.py	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/gamedata/python/start.py	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,34 @@
+import ggob
+
+game = ggob.GobGame.get_this()
+
+# System Arix
+game.add_system('Arix', 50, 50)
+game.prepare()
+
+game.add_planet_and_station(0, 'gob.dat', 'station0sprite', 'gob.dat#station0picture.bmp', 'supbl')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'orzne')
+game.add_planet_and_station(2, 'gob.dat', 'station2sprite', 'gob.dat#station2picture.bmp', 'kohma')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'utwju')
+
+game.add_new_enemy()
+
+for i in xrange(10):
+    game.add_asteroid()
+
+# System Beta
+game.add_system('Beta', 100, 100)
+game.prepare()
+
+game.add_stars()
+game.add_planet_and_station(0, 'gob.dat', 'station0sprite', 'gob.dat#station0picture.bmp', 'supbl')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'orzne')
+game.add_planet_and_station(2, 'gob.dat', 'station2sprite', 'gob.dat#station2picture.bmp', 'kohma')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'utwju')
+
+game.add_new_enemy()
+
+for i in xrange(10):
+    game.add_asteroid()
+
+game.add_player('Arix', 12400, 12400)

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/makefile	2005-03-12 19:12:58 UTC (rev 136)
@@ -55,7 +55,8 @@
 ifdef debug
 DATAPATH=gamedata
 else
-DATAPATH=/usr/local/share/games/tw-light
+#DATAPATH=/usr/local/share/games/tw-light
+DATAPATH=gamedata
 endif
 endif
 endif
@@ -80,11 +81,10 @@
         source/other source/ships source/sc1ships source/sc2ships \
         source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
-        source/libraries/raknet \
-        source/libraries/lua source/libraries/lua/lib 
+        source/libraries/raknet source/python source/generated 
 
 #FILELIST := ${shell find source -type f &quot;(&quot; -name &quot;*.c&quot; -o -name &quot;*.cpp&quot; &quot;)&quot;}
-FILELIST= ${shell cat sources.lst}
+FILELIST= ${shell cat sources.lst} 
 
 BASE_NAMES = $(basename $(notdir $(FILELIST)))
 POBJS = $(addsuffix .o,$(BASE_NAMES))
@@ -116,18 +116,18 @@
 	OBJDIR := ${addsuffix -win32,$(OBJDIR)}
 	NAME := ${addsuffix .exe,$(NAME)}
 	CFLAGS += -DWIN32 -I mingw-libs/include -I mingw-libs/include/SDL 
-	LIBS += -L mingw-libs/lib -lalleg -lwinmm -lws2_32 -lSDL -lSDLmain 
+	LIBS += -L mingw-libs/lib -lalleg -lwinmm -lws2_32 -lSDL -lSDLmain -lpython24 -lz 
 else
 	TIMESTAMP = ${shell LC_TIME=&quot;POSIX&quot; date +%c}
 	EXPDIR=tw-light-$(PRODUCTVERSION)r$(SVNVERSION)
 	CFLAGS += -DLINUX
-	INCLUDES := ${shell allegro-config --cflags} ${shell sdl-config --cflags} ${shell xslt-config --cflags} ${shell xmlwrapp-config --cflags} 
+	INCLUDES := ${shell allegro-config --cflags} ${shell sdl-config --cflags} 
 	CFLAGS += $(INCLUDES)
-	LIBS_CONFIG := ${shell allegro-config --libs} -pthread ${shell sdl-config --libs} ${shell xslt-config --libs}  ${shell xmlwrapp-config --libs} 
-	LIBS += $(LIBS_CONFIG)
+	LIBS_CONFIG := ${shell allegro-config --libs} -pthread ${shell sdl-config --libs} ${shell python-config} 
+	LIBS += $(LIBS_CONFIG) -lc -lXt -L/usr/X11R6/lib -lX11 -lm -lz
 endif
 
-CFLAGS += -I./source -I./source/libraries -I./source/libraries/lua
+CFLAGS += -I./source -I./source/libraries -I/usr/include/python2.3
 
 ifdef TEST
 
@@ -169,6 +169,12 @@
 	$(LD) $(CFLAGS) $(SUBSYSTEM) -o $@ $(OBJDIR)/*.o $(LIBS) 
 	./$(NAME) -test
 
+
+source/generated/ggob_wrap.cpp: source/games/ggob.i source/games/ggob.h
+	swig -c++ -python -o source/generated/ggob_wrap.cpp source/games/ggob.i
+	cp source/generated/ggob.py $(DATAPATH)/python/
+
+
 $(OBJDIR)/%.o: %.cpp
 	$(CX) -MMD $(CFLAGS) -c $&lt; -o $@
 
@@ -178,6 +184,7 @@
 $(OBJDIR)/winicon.o: tw-light.rc tw-light.ico
 	$(RC) tw-light.rc -o $(OBJDIR)/winicon.o
 
+
 clean:
 	$(RM) $(OBJDIR)/*.o
 	$(RM) $(OBJDIR)/*.d

Added: trunk/mingw-libs/include/Python.h
===================================================================
--- trunk/mingw-libs/include/Python.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/Python.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,171 @@
+#ifndef Py_PYTHON_H
+#define Py_PYTHON_H
+/* Since this is a &quot;meta-include&quot; file, no #ifdef __cplusplus / extern &quot;C&quot; { */
+
+/* Include nearly all Python header files */
+
+#include &quot;patchlevel.h&quot;
+#include &quot;pyconfig.h&quot;
+
+/* Cyclic gc is always enabled, starting with release 2.3a1.  Supply the
+ * old symbol for the benefit of extension modules written before then
+ * that may be conditionalizing on it.  The core doesn't use it anymore.
+ */
+#ifndef WITH_CYCLE_GC
+#define WITH_CYCLE_GC 1
+#endif
+
+#include &lt;limits.h&gt;
+
+#ifndef UCHAR_MAX
+#error &quot;Something's broken.  UCHAR_MAX should be defined in limits.h.&quot;
+#endif
+
+#if UCHAR_MAX != 255
+#error &quot;Python's source code assumes C's unsigned char is an 8-bit type.&quot;
+#endif
+
+#if defined(__sgi) &amp;&amp; defined(WITH_THREAD) &amp;&amp; !defined(_SGI_MP_SOURCE)
+#define _SGI_MP_SOURCE
+#endif
+
+#include &lt;stdio.h&gt;
+#ifndef NULL
+#   error &quot;Python.h requires that stdio.h define NULL.&quot;
+#endif
+
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdlib.h&gt;
+#ifdef HAVE_UNISTD_H
+#include &lt;unistd.h&gt;
+#endif
+
+/* For uintptr_t, intptr_t */
+#ifdef HAVE_STDDEF_H
+#include &lt;stddef.h&gt;
+#endif
+
+/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
+ * compiler command line when building Python in release mode; else
+ * assert() calls won't be removed.
+ */
+#include &lt;assert.h&gt;
+
+#include &quot;pyport.h&quot;
+
+/* pyconfig.h or pyport.h may or may not define DL_IMPORT */
+#ifndef DL_IMPORT	/* declarations for DLL import/export */
+#define DL_IMPORT(RTYPE) RTYPE
+#endif
+#ifndef DL_EXPORT	/* declarations for DLL import/export */
+#define DL_EXPORT(RTYPE) RTYPE
+#endif
+
+/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.
+ *  PYMALLOC_DEBUG is in error if pymalloc is not in use.
+ */
+#if defined(Py_DEBUG) &amp;&amp; defined(WITH_PYMALLOC) &amp;&amp; !defined(PYMALLOC_DEBUG)
+#define PYMALLOC_DEBUG
+#endif
+#if defined(PYMALLOC_DEBUG) &amp;&amp; !defined(WITH_PYMALLOC)
+#error &quot;PYMALLOC_DEBUG requires WITH_PYMALLOC&quot;
+#endif
+#include &quot;pymem.h&quot;
+
+#include &quot;object.h&quot;
+#include &quot;objimpl.h&quot;
+
+#include &quot;pydebug.h&quot;
+
+#include &quot;unicodeobject.h&quot;
+#include &quot;intobject.h&quot;
+#include &quot;boolobject.h&quot;
+#include &quot;longobject.h&quot;
+#include &quot;floatobject.h&quot;
+#ifndef WITHOUT_COMPLEX
+#include &quot;complexobject.h&quot;
+#endif
+#include &quot;rangeobject.h&quot;
+#include &quot;stringobject.h&quot;
+#include &quot;bufferobject.h&quot;
+#include &quot;tupleobject.h&quot;
+#include &quot;listobject.h&quot;
+#include &quot;dictobject.h&quot;
+#include &quot;enumobject.h&quot;
+#include &quot;setobject.h&quot;
+#include &quot;methodobject.h&quot;
+#include &quot;moduleobject.h&quot;
+#include &quot;funcobject.h&quot;
+#include &quot;classobject.h&quot;
+#include &quot;fileobject.h&quot;
+#include &quot;cobject.h&quot;
+#include &quot;traceback.h&quot;
+#include &quot;sliceobject.h&quot;
+#include &quot;cellobject.h&quot;
+#include &quot;iterobject.h&quot;
+#include &quot;genobject.h&quot;
+#include &quot;descrobject.h&quot;
+#include &quot;weakrefobject.h&quot;
+
+#include &quot;codecs.h&quot;
+#include &quot;pyerrors.h&quot;
+
+#include &quot;pystate.h&quot;
+
+#include &quot;modsupport.h&quot;
+#include &quot;pythonrun.h&quot;
+#include &quot;ceval.h&quot;
+#include &quot;sysmodule.h&quot;
+#include &quot;intrcheck.h&quot;
+#include &quot;import.h&quot;
+
+#include &quot;abstract.h&quot;
+
+#include &quot;compile.h&quot;
+#include &quot;eval.h&quot;
+
+#include &quot;pystrtod.h&quot;
+
+/* _Py_Mangle is defined in compile.c */
+PyAPI_FUNC(int) _Py_Mangle(char *p, char *name, \
+				 char *buffer, size_t maxlen);
+
+/* PyArg_GetInt is deprecated and should not be used, use PyArg_Parse(). */
+#define PyArg_GetInt(v, a)	PyArg_Parse((v), &quot;i&quot;, (a))
+
+/* PyArg_NoArgs should not be necessary.
+   Set ml_flags in the PyMethodDef to METH_NOARGS. */
+#define PyArg_NoArgs(v)		PyArg_Parse(v, &quot;&quot;)
+
+/* Convert a possibly signed character to a nonnegative int */
+/* XXX This assumes characters are 8 bits wide */
+#ifdef __CHAR_UNSIGNED__
+#define Py_CHARMASK(c)		(c)
+#else
+#define Py_CHARMASK(c)		((c) &amp; 0xff)
+#endif
+
+#include &quot;pyfpe.h&quot;
+
+/* These definitions must match corresponding definitions in graminit.h.
+   There's code in compile.c that checks that they are the same. */
+#define Py_single_input 256
+#define Py_file_input 257
+#define Py_eval_input 258
+
+#ifdef HAVE_PTH
+/* GNU pth user-space thread support */
+#include &lt;pth.h&gt;
+#endif
+
+/* Define macros for inline documentation. */
+#define PyDoc_VAR(name) static char name[]
+#define PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)
+#ifdef WITH_DOC_STRINGS
+#define PyDoc_STR(str) str
+#else
+#define PyDoc_STR(str) &quot;&quot;
+#endif
+
+#endif /* !Py_PYTHON_H */

Added: trunk/mingw-libs/include/abstract.h
===================================================================
--- trunk/mingw-libs/include/abstract.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/abstract.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,1223 @@
+#ifndef Py_ABSTRACTOBJECT_H
+#define Py_ABSTRACTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Abstract Object Interface (many thanks to Jim Fulton) */
+
+/*
+   PROPOSAL: A Generic Python Object Interface for Python C Modules
+
+Problem
+
+  Python modules written in C that must access Python objects must do
+  so through routines whose interfaces are described by a set of
+  include files.  Unfortunately, these routines vary according to the
+  object accessed.  To use these routines, the C programmer must check
+  the type of the object being used and must call a routine based on
+  the object type.  For example, to access an element of a sequence,
+  the programmer must determine whether the sequence is a list or a
+  tuple:
+
+    if(is_tupleobject(o))
+      e=gettupleitem(o,i)
+    else if(is_listitem(o))
+      e=getlistitem(o,i)
+
+  If the programmer wants to get an item from another type of object
+  that provides sequence behavior, there is no clear way to do it
+  correctly.  
+
+  The persistent programmer may peruse object.h and find that the
+  _typeobject structure provides a means of invoking up to (currently
+  about) 41 special operators.  So, for example, a routine can get an
+  item from any object that provides sequence behavior. However, to
+  use this mechanism, the programmer must make their code dependent on
+  the current Python implementation.
+
+  Also, certain semantics, especially memory management semantics, may
+  differ by the type of object being used.  Unfortunately, these
+  semantics are not clearly described in the current include files.
+  An abstract interface providing more consistent semantics is needed. 
+
+Proposal
+
+  I propose the creation of a standard interface (with an associated
+  library of routines and/or macros) for generically obtaining the
+  services of Python objects.  This proposal can be viewed as one
+  components of a Python C interface consisting of several components.
+
+  From the viewpoint of C access to Python services, we have (as
+  suggested by Guido in off-line discussions):
+
+  - &quot;Very high level layer&quot;: two or three functions that let you exec or
+    eval arbitrary Python code given as a string in a module whose name is
+    given, passing C values in and getting C values out using
+    mkvalue/getargs style format strings.  This does not require the user
+    to declare any variables of type &quot;PyObject *&quot;.  This should be enough
+    to write a simple application that gets Python code from the user,
+    execs it, and returns the output or errors.  (Error handling must also
+    be part of this API.)
+
+  - &quot;Abstract objects layer&quot;: which is the subject of this proposal.
+    It has many functions operating on objects, and lest you do many
+    things from C that you can also write in Python, without going
+    through the Python parser.
+
+  - &quot;Concrete objects layer&quot;: This is the public type-dependent
+    interface provided by the standard built-in types, such as floats,
+    strings, and lists.  This interface exists and is currently
+    documented by the collection of include files provided with the
+    Python distributions.
+
+  From the point of view of Python accessing services provided by C
+  modules: 
+
+  - &quot;Python module interface&quot;: this interface consist of the basic
+    routines used to define modules and their members.  Most of the
+    current extensions-writing guide deals with this interface.
+
+  - &quot;Built-in object interface&quot;: this is the interface that a new
+    built-in type must provide and the mechanisms and rules that a
+    developer of a new built-in type must use and follow.
+
+  This proposal is a &quot;first-cut&quot; that is intended to spur
+  discussion. See especially the lists of notes.
+
+  The Python C object interface will provide four protocols: object,
+  numeric, sequence, and mapping.  Each protocol consists of a
+  collection of related operations.  If an operation that is not
+  provided by a particular type is invoked, then a standard exception,
+  NotImplementedError is raised with a operation name as an argument.
+  In addition, for convenience this interface defines a set of
+  constructors for building objects of built-in types.  This is needed
+  so new objects can be returned from C functions that otherwise treat
+  objects generically.
+
+Memory Management
+
+  For all of the functions described in this proposal, if a function
+  retains a reference to a Python object passed as an argument, then the
+  function will increase the reference count of the object.  It is
+  unnecessary for the caller to increase the reference count of an
+  argument in anticipation of the object's retention.
+
+  All Python objects returned from functions should be treated as new
+  objects.  Functions that return objects assume that the caller will
+  retain a reference and the reference count of the object has already
+  been incremented to account for this fact.  A caller that does not
+  retain a reference to an object that is returned from a function
+  must decrement the reference count of the object (using
+  DECREF(object)) to prevent memory leaks.
+
+  Note that the behavior mentioned here is different from the current
+  behavior for some objects (e.g. lists and tuples) when certain
+  type-specific routines are called directly (e.g. setlistitem).  The
+  proposed abstraction layer will provide a consistent memory
+  management interface, correcting for inconsistent behavior for some
+  built-in types.
+
+Protocols
+
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/
+
+/*  Object Protocol: */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Print(PyObject *o, FILE *fp, int flags);
+
+         Print an object, o, on file, fp.  Returns -1 on
+	 error.  The flags argument is used to enable certain printing
+	 options. The only option currently supported is Py_Print_RAW. 
+
+         (What should be said about Py_Print_RAW?)	
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_HasAttrString(PyObject *o, char *attr_name);
+
+         Returns 1 if o has the attribute attr_name, and 0 otherwise.
+	 This is equivalent to the Python expression:
+	 hasattr(o,attr_name). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject* PyObject_GetAttrString(PyObject *o, char *attr_name);
+
+	 Retrieve an attributed named attr_name form object o.
+	 Returns the attribute value on success, or NULL on failure.
+	 This is the equivalent of the Python expression: o.attr_name.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_HasAttr(PyObject *o, PyObject *attr_name);
+
+         Returns 1 if o has the attribute attr_name, and 0 otherwise.
+	 This is equivalent to the Python expression:
+	 hasattr(o,attr_name). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);
+
+	 Retrieve an attributed named attr_name form object o.
+	 Returns the attribute value on success, or NULL on failure.
+	 This is the equivalent of the Python expression: o.attr_name.
+
+       */
+
+
+     /* Implemented elsewhere:
+
+     int PyObject_SetAttrString(PyObject *o, char *attr_name, PyObject *v);
+
+	 Set the value of the attribute named attr_name, for object o,
+	 to the value, v. Returns -1 on failure.  This is
+	 the equivalent of the Python statement: o.attr_name=v.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);
+
+	 Set the value of the attribute named attr_name, for object o,
+	 to the value, v. Returns -1 on failure.  This is
+	 the equivalent of the Python statement: o.attr_name=v.
+
+       */
+
+     /* implemented as a macro:
+
+     int PyObject_DelAttrString(PyObject *o, char *attr_name);
+
+	 Delete attribute named attr_name, for object o. Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: del o.attr_name.
+
+       */
+#define  PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A),NULL)
+
+     /* implemented as a macro:
+
+     int PyObject_DelAttr(PyObject *o, PyObject *attr_name);
+
+	 Delete attribute named attr_name, for object o. Returns -1
+	 on failure.  This is the equivalent of the Python
+	 statement: del o.attr_name.
+
+       */
+#define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A),NULL)
+
+     PyAPI_FUNC(int) PyObject_Cmp(PyObject *o1, PyObject *o2, int *result);
+
+       /*
+	 Compare the values of o1 and o2 using a routine provided by
+	 o1, if one exists, otherwise with a routine provided by o2.
+	 The result of the comparison is returned in result.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: result=cmp(o1,o2).
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Compare(PyObject *o1, PyObject *o2);
+
+	 Compare the values of o1 and o2 using a routine provided by
+	 o1, if one exists, otherwise with a routine provided by o2.
+	 Returns the result of the comparison on success.  On error,
+	 the value returned is undefined. This is equivalent to the
+	 Python expression: cmp(o1,o2).
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Repr(PyObject *o);
+
+	 Compute the string representation of object, o.  Returns the
+	 string representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: repr(o).
+
+	 Called by the repr() built-in function and by reverse quotes.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Str(PyObject *o);
+
+	 Compute the string representation of object, o.  Returns the
+	 string representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: str(o).)
+
+	 Called by the str() built-in function and by the print
+	 statement.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Unicode(PyObject *o);
+
+	 Compute the unicode representation of object, o.  Returns the
+	 unicode representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: unistr(o).)
+
+	 Called by the unistr() built-in function.
+
+       */
+
+     PyAPI_FUNC(int) PyCallable_Check(PyObject *o);
+
+       /*
+	 Determine if the object, o, is callable.  Return 1 if the
+	 object is callable and 0 otherwise.
+
+	 This function always succeeds.
+
+       */
+
+
+
+     PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable_object,
+					 PyObject *args, PyObject *kw);
+
+       /*
+	 Call a callable Python object, callable_object, with
+	 arguments and keywords arguments.  The 'args' argument can not be
+	 NULL, but the 'kw' argument can be NULL.
+
+       */
+     
+     PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable_object,
+                                               PyObject *args);
+
+       /*
+	 Call a callable Python object, callable_object, with
+	 arguments given by the tuple, args.  If no arguments are
+	 needed, then args may be NULL.  Returns the result of the
+	 call on success, or NULL on failure.  This is the equivalent
+	 of the Python expression: apply(o,args).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable_object,
+                                                 char *format, ...);
+
+       /*
+	 Call a callable Python object, callable_object, with a
+	 variable number of C arguments. The C arguments are described
+	 using a mkvalue-style format string. The format may be NULL,
+	 indicating that no arguments are provided.  Returns the
+	 result of the call on success, or NULL on failure.  This is
+	 the equivalent of the Python expression: apply(o,args).
+
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *o, char *m,
+                                               char *format, ...);
+
+       /*
+	 Call the method named m of object o with a variable number of
+	 C arguments.  The C arguments are described by a mkvalue
+	 format string.  The format may be NULL, indicating that no
+	 arguments are provided. Returns the result of the call on
+	 success, or NULL on failure.  This is the equivalent of the
+	 Python expression: o.method(args).
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
+                                                        ...);
+
+       /*
+	 Call a callable Python object, callable_object, with a
+	 variable number of C arguments.  The C arguments are provided
+	 as PyObject * values, terminated by a NULL.  Returns the
+	 result of the call on success, or NULL on failure.  This is
+	 the equivalent of the Python expression: apply(o,args).
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(PyObject *o,
+                                                      PyObject *m, ...);
+
+       /*
+	 Call the method named m of object o with a variable number of
+	 C arguments.  The C arguments are provided as PyObject *
+	 values, terminated by NULL.  Returns the result of the call
+	 on success, or NULL on failure.  This is the equivalent of
+	 the Python expression: o.method(args).
+       */
+
+
+     /* Implemented elsewhere:
+
+     long PyObject_Hash(PyObject *o);
+
+         Compute and return the hash, hash_value, of an object, o.  On
+	 failure, return -1.  This is the equivalent of the Python
+	 expression: hash(o).
+
+       */
+
+
+     /* Implemented elsewhere:
+
+     int PyObject_IsTrue(PyObject *o);
+
+	 Returns 1 if the object, o, is considered to be true, 0 if o is
+	 considered to be false and -1 on failure. This is equivalent to the
+	 Python expression: not not o
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Not(PyObject *o);
+
+	 Returns 0 if the object, o, is considered to be true, 1 if o is
+	 considered to be false and -1 on failure. This is equivalent to the
+	 Python expression: not o
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
+
+       /*
+	 On success, returns a type object corresponding to the object
+	 type of object o. On failure, returns NULL.  This is
+	 equivalent to the Python expression: type(o).
+       */
+
+     PyAPI_FUNC(int) PyObject_Size(PyObject *o);
+
+       /*
+         Return the size of object o.  If the object, o, provides
+	 both sequence and mapping protocols, the sequence size is
+	 returned. On error, -1 is returned.  This is the equivalent
+	 to the Python expression: len(o).
+
+       */
+
+       /* For DLL compatibility */
+#undef PyObject_Length
+     PyAPI_FUNC(int) PyObject_Length(PyObject *o);
+#define PyObject_Length PyObject_Size
+
+
+     PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
+
+       /*
+	 Return element of o corresponding to the object, key, or NULL
+	 on failure. This is the equivalent of the Python expression:
+	 o[key].
+
+       */
+
+     PyAPI_FUNC(int) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);
+
+       /*
+	 Map the object, key, to the value, v.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[key]=v.
+       */
+
+     PyAPI_FUNC(int) PyObject_DelItemString(PyObject *o, char *key);
+
+       /*
+         Remove the mapping for object, key, from the object *o.
+         Returns -1 on failure.  This is equivalent to
+         the Python statement: del o[key].
+       */
+
+     PyAPI_FUNC(int) PyObject_DelItem(PyObject *o, PyObject *key);
+
+       /*
+	 Delete the mapping for key from *o.  Returns -1 on failure.
+	 This is the equivalent of the Python statement: del o[key].
+       */
+
+     PyAPI_FUNC(int) PyObject_AsCharBuffer(PyObject *obj,
+					  const char **buffer,
+					  int *buffer_len);
+
+       /* 
+	  Takes an arbitrary object which must support the (character,
+	  single segment) buffer interface and returns a pointer to a
+	  read-only memory location useable as character based input
+	  for subsequent processing.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurs. Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+     PyAPI_FUNC(int) PyObject_CheckReadBuffer(PyObject *obj);
+
+      /*  
+	  Checks whether an arbitrary object supports the (character,
+	  single segment) buffer interface.  Returns 1 on success, 0
+	  on failure.
+
+      */
+
+     PyAPI_FUNC(int) PyObject_AsReadBuffer(PyObject *obj,
+					  const void **buffer,
+					  int *buffer_len);
+
+       /* 
+	  Same as PyObject_AsCharBuffer() except that this API expects
+	  (readable, single segment) buffer interface and returns a
+	  pointer to a read-only memory location which can contain
+	  arbitrary data.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurrs.  Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+     PyAPI_FUNC(int) PyObject_AsWriteBuffer(PyObject *obj,
+					   void **buffer,
+					   int *buffer_len);
+
+       /* 
+	  Takes an arbitrary object which must support the (writeable,
+	  single segment) buffer interface and returns a pointer to a
+	  writeable memory location in buffer of size buffer_len.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurrs. Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+/* Iterators */
+
+     PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
+     /* Takes an object and returns an iterator for it.
+        This is typically a new iterator but if the argument
+	is an iterator, this returns itself. */
+
+#define PyIter_Check(obj) \
+    (PyType_HasFeature((obj)-&gt;ob_type, Py_TPFLAGS_HAVE_ITER) &amp;&amp; \
+     (obj)-&gt;ob_type-&gt;tp_iternext != NULL)
+
+     PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
+     /* Takes an iterator object and calls its tp_iternext slot,
+	returning the next value.  If the iterator is exhausted,
+	this returns NULL without setting an exception.
+	NULL with an exception means an error occurred. */
+
+/*  Number Protocol:*/
+
+     PyAPI_FUNC(int) PyNumber_Check(PyObject *o);
+
+       /*
+         Returns 1 if the object, o, provides numeric protocols, and
+	 false otherwise. 
+
+	 This function always succeeds.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of adding o1 and o2, or null on failure.
+	 This is the equivalent of the Python expression: o1+o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of subtracting o2 from o1, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1-o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of multiplying o1 and o2, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1*o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Divide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2, or null on failure.
+	 This is the equivalent of the Python expression: o1/o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving an integral result,
+	 or null on failure.
+	 This is the equivalent of the Python expression: o1//o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving a float result,
+	 or null on failure.
+	 This is the equivalent of the Python expression: o1/o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the remainder of dividing o1 by o2, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1%o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
+
+       /*
+	 See the built-in function divmod.  Returns NULL on failure.
+	 This is the equivalent of the Python expression:
+	 divmod(o1,o2).
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
+                                          PyObject *o3);
+
+       /*
+	 See the built-in function pow.  Returns NULL on failure.
+	 This is the equivalent of the Python expression:
+	 pow(o1,o2,o3), where o3 is optional.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
+
+       /*
+	 Returns the negation of o on success, or null on failure.
+	 This is the equivalent of the Python expression: -o.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
+
+       /*
+         Returns the (what?) of o on success, or NULL on failure.
+	 This is the equivalent of the Python expression: +o.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
+
+       /*
+	 Returns the absolute value of o, or null on failure.  This is
+	 the equivalent of the Python expression: abs(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
+
+       /*
+	 Returns the bitwise negation of o on success, or NULL on
+	 failure.  This is the equivalent of the Python expression:
+	 ~o.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of left shifting o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1 &lt;&lt; o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of right shifting o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1 &gt;&gt; o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise and of o1 and o2 on success, or
+	 NULL on failure. This is the equivalent of the Python
+	 expression: o1&amp;o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the bitwise exclusive or of o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1^o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise or on o1 and o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1|o2.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyNumber_Coerce(PyObject **p1, PyObject **p2);
+
+	 This function takes the addresses of two variables of type
+	 PyObject*.
+
+	 If the objects pointed to by *p1 and *p2 have the same type,
+	 increment their reference count and return 0 (success).
+	 If the objects can be converted to a common numeric type,
+	 replace *p1 and *p2 by their converted value (with 'new'
+	 reference counts), and return 0.
+	 If no conversion is possible, or if some other error occurs,
+	 return -1 (failure) and don't increment the reference counts.
+	 The call PyNumber_Coerce(&amp;o1, &amp;o2) is equivalent to the Python
+	 statement o1, o2 = coerce(o1, o2).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Int(PyObject *o);
+
+       /*
+	 Returns the o converted to an integer object on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: int(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
+
+       /*
+	 Returns the o converted to a long integer object on success,
+	 or NULL on failure.  This is the equivalent of the Python
+	 expression: long(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
+
+       /*
+	 Returns the o converted to a float object on success, or NULL
+	 on failure.  This is the equivalent of the Python expression:
+	 float(o).
+       */
+	 
+/*  In-place variants of (some of) the above number protocol functions */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of adding o2 to o1, possibly in-place, or null
+	 on failure.  This is the equivalent of the Python expression:
+	 o1 += o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of subtracting o2 from o1, possibly in-place or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 -= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of multiplying o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 *= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2, possibly in-place, or null
+	 on failure.  This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
+						       PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving an integral result,
+	 possibly in-place, or null on failure.
+	 This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
+						      PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving a float result,
+	 possibly in-place, or null on failure.
+	 This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the remainder of dividing o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 %= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
+     						 PyObject *o3);
+
+       /*
+	 Returns the result of raising o1 to the power of o2, possibly
+	 in-place, or null on failure.  This is the equivalent of the Python
+	 expression: o1 **= o2, or pow(o1, o2, o3) if o3 is present.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of left shifting o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 &lt;&lt;= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of right shifting o1 by o2, possibly in-place or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 &gt;&gt;= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise and of o1 and o2, possibly in-place,
+	 or null on failure. This is the equivalent of the Python
+	 expression: o1 &amp;= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the bitwise exclusive or of o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 ^= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise or of o1 and o2, possibly in-place,
+	 or null on failure.  This is the equivalent of the Python
+	 expression: o1 |= o2.
+
+       */
+
+
+/*  Sequence protocol:*/
+
+     PyAPI_FUNC(int) PySequence_Check(PyObject *o);
+
+       /*
+         Return 1 if the object provides sequence protocol, and zero
+	 otherwise.  
+
+	 This function always succeeds.
+
+       */
+
+     PyAPI_FUNC(int) PySequence_Size(PyObject *o);
+
+       /*
+         Return the size of sequence object o, or -1 on failure.
+
+       */
+
+       /* For DLL compatibility */
+#undef PySequence_Length
+     PyAPI_FUNC(int) PySequence_Length(PyObject *o);
+#define PySequence_Length PySequence_Size
+
+
+     PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
+
+       /*
+	 Return the concatenation of o1 and o2 on success, and NULL on
+	 failure.   This is the equivalent of the Python
+	 expression: o1+o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, int count);
+
+       /*
+	 Return the result of repeating sequence object o count times,
+	 or NULL on failure.  This is the equivalent of the Python
+	 expression: o1*count.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, int i);
+
+       /*
+	 Return the ith element of o, or NULL on failure. This is the
+	 equivalent of the Python expression: o[i].
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, int i1, int i2);
+
+       /*
+	 Return the slice of sequence object o between i1 and i2, or
+	 NULL on failure. This is the equivalent of the Python
+	 expression: o[i1:i2].
+
+       */
+
+     PyAPI_FUNC(int) PySequence_SetItem(PyObject *o, int i, PyObject *v);
+
+       /*
+	 Assign object v to the ith element of o.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[i]=v.
+
+       */
+
+     PyAPI_FUNC(int) PySequence_DelItem(PyObject *o, int i);
+
+       /*
+	 Delete the ith element of object v.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: del o[i].
+       */
+
+     PyAPI_FUNC(int) PySequence_SetSlice(PyObject *o, int i1, int i2,
+                                        PyObject *v);
+
+       /*
+         Assign the sequence object, v, to the slice in sequence
+	 object, o, from i1 to i2.  Returns -1 on failure. This is the
+	 equivalent of the Python statement: o[i1:i2]=v.
+       */
+
+     PyAPI_FUNC(int) PySequence_DelSlice(PyObject *o, int i1, int i2);
+
+       /*
+	 Delete the slice in sequence object, o, from i1 to i2.
+	 Returns -1 on failure. This is the equivalent of the Python
+	 statement: del o[i1:i2].
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
+
+       /*
+	 Returns the sequence, o, as a tuple on success, and NULL on failure.
+	 This is equivalent to the Python expression: tuple(o)
+       */
+
+
+     PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
+       /*
+	 Returns the sequence, o, as a list on success, and NULL on failure.
+	 This is equivalent to the Python expression: list(o)
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
+       /*
+         Returns the sequence, o, as a tuple, unless it's already a
+         tuple or list.  Use PySequence_Fast_GET_ITEM to access the
+         members of this list, and PySequence_Fast_GET_SIZE to get its length.
+
+         Returns NULL on failure.  If the object does not support iteration,
+         raises a TypeError exception with m as the message text.
+       */
+
+#define PySequence_Fast_GET_SIZE(o) \
+	(PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
+       /*
+	 Return the size of o, assuming that o was returned by
+         PySequence_Fast and is not NULL.
+       */
+
+#define PySequence_Fast_GET_ITEM(o, i)\
+     (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
+       /*
+	 Return the ith element of o, assuming that o was returned by
+         PySequence_Fast, and that i is within bounds.
+       */
+
+#define PySequence_ITEM(o, i)\
+	( o-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item(o, i) )
+       /* Assume tp_as_sequence and sq_item exist and that i does not
+	  need to be corrected for a negative index
+       */     
+
+#define PySequence_Fast_ITEMS(sf) \
+	(PyList_Check(sf) ? ((PyListObject *)(sf))-&gt;ob_item \
+			  : ((PyTupleObject *)(sf))-&gt;ob_item)
+	/* Return a pointer to the underlying item array for
+           an object retured by PySequence_Fast */
+
+     PyAPI_FUNC(int) PySequence_Count(PyObject *o, PyObject *value);
+
+       /*
+         Return the number of occurrences on value on o, that is,
+	 return the number of keys for which o[key]==value.  On
+	 failure, return -1.  This is equivalent to the Python
+	 expression: o.count(value).
+       */
+
+     PyAPI_FUNC(int) PySequence_Contains(PyObject *seq, PyObject *ob);
+       /*
+         Return -1 if error; 1 if ob in seq; 0 if ob not in seq.
+         Use __contains__ if possible, else _PySequence_IterSearch().
+       */
+
+#define PY_ITERSEARCH_COUNT    1
+#define PY_ITERSEARCH_INDEX    2
+#define PY_ITERSEARCH_CONTAINS 3
+     PyAPI_FUNC(int) _PySequence_IterSearch(PyObject *seq, PyObject *obj,
+     		    int operation);
+	/*
+	  Iterate over seq.  Result depends on the operation:
+	  PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
+	  	error.
+	  PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
+	  	obj in seq; set ValueError and return -1 if none found;
+	  	also return -1 on error.
+	  PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
+	  	error.
+	*/
+
+/* For DLL-level backwards compatibility */
+#undef PySequence_In
+     PyAPI_FUNC(int) PySequence_In(PyObject *o, PyObject *value);
+
+/* For source-level backwards compatibility */
+#define PySequence_In PySequence_Contains
+
+       /*
+	 Determine if o contains value.  If an item in o is equal to
+	 X, return 1, otherwise return 0.  On error, return -1.  This
+	 is equivalent to the Python expression: value in o.
+       */
+
+     PyAPI_FUNC(int) PySequence_Index(PyObject *o, PyObject *value);
+
+       /*
+	 Return the first index for which o[i]=value.  On error,
+	 return -1.    This is equivalent to the Python
+	 expression: o.index(value).
+       */
+
+/* In-place versions of some of the above Sequence functions. */
+
+     PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
+
+       /*
+	 Append o2 to o1, in-place when possible. Return the resulting
+	 object, which could be o1, or NULL on failure.  This is the
+	 equivalent of the Python expression: o1 += o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, int count);
+
+       /*
+	 Repeat o1 by count, in-place when possible. Return the resulting
+	 object, which could be o1, or NULL on failure.  This is the
+	 equivalent of the Python expression: o1 *= count.
+
+       */
+
+/*  Mapping protocol:*/
+
+     PyAPI_FUNC(int) PyMapping_Check(PyObject *o);
+
+       /*
+         Return 1 if the object provides mapping protocol, and zero
+	 otherwise.  
+
+	 This function always succeeds.
+       */
+
+     PyAPI_FUNC(int) PyMapping_Size(PyObject *o);
+
+       /*
+         Returns the number of keys in object o on success, and -1 on
+	 failure.  For objects that do not provide sequence protocol,
+	 this is equivalent to the Python expression: len(o).
+       */
+
+       /* For DLL compatibility */
+#undef PyMapping_Length
+     PyAPI_FUNC(int) PyMapping_Length(PyObject *o);
+#define PyMapping_Length PyMapping_Size
+
+
+     /* implemented as a macro:
+
+     int PyMapping_DelItemString(PyObject *o, char *key);
+
+	 Remove the mapping for object, key, from the object *o.
+	 Returns -1 on failure.  This is equivalent to
+	 the Python statement: del o[key].
+       */
+#define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))
+
+     /* implemented as a macro:
+
+     int PyMapping_DelItem(PyObject *o, PyObject *key);
+
+	 Remove the mapping for object, key, from the object *o.
+	 Returns -1 on failure.  This is equivalent to
+	 the Python statement: del o[key].
+       */
+#define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))
+
+     PyAPI_FUNC(int) PyMapping_HasKeyString(PyObject *o, char *key);
+
+       /*
+	 On success, return 1 if the mapping object has the key, key,
+	 and 0 otherwise.  This is equivalent to the Python expression:
+	 o.has_key(key). 
+
+	 This function always succeeds.
+       */
+
+     PyAPI_FUNC(int) PyMapping_HasKey(PyObject *o, PyObject *key);
+
+       /*
+	 Return 1 if the mapping object has the key, key,
+	 and 0 otherwise.  This is equivalent to the Python expression:
+	 o.has_key(key). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Keys(PyObject *o);
+
+         On success, return a list of the keys in object o.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.keys().
+       */
+#define PyMapping_Keys(O) PyObject_CallMethod(O,&quot;keys&quot;,NULL)
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Values(PyObject *o);
+
+         On success, return a list of the values in object o.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.values().
+       */
+#define PyMapping_Values(O) PyObject_CallMethod(O,&quot;values&quot;,NULL)
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Items(PyObject *o);
+
+         On success, return a list of the items in object o, where
+	 each item is a tuple containing a key-value pair.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.items().
+
+       */
+#define PyMapping_Items(O) PyObject_CallMethod(O,&quot;items&quot;,NULL)
+
+     PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o, char *key);
+
+       /*
+	 Return element of o corresponding to the object, key, or NULL
+	 on failure. This is the equivalent of the Python expression:
+	 o[key].
+       */
+
+     PyAPI_FUNC(int) PyMapping_SetItemString(PyObject *o, char *key,
+                                            PyObject *value);
+
+       /*
+	 Map the object, key, to the value, v.  Returns 
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[key]=v.
+      */
+
+
+PyAPI_FUNC(int) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);
+      /* isinstance(object, typeorclass) */
+
+PyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
+      /* issubclass(object, typeorclass) */
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* Py_ABSTRACTOBJECT_H */

Added: trunk/mingw-libs/include/bitset.h
===================================================================
--- trunk/mingw-libs/include/bitset.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/bitset.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,32 @@
+
+#ifndef Py_BITSET_H
+#define Py_BITSET_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Bitset interface */
+
+#define BYTE		char
+
+typedef BYTE *bitset;
+
+bitset newbitset(int nbits);
+void delbitset(bitset bs);
+#define testbit(ss, ibit) (((ss)[BIT2BYTE(ibit)] &amp; BIT2MASK(ibit)) != 0)
+int addbit(bitset bs, int ibit); /* Returns 0 if already set */
+int samebitset(bitset bs1, bitset bs2, int nbits);
+void mergebitset(bitset bs1, bitset bs2, int nbits);
+
+#define BITSPERBYTE	(8*sizeof(BYTE))
+#define NBYTES(nbits)	(((nbits) + BITSPERBYTE - 1) / BITSPERBYTE)
+
+#define BIT2BYTE(ibit)	((ibit) / BITSPERBYTE)
+#define BIT2SHIFT(ibit)	((ibit) % BITSPERBYTE)
+#define BIT2MASK(ibit)	(1 &lt;&lt; BIT2SHIFT(ibit))
+#define BYTE2BIT(ibyte)	((ibyte) * BITSPERBYTE)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BITSET_H */

Added: trunk/mingw-libs/include/boolobject.h
===================================================================
--- trunk/mingw-libs/include/boolobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/boolobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,36 @@
+/* Boolean object interface */
+
+#ifndef Py_BOOLOBJECT_H
+#define Py_BOOLOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+typedef PyIntObject PyBoolObject;
+
+PyAPI_DATA(PyTypeObject) PyBool_Type;
+
+#define PyBool_Check(x) ((x)-&gt;ob_type == &amp;PyBool_Type)
+
+/* Py_False and Py_True are the only two bools in existence.
+Don't forget to apply Py_INCREF() when returning either!!! */
+
+/* Don't use these directly */
+PyAPI_DATA(PyIntObject) _Py_ZeroStruct, _Py_TrueStruct;
+
+/* Use these macros */
+#define Py_False ((PyObject *) &amp;_Py_ZeroStruct)
+#define Py_True ((PyObject *) &amp;_Py_TrueStruct)
+
+/* Macros for returning Py_True or Py_False, respectively */
+#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
+#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False
+
+/* Function to return a bool from a C long */
+PyAPI_FUNC(PyObject *) PyBool_FromLong(long);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BOOLOBJECT_H */

Added: trunk/mingw-libs/include/bufferobject.h
===================================================================
--- trunk/mingw-libs/include/bufferobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/bufferobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,33 @@
+
+/* Buffer object interface */
+
+/* Note: the object's structure is private */
+
+#ifndef Py_BUFFEROBJECT_H
+#define Py_BUFFEROBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+PyAPI_DATA(PyTypeObject) PyBuffer_Type;
+
+#define PyBuffer_Check(op) ((op)-&gt;ob_type == &amp;PyBuffer_Type)
+
+#define Py_END_OF_BUFFER	(-1)
+
+PyAPI_FUNC(PyObject *) PyBuffer_FromObject(PyObject *base,
+                                                 int offset, int size);
+PyAPI_FUNC(PyObject *) PyBuffer_FromReadWriteObject(PyObject *base,
+                                                          int offset,
+                                                          int size);
+
+PyAPI_FUNC(PyObject *) PyBuffer_FromMemory(void *ptr, int size);
+PyAPI_FUNC(PyObject *) PyBuffer_FromReadWriteMemory(void *ptr, int size);
+
+PyAPI_FUNC(PyObject *) PyBuffer_New(int size);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BUFFEROBJECT_H */

Added: trunk/mingw-libs/include/cStringIO.h
===================================================================
--- trunk/mingw-libs/include/cStringIO.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/cStringIO.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,70 @@
+#ifndef Py_CSTRINGIO_H
+#define Py_CSTRINGIO_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+/*
+
+  This header provides access to cStringIO objects from C.
+  Functions are provided for calling cStringIO objects and
+  macros are provided for testing whether you have cStringIO 
+  objects.
+
+  Before calling any of the functions or macros, you must initialize
+  the routines with:
+
+    PycString_IMPORT
+
+  This would typically be done in your init function.
+
+*/
+#define PycString_IMPORT \
+  PycStringIO = (struct PycStringIO_CAPI*)PyCObject_Import(&quot;cStringIO&quot;, \
+                                                           &quot;cStringIO_CAPI&quot;)
+
+/* Basic functions to manipulate cStringIO objects from C */
+
+static struct PycStringIO_CAPI {
+  
+ /* Read a string from an input object.  If the last argument
+    is -1, the remainder will be read.
+    */
+  int(*cread)(PyObject *, char **, int);
+
+ /* Read a line from an input object.  Returns the length of the read
+    line as an int and a pointer inside the object buffer as char** (so
+    the caller doesn't have to provide its own buffer as destination).
+    */
+  int(*creadline)(PyObject *, char **);
+
+  /* Write a string to an output object*/
+  int(*cwrite)(PyObject *, char *, int);
+
+  /* Get the output object as a Python string (returns new reference). */
+  PyObject *(*cgetvalue)(PyObject *);
+
+  /* Create a new output object */
+  PyObject *(*NewOutput)(int);
+
+  /* Create an input object from a Python string
+     (copies the Python string reference).
+     */
+  PyObject *(*NewInput)(PyObject *);
+
+  /* The Python types for cStringIO input and output objects.
+     Note that you can do input on an output object.
+     */
+  PyTypeObject *InputType, *OutputType;
+
+} *PycStringIO;
+
+/* These can be used to test if you have one */
+#define PycStringIO_InputCheck(O) \
+  ((O)-&gt;ob_type==PycStringIO-&gt;InputType)
+#define PycStringIO_OutputCheck(O) \
+  ((O)-&gt;ob_type==PycStringIO-&gt;OutputType)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CSTRINGIO_H */

Added: trunk/mingw-libs/include/cellobject.h
===================================================================
--- trunk/mingw-libs/include/cellobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/cellobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,28 @@
+/* Cell object interface */
+
+#ifndef Py_CELLOBJECT_H
+#define Py_CELLOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *ob_ref;	/* Content of the cell or NULL when empty */
+} PyCellObject;
+
+PyAPI_DATA(PyTypeObject) PyCell_Type;
+
+#define PyCell_Check(op) ((op)-&gt;ob_type == &amp;PyCell_Type)
+
+PyAPI_FUNC(PyObject *) PyCell_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyCell_Get(PyObject *);
+PyAPI_FUNC(int) PyCell_Set(PyObject *, PyObject *);
+
+#define PyCell_GET(op) (((PyCellObject *)(op))-&gt;ob_ref)
+#define PyCell_SET(op, v) (((PyCellObject *)(op))-&gt;ob_ref = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TUPLEOBJECT_H */

Added: trunk/mingw-libs/include/ceval.h
===================================================================
--- trunk/mingw-libs/include/ceval.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/ceval.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,154 @@
+#ifndef Py_CEVAL_H
+#define Py_CEVAL_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Interface to random parts in ceval.c */
+
+PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
+	PyObject *, PyObject *, PyObject *);
+
+/* DLL-level Backwards compatibility: */
+#undef PyEval_CallObject
+PyAPI_FUNC(PyObject *) PyEval_CallObject(PyObject *, PyObject *);
+
+/* Inline this */
+#define PyEval_CallObject(func,arg) \
+        PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)
+
+PyAPI_FUNC(PyObject *) PyEval_CallFunction(PyObject *obj, char *format, ...);
+PyAPI_FUNC(PyObject *) PyEval_CallMethod(PyObject *obj,
+                                        char *methodname, char *format, ...);
+
+PyAPI_FUNC(void) PyEval_SetProfile(Py_tracefunc, PyObject *);
+PyAPI_FUNC(void) PyEval_SetTrace(Py_tracefunc, PyObject *);
+
+struct _frame; /* Avoid including frameobject.h */
+
+PyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);
+PyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);
+PyAPI_FUNC(PyObject *) PyEval_GetLocals(void);
+PyAPI_FUNC(struct _frame *) PyEval_GetFrame(void);
+PyAPI_FUNC(int) PyEval_GetRestricted(void);
+
+/* Look at the current frame's (if any) code's co_flags, and turn on
+   the corresponding compiler flags in cf-&gt;cf_flags.  Return 1 if any
+   flag was set, else return 0. */
+PyAPI_FUNC(int) PyEval_MergeCompilerFlags(PyCompilerFlags *cf);
+
+PyAPI_FUNC(int) Py_FlushLine(void);
+
+PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
+PyAPI_FUNC(int) Py_MakePendingCalls(void);
+
+/* Protection against deeply nested recursive calls */
+PyAPI_FUNC(void) Py_SetRecursionLimit(int);
+PyAPI_FUNC(int) Py_GetRecursionLimit(void);
+
+#define Py_EnterRecursiveCall(where)                                    \
+	    (_Py_MakeRecCheck(PyThreadState_GET()-&gt;recursion_depth) &amp;&amp;  \
+	     _Py_CheckRecursiveCall(where))
+#define Py_LeaveRecursiveCall()				\
+	    (--PyThreadState_GET()-&gt;recursion_depth)
+PyAPI_FUNC(int) _Py_CheckRecursiveCall(char *where);
+PyAPI_DATA(int) _Py_CheckRecursionLimit;
+#ifdef USE_STACKCHECK
+#  define _Py_MakeRecCheck(x)  (++(x) &gt; --_Py_CheckRecursionLimit)
+#else
+#  define _Py_MakeRecCheck(x)  (++(x) &gt; _Py_CheckRecursionLimit)
+#endif
+
+PyAPI_FUNC(char *) PyEval_GetFuncName(PyObject *);
+PyAPI_FUNC(char *) PyEval_GetFuncDesc(PyObject *);
+
+PyAPI_FUNC(PyObject *) PyEval_GetCallStats(PyObject *);
+PyAPI_FUNC(PyObject *) PyEval_EvalFrame(struct _frame *);
+
+/* this used to be handled on a per-thread basis - now just two globals */
+PyAPI_DATA(volatile int) _Py_Ticker;
+PyAPI_DATA(int) _Py_CheckInterval;
+
+/* Interface for threads.
+
+   A module that plans to do a blocking system call (or something else
+   that lasts a long time and doesn't touch Python data) can allow other
+   threads to run as follows:
+
+	...preparations here...
+	Py_BEGIN_ALLOW_THREADS
+	...blocking system call here...
+	Py_END_ALLOW_THREADS
+	...interpret result here...
+
+   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
+   {}-surrounded block.
+   To leave the block in the middle (e.g., with return), you must insert
+   a line containing Py_BLOCK_THREADS before the return, e.g.
+
+	if (...premature_exit...) {
+		Py_BLOCK_THREADS
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+
+   An alternative is:
+
+	Py_BLOCK_THREADS
+	if (...premature_exit...) {
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+	Py_UNBLOCK_THREADS
+
+   For convenience, that the value of 'errno' is restored across
+   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.
+
+   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
+   Py_END_ALLOW_THREADS!!!
+
+   The function PyEval_InitThreads() should be called only from
+   initthread() in &quot;threadmodule.c&quot;.
+
+   Note that not yet all candidates have been converted to use this
+   mechanism!
+*/
+
+PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
+PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
+
+#ifdef WITH_THREAD
+
+PyAPI_FUNC(int)  PyEval_ThreadsInitialized(void);
+PyAPI_FUNC(void) PyEval_InitThreads(void);
+PyAPI_FUNC(void) PyEval_AcquireLock(void);
+PyAPI_FUNC(void) PyEval_ReleaseLock(void);
+PyAPI_FUNC(void) PyEval_AcquireThread(PyThreadState *tstate);
+PyAPI_FUNC(void) PyEval_ReleaseThread(PyThreadState *tstate);
+PyAPI_FUNC(void) PyEval_ReInitThreads(void);
+
+#define Py_BEGIN_ALLOW_THREADS { \
+			PyThreadState *_save; \
+			_save = PyEval_SaveThread();
+#define Py_BLOCK_THREADS	PyEval_RestoreThread(_save);
+#define Py_UNBLOCK_THREADS	_save = PyEval_SaveThread();
+#define Py_END_ALLOW_THREADS	PyEval_RestoreThread(_save); \
+		 }
+
+#else /* !WITH_THREAD */
+
+#define Py_BEGIN_ALLOW_THREADS {
+#define Py_BLOCK_THREADS
+#define Py_UNBLOCK_THREADS
+#define Py_END_ALLOW_THREADS }
+
+#endif /* !WITH_THREAD */
+
+PyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, int *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CEVAL_H */

Added: trunk/mingw-libs/include/classobject.h
===================================================================
--- trunk/mingw-libs/include/classobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/classobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,81 @@
+
+/* Class object interface */
+
+/* Revealing some structures (not for general use) */
+
+#ifndef Py_CLASSOBJECT_H
+#define Py_CLASSOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    PyObject	*cl_bases;	/* A tuple of class objects */
+    PyObject	*cl_dict;	/* A dictionary */
+    PyObject	*cl_name;	/* A string */
+    /* The following three are functions or NULL */
+    PyObject	*cl_getattr;
+    PyObject	*cl_setattr;
+    PyObject	*cl_delattr;
+} PyClassObject;
+
+typedef struct {
+    PyObject_HEAD
+    PyClassObject *in_class;	/* The class object */
+    PyObject	  *in_dict;	/* A dictionary */
+    PyObject	  *in_weakreflist; /* List of weak references */
+} PyInstanceObject;
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *im_func;   /* The callable object implementing the method */
+    PyObject *im_self;   /* The instance it is bound to, or NULL */
+    PyObject *im_class;  /* The class that asked for the method */
+    PyObject *im_weakreflist; /* List of weak references */
+} PyMethodObject;
+
+PyAPI_DATA(PyTypeObject) PyClass_Type, PyInstance_Type, PyMethod_Type;
+
+#define PyClass_Check(op) ((op)-&gt;ob_type == &amp;PyClass_Type)
+#define PyInstance_Check(op) ((op)-&gt;ob_type == &amp;PyInstance_Type)
+#define PyMethod_Check(op) ((op)-&gt;ob_type == &amp;PyMethod_Type)
+
+PyAPI_FUNC(PyObject *) PyClass_New(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyInstance_New(PyObject *, PyObject *,
+                                            PyObject *);
+PyAPI_FUNC(PyObject *) PyInstance_NewRaw(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_New(PyObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(PyObject *) PyMethod_Function(PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_Self(PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_Class(PyObject *);
+
+/* Look up attribute with name (a string) on instance object pinst, using
+ * only the instance and base class dicts.  If a descriptor is found in
+ * a class dict, the descriptor is returned without calling it.
+ * Returns NULL if nothing found, else a borrowed reference to the
+ * value associated with name in the dict in which name was found.
+ * The point of this routine is that it never calls arbitrary Python
+ * code, so is always &quot;safe&quot;:  all it does is dict lookups.  The function
+ * can't fail, never sets an exception, and NULL is not an error (it just
+ * means &quot;not found&quot;).
+ */
+PyAPI_FUNC(PyObject *) _PyInstance_Lookup(PyObject *pinst, PyObject *name);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyMethod_GET_FUNCTION(meth) \
+        (((PyMethodObject *)meth) -&gt; im_func)
+#define PyMethod_GET_SELF(meth) \
+	(((PyMethodObject *)meth) -&gt; im_self)
+#define PyMethod_GET_CLASS(meth) \
+	(((PyMethodObject *)meth) -&gt; im_class)
+
+PyAPI_FUNC(int) PyClass_IsSubclass(PyObject *, PyObject *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CLASSOBJECT_H */

Added: trunk/mingw-libs/include/cobject.h
===================================================================
--- trunk/mingw-libs/include/cobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/cobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,54 @@
+
+/* C objects to be exported from one extension module to another.
+ 
+   C objects are used for communication between extension modules.
+   They provide a way for an extension module to export a C interface
+   to other extension modules, so that extension modules can use the
+   Python import mechanism to link to one another.
+
+*/
+
+#ifndef Py_COBJECT_H
+#define Py_COBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyCObject_Type;
+
+#define PyCObject_Check(op) ((op)-&gt;ob_type == &amp;PyCObject_Type)
+
+/* Create a PyCObject from a pointer to a C object and an optional
+   destructor function.  If the second argument is non-null, then it
+   will be called with the first argument if and when the PyCObject is
+   destroyed.
+
+*/
+PyAPI_FUNC(PyObject *) PyCObject_FromVoidPtr(
+	void *cobj, void (*destruct)(void*));
+
+
+/* Create a PyCObject from a pointer to a C object, a description object,
+   and an optional destructor function.  If the third argument is non-null,
+   then it will be called with the first and second arguments if and when 
+   the PyCObject is destroyed.
+*/
+PyAPI_FUNC(PyObject *) PyCObject_FromVoidPtrAndDesc(
+	void *cobj, void *desc, void (*destruct)(void*,void*));
+
+/* Retrieve a pointer to a C object from a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_AsVoidPtr(PyObject *);
+
+/* Retrieve a pointer to a description object from a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_GetDesc(PyObject *);
+
+/* Import a pointer to a C object from a module using a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_Import(char *module_name, char *cobject_name);
+
+/* Modify a C object. Fails (==0) if object has a destructor. */
+PyAPI_FUNC(int) PyCObject_SetVoidPtr(PyObject *self, void *cobj);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COBJECT_H */

Added: trunk/mingw-libs/include/codecs.h
===================================================================
--- trunk/mingw-libs/include/codecs.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/codecs.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,153 @@
+#ifndef Py_CODECREGISTRY_H
+#define Py_CODECREGISTRY_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* ------------------------------------------------------------------------
+
+   Python Codec Registry and support functions
+
+
+Written by Marc-Andre Lemburg (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">mal at lemburg.com</A>).
+
+Copyright (c) Corporation for National Research Initiatives.
+
+   ------------------------------------------------------------------------ */
+
+/* Register a new codec search function.
+
+   As side effect, this tries to load the encodings package, if not
+   yet done, to make sure that it is always first in the list of
+   search functions.
+
+   The search_function's refcount is incremented by this function. */
+
+PyAPI_FUNC(int) PyCodec_Register(
+       PyObject *search_function
+       );
+
+/* Codec register lookup API.
+
+   Looks up the given encoding and returns a tuple (encoder, decoder,
+   stream reader, stream writer) of functions which implement the
+   different aspects of processing the encoding.
+
+   The encoding string is looked up converted to all lower-case
+   characters. This makes encodings looked up through this mechanism
+   effectively case-insensitive.
+
+   If no codec is found, a KeyError is set and NULL returned. 
+
+   As side effect, this tries to load the encodings package, if not
+   yet done. This is part of the lazy load strategy for the encodings
+   package.
+
+ */
+
+PyAPI_FUNC(PyObject *) _PyCodec_Lookup(
+       const char *encoding
+       );
+
+/* Generic codec based encoding API.
+
+   object is passed through the encoder function found for the given
+   encoding using the error handling method defined by errors. errors
+   may be NULL to use the default method defined for the codec.
+   
+   Raises a LookupError in case no encoder can be found.
+
+ */
+
+PyAPI_FUNC(PyObject *) PyCodec_Encode(
+       PyObject *object,
+       const char *encoding,
+       const char *errors
+       );
+
+/* Generic codec based decoding API.
+
+   object is passed through the decoder function found for the given
+   encoding using the error handling method defined by errors. errors
+   may be NULL to use the default method defined for the codec.
+   
+   Raises a LookupError in case no encoder can be found.
+
+ */
+
+PyAPI_FUNC(PyObject *) PyCodec_Decode(
+       PyObject *object,
+       const char *encoding,
+       const char *errors
+       );
+
+/* --- Codec Lookup APIs -------------------------------------------------- 
+
+   All APIs return a codec object with incremented refcount and are
+   based on _PyCodec_Lookup().  The same comments w/r to the encoding
+   name also apply to these APIs.
+
+*/
+
+/* Get an encoder function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_Encoder(
+       const char *encoding
+       );
+
+/* Get a decoder function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_Decoder(
+       const char *encoding
+       );
+
+/* Get a StreamReader factory function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_StreamReader(
+       const char *encoding,
+       PyObject *stream,
+       const char *errors
+       );
+
+/* Get a StreamWriter factory function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_StreamWriter(
+       const char *encoding,
+       PyObject *stream,
+       const char *errors
+       );
+
+/* Unicode encoding error handling callback registry API */
+
+/* Register the error handling callback function error under the name
+   name. This function will be called by the codec when it encounters
+   unencodable characters/undecodable bytes and doesn't know the
+   callback name, when name is specified as the error parameter
+   in the call to the encode/decode function.
+   Return 0 on success, -1 on error */
+PyAPI_FUNC(int) PyCodec_RegisterError(const char *name, PyObject *error);
+
+/* Lookup the error handling callback function registered under the
+   name error. As a special case NULL can be passed, in which case
+   the error handling callback for &quot;strict&quot; will be returned. */
+PyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);
+
+/* raise exc as an exception */
+PyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);
+
+/* ignore the unicode error, skipping the faulty input */
+PyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);
+
+/* replace the unicode error with ? or U+FFFD */
+PyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);
+
+/* replace the unicode encode error with XML character references */
+PyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
+
+/* replace the unicode encode error with backslash escapes (\x, \u and \U) */
+PyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CODECREGISTRY_H */

Added: trunk/mingw-libs/include/compile.h
===================================================================
--- trunk/mingw-libs/include/compile.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/compile.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,87 @@
+
+/* Definitions for bytecode */
+
+#ifndef Py_COMPILE_H
+#define Py_COMPILE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Bytecode object */
+typedef struct {
+    PyObject_HEAD
+    int co_argcount;		/* #arguments, except *args */
+    int co_nlocals;		/* #local variables */
+    int co_stacksize;		/* #entries needed for evaluation stack */
+    int co_flags;		/* CO_..., see below */
+    PyObject *co_code;		/* instruction opcodes */
+    PyObject *co_consts;	/* list (constants used) */
+    PyObject *co_names;		/* list of strings (names used) */
+    PyObject *co_varnames;	/* tuple of strings (local variable names) */
+    PyObject *co_freevars;	/* tuple of strings (free variable names) */
+    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
+    /* The rest doesn't count for hash/cmp */
+    PyObject *co_filename;	/* string (where it was loaded from) */
+    PyObject *co_name;		/* string (name, for reference) */
+    int co_firstlineno;		/* first source line number */
+    PyObject *co_lnotab;	/* string (encoding addr&lt;-&gt;lineno mapping) */
+} PyCodeObject;
+
+/* Masks for co_flags above */
+#define CO_OPTIMIZED	0x0001
+#define CO_NEWLOCALS	0x0002
+#define CO_VARARGS	0x0004
+#define CO_VARKEYWORDS	0x0008
+#define CO_NESTED       0x0010
+#define CO_GENERATOR    0x0020
+/* The CO_NOFREE flag is set if there are no free or cell variables.
+   This information is redundant, but it allows a single flag test
+   to determine whether there is any extra work to be done when the
+   call frame it setup.
+*/
+#define CO_NOFREE       0x0040
+/* XXX Temporary hack.  Until generators are a permanent part of the
+   language, we need a way for a code object to record that generators
+   were *possible* when it was compiled.  This is so code dynamically
+   compiled *by* a code object knows whether to allow yield stmts.  In
+   effect, this passes on the &quot;from __future__ import generators&quot; state
+   in effect when the code block was compiled. */
+#define CO_GENERATOR_ALLOWED    0x1000 /* no longer used in an essential way */
+#define CO_FUTURE_DIVISION    	0x2000
+
+PyAPI_DATA(PyTypeObject) PyCode_Type;
+
+#define PyCode_Check(op) ((op)-&gt;ob_type == &amp;PyCode_Type)
+#define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)-&gt;co_freevars))
+
+#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */
+
+/* Public interface */
+struct _node; /* Declare the existence of this type */
+PyAPI_FUNC(PyCodeObject *) PyNode_Compile(struct _node *, const char *);
+PyAPI_FUNC(PyCodeObject *) PyCode_New(
+	int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
+	PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *); 
+        /* same as struct above */
+PyAPI_FUNC(int) PyCode_Addr2Line(PyCodeObject *, int);
+
+/* Future feature support */
+
+typedef struct {
+    int ff_found_docstring;
+    int ff_last_lineno;
+    int ff_features;
+} PyFutureFeatures;
+
+PyAPI_FUNC(PyFutureFeatures *) PyNode_Future(struct _node *, const char *);
+PyAPI_FUNC(PyCodeObject *) PyNode_CompileFlags(struct _node *, const char *,
+					      PyCompilerFlags *);
+
+#define FUTURE_NESTED_SCOPES &quot;nested_scopes&quot;
+#define FUTURE_GENERATORS &quot;generators&quot;
+#define FUTURE_DIVISION &quot;division&quot;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COMPILE_H */

Added: trunk/mingw-libs/include/complexobject.h
===================================================================
--- trunk/mingw-libs/include/complexobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/complexobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,58 @@
+/* Complex number structure */
+
+#ifndef Py_COMPLEXOBJECT_H
+#define Py_COMPLEXOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    double real;
+    double imag;
+} Py_complex;
+
+/* Operations on complex numbers from complexmodule.c */
+
+#define c_sum _Py_c_sum
+#define c_diff _Py_c_diff
+#define c_neg _Py_c_neg
+#define c_prod _Py_c_prod
+#define c_quot _Py_c_quot
+#define c_pow _Py_c_pow
+
+PyAPI_FUNC(Py_complex) c_sum(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_diff(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_neg(Py_complex);
+PyAPI_FUNC(Py_complex) c_prod(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_quot(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_pow(Py_complex, Py_complex);
+
+
+/* Complex object interface */
+
+/*
+PyComplexObject represents a complex number with double-precision
+real and imaginary parts.
+*/
+
+typedef struct {
+    PyObject_HEAD
+    Py_complex cval;
+} PyComplexObject;     
+
+PyAPI_DATA(PyTypeObject) PyComplex_Type;
+
+#define PyComplex_Check(op) PyObject_TypeCheck(op, &amp;PyComplex_Type)
+#define PyComplex_CheckExact(op) ((op)-&gt;ob_type == &amp;PyComplex_Type)
+
+PyAPI_FUNC(PyObject *) PyComplex_FromCComplex(Py_complex);
+PyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);
+
+PyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);
+PyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);
+PyAPI_FUNC(Py_complex) PyComplex_AsCComplex(PyObject *op);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COMPLEXOBJECT_H */

Added: trunk/mingw-libs/include/datetime.h
===================================================================
--- trunk/mingw-libs/include/datetime.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/datetime.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,245 @@
+/*  datetime.h
+ */
+
+#ifndef DATETIME_H
+#define DATETIME_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Fields are packed into successive bytes, each viewed as unsigned and
+ * big-endian, unless otherwise noted:
+ *
+ * byte offset
+ *  0 		year     2 bytes, 1-9999
+ *  2		month    1 byte, 1-12
+ *  3 		day      1 byte, 1-31
+ *  4		hour     1 byte, 0-23
+ *  5 		minute   1 byte, 0-59
+ *  6 		second   1 byte, 0-59
+ *  7 		usecond  3 bytes, 0-999999
+ * 10
+ */
+
+/* # of bytes for year, month, and day. */
+#define _PyDateTime_DATE_DATASIZE 4
+
+/* # of bytes for hour, minute, second, and usecond. */
+#define _PyDateTime_TIME_DATASIZE 6
+
+/* # of bytes for year, month, day, hour, minute, second, and usecond. */
+#define _PyDateTime_DATETIME_DATASIZE 10
+
+
+typedef struct
+{
+	PyObject_HEAD
+	long hashcode;		/* -1 when unknown */
+	int days;		/* -MAX_DELTA_DAYS &lt;= days &lt;= MAX_DELTA_DAYS */
+	int seconds;		/* 0 &lt;= seconds &lt; 24*3600 is invariant */
+	int microseconds;	/* 0 &lt;= microseconds &lt; 1000000 is invariant */
+} PyDateTime_Delta;
+
+typedef struct
+{
+	PyObject_HEAD		/* a pure abstract base clase */
+} PyDateTime_TZInfo;
+
+
+/* The datetime and time types have hashcodes, and an optional tzinfo member,
+ * present if and only if hastzinfo is true.
+ */
+#define _PyTZINFO_HEAD		\
+	PyObject_HEAD		\
+	long hashcode;		\
+	char hastzinfo;		/* boolean flag */
+
+/* No _PyDateTime_BaseTZInfo is allocated; it's just to have something
+ * convenient to cast to, when getting at the hastzinfo member of objects
+ * starting with _PyTZINFO_HEAD.
+ */
+typedef struct
+{
+	_PyTZINFO_HEAD
+} _PyDateTime_BaseTZInfo;
+
+/* All time objects are of PyDateTime_TimeType, but that can be allocated
+ * in two ways, with or without a tzinfo member.  Without is the same as
+ * tzinfo == None, but consumes less memory.  _PyDateTime_BaseTime is an
+ * internal struct used to allocate the right amount of space for the
+ * &quot;without&quot; case.
+ */
+#define _PyDateTime_TIMEHEAD	\
+	_PyTZINFO_HEAD		\
+	unsigned char data[_PyDateTime_TIME_DATASIZE];
+
+typedef struct
+{
+	_PyDateTime_TIMEHEAD
+} _PyDateTime_BaseTime;		/* hastzinfo false */
+
+typedef struct
+{
+	_PyDateTime_TIMEHEAD
+	PyObject *tzinfo;
+} PyDateTime_Time;		/* hastzinfo true */
+
+
+/* All datetime objects are of PyDateTime_DateTimeType, but that can be
+ * allocated in two ways too, just like for time objects above.  In addition,
+ * the plain date type is a base class for datetime, so it must also have
+ * a hastzinfo member (although it's unused there).
+ */
+typedef struct
+{
+	_PyTZINFO_HEAD
+	unsigned char data[_PyDateTime_DATE_DATASIZE];
+} PyDateTime_Date;
+
+#define _PyDateTime_DATETIMEHEAD	\
+	_PyTZINFO_HEAD			\
+	unsigned char data[_PyDateTime_DATETIME_DATASIZE];
+
+typedef struct
+{
+	_PyDateTime_DATETIMEHEAD
+} _PyDateTime_BaseDateTime;	/* hastzinfo false */
+
+typedef struct
+{
+	_PyDateTime_DATETIMEHEAD
+	PyObject *tzinfo;
+} PyDateTime_DateTime;		/* hastzinfo true */
+
+
+/* Apply for date and datetime instances. */
+#define PyDateTime_GET_YEAR(o)     ((((PyDateTime_Date*)o)-&gt;data[0] &lt;&lt; 8) | \
+                                     ((PyDateTime_Date*)o)-&gt;data[1])
+#define PyDateTime_GET_MONTH(o)    (((PyDateTime_Date*)o)-&gt;data[2])
+#define PyDateTime_GET_DAY(o)      (((PyDateTime_Date*)o)-&gt;data[3])
+
+#define PyDateTime_DATE_GET_HOUR(o)        (((PyDateTime_DateTime*)o)-&gt;data[4])
+#define PyDateTime_DATE_GET_MINUTE(o)      (((PyDateTime_DateTime*)o)-&gt;data[5])
+#define PyDateTime_DATE_GET_SECOND(o)      (((PyDateTime_DateTime*)o)-&gt;data[6])
+#define PyDateTime_DATE_GET_MICROSECOND(o) 		\
+	((((PyDateTime_DateTime*)o)-&gt;data[7] &lt;&lt; 16) |	\
+         (((PyDateTime_DateTime*)o)-&gt;data[8] &lt;&lt; 8)  |	\
+          ((PyDateTime_DateTime*)o)-&gt;data[9])
+
+/* Apply for time instances. */
+#define PyDateTime_TIME_GET_HOUR(o)        (((PyDateTime_Time*)o)-&gt;data[0])
+#define PyDateTime_TIME_GET_MINUTE(o)      (((PyDateTime_Time*)o)-&gt;data[1])
+#define PyDateTime_TIME_GET_SECOND(o)      (((PyDateTime_Time*)o)-&gt;data[2])
+#define PyDateTime_TIME_GET_MICROSECOND(o) 		\
+	((((PyDateTime_Time*)o)-&gt;data[3] &lt;&lt; 16) |	\
+         (((PyDateTime_Time*)o)-&gt;data[4] &lt;&lt; 8)  |	\
+          ((PyDateTime_Time*)o)-&gt;data[5])
+
+
+/* Define structure for C API. */
+typedef struct {
+    /* type objects */
+    PyTypeObject *DateType;
+    PyTypeObject *DateTimeType;
+    PyTypeObject *TimeType;
+    PyTypeObject *DeltaType;
+    PyTypeObject *TZInfoType;
+
+    /* constructors */
+    PyObject *(*Date_FromDate)(int, int, int, PyTypeObject*);
+    PyObject *(*DateTime_FromDateAndTime)(int, int, int, int, int, int, int,
+            PyObject*, PyTypeObject*);
+    PyObject *(*Time_FromTime)(int, int, int, int, PyObject*, PyTypeObject*);
+    PyObject *(*Delta_FromDelta)(int, int, int, int, PyTypeObject*);
+
+    /* constructors for the DB API */
+    PyObject *(*DateTime_FromTimestamp)(PyObject*, PyObject*, PyObject*);
+    PyObject *(*Date_FromTimestamp)(PyObject*, PyObject*);
+
+} PyDateTime_CAPI;
+
+
+/* &quot;magic&quot; constant used to partially protect against developer mistakes. */
+#define DATETIME_API_MAGIC 0x414548d5
+
+#ifdef Py_BUILD_CORE
+
+/* Macros for type checking when building the Python core. */
+#define PyDate_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_DateType)
+#define PyDate_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_DateType)
+
+#define PyDateTime_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_DateTimeType)
+#define PyDateTime_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_DateTimeType)
+
+#define PyTime_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_TimeType)
+#define PyTime_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_TimeType)
+
+#define PyDelta_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_DeltaType)
+#define PyDelta_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_DeltaType)
+
+#define PyTZInfo_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_TZInfoType)
+#define PyTZInfo_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_TZInfoType)
+
+#else
+
+/* Define global variable for the C API and a macro for setting it. */
+static PyDateTime_CAPI *PyDateTimeAPI;
+
+#define PyDateTime_IMPORT \
+        PyDateTimeAPI = (PyDateTime_CAPI*) PyCObject_Import(&quot;datetime&quot;, \
+                                                            &quot;datetime_CAPI&quot;)
+
+/* This macro would be used if PyCObject_ImportEx() was created.
+#define PyDateTime_IMPORT \
+        PyDateTimeAPI = (PyDateTime_CAPI*) PyCObject_ImportEx(&quot;datetime&quot;, \
+                                                            &quot;datetime_CAPI&quot;, \
+                                                            DATETIME_API_MAGIC)
+*/
+
+/* Macros for type checking when not building the Python core. */
+#define PyDate_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;DateType)
+#define PyDate_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;DateType)
+
+#define PyDateTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;DateTimeType)
+#define PyDateTime_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;DateTimeType)
+
+#define PyTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;TimeType)
+#define PyTime_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;TimeType)
+
+#define PyDelta_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;DeltaType)
+#define PyDelta_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;DeltaType)
+
+#define PyTZInfo_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;TZInfoType)
+#define PyTZInfo_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;TZInfoType)
+
+/* Macros for accessing constructors in a simplified fashion. */
+#define PyDate_FromDate(year, month, day) \
+	PyDateTimeAPI-&gt;Date_FromDate(year, month, day, PyDateTimeAPI-&gt;DateType)
+
+#define PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, usec) \
+	PyDateTimeAPI-&gt;DateTime_FromDateAndTime(year, month, day, hour, \
+		min, sec, usec, Py_None, PyDateTimeAPI-&gt;DateTimeType)
+
+#define PyTime_FromTime(hour, minute, second, usecond) \
+	PyDateTimeAPI-&gt;Time_FromTime(hour, minute, second, usecond, \
+		Py_None, PyDateTimeAPI-&gt;TimeType)
+
+#define PyDelta_FromDSU(days, seconds, useconds) \
+	PyDateTimeAPI-&gt;Delta_FromDelta(days, seconds, useconds, 1, \
+		PyDateTimeAPI-&gt;DeltaType)
+
+/* Macros supporting the DB API. */
+#define PyDateTime_FromTimestamp(args) \
+	PyDateTimeAPI-&gt;DateTime_FromTimestamp( \
+		(PyObject*) (PyDateTimeAPI-&gt;DateTimeType), args, NULL)
+
+#define PyDate_FromTimestamp(args) \
+	PyDateTimeAPI-&gt;Date_FromTimestamp( \
+		(PyObject*) (PyDateTimeAPI-&gt;DateType), args)
+
+#endif	/* Py_BUILD_CORE */
+
+#ifdef __cplusplus
+}
+#endif
+#endif

Added: trunk/mingw-libs/include/descrobject.h
===================================================================
--- trunk/mingw-libs/include/descrobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/descrobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,91 @@
+/* Descriptors */
+#ifndef Py_DESCROBJECT_H
+#define Py_DESCROBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef PyObject *(*getter)(PyObject *, void *);
+typedef int (*setter)(PyObject *, PyObject *, void *);
+
+typedef struct PyGetSetDef {
+	char *name;
+	getter get;
+	setter set;
+	char *doc;
+	void *closure;
+} PyGetSetDef;
+
+typedef PyObject *(*wrapperfunc)(PyObject *self, PyObject *args,
+				 void *wrapped);
+
+typedef PyObject *(*wrapperfunc_kwds)(PyObject *self, PyObject *args,
+				      void *wrapped, PyObject *kwds);
+
+struct wrapperbase {
+	char *name;
+	int offset;
+	void *function;
+	wrapperfunc wrapper;
+	char *doc;
+	int flags;
+	PyObject *name_strobj;
+};
+
+/* Flags for above struct */
+#define PyWrapperFlag_KEYWORDS 1 /* wrapper function takes keyword args */
+
+/* Various kinds of descriptor objects */
+
+#define PyDescr_COMMON \
+	PyObject_HEAD \
+	PyTypeObject *d_type; \
+	PyObject *d_name
+
+typedef struct {
+	PyDescr_COMMON;
+} PyDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	PyMethodDef *d_method;
+} PyMethodDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	struct PyMemberDef *d_member;
+} PyMemberDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	PyGetSetDef *d_getset;
+} PyGetSetDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	struct wrapperbase *d_base;
+	void *d_wrapped; /* This can be any function pointer */
+} PyWrapperDescrObject;
+
+PyAPI_DATA(PyTypeObject) PyWrapperDescr_Type;
+
+PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *,
+					       struct PyMemberDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *,
+					       struct PyGetSetDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,
+						struct wrapperbase *, void *);
+#define PyDescr_IsData(d) ((d)-&gt;ob_type-&gt;tp_descr_set != NULL)
+
+PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);
+
+
+PyAPI_DATA(PyTypeObject) PyProperty_Type;
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_DESCROBJECT_H */
+

Added: trunk/mingw-libs/include/dictobject.h
===================================================================
--- trunk/mingw-libs/include/dictobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/dictobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,134 @@
+#ifndef Py_DICTOBJECT_H
+#define Py_DICTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Dictionary object type -- mapping from hashable object to object */
+
+/* The distribution includes a separate file, Objects/dictnotes.txt,
+   describing explorations into dictionary design and optimization.  
+   It covers typical dictionary use patterns, the parameters for
+   tuning dictionaries, and several ideas for possible optimizations.
+*/
+
+/*
+There are three kinds of slots in the table:
+
+1. Unused.  me_key == me_value == NULL
+   Does not hold an active (key, value) pair now and never did.  Unused can
+   transition to Active upon key insertion.  This is the only case in which
+   me_key is NULL, and is each slot's initial state.
+
+2. Active.  me_key != NULL and me_key != dummy and me_value != NULL
+   Holds an active (key, value) pair.  Active can transition to Dummy upon
+   key deletion.  This is the only case in which me_value != NULL.
+
+3. Dummy.  me_key == dummy and me_value == NULL
+   Previously held an active (key, value) pair, but that was deleted and an
+   active pair has not yet overwritten the slot.  Dummy can transition to
+   Active upon key insertion.  Dummy slots cannot be made Unused again
+   (cannot have me_key set to NULL), else the probe sequence in case of
+   collision would have no way to know they were once active.
+
+Note: .popitem() abuses the me_hash field of an Unused or Dummy slot to
+hold a search finger.  The me_hash field of Unused or Dummy slots has no
+meaning otherwise.
+*/
+
+/* PyDict_MINSIZE is the minimum size of a dictionary.  This many slots are
+ * allocated directly in the dict object (in the ma_smalltable member).
+ * It must be a power of 2, and at least 4.  8 allows dicts with no more
+ * than 5 active entries to live in ma_smalltable (and so avoid an
+ * additional malloc); instrumentation suggested this suffices for the
+ * majority of dicts (consisting mostly of usually-small instance dicts and
+ * usually-small dicts created to pass keyword arguments).
+ */
+#define PyDict_MINSIZE 8
+
+typedef struct {
+	long me_hash;      /* cached hash code of me_key */
+	PyObject *me_key;
+	PyObject *me_value;
+} PyDictEntry;
+
+/*
+To ensure the lookup algorithm terminates, there must be at least one Unused
+slot (NULL key) in the table.
+The value ma_fill is the number of non-NULL keys (sum of Active and Dummy);
+ma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL
+values == the number of Active items).
+To avoid slowing down lookups on a near-full table, we resize the table when
+it's two-thirds full.
+*/
+typedef struct _dictobject PyDictObject;
+struct _dictobject {
+	PyObject_HEAD
+	int ma_fill;  /* # Active + # Dummy */
+	int ma_used;  /* # Active */
+
+	/* The table contains ma_mask + 1 slots, and that's a power of 2.
+	 * We store the mask instead of the size because the mask is more
+	 * frequently needed.
+	 */
+	int ma_mask;
+
+	/* ma_table points to ma_smalltable for small tables, else to
+	 * additional malloc'ed memory.  ma_table is never NULL!  This rule
+	 * saves repeated runtime null-tests in the workhorse getitem and
+	 * setitem calls.
+	 */
+	PyDictEntry *ma_table;
+	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
+	PyDictEntry ma_smalltable[PyDict_MINSIZE];
+};
+
+PyAPI_DATA(PyTypeObject) PyDict_Type;
+
+#define PyDict_Check(op) PyObject_TypeCheck(op, &amp;PyDict_Type)
+#define PyDict_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDict_Type)
+
+PyAPI_FUNC(PyObject *) PyDict_New(void);
+PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
+PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Next(
+	PyObject *mp, int *pos, PyObject **key, PyObject **value);
+PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Size(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);
+
+/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
+PyAPI_FUNC(int) PyDict_Update(PyObject *mp, PyObject *other);
+
+/* PyDict_Merge updates/merges from a mapping object (an object that
+   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
+   the last occurrence of a key wins, else the first.  The Python
+   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
+*/
+PyAPI_FUNC(int) PyDict_Merge(PyObject *mp,
+				   PyObject *other,
+				   int override);
+
+/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
+   iterable objects of length 2.  If override is true, the last occurrence
+   of a key wins, else the first.  The Python dict constructor dict(seq2)
+   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
+*/
+PyAPI_FUNC(int) PyDict_MergeFromSeq2(PyObject *d,
+					   PyObject *seq2,
+					   int override);
+
+PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
+PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_DICTOBJECT_H */

Added: trunk/mingw-libs/include/enumobject.h
===================================================================
--- trunk/mingw-libs/include/enumobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/enumobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,17 @@
+#ifndef Py_ENUMOBJECT_H
+#define Py_ENUMOBJECT_H
+
+/* Enumerate Object */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyEnum_Type;
+PyAPI_DATA(PyTypeObject) PyReversed_Type;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_ENUMOBJECT_H */

Added: trunk/mingw-libs/include/errcode.h
===================================================================
--- trunk/mingw-libs/include/errcode.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/errcode.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,35 @@
+#ifndef Py_ERRCODE_H
+#define Py_ERRCODE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Error codes passed around between file input, tokenizer, parser and
+   interpreter.  This is necessary so we can turn them into Python
+   exceptions at a higher level.  Note that some errors have a
+   slightly different meaning when passed from the tokenizer to the
+   parser than when passed from the parser to the interpreter; e.g.
+   the parser only returns E_EOF when it hits EOF immediately, and it
+   never returns E_OK. */
+
+#define E_OK		10	/* No error */
+#define E_EOF		11	/* End Of File */
+#define E_INTR		12	/* Interrupted */
+#define E_TOKEN		13	/* Bad token */
+#define E_SYNTAX	14	/* Syntax error */
+#define E_NOMEM		15	/* Ran out of memory */
+#define E_DONE		16	/* Parsing complete */
+#define E_ERROR		17	/* Execution error */
+#define E_TABSPACE	18	/* Inconsistent mixing of tabs and spaces */
+#define E_OVERFLOW      19	/* Node had too many children */
+#define E_TOODEEP	20	/* Too many indentation levels */
+#define E_DEDENT	21	/* No matching outer block for dedent */
+#define E_DECODE	22	/* Error in decoding into Unicode */
+#define E_EOFS		23	/* EOF in triple-quoted string */
+#define E_EOLS		24	/* EOL in single-quoted string */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ERRCODE_H */

Added: trunk/mingw-libs/include/eval.h
===================================================================
--- trunk/mingw-libs/include/eval.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/eval.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,25 @@
+
+/* Interface to execute compiled code */
+
+#ifndef Py_EVAL_H
+#define Py_EVAL_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyCodeObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyCodeObject *co,
+					PyObject *globals,
+					PyObject *locals,
+					PyObject **args, int argc,
+					PyObject **kwds, int kwdc,
+					PyObject **defs, int defc,
+					PyObject *closure);
+
+PyAPI_FUNC(PyObject *) _PyEval_CallTracing(PyObject *func, PyObject *args);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_EVAL_H */

Added: trunk/mingw-libs/include/fileobject.h
===================================================================
--- trunk/mingw-libs/include/fileobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/fileobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,63 @@
+
+/* File object interface */
+
+#ifndef Py_FILEOBJECT_H
+#define Py_FILEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+	PyObject_HEAD
+	FILE *f_fp;
+	PyObject *f_name;
+	PyObject *f_mode;
+	int (*f_close)(FILE *);
+	int f_softspace;	/* Flag used by 'print' command */
+	int f_binary;		/* Flag which indicates whether the file is 
+				   open in binary (1) or text (0) mode */
+	char* f_buf;		/* Allocated readahead buffer */
+	char* f_bufend;		/* Points after last occupied position */
+	char* f_bufptr;		/* Current buffer position */
+	char *f_setbuf;		/* Buffer for setbuf(3) and setvbuf(3) */
+	int f_univ_newline;	/* Handle any newline convention */
+	int f_newlinetypes;	/* Types of newlines seen */
+	int f_skipnextlf;	/* Skip next \n */
+	PyObject *f_encoding;
+	PyObject *weakreflist; /* List of weak references */
+} PyFileObject;
+
+PyAPI_DATA(PyTypeObject) PyFile_Type;
+
+#define PyFile_Check(op) PyObject_TypeCheck(op, &amp;PyFile_Type)
+#define PyFile_CheckExact(op) ((op)-&gt;ob_type == &amp;PyFile_Type)
+
+PyAPI_FUNC(PyObject *) PyFile_FromString(char *, char *);
+PyAPI_FUNC(void) PyFile_SetBufSize(PyObject *, int);
+PyAPI_FUNC(int) PyFile_SetEncoding(PyObject *, const char *);
+PyAPI_FUNC(PyObject *) PyFile_FromFile(FILE *, char *, char *,
+                                             int (*)(FILE *));
+PyAPI_FUNC(FILE *) PyFile_AsFile(PyObject *);
+PyAPI_FUNC(PyObject *) PyFile_Name(PyObject *);
+PyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);
+PyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);
+PyAPI_FUNC(int) PyFile_SoftSpace(PyObject *, int);
+PyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);
+PyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);
+
+/* The default encoding used by the platform file system APIs
+   If non-NULL, this is different than the default encoding for strings
+*/
+PyAPI_DATA(const char *) Py_FileSystemDefaultEncoding;
+
+/* Routines to replace fread() and fgets() which accept any of \r, \n
+   or \r\n as line terminators.
+*/
+#define PY_STDIOTEXTMODE &quot;b&quot;
+char *Py_UniversalNewlineFgets(char *, int, FILE*, PyObject *);
+size_t Py_UniversalNewlineFread(char *, size_t, FILE *, PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FILEOBJECT_H */

Added: trunk/mingw-libs/include/floatobject.h
===================================================================
--- trunk/mingw-libs/include/floatobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/floatobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,95 @@
+
+/* Float object interface */
+
+/*
+PyFloatObject represents a (double precision) floating point number.
+*/
+
+#ifndef Py_FLOATOBJECT_H
+#define Py_FLOATOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    double ob_fval;
+} PyFloatObject;
+
+PyAPI_DATA(PyTypeObject) PyFloat_Type;
+
+#define PyFloat_Check(op) PyObject_TypeCheck(op, &amp;PyFloat_Type)
+#define PyFloat_CheckExact(op) ((op)-&gt;ob_type == &amp;PyFloat_Type)
+
+/* Return Python float from string PyObject.  Second argument ignored on
+   input, and, if non-NULL, NULL is stored into *junk (this tried to serve a
+   purpose once but can't be made to work as intended). */
+PyAPI_FUNC(PyObject *) PyFloat_FromString(PyObject*, char** junk);
+
+/* Return Python float from C double. */
+PyAPI_FUNC(PyObject *) PyFloat_FromDouble(double);
+
+/* Extract C double from Python float.  The macro version trades safety for
+   speed. */
+PyAPI_FUNC(double) PyFloat_AsDouble(PyObject *);
+#define PyFloat_AS_DOUBLE(op) (((PyFloatObject *)(op))-&gt;ob_fval)
+
+/* Write repr(v) into the char buffer argument, followed by null byte.  The
+   buffer must be &quot;big enough&quot;; &gt;= 100 is very safe.
+   PyFloat_AsReprString(buf, x) strives to print enough digits so that
+   PyFloat_FromString(buf) then reproduces x exactly. */
+PyAPI_FUNC(void) PyFloat_AsReprString(char*, PyFloatObject *v);
+
+/* Write str(v) into the char buffer argument, followed by null byte.  The
+   buffer must be &quot;big enough&quot;; &gt;= 100 is very safe.  Note that it's
+   unusual to be able to get back the float you started with from
+   PyFloat_AsString's result -- use PyFloat_AsReprString() if you want to
+   preserve precision across conversions. */
+PyAPI_FUNC(void) PyFloat_AsString(char*, PyFloatObject *v);
+
+/* _PyFloat_{Pack,Unpack}{4,8}
+ *
+ * The struct and pickle (at least) modules need an efficient platform-
+ * independent way to store floating-point values as byte strings.
+ * The Pack routines produce a string from a C double, and the Unpack
+ * routines produce a C double from such a string.  The suffix (4 or 8)
+ * specifies the number of bytes in the string.
+ *
+ * Excepting NaNs and infinities (which aren't handled correctly), the 4-
+ * byte format is identical to the IEEE-754 single precision format, and
+ * the 8-byte format to the IEEE-754 double precision format.  On non-
+ * IEEE platforms with more precision, or larger dynamic range, than
+ * 754 supports, not all values can be packed; on non-IEEE platforms with
+ * less precision, or smaller dynamic range, not all values can be
+ * unpacked.  What happens in such cases is partly accidental (alas).
+ */
+
+/* The pack routines write 4 or 8 bytes, starting at p.  le is a bool
+ * argument, true if you want the string in little-endian format (exponent
+ * last, at p+3 or p+7), false if you want big-endian format (exponent
+ * first, at p).
+ * Return value:  0 if all is OK, -1 if error (and an exception is
+ * set, most likely OverflowError).
+ * Bug:  What this does is undefined if x is a NaN or infinity.
+ * Bug:  -0.0 and +0.0 produce the same string.
+ */
+PyAPI_FUNC(int) _PyFloat_Pack4(double x, unsigned char *p, int le);
+PyAPI_FUNC(int) _PyFloat_Pack8(double x, unsigned char *p, int le);
+
+/* The unpack routines read 4 or 8 bytes, starting at p.  le is a bool
+ * argument, true if the string is in little-endian format (exponent
+ * last, at p+3 or p+7), false if big-endian (exponent first, at p).
+ * Return value:  The unpacked double.  On error, this is -1.0 and
+ * PyErr_Occurred() is true (and an exception is set, most likely
+ * OverflowError).
+ * Bug:  What this does is undefined if the string represents a NaN or
+ * infinity.
+ */
+PyAPI_FUNC(double) _PyFloat_Unpack4(const unsigned char *p, int le);
+PyAPI_FUNC(double) _PyFloat_Unpack8(const unsigned char *p, int le);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FLOATOBJECT_H */

Added: trunk/mingw-libs/include/frameobject.h
===================================================================
--- trunk/mingw-libs/include/frameobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/frameobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,76 @@
+
+/* Frame object interface */
+
+#ifndef Py_FRAMEOBJECT_H
+#define Py_FRAMEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    int b_type;			/* what kind of block this is */
+    int b_handler;		/* where to jump to find handler */
+    int b_level;		/* value stack level to pop to */
+} PyTryBlock;
+
+typedef struct _frame {
+    PyObject_VAR_HEAD
+    struct _frame *f_back;	/* previous frame, or NULL */
+    PyCodeObject *f_code;	/* code segment */
+    PyObject *f_builtins;	/* builtin symbol table (PyDictObject) */
+    PyObject *f_globals;	/* global symbol table (PyDictObject) */
+    PyObject *f_locals;		/* local symbol table (any mapping) */
+    PyObject **f_valuestack;	/* points after the last local */
+    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.
+       Frame evaluation usually NULLs it, but a frame that yields sets it
+       to the current stack top. */
+    PyObject **f_stacktop;
+    PyObject *f_trace;		/* Trace function */
+    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;
+    PyThreadState *f_tstate;
+    int f_lasti;		/* Last instruction if called */
+    /* As of 2.3 f_lineno is only valid when tracing is active (i.e. when
+       f_trace is set) -- at other times use PyCode_Addr2Line instead. */
+    int f_lineno;		/* Current line number */
+    int f_restricted;		/* Flag set if restricted operations
+				   in this scope */
+    int f_iblock;		/* index in f_blockstack */
+    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
+    int f_nlocals;		/* number of locals */
+    int f_ncells;
+    int f_nfreevars;
+    int f_stacksize;		/* size of value stack */
+    PyObject *f_localsplus[1];	/* locals+stack, dynamically sized */
+} PyFrameObject;
+
+
+/* Standard object interface */
+
+PyAPI_DATA(PyTypeObject) PyFrame_Type;
+
+#define PyFrame_Check(op) ((op)-&gt;ob_type == &amp;PyFrame_Type)
+
+PyAPI_FUNC(PyFrameObject *) PyFrame_New(PyThreadState *, PyCodeObject *,
+                                       PyObject *, PyObject *);
+
+
+/* The rest of the interface is specific for frame objects */
+
+/* Block management functions */
+
+PyAPI_FUNC(void) PyFrame_BlockSetup(PyFrameObject *, int, int, int);
+PyAPI_FUNC(PyTryBlock *) PyFrame_BlockPop(PyFrameObject *);
+
+/* Extend the value stack */
+
+PyAPI_FUNC(PyObject **) PyFrame_ExtendStack(PyFrameObject *, int, int);
+
+/* Conversions between &quot;fast locals&quot; and locals in dictionary */
+
+PyAPI_FUNC(void) PyFrame_LocalsToFast(PyFrameObject *, int);
+PyAPI_FUNC(void) PyFrame_FastToLocals(PyFrameObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FRAMEOBJECT_H */

Added: trunk/mingw-libs/include/funcobject.h
===================================================================
--- trunk/mingw-libs/include/funcobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/funcobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,76 @@
+
+/* Function object interface */
+
+#ifndef Py_FUNCOBJECT_H
+#define Py_FUNCOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Function objects and code objects should not be confused with each other:
+ *
+ * Function objects are created by the execution of the 'def' statement.
+ * They reference a code object in their func_code attribute, which is a
+ * purely syntactic object, i.e. nothing more than a compiled version of some
+ * source code lines.  There is one code object per source code &quot;fragment&quot;,
+ * but each code object can be referenced by zero or many function objects
+ * depending only on how many times the 'def' statement in the source was
+ * executed so far.
+ */
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *func_code;	/* A code object */
+    PyObject *func_globals;	/* A dictionary (other mappings won't do) */
+    PyObject *func_defaults;	/* NULL or a tuple */
+    PyObject *func_closure;	/* NULL or a tuple of cell objects */
+    PyObject *func_doc;		/* The __doc__ attribute, can be anything */
+    PyObject *func_name;	/* The __name__ attribute, a string object */
+    PyObject *func_dict;	/* The __dict__ attribute, a dict or NULL */
+    PyObject *func_weakreflist;	/* List of weak references */
+    PyObject *func_module;	/* The __module__ attribute, can be anything */
+
+    /* Invariant:
+     *     func_closure contains the bindings for func_code-&gt;co_freevars, so
+     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
+     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
+     */
+} PyFunctionObject;
+
+PyAPI_DATA(PyTypeObject) PyFunction_Type;
+
+#define PyFunction_Check(op) ((op)-&gt;ob_type == &amp;PyFunction_Type)
+
+PyAPI_FUNC(PyObject *) PyFunction_New(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetCode(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetGlobals(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyFunction_GET_CODE(func) \
+        (((PyFunctionObject *)func) -&gt; func_code)
+#define PyFunction_GET_GLOBALS(func) \
+	(((PyFunctionObject *)func) -&gt; func_globals)
+#define PyFunction_GET_MODULE(func) \
+	(((PyFunctionObject *)func) -&gt; func_module)
+#define PyFunction_GET_DEFAULTS(func) \
+	(((PyFunctionObject *)func) -&gt; func_defaults)
+#define PyFunction_GET_CLOSURE(func) \
+	(((PyFunctionObject *)func) -&gt; func_closure)
+
+/* The classmethod and staticmethod types lives here, too */
+PyAPI_DATA(PyTypeObject) PyClassMethod_Type;
+PyAPI_DATA(PyTypeObject) PyStaticMethod_Type;
+
+PyAPI_FUNC(PyObject *) PyClassMethod_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyStaticMethod_New(PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FUNCOBJECT_H */

Added: trunk/mingw-libs/include/genobject.h
===================================================================
--- trunk/mingw-libs/include/genobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/genobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,35 @@
+
+/* Generator object interface */
+
+#ifndef Py_GENOBJECT_H
+#define Py_GENOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct _frame; /* Avoid including frameobject.h */
+
+typedef struct {
+	PyObject_HEAD
+	/* The gi_ prefix is intended to remind of generator-iterator. */
+
+	struct _frame *gi_frame;
+
+	/* True if generator is being executed. */
+	int gi_running;
+
+	/* List of weak reference. */
+	PyObject *gi_weakreflist;
+} PyGenObject;
+
+PyAPI_DATA(PyTypeObject) PyGen_Type;
+
+#define PyGen_Check(op) PyObject_TypeCheck(op, &amp;PyGen_Type)
+#define PyGen_CheckExact(op) ((op)-&gt;ob_type == &amp;PyGen_Type)
+
+PyAPI_FUNC(PyObject *) PyGen_New(struct _frame *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_GENOBJECT_H */

Added: trunk/mingw-libs/include/graminit.h
===================================================================
--- trunk/mingw-libs/include/graminit.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/graminit.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,78 @@
+#define single_input 256
+#define file_input 257
+#define eval_input 258
+#define decorator 259
+#define decorators 260
+#define funcdef 261
+#define parameters 262
+#define varargslist 263
+#define fpdef 264
+#define fplist 265
+#define stmt 266
+#define simple_stmt 267
+#define small_stmt 268
+#define expr_stmt 269
+#define augassign 270
+#define print_stmt 271
+#define del_stmt 272
+#define pass_stmt 273
+#define flow_stmt 274
+#define break_stmt 275
+#define continue_stmt 276
+#define return_stmt 277
+#define yield_stmt 278
+#define raise_stmt 279
+#define import_stmt 280
+#define import_name 281
+#define import_from 282
+#define import_as_name 283
+#define dotted_as_name 284
+#define import_as_names 285
+#define dotted_as_names 286
+#define dotted_name 287
+#define global_stmt 288
+#define exec_stmt 289
+#define assert_stmt 290
+#define compound_stmt 291
+#define if_stmt 292
+#define while_stmt 293
+#define for_stmt 294
+#define try_stmt 295
+#define except_clause 296
+#define suite 297
+#define test 298
+#define and_test 299
+#define not_test 300
+#define comparison 301
+#define comp_op 302
+#define expr 303
+#define xor_expr 304
+#define and_expr 305
+#define shift_expr 306
+#define arith_expr 307
+#define term 308
+#define factor 309
+#define power 310
+#define atom 311
+#define listmaker 312
+#define testlist_gexp 313
+#define lambdef 314
+#define trailer 315
+#define subscriptlist 316
+#define subscript 317
+#define sliceop 318
+#define exprlist 319
+#define testlist 320
+#define testlist_safe 321
+#define dictmaker 322
+#define classdef 323
+#define arglist 324
+#define argument 325
+#define list_iter 326
+#define list_for 327
+#define list_if 328
+#define gen_iter 329
+#define gen_for 330
+#define gen_if 331
+#define testlist1 332
+#define encoding_decl 333

Added: trunk/mingw-libs/include/grammar.h
===================================================================
--- trunk/mingw-libs/include/grammar.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/grammar.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,93 @@
+
+/* Grammar interface */
+
+#ifndef Py_GRAMMAR_H
+#define Py_GRAMMAR_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;bitset.h&quot; /* Sigh... */
+
+/* A label of an arc */
+
+typedef struct {
+    int		 lb_type;
+    char	*lb_str;
+} label;
+
+#define EMPTY 0		/* Label number 0 is by definition the empty label */
+
+/* A list of labels */
+
+typedef struct {
+    int		 ll_nlabels;
+    label	*ll_label;
+} labellist;
+
+/* An arc from one state to another */
+
+typedef struct {
+    short	a_lbl;		/* Label of this arc */
+    short	a_arrow;	/* State where this arc goes to */
+} arc;
+
+/* A state in a DFA */
+
+typedef struct {
+    int		 s_narcs;
+    arc		*s_arc;		/* Array of arcs */
+	
+    /* Optional accelerators */
+    int		 s_lower;	/* Lowest label index */
+    int		 s_upper;	/* Highest label index */
+    int		*s_accel;	/* Accelerator */
+    int		 s_accept;	/* Nonzero for accepting state */
+} state;
+
+/* A DFA */
+
+typedef struct {
+    int		 d_type;	/* Non-terminal this represents */
+    char	*d_name;	/* For printing */
+    int		 d_initial;	/* Initial state */
+    int		 d_nstates;
+    state	*d_state;	/* Array of states */
+    bitset	 d_first;
+} dfa;
+
+/* A grammar */
+
+typedef struct {
+    int		 g_ndfas;
+    dfa		*g_dfa;		/* Array of DFAs */
+    labellist	 g_ll;
+    int		 g_start;	/* Start symbol of the grammar */
+    int		 g_accel;	/* Set if accelerators present */
+} grammar;
+
+/* FUNCTIONS */
+
+grammar *newgrammar(int start);
+dfa *adddfa(grammar *g, int type, char *name);
+int addstate(dfa *d);
+void addarc(dfa *d, int from, int to, int lbl);
+dfa *PyGrammar_FindDFA(grammar *g, int type);
+
+int addlabel(labellist *ll, int type, char *str);
+int findlabel(labellist *ll, int type, char *str);
+char *PyGrammar_LabelRepr(label *lb);
+void translatelabels(grammar *g);
+
+void addfirstsets(grammar *g);
+
+void PyGrammar_AddAccelerators(grammar *g);
+void PyGrammar_RemoveAccelerators(grammar *);
+
+void printgrammar(grammar *g, FILE *fp);
+void printnonterminals(grammar *g, FILE *fp);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_GRAMMAR_H */

Added: trunk/mingw-libs/include/import.h
===================================================================
--- trunk/mingw-libs/include/import.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/import.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,55 @@
+
+/* Module definition and import interface */
+
+#ifndef Py_IMPORT_H
+#define Py_IMPORT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(long) PyImport_GetMagicNumber(void);
+PyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(char *name, PyObject *co);
+PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(
+	char *name, PyObject *co, char *pathname);
+PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
+PyAPI_FUNC(PyObject *) PyImport_AddModule(char *name);
+PyAPI_FUNC(PyObject *) PyImport_ImportModule(char *name);
+PyAPI_FUNC(PyObject *) PyImport_ImportModuleEx(
+	char *name, PyObject *globals, PyObject *locals, PyObject *fromlist);
+PyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);
+PyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);
+PyAPI_FUNC(void) PyImport_Cleanup(void);
+PyAPI_FUNC(int) PyImport_ImportFrozenModule(char *);
+
+PyAPI_FUNC(struct filedescr *) _PyImport_FindModule(
+	const char *, PyObject *, char *, size_t, FILE **, PyObject **);
+PyAPI_FUNC(int) _PyImport_IsScript(struct filedescr *);
+
+PyAPI_FUNC(PyObject *)_PyImport_FindExtension(char *, char *);
+PyAPI_FUNC(PyObject *)_PyImport_FixupExtension(char *, char *);
+
+struct _inittab {
+    char *name;
+    void (*initfunc)(void);
+};
+
+PyAPI_DATA(struct _inittab *) PyImport_Inittab;
+
+PyAPI_FUNC(int) PyImport_AppendInittab(char *name, void (*initfunc)(void));
+PyAPI_FUNC(int) PyImport_ExtendInittab(struct _inittab *newtab);
+
+struct _frozen {
+    char *name;
+    unsigned char *code;
+    int size;
+};
+
+/* Embedding apps may change this pointer to point to their favorite
+   collection of frozen modules: */
+
+PyAPI_DATA(struct _frozen *) PyImport_FrozenModules;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_IMPORT_H */

Added: trunk/mingw-libs/include/intobject.h
===================================================================
--- trunk/mingw-libs/include/intobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/intobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,61 @@
+
+/* Integer object interface */
+
+/*
+PyIntObject represents a (long) integer.  This is an immutable object;
+an integer cannot change its value after creation.
+
+There are functions to create new integer objects, to test an object
+for integer-ness, and to get the integer value.  The latter functions
+returns -1 and sets errno to EBADF if the object is not an PyIntObject.
+None of the functions should be applied to nil objects.
+
+The type PyIntObject is (unfortunately) exposed here so we can declare
+_Py_TrueStruct and _Py_ZeroStruct in boolobject.h; don't use this.
+*/
+
+#ifndef Py_INTOBJECT_H
+#define Py_INTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    long ob_ival;
+} PyIntObject;
+
+PyAPI_DATA(PyTypeObject) PyInt_Type;
+
+#define PyInt_Check(op) PyObject_TypeCheck(op, &amp;PyInt_Type)
+#define PyInt_CheckExact(op) ((op)-&gt;ob_type == &amp;PyInt_Type)
+
+PyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, int, int);
+#endif
+PyAPI_FUNC(PyObject *) PyInt_FromLong(long);
+PyAPI_FUNC(long) PyInt_AsLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyInt_AsUnsignedLongMask(PyObject *);
+#ifdef HAVE_LONG_LONG
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyInt_AsUnsignedLongLongMask(PyObject *);
+#endif
+
+PyAPI_FUNC(long) PyInt_GetMax(void);
+
+/* Macro, trading safety for speed */
+#define PyInt_AS_LONG(op) (((PyIntObject *)(op))-&gt;ob_ival)
+
+/* These aren't really part of the Int object, but they're handy; the protos
+ * are necessary for systems that need the magic of PyAPI_FUNC and that want
+ * to have stropmodule as a dynamically loaded module instead of building it
+ * into the main Python shared library/DLL.  Guido thinks I'm weird for
+ * building it this way.  :-)  [cjh]
+ */
+PyAPI_FUNC(unsigned long) PyOS_strtoul(char *, char **, int);
+PyAPI_FUNC(long) PyOS_strtol(char *, char **, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_INTOBJECT_H */

Added: trunk/mingw-libs/include/intrcheck.h
===================================================================
--- trunk/mingw-libs/include/intrcheck.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/intrcheck.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,15 @@
+
+#ifndef Py_INTRCHECK_H
+#define Py_INTRCHECK_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(int) PyOS_InterruptOccurred(void);
+PyAPI_FUNC(void) PyOS_InitInterrupts(void);
+PyAPI_FUNC(void) PyOS_AfterFork(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_INTRCHECK_H */

Added: trunk/mingw-libs/include/iterobject.h
===================================================================
--- trunk/mingw-libs/include/iterobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/iterobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,23 @@
+#ifndef Py_ITEROBJECT_H
+#define Py_ITEROBJECT_H
+/* Iterators (the basic kind, over a sequence) */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PySeqIter_Type;
+
+#define PySeqIter_Check(op) ((op)-&gt;ob_type == &amp;PySeqIter_Type)
+
+PyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);
+
+PyAPI_DATA(PyTypeObject) PyCallIter_Type;
+
+#define PyCallIter_Check(op) ((op)-&gt;ob_type == &amp;PyCallIter_Type)
+
+PyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ITEROBJECT_H */
+

Added: trunk/mingw-libs/include/listobject.h
===================================================================
--- trunk/mingw-libs/include/listobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/listobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,67 @@
+
+/* List object interface */
+
+/*
+Another generally useful object type is an list of object pointers.
+This is a mutable type: the list items can be changed, and items can be
+added or removed.  Out-of-range indices or non-list objects are ignored.
+
+*** WARNING *** PyList_SetItem does not increment the new item's reference
+count, but does decrement the reference count of the item it replaces,
+if not nil.  It does *decrement* the reference count if it is *not*
+inserted in the list.  Similarly, PyList_GetItem does not increment the
+returned item's reference count.
+*/
+
+#ifndef Py_LISTOBJECT_H
+#define Py_LISTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_VAR_HEAD
+    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
+    PyObject **ob_item;
+
+    /* ob_item contains space for 'allocated' elements.  The number
+     * currently in use is ob_size.
+     * Invariants:
+     *     0 &lt;= ob_size &lt;= allocated
+     *     len(list) == ob_size
+     *     ob_item == NULL implies ob_size == allocated == 0
+     * list.sort() temporarily sets allocated to -1 to detect mutations.
+     *
+     * Items must normally not be NULL, except during construction when
+     * the list is not yet visible outside the function that builds it.
+     */
+    int allocated;
+} PyListObject;
+
+PyAPI_DATA(PyTypeObject) PyList_Type;
+
+#define PyList_Check(op) PyObject_TypeCheck(op, &amp;PyList_Type)
+#define PyList_CheckExact(op) ((op)-&gt;ob_type == &amp;PyList_Type)
+
+PyAPI_FUNC(PyObject *) PyList_New(int size);
+PyAPI_FUNC(int) PyList_Size(PyObject *);
+PyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, int);
+PyAPI_FUNC(int) PyList_SetItem(PyObject *, int, PyObject *);
+PyAPI_FUNC(int) PyList_Insert(PyObject *, int, PyObject *);
+PyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, int, int);
+PyAPI_FUNC(int) PyList_SetSlice(PyObject *, int, int, PyObject *);
+PyAPI_FUNC(int) PyList_Sort(PyObject *);
+PyAPI_FUNC(int) PyList_Reverse(PyObject *);
+PyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);
+PyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);
+
+/* Macro, trading safety for speed */
+#define PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])
+#define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))
+#define PyList_GET_SIZE(op)    (((PyListObject *)(op))-&gt;ob_size)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LISTOBJECT_H */

Added: trunk/mingw-libs/include/longintrepr.h
===================================================================
--- trunk/mingw-libs/include/longintrepr.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/longintrepr.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,63 @@
+#ifndef Py_LONGINTREPR_H
+#define Py_LONGINTREPR_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* This is published for the benefit of &quot;friend&quot; marshal.c only. */
+
+/* Parameters of the long integer representation.
+   These shouldn't have to be changed as C should guarantee that a short
+   contains at least 16 bits, but it's made changeable anyway.
+   Note: 'digit' should be able to hold 2*MASK+1, and 'twodigits'
+   should be able to hold the intermediate results in 'mul'
+   (at most (BASE-1)*(2*BASE+1) == MASK*(2*MASK+3)).
+   Also, x_sub assumes that 'digit' is an unsigned type, and overflow
+   is handled by taking the result mod 2**N for some N &gt; SHIFT.
+   And, at some places it is assumed that MASK fits in an int, as well.
+   long_pow() requires that SHIFT be divisible by 5. */
+
+typedef unsigned short digit;
+typedef unsigned int wdigit; /* digit widened to parameter size */
+#define BASE_TWODIGITS_TYPE long
+typedef unsigned BASE_TWODIGITS_TYPE twodigits;
+typedef BASE_TWODIGITS_TYPE stwodigits; /* signed variant of twodigits */
+
+#define SHIFT	15
+#define BASE	((digit)1 &lt;&lt; SHIFT)
+#define MASK	((int)(BASE - 1))
+
+#if SHIFT % 5 != 0
+#error &quot;longobject.c requires that SHIFT be divisible by 5&quot;
+#endif
+
+/* Long integer representation.
+   The absolute value of a number is equal to
+   	SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
+   Negative numbers are represented with ob_size &lt; 0;
+   zero is represented by ob_size == 0.
+   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
+   digit) is never zero.  Also, in all cases, for all valid i,
+   	0 &lt;= ob_digit[i] &lt;= MASK.
+   The allocation function takes care of allocating extra memory
+   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.
+
+   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
+   aware that longs abuse  ob_size's sign bit.
+*/
+
+struct _longobject {
+	PyObject_VAR_HEAD
+	digit ob_digit[1];
+};
+
+PyAPI_FUNC(PyLongObject *) _PyLong_New(int);
+
+/* Return a copy of src. */
+PyAPI_FUNC(PyObject *) _PyLong_Copy(PyLongObject *src);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LONGINTREPR_H */

Added: trunk/mingw-libs/include/longobject.h
===================================================================
--- trunk/mingw-libs/include/longobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/longobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,108 @@
+#ifndef Py_LONGOBJECT_H
+#define Py_LONGOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Long (arbitrary precision) integer object interface */
+
+typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */
+
+PyAPI_DATA(PyTypeObject) PyLong_Type;
+
+#define PyLong_Check(op) PyObject_TypeCheck(op, &amp;PyLong_Type)
+#define PyLong_CheckExact(op) ((op)-&gt;ob_type == &amp;PyLong_Type)
+
+PyAPI_FUNC(PyObject *) PyLong_FromLong(long);
+PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);
+PyAPI_FUNC(PyObject *) PyLong_FromDouble(double);
+PyAPI_FUNC(long) PyLong_AsLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLongMask(PyObject *);
+
+/* _PyLong_AsScaledDouble returns a double x and an exponent e such that
+   the true value is approximately equal to x * 2**(SHIFT*e).  e is &gt;= 0.
+   x is 0.0 if and only if the input is 0 (in which case, e and x are both
+   zeroes).  Overflow is impossible.  Note that the exponent returned must
+   be multiplied by SHIFT!  There may not be enough room in an int to store
+   e*SHIFT directly. */
+PyAPI_FUNC(double) _PyLong_AsScaledDouble(PyObject *vv, int *e);
+
+PyAPI_FUNC(double) PyLong_AsDouble(PyObject *);
+PyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);
+PyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);
+
+#ifdef HAVE_LONG_LONG
+PyAPI_FUNC(PyObject *) PyLong_FromLongLong(PY_LONG_LONG);
+PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned PY_LONG_LONG);
+PyAPI_FUNC(PY_LONG_LONG) PyLong_AsLongLong(PyObject *);
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyLong_AsUnsignedLongLong(PyObject *);
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyLong_AsUnsignedLongLongMask(PyObject *);
+#endif /* HAVE_LONG_LONG */
+
+PyAPI_FUNC(PyObject *) PyLong_FromString(char *, char **, int);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyLong_FromUnicode(Py_UNICODE*, int, int);
+#endif
+
+/* _PyLong_Sign.  Return 0 if v is 0, -1 if v &lt; 0, +1 if v &gt; 0.
+   v must not be NULL, and must be a normalized long.
+   There are no error cases.
+*/
+PyAPI_FUNC(int) _PyLong_Sign(PyObject *v);
+
+
+/* _PyLong_NumBits.  Return the number of bits needed to represent the
+   absolute value of a long.  For example, this returns 1 for 1 and -1, 2
+   for 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.
+   v must not be NULL, and must be a normalized long.
+   (size_t)-1 is returned and OverflowError set if the true result doesn't
+   fit in a size_t.
+*/
+PyAPI_FUNC(size_t) _PyLong_NumBits(PyObject *v);
+
+/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
+   base 256, and return a Python long with the same numeric value.
+   If n is 0, the integer is 0.  Else:
+   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;
+   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the
+   LSB.
+   If is_signed is 0/false, view the bytes as a non-negative integer.
+   If is_signed is 1/true, view the bytes as a 2's-complement integer,
+   non-negative if bit 0x80 of the MSB is clear, negative if set.
+   Error returns:
+   + Return NULL with the appropriate exception set if there's not
+     enough memory to create the Python long.
+*/
+PyAPI_FUNC(PyObject *) _PyLong_FromByteArray(
+	const unsigned char* bytes, size_t n,
+	int little_endian, int is_signed);
+
+/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long
+   v to a base-256 integer, stored in array bytes.  Normally return 0,
+   return -1 on error.
+   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at
+   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and
+   the LSB at bytes[n-1].
+   If is_signed is 0/false, it's an error if v &lt; 0; else (v &gt;= 0) n bytes
+   are filled and there's nothing special about bit 0x80 of the MSB.
+   If is_signed is 1/true, bytes is filled with the 2's-complement
+   representation of v's value.  Bit 0x80 of the MSB is the sign bit.
+   Error returns (-1):
+   + is_signed is 0 and v &lt; 0.  TypeError is set in this case, and bytes
+     isn't altered.
+   + n isn't big enough to hold the full mathematical value of v.  For
+     example, if is_signed is 0 and there are more digits in the v than
+     fit in n; or if is_signed is 1, v &lt; 0, and n is just 1 bit shy of
+     being large enough to hold a sign bit.  OverflowError is set in this
+     case, but bytes holds the least-signficant n bytes of the true value.
+*/
+PyAPI_FUNC(int) _PyLong_AsByteArray(PyLongObject* v,
+	unsigned char* bytes, size_t n,
+	int little_endian, int is_signed);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LONGOBJECT_H */

Added: trunk/mingw-libs/include/marshal.h
===================================================================
--- trunk/mingw-libs/include/marshal.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/marshal.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,25 @@
+
+/* Interface for marshal.c */
+
+#ifndef Py_MARSHAL_H
+#define Py_MARSHAL_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define Py_MARSHAL_VERSION 1
+
+PyAPI_FUNC(void) PyMarshal_WriteLongToFile(long, FILE *, int);
+PyAPI_FUNC(void) PyMarshal_WriteObjectToFile(PyObject *, FILE *, int);
+PyAPI_FUNC(PyObject *) PyMarshal_WriteObjectToString(PyObject *, int);
+
+PyAPI_FUNC(long) PyMarshal_ReadLongFromFile(FILE *);
+PyAPI_FUNC(int) PyMarshal_ReadShortFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadLastObjectFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromString(char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MARSHAL_H */

Added: trunk/mingw-libs/include/metagrammar.h
===================================================================
--- trunk/mingw-libs/include/metagrammar.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/metagrammar.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,18 @@
+#ifndef Py_METAGRAMMAR_H
+#define Py_METAGRAMMAR_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+#define MSTART 256
+#define RULE 257
+#define RHS 258
+#define ALT 259
+#define ITEM 260
+#define ATOM 261
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_METAGRAMMAR_H */

Added: trunk/mingw-libs/include/methodobject.h
===================================================================
--- trunk/mingw-libs/include/methodobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/methodobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,91 @@
+
+/* Method object interface */
+
+#ifndef Py_METHODOBJECT_H
+#define Py_METHODOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This is about the type 'builtin_function_or_method',
+   not Python methods in user-defined classes.  See classobject.h
+   for the latter. */
+
+PyAPI_DATA(PyTypeObject) PyCFunction_Type;
+
+#define PyCFunction_Check(op) ((op)-&gt;ob_type == &amp;PyCFunction_Type)
+
+typedef PyObject *(*PyCFunction)(PyObject *, PyObject *);
+typedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *,
+					     PyObject *);
+typedef PyObject *(*PyNoArgsFunction)(PyObject *);
+
+PyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);
+PyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);
+PyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyCFunction_GET_FUNCTION(func) \
+        (((PyCFunctionObject *)func) -&gt; m_ml -&gt; ml_meth)
+#define PyCFunction_GET_SELF(func) \
+	(((PyCFunctionObject *)func) -&gt; m_self)
+#define PyCFunction_GET_FLAGS(func) \
+	(((PyCFunctionObject *)func) -&gt; m_ml -&gt; ml_flags)
+PyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
+
+struct PyMethodDef {
+    char	*ml_name;	/* The name of the built-in function/method */
+    PyCFunction  ml_meth;	/* The C function that implements it */
+    int		 ml_flags;	/* Combination of METH_xxx flags, which mostly
+				   describe the args expected by the C func */
+    char	*ml_doc;	/* The __doc__ attribute, or NULL */
+};
+typedef struct PyMethodDef PyMethodDef;
+
+PyAPI_FUNC(PyObject *) Py_FindMethod(PyMethodDef[], PyObject *, char *);
+
+#define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
+PyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *, 
+					 PyObject *);
+
+/* Flag passed to newmethodobject */
+#define METH_OLDARGS  0x0000
+#define METH_VARARGS  0x0001
+#define METH_KEYWORDS 0x0002
+/* METH_NOARGS and METH_O must not be combined with the flags above. */
+#define METH_NOARGS   0x0004
+#define METH_O        0x0008
+
+/* METH_CLASS and METH_STATIC are a little different; these control
+   the construction of methods for a class.  These cannot be used for
+   functions in modules. */
+#define METH_CLASS    0x0010
+#define METH_STATIC   0x0020
+
+/* METH_COEXIST allows a method to be entered eventhough a slot has
+   already filled the entry.  When defined, the flag allows a separate
+   method, &quot;__contains__&quot; for example, to coexist with a defined 
+   slot like sq_contains. */
+
+#define METH_COEXIST   0x0040
+
+typedef struct PyMethodChain {
+    PyMethodDef *methods;		/* Methods of this type */
+    struct PyMethodChain *link;	/* NULL or base type */
+} PyMethodChain;
+
+PyAPI_FUNC(PyObject *) Py_FindMethodInChain(PyMethodChain *, PyObject *,
+                                                  char *);
+
+typedef struct {
+    PyObject_HEAD
+    PyMethodDef *m_ml; /* Description of the C function to call */
+    PyObject    *m_self; /* Passed as 'self' arg to the C func, can be NULL */
+    PyObject    *m_module; /* The __module__ attribute, can be anything */
+} PyCFunctionObject;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_METHODOBJECT_H */

Added: trunk/mingw-libs/include/modsupport.h
===================================================================
--- trunk/mingw-libs/include/modsupport.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/modsupport.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,103 @@
+
+#ifndef Py_MODSUPPORT_H
+#define Py_MODSUPPORT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Module support interface */
+
+#include &lt;stdarg.h&gt;
+
+PyAPI_FUNC(int) PyArg_Parse(PyObject *, char *, ...);
+PyAPI_FUNC(int) PyArg_ParseTuple(PyObject *, char *, ...);
+PyAPI_FUNC(int) PyArg_ParseTupleAndKeywords(PyObject *, PyObject *,
+                                                  char *, char **, ...);
+PyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, char *, int, int, ...);
+PyAPI_FUNC(PyObject *) Py_BuildValue(char *, ...);
+
+PyAPI_FUNC(int) PyArg_VaParse(PyObject *, char *, va_list);
+PyAPI_FUNC(int) PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *,
+                                                  char *, char **, va_list);
+PyAPI_FUNC(PyObject *) Py_VaBuildValue(char *, va_list);
+
+PyAPI_FUNC(int) PyModule_AddObject(PyObject *, char *, PyObject *);
+PyAPI_FUNC(int) PyModule_AddIntConstant(PyObject *, char *, long);
+PyAPI_FUNC(int) PyModule_AddStringConstant(PyObject *, char *, char *);
+
+#define PYTHON_API_VERSION 1012
+#define PYTHON_API_STRING &quot;1012&quot;
+/* The API version is maintained (independently from the Python version)
+   so we can detect mismatches between the interpreter and dynamically
+   loaded modules.  These are diagnosed by an error message but
+   the module is still loaded (because the mismatch can only be tested
+   after loading the module).  The error message is intended to
+   explain the core dump a few seconds later.
+
+   The symbol PYTHON_API_STRING defines the same value as a string
+   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***
+
+   Please add a line or two to the top of this log for each API
+   version change:
+
+   19-Aug-2002  GvR	1012	Changes to string object struct for
+   				interning changes, saving 3 bytes.
+
+   17-Jul-2001	GvR	1011	Descr-branch, just to be on the safe side
+
+   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
+                                PyFrame_New(); Python 2.1a2
+
+   14-Mar-2000  GvR     1009    Unicode API added
+
+   3-Jan-1999	GvR	1007	Decided to change back!  (Don't reuse 1008!)
+
+   3-Dec-1998	GvR	1008	Python 1.5.2b1
+
+   18-Jan-1997	GvR	1007	string interning and other speedups
+
+   11-Oct-1996	GvR	renamed Py_Ellipses to Py_Ellipsis :-(
+
+   30-Jul-1996	GvR	Slice and ellipses syntax added
+
+   23-Jul-1996	GvR	For 1.4 -- better safe than sorry this time :-)
+
+   7-Nov-1995	GvR	Keyword arguments (should've been done at 1.3 :-( )
+
+   10-Jan-1995	GvR	Renamed globals to new naming scheme
+
+   9-Jan-1995	GvR	Initial version (incompatible with older API)
+*/
+
+#ifdef MS_WINDOWS
+/* Special defines for Windows versions used to live here.  Things
+   have changed, and the &quot;Version&quot; is now in a global string variable.
+   Reason for this is that this for easier branding of a &quot;custom DLL&quot;
+   without actually needing a recompile.  */
+#endif /* MS_WINDOWS */
+
+#ifdef Py_TRACE_REFS
+/* When we are tracing reference counts, rename Py_InitModule4 so
+   modules compiled with incompatible settings will generate a
+   link-time error. */
+#define Py_InitModule4 Py_InitModule4TraceRefs
+#endif
+
+PyAPI_FUNC(PyObject *) Py_InitModule4(char *name, PyMethodDef *methods,
+                                            char *doc, PyObject *self,
+                                            int apiver);
+
+#define Py_InitModule(name, methods) \
+	Py_InitModule4(name, methods, (char *)NULL, (PyObject *)NULL, \
+		       PYTHON_API_VERSION)
+
+#define Py_InitModule3(name, methods, doc) \
+	Py_InitModule4(name, methods, doc, (PyObject *)NULL, \
+		       PYTHON_API_VERSION)
+
+PyAPI_DATA(char *) _Py_PackageContext;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MODSUPPORT_H */

Added: trunk/mingw-libs/include/moduleobject.h
===================================================================
--- trunk/mingw-libs/include/moduleobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/moduleobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,24 @@
+
+/* Module object interface */
+
+#ifndef Py_MODULEOBJECT_H
+#define Py_MODULEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyModule_Type;
+
+#define PyModule_Check(op) PyObject_TypeCheck(op, &amp;PyModule_Type)
+#define PyModule_CheckExact(op) ((op)-&gt;ob_type == &amp;PyModule_Type)
+
+PyAPI_FUNC(PyObject *) PyModule_New(char *);
+PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
+PyAPI_FUNC(char *) PyModule_GetName(PyObject *);
+PyAPI_FUNC(char *) PyModule_GetFilename(PyObject *);
+PyAPI_FUNC(void) _PyModule_Clear(PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MODULEOBJECT_H */

Added: trunk/mingw-libs/include/node.h
===================================================================
--- trunk/mingw-libs/include/node.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/node.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,39 @@
+
+/* Parse tree node interface */
+
+#ifndef Py_NODE_H
+#define Py_NODE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct _node {
+    short		n_type;
+    char		*n_str;
+    int			n_lineno;
+    int			n_nchildren;
+    struct _node	*n_child;
+} node;
+
+PyAPI_FUNC(node *) PyNode_New(int type);
+PyAPI_FUNC(int) PyNode_AddChild(node *n, int type,
+                                      char *str, int lineno);
+PyAPI_FUNC(void) PyNode_Free(node *n);
+
+/* Node access functions */
+#define NCH(n)		((n)-&gt;n_nchildren)
+	
+#define CHILD(n, i)	(&amp;(n)-&gt;n_child[i])
+#define RCHILD(n, i)	(CHILD(n, NCH(n) + i))
+#define TYPE(n)		((n)-&gt;n_type)
+#define STR(n)		((n)-&gt;n_str)
+
+/* Assert that the type of a node is what we expect */
+#define REQ(n, type) assert(TYPE(n) == (type))
+
+PyAPI_FUNC(void) PyNode_ListTree(node *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_NODE_H */

Added: trunk/mingw-libs/include/object.h
===================================================================
--- trunk/mingw-libs/include/object.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/object.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,807 @@
+#ifndef Py_OBJECT_H
+#define Py_OBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Object and type object interface */
+
+/*
+Objects are structures allocated on the heap.  Special rules apply to
+the use of objects to ensure they are properly garbage-collected.
+Objects are never allocated statically or on the stack; they must be
+accessed through special macros and functions only.  (Type objects are
+exceptions to the first rule; the standard types are represented by
+statically initialized type objects, although work on type/class unification
+for Python 2.2 made it possible to have heap-allocated type objects too).
+
+An object has a 'reference count' that is increased or decreased when a
+pointer to the object is copied or deleted; when the reference count
+reaches zero there are no references to the object left and it can be
+removed from the heap.
+
+An object has a 'type' that determines what it represents and what kind
+of data it contains.  An object's type is fixed when it is created.
+Types themselves are represented as objects; an object contains a
+pointer to the corresponding type object.  The type itself has a type
+pointer pointing to the object representing the type 'type', which
+contains a pointer to itself!).
+
+Objects do not float around in memory; once allocated an object keeps
+the same size and address.  Objects that must hold variable-size data
+can contain pointers to variable-size parts of the object.  Not all
+objects of the same type have the same size; but the size cannot change
+after allocation.  (These restrictions are made so a reference to an
+object can be simply a pointer -- moving an object would require
+updating all the pointers, and changing an object's size would require
+moving it if there was another object right next to it.)
+
+Objects are always accessed through pointers of the type 'PyObject *'.
+The type 'PyObject' is a structure that only contains the reference count
+and the type pointer.  The actual memory allocated for an object
+contains other data that can only be accessed after casting the pointer
+to a pointer to a longer structure type.  This longer type must start
+with the reference count and type fields; the macro PyObject_HEAD should be
+used for this (to accommodate for future changes).  The implementation
+of a particular object type can cast the object pointer to the proper
+type and back.
+
+A standard interface exists for objects that contain an array of items
+whose size is determined when the object is allocated.
+*/
+
+/* Py_DEBUG implies Py_TRACE_REFS. */
+#if defined(Py_DEBUG) &amp;&amp; !defined(Py_TRACE_REFS)
+#define Py_TRACE_REFS
+#endif
+
+/* Py_TRACE_REFS implies Py_REF_DEBUG. */
+#if defined(Py_TRACE_REFS) &amp;&amp; !defined(Py_REF_DEBUG)
+#define Py_REF_DEBUG
+#endif
+
+#ifdef Py_TRACE_REFS
+/* Define pointers to support a doubly-linked list of all live heap objects. */
+#define _PyObject_HEAD_EXTRA		\
+	struct _object *_ob_next;	\
+	struct _object *_ob_prev;
+
+#define _PyObject_EXTRA_INIT 0, 0,
+
+#else
+#define _PyObject_HEAD_EXTRA
+#define _PyObject_EXTRA_INIT
+#endif
+
+/* PyObject_HEAD defines the initial segment of every PyObject. */
+#define PyObject_HEAD			\
+	_PyObject_HEAD_EXTRA		\
+	int ob_refcnt;			\
+	struct _typeobject *ob_type;
+
+#define PyObject_HEAD_INIT(type)	\
+	_PyObject_EXTRA_INIT		\
+	1, type,
+
+/* PyObject_VAR_HEAD defines the initial segment of all variable-size
+ * container objects.  These end with a declaration of an array with 1
+ * element, but enough space is malloc'ed so that the array actually
+ * has room for ob_size elements.  Note that ob_size is an element count,
+ * not necessarily a byte count.
+ */
+#define PyObject_VAR_HEAD		\
+	PyObject_HEAD			\
+	int ob_size; /* Number of items in variable part */
+
+/* Nothing is actually declared to be a PyObject, but every pointer to
+ * a Python object can be cast to a PyObject*.  This is inheritance built
+ * by hand.  Similarly every pointer to a variable-size Python object can,
+ * in addition, be cast to PyVarObject*.
+ */
+typedef struct _object {
+	PyObject_HEAD
+} PyObject;
+
+typedef struct {
+	PyObject_VAR_HEAD
+} PyVarObject;
+
+
+/*
+Type objects contain a string containing the type name (to help somewhat
+in debugging), the allocation parameters (see PyObject_New() and
+PyObject_NewVar()),
+and methods for accessing objects of the type.  Methods are optional, a
+nil pointer meaning that particular kind of access is not available for
+this type.  The Py_DECREF() macro uses the tp_dealloc method without
+checking for a nil pointer; it should always be implemented except if
+the implementation can guarantee that the reference count will never
+reach zero (e.g., for statically allocated type objects).
+
+NB: the methods for certain type groups are now contained in separate
+method blocks.
+*/
+
+typedef PyObject * (*unaryfunc)(PyObject *);
+typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
+typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
+typedef int (*inquiry)(PyObject *);
+typedef int (*coercion)(PyObject **, PyObject **);
+typedef PyObject *(*intargfunc)(PyObject *, int);
+typedef PyObject *(*intintargfunc)(PyObject *, int, int);
+typedef int(*intobjargproc)(PyObject *, int, PyObject *);
+typedef int(*intintobjargproc)(PyObject *, int, int, PyObject *);
+typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);
+typedef int (*getreadbufferproc)(PyObject *, int, void **);
+typedef int (*getwritebufferproc)(PyObject *, int, void **);
+typedef int (*getsegcountproc)(PyObject *, int *);
+typedef int (*getcharbufferproc)(PyObject *, int, const char **);
+typedef int (*objobjproc)(PyObject *, PyObject *);
+typedef int (*visitproc)(PyObject *, void *);
+typedef int (*traverseproc)(PyObject *, visitproc, void *);
+
+typedef struct {
+	/* For numbers without flag bit Py_TPFLAGS_CHECKTYPES set, all
+	   arguments are guaranteed to be of the object's type (modulo
+	   coercion hacks -- i.e. if the type's coercion function
+	   returns other types, then these are allowed as well).  Numbers that
+	   have the Py_TPFLAGS_CHECKTYPES flag bit set should check *both*
+	   arguments for proper type and implement the necessary conversions
+	   in the slot functions themselves. */
+
+	binaryfunc nb_add;
+	binaryfunc nb_subtract;
+	binaryfunc nb_multiply;
+	binaryfunc nb_divide;
+	binaryfunc nb_remainder;
+	binaryfunc nb_divmod;
+	ternaryfunc nb_power;
+	unaryfunc nb_negative;
+	unaryfunc nb_positive;
+	unaryfunc nb_absolute;
+	inquiry nb_nonzero;
+	unaryfunc nb_invert;
+	binaryfunc nb_lshift;
+	binaryfunc nb_rshift;
+	binaryfunc nb_and;
+	binaryfunc nb_xor;
+	binaryfunc nb_or;
+	coercion nb_coerce;
+	unaryfunc nb_int;
+	unaryfunc nb_long;
+	unaryfunc nb_float;
+	unaryfunc nb_oct;
+	unaryfunc nb_hex;
+	/* Added in release 2.0 */
+	binaryfunc nb_inplace_add;
+	binaryfunc nb_inplace_subtract;
+	binaryfunc nb_inplace_multiply;
+	binaryfunc nb_inplace_divide;
+	binaryfunc nb_inplace_remainder;
+	ternaryfunc nb_inplace_power;
+	binaryfunc nb_inplace_lshift;
+	binaryfunc nb_inplace_rshift;
+	binaryfunc nb_inplace_and;
+	binaryfunc nb_inplace_xor;
+	binaryfunc nb_inplace_or;
+
+	/* Added in release 2.2 */
+	/* The following require the Py_TPFLAGS_HAVE_CLASS flag */
+	binaryfunc nb_floor_divide;
+	binaryfunc nb_true_divide;
+	binaryfunc nb_inplace_floor_divide;
+	binaryfunc nb_inplace_true_divide;
+} PyNumberMethods;
+
+typedef struct {
+	inquiry sq_length;
+	binaryfunc sq_concat;
+	intargfunc sq_repeat;
+	intargfunc sq_item;
+	intintargfunc sq_slice;
+	intobjargproc sq_ass_item;
+	intintobjargproc sq_ass_slice;
+	objobjproc sq_contains;
+	/* Added in release 2.0 */
+	binaryfunc sq_inplace_concat;
+	intargfunc sq_inplace_repeat;
+} PySequenceMethods;
+
+typedef struct {
+	inquiry mp_length;
+	binaryfunc mp_subscript;
+	objobjargproc mp_ass_subscript;
+} PyMappingMethods;
+
+typedef struct {
+	getreadbufferproc bf_getreadbuffer;
+	getwritebufferproc bf_getwritebuffer;
+	getsegcountproc bf_getsegcount;
+	getcharbufferproc bf_getcharbuffer;
+} PyBufferProcs;
+
+
+typedef void (*freefunc)(void *);
+typedef void (*destructor)(PyObject *);
+typedef int (*printfunc)(PyObject *, FILE *, int);
+typedef PyObject *(*getattrfunc)(PyObject *, char *);
+typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
+typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
+typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
+typedef int (*cmpfunc)(PyObject *, PyObject *);
+typedef PyObject *(*reprfunc)(PyObject *);
+typedef long (*hashfunc)(PyObject *);
+typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
+typedef PyObject *(*getiterfunc) (PyObject *);
+typedef PyObject *(*iternextfunc) (PyObject *);
+typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
+typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
+typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
+typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
+typedef PyObject *(*allocfunc)(struct _typeobject *, int);
+
+typedef struct _typeobject {
+	PyObject_VAR_HEAD
+	char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */
+	int tp_basicsize, tp_itemsize; /* For allocation */
+
+	/* Methods to implement standard operations */
+
+	destructor tp_dealloc;
+	printfunc tp_print;
+	getattrfunc tp_getattr;
+	setattrfunc tp_setattr;
+	cmpfunc tp_compare;
+	reprfunc tp_repr;
+
+	/* Method suites for standard classes */
+
+	PyNumberMethods *tp_as_number;
+	PySequenceMethods *tp_as_sequence;
+	PyMappingMethods *tp_as_mapping;
+
+	/* More standard operations (here for binary compatibility) */
+
+	hashfunc tp_hash;
+	ternaryfunc tp_call;
+	reprfunc tp_str;
+	getattrofunc tp_getattro;
+	setattrofunc tp_setattro;
+
+	/* Functions to access object as input/output buffer */
+	PyBufferProcs *tp_as_buffer;
+
+	/* Flags to define presence of optional/expanded features */
+	long tp_flags;
+
+	char *tp_doc; /* Documentation string */
+
+	/* Assigned meaning in release 2.0 */
+	/* call function for all accessible objects */
+	traverseproc tp_traverse;
+
+	/* delete references to contained objects */
+	inquiry tp_clear;
+
+	/* Assigned meaning in release 2.1 */
+	/* rich comparisons */
+	richcmpfunc tp_richcompare;
+
+	/* weak reference enabler */
+	long tp_weaklistoffset;
+
+	/* Added in release 2.2 */
+	/* Iterators */
+	getiterfunc tp_iter;
+	iternextfunc tp_iternext;
+
+	/* Attribute descriptor and subclassing stuff */
+	struct PyMethodDef *tp_methods;
+	struct PyMemberDef *tp_members;
+	struct PyGetSetDef *tp_getset;
+	struct _typeobject *tp_base;
+	PyObject *tp_dict;
+	descrgetfunc tp_descr_get;
+	descrsetfunc tp_descr_set;
+	long tp_dictoffset;
+	initproc tp_init;
+	allocfunc tp_alloc;
+	newfunc tp_new;
+	freefunc tp_free; /* Low-level free-memory routine */
+	inquiry tp_is_gc; /* For PyObject_IS_GC */
+	PyObject *tp_bases;
+	PyObject *tp_mro; /* method resolution order */
+	PyObject *tp_cache;
+	PyObject *tp_subclasses;
+	PyObject *tp_weaklist;
+	destructor tp_del;
+
+#ifdef COUNT_ALLOCS
+	/* these must be last and never explicitly initialized */
+	int tp_allocs;
+	int tp_frees;
+	int tp_maxalloc;
+	struct _typeobject *tp_next;
+#endif
+} PyTypeObject;
+
+
+/* The *real* layout of a type object when allocated on the heap */
+typedef struct _heaptypeobject {
+	/* Note: there's a dependency on the order of these members
+	   in slotptr() in typeobject.c . */
+	PyTypeObject type;
+	PyNumberMethods as_number;
+	PyMappingMethods as_mapping;
+	PySequenceMethods as_sequence; /* as_sequence comes after as_mapping,
+					  so that the mapping wins when both
+					  the mapping and the sequence define
+					  a given operator (e.g. __getitem__).
+					  see add_operators() in typeobject.c . */
+	PyBufferProcs as_buffer;
+	PyObject *name, *slots;
+	/* here are optional user slots, followed by the members. */
+} PyHeapTypeObject;
+
+/* access macro to the members which are floating &quot;behind&quot; the object */
+#define PyHeapType_GET_MEMBERS(etype) \
+    ((PyMemberDef *)(((char *)etype) + (etype)-&gt;type.ob_type-&gt;tp_basicsize))
+
+
+/* Generic type check */
+PyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);
+#define PyObject_TypeCheck(ob, tp) \
+	((ob)-&gt;ob_type == (tp) || PyType_IsSubtype((ob)-&gt;ob_type, (tp)))
+
+PyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */
+PyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */
+PyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */
+
+#define PyType_Check(op) PyObject_TypeCheck(op, &amp;PyType_Type)
+#define PyType_CheckExact(op) ((op)-&gt;ob_type == &amp;PyType_Type)
+
+PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
+PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, int);
+PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
+					       PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyType_Lookup(PyTypeObject *, PyObject *);
+
+/* Generic operations on objects */
+PyAPI_FUNC(int) PyObject_Print(PyObject *, FILE *, int);
+PyAPI_FUNC(void) _PyObject_Dump(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyObject_Unicode(PyObject *);
+#endif
+PyAPI_FUNC(int) PyObject_Compare(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
+PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
+PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, char *);
+PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, char *, PyObject *);
+PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, char *);
+PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject **) _PyObject_GetDictPtr(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
+					      PyObject *, PyObject *);
+PyAPI_FUNC(long) PyObject_Hash(PyObject *);
+PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
+PyAPI_FUNC(int) PyObject_Not(PyObject *);
+PyAPI_FUNC(int) PyCallable_Check(PyObject *);
+PyAPI_FUNC(int) PyNumber_Coerce(PyObject **, PyObject **);
+PyAPI_FUNC(int) PyNumber_CoerceEx(PyObject **, PyObject **);
+
+PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
+
+/* A slot function whose address we need to compare */
+extern int _PyObject_SlotCompare(PyObject *, PyObject *);
+
+
+/* PyObject_Dir(obj) acts like Python __builtin__.dir(obj), returning a
+   list of strings.  PyObject_Dir(NULL) is like __builtin__.dir(),
+   returning the names of the current locals.  In this case, if there are
+   no current locals, NULL is returned, and PyErr_Occurred() is false.
+*/
+PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
+
+
+/* Helpers for printing recursive container types */
+PyAPI_FUNC(int) Py_ReprEnter(PyObject *);
+PyAPI_FUNC(void) Py_ReprLeave(PyObject *);
+
+/* Helpers for hash functions */
+PyAPI_FUNC(long) _Py_HashDouble(double);
+PyAPI_FUNC(long) _Py_HashPointer(void*);
+
+/* Helper for passing objects to printf and the like */
+#define PyObject_REPR(obj) PyString_AS_STRING(PyObject_Repr(obj))
+
+/* Flag bits for printing: */
+#define Py_PRINT_RAW	1	/* No string quotes etc. */
+
+/*
+`Type flags (tp_flags)
+
+These flags are used to extend the type structure in a backwards-compatible
+fashion. Extensions can use the flags to indicate (and test) when a given
+type structure contains a new feature. The Python core will use these when
+introducing new functionality between major revisions (to avoid mid-version
+changes in the PYTHON_API_VERSION).
+
+Arbitration of the flag bit positions will need to be coordinated among
+all extension writers who publically release their extensions (this will
+be fewer than you might expect!)..
+
+Python 1.5.2 introduced the bf_getcharbuffer slot into PyBufferProcs.
+
+Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.
+
+Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
+given type object has a specified feature.
+*/
+
+/* PyBufferProcs contains bf_getcharbuffer */
+#define Py_TPFLAGS_HAVE_GETCHARBUFFER  (1L&lt;&lt;0)
+
+/* PySequenceMethods contains sq_contains */
+#define Py_TPFLAGS_HAVE_SEQUENCE_IN (1L&lt;&lt;1)
+
+/* This is here for backwards compatibility.  Extensions that use the old GC
+ * API will still compile but the objects will not be tracked by the GC. */
+#define Py_TPFLAGS_GC 0 /* used to be (1L&lt;&lt;2) */
+
+/* PySequenceMethods and PyNumberMethods contain in-place operators */
+#define Py_TPFLAGS_HAVE_INPLACEOPS (1L&lt;&lt;3)
+
+/* PyNumberMethods do their own coercion */
+#define Py_TPFLAGS_CHECKTYPES (1L&lt;&lt;4)
+
+/* tp_richcompare is defined */
+#define Py_TPFLAGS_HAVE_RICHCOMPARE (1L&lt;&lt;5)
+
+/* Objects which are weakly referencable if their tp_weaklistoffset is &gt;0 */
+#define Py_TPFLAGS_HAVE_WEAKREFS (1L&lt;&lt;6)
+
+/* tp_iter is defined */
+#define Py_TPFLAGS_HAVE_ITER (1L&lt;&lt;7)
+
+/* New members introduced by Python 2.2 exist */
+#define Py_TPFLAGS_HAVE_CLASS (1L&lt;&lt;8)
+
+/* Set if the type object is dynamically allocated */
+#define Py_TPFLAGS_HEAPTYPE (1L&lt;&lt;9)
+
+/* Set if the type allows subclassing */
+#define Py_TPFLAGS_BASETYPE (1L&lt;&lt;10)
+
+/* Set if the type is 'ready' -- fully initialized */
+#define Py_TPFLAGS_READY (1L&lt;&lt;12)
+
+/* Set while the type is being 'readied', to prevent recursive ready calls */
+#define Py_TPFLAGS_READYING (1L&lt;&lt;13)
+
+/* Objects support garbage collection (see objimp.h) */
+#define Py_TPFLAGS_HAVE_GC (1L&lt;&lt;14)
+
+/* These two bits are preserved for Stackless Python, next after this is 16 */
+#ifdef STACKLESS
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3L&lt;&lt;15)
+#else
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
+#endif
+
+#define Py_TPFLAGS_DEFAULT  ( \
+                             Py_TPFLAGS_HAVE_GETCHARBUFFER | \
+                             Py_TPFLAGS_HAVE_SEQUENCE_IN | \
+                             Py_TPFLAGS_HAVE_INPLACEOPS | \
+                             Py_TPFLAGS_HAVE_RICHCOMPARE | \
+                             Py_TPFLAGS_HAVE_WEAKREFS | \
+                             Py_TPFLAGS_HAVE_ITER | \
+                             Py_TPFLAGS_HAVE_CLASS | \
+                             Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
+                            0)
+
+#define PyType_HasFeature(t,f)  (((t)-&gt;tp_flags &amp; (f)) != 0)
+
+
+/*
+The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
+reference counts.  Py_DECREF calls the object's deallocator function when
+the refcount falls to 0; for
+objects that don't contain references to other objects or heap memory
+this can be the standard function free().  Both macros can be used
+wherever a void expression is allowed.  The argument must not be a
+NIL pointer.  If it may be NIL, use Py_XINCREF/Py_XDECREF instead.
+The macro _Py_NewReference(op) initialize reference counts to 1, and
+in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
+bookkeeping appropriate to the special build.
+
+We assume that the reference count field can never overflow; this can
+be proven when the size of the field is the same as the pointer size, so
+we ignore the possibility.  Provided a C int is at least 32 bits (which
+is implicitly assumed in many parts of this code), that's enough for
+about 2**31 references to an object.
+
+XXX The following became out of date in Python 2.2, but I'm not sure
+XXX what the full truth is now.  Certainly, heap-allocated type objects
+XXX can and should be deallocated.
+Type objects should never be deallocated; the type pointer in an object
+is not considered to be a reference to the type object, to save
+complications in the deallocation function.  (This is actually a
+decision that's up to the implementer of each new type so if you want,
+you can count such references to the type object.)
+
+*** WARNING*** The Py_DECREF macro must have a side-effect-free argument
+since it may evaluate its argument multiple times.  (The alternative
+would be to mace it a proper function or assign it to a global temporary
+variable first, both of which are slower; and in a multi-threaded
+environment the global variable trick is not safe.)
+*/
+
+/* First define a pile of simple helper macros, one set per special
+ * build symbol.  These either expand to the obvious things, or to
+ * nothing at all when the special mode isn't in effect.  The main
+ * macros can later be defined just once then, yet expand to different
+ * things depending on which special build options are and aren't in effect.
+ * Trust me &lt;wink&gt;:  while painful, this is 20x easier to understand than,
+ * e.g, defining _Py_NewReference five different times in a maze of nested
+ * #ifdefs (we used to do that -- it was impenetrable).
+ */
+#ifdef Py_REF_DEBUG
+PyAPI_DATA(long) _Py_RefTotal;
+PyAPI_FUNC(void) _Py_NegativeRefcount(const char *fname,
+					    int lineno, PyObject *op);
+#define _Py_INC_REFTOTAL	_Py_RefTotal++
+#define _Py_DEC_REFTOTAL	_Py_RefTotal--
+#define _Py_REF_DEBUG_COMMA	,
+#define _Py_CHECK_REFCNT(OP)					\
+{	if ((OP)-&gt;ob_refcnt &lt; 0)				\
+		_Py_NegativeRefcount(__FILE__, __LINE__,	\
+				     (PyObject *)(OP));		\
+}
+#else
+#define _Py_INC_REFTOTAL
+#define _Py_DEC_REFTOTAL
+#define _Py_REF_DEBUG_COMMA
+#define _Py_CHECK_REFCNT(OP)	/* a semicolon */;
+#endif /* Py_REF_DEBUG */
+
+#ifdef COUNT_ALLOCS
+PyAPI_FUNC(void) inc_count(PyTypeObject *);
+#define _Py_INC_TPALLOCS(OP)	inc_count((OP)-&gt;ob_type)
+#define _Py_INC_TPFREES(OP)	(OP)-&gt;ob_type-&gt;tp_frees++
+#define _Py_DEC_TPFREES(OP)	(OP)-&gt;ob_type-&gt;tp_frees--
+#define _Py_COUNT_ALLOCS_COMMA	,
+#else
+#define _Py_INC_TPALLOCS(OP)
+#define _Py_INC_TPFREES(OP)
+#define _Py_DEC_TPFREES(OP)
+#define _Py_COUNT_ALLOCS_COMMA
+#endif /* COUNT_ALLOCS */
+
+#ifdef Py_TRACE_REFS
+/* Py_TRACE_REFS is such major surgery that we call external routines. */
+PyAPI_FUNC(void) _Py_NewReference(PyObject *);
+PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
+PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
+PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
+PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
+PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
+
+#else
+/* Without Py_TRACE_REFS, there's little enough to do that we expand code
+ * inline.
+ */
+#define _Py_NewReference(op) (				\
+	_Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA	\
+	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA		\
+	(op)-&gt;ob_refcnt = 1)
+
+#define _Py_ForgetReference(op) _Py_INC_TPFREES(op)
+
+#define _Py_Dealloc(op) (				\
+	_Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA	\
+	(*(op)-&gt;ob_type-&gt;tp_dealloc)((PyObject *)(op)))
+#endif /* !Py_TRACE_REFS */
+
+#define Py_INCREF(op) (				\
+	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
+	(op)-&gt;ob_refcnt++)
+
+#define Py_DECREF(op)					\
+	if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
+	    --(op)-&gt;ob_refcnt != 0)			\
+		_Py_CHECK_REFCNT(op)			\
+	else						\
+		_Py_Dealloc((PyObject *)(op))
+
+#define Py_CLEAR(op)				\
+        do {                            	\
+                if (op) {			\
+                        PyObject *tmp = (PyObject *)(op);	\
+                        (op) = NULL;		\
+                        Py_DECREF(tmp);		\
+                }				\
+        } while (0)
+
+/* Macros to use in case the object pointer may be NULL: */
+#define Py_XINCREF(op) if ((op) == NULL) ; else Py_INCREF(op)
+#define Py_XDECREF(op) if ((op) == NULL) ; else Py_DECREF(op)
+
+/*
+These are provided as conveniences to Python runtime embedders, so that
+they can have object code that is not dependent on Python compilation flags.
+*/
+PyAPI_FUNC(void) Py_IncRef(PyObject *);
+PyAPI_FUNC(void) Py_DecRef(PyObject *);
+
+/*
+_Py_NoneStruct is an object of undefined type which can be used in contexts
+where NULL (nil) is not suitable (since NULL often means 'error').
+
+Don't forget to apply Py_INCREF() when returning this value!!!
+*/
+PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */
+#define Py_None (&amp;_Py_NoneStruct)
+
+/* Macro for returning Py_None from a function */
+#define Py_RETURN_NONE return Py_INCREF(Py_None), Py_None
+
+/*
+Py_NotImplemented is a singleton used to signal that an operation is
+not implemented for a given type combination.
+*/
+PyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */
+#define Py_NotImplemented (&amp;_Py_NotImplementedStruct)
+
+/* Rich comparison opcodes */
+#define Py_LT 0
+#define Py_LE 1
+#define Py_EQ 2
+#define Py_NE 3
+#define Py_GT 4
+#define Py_GE 5
+
+/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.
+ * Defined in object.c.
+ */
+PyAPI_DATA(int) _Py_SwappedOp[];
+
+/*
+Define staticforward and statichere for source compatibility with old
+C extensions.
+
+The staticforward define was needed to support certain broken C
+compilers (notably SCO ODT 3.0, perhaps early AIX as well) botched the
+static keyword when it was used with a forward declaration of a static
+initialized structure.  Standard C allows the forward declaration with
+static, and we've decided to stop catering to broken C compilers.
+(In fact, we expect that the compilers are all fixed eight years later.)
+*/
+
+#define staticforward static
+#define statichere static
+
+
+/*
+More conventions
+================
+
+Argument Checking
+-----------------
+
+Functions that take objects as arguments normally don't check for nil
+arguments, but they do check the type of the argument, and return an
+error if the function doesn't apply to the type.
+
+Failure Modes
+-------------
+
+Functions may fail for a variety of reasons, including running out of
+memory.  This is communicated to the caller in two ways: an error string
+is set (see errors.h), and the function result differs: functions that
+normally return a pointer return NULL for failure, functions returning
+an integer return -1 (which could be a legal return value too!), and
+other functions return 0 for success and -1 for failure.
+Callers should always check for errors before using the result.  If
+an error was set, the caller must either explicitly clear it, or pass
+the error on to its caller.
+
+Reference Counts
+----------------
+
+It takes a while to get used to the proper usage of reference counts.
+
+Functions that create an object set the reference count to 1; such new
+objects must be stored somewhere or destroyed again with Py_DECREF().
+Some functions that 'store' objects, such as PyTuple_SetItem() and
+PyList_SetItem(),
+don't increment the reference count of the object, since the most
+frequent use is to store a fresh object.  Functions that 'retrieve'
+objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
+don't increment
+the reference count, since most frequently the object is only looked at
+quickly.  Thus, to retrieve an object and store it again, the caller
+must call Py_INCREF() explicitly.
+
+NOTE: functions that 'consume' a reference count, like
+PyList_SetItem(), consume the reference even if the object wasn't
+successfully stored, to simplify error handling.
+
+It seems attractive to make other functions that take an object as
+argument consume a reference count; however, this may quickly get
+confusing (even the current practice is already confusing).  Consider
+it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
+times.
+*/
+
+
+/* Trashcan mechanism, thanks to Christian Tismer.
+
+When deallocating a container object, it's possible to trigger an unbounded
+chain of deallocations, as each Py_DECREF in turn drops the refcount on &quot;the
+next&quot; object in the chain to 0.  This can easily lead to stack faults, and
+especially in threads (which typically have less stack space to work with).
+
+A container object that participates in cyclic gc can avoid this by
+bracketing the body of its tp_dealloc function with a pair of macros:
+
+static void
+mytype_dealloc(mytype *p)
+{
+        ... declarations go here ...
+
+ 	PyObject_GC_UnTrack(p);	   // must untrack first
+	Py_TRASHCAN_SAFE_BEGIN(p)
+	... The body of the deallocator goes here, including all calls ...
+	... to Py_DECREF on contained objects.                         ...
+	Py_TRASHCAN_SAFE_END(p)
+}
+
+CAUTION:  Never return from the middle of the body!  If the body needs to
+&quot;get out early&quot;, put a label immediately before the Py_TRASHCAN_SAFE_END
+call, and goto it.  Else the call-depth counter (see below) will stay
+above 0 forever, and the trashcan will never get emptied.
+
+How it works:  The BEGIN macro increments a call-depth counter.  So long
+as this counter is small, the body of the deallocator is run directly without
+further ado.  But if the counter gets large, it instead adds p to a list of
+objects to be deallocated later, skips the body of the deallocator, and
+resumes execution after the END macro.  The tp_dealloc routine then returns
+without deallocating anything (and so unbounded call-stack depth is avoided).
+
+When the call stack finishes unwinding again, code generated by the END macro
+notices this, and calls another routine to deallocate all the objects that
+may have been added to the list of deferred deallocations.  In effect, a
+chain of N deallocations is broken into N / PyTrash_UNWIND_LEVEL pieces,
+with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
+*/
+
+PyAPI_FUNC(void) _PyTrash_deposit_object(PyObject*);
+PyAPI_FUNC(void) _PyTrash_destroy_chain(void);
+PyAPI_DATA(int) _PyTrash_delete_nesting;
+PyAPI_DATA(PyObject *) _PyTrash_delete_later;
+
+#define PyTrash_UNWIND_LEVEL 50
+
+#define Py_TRASHCAN_SAFE_BEGIN(op) \
+	if (_PyTrash_delete_nesting &lt; PyTrash_UNWIND_LEVEL) { \
+		++_PyTrash_delete_nesting;
+		/* The body of the deallocator is here. */
+#define Py_TRASHCAN_SAFE_END(op) \
+		--_PyTrash_delete_nesting; \
+		if (_PyTrash_delete_later &amp;&amp; _PyTrash_delete_nesting &lt;= 0) \
+			_PyTrash_destroy_chain(); \
+	} \
+	else \
+		_PyTrash_deposit_object((PyObject*)op);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OBJECT_H */

Added: trunk/mingw-libs/include/objimpl.h
===================================================================
--- trunk/mingw-libs/include/objimpl.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/objimpl.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,340 @@
+/* The PyObject_ memory family:  high-level object memory interfaces.
+   See pymem.h for the low-level PyMem_ family.
+*/
+
+#ifndef Py_OBJIMPL_H
+#define Py_OBJIMPL_H
+
+#include &quot;pymem.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* BEWARE:
+
+   Each interface exports both functions and macros.  Extension modules should
+   use the functions, to ensure binary compatibility across Python versions.
+   Because the Python implementation is free to change internal details, and
+   the macros may (or may not) expose details for speed, if you do use the
+   macros you must recompile your extensions with each Python release.
+
+   Never mix calls to PyObject_ memory functions with calls to the platform
+   malloc/realloc/ calloc/free, or with calls to PyMem_.
+*/
+
+/*
+Functions and macros for modules that implement new object types.
+
+ - PyObject_New(type, typeobj) allocates memory for a new object of the given
+   type, and initializes part of it.  'type' must be the C structure type used
+   to represent the object, and 'typeobj' the address of the corresponding
+   type object.  Reference count and type pointer are filled in; the rest of
+   the bytes of the object are *undefined*!  The resulting expression type is
+   'type *'.  The size of the object is determined by the tp_basicsize field
+   of the type object.
+
+ - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
+   object with room for n items.  In addition to the refcount and type pointer
+   fields, this also fills in the ob_size field.
+
+ - PyObject_Del(op) releases the memory allocated for an object.  It does not
+   run a destructor -- it only frees the memory.  PyObject_Free is identical.
+
+ - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
+   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
+   new object (allocated by an arbitrary allocator), and initialize its object
+   header fields.
+
+Note that objects created with PyObject_{New, NewVar} are allocated using the
+specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
+enabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG
+is also #defined.
+
+In case a specific form of memory management is needed (for example, if you
+must use the platform malloc heap(s), or shared memory, or C++ local storage or
+operator new), you must first allocate the object with your custom allocator,
+then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
+specific fields:  reference count, type pointer, possibly others.  You should
+be aware that Python no control over these objects because they don't
+cooperate with the Python memory manager.  Such objects may not be eligible
+for automatic garbage collection and you have to make sure that they are
+released accordingly whenever their destructor gets called (cf. the specific
+form of memory management you're using).
+
+Unless you have specific memory management requirements, use
+PyObject_{New, NewVar, Del}.
+*/
+
+/*
+ * Raw object memory interface
+ * ===========================
+ */
+
+/* Functions to call the same malloc/realloc/free as used by Python's
+   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
+   the platform malloc/realloc/free.  The Python object allocator is
+   designed for fast, cache-conscious allocation of many &quot;small&quot; objects,
+   and with low hidden memory overhead.
+
+   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.
+
+   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
+   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
+   at p.
+
+   Returned pointers must be checked for NULL explicitly; no action is
+   performed on failure other than to return NULL (no warning it printed, no
+   exception is set, etc).
+
+   For allocating objects, use PyObject_{New, NewVar} instead whenever
+   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
+   so that you can exploit Python's small-block allocator for non-object
+   uses.  If you must use these routines to allocate object memory, make sure
+   the object gets initialized via PyObject_{Init, InitVar} after obtaining
+   the raw memory.
+*/
+PyAPI_FUNC(void *) PyObject_Malloc(size_t);
+PyAPI_FUNC(void *) PyObject_Realloc(void *, size_t);
+PyAPI_FUNC(void) PyObject_Free(void *);
+
+
+/* Macros */
+#ifdef WITH_PYMALLOC
+#ifdef PYMALLOC_DEBUG
+PyAPI_FUNC(void *) _PyObject_DebugMalloc(size_t nbytes);
+PyAPI_FUNC(void *) _PyObject_DebugRealloc(void *p, size_t nbytes);
+PyAPI_FUNC(void) _PyObject_DebugFree(void *p);
+PyAPI_FUNC(void) _PyObject_DebugDumpAddress(const void *p);
+PyAPI_FUNC(void) _PyObject_DebugCheckAddress(const void *p);
+PyAPI_FUNC(void) _PyObject_DebugMallocStats(void);
+#define PyObject_MALLOC		_PyObject_DebugMalloc
+#define PyObject_Malloc		_PyObject_DebugMalloc
+#define PyObject_REALLOC	_PyObject_DebugRealloc
+#define PyObject_Realloc	_PyObject_DebugRealloc
+#define PyObject_FREE		_PyObject_DebugFree
+#define PyObject_Free		_PyObject_DebugFree
+
+#else	/* WITH_PYMALLOC &amp;&amp; ! PYMALLOC_DEBUG */
+#define PyObject_MALLOC		PyObject_Malloc
+#define PyObject_REALLOC	PyObject_Realloc
+#define PyObject_FREE		PyObject_Free
+#endif
+
+#else	/* ! WITH_PYMALLOC */
+#define PyObject_MALLOC		PyMem_MALLOC
+#define PyObject_REALLOC	PyMem_REALLOC
+/* This is an odd one!  For backward compatability with old extensions, the
+   PyMem &quot;release memory&quot; functions have to invoke the object allocator's
+   free() function.  When pymalloc isn't enabled, that leaves us using
+   the platform free(). */
+#define PyObject_FREE		free
+
+#endif	/* WITH_PYMALLOC */
+
+#define PyObject_Del		PyObject_Free
+#define PyObject_DEL		PyObject_FREE
+
+/* for source compatibility with 2.2 */
+#define _PyObject_Del		PyObject_Free
+
+/*
+ * Generic object allocator interface
+ * ==================================
+ */
+
+/* Functions */
+PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
+                                                 PyTypeObject *, int);
+PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, int);
+
+#define PyObject_New(type, typeobj) \
+		( (type *) _PyObject_New(typeobj) )
+#define PyObject_NewVar(type, typeobj, n) \
+		( (type *) _PyObject_NewVar((typeobj), (n)) )
+
+/* Macros trading binary compatibility for speed. See also pymem.h.
+   Note that these macros expect non-NULL object pointers.*/
+#define PyObject_INIT(op, typeobj) \
+	( (op)-&gt;ob_type = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
+#define PyObject_INIT_VAR(op, typeobj, size) \
+	( (op)-&gt;ob_size = (size), PyObject_INIT((op), (typeobj)) )
+
+#define _PyObject_SIZE(typeobj) ( (typeobj)-&gt;tp_basicsize )
+
+/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
+   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
+   value is rounded up to the closest multiple of sizeof(void *), in order to
+   ensure that pointer fields at the end of the object are correctly aligned
+   for the platform (this is of special importance for subclasses of, e.g.,
+   str or long, so that pointers can be stored after the embedded data).
+
+   Note that there's no memory wastage in doing this, as malloc has to
+   return (at worst) pointer-aligned memory anyway.
+*/
+#if ((SIZEOF_VOID_P - 1) &amp; SIZEOF_VOID_P) != 0
+#   error &quot;_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2&quot;
+#endif
+
+#define _PyObject_VAR_SIZE(typeobj, nitems)	\
+	(size_t)				\
+	( ( (typeobj)-&gt;tp_basicsize +		\
+	    (nitems)*(typeobj)-&gt;tp_itemsize +	\
+	    (SIZEOF_VOID_P - 1)			\
+	  ) &amp; ~(SIZEOF_VOID_P - 1)		\
+	)
+
+#define PyObject_NEW(type, typeobj) \
+( (type *) PyObject_Init( \
+	(PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )
+
+#define PyObject_NEW_VAR(type, typeobj, n) \
+( (type *) PyObject_InitVar( \
+      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\
+      (typeobj), (n)) )
+
+/* This example code implements an object constructor with a custom
+   allocator, where PyObject_New is inlined, and shows the important
+   distinction between two steps (at least):
+       1) the actual allocation of the object storage;
+       2) the initialization of the Python specific fields
+          in this storage with PyObject_{Init, InitVar}.
+
+   PyObject *
+   YourObject_New(...)
+   {
+       PyObject *op;
+
+       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));
+       if (op == NULL)
+           return PyErr_NoMemory();
+
+       PyObject_Init(op, &amp;YourTypeStruct);
+
+       op-&gt;ob_field = value;
+       ...
+       return op;
+   }
+
+   Note that in C++, the use of the new operator usually implies that
+   the 1st step is performed automatically for you, so in a C++ class
+   constructor you would start directly with PyObject_Init/InitVar
+*/
+
+/*
+ * Garbage Collection Support
+ * ==========================
+ */
+
+/* C equivalent of gc.collect(). */
+long PyGC_Collect(void);
+
+/* Test if a type has a GC head */
+#define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)
+
+/* Test if an object has a GC head */
+#define PyObject_IS_GC(o) (PyType_IS_GC((o)-&gt;ob_type) &amp;&amp; \
+	((o)-&gt;ob_type-&gt;tp_is_gc == NULL || (o)-&gt;ob_type-&gt;tp_is_gc(o)))
+
+PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, int);
+#define PyObject_GC_Resize(type, op, n) \
+		( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )
+
+/* for source compatibility with 2.2 */
+#define _PyObject_GC_Del PyObject_GC_Del
+
+/* GC information is stored BEFORE the object structure. */
+typedef union _gc_head {
+	struct {
+		union _gc_head *gc_next;
+		union _gc_head *gc_prev;
+		int gc_refs;
+	} gc;
+	long double dummy;  /* force worst-case alignment */
+} PyGC_Head;
+
+extern PyGC_Head *_PyGC_generation0;
+
+#define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)
+
+#define _PyGC_REFS_UNTRACKED			(-2)
+#define _PyGC_REFS_REACHABLE			(-3)
+#define _PyGC_REFS_TENTATIVELY_UNREACHABLE	(-4)
+
+/* Tell the GC to track this object.  NB: While the object is tracked the
+ * collector it must be safe to call the ob_traverse method. */
+#define _PyObject_GC_TRACK(o) do { \
+	PyGC_Head *g = _Py_AS_GC(o); \
+	if (g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED) \
+		Py_FatalError(&quot;GC object already tracked&quot;); \
+	g-&gt;gc.gc_refs = _PyGC_REFS_REACHABLE; \
+	g-&gt;gc.gc_next = _PyGC_generation0; \
+	g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \
+	g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \
+	_PyGC_generation0-&gt;gc.gc_prev = g; \
+    } while (0);
+
+/* Tell the GC to stop tracking this object.
+ * gc_next doesn't need to be set to NULL, but doing so is a good
+ * way to provoke memory errors if calling code is confused.
+ */
+#define _PyObject_GC_UNTRACK(o) do { \
+	PyGC_Head *g = _Py_AS_GC(o); \
+	assert(g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED); \
+	g-&gt;gc.gc_refs = _PyGC_REFS_UNTRACKED; \
+	g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \
+	g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \
+	g-&gt;gc.gc_next = NULL; \
+    } while (0);
+
+PyAPI_FUNC(PyObject *) _PyObject_GC_Malloc(size_t);
+PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, int);
+PyAPI_FUNC(void) PyObject_GC_Track(void *);
+PyAPI_FUNC(void) PyObject_GC_UnTrack(void *);
+PyAPI_FUNC(void) PyObject_GC_Del(void *);
+
+#define PyObject_GC_New(type, typeobj) \
+		( (type *) _PyObject_GC_New(typeobj) )
+#define PyObject_GC_NewVar(type, typeobj, n) \
+		( (type *) _PyObject_GC_NewVar((typeobj), (n)) )
+
+
+/* Utility macro to help write tp_traverse functions.
+ * To use this macro, the tp_traverse function must name its arguments
+ * &quot;visit&quot; and &quot;arg&quot;.  This is intended to keep tp_traverse functions
+ * looking as much alike as possible.
+ */
+#define Py_VISIT(op)					\
+        do { 						\
+                if (op) {				\
+                        int vret = visit((op), arg);	\
+                        if (vret)			\
+                                return vret;		\
+                }					\
+        } while (0)
+
+/* This is here for the sake of backwards compatibility.  Extensions that
+ * use the old GC API will still compile but the objects will not be
+ * tracked by the GC. */
+#define PyGC_HEAD_SIZE 0
+#define PyObject_GC_Init(op)
+#define PyObject_GC_Fini(op)
+#define PyObject_AS_GC(op) (op)
+#define PyObject_FROM_GC(op) (op)
+
+
+/* Test if a type supports weak references */
+#define PyType_SUPPORTS_WEAKREFS(t) \
+        (PyType_HasFeature((t), Py_TPFLAGS_HAVE_WEAKREFS) \
+         &amp;&amp; ((t)-&gt;tp_weaklistoffset &gt; 0))
+
+#define PyObject_GET_WEAKREFS_LISTPTR(o) \
+	((PyObject **) (((char *) (o)) + (o)-&gt;ob_type-&gt;tp_weaklistoffset))
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OBJIMPL_H */

Added: trunk/mingw-libs/include/opcode.h
===================================================================
--- trunk/mingw-libs/include/opcode.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/opcode.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,153 @@
+#ifndef Py_OPCODE_H
+#define Py_OPCODE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Instruction opcodes for compiled code */
+
+#define STOP_CODE	0
+#define POP_TOP		1
+#define ROT_TWO		2
+#define ROT_THREE	3
+#define DUP_TOP		4
+#define ROT_FOUR	5
+#define NOP		9
+
+#define UNARY_POSITIVE	10
+#define UNARY_NEGATIVE	11
+#define UNARY_NOT	12
+#define UNARY_CONVERT	13
+
+#define UNARY_INVERT	15
+
+#define LIST_APPEND	18
+#define BINARY_POWER	19
+
+#define BINARY_MULTIPLY	20
+#define BINARY_DIVIDE	21
+#define BINARY_MODULO	22
+#define BINARY_ADD	23
+#define BINARY_SUBTRACT	24
+#define BINARY_SUBSCR	25
+#define BINARY_FLOOR_DIVIDE 26
+#define BINARY_TRUE_DIVIDE 27
+#define INPLACE_FLOOR_DIVIDE 28
+#define INPLACE_TRUE_DIVIDE 29
+
+#define SLICE		30
+/* Also uses 31-33 */
+
+#define STORE_SLICE	40
+/* Also uses 41-43 */
+
+#define DELETE_SLICE	50
+/* Also uses 51-53 */
+
+#define INPLACE_ADD	55
+#define INPLACE_SUBTRACT	56
+#define INPLACE_MULTIPLY	57
+#define INPLACE_DIVIDE	58
+#define INPLACE_MODULO	59
+#define STORE_SUBSCR	60
+#define DELETE_SUBSCR	61
+
+#define BINARY_LSHIFT	62
+#define BINARY_RSHIFT	63
+#define BINARY_AND	64
+#define BINARY_XOR	65
+#define BINARY_OR	66
+#define INPLACE_POWER	67
+#define GET_ITER	68
+
+#define PRINT_EXPR	70
+#define PRINT_ITEM	71
+#define PRINT_NEWLINE	72
+#define PRINT_ITEM_TO   73
+#define PRINT_NEWLINE_TO 74
+#define INPLACE_LSHIFT	75
+#define INPLACE_RSHIFT	76
+#define INPLACE_AND	77
+#define INPLACE_XOR	78
+#define INPLACE_OR	79
+#define BREAK_LOOP	80
+
+#define LOAD_LOCALS	82
+#define RETURN_VALUE	83
+#define IMPORT_STAR	84
+#define EXEC_STMT	85
+#define YIELD_VALUE	86
+
+#define POP_BLOCK	87
+#define END_FINALLY	88
+#define BUILD_CLASS	89
+
+#define HAVE_ARGUMENT	90	/* Opcodes from here have an argument: */
+
+#define STORE_NAME	90	/* Index in name list */
+#define DELETE_NAME	91	/* &quot;&quot; */
+#define UNPACK_SEQUENCE	92	/* Number of sequence items */
+#define FOR_ITER	93
+
+#define STORE_ATTR	95	/* Index in name list */
+#define DELETE_ATTR	96	/* &quot;&quot; */
+#define STORE_GLOBAL	97	/* &quot;&quot; */
+#define DELETE_GLOBAL	98	/* &quot;&quot; */
+#define DUP_TOPX	99	/* number of items to duplicate */
+#define LOAD_CONST	100	/* Index in const list */
+#define LOAD_NAME	101	/* Index in name list */
+#define BUILD_TUPLE	102	/* Number of tuple items */
+#define BUILD_LIST	103	/* Number of list items */
+#define BUILD_MAP	104	/* Always zero for now */
+#define LOAD_ATTR	105	/* Index in name list */
+#define COMPARE_OP	106	/* Comparison operator */
+#define IMPORT_NAME	107	/* Index in name list */
+#define IMPORT_FROM	108	/* Index in name list */
+
+#define JUMP_FORWARD	110	/* Number of bytes to skip */
+#define JUMP_IF_FALSE	111	/* &quot;&quot; */
+#define JUMP_IF_TRUE	112	/* &quot;&quot; */
+#define JUMP_ABSOLUTE	113	/* Target byte offset from beginning of code */
+
+#define LOAD_GLOBAL	116	/* Index in name list */
+
+#define CONTINUE_LOOP	119	/* Start of loop (absolute) */
+#define SETUP_LOOP	120	/* Target address (absolute) */
+#define SETUP_EXCEPT	121	/* &quot;&quot; */
+#define SETUP_FINALLY	122	/* &quot;&quot; */
+
+#define LOAD_FAST	124	/* Local variable number */
+#define STORE_FAST	125	/* Local variable number */
+#define DELETE_FAST	126	/* Local variable number */
+
+#define RAISE_VARARGS	130	/* Number of raise arguments (1, 2 or 3) */
+/* CALL_FUNCTION_XXX opcodes defined below depend on this definition */
+#define CALL_FUNCTION	131	/* #args + (#kwargs&lt;&lt;8) */
+#define MAKE_FUNCTION	132	/* #defaults */
+#define BUILD_SLICE 	133	/* Number of items */
+
+#define MAKE_CLOSURE    134     /* #free vars */
+#define LOAD_CLOSURE    135     /* Load free variable from closure */
+#define LOAD_DEREF      136     /* Load and dereference from closure cell */ 
+#define STORE_DEREF     137     /* Store into cell */ 
+
+/* The next 3 opcodes must be contiguous and satisfy
+   (CALL_FUNCTION_VAR - CALL_FUNCTION) &amp; 3 == 1  */
+#define CALL_FUNCTION_VAR          140	/* #args + (#kwargs&lt;&lt;8) */
+#define CALL_FUNCTION_KW           141	/* #args + (#kwargs&lt;&lt;8) */
+#define CALL_FUNCTION_VAR_KW       142	/* #args + (#kwargs&lt;&lt;8) */
+
+/* Support for opargs more than 16 bits long */
+#define EXTENDED_ARG  143
+
+
+enum cmp_op {PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE, PyCmp_GT=Py_GT, PyCmp_GE=Py_GE,
+	     PyCmp_IN, PyCmp_NOT_IN, PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD};
+
+#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OPCODE_H */

Added: trunk/mingw-libs/include/osdefs.h
===================================================================
--- trunk/mingw-libs/include/osdefs.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/osdefs.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,51 @@
+#ifndef Py_OSDEFS_H
+#define Py_OSDEFS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Operating system dependencies */
+
+/* Mod by chrish: QNX has WATCOM, but isn't DOS */
+#if !defined(__QNX__)
+#if defined(MS_WINDOWS) || defined(__BORLANDC__) || defined(__WATCOMC__) || defined(__DJGPP__) || defined(PYOS_OS2)
+#if defined(PYOS_OS2) &amp;&amp; defined(PYCC_GCC)
+#define MAXPATHLEN 260
+#define SEP '/'
+#define ALTSEP '\\'
+#else
+#define SEP '\\'
+#define ALTSEP '/'
+#define MAXPATHLEN 256
+#endif
+#define DELIM ';'
+#endif
+#endif
+
+#ifdef RISCOS
+#define SEP '.'
+#define MAXPATHLEN 256
+#define DELIM ','
+#endif
+
+
+/* Filename separator */
+#ifndef SEP
+#define SEP '/'
+#endif
+
+/* Max pathname length */
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
+/* Search path entry delimiter */
+#ifndef DELIM
+#define DELIM ':'
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OSDEFS_H */

Added: trunk/mingw-libs/include/parsetok.h
===================================================================
--- trunk/mingw-libs/include/parsetok.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/parsetok.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,48 @@
+
+/* Parser-tokenizer link interface */
+
+#ifndef Py_PARSETOK_H
+#define Py_PARSETOK_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    int error;
+    const char *filename;
+    int lineno;
+    int offset;
+    char *text;
+    int token;
+    int expected;
+} perrdetail;
+
+#if 0
+#define PyPARSE_YIELD_IS_KEYWORD	0x0001
+#endif
+
+#define PyPARSE_DONT_IMPLY_DEDENT	0x0002
+
+PyAPI_FUNC(node *) PyParser_ParseString(const char *, grammar *, int,
+                                              perrdetail *);
+PyAPI_FUNC(node *) PyParser_ParseFile (FILE *, const char *, grammar *, int,
+                                             char *, char *, perrdetail *);
+
+PyAPI_FUNC(node *) PyParser_ParseStringFlags(const char *, grammar *, int,
+                                              perrdetail *, int);
+PyAPI_FUNC(node *) PyParser_ParseFileFlags(FILE *, const char *, grammar *,
+						 int, char *, char *,
+						 perrdetail *, int);
+
+PyAPI_FUNC(node *) PyParser_ParseStringFlagsFilename(const char *,
+					      const char *,
+					      grammar *, int,
+                                              perrdetail *, int);
+
+/* Note that he following function is defined in pythonrun.c not parsetok.c. */
+PyAPI_FUNC(void) PyParser_SetError(perrdetail *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PARSETOK_H */

Added: trunk/mingw-libs/include/patchlevel.h
===================================================================
--- trunk/mingw-libs/include/patchlevel.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/patchlevel.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,37 @@
+
+/* Newfangled version identification scheme.
+
+   This scheme was added in Python 1.5.2b2; before that time, only PATCHLEVEL
+   was available.  To test for presence of the scheme, test for
+   defined(PY_MAJOR_VERSION).
+
+   When the major or minor version changes, the VERSION variable in
+   configure.in must also be changed.
+
+   There is also (independent) API version information in modsupport.h.
+*/
+
+/* Values for PY_RELEASE_LEVEL */
+#define PY_RELEASE_LEVEL_ALPHA	0xA
+#define PY_RELEASE_LEVEL_BETA	0xB
+#define PY_RELEASE_LEVEL_GAMMA	0xC     /* For release candidates */
+#define PY_RELEASE_LEVEL_FINAL	0xF	/* Serial should be 0 here */
+					/* Higher for patch releases */
+
+/* Version parsed out into numeric values */
+#define PY_MAJOR_VERSION	2
+#define PY_MINOR_VERSION	4
+#define PY_MICRO_VERSION	0
+#define PY_RELEASE_LEVEL	PY_RELEASE_LEVEL_FINAL
+#define PY_RELEASE_SERIAL	0
+
+/* Version as a string */
+#define PY_VERSION		&quot;2.4&quot;
+
+/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
+   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX &gt;= ... */
+#define PY_VERSION_HEX ((PY_MAJOR_VERSION &lt;&lt; 24) | \
+			(PY_MINOR_VERSION &lt;&lt; 16) | \
+			(PY_MICRO_VERSION &lt;&lt;  8) | \
+			(PY_RELEASE_LEVEL &lt;&lt;  4) | \
+			(PY_RELEASE_SERIAL &lt;&lt; 0))

Added: trunk/mingw-libs/include/pgen.h
===================================================================
--- trunk/mingw-libs/include/pgen.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pgen.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,18 @@
+#ifndef Py_PGEN_H
+#define Py_PGEN_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Parser generator interface */
+
+extern grammar *meta_grammar(void);
+
+struct _node;
+extern grammar *pgen(struct _node *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PGEN_H */

Added: trunk/mingw-libs/include/pgenheaders.h
===================================================================
--- trunk/mingw-libs/include/pgenheaders.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pgenheaders.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,42 @@
+#ifndef Py_PGENHEADERS_H
+#define Py_PGENHEADERS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Include files and extern declarations used by most of the parser. */
+
+#include &quot;Python.h&quot;
+
+PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+
+#define addarc _Py_addarc
+#define addbit _Py_addbit
+#define adddfa _Py_adddfa
+#define addfirstsets _Py_addfirstsets
+#define addlabel _Py_addlabel
+#define addstate _Py_addstate
+#define delbitset _Py_delbitset
+#define dumptree _Py_dumptree
+#define findlabel _Py_findlabel
+#define mergebitset _Py_mergebitset
+#define meta_grammar _Py_meta_grammar
+#define newbitset _Py_newbitset
+#define newgrammar _Py_newgrammar
+#define pgen _Py_pgen
+#define printgrammar _Py_printgrammar
+#define printnonterminals _Py_printnonterminals
+#define printtree _Py_printtree
+#define samebitset _Py_samebitset
+#define showtree _Py_showtree
+#define tok_dump _Py_tok_dump
+#define translatelabels _Py_translatelabels
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PGENHEADERS_H */

Added: trunk/mingw-libs/include/py_curses.h
===================================================================
--- trunk/mingw-libs/include/py_curses.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/py_curses.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,176 @@
+
+#ifndef Py_CURSES_H
+#define Py_CURSES_H
+
+#ifdef __APPLE__
+/*
+** On Mac OS X 10.2 [n]curses.h and stdlib.h use different guards
+** against multiple definition of wchar_t.
+*/
+#ifdef	_BSD_WCHAR_T_DEFINED_
+#define _WCHAR_T
+#endif
+#endif
+
+#ifdef __FreeBSD__
+/*
+** On FreeBSD, [n]curses.h and stdlib.h/wchar.h use different guards
+** against multiple definition of wchar_t and wint_t.
+*/
+#ifdef	_XOPEN_SOURCE_EXTENDED
+#ifndef __FreeBSD_version
+#include &lt;osreldate.h&gt;
+#endif
+#if __FreeBSD_version &gt;= 500000
+#ifndef __wchar_t
+#define __wchar_t
+#endif
+#ifndef __wint_t
+#define __wint_t
+#endif
+#else
+#ifndef _WCHAR_T
+#define _WCHAR_T
+#endif
+#ifndef _WINT_T
+#define _WINT_T
+#endif
+#endif
+#endif
+#endif
+
+#ifdef HAVE_NCURSES_H
+#include &lt;ncurses.h&gt;
+#else
+#include &lt;curses.h&gt;
+#ifdef HAVE_TERM_H
+/* for tigetstr, which is not declared in SysV curses */
+#include &lt;term.h&gt;
+#endif
+#endif
+
+#ifdef HAVE_NCURSES_H
+/* configure was checking &lt;curses.h&gt;, but we will
+   use &lt;ncurses.h&gt;, which has all these features. */
+#ifndef WINDOW_HAS_FLAGS
+#define WINDOW_HAS_FLAGS 1
+#endif
+#ifndef MVWDELCH_IS_EXPRESSION
+#define MVWDELCH_IS_EXPRESSION 1
+#endif
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define PyCurses_API_pointers 4
+
+/* Type declarations */
+
+typedef struct {
+	PyObject_HEAD
+	WINDOW *win;
+} PyCursesWindowObject;
+
+#define PyCursesWindow_Check(v)	 ((v)-&gt;ob_type == &amp;PyCursesWindow_Type)
+
+#ifdef CURSES_MODULE
+/* This section is used when compiling _cursesmodule.c */
+
+#else
+/* This section is used in modules that use the _cursesmodule API */
+
+static void **PyCurses_API;
+
+#define PyCursesWindow_Type (*(PyTypeObject *) PyCurses_API[0])
+#define PyCursesSetupTermCalled  {if (! ((int (*)(void))PyCurses_API[1]) () ) return NULL;}
+#define PyCursesInitialised      {if (! ((int (*)(void))PyCurses_API[2]) () ) return NULL;}
+#define PyCursesInitialisedColor {if (! ((int (*)(void))PyCurses_API[3]) () ) return NULL;}
+
+#define import_curses() \
+{ \
+  PyObject *module = PyImport_ImportModule(&quot;_curses&quot;); \
+  if (module != NULL) { \
+    PyObject *module_dict = PyModule_GetDict(module); \
+    PyObject *c_api_object = PyDict_GetItemString(module_dict, &quot;_C_API&quot;); \
+    if (PyCObject_Check(c_api_object)) { \
+      PyCurses_API = (void **)PyCObject_AsVoidPtr(c_api_object); \
+    } \
+  } \
+}
+#endif
+
+/* general error messages */
+static char *catchall_ERR  = &quot;curses function returned ERR&quot;;
+static char *catchall_NULL = &quot;curses function returned NULL&quot;;
+
+/* Function Prototype Macros - They are ugly but very, very useful. ;-)
+
+   X - function name
+   TYPE - parameter Type
+   ERGSTR - format string for construction of the return value
+   PARSESTR - format string for argument parsing
+   */
+
+#define NoArgNoReturnFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  return PyCursesCheckERR(X(), # X); }
+
+#define NoArgOrFlagNoReturnFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self, PyObject *args) \
+{ \
+  int flag = 0; \
+  PyCursesInitialised \
+  switch(PyTuple_Size(args)) { \
+  case 0: \
+    return PyCursesCheckERR(X(), # X); \
+  case 1: \
+    if (!PyArg_ParseTuple(args, &quot;i;True(1) or False(0)&quot;, &amp;flag)) return NULL; \
+    if (flag) return PyCursesCheckERR(X(), # X); \
+    else return PyCursesCheckERR(no ## X (), # X); \
+  default: \
+    PyErr_SetString(PyExc_TypeError, # X &quot; requires 0 or 1 arguments&quot;); \
+    return NULL; } }
+
+#define NoArgReturnIntFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+ PyCursesInitialised \
+ return PyInt_FromLong((long) X()); }
+
+
+#define NoArgReturnStringFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  return PyString_FromString(X()); }
+
+#define NoArgTrueFalseFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  if (X () == FALSE) { \
+    Py_INCREF(Py_False); \
+    return Py_False; \
+  } \
+  Py_INCREF(Py_True); \
+  return Py_True; }
+
+#define NoArgNoReturnVoidFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  X(); \
+  Py_INCREF(Py_None); \
+  return Py_None; }
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !defined(Py_CURSES_H) */
+
+

Added: trunk/mingw-libs/include/pyconfig.h
===================================================================
--- trunk/mingw-libs/include/pyconfig.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyconfig.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,565 @@
+#ifndef Py_CONFIG_H
+#define Py_CONFIG_H
+
+/* pyconfig.h.  NOT Generated automatically by configure.
+
+This is a manually maintained version used for the Watcom,
+Borland and Microsoft Visual C++ compilers.  It is a
+standard part of the Python distribution.
+
+WINDOWS DEFINES:
+The code specific to Windows should be wrapped around one of
+the following #defines
+
+MS_WIN64 - Code specific to the MS Win64 API
+MS_WIN32 - Code specific to the MS Win32 (and Win64) API (obsolete, this covers all supported APIs)
+MS_WINDOWS - Code specific to Windows, but all versions.
+Py_ENABLE_SHARED - Code if the Python core is built as a DLL.
+
+Also note that neither &quot;_M_IX86&quot; or &quot;_MSC_VER&quot; should be used for
+any purpose other than &quot;Windows Intel x86 specific&quot; and &quot;Microsoft
+compiler specific&quot;.  Therefore, these should be very rare.
+
+
+NOTE: The following symbols are deprecated:
+NT, WIN32, USE_DL_EXPORT, USE_DL_IMPORT, DL_EXPORT, DL_IMPORT
+MS_CORE_DLL.
+
+*/
+
+#include &lt;io.h&gt;
+#define HAVE_SYS_UTIME_H
+#define HAVE_HYPOT
+#define HAVE_TEMPNAM
+#define HAVE_TMPFILE
+#define HAVE_TMPNAM
+#define HAVE_CLOCK
+#define HAVE_STRFTIME
+#define HAVE_STRERROR
+#define DONT_HAVE_SIG_ALARM
+#define DONT_HAVE_SIG_PAUSE
+#define LONG_BIT	32
+#define WORD_BIT 32
+#define PREFIX &quot;&quot;
+#define EXEC_PREFIX &quot;&quot;
+
+#define MS_WIN32 /* only support win32 and greater. */
+#define MS_WINDOWS
+#ifndef PYTHONPATH
+#	define PYTHONPATH &quot;.\\DLLs;.\\lib;.\\lib\\plat-win;.\\lib\\lib-tk&quot;
+#endif
+#define NT_THREADS
+#define WITH_THREAD
+#ifndef NETSCAPE_PI
+#define USE_SOCKET
+#endif
+
+/* Compiler specific defines */
+
+/* ------------------------------------------------------------------------*/
+/* Microsoft C defines _MSC_VER */
+#ifdef _MSC_VER
+
+/* We want COMPILER to expand to a string containing _MSC_VER's *value*.
+ * This is horridly tricky, because the stringization operator only works
+ * on macro arguments, and doesn't evaluate macros passed *as* arguments.
+ * Attempts simpler than the following appear doomed to produce &quot;_MSC_VER&quot;
+ * literally in the string.
+ */
+#define _Py_PASTE_VERSION(SUFFIX) \
+	(&quot;[MSC v.&quot; _Py_STRINGIZE(_MSC_VER) &quot; &quot; SUFFIX &quot;]&quot;)
+/* e.g., this produces, after compile-time string catenation,
+ * 	(&quot;[MSC v.1200 32 bit (Intel)]&quot;)
+ *
+ * _Py_STRINGIZE(_MSC_VER) expands to
+ * _Py_STRINGIZE1((_MSC_VER)) expands to
+ * _Py_STRINGIZE2(_MSC_VER) but as this call is the result of token-pasting
+ *      it's scanned again for macros and so further expands to (under MSVC 6)
+ * _Py_STRINGIZE2(1200) which then expands to
+ * &quot;1200&quot;
+ */
+#define _Py_STRINGIZE(X) _Py_STRINGIZE1((X))
+#define _Py_STRINGIZE1(X) _Py_STRINGIZE2 ## X
+#define _Py_STRINGIZE2(X) #X
+
+/* MSVC defines _WINxx to differentiate the windows platform types
+
+   Note that for compatibility reasons _WIN32 is defined on Win32
+   *and* on Win64. For the same reasons, in Python, MS_WIN32 is
+   defined on Win32 *and* Win64. Win32 only code must therefore be
+   guarded as follows:
+   	#if defined(MS_WIN32) &amp;&amp; !defined(MS_WIN64)
+*/
+#ifdef _WIN64
+#define MS_WIN64
+#endif
+
+/* set the COMPILER */
+#ifdef MS_WIN64
+#ifdef _M_IX86
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (Intel)&quot;)
+#elif defined(_M_IA64)
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (Itanium)&quot;)
+#elif defined(_M_AMD64)
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (AMD64)&quot;)
+#else
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (Unknown)&quot;)
+#endif
+#endif /* MS_WIN64 */
+
+#if defined(MS_WIN32) &amp;&amp; !defined(MS_WIN64)
+#ifdef _M_IX86
+#define COMPILER _Py_PASTE_VERSION(&quot;32 bit (Intel)&quot;)
+#else
+#define COMPILER _Py_PASTE_VERSION(&quot;32 bit (Unknown)&quot;)
+#endif
+#endif /* MS_WIN32 &amp;&amp; !MS_WIN64 */
+
+typedef int pid_t;
+#define hypot _hypot
+
+#include &lt;float.h&gt;
+#define Py_IS_NAN _isnan
+#define Py_IS_INFINITY(X) (!_finite(X) &amp;&amp; !_isnan(X))
+
+#endif /* _MSC_VER */
+
+/* define some ANSI types that are not defined in earlier Win headers */
+#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1200
+/* This file only exists in VC 6.0 or higher */
+#include &lt;basetsd.h&gt;
+#endif
+
+/* ------------------------------------------------------------------------*/
+/* The Borland compiler defines __BORLANDC__ */
+/* XXX These defines are likely incomplete, but should be easy to fix. */
+#ifdef __BORLANDC__
+#define COMPILER &quot;[Borland]&quot;
+
+#ifdef _WIN32
+/* tested with BCC 5.5 (__BORLANDC__ &gt;= 0x0550)
+ */
+
+typedef int pid_t;
+/* BCC55 seems to understand __declspec(dllimport), it is used in its
+   own header files (winnt.h, ...) - so we can do nothing and get the default*/
+
+#undef HAVE_SYS_UTIME_H
+#define HAVE_UTIME_H
+#define HAVE_DIRENT_H
+
+/* rename a few functions for the Borland compiler */
+#include &lt;io.h&gt;
+#define _chsize chsize
+#define _setmode setmode
+
+#else /* !_WIN32 */
+#error &quot;Only Win32 and later are supported&quot;
+#endif /* !_WIN32 */
+
+#endif /* BORLANDC */
+
+/* ------------------------------------------------------------------------*/
+/* egcs/gnu-win32 defines __GNUC__ and _WIN32 */
+#if defined(__GNUC__) &amp;&amp; defined(_WIN32)
+/* XXX These defines are likely incomplete, but should be easy to fix.
+   They should be complete enough to build extension modules. */
+/* Suggested by Rene Liebscher &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">R.Liebscher at gmx.de</A>&gt; to avoid a GCC 2.91.*
+   bug that requires structure imports.  More recent versions of the
+   compiler don't exhibit this bug.
+*/
+#if (__GNUC__==2) &amp;&amp; (__GNUC_MINOR__&lt;=91)
+#warning &quot;Please use an up-to-date version of gcc! (&gt;2.91 recommended)&quot;
+#endif
+
+#define COMPILER &quot;[gcc]&quot;
+#define hypot _hypot
+#define PY_LONG_LONG long long
+#endif /* GNUC */
+
+/* ------------------------------------------------------------------------*/
+/* lcc-win32 defines __LCC__ */
+#if defined(__LCC__)
+/* XXX These defines are likely incomplete, but should be easy to fix.
+   They should be complete enough to build extension modules. */
+
+#define COMPILER &quot;[lcc-win32]&quot;
+typedef int pid_t;
+/* __declspec() is supported here too - do nothing to get the defaults */
+
+#endif /* LCC */
+
+/* ------------------------------------------------------------------------*/
+/* End of compilers - finish up */
+
+#ifndef NO_STDIO_H
+#	include &lt;stdio.h&gt;
+#endif
+
+/* 64 bit ints are usually spelt __int64 unless compiler has overridden */
+#define HAVE_LONG_LONG 1
+#ifndef PY_LONG_LONG
+#	define PY_LONG_LONG __int64
+#endif
+
+/* For Windows the Python core is in a DLL by default.  Test
+Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
+#if !defined(MS_NO_COREDLL) &amp;&amp; !defined(Py_NO_ENABLE_SHARED)
+#	define Py_ENABLE_SHARED 1 /* standard symbol for shared library */
+#	define MS_COREDLL	/* deprecated old symbol */
+#endif /* !MS_NO_COREDLL &amp;&amp; ... */
+
+/* Deprecated USE_DL_EXPORT macro - please use Py_BUILD_CORE */
+#ifdef USE_DL_EXPORT
+#	define Py_BUILD_CORE
+#endif /* USE_DL_EXPORT */
+
+/*  All windows compilers that use this header support __declspec */
+#define HAVE_DECLSPEC_DLL
+
+/* For an MSVC DLL, we can nominate the .lib files used by extensions */
+#ifdef MS_COREDLL
+#	ifndef Py_BUILD_CORE /* not building the core - must be an ext */
+#		if defined(_MSC_VER)
+			/* So MSVC users need not specify the .lib file in
+			their Makefile (other compilers are generally
+			taken care of by distutils.) */
+#			ifdef _DEBUG
+#				pragma comment(lib,&quot;python24_d.lib&quot;)
+#			else
+#				pragma comment(lib,&quot;python24.lib&quot;)
+#			endif /* _DEBUG */
+#		endif /* _MSC_VER */
+#	endif /* Py_BUILD_CORE */
+#endif /* MS_COREDLL */
+
+#if defined(MS_WIN64)
+/* maintain &quot;win32&quot; sys.platform for backward compatibility of Python code,
+   the Win64 API should be close enough to the Win32 API to make this
+   preferable */
+#	define PLATFORM &quot;win32&quot;
+#	define SIZEOF_VOID_P 8
+#	define SIZEOF_TIME_T 8
+#	define SIZEOF_OFF_T 4
+#	define SIZEOF_FPOS_T 8
+#	define SIZEOF_HKEY 8
+/* configure.in defines HAVE_LARGEFILE_SUPPORT iff HAVE_LONG_LONG,
+   sizeof(off_t) &gt; sizeof(long), and sizeof(PY_LONG_LONG) &gt;= sizeof(off_t).
+   On Win64 the second condition is not true, but if fpos_t replaces off_t
+   then this is true. The uses of HAVE_LARGEFILE_SUPPORT imply that Win64
+   should define this. */
+#	define HAVE_LARGEFILE_SUPPORT
+#elif defined(MS_WIN32)
+#	define PLATFORM &quot;win32&quot;
+#	define HAVE_LARGEFILE_SUPPORT
+#	define SIZEOF_VOID_P 4
+#	define SIZEOF_TIME_T 4
+#	define SIZEOF_OFF_T 4
+#	define SIZEOF_FPOS_T 8
+#	define SIZEOF_HKEY 4
+#endif
+
+#ifdef _DEBUG
+#	define Py_DEBUG
+#endif
+
+
+#ifdef MS_WIN32
+
+#define SIZEOF_SHORT 2
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+#define SIZEOF_LONG_LONG 8
+
+/* VC 7.1 has them and VC 6.0 does not.  VC 6.0 has a version number of 1200.
+   If some compiler does not provide them, modify the #if appropriately. */
+#if defined(_MSC_VER)
+#if _MSC_VER &gt; 1200
+#define HAVE_UINTPTR_T 1
+#define HAVE_INTPTR_T 1
+#endif  /* _MSC_VER &gt; 1200  */ 
+#endif  /* _MSC_VER */
+
+#endif
+
+/* Fairly standard from here! */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define to empty if the keyword does not work.  */
+/* #define const  */
+
+/* Define if you have dirent.h.  */
+/* #define DIRENT 1 */
+
+/* Define to the type of elements in the array set by `getgroups'.
+   Usually this is either `int' or `gid_t'.  */
+/* #undef GETGROUPS_T */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef gid_t */
+
+/* Define if your struct tm has tm_zone.  */
+/* #undef HAVE_TM_ZONE */
+
+/* Define if you don't have tm_zone but do have the external array
+   tzname.  */
+#define HAVE_TZNAME
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef mode_t */
+
+/* Define if you don't have dirent.h, but have ndir.h.  */
+/* #undef NDIR */
+
+/* Define to `long' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef off_t */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef pid_t */
+
+/* Define if the system does not provide POSIX.1 features except
+   with this defined.  */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define to `unsigned' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef size_t */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+#if _MSC_VER + 0 &gt;= 1300
+/* VC.NET typedefs socklen_t in ws2tcpip.h. */
+#else
+#define socklen_t int
+#endif
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Define if you don't have dirent.h, but have sys/dir.h.  */
+/* #undef SYSDIR */
+
+/* Define if you don't have dirent.h, but have sys/ndir.h.  */
+/* #undef SYSNDIR */
+
+/* Define if you can safely include both &lt;sys/time.h&gt; and &lt;time.h&gt;.  */
+/* #undef TIME_WITH_SYS_TIME */
+
+/* Define if your &lt;sys/time.h&gt; declares struct tm.  */
+/* #define TM_IN_SYS_TIME 1 */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef uid_t */
+
+/* Define if the closedir function returns void instead of int.  */
+/* #undef VOID_CLOSEDIR */
+
+/* Define if getpgrp() must be called as getpgrp(0)
+   and (consequently) setpgrp() as setpgrp(0, 0). */
+/* #undef GETPGRP_HAVE_ARGS */
+
+/* Define this if your time.h defines altzone */
+/* #define HAVE_ALTZONE */
+
+/* Define if you have the putenv function.  */
+#define HAVE_PUTENV
+
+/* Define if your compiler supports function prototypes */
+#define HAVE_PROTOTYPES
+
+/* Define if  you can safely include both &lt;sys/select.h&gt; and &lt;sys/time.h&gt;
+   (which you can't on SCO ODT 3.0). */
+/* #undef SYS_SELECT_WITH_SYS_TIME */
+
+/* Define if you want documentation strings in extension modules */
+#define WITH_DOC_STRINGS 1
+
+/* Define if you want to compile in rudimentary thread support */
+/* #undef WITH_THREAD */
+
+/* Define if you want to use the GNU readline library */
+/* #define WITH_READLINE 1 */
+
+/* Define if you want to have a Unicode type. */
+#define Py_USING_UNICODE
+
+/* Define as the integral type used for Unicode representation. */
+#define PY_UNICODE_TYPE unsigned short
+
+/* Define as the size of the unicode type. */
+#define Py_UNICODE_SIZE SIZEOF_SHORT
+
+/* Define if you have a useable wchar_t type defined in wchar.h; useable
+   means wchar_t must be 16-bit unsigned type. (see
+   Include/unicodeobject.h). */
+#if Py_UNICODE_SIZE == 2
+#define HAVE_USABLE_WCHAR_T
+
+/* Define to indicate that the Python Unicode representation can be passed
+   as-is to Win32 Wide API.  */
+#define Py_WIN_WIDE_FILENAMES
+#endif
+
+/* Use Python's own small-block memory-allocator. */
+#define WITH_PYMALLOC 1
+
+/* Define if you have clock.  */
+/* #define HAVE_CLOCK */
+
+/* Define when any dynamic module loading is enabled */
+#define HAVE_DYNAMIC_LOADING
+
+/* Define if you have ftime.  */
+#define HAVE_FTIME
+
+/* Define if you have getpeername.  */
+#define HAVE_GETPEERNAME
+
+/* Define if you have getpgrp.  */
+/* #undef HAVE_GETPGRP */
+
+/* Define if you have getpid.  */
+#define HAVE_GETPID
+
+/* Define if you have gettimeofday.  */
+/* #undef HAVE_GETTIMEOFDAY */
+
+/* Define if you have getwd.  */
+/* #undef HAVE_GETWD */
+
+/* Define if you have lstat.  */
+/* #undef HAVE_LSTAT */
+
+/* Define if you have the mktime function.  */
+#define HAVE_MKTIME
+
+/* Define if you have nice.  */
+/* #undef HAVE_NICE */
+
+/* Define if you have readlink.  */
+/* #undef HAVE_READLINK */
+
+/* Define if you have select.  */
+/* #undef HAVE_SELECT */
+
+/* Define if you have setpgid.  */
+/* #undef HAVE_SETPGID */
+
+/* Define if you have setpgrp.  */
+/* #undef HAVE_SETPGRP */
+
+/* Define if you have setsid.  */
+/* #undef HAVE_SETSID */
+
+/* Define if you have setvbuf.  */
+#define HAVE_SETVBUF
+
+/* Define if you have siginterrupt.  */
+/* #undef HAVE_SIGINTERRUPT */
+
+/* Define if you have symlink.  */
+/* #undef HAVE_SYMLINK */
+
+/* Define if you have tcgetpgrp.  */
+/* #undef HAVE_TCGETPGRP */
+
+/* Define if you have tcsetpgrp.  */
+/* #undef HAVE_TCSETPGRP */
+
+/* Define if you have times.  */
+/* #undef HAVE_TIMES */
+
+/* Define if you have uname.  */
+/* #undef HAVE_UNAME */
+
+/* Define if you have waitpid.  */
+/* #undef HAVE_WAITPID */
+
+/* Define to 1 if you have the `wcscoll' function. */
+#define HAVE_WCSCOLL 1
+
+/* Define if you have the &lt;dlfcn.h&gt; header file.  */
+/* #undef HAVE_DLFCN_H */
+
+/* Define if you have the &lt;fcntl.h&gt; header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the &lt;stdarg.h&gt; prototypes.  */
+#define HAVE_STDARG_PROTOTYPES
+
+/* Define if you have the &lt;stddef.h&gt; header file.  */
+#define HAVE_STDDEF_H 1
+
+/* Define if you have the &lt;sys/audioio.h&gt; header file.  */
+/* #undef HAVE_SYS_AUDIOIO_H */
+
+/* Define if you have the &lt;sys/param.h&gt; header file.  */
+/* #define HAVE_SYS_PARAM_H 1 */
+
+/* Define if you have the &lt;sys/select.h&gt; header file.  */
+/* #define HAVE_SYS_SELECT_H 1 */
+
+/* Define if you have the &lt;sys/time.h&gt; header file.  */
+/* #define HAVE_SYS_TIME_H 1 */
+
+/* Define if you have the &lt;sys/times.h&gt; header file.  */
+/* #define HAVE_SYS_TIMES_H 1 */
+
+/* Define if you have the &lt;sys/un.h&gt; header file.  */
+/* #define HAVE_SYS_UN_H 1 */
+
+/* Define if you have the &lt;sys/utime.h&gt; header file.  */
+/* #define HAVE_SYS_UTIME_H 1 */
+
+/* Define if you have the &lt;sys/utsname.h&gt; header file.  */
+/* #define HAVE_SYS_UTSNAME_H 1 */
+
+/* Define if you have the &lt;thread.h&gt; header file.  */
+/* #undef HAVE_THREAD_H */
+
+/* Define if you have the &lt;unistd.h&gt; header file.  */
+/* #define HAVE_UNISTD_H 1 */
+
+/* Define if you have the &lt;utime.h&gt; header file.  */
+/* #define HAVE_UTIME_H 1 */
+
+/* Define if the compiler provides a wchar.h header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define if you have the dl library (-ldl).  */
+/* #undef HAVE_LIBDL */
+
+/* Define if you have the mpc library (-lmpc).  */
+/* #undef HAVE_LIBMPC */
+
+/* Define if you have the nsl library (-lnsl).  */
+#define HAVE_LIBNSL 1
+
+/* Define if you have the seq library (-lseq).  */
+/* #undef HAVE_LIBSEQ */
+
+/* Define if you have the socket library (-lsocket).  */
+#define HAVE_LIBSOCKET 1
+
+/* Define if you have the sun library (-lsun).  */
+/* #undef HAVE_LIBSUN */
+
+/* Define if you have the termcap library (-ltermcap).  */
+/* #undef HAVE_LIBTERMCAP */
+
+/* Define if you have the termlib library (-ltermlib).  */
+/* #undef HAVE_LIBTERMLIB */
+
+/* Define if you have the thread library (-lthread).  */
+/* #undef HAVE_LIBTHREAD */
+#endif /* !Py_CONFIG_H */

Added: trunk/mingw-libs/include/pydebug.h
===================================================================
--- trunk/mingw-libs/include/pydebug.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pydebug.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,34 @@
+
+#ifndef Py_PYDEBUG_H
+#define Py_PYDEBUG_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(int) Py_DebugFlag;
+PyAPI_DATA(int) Py_VerboseFlag;
+PyAPI_DATA(int) Py_InteractiveFlag;
+PyAPI_DATA(int) Py_OptimizeFlag;
+PyAPI_DATA(int) Py_NoSiteFlag;
+PyAPI_DATA(int) Py_UseClassExceptionsFlag;
+PyAPI_DATA(int) Py_FrozenFlag;
+PyAPI_DATA(int) Py_TabcheckFlag;
+PyAPI_DATA(int) Py_UnicodeFlag;
+PyAPI_DATA(int) Py_IgnoreEnvironmentFlag;
+PyAPI_DATA(int) Py_DivisionWarningFlag;
+/* _XXX Py_QnewFlag should go away in 3.0.  It's true iff -Qnew is passed,
+  on the command line, and is used in 2.2 by ceval.c to make all &quot;/&quot; divisions
+  true divisions (which they will be in 3.0). */
+PyAPI_DATA(int) _Py_QnewFlag;
+
+/* this is a wrapper around getenv() that pays attention to
+   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like
+   PYTHONPATH and PYTHONHOME from the environment */
+#define Py_GETENV(s) (Py_IgnoreEnvironmentFlag ? NULL : getenv(s))
+
+PyAPI_FUNC(void) Py_FatalError(const char *message);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYDEBUG_H */

Added: trunk/mingw-libs/include/pyerrors.h
===================================================================
--- trunk/mingw-libs/include/pyerrors.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyerrors.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,234 @@
+#ifndef Py_ERRORS_H
+#define Py_ERRORS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Error handling definitions */
+
+PyAPI_FUNC(void) PyErr_SetNone(PyObject *);
+PyAPI_FUNC(void) PyErr_SetObject(PyObject *, PyObject *);
+PyAPI_FUNC(void) PyErr_SetString(PyObject *, const char *);
+PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
+PyAPI_FUNC(void) PyErr_Clear(void);
+PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
+PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
+
+/* Error testing and normalization */
+PyAPI_FUNC(int) PyErr_GivenExceptionMatches(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyErr_ExceptionMatches(PyObject *);
+PyAPI_FUNC(void) PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);
+
+
+/* Predefined exceptions */
+
+PyAPI_DATA(PyObject *) PyExc_Exception;
+PyAPI_DATA(PyObject *) PyExc_StopIteration;
+PyAPI_DATA(PyObject *) PyExc_StandardError;
+PyAPI_DATA(PyObject *) PyExc_ArithmeticError;
+PyAPI_DATA(PyObject *) PyExc_LookupError;
+
+PyAPI_DATA(PyObject *) PyExc_AssertionError;
+PyAPI_DATA(PyObject *) PyExc_AttributeError;
+PyAPI_DATA(PyObject *) PyExc_EOFError;
+PyAPI_DATA(PyObject *) PyExc_FloatingPointError;
+PyAPI_DATA(PyObject *) PyExc_EnvironmentError;
+PyAPI_DATA(PyObject *) PyExc_IOError;
+PyAPI_DATA(PyObject *) PyExc_OSError;
+PyAPI_DATA(PyObject *) PyExc_ImportError;
+PyAPI_DATA(PyObject *) PyExc_IndexError;
+PyAPI_DATA(PyObject *) PyExc_KeyError;
+PyAPI_DATA(PyObject *) PyExc_KeyboardInterrupt;
+PyAPI_DATA(PyObject *) PyExc_MemoryError;
+PyAPI_DATA(PyObject *) PyExc_NameError;
+PyAPI_DATA(PyObject *) PyExc_OverflowError;
+PyAPI_DATA(PyObject *) PyExc_RuntimeError;
+PyAPI_DATA(PyObject *) PyExc_NotImplementedError;
+PyAPI_DATA(PyObject *) PyExc_SyntaxError;
+PyAPI_DATA(PyObject *) PyExc_IndentationError;
+PyAPI_DATA(PyObject *) PyExc_TabError;
+PyAPI_DATA(PyObject *) PyExc_ReferenceError;
+PyAPI_DATA(PyObject *) PyExc_SystemError;
+PyAPI_DATA(PyObject *) PyExc_SystemExit;
+PyAPI_DATA(PyObject *) PyExc_TypeError;
+PyAPI_DATA(PyObject *) PyExc_UnboundLocalError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeEncodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeDecodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeTranslateError;
+PyAPI_DATA(PyObject *) PyExc_ValueError;
+PyAPI_DATA(PyObject *) PyExc_ZeroDivisionError;
+#ifdef MS_WINDOWS
+PyAPI_DATA(PyObject *) PyExc_WindowsError;
+#endif
+#ifdef __VMS
+PyAPI_DATA(PyObject *) PyExc_VMSError;
+#endif
+
+PyAPI_DATA(PyObject *) PyExc_MemoryErrorInst;
+
+/* Predefined warning categories */
+PyAPI_DATA(PyObject *) PyExc_Warning;
+PyAPI_DATA(PyObject *) PyExc_UserWarning;
+PyAPI_DATA(PyObject *) PyExc_DeprecationWarning;
+PyAPI_DATA(PyObject *) PyExc_PendingDeprecationWarning;
+PyAPI_DATA(PyObject *) PyExc_SyntaxWarning;
+/* PyExc_OverflowWarning will go away for Python 2.5 */
+PyAPI_DATA(PyObject *) PyExc_OverflowWarning;
+PyAPI_DATA(PyObject *) PyExc_RuntimeWarning;
+PyAPI_DATA(PyObject *) PyExc_FutureWarning;
+
+
+/* Convenience functions */
+
+PyAPI_FUNC(int) PyErr_BadArgument(void);
+PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
+	PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(PyObject *, char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithUnicodeFilename(
+	PyObject *, Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+
+PyAPI_FUNC(PyObject *) PyErr_Format(PyObject *, const char *, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 2, 3)));
+
+#ifdef MS_WINDOWS
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilenameObject(
+	int, const char *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
+	int, const char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithUnicodeFilename(
+	int, const Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
+	PyObject *,int, PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
+	PyObject *,int, const char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithUnicodeFilename(
+	PyObject *,int, const Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
+#endif /* MS_WINDOWS */
+
+/* Export the old function so that the existing API remains available: */
+PyAPI_FUNC(void) PyErr_BadInternalCall(void);
+PyAPI_FUNC(void) _PyErr_BadInternalCall(char *filename, int lineno);
+/* Mask the old API with a call to the new API for code compiled under
+   Python 2.0: */
+#define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)
+
+/* Function to create a new exception */
+PyAPI_FUNC(PyObject *) PyErr_NewException(char *name, PyObject *base,
+                                         PyObject *dict);
+PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);
+
+/* Issue a warning or exception */
+PyAPI_FUNC(int) PyErr_Warn(PyObject *, char *);
+PyAPI_FUNC(int) PyErr_WarnExplicit(PyObject *, const char *,
+				   const char *, int, 
+				   const char *, PyObject *);
+
+/* In sigcheck.c or signalmodule.c */
+PyAPI_FUNC(int) PyErr_CheckSignals(void);
+PyAPI_FUNC(void) PyErr_SetInterrupt(void);
+
+/* Support for adding program text to SyntaxErrors */
+PyAPI_FUNC(void) PyErr_SyntaxLocation(const char *, int);
+PyAPI_FUNC(PyObject *) PyErr_ProgramText(const char *, int);
+
+#ifdef Py_USING_UNICODE
+/* The following functions are used to create and modify unicode
+   exceptions from C */
+
+/* create a UnicodeDecodeError object */
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
+	const char *, const char *, int, int, int, const char *);
+
+/* create a UnicodeEncodeError object */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_Create(
+	const char *, const Py_UNICODE *, int, int, int, const char *);
+
+/* create a UnicodeTranslateError object */
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_Create(
+	const Py_UNICODE *, int, int, int, const char *);
+
+/* get the encoding attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);
+
+/* get the object attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);
+
+/* get the value of the start attribute (the int * may not be NULL)
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_GetStart(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_GetStart(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_GetStart(PyObject *, int *);
+
+/* assign a new value to the start attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetStart(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetStart(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetStart(PyObject *, int);
+
+/* get the value of the end attribute (the int *may not be NULL)
+ return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_GetEnd(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_GetEnd(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_GetEnd(PyObject *, int *);
+
+/* assign a new value to the end attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetEnd(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetEnd(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, int);
+
+/* get the value of the reason attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);
+
+/* assign a new value to the reason attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetReason(
+	PyObject *, const char *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetReason(
+	PyObject *, const char *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetReason(
+	PyObject *, const char *);
+#endif
+
+
+/* These APIs aren't really part of the error implementation, but
+   often needed to format error messages; the native C lib APIs are
+   not available on all platforms, which is why we provide emulations
+   for those platforms in Python/mysnprintf.c,
+   WARNING:  The return value of snprintf varies across platforms; do
+   not rely on any particular behavior; eventually the C99 defn may
+   be reliable.
+*/
+#if defined(MS_WIN32) &amp;&amp; !defined(HAVE_SNPRINTF)
+# define HAVE_SNPRINTF
+# define snprintf _snprintf
+# define vsnprintf _vsnprintf
+#endif
+
+#include &lt;stdarg.h&gt;
+PyAPI_FUNC(int) PyOS_snprintf(char *str, size_t size, const char  *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 3, 4)));
+PyAPI_FUNC(int) PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)
+			Py_GCC_ATTRIBUTE((format(printf, 3, 0)));
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ERRORS_H */

Added: trunk/mingw-libs/include/pyfpe.h
===================================================================
--- trunk/mingw-libs/include/pyfpe.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyfpe.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,176 @@
+#ifndef Py_PYFPE_H
+#define Py_PYFPE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+/*
+     ---------------------------------------------------------------------  
+    /                       Copyright (c) 1996.                           \ 
+   |          The Regents of the University of California.                 |
+   |                        All rights reserved.                           |
+   |                                                                       |
+   |   Permission to use, copy, modify, and distribute this software for   |
+   |   any purpose without fee is hereby granted, provided that this en-   |
+   |   tire notice is included in all copies of any software which is or   |
+   |   includes  a  copy  or  modification  of  this software and in all   |
+   |   copies of the supporting documentation for such software.           |
+   |                                                                       |
+   |   This  work was produced at the University of California, Lawrence   |
+   |   Livermore National Laboratory under  contract  no.  W-7405-ENG-48   |
+   |   between  the  U.S.  Department  of  Energy and The Regents of the   |
+   |   University of California for the operation of UC LLNL.              |
+   |                                                                       |
+   |                              DISCLAIMER                               |
+   |                                                                       |
+   |   This  software was prepared as an account of work sponsored by an   |
+   |   agency of the United States Government. Neither the United States   |
+   |   Government  nor the University of California nor any of their em-   |
+   |   ployees, makes any warranty, express or implied, or  assumes  any   |
+   |   liability  or  responsibility  for the accuracy, completeness, or   |
+   |   usefulness of any information,  apparatus,  product,  or  process   |
+   |   disclosed,   or  represents  that  its  use  would  not  infringe   |
+   |   privately-owned rights. Reference herein to any specific  commer-   |
+   |   cial  products,  process,  or  service  by trade name, trademark,   |
+   |   manufacturer, or otherwise, does not  necessarily  constitute  or   |
+   |   imply  its endorsement, recommendation, or favoring by the United   |
+   |   States Government or the University of California. The views  and   |
+   |   opinions  of authors expressed herein do not necessarily state or   |
+   |   reflect those of the United States Government or  the  University   |
+   |   of  California,  and shall not be used for advertising or product   |
+    \  endorsement purposes.                                              / 
+     ---------------------------------------------------------------------  
+*/
+
+/*
+ *       Define macros for handling SIGFPE.
+ *       Lee Busby, LLNL, November, 1996
+ *       <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">busby1 at llnl.gov</A>
+ * 
+ *********************************************
+ * Overview of the system for handling SIGFPE:
+ * 
+ * This file (Include/pyfpe.h) defines a couple of &quot;wrapper&quot; macros for
+ * insertion into your Python C code of choice. Their proper use is
+ * discussed below. The file Python/pyfpe.c defines a pair of global
+ * variables PyFPE_jbuf and PyFPE_counter which are used by the signal
+ * handler for SIGFPE to decide if a particular exception was protected
+ * by the macros. The signal handler itself, and code for enabling the
+ * generation of SIGFPE in the first place, is in a (new) Python module
+ * named fpectl. This module is standard in every respect. It can be loaded
+ * either statically or dynamically as you choose, and like any other
+ * Python module, has no effect until you import it.
+ * 
+ * In the general case, there are three steps toward handling SIGFPE in any
+ * Python code:
+ * 
+ * 1) Add the *_PROTECT macros to your C code as required to protect
+ *    dangerous floating point sections.
+ * 
+ * 2) Turn on the inclusion of the code by adding the ``--with-fpectl''
+ *    flag at the time you run configure.  If the fpectl or other modules
+ *    which use the *_PROTECT macros are to be dynamically loaded, be
+ *    sure they are compiled with WANT_SIGFPE_HANDLER defined.
+ * 
+ * 3) When python is built and running, import fpectl, and execute
+ *    fpectl.turnon_sigfpe(). This sets up the signal handler and enables
+ *    generation of SIGFPE whenever an exception occurs. From this point
+ *    on, any properly trapped SIGFPE should result in the Python
+ *    FloatingPointError exception.
+ * 
+ * Step 1 has been done already for the Python kernel code, and should be
+ * done soon for the NumPy array package.  Step 2 is usually done once at
+ * python install time. Python's behavior with respect to SIGFPE is not
+ * changed unless you also do step 3. Thus you can control this new
+ * facility at compile time, or run time, or both.
+ * 
+ ******************************** 
+ * Using the macros in your code:
+ * 
+ * static PyObject *foobar(PyObject *self,PyObject *args)
+ * {
+ *     ....
+ *     PyFPE_START_PROTECT(&quot;Error in foobar&quot;, return 0)
+ *     result = dangerous_op(somearg1, somearg2, ...);
+ *     PyFPE_END_PROTECT(result)
+ *     ....
+ * }
+ * 
+ * If a floating point error occurs in dangerous_op, foobar returns 0 (NULL),
+ * after setting the associated value of the FloatingPointError exception to
+ * &quot;Error in foobar&quot;. ``Dangerous_op'' can be a single operation, or a block
+ * of code, function calls, or any combination, so long as no alternate
+ * return is possible before the PyFPE_END_PROTECT macro is reached.
+ * 
+ * The macros can only be used in a function context where an error return
+ * can be recognized as signaling a Python exception. (Generally, most
+ * functions that return a PyObject * will qualify.)
+ * 
+ * Guido's original design suggestion for PyFPE_START_PROTECT and
+ * PyFPE_END_PROTECT had them open and close a local block, with a locally
+ * defined jmp_buf and jmp_buf pointer. This would allow recursive nesting
+ * of the macros. The Ansi C standard makes it clear that such local
+ * variables need to be declared with the &quot;volatile&quot; type qualifier to keep
+ * setjmp from corrupting their values. Some current implementations seem
+ * to be more restrictive. For example, the HPUX man page for setjmp says
+ * 
+ *   Upon the return from a setjmp() call caused by a longjmp(), the
+ *   values of any non-static local variables belonging to the routine
+ *   from which setjmp() was called are undefined. Code which depends on
+ *   such values is not guaranteed to be portable.
+ * 
+ * I therefore decided on a more limited form of nesting, using a counter
+ * variable (PyFPE_counter) to keep track of any recursion.  If an exception
+ * occurs in an ``inner'' pair of macros, the return will apparently
+ * come from the outermost level.
+ * 
+ */
+
+#ifdef WANT_SIGFPE_HANDLER
+#include &lt;signal.h&gt;
+#include &lt;setjmp.h&gt;
+#include &lt;math.h&gt;
+extern jmp_buf PyFPE_jbuf;
+extern int PyFPE_counter;
+extern double PyFPE_dummy(void *);
+
+#define PyFPE_START_PROTECT(err_string, leave_stmt) \
+if (!PyFPE_counter++ &amp;&amp; setjmp(PyFPE_jbuf)) { \
+	PyErr_SetString(PyExc_FloatingPointError, err_string); \
+	PyFPE_counter = 0; \
+	leave_stmt; \
+}
+
+/*
+ * This (following) is a heck of a way to decrement a counter. However,
+ * unless the macro argument is provided, code optimizers will sometimes move
+ * this statement so that it gets executed *before* the unsafe expression
+ * which we're trying to protect.  That pretty well messes things up,
+ * of course.
+ * 
+ * If the expression(s) you're trying to protect don't happen to return a
+ * value, you will need to manufacture a dummy result just to preserve the
+ * correct ordering of statements.  Note that the macro passes the address
+ * of its argument (so you need to give it something which is addressable).
+ * If your expression returns multiple results, pass the last such result
+ * to PyFPE_END_PROTECT.
+ * 
+ * Note that PyFPE_dummy returns a double, which is cast to int.
+ * This seeming insanity is to tickle the Floating Point Unit (FPU).
+ * If an exception has occurred in a preceding floating point operation,
+ * some architectures (notably Intel 80x86) will not deliver the interrupt
+ * until the *next* floating point operation.  This is painful if you've
+ * already decremented PyFPE_counter.
+ */
+#define PyFPE_END_PROTECT(v) PyFPE_counter -= (int)PyFPE_dummy(&amp;(v));
+
+#else
+
+#define PyFPE_START_PROTECT(err_string, leave_stmt)
+#define PyFPE_END_PROTECT(v)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYFPE_H */

Added: trunk/mingw-libs/include/pygetopt.h
===================================================================
--- trunk/mingw-libs/include/pygetopt.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pygetopt.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,17 @@
+
+#ifndef Py_PYGETOPT_H
+#define Py_PYGETOPT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(int) _PyOS_opterr;
+PyAPI_DATA(int) _PyOS_optind;
+PyAPI_DATA(char *) _PyOS_optarg;
+
+PyAPI_FUNC(int) _PyOS_GetOpt(int argc, char **argv, char *optstring);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYGETOPT_H */

Added: trunk/mingw-libs/include/pymactoolbox.h
===================================================================
--- trunk/mingw-libs/include/pymactoolbox.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pymactoolbox.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,189 @@
+/*
+** pymactoolbox.h - globals defined in mactoolboxglue.c
+*/
+#ifndef Py_PYMACTOOLBOX_H
+#define Py_PYMACTOOLBOX_H
+#ifdef __cplusplus
+	extern &quot;C&quot; {
+#endif
+
+#include &lt;Carbon/Carbon.h&gt;
+#include &lt;QuickTime/QuickTime.h&gt;
+
+/*
+** Helper routines for error codes and such.
+*/
+char *PyMac_StrError(int);			/* strerror with mac errors */
+extern PyObject *PyMac_OSErrException;		/* Exception for OSErr */
+PyObject *PyMac_GetOSErrException(void);	/* Initialize &amp; return it */
+PyObject *PyErr_Mac(PyObject *, int);		/* Exception with a mac error */
+PyObject *PyMac_Error(OSErr);			/* Uses PyMac_GetOSErrException */
+extern OSErr PyMac_GetFullPathname(FSSpec *, char *, int); /* convert
+							      fsspec-&gt;path */
+/*
+** These conversion routines are defined in mactoolboxglue.c itself.
+*/
+int PyMac_GetOSType(PyObject *, OSType *);	/* argument parser for OSType */
+PyObject *PyMac_BuildOSType(OSType);		/* Convert OSType to PyObject */
+
+PyObject *PyMac_BuildNumVersion(NumVersion);/* Convert NumVersion to PyObject */
+
+int PyMac_GetStr255(PyObject *, Str255);	/* argument parser for Str255 */
+PyObject *PyMac_BuildStr255(Str255);		/* Convert Str255 to PyObject */
+PyObject *PyMac_BuildOptStr255(Str255);		/* Convert Str255 to PyObject,
+						   NULL to None */
+
+int PyMac_GetRect(PyObject *, Rect *);		/* argument parser for Rect */
+PyObject *PyMac_BuildRect(Rect *);		/* Convert Rect to PyObject */
+
+int PyMac_GetPoint(PyObject *, Point *);	/* argument parser for Point */
+PyObject *PyMac_BuildPoint(Point);		/* Convert Point to PyObject */
+
+int PyMac_GetEventRecord(PyObject *, EventRecord *); /* argument parser for
+							EventRecord */
+PyObject *PyMac_BuildEventRecord(EventRecord *); /* Convert EventRecord to
+						    PyObject */
+
+int PyMac_GetFixed(PyObject *, Fixed *);	/* argument parser for Fixed */
+PyObject *PyMac_BuildFixed(Fixed);		/* Convert Fixed to PyObject */
+int PyMac_Getwide(PyObject *, wide *);		/* argument parser for wide */
+PyObject *PyMac_Buildwide(wide *);		/* Convert wide to PyObject */
+
+/*
+** The rest of the routines are implemented by extension modules. If they are
+** dynamically loaded mactoolboxglue will contain a stub implementation of the
+** routine, which imports the module, whereupon the module's init routine will
+** communicate the routine pointer back to the stub.
+** If USE_TOOLBOX_OBJECT_GLUE is not defined there is no glue code, and the
+** extension modules simply declare the routine. This is the case for static
+** builds (and could be the case for MacPython CFM builds, because CFM extension
+** modules can reference each other without problems).
+*/
+
+#ifdef USE_TOOLBOX_OBJECT_GLUE
+/*
+** These macros are used in the module init code. If we use toolbox object glue
+** it sets the function pointer to point to the real function.
+*/
+#define PyMac_INIT_TOOLBOX_OBJECT_NEW(object, rtn) { \
+	extern PyObject *(*PyMacGluePtr_##rtn)(object); \
+	PyMacGluePtr_##rtn = _##rtn; \
+}
+#define PyMac_INIT_TOOLBOX_OBJECT_CONVERT(object, rtn) { \
+	extern int (*PyMacGluePtr_##rtn)(PyObject *, object *); \
+	PyMacGluePtr_##rtn = _##rtn; \
+}
+#else
+/*
+** If we don't use toolbox object glue the init macros are empty. Moreover, we define
+** _xxx_New to be the same as xxx_New, and the code in mactoolboxglue isn't included.
+*/
+#define PyMac_INIT_TOOLBOX_OBJECT_NEW(object, rtn)
+#define PyMac_INIT_TOOLBOX_OBJECT_CONVERT(object, rtn)
+#endif /* USE_TOOLBOX_OBJECT_GLUE */
+
+/* macfs exports */
+int PyMac_GetFSSpec(PyObject *, FSSpec *);	/* argument parser for FSSpec */
+PyObject *PyMac_BuildFSSpec(FSSpec *);		/* Convert FSSpec to PyObject */
+
+int PyMac_GetFSRef(PyObject *, FSRef *);	/* argument parser for FSRef */
+PyObject *PyMac_BuildFSRef(FSRef *);		/* Convert FSRef to PyObject */
+
+/* AE exports */
+extern PyObject *AEDesc_New(AppleEvent *); /* XXXX Why passed by address?? */
+extern PyObject *AEDesc_NewBorrowed(AppleEvent *);
+extern int AEDesc_Convert(PyObject *, AppleEvent *);
+
+/* Cm exports */
+extern PyObject *CmpObj_New(Component);
+extern int CmpObj_Convert(PyObject *, Component *);
+extern PyObject *CmpInstObj_New(ComponentInstance);
+extern int CmpInstObj_Convert(PyObject *, ComponentInstance *);
+
+/* Ctl exports */
+extern PyObject *CtlObj_New(ControlHandle);
+extern int CtlObj_Convert(PyObject *, ControlHandle *);
+
+/* Dlg exports */
+extern PyObject *DlgObj_New(DialogPtr);
+extern int DlgObj_Convert(PyObject *, DialogPtr *);
+extern PyObject *DlgObj_WhichDialog(DialogPtr);
+
+/* Drag exports */
+extern PyObject *DragObj_New(DragReference);
+extern int DragObj_Convert(PyObject *, DragReference *);
+
+/* List exports */
+extern PyObject *ListObj_New(ListHandle);
+extern int ListObj_Convert(PyObject *, ListHandle *);
+
+/* Menu exports */
+extern PyObject *MenuObj_New(MenuHandle);
+extern int MenuObj_Convert(PyObject *, MenuHandle *);
+
+/* Qd exports */
+extern PyObject *GrafObj_New(GrafPtr);
+extern int GrafObj_Convert(PyObject *, GrafPtr *);
+extern PyObject *BMObj_New(BitMapPtr);
+extern int BMObj_Convert(PyObject *, BitMapPtr *);
+extern PyObject *QdRGB_New(RGBColor *);
+extern int QdRGB_Convert(PyObject *, RGBColor *);
+
+/* Qdoffs exports */
+extern PyObject *GWorldObj_New(GWorldPtr);
+extern int GWorldObj_Convert(PyObject *, GWorldPtr *);
+
+/* Qt exports */
+extern PyObject *TrackObj_New(Track);
+extern int TrackObj_Convert(PyObject *, Track *);
+extern PyObject *MovieObj_New(Movie);
+extern int MovieObj_Convert(PyObject *, Movie *);
+extern PyObject *MovieCtlObj_New(MovieController);
+extern int MovieCtlObj_Convert(PyObject *, MovieController *);
+extern PyObject *TimeBaseObj_New(TimeBase);
+extern int TimeBaseObj_Convert(PyObject *, TimeBase *);
+extern PyObject *UserDataObj_New(UserData);
+extern int UserDataObj_Convert(PyObject *, UserData *);
+extern PyObject *MediaObj_New(Media);
+extern int MediaObj_Convert(PyObject *, Media *);
+
+/* Res exports */
+extern PyObject *ResObj_New(Handle);
+extern int ResObj_Convert(PyObject *, Handle *);
+extern PyObject *OptResObj_New(Handle);
+extern int OptResObj_Convert(PyObject *, Handle *);
+
+/* TE exports */
+extern PyObject *TEObj_New(TEHandle);
+extern int TEObj_Convert(PyObject *, TEHandle *);
+
+/* Win exports */
+extern PyObject *WinObj_New(WindowPtr);
+extern int WinObj_Convert(PyObject *, WindowPtr *);
+extern PyObject *WinObj_WhichWindow(WindowPtr);
+
+/* CF exports */
+extern PyObject *CFObj_New(CFTypeRef);
+extern int CFObj_Convert(PyObject *, CFTypeRef *);
+extern PyObject *CFTypeRefObj_New(CFTypeRef);
+extern int CFTypeRefObj_Convert(PyObject *, CFTypeRef *);
+extern PyObject *CFStringRefObj_New(CFStringRef);
+extern int CFStringRefObj_Convert(PyObject *, CFStringRef *);
+extern PyObject *CFMutableStringRefObj_New(CFMutableStringRef);
+extern int CFMutableStringRefObj_Convert(PyObject *, CFMutableStringRef *);
+extern PyObject *CFArrayRefObj_New(CFArrayRef);
+extern int CFArrayRefObj_Convert(PyObject *, CFArrayRef *);
+extern PyObject *CFMutableArrayRefObj_New(CFMutableArrayRef);
+extern int CFMutableArrayRefObj_Convert(PyObject *, CFMutableArrayRef *);
+extern PyObject *CFDictionaryRefObj_New(CFDictionaryRef);
+extern int CFDictionaryRefObj_Convert(PyObject *, CFDictionaryRef *);
+extern PyObject *CFMutableDictionaryRefObj_New(CFMutableDictionaryRef);
+extern int CFMutableDictionaryRefObj_Convert(PyObject *, CFMutableDictionaryRef *);
+extern PyObject *CFURLRefObj_New(CFURLRef);
+extern int CFURLRefObj_Convert(PyObject *, CFURLRef *);
+extern int OptionalCFURLRefObj_Convert(PyObject *, CFURLRef *);
+
+#ifdef __cplusplus
+	}
+#endif
+#endif

Added: trunk/mingw-libs/include/pymem.h
===================================================================
--- trunk/mingw-libs/include/pymem.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pymem.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,108 @@
+/* The PyMem_ family:  low-level memory allocation interfaces.
+   See objimpl.h for the PyObject_ memory family.
+*/
+
+#ifndef Py_PYMEM_H
+#define Py_PYMEM_H
+
+#include &quot;pyport.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* BEWARE:
+
+   Each interface exports both functions and macros.  Extension modules should
+   use the functions, to ensure binary compatibility across Python versions.
+   Because the Python implementation is free to change internal details, and
+   the macros may (or may not) expose details for speed, if you do use the
+   macros you must recompile your extensions with each Python release.
+
+   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
+   calloc/free.  For example, on Windows different DLLs may end up using
+   different heaps, and if you use PyMem_Malloc you'll get the memory from the
+   heap used by the Python DLL; it could be a disaster if you free()'ed that
+   directly in your own extension.  Using PyMem_Free instead ensures Python
+   can return the memory to the proper heap.  As another example, in
+   PYMALLOC_DEBUG mode, Python wraps all calls to all PyMem_ and PyObject_
+   memory functions in special debugging wrappers that add additional
+   debugging info to dynamic memory blocks.  The system routines have no idea
+   what to do with that stuff, and the Python wrappers have no idea what to do
+   with raw blocks obtained directly by the system routines then.
+*/
+
+/*
+ * Raw memory interface
+ * ====================
+ */
+
+/* Functions
+
+   Functions supplying platform-independent semantics for malloc/realloc/
+   free.  These functions make sure that allocating 0 bytes returns a distinct
+   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
+   may be returned), even if the platform malloc and realloc don't.
+   Returned pointers must be checked for NULL explicitly.  No action is
+   performed on failure (no exception is set, no warning is printed, etc).
+*/
+
+PyAPI_FUNC(void *) PyMem_Malloc(size_t);
+PyAPI_FUNC(void *) PyMem_Realloc(void *, size_t);
+PyAPI_FUNC(void) PyMem_Free(void *);
+
+/* Starting from Python 1.6, the wrappers Py_{Malloc,Realloc,Free} are
+   no longer supported. They used to call PyErr_NoMemory() on failure. */
+
+/* Macros. */
+#ifdef PYMALLOC_DEBUG
+/* Redirect all memory operations to Python's debugging allocator. */
+#define PyMem_MALLOC		PyObject_MALLOC
+#define PyMem_REALLOC		PyObject_REALLOC
+
+#else	/* ! PYMALLOC_DEBUG */
+
+/* PyMem_MALLOC(0) means malloc(1). Some systems would return NULL
+   for malloc(0), which would be treated as an error. Some platforms
+   would return a pointer with no memory behind it, which would break
+   pymalloc. To solve these problems, allocate an extra byte. */
+#define PyMem_MALLOC(n)         malloc((n) ? (n) : 1)
+#define PyMem_REALLOC(p, n)     realloc((p), (n) ? (n) : 1)
+
+#endif	/* PYMALLOC_DEBUG */
+
+/* In order to avoid breaking old code mixing PyObject_{New, NEW} with
+   PyMem_{Del, DEL} and PyMem_{Free, FREE}, the PyMem &quot;release memory&quot;
+   functions have to be redirected to the object deallocator. */
+#define PyMem_FREE           	PyObject_FREE
+
+/*
+ * Type-oriented memory interface
+ * ==============================
+ *
+ * These are carried along for historical reasons.  There's rarely a good
+ * reason to use them anymore (you can just as easily do the multiply and
+ * cast yourself).
+ */
+
+#define PyMem_New(type, n) \
+	( (type *) PyMem_Malloc((n) * sizeof(type)) )
+#define PyMem_NEW(type, n) \
+	( (type *) PyMem_MALLOC((n) * sizeof(type)) )
+
+#define PyMem_Resize(p, type, n) \
+	( (p) = (type *) PyMem_Realloc((p), (n) * sizeof(type)) )
+#define PyMem_RESIZE(p, type, n) \
+	( (p) = (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )
+
+/* In order to avoid breaking old code mixing PyObject_{New, NEW} with
+   PyMem_{Del, DEL} and PyMem_{Free, FREE}, the PyMem &quot;release memory&quot;
+   functions have to be redirected to the object deallocator. */
+#define PyMem_Del		PyObject_Free
+#define PyMem_DEL		PyObject_FREE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_PYMEM_H */

Added: trunk/mingw-libs/include/pyport.h
===================================================================
--- trunk/mingw-libs/include/pyport.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyport.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,637 @@
+#ifndef Py_PYPORT_H
+#define Py_PYPORT_H
+
+#include &quot;pyconfig.h&quot; /* include for defines */
+
+/**************************************************************************
+Symbols and macros to supply platform-independent interfaces to basic
+C language &amp; library operations whose spellings vary across platforms.
+
+Please try to make documentation here as clear as possible:  by definition,
+the stuff here is trying to illuminate C's darkest corners.
+
+Config #defines referenced here:
+
+SIGNED_RIGHT_SHIFT_ZERO_FILLS
+Meaning:  To be defined iff i&gt;&gt;j does not extend the sign bit when i is a
+          signed integral type and i &lt; 0.
+Used in:  Py_ARITHMETIC_RIGHT_SHIFT
+
+Py_DEBUG
+Meaning:  Extra checks compiled in for debug mode.
+Used in:  Py_SAFE_DOWNCAST
+
+HAVE_UINTPTR_T
+Meaning:  The C9X type uintptr_t is supported by the compiler
+Used in:  Py_uintptr_t
+
+HAVE_LONG_LONG
+Meaning:  The compiler supports the C type &quot;long long&quot;
+Used in:  PY_LONG_LONG
+
+**************************************************************************/
+
+
+/* For backward compatibility only. Obsolete, do not use. */
+#ifdef HAVE_PROTOTYPES
+#define Py_PROTO(x) x
+#else
+#define Py_PROTO(x) ()
+#endif
+#ifndef Py_FPROTO
+#define Py_FPROTO(x) Py_PROTO(x)
+#endif
+
+/* typedefs for some C9X-defined synonyms for integral types.
+ *
+ * The names in Python are exactly the same as the C9X names, except with a
+ * Py_ prefix.  Until C9X is universally implemented, this is the only way
+ * to ensure that Python gets reliable names that don't conflict with names
+ * in non-Python code that are playing their own tricks to define the C9X
+ * names.
+ *
+ * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
+ * integral synonyms.  Only define the ones we actually need.
+ */
+
+#ifdef HAVE_LONG_LONG
+#ifndef PY_LONG_LONG
+#define PY_LONG_LONG long long
+#endif
+#endif /* HAVE_LONG_LONG */
+
+/* uintptr_t is the C9X name for an unsigned integral type such that a
+ * legitimate void* can be cast to uintptr_t and then back to void* again
+ * without loss of information.  Similarly for intptr_t, wrt a signed
+ * integral type.
+ */
+#ifdef HAVE_UINTPTR_T
+typedef uintptr_t	Py_uintptr_t;
+typedef intptr_t	Py_intptr_t;
+
+#elif SIZEOF_VOID_P &lt;= SIZEOF_INT
+typedef unsigned int	Py_uintptr_t;
+typedef int		Py_intptr_t;
+
+#elif SIZEOF_VOID_P &lt;= SIZEOF_LONG
+typedef unsigned long	Py_uintptr_t;
+typedef long		Py_intptr_t;
+
+#elif defined(HAVE_LONG_LONG) &amp;&amp; (SIZEOF_VOID_P &lt;= SIZEOF_LONG_LONG)
+typedef unsigned PY_LONG_LONG	Py_uintptr_t;
+typedef PY_LONG_LONG		Py_intptr_t;
+
+#else
+#   error &quot;Python needs a typedef for Py_uintptr_t in pyport.h.&quot;
+#endif /* HAVE_UINTPTR_T */
+
+#include &lt;stdlib.h&gt;
+
+#include &lt;math.h&gt; /* Moved here from the math section, before extern &quot;C&quot; */
+
+/********************************************
+ * WRAPPER FOR &lt;time.h&gt; and/or &lt;sys/time.h&gt; *
+ ********************************************/
+
+#ifdef TIME_WITH_SYS_TIME
+#include &lt;sys/time.h&gt;
+#include &lt;time.h&gt;
+#else /* !TIME_WITH_SYS_TIME */
+#ifdef HAVE_SYS_TIME_H
+#include &lt;sys/time.h&gt;
+#else /* !HAVE_SYS_TIME_H */
+#include &lt;time.h&gt;
+#endif /* !HAVE_SYS_TIME_H */
+#endif /* !TIME_WITH_SYS_TIME */
+
+
+/******************************
+ * WRAPPER FOR &lt;sys/select.h&gt; *
+ ******************************/
+
+/* NB caller must include &lt;sys/types.h&gt; */
+
+#ifdef HAVE_SYS_SELECT_H
+
+#include &lt;sys/select.h&gt;
+
+#endif /* !HAVE_SYS_SELECT_H */
+
+/*******************************
+ * stat() and fstat() fiddling *
+ *******************************/
+
+/* We expect that stat and fstat exist on most systems.
+ *  It's confirmed on Unix, Mac and Windows.
+ *  If you don't have them, add
+ *      #define DONT_HAVE_STAT
+ * and/or
+ *      #define DONT_HAVE_FSTAT
+ * to your pyconfig.h. Python code beyond this should check HAVE_STAT and
+ * HAVE_FSTAT instead.
+ * Also
+ *      #define DONT_HAVE_SYS_STAT_H
+ * if &lt;sys/stat.h&gt; doesn't exist on your platform, and
+ *      #define HAVE_STAT_H
+ * if &lt;stat.h&gt; does (don't look at me -- ths mess is inherited).
+ */
+#ifndef DONT_HAVE_STAT
+#define HAVE_STAT
+#endif
+
+#ifndef DONT_HAVE_FSTAT
+#define HAVE_FSTAT
+#endif
+
+#ifdef RISCOS
+#include &lt;sys/types.h&gt;
+#include &quot;unixstuff.h&quot;
+#endif
+
+#ifndef DONT_HAVE_SYS_STAT_H
+#if defined(PYOS_OS2) &amp;&amp; defined(PYCC_GCC)
+#include &lt;sys/types.h&gt;
+#endif
+#include &lt;sys/stat.h&gt;
+#elif defined(HAVE_STAT_H)
+#include &lt;stat.h&gt;
+#endif
+
+#if defined(PYCC_VACPP)
+/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */
+#define S_IFMT (S_IFDIR|S_IFCHR|S_IFREG)
+#endif
+
+#ifndef S_ISREG
+#define S_ISREG(x) (((x) &amp; S_IFMT) == S_IFREG)
+#endif
+
+#ifndef S_ISDIR
+#define S_ISDIR(x) (((x) &amp; S_IFMT) == S_IFDIR)
+#endif
+
+
+#ifdef __cplusplus
+/* Move this down here since some C++ #include's don't like to be included
+   inside an extern &quot;C&quot; */
+extern &quot;C&quot; {
+#endif
+
+
+/* Py_ARITHMETIC_RIGHT_SHIFT
+ * C doesn't define whether a right-shift of a signed integer sign-extends
+ * or zero-fills.  Here a macro to force sign extension:
+ * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
+ *    Return I &gt;&gt; J, forcing sign extension.
+ * Requirements:
+ *    I is of basic signed type TYPE (char, short, int, long, or long long).
+ *    TYPE is one of char, short, int, long, or long long, although long long
+ *    must not be used except on platforms that support it.
+ *    J is an integer &gt;= 0 and strictly less than the number of bits in TYPE
+ *    (because C doesn't define what happens for J outside that range either).
+ * Caution:
+ *    I may be evaluated more than once.
+ */
+#ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS
+#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) \
+	((I) &lt; 0 ? ~((~(unsigned TYPE)(I)) &gt;&gt; (J)) : (I) &gt;&gt; (J))
+#else
+#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) &gt;&gt; (J))
+#endif
+
+/* Py_FORCE_EXPANSION(X)
+ * &quot;Simply&quot; returns its argument.  However, macro expansions within the
+ * argument are evaluated.  This unfortunate trickery is needed to get
+ * token-pasting to work as desired in some cases.
+ */
+#define Py_FORCE_EXPANSION(X) X
+
+/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
+ * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
+ * assert-fails if any information is lost.
+ * Caution:
+ *    VALUE may be evaluated more than once.
+ */
+#ifdef Py_DEBUG
+#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) \
+	(assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))
+#else
+#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)
+#endif
+
+/* Py_IS_NAN(X)
+ * Return 1 if float or double arg is a NaN, else 0.
+ * Caution:
+ *     X is evaluated more than once.
+ *     This may not work on all platforms.  Each platform has *some*
+ *     way to spell this, though -- override in pyconfig.h if you have
+ *     a platform where it doesn't work.
+ */
+#ifndef Py_IS_NAN
+#define Py_IS_NAN(X) ((X) != (X))
+#endif
+
+/* Py_IS_INFINITY(X)
+ * Return 1 if float or double arg is an infinity, else 0.
+ * Caution:
+ *    X is evaluated more than once.
+ *    This implementation may set the underflow flag if |X| is very small;
+ *    it really can't be implemented correctly (&amp; easily) before C99.
+ *    Override in pyconfig.h if you have a better spelling on your platform.
+ */
+#ifndef Py_IS_INFINITY
+#define Py_IS_INFINITY(X) ((X) &amp;&amp; (X)*0.5 == (X))
+#endif
+
+/* HUGE_VAL is supposed to expand to a positive double infinity.  Python
+ * uses Py_HUGE_VAL instead because some platforms are broken in this
+ * respect.  We used to embed code in pyport.h to try to worm around that,
+ * but different platforms are broken in conflicting ways.  If you're on
+ * a platform where HUGE_VAL is defined incorrectly, fiddle your Python
+ * config to #define Py_HUGE_VAL to something that works on your platform.
+ */
+#ifndef Py_HUGE_VAL
+#define Py_HUGE_VAL HUGE_VAL
+#endif
+
+/* Py_OVERFLOWED(X)
+ * Return 1 iff a libm function overflowed.  Set errno to 0 before calling
+ * a libm function, and invoke this macro after, passing the function
+ * result.
+ * Caution:
+ *    This isn't reliable.  C99 no longer requires libm to set errno under
+ *	  any exceptional condition, but does require +- HUGE_VAL return
+ *	  values on overflow.  A 754 box *probably* maps HUGE_VAL to a
+ *	  double infinity, and we're cool if that's so, unless the input
+ *	  was an infinity and an infinity is the expected result.  A C89
+ *	  system sets errno to ERANGE, so we check for that too.  We're
+ *	  out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or
+ *	  if the returned result is a NaN, or if a C89 box returns HUGE_VAL
+ *	  in non-overflow cases.
+ *    X is evaluated more than once.
+ * Some platforms have better way to spell this, so expect some #ifdef'ery.
+ *
+ * OpenBSD uses 'isinf()' because a compiler bug on that platform causes
+ * the longer macro version to be mis-compiled. This isn't optimal, and
+ * should be removed once a newer compiler is available on that platform.
+ * The system that had the failure was running OpenBSD 3.2 on Intel, with
+ * gcc 2.95.3.
+ *
+ * According to Tim's checkin, the FreeBSD systems use isinf() to work
+ * around a FPE bug on that platform.
+ */
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#define Py_OVERFLOWED(X) isinf(X)
+#else
+#define Py_OVERFLOWED(X) ((X) != 0.0 &amp;&amp; (errno == ERANGE ||    \
+					 (X) == Py_HUGE_VAL || \
+					 (X) == -Py_HUGE_VAL))
+#endif
+
+/* Py_SET_ERRNO_ON_MATH_ERROR(x)
+ * If a libm function did not set errno, but it looks like the result
+ * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
+ * to 0 before calling a libm function, and invoke this macro after,
+ * passing the function result.
+ * Caution:
+ *    This isn't reliable.  See Py_OVERFLOWED comments.
+ *    X is evaluated more than once.
+ */
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#define _Py_SET_EDOM_FOR_NAN(X) if (isnan(X)) errno = EDOM;
+#else
+#define _Py_SET_EDOM_FOR_NAN(X) ;
+#endif
+#define Py_SET_ERRNO_ON_MATH_ERROR(X) \
+	do { \
+		if (errno == 0) { \
+			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL) \
+				errno = ERANGE; \
+			else _Py_SET_EDOM_FOR_NAN(X) \
+		} \
+	} while(0)
+
+/* Py_SET_ERANGE_ON_OVERFLOW(x)
+ * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
+ */
+#define Py_SET_ERANGE_IF_OVERFLOW(X) Py_SET_ERRNO_ON_MATH_ERROR(X)
+
+/* Py_ADJUST_ERANGE1(x)
+ * Py_ADJUST_ERANGE2(x, y)
+ * Set errno to 0 before calling a libm function, and invoke one of these
+ * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
+ * for functions returning complex results).  This makes two kinds of
+ * adjustments to errno:  (A) If it looks like the platform libm set
+ * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
+ * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
+ * effect, we're trying to force a useful implementation of C89 errno
+ * behavior.
+ * Caution:
+ *    This isn't reliable.  See Py_OVERFLOWED comments.
+ *    X and Y may be evaluated more than once.
+ */
+#define Py_ADJUST_ERANGE1(X)						\
+	do {								\
+		if (errno == 0) {					\
+			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)	\
+				errno = ERANGE;				\
+		}							\
+		else if (errno == ERANGE &amp;&amp; (X) == 0.0)			\
+			errno = 0;					\
+	} while(0)
+
+#define Py_ADJUST_ERANGE2(X, Y)						\
+	do {								\
+		if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||	\
+		    (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {	\
+				if (errno == 0)				\
+					errno = ERANGE;			\
+		}							\
+		else if (errno == ERANGE)				\
+			errno = 0;					\
+	} while(0)
+
+/* Py_DEPRECATED(version)
+ * Declare a variable, type, or function deprecated.
+ * Usage:
+ *    extern int old_var Py_DEPRECATED(2.3);
+ *    typedef int T1 Py_DEPRECATED(2.4);
+ *    extern int x() Py_DEPRECATED(2.5);
+ */
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 1)
+#define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))
+#else
+#define Py_DEPRECATED(VERSION_UNUSED)
+#endif
+
+/**************************************************************************
+Prototypes that are missing from the standard include files on some systems
+(and possibly only some versions of such systems.)
+
+Please be conservative with adding new ones, document them and enclose them
+in platform-specific #ifdefs.
+**************************************************************************/
+
+#ifdef SOLARIS
+/* Unchecked */
+extern int gethostname(char *, int);
+#endif
+
+#ifdef __BEOS__
+/* Unchecked */
+/* It's in the libs, but not the headers... - [cjh] */
+int shutdown( int, int );
+#endif
+
+#ifdef HAVE__GETPTY
+#include &lt;sys/types.h&gt;		/* we need to import mode_t */
+extern char * _getpty(int *, int, mode_t, int);
+#endif
+
+#if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY)
+#if !defined(HAVE_PTY_H) &amp;&amp; !defined(HAVE_LIBUTIL_H)
+/* BSDI does not supply a prototype for the 'openpty' and 'forkpty'
+   functions, even though they are included in libutil. */
+#include &lt;termios.h&gt;
+extern int openpty(int *, int *, char *, struct termios *, struct winsize *);
+extern int forkpty(int *, char *, struct termios *, struct winsize *);
+#endif /* !defined(HAVE_PTY_H) &amp;&amp; !defined(HAVE_LIBUTIL_H) */
+#endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */
+
+
+/* These are pulled from various places. It isn't obvious on what platforms
+   they are necessary, nor what the exact prototype should look like (which
+   is likely to vary between platforms!) If you find you need one of these
+   declarations, please move them to a platform-specific block and include
+   proper prototypes. */
+#if 0
+
+/* From Modules/resource.c */
+extern int getrusage();
+extern int getpagesize();
+
+/* From Python/sysmodule.c and Modules/posixmodule.c */
+extern int fclose(FILE *);
+
+/* From Modules/posixmodule.c */
+extern int fdatasync(int);
+#endif /* 0 */
+
+
+/************************
+ * WRAPPER FOR &lt;math.h&gt; *
+ ************************/
+
+#ifndef HAVE_HYPOT
+extern double hypot(double, double);
+#endif
+
+
+/*******************************************************************
+On 4.4BSD-descendants, ctype functions serves the whole range of
+wchar_t character set rather than single byte code points only.
+This characteristic can break some operations of string object
+including str.upper() and str.split() on UTF-8 locales.  This
+workaround was provided by Tim Robbins of FreeBSD project.  He said
+the incompatibility will be fixed in FreeBSD 6.
+********************************************************************/
+
+#ifdef __FreeBSD__
+#include &lt;osreldate.h&gt;
+#if __FreeBSD_version &gt; 500039
+#include &lt;ctype.h&gt;
+#include &lt;wctype.h&gt;
+#undef isalnum
+#define isalnum(c) iswalnum(btowc(c))
+#undef isalpha
+#define isalpha(c) iswalpha(btowc(c))
+#undef islower
+#define islower(c) iswlower(btowc(c))
+#undef isspace
+#define isspace(c) iswspace(btowc(c))
+#undef isupper
+#define isupper(c) iswupper(btowc(c))
+#undef tolower
+#define tolower(c) towlower(btowc(c))
+#undef toupper
+#define toupper(c) towupper(btowc(c))
+#endif
+#endif
+
+
+/* Declarations for symbol visibility.
+
+  PyAPI_FUNC(type): Declares a public Python API function and return type
+  PyAPI_DATA(type): Declares public Python data and its type
+  PyMODINIT_FUNC:   A Python module init function.  If these functions are
+                    inside the Python core, they are private to the core.
+                    If in an extension module, it may be declared with
+                    external linkage depending on the platform.
+
+  As a number of platforms support/require &quot;__declspec(dllimport/dllexport)&quot;,
+  we support a HAVE_DECLSPEC_DLL macro to save duplication.
+*/
+
+/*
+  All windows ports, except cygwin, are handled in PC/pyconfig.h.
+
+  BeOS and cygwin are the only other autoconf platform requiring special
+  linkage handling and both of these use __declspec().
+*/
+#if defined(__CYGWIN__) || defined(__BEOS__)
+#	define HAVE_DECLSPEC_DLL
+#endif
+
+/* only get special linkage if built as shared or platform is Cygwin */
+#if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
+#	if defined(HAVE_DECLSPEC_DLL)
+#		ifdef Py_BUILD_CORE
+#			define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE
+#			define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE
+			/* module init functions inside the core need no external linkage */
+			/* except for Cygwin to handle embedding (FIXME: BeOS too?) */
+#			if defined(__CYGWIN__)
+#				define PyMODINIT_FUNC __declspec(dllexport) void
+#			else /* __CYGWIN__ */
+#				define PyMODINIT_FUNC void
+#			endif /* __CYGWIN__ */
+#		else /* Py_BUILD_CORE */
+			/* Building an extension module, or an embedded situation */
+			/* public Python functions and data are imported */
+			/* Under Cygwin, auto-import functions to prevent compilation */
+			/* failures similar to <A HREF="http://python.org/doc/FAQ.html#3.24">http://python.org/doc/FAQ.html#3.24</A> */
+#			if !defined(__CYGWIN__)
+#				define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
+#			endif /* !__CYGWIN__ */
+#			define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
+			/* module init functions outside the core must be exported */
+#			if defined(__cplusplus)
+#				define PyMODINIT_FUNC extern &quot;C&quot; __declspec(dllexport) void
+#			else /* __cplusplus */
+#				define PyMODINIT_FUNC __declspec(dllexport) void
+#			endif /* __cplusplus */
+#		endif /* Py_BUILD_CORE */
+#	endif /* HAVE_DECLSPEC */
+#endif /* Py_ENABLE_SHARED */
+
+/* If no external linkage macros defined by now, create defaults */
+#ifndef PyAPI_FUNC
+#	define PyAPI_FUNC(RTYPE) RTYPE
+#endif
+#ifndef PyAPI_DATA
+#	define PyAPI_DATA(RTYPE) extern RTYPE
+#endif
+#ifndef PyMODINIT_FUNC
+#	if defined(__cplusplus)
+#		define PyMODINIT_FUNC extern &quot;C&quot; void
+#	else /* __cplusplus */
+#		define PyMODINIT_FUNC void
+#	endif /* __cplusplus */
+#endif
+
+/* Deprecated DL_IMPORT and DL_EXPORT macros */
+#if defined(Py_ENABLE_SHARED) &amp;&amp; defined (HAVE_DECLSPEC_DLL)
+#	if defined(Py_BUILD_CORE)
+#		define DL_IMPORT(RTYPE) __declspec(dllexport) RTYPE
+#		define DL_EXPORT(RTYPE) __declspec(dllexport) RTYPE
+#	else
+#		define DL_IMPORT(RTYPE) __declspec(dllimport) RTYPE
+#		define DL_EXPORT(RTYPE) __declspec(dllexport) RTYPE
+#	endif
+#endif
+#ifndef DL_EXPORT
+#	define DL_EXPORT(RTYPE) RTYPE
+#endif
+#ifndef DL_IMPORT
+#	define DL_IMPORT(RTYPE) RTYPE
+#endif
+/* End of deprecated DL_* macros */
+
+/* If the fd manipulation macros aren't defined,
+   here is a set that should do the job */
+
+#if 0 /* disabled and probably obsolete */
+
+#ifndef	FD_SETSIZE
+#define	FD_SETSIZE	256
+#endif
+
+#ifndef FD_SET
+
+typedef long fd_mask;
+
+#define NFDBITS	(sizeof(fd_mask) * NBBY)	/* bits per mask */
+#ifndef howmany
+#define	howmany(x, y)	(((x)+((y)-1))/(y))
+#endif /* howmany */
+
+typedef	struct fd_set {
+	fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
+} fd_set;
+
+#define	FD_SET(n, p)	((p)-&gt;fds_bits[(n)/NFDBITS] |= (1 &lt;&lt; ((n) % NFDBITS)))
+#define	FD_CLR(n, p)	((p)-&gt;fds_bits[(n)/NFDBITS] &amp;= ~(1 &lt;&lt; ((n) % NFDBITS)))
+#define	FD_ISSET(n, p)	((p)-&gt;fds_bits[(n)/NFDBITS] &amp; (1 &lt;&lt; ((n) % NFDBITS)))
+#define FD_ZERO(p)	memset((char *)(p), '\0', sizeof(*(p)))
+
+#endif /* FD_SET */
+
+#endif /* fd manipulation macros */
+
+
+/* limits.h constants that may be missing */
+
+#ifndef INT_MAX
+#define INT_MAX 2147483647
+#endif
+
+#ifndef LONG_MAX
+#if SIZEOF_LONG == 4
+#define LONG_MAX 0X7FFFFFFFL
+#elif SIZEOF_LONG == 8
+#define LONG_MAX 0X7FFFFFFFFFFFFFFFL
+#else
+#error &quot;could not set LONG_MAX in pyport.h&quot;
+#endif
+#endif
+
+#ifndef LONG_MIN
+#define LONG_MIN (-LONG_MAX-1)
+#endif
+
+#ifndef LONG_BIT
+#define LONG_BIT (8 * SIZEOF_LONG)
+#endif
+
+#if LONG_BIT != 8 * SIZEOF_LONG
+/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
+ * 32-bit platforms using gcc.  We try to catch that here at compile-time
+ * rather than waiting for integer multiplication to trigger bogus
+ * overflows.
+ */
+#error &quot;LONG_BIT definition appears wrong for platform (bad gcc/glibc config?).&quot;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/*
+ * Hide GCC attributes from compilers that don't support them.
+ */
+#if (!defined(__GNUC__) || __GNUC__ &lt; 2 || \
+     (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 7) ) &amp;&amp; \
+    !defined(RISCOS)
+#define Py_GCC_ATTRIBUTE(x)
+#else
+#define Py_GCC_ATTRIBUTE(x) __attribute__(x)
+#endif
+
+/* Eliminate end-of-loop code not reached warnings from SunPro C
+ * when using do{...}while(0) macros
+ */
+#ifdef __SUNPRO_C
+#pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)
+#endif
+
+#endif /* Py_PYPORT_H */

Added: trunk/mingw-libs/include/pystate.h
===================================================================
--- trunk/mingw-libs/include/pystate.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pystate.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,185 @@
+
+/* Thread and interpreter state structures and their interfaces */
+
+
+#ifndef Py_PYSTATE_H
+#define Py_PYSTATE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* State shared between threads */
+
+struct _ts; /* Forward */
+struct _is; /* Forward */
+
+typedef struct _is {
+
+    struct _is *next;
+    struct _ts *tstate_head;
+
+    PyObject *modules;
+    PyObject *sysdict;
+    PyObject *builtins;
+
+    PyObject *codec_search_path;
+    PyObject *codec_search_cache;
+    PyObject *codec_error_registry;
+
+#ifdef HAVE_DLOPEN
+    int dlopenflags;
+#endif
+#ifdef WITH_TSC
+    int tscdump;
+#endif
+
+} PyInterpreterState;
+
+
+/* State unique per thread */
+
+struct _frame; /* Avoid including frameobject.h */
+
+/* Py_tracefunc return -1 when raising an exception, or 0 for success. */
+typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);
+
+/* The following values are used for 'what' for tracefunc functions: */
+#define PyTrace_CALL 0
+#define PyTrace_EXCEPTION 1
+#define PyTrace_LINE 2
+#define PyTrace_RETURN 3
+#define PyTrace_C_CALL 4
+#define PyTrace_C_EXCEPTION 5
+#define PyTrace_C_RETURN 6
+
+typedef struct _ts {
+
+    struct _ts *next;
+    PyInterpreterState *interp;
+
+    struct _frame *frame;
+    int recursion_depth;
+    int tracing;
+    int use_tracing;
+
+    Py_tracefunc c_profilefunc;
+    Py_tracefunc c_tracefunc;
+    PyObject *c_profileobj;
+    PyObject *c_traceobj;
+
+    PyObject *curexc_type;
+    PyObject *curexc_value;
+    PyObject *curexc_traceback;
+
+    PyObject *exc_type;
+    PyObject *exc_value;
+    PyObject *exc_traceback;
+
+    PyObject *dict;
+
+    /* tick_counter is incremented whenever the check_interval ticker
+     * reaches zero. The purpose is to give a useful measure of the number
+     * of interpreted bytecode instructions in a given thread.  This
+     * extremely lightweight statistic collector may be of interest to
+     * profilers (like psyco.jit()), although nothing in the core uses it.
+     */
+    int tick_counter;
+
+    int gilstate_counter;
+
+    PyObject *async_exc; /* Asynchronous exception to raise */
+    long thread_id; /* Thread id where this tstate was created */
+
+    /* XXX signal handlers should also be here */
+
+} PyThreadState;
+
+
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
+PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
+PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
+
+PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
+PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
+#ifdef WITH_THREAD
+PyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);
+#endif
+
+PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
+PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
+PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
+PyAPI_FUNC(int) PyThreadState_SetAsyncExc(long, PyObject *);
+
+
+/* Variable and macro for in-line access to current thread state */
+
+PyAPI_DATA(PyThreadState *) _PyThreadState_Current;
+
+#ifdef Py_DEBUG
+#define PyThreadState_GET() PyThreadState_Get()
+#else
+#define PyThreadState_GET() (_PyThreadState_Current)
+#endif
+
+typedef
+    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
+        PyGILState_STATE;
+
+/* Ensure that the current thread is ready to call the Python
+   C API, regardless of the current state of Python, or of its
+   thread lock.  This may be called as many times as desired
+   by a thread so long as each call is matched with a call to
+   PyGILState_Release().  In general, other thread-state APIs may
+   be used between _Ensure() and _Release() calls, so long as the
+   thread-state is restored to its previous state before the Release().
+   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
+   Py_END_ALLOW_THREADS macros are acceptable.
+
+   The return value is an opaque &quot;handle&quot; to the thread state when
+   PyGILState_Ensure() was called, and must be passed to
+   PyGILState_Release() to ensure Python is left in the same state. Even
+   though recursive calls are allowed, these handles can *not* be shared -
+   each unique call to PyGILState_Ensure must save the handle for its
+   call to PyGILState_Release.
+
+   When the function returns, the current thread will hold the GIL.
+
+   Failure is a fatal error.
+*/
+PyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);
+
+/* Release any resources previously acquired.  After this call, Python's
+   state will be the same as it was prior to the corresponding
+   PyGILState_Ensure() call (but generally this state will be unknown to
+   the caller, hence the use of the GILState API.)
+
+   Every call to PyGILState_Ensure must be matched by a call to
+   PyGILState_Release on the same thread.
+*/
+PyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);
+
+/* Helper/diagnostic function - get the current thread state for
+   this thread.  May return NULL if no GILState API has been used
+   on the current thread.  Note the main thread always has such a
+   thread-state, even if no auto-thread-state call has been made
+   on the main thread.
+*/
+PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
+
+/* Routines for advanced debuggers, requested by David Beazley.
+   Don't use unless you know what you are doing! */
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Head(void);
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Next(PyInterpreterState *);
+PyAPI_FUNC(PyThreadState *) PyInterpreterState_ThreadHead(PyInterpreterState *);
+PyAPI_FUNC(PyThreadState *) PyThreadState_Next(PyThreadState *);
+
+typedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);
+
+/* hook for PyEval_GetFrame(), requested for Psyco */
+PyAPI_DATA(PyThreadFrameGetter) _PyThreadState_GetFrame;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYSTATE_H */

Added: trunk/mingw-libs/include/pystrtod.h
===================================================================
--- trunk/mingw-libs/include/pystrtod.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pystrtod.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,18 @@
+#ifndef Py_STRTOD_H
+#define Py_STRTOD_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+PyAPI_FUNC(double) PyOS_ascii_strtod(const char *str, char **ptr);
+PyAPI_FUNC(double) PyOS_ascii_atof(const char *str);
+PyAPI_FUNC(char *) PyOS_ascii_formatd(char *buffer, int buf_len,  const char *format, double d);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_STRTOD_H */

Added: trunk/mingw-libs/include/pythonrun.h
===================================================================
--- trunk/mingw-libs/include/pythonrun.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pythonrun.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,152 @@
+
+/* Interfaces to parse and execute pieces of python code */
+
+#ifndef Py_PYTHONRUN_H
+#define Py_PYTHONRUN_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define PyCF_MASK (CO_FUTURE_DIVISION)
+#define PyCF_MASK_OBSOLETE (CO_GENERATOR_ALLOWED | CO_NESTED)
+#define PyCF_SOURCE_IS_UTF8  0x0100
+#define PyCF_DONT_IMPLY_DEDENT 0x0200
+
+typedef struct {
+	int cf_flags;  /* bitmask of CO_xxx flags relevant to future */
+} PyCompilerFlags;
+
+PyAPI_FUNC(void) Py_SetProgramName(char *);
+PyAPI_FUNC(char *) Py_GetProgramName(void);
+
+PyAPI_FUNC(void) Py_SetPythonHome(char *);
+PyAPI_FUNC(char *) Py_GetPythonHome(void);
+
+PyAPI_FUNC(void) Py_Initialize(void);
+PyAPI_FUNC(void) Py_InitializeEx(int);
+PyAPI_FUNC(void) Py_Finalize(void);
+PyAPI_FUNC(int) Py_IsInitialized(void);
+PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
+PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
+
+PyAPI_FUNC(int) PyRun_AnyFile(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_AnyFileEx(FILE *, const char *, int);
+
+PyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_AnyFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
+
+PyAPI_FUNC(int) PyRun_SimpleString(const char *);
+PyAPI_FUNC(int) PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_SimpleFile(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_SimpleFileEx(FILE *, const char *, int);
+PyAPI_FUNC(int) PyRun_SimpleFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_InteractiveOne(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_InteractiveOneFlags(FILE *, const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_InteractiveLoop(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_InteractiveLoopFlags(FILE *, const char *, PyCompilerFlags *);
+
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseString(const char *, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseFile(FILE *, const char *, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlags(const char *, int, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlagsFilename(const char *,
+								  const char *,
+								  int,
+								  int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseFileFlags(FILE *, const char *,
+							int, int);
+
+PyAPI_FUNC(PyObject *) PyRun_String(const char *, int, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyRun_File(FILE *, const char *, int, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyRun_FileEx(FILE *, const char *, int,
+				   PyObject *, PyObject *, int);
+PyAPI_FUNC(PyObject *) PyRun_StringFlags(const char *, int, PyObject *, PyObject *,
+					PyCompilerFlags *);
+PyAPI_FUNC(PyObject *) PyRun_FileFlags(FILE *, const char *, int, PyObject *, 
+				      PyObject *, PyCompilerFlags *);
+PyAPI_FUNC(PyObject *) PyRun_FileExFlags(FILE *, const char *, int, PyObject *, 
+					PyObject *, int, PyCompilerFlags *);
+
+PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
+PyAPI_FUNC(PyObject *) Py_CompileStringFlags(const char *, const char *, int,
+					    PyCompilerFlags *);
+PyAPI_FUNC(struct symtable *) Py_SymtableString(const char *, const char *, int);
+
+PyAPI_FUNC(void) PyErr_Print(void);
+PyAPI_FUNC(void) PyErr_PrintEx(int);
+PyAPI_FUNC(void) PyErr_Display(PyObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(int) Py_AtExit(void (*func)(void));
+
+PyAPI_FUNC(void) Py_Exit(int);
+
+PyAPI_FUNC(int) Py_FdIsInteractive(FILE *, const char *);
+
+/* Bootstrap */
+PyAPI_FUNC(int) Py_Main(int argc, char **argv);
+
+/* In getpath.c */
+PyAPI_FUNC(char *) Py_GetProgramFullPath(void);
+PyAPI_FUNC(char *) Py_GetPrefix(void);
+PyAPI_FUNC(char *) Py_GetExecPrefix(void);
+PyAPI_FUNC(char *) Py_GetPath(void);
+
+/* In their own files */
+PyAPI_FUNC(const char *) Py_GetVersion(void);
+PyAPI_FUNC(const char *) Py_GetPlatform(void);
+PyAPI_FUNC(const char *) Py_GetCopyright(void);
+PyAPI_FUNC(const char *) Py_GetCompiler(void);
+PyAPI_FUNC(const char *) Py_GetBuildInfo(void);
+
+/* Internal -- various one-time initializations */
+PyAPI_FUNC(PyObject *) _PyBuiltin_Init(void);
+PyAPI_FUNC(PyObject *) _PySys_Init(void);
+PyAPI_FUNC(void) _PyImport_Init(void);
+PyAPI_FUNC(void) _PyExc_Init(void);
+PyAPI_FUNC(void) _PyImportHooks_Init(void);
+PyAPI_FUNC(int) _PyFrame_Init(void);
+PyAPI_FUNC(int) _PyInt_Init(void);
+
+/* Various internal finalizers */
+PyAPI_FUNC(void) _PyExc_Fini(void);
+PyAPI_FUNC(void) _PyImport_Fini(void);
+PyAPI_FUNC(void) PyMethod_Fini(void);
+PyAPI_FUNC(void) PyFrame_Fini(void);
+PyAPI_FUNC(void) PyCFunction_Fini(void);
+PyAPI_FUNC(void) PyTuple_Fini(void);
+PyAPI_FUNC(void) PyList_Fini(void);
+PyAPI_FUNC(void) PyString_Fini(void);
+PyAPI_FUNC(void) PyInt_Fini(void);
+PyAPI_FUNC(void) PyFloat_Fini(void);
+PyAPI_FUNC(void) PyOS_FiniInterrupts(void);
+
+/* Stuff with no proper home (yet) */
+PyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, char *);
+PyAPI_DATA(int) (*PyOS_InputHook)(void);
+PyAPI_DATA(char) *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, char *);
+PyAPI_DATA(PyThreadState*) _PyOS_ReadlineTState;
+
+/* Stack size, in &quot;pointers&quot; (so we get extra safety margins
+   on 64-bit platforms).  On a 32-bit platform, this translates
+   to a 8k margin. */
+#define PYOS_STACK_MARGIN 2048
+
+#if defined(WIN32) &amp;&amp; !defined(MS_WIN64) &amp;&amp; defined(_MSC_VER)
+/* Enable stack checking under Microsoft C */
+#define USE_STACKCHECK
+#endif
+
+#ifdef USE_STACKCHECK
+/* Check that we aren't overflowing our stack */
+PyAPI_FUNC(int) PyOS_CheckStack(void);
+#endif
+
+/* Signals */
+typedef void (*PyOS_sighandler_t)(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYTHONRUN_H */

Added: trunk/mingw-libs/include/pythread.h
===================================================================
--- trunk/mingw-libs/include/pythread.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pythread.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,44 @@
+
+#ifndef Py_PYTHREAD_H
+#define Py_PYTHREAD_H
+
+#define NO_EXIT_PROG		/* don't define PyThread_exit_prog() */
+				/* (the result is no use of signals on SGI) */
+
+typedef void *PyThread_type_lock;
+typedef void *PyThread_type_sema;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(void) PyThread_init_thread(void);
+PyAPI_FUNC(long) PyThread_start_new_thread(void (*)(void *), void *);
+PyAPI_FUNC(void) PyThread_exit_thread(void);
+PyAPI_FUNC(void) PyThread__PyThread_exit_thread(void);
+PyAPI_FUNC(long) PyThread_get_thread_ident(void);
+
+PyAPI_FUNC(PyThread_type_lock) PyThread_allocate_lock(void);
+PyAPI_FUNC(void) PyThread_free_lock(PyThread_type_lock);
+PyAPI_FUNC(int) PyThread_acquire_lock(PyThread_type_lock, int);
+#define WAIT_LOCK	1
+#define NOWAIT_LOCK	0
+PyAPI_FUNC(void) PyThread_release_lock(PyThread_type_lock);
+
+#ifndef NO_EXIT_PROG
+PyAPI_FUNC(void) PyThread_exit_prog(int);
+PyAPI_FUNC(void) PyThread__PyThread_exit_prog(int);
+#endif
+
+/* Thread Local Storage (TLS) API */
+PyAPI_FUNC(int) PyThread_create_key(void);
+PyAPI_FUNC(void) PyThread_delete_key(int);
+PyAPI_FUNC(int) PyThread_set_key_value(int, void *);
+PyAPI_FUNC(void *) PyThread_get_key_value(int);
+PyAPI_FUNC(void) PyThread_delete_key_value(int key);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_PYTHREAD_H */

Added: trunk/mingw-libs/include/rangeobject.h
===================================================================
--- trunk/mingw-libs/include/rangeobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/rangeobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,30 @@
+
+/* Range object interface */
+
+#ifndef Py_RANGEOBJECT_H
+#define Py_RANGEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This is about the type 'xrange', not the built-in function range(), which
+   returns regular lists. */
+
+/*
+A range object represents an integer range.  This is an immutable object;
+a range cannot change its value after creation.
+
+Range objects behave like the corresponding tuple objects except that
+they are represented by a start, stop, and step datamembers.
+*/
+
+PyAPI_DATA(PyTypeObject) PyRange_Type;
+
+#define PyRange_Check(op) ((op)-&gt;ob_type == &amp;PyRange_Type)
+
+PyAPI_FUNC(PyObject *) PyRange_New(long, long, long, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_RANGEOBJECT_H */

Added: trunk/mingw-libs/include/setobject.h
===================================================================
--- trunk/mingw-libs/include/setobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/setobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,41 @@
+
+/* Set object interface */
+
+#ifndef Py_SETOBJECT_H
+#define Py_SETOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/*
+This data structure is shared by set and frozenset objects.
+*/
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *data;
+	long hash;	/* only used by frozenset objects */
+	PyObject *weakreflist; /* List of weak references */
+
+	/* Invariants:
+	 *     data is a dictionary whose values are all True.
+	 *     data points to the same dict for the whole life of the set.
+	 * For frozensets only:
+	 *     data is immutable.
+	 *     hash is the hash of the frozenset or -1 if not computed yet.
+	 */
+} PySetObject;
+
+PyAPI_DATA(PyTypeObject) PySet_Type;
+PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
+
+#define PyFrozenSet_CheckExact(ob) ((ob)-&gt;ob_type == &amp;PyFrozenSet_Type)
+#define PyAnySet_Check(ob) \
+	((ob)-&gt;ob_type == &amp;PySet_Type || (ob)-&gt;ob_type == &amp;PyFrozenSet_Type || \
+	  PyType_IsSubtype((ob)-&gt;ob_type, &amp;PySet_Type) || \
+	  PyType_IsSubtype((ob)-&gt;ob_type, &amp;PyFrozenSet_Type))
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SETOBJECT_H */

Added: trunk/mingw-libs/include/sliceobject.h
===================================================================
--- trunk/mingw-libs/include/sliceobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/sliceobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,42 @@
+#ifndef Py_SLICEOBJECT_H
+#define Py_SLICEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* The unique ellipsis object &quot;...&quot; */
+
+PyAPI_DATA(PyObject) _Py_EllipsisObject; /* Don't use this directly */
+
+#define Py_Ellipsis (&amp;_Py_EllipsisObject)
+
+/* Slice object interface */
+
+/*
+
+A slice object containing start, stop, and step data members (the
+names are from range).  After much talk with Guido, it was decided to
+let these be any arbitrary python type.  Py_None stands for omitted values.
+*/
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *start, *stop, *step;	/* not NULL */
+} PySliceObject;
+
+PyAPI_DATA(PyTypeObject) PySlice_Type;
+
+#define PySlice_Check(op) ((op)-&gt;ob_type == &amp;PySlice_Type)
+
+PyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,
+                                  PyObject* step);
+PyAPI_FUNC(int) PySlice_GetIndices(PySliceObject *r, int length,
+                                  int *start, int *stop, int *step);
+PyAPI_FUNC(int) PySlice_GetIndicesEx(PySliceObject *r, int length,
+				    int *start, int *stop, 
+				    int *step, int *slicelength);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SLICEOBJECT_H */

Added: trunk/mingw-libs/include/stringobject.h
===================================================================
--- trunk/mingw-libs/include/stringobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/stringobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,183 @@
+
+/* String object interface */
+
+#ifndef Py_STRINGOBJECT_H
+#define Py_STRINGOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &lt;stdarg.h&gt;
+
+/*
+Type PyStringObject represents a character string.  An extra zero byte is
+reserved at the end to ensure it is zero-terminated, but a size is
+present so strings with null bytes in them can be represented.  This
+is an immutable object type.
+
+There are functions to create new string objects, to test
+an object for string-ness, and to get the
+string value.  The latter function returns a null pointer
+if the object is not of the proper type.
+There is a variant that takes an explicit size as well as a
+variant that assumes a zero-terminated string.  Note that none of the
+functions should be applied to nil objects.
+*/
+
+/* Caching the hash (ob_shash) saves recalculation of a string's hash value.
+   Interning strings (ob_sstate) tries to ensure that only one string
+   object with a given value exists, so equality tests can be one pointer
+   comparison.  This is generally restricted to strings that &quot;look like&quot;
+   Python identifiers, although the intern() builtin can be used to force
+   interning of any string.
+   Together, these sped the interpreter by up to 20%. */
+
+typedef struct {
+    PyObject_VAR_HEAD
+    long ob_shash;
+    int ob_sstate;
+    char ob_sval[1];
+
+    /* Invariants:
+     *     ob_sval contains space for 'ob_size+1' elements.
+     *     ob_sval[ob_size] == 0.
+     *     ob_shash is the hash of the string or -1 if not computed yet.
+     *     ob_sstate != 0 iff the string object is in stringobject.c's
+     *       'interned' dictionary; in this case the two references
+     *       from 'interned' to this object are *not counted* in ob_refcnt.
+     */
+} PyStringObject;
+
+#define SSTATE_NOT_INTERNED 0
+#define SSTATE_INTERNED_MORTAL 1
+#define SSTATE_INTERNED_IMMORTAL 2
+
+PyAPI_DATA(PyTypeObject) PyBaseString_Type;
+PyAPI_DATA(PyTypeObject) PyString_Type;
+
+#define PyString_Check(op) PyObject_TypeCheck(op, &amp;PyString_Type)
+#define PyString_CheckExact(op) ((op)-&gt;ob_type == &amp;PyString_Type)
+
+PyAPI_FUNC(PyObject *) PyString_FromStringAndSize(const char *, int);
+PyAPI_FUNC(PyObject *) PyString_FromString(const char *);
+PyAPI_FUNC(PyObject *) PyString_FromFormatV(const char*, va_list)
+				Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
+PyAPI_FUNC(PyObject *) PyString_FromFormat(const char*, ...)
+				Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(int) PyString_Size(PyObject *);
+PyAPI_FUNC(char *) PyString_AsString(PyObject *);
+PyAPI_FUNC(PyObject *) PyString_Repr(PyObject *, int);
+PyAPI_FUNC(void) PyString_Concat(PyObject **, PyObject *);
+PyAPI_FUNC(void) PyString_ConcatAndDel(PyObject **, PyObject *);
+PyAPI_FUNC(int) _PyString_Resize(PyObject **, int);
+PyAPI_FUNC(int) _PyString_Eq(PyObject *, PyObject*);
+PyAPI_FUNC(PyObject *) PyString_Format(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyString_FormatLong(PyObject*, int, int,
+						  int, char**, int*);
+PyAPI_FUNC(PyObject *) PyString_DecodeEscape(const char *, int, 
+						   const char *, int,
+						   const char *);
+
+PyAPI_FUNC(void) PyString_InternInPlace(PyObject **);
+PyAPI_FUNC(void) PyString_InternImmortal(PyObject **);
+PyAPI_FUNC(PyObject *) PyString_InternFromString(const char *);
+PyAPI_FUNC(void) _Py_ReleaseInternedStrings(void);
+
+/* Use only if you know it's a string */
+#define PyString_CHECK_INTERNED(op) (((PyStringObject *)(op))-&gt;ob_sstate)
+
+/* Macro, trading safety for speed */
+#define PyString_AS_STRING(op) (((PyStringObject *)(op))-&gt;ob_sval)
+#define PyString_GET_SIZE(op)  (((PyStringObject *)(op))-&gt;ob_size)
+
+/* _PyString_Join(sep, x) is like sep.join(x).  sep must be PyStringObject*,
+   x must be an iterable object. */
+PyAPI_FUNC(PyObject *) _PyString_Join(PyObject *sep, PyObject *x);
+
+/* --- Generic Codecs ----------------------------------------------------- */
+
+/* Create an object by decoding the encoded string s of the
+   given size. */
+
+PyAPI_FUNC(PyObject*) PyString_Decode(
+    const char *s,              /* encoded string */
+    int size,                   /* size of buffer */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a char buffer of the given size and returns a 
+   Python object. */
+
+PyAPI_FUNC(PyObject*) PyString_Encode(
+    const char *s,              /* string char buffer */
+    int size,                   /* number of chars to encode */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a string object and returns the result as Python 
+   object. */
+
+PyAPI_FUNC(PyObject*) PyString_AsEncodedObject(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Encodes a string object and returns the result as Python string
+   object.   
+   
+   If the codec returns an Unicode object, the object is converted
+   back to a string using the default encoding.
+
+   DEPRECATED - use PyString_AsEncodedObject() instead. */
+
+PyAPI_FUNC(PyObject*) PyString_AsEncodedString(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Decodes a string object and returns the result as Python 
+   object. */
+
+PyAPI_FUNC(PyObject*) PyString_AsDecodedObject(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Decodes a string object and returns the result as Python string
+   object.  
+   
+   If the codec returns an Unicode object, the object is converted
+   back to a string using the default encoding.
+
+   DEPRECATED - use PyString_AsDecodedObject() instead. */
+
+PyAPI_FUNC(PyObject*) PyString_AsDecodedString(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Provides access to the internal data buffer and size of a string
+   object or the default encoded version of an Unicode object. Passing
+   NULL as *len parameter will force the string buffer to be
+   0-terminated (passing a string with embedded NULL characters will
+   cause an exception).  */
+
+PyAPI_FUNC(int) PyString_AsStringAndSize(
+    register PyObject *obj,	/* string or Unicode object */
+    register char **s,		/* pointer to buffer variable */
+    register int *len		/* pointer to length variable or NULL
+				   (only possible for 0-terminated
+				   strings) */
+    );
+    
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRINGOBJECT_H */

Added: trunk/mingw-libs/include/structmember.h
===================================================================
--- trunk/mingw-libs/include/structmember.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/structmember.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,89 @@
+#ifndef Py_STRUCTMEMBER_H
+#define Py_STRUCTMEMBER_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Interface to map C struct members to Python object attributes */
+
+#include &lt;stddef.h&gt; /* For offsetof */
+
+/* The offsetof() macro calculates the offset of a structure member
+   in its structure.  Unfortunately this cannot be written down
+   portably, hence it is provided by a Standard C header file.
+   For pre-Standard C compilers, here is a version that usually works
+   (but watch out!): */
+
+#ifndef offsetof
+#define offsetof(type, member) ( (int) &amp; ((type*)0) -&gt; member )
+#endif
+
+/* An array of memberlist structures defines the name, type and offset
+   of selected members of a C structure.  These can be read by
+   PyMember_Get() and set by PyMember_Set() (except if their READONLY flag
+   is set).  The array must be terminated with an entry whose name
+   pointer is NULL. */
+
+struct memberlist {
+	/* Obsolete version, for binary backwards compatibility */
+	char *name;
+	int type;
+	int offset;
+	int flags;
+};
+
+typedef struct PyMemberDef {
+	/* Current version, use this */
+	char *name;
+	int type;
+	int offset;
+	int flags;
+	char *doc;
+} PyMemberDef;
+
+/* Types */
+#define T_SHORT		0
+#define T_INT		1
+#define T_LONG		2
+#define T_FLOAT		3
+#define T_DOUBLE	4
+#define T_STRING	5
+#define T_OBJECT	6
+/* XXX the ordering here is weird for binary compatibility */
+#define T_CHAR		7	/* 1-character string */
+#define T_BYTE		8	/* 8-bit signed int */
+/* unsigned variants: */
+#define T_UBYTE		9
+#define T_USHORT	10
+#define T_UINT		11
+#define T_ULONG		12
+
+/* Added by Jack: strings contained in the structure */
+#define T_STRING_INPLACE	13
+
+#define T_OBJECT_EX	16	/* Like T_OBJECT, but raises AttributeError
+				   when the value is NULL, instead of
+				   converting to None. */
+
+/* Flags */
+#define READONLY	1
+#define RO		READONLY		/* Shorthand */
+#define READ_RESTRICTED	2
+#define WRITE_RESTRICTED 4
+#define RESTRICTED	(READ_RESTRICTED | WRITE_RESTRICTED)
+
+
+/* Obsolete API, for binary backwards compatibility */
+PyAPI_FUNC(PyObject *) PyMember_Get(char *, struct memberlist *, char *);
+PyAPI_FUNC(int) PyMember_Set(char *, struct memberlist *, char *, PyObject *);
+
+/* Current API, use this */
+PyAPI_FUNC(PyObject *) PyMember_GetOne(char *, struct PyMemberDef *);
+PyAPI_FUNC(int) PyMember_SetOne(char *, struct PyMemberDef *, PyObject *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRUCTMEMBER_H */

Added: trunk/mingw-libs/include/structseq.h
===================================================================
--- trunk/mingw-libs/include/structseq.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/structseq.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,41 @@
+
+/* Tuple object interface */
+
+#ifndef Py_STRUCTSEQ_H
+#define Py_STRUCTSEQ_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct PyStructSequence_Field {
+	char *name;
+	char *doc;
+} PyStructSequence_Field;
+
+typedef struct PyStructSequence_Desc {
+	char *name;
+	char *doc;
+	struct PyStructSequence_Field *fields;
+	int n_in_sequence;
+} PyStructSequence_Desc;
+
+extern char* PyStructSequence_UnnamedField;
+
+PyAPI_FUNC(void) PyStructSequence_InitType(PyTypeObject *type,
+					   PyStructSequence_Desc *desc);
+
+PyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);
+
+typedef struct {
+	PyObject_VAR_HEAD
+	PyObject *ob_item[1];
+} PyStructSequence;
+
+/* Macro, *only* to be used to fill in brand new objects */
+#define PyStructSequence_SET_ITEM(op, i, v) \
+	(((PyStructSequence *)(op))-&gt;ob_item[i] = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRUCTSEQ_H */

Added: trunk/mingw-libs/include/symtable.h
===================================================================
--- trunk/mingw-libs/include/symtable.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/symtable.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,102 @@
+#ifndef Py_SYMTABLE_H
+#define Py_SYMTABLE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* A symbol table is constructed each time PyNode_Compile() is
+   called.  The table walks the entire parse tree and identifies each
+   use or definition of a variable. 
+
+   The symbol table contains a dictionary for each code block in a
+   module: The symbol dictionary for the block.  They keys of these
+   dictionaries are the name of all variables used or defined in the
+   block; the integer values are used to store several flags,
+   e.g. DEF_PARAM indicates that a variable is a parameter to a
+   function. 
+*/
+
+struct _symtable_entry;
+
+struct symtable {
+	int st_pass;             /* pass == 1 or 2 */
+	const char *st_filename; /* name of file being compiled */
+	struct _symtable_entry *st_cur; /* current symbol table entry */
+	PyObject *st_symbols;    /* dictionary of symbol table entries */
+        PyObject *st_stack;      /* stack of namespace info */
+	PyObject *st_global;     /* borrowed ref to MODULE in st_symbols */
+	int st_nscopes;          /* number of scopes */
+	int st_errors;           /* number of errors */
+	char *st_private;        /* name of current class or NULL */
+	PyFutureFeatures *st_future; /* module's future features */
+};
+
+typedef struct _symtable_entry {
+	PyObject_HEAD
+	PyObject *ste_id;        /* int: key in st_symbols) */
+	PyObject *ste_symbols;   /* dict: name to flags) */
+	PyObject *ste_name;      /* string: name of scope */
+	PyObject *ste_varnames;  /* list of variable names */
+	PyObject *ste_children;  /* list of child ids */
+	int ste_type;            /* module, class, or function */
+	int ste_lineno;          /* first line of scope */
+	int ste_optimized;       /* true if namespace can't be optimized */
+	int ste_nested;          /* true if scope is nested */
+	int ste_child_free;      /* true if a child scope has free variables,
+				    including free refs to globals */
+	int ste_generator;       /* true if namespace is a generator */
+	int ste_opt_lineno;      /* lineno of last exec or import * */
+	int ste_tmpname;         /* temporary name counter */
+	struct symtable *ste_table;
+} PySymtableEntryObject;
+
+PyAPI_DATA(PyTypeObject) PySymtableEntry_Type;
+
+#define PySymtableEntry_Check(op) ((op)-&gt;ob_type == &amp;PySymtableEntry_Type)
+
+PyAPI_FUNC(PyObject *) PySymtableEntry_New(struct symtable *,
+						 char *, int, int);
+
+PyAPI_FUNC(struct symtable *) PyNode_CompileSymtable(struct _node *, const char *);
+PyAPI_FUNC(void) PySymtable_Free(struct symtable *);
+
+
+#define TOP &quot;global&quot;
+
+/* Flags for def-use information */
+
+#define DEF_GLOBAL 1           /* global stmt */
+#define DEF_LOCAL 2            /* assignment in code block */
+#define DEF_PARAM 2&lt;&lt;1         /* formal parameter */
+#define USE 2&lt;&lt;2               /* name is used */
+#define DEF_STAR 2&lt;&lt;3          /* parameter is star arg */
+#define DEF_DOUBLESTAR 2&lt;&lt;4    /* parameter is star-star arg */
+#define DEF_INTUPLE 2&lt;&lt;5       /* name defined in tuple in parameters */
+#define DEF_FREE 2&lt;&lt;6          /* name used but not defined in nested scope */
+#define DEF_FREE_GLOBAL 2&lt;&lt;7   /* free variable is actually implicit global */
+#define DEF_FREE_CLASS 2&lt;&lt;8    /* free variable from class's method */
+#define DEF_IMPORT 2&lt;&lt;9        /* assignment occurred via import */
+
+#define DEF_BOUND (DEF_LOCAL | DEF_PARAM | DEF_IMPORT)
+
+#define TYPE_FUNCTION 1
+#define TYPE_CLASS 2
+#define TYPE_MODULE 3
+
+#define LOCAL 1
+#define GLOBAL_EXPLICIT 2
+#define GLOBAL_IMPLICIT 3
+#define FREE 4
+#define CELL 5
+
+#define OPT_IMPORT_STAR 1
+#define OPT_EXEC 2
+#define OPT_BARE_EXEC 4
+
+#define GENERATOR 1
+#define GENERATOR_EXPRESSION 2
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SYMTABLE_H */

Added: trunk/mingw-libs/include/sysmodule.h
===================================================================
--- trunk/mingw-libs/include/sysmodule.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/sysmodule.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,30 @@
+
+/* System module interface */
+
+#ifndef Py_SYSMODULE_H
+#define Py_SYSMODULE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(PyObject *) PySys_GetObject(char *);
+PyAPI_FUNC(int) PySys_SetObject(char *, PyObject *);
+PyAPI_FUNC(FILE *) PySys_GetFile(char *, FILE *);
+PyAPI_FUNC(void) PySys_SetArgv(int, char **);
+PyAPI_FUNC(void) PySys_SetPath(char *);
+
+PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+
+PyAPI_DATA(PyObject *) _PySys_TraceFunc, *_PySys_ProfileFunc;
+PyAPI_DATA(int) _PySys_CheckInterval;
+
+PyAPI_FUNC(void) PySys_ResetWarnOptions(void);
+PyAPI_FUNC(void) PySys_AddWarnOption(char *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SYSMODULE_H */

Added: trunk/mingw-libs/include/timefuncs.h
===================================================================
--- trunk/mingw-libs/include/timefuncs.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/timefuncs.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,23 @@
+/*  timefuncs.h
+ */
+
+/* Utility function related to timemodule.c. */
+
+#ifndef TIMEFUNCS_H
+#define TIMEFUNCS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Cast double x to time_t, but raise ValueError if x is too large
+ * to fit in a time_t.  ValueError is set on return iff the return
+ * value is (time_t)-1 and PyErr_Occurred().
+ */
+PyAPI_FUNC(time_t) _PyTime_DoubleToTimet(double x);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif  /* TIMEFUNCS_H */

Added: trunk/mingw-libs/include/token.h
===================================================================
--- trunk/mingw-libs/include/token.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/token.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,83 @@
+
+/* Token types */
+
+#ifndef Py_TOKEN_H
+#define Py_TOKEN_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define ENDMARKER	0
+#define NAME		1
+#define NUMBER		2
+#define STRING		3
+#define NEWLINE		4
+#define INDENT		5
+#define DEDENT		6
+#define LPAR		7
+#define RPAR		8
+#define LSQB		9
+#define RSQB		10
+#define COLON		11
+#define COMMA		12
+#define SEMI		13
+#define PLUS		14
+#define MINUS		15
+#define STAR		16
+#define SLASH		17
+#define VBAR		18
+#define AMPER		19
+#define LESS		20
+#define GREATER		21
+#define EQUAL		22
+#define DOT		23
+#define PERCENT		24
+#define BACKQUOTE	25
+#define LBRACE		26
+#define RBRACE		27
+#define EQEQUAL		28
+#define NOTEQUAL	29
+#define LESSEQUAL	30
+#define GREATEREQUAL	31
+#define TILDE		32
+#define CIRCUMFLEX	33
+#define LEFTSHIFT	34
+#define RIGHTSHIFT	35
+#define DOUBLESTAR	36
+#define PLUSEQUAL	37
+#define MINEQUAL	38
+#define STAREQUAL	39
+#define SLASHEQUAL	40
+#define PERCENTEQUAL	41
+#define AMPEREQUAL	42
+#define VBAREQUAL	43
+#define CIRCUMFLEXEQUAL	44
+#define LEFTSHIFTEQUAL	45
+#define RIGHTSHIFTEQUAL	46
+#define DOUBLESTAREQUAL	47
+#define DOUBLESLASH	48
+#define DOUBLESLASHEQUAL 49
+#define AT              50	
+/* Don't forget to update the table _PyParser_TokenNames in tokenizer.c! */
+#define OP		51
+#define ERRORTOKEN	52
+#define N_TOKENS	53
+
+/* Special definitions for cooperation with parser */
+
+#define NT_OFFSET		256
+
+#define ISTERMINAL(x)		((x) &lt; NT_OFFSET)
+#define ISNONTERMINAL(x)	((x) &gt;= NT_OFFSET)
+#define ISEOF(x)		((x) == ENDMARKER)
+
+
+PyAPI_DATA(char *) _PyParser_TokenNames[]; /* Token names */
+PyAPI_FUNC(int) PyToken_OneChar(int);
+PyAPI_FUNC(int) PyToken_TwoChars(int, int);
+PyAPI_FUNC(int) PyToken_ThreeChars(int, int, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TOKEN_H */

Added: trunk/mingw-libs/include/traceback.h
===================================================================
--- trunk/mingw-libs/include/traceback.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/traceback.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,30 @@
+
+#ifndef Py_TRACEBACK_H
+#define Py_TRACEBACK_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct _frame;
+
+/* Traceback interface */
+
+typedef struct _traceback {
+	PyObject_HEAD
+	struct _traceback *tb_next;
+	struct _frame *tb_frame;
+	int tb_lasti;
+	int tb_lineno;
+} PyTracebackObject;
+
+PyAPI_FUNC(int) PyTraceBack_Here(struct _frame *);
+PyAPI_FUNC(int) PyTraceBack_Print(PyObject *, PyObject *);
+
+/* Reveal traceback type so we can typecheck traceback objects */
+PyAPI_DATA(PyTypeObject) PyTraceBack_Type;
+#define PyTraceBack_Check(v) ((v)-&gt;ob_type == &amp;PyTraceBack_Type)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TRACEBACK_H */

Added: trunk/mingw-libs/include/tupleobject.h
===================================================================
--- trunk/mingw-libs/include/tupleobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/tupleobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,57 @@
+
+/* Tuple object interface */
+
+#ifndef Py_TUPLEOBJECT_H
+#define Py_TUPLEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/*
+Another generally useful object type is a tuple of object pointers.
+For Python, this is an immutable type.  C code can change the tuple items
+(but not their number), and even use tuples are general-purpose arrays of
+object references, but in general only brand new tuples should be mutated,
+not ones that might already have been exposed to Python code.
+
+*** WARNING *** PyTuple_SetItem does not increment the new item's reference
+count, but does decrement the reference count of the item it replaces,
+if not nil.  It does *decrement* the reference count if it is *not*
+inserted in the tuple.  Similarly, PyTuple_GetItem does not increment the
+returned item's reference count.
+*/
+
+typedef struct {
+    PyObject_VAR_HEAD
+    PyObject *ob_item[1];
+
+    /* ob_item contains space for 'ob_size' elements.
+     * Items must normally not be NULL, except during construction when
+     * the tuple is not yet visible outside the function that builds it.
+     */
+} PyTupleObject;
+
+PyAPI_DATA(PyTypeObject) PyTuple_Type;
+
+#define PyTuple_Check(op) PyObject_TypeCheck(op, &amp;PyTuple_Type)
+#define PyTuple_CheckExact(op) ((op)-&gt;ob_type == &amp;PyTuple_Type)
+
+PyAPI_FUNC(PyObject *) PyTuple_New(int size);
+PyAPI_FUNC(int) PyTuple_Size(PyObject *);
+PyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, int);
+PyAPI_FUNC(int) PyTuple_SetItem(PyObject *, int, PyObject *);
+PyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, int, int);
+PyAPI_FUNC(int) _PyTuple_Resize(PyObject **, int);
+PyAPI_FUNC(PyObject *) PyTuple_Pack(int, ...);
+
+/* Macro, trading safety for speed */
+#define PyTuple_GET_ITEM(op, i) (((PyTupleObject *)(op))-&gt;ob_item[i])
+#define PyTuple_GET_SIZE(op)    (((PyTupleObject *)(op))-&gt;ob_size)
+
+/* Macro, *only* to be used to fill in brand new tuples */
+#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))-&gt;ob_item[i] = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TUPLEOBJECT_H */

Added: trunk/mingw-libs/include/ucnhash.h
===================================================================
--- trunk/mingw-libs/include/ucnhash.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/ucnhash.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,29 @@
+/* Unicode name database interface */
+
+#ifndef Py_UCNHASH_H
+#define Py_UCNHASH_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* revised ucnhash CAPI interface (exported through a PyCObject) */
+
+typedef struct {
+
+    /* Size of this struct */
+    int size;
+
+    /* Get name for a given character code.  Returns non-zero if
+       success, zero if not.  Does not set Python exceptions. */
+    int (*getname)(Py_UCS4 code, char* buffer, int buflen);
+
+    /* Get character code for a given name.  Same error handling
+       as for getname. */
+    int (*getcode)(const char* name, int namelen, Py_UCS4* code);
+
+} _PyUnicode_Name_CAPI;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_UCNHASH_H */

Added: trunk/mingw-libs/include/unicodeobject.h
===================================================================
--- trunk/mingw-libs/include/unicodeobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/unicodeobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,1196 @@
+#ifndef Py_UNICODEOBJECT_H
+#define Py_UNICODEOBJECT_H
+
+/*
+
+Unicode implementation based on original code by Fredrik Lundh,
+modified by Marc-Andre Lemburg (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">mal at lemburg.com</A>) according to the
+Unicode Integration Proposal (see file Misc/unicode.txt).
+
+Copyright (c) Corporation for National Research Initiatives.
+
+
+ Original header:
+ --------------------------------------------------------------------
+
+ * Yet another Unicode string type for Python.  This type supports the
+ * 16-bit Basic Multilingual Plane (BMP) only.
+ *
+ * Written by Fredrik Lundh, January 1999.
+ *
+ * Copyright (c) 1999 by Secret Labs AB.
+ * Copyright (c) 1999 by Fredrik Lundh.
+ *
+ * <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">fredrik at pythonware.com</A>
+ * <A HREF="http://www.pythonware.com">http://www.pythonware.com</A>
+ *
+ * --------------------------------------------------------------------
+ * This Unicode String Type is
+ * 
+ * Copyright (c) 1999 by Secret Labs AB
+ * Copyright (c) 1999 by Fredrik Lundh
+ * 
+ * By obtaining, using, and/or copying this software and/or its
+ * associated documentation, you agree that you have read, understood,
+ * and will comply with the following terms and conditions:
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * associated documentation for any purpose and without fee is hereby
+ * granted, provided that the above copyright notice appears in all
+ * copies, and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Secret Labs
+ * AB or the author not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.
+ * 
+ * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * -------------------------------------------------------------------- */
+
+#include &lt;ctype.h&gt;
+
+/* === Internal API ======================================================= */
+
+/* --- Internal Unicode Format -------------------------------------------- */
+
+#ifndef Py_USING_UNICODE
+
+#define PyUnicode_Check(op)                 0
+#define PyUnicode_CheckExact(op)            0
+
+#else
+
+/* FIXME: MvL's new implementation assumes that Py_UNICODE_SIZE is
+   properly set, but the default rules below doesn't set it.  I'll
+   sort this out some other day -- <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">fredrik at pythonware.com</A> */
+
+#ifndef Py_UNICODE_SIZE
+#error Must define Py_UNICODE_SIZE
+#endif
+
+/* Setting Py_UNICODE_WIDE enables UCS-4 storage.  Otherwise, Unicode
+   strings are stored as UCS-2 (with limited support for UTF-16) */
+
+#if Py_UNICODE_SIZE &gt;= 4
+#define Py_UNICODE_WIDE
+#endif
+
+/* Set these flags if the platform has &quot;wchar.h&quot;, &quot;wctype.h&quot; and the
+   wchar_t type is a 16-bit unsigned type */
+/* #define HAVE_WCHAR_H */
+/* #define HAVE_USABLE_WCHAR_T */
+
+/* Defaults for various platforms */
+#ifndef PY_UNICODE_TYPE
+
+/* Windows has a usable wchar_t type (unless we're using UCS-4) */
+# if defined(MS_WIN32) &amp;&amp; Py_UNICODE_SIZE == 2
+#  define HAVE_USABLE_WCHAR_T
+#  define PY_UNICODE_TYPE wchar_t
+# endif
+
+# if defined(Py_UNICODE_WIDE)
+#  define PY_UNICODE_TYPE Py_UCS4
+# endif
+
+#endif
+
+/* If the compiler provides a wchar_t type we try to support it
+   through the interface functions PyUnicode_FromWideChar() and
+   PyUnicode_AsWideChar(). */
+
+#ifdef HAVE_USABLE_WCHAR_T
+# ifndef HAVE_WCHAR_H
+#  define HAVE_WCHAR_H
+# endif
+#endif
+
+#ifdef HAVE_WCHAR_H
+/* Work around a cosmetic bug in BSDI 4.x wchar.h; thanks to Thomas Wouters */
+# ifdef _HAVE_BSDI
+#  include &lt;time.h&gt;
+# endif
+#  include &lt;wchar.h&gt;
+#endif
+
+/*
+ * Use this typedef when you need to represent a UTF-16 surrogate pair
+ * as single unsigned integer.
+ */
+#if SIZEOF_INT &gt;= 4 
+typedef unsigned int Py_UCS4; 
+#elif SIZEOF_LONG &gt;= 4
+typedef unsigned long Py_UCS4; 
+#endif
+
+typedef PY_UNICODE_TYPE Py_UNICODE;
+
+/* --- UCS-2/UCS-4 Name Mangling ------------------------------------------ */
+
+/* Unicode API names are mangled to assure that UCS-2 and UCS-4 builds
+   produce different external names and thus cause import errors in
+   case Python interpreters and extensions with mixed compiled in
+   Unicode width assumptions are combined. */
+
+#ifndef Py_UNICODE_WIDE
+
+# define PyUnicode_AsASCIIString PyUnicodeUCS2_AsASCIIString
+# define PyUnicode_AsCharmapString PyUnicodeUCS2_AsCharmapString
+# define PyUnicode_AsEncodedObject PyUnicodeUCS2_AsEncodedObject
+# define PyUnicode_AsEncodedString PyUnicodeUCS2_AsEncodedString
+# define PyUnicode_AsLatin1String PyUnicodeUCS2_AsLatin1String
+# define PyUnicode_AsRawUnicodeEscapeString PyUnicodeUCS2_AsRawUnicodeEscapeString
+# define PyUnicode_AsUTF16String PyUnicodeUCS2_AsUTF16String
+# define PyUnicode_AsUTF8String PyUnicodeUCS2_AsUTF8String
+# define PyUnicode_AsUnicode PyUnicodeUCS2_AsUnicode
+# define PyUnicode_AsUnicodeEscapeString PyUnicodeUCS2_AsUnicodeEscapeString
+# define PyUnicode_AsWideChar PyUnicodeUCS2_AsWideChar
+# define PyUnicode_Compare PyUnicodeUCS2_Compare
+# define PyUnicode_Concat PyUnicodeUCS2_Concat
+# define PyUnicode_Contains PyUnicodeUCS2_Contains
+# define PyUnicode_Count PyUnicodeUCS2_Count
+# define PyUnicode_Decode PyUnicodeUCS2_Decode
+# define PyUnicode_DecodeASCII PyUnicodeUCS2_DecodeASCII
+# define PyUnicode_DecodeCharmap PyUnicodeUCS2_DecodeCharmap
+# define PyUnicode_DecodeLatin1 PyUnicodeUCS2_DecodeLatin1
+# define PyUnicode_DecodeRawUnicodeEscape PyUnicodeUCS2_DecodeRawUnicodeEscape
+# define PyUnicode_DecodeUTF16 PyUnicodeUCS2_DecodeUTF16
+# define PyUnicode_DecodeUTF16Stateful PyUnicodeUCS2_DecodeUTF16Stateful
+# define PyUnicode_DecodeUTF8 PyUnicodeUCS2_DecodeUTF8
+# define PyUnicode_DecodeUTF8Stateful PyUnicodeUCS2_DecodeUTF8Stateful
+# define PyUnicode_DecodeUnicodeEscape PyUnicodeUCS2_DecodeUnicodeEscape
+# define PyUnicode_Encode PyUnicodeUCS2_Encode
+# define PyUnicode_EncodeASCII PyUnicodeUCS2_EncodeASCII
+# define PyUnicode_EncodeCharmap PyUnicodeUCS2_EncodeCharmap
+# define PyUnicode_EncodeDecimal PyUnicodeUCS2_EncodeDecimal
+# define PyUnicode_EncodeLatin1 PyUnicodeUCS2_EncodeLatin1
+# define PyUnicode_EncodeRawUnicodeEscape PyUnicodeUCS2_EncodeRawUnicodeEscape
+# define PyUnicode_EncodeUTF16 PyUnicodeUCS2_EncodeUTF16
+# define PyUnicode_EncodeUTF8 PyUnicodeUCS2_EncodeUTF8
+# define PyUnicode_EncodeUnicodeEscape PyUnicodeUCS2_EncodeUnicodeEscape
+# define PyUnicode_Find PyUnicodeUCS2_Find
+# define PyUnicode_Format PyUnicodeUCS2_Format
+# define PyUnicode_FromEncodedObject PyUnicodeUCS2_FromEncodedObject
+# define PyUnicode_FromObject PyUnicodeUCS2_FromObject
+# define PyUnicode_FromOrdinal PyUnicodeUCS2_FromOrdinal
+# define PyUnicode_FromUnicode PyUnicodeUCS2_FromUnicode
+# define PyUnicode_FromWideChar PyUnicodeUCS2_FromWideChar
+# define PyUnicode_GetDefaultEncoding PyUnicodeUCS2_GetDefaultEncoding
+# define PyUnicode_GetMax PyUnicodeUCS2_GetMax
+# define PyUnicode_GetSize PyUnicodeUCS2_GetSize
+# define PyUnicode_Join PyUnicodeUCS2_Join
+# define PyUnicode_Replace PyUnicodeUCS2_Replace
+# define PyUnicode_Resize PyUnicodeUCS2_Resize
+# define PyUnicode_SetDefaultEncoding PyUnicodeUCS2_SetDefaultEncoding
+# define PyUnicode_Split PyUnicodeUCS2_Split
+# define PyUnicode_RSplit PyUnicodeUCS2_RSplit
+# define PyUnicode_Splitlines PyUnicodeUCS2_Splitlines
+# define PyUnicode_Tailmatch PyUnicodeUCS2_Tailmatch
+# define PyUnicode_Translate PyUnicodeUCS2_Translate
+# define PyUnicode_TranslateCharmap PyUnicodeUCS2_TranslateCharmap
+# define _PyUnicode_AsDefaultEncodedString _PyUnicodeUCS2_AsDefaultEncodedString
+# define _PyUnicode_Fini _PyUnicodeUCS2_Fini
+# define _PyUnicode_Init _PyUnicodeUCS2_Init
+# define _PyUnicode_IsAlpha _PyUnicodeUCS2_IsAlpha
+# define _PyUnicode_IsDecimalDigit _PyUnicodeUCS2_IsDecimalDigit
+# define _PyUnicode_IsDigit _PyUnicodeUCS2_IsDigit
+# define _PyUnicode_IsLinebreak _PyUnicodeUCS2_IsLinebreak
+# define _PyUnicode_IsLowercase _PyUnicodeUCS2_IsLowercase
+# define _PyUnicode_IsNumeric _PyUnicodeUCS2_IsNumeric
+# define _PyUnicode_IsTitlecase _PyUnicodeUCS2_IsTitlecase
+# define _PyUnicode_IsUppercase _PyUnicodeUCS2_IsUppercase
+# define _PyUnicode_IsWhitespace _PyUnicodeUCS2_IsWhitespace
+# define _PyUnicode_ToDecimalDigit _PyUnicodeUCS2_ToDecimalDigit
+# define _PyUnicode_ToDigit _PyUnicodeUCS2_ToDigit
+# define _PyUnicode_ToLowercase _PyUnicodeUCS2_ToLowercase
+# define _PyUnicode_ToNumeric _PyUnicodeUCS2_ToNumeric
+# define _PyUnicode_ToTitlecase _PyUnicodeUCS2_ToTitlecase
+# define _PyUnicode_ToUppercase _PyUnicodeUCS2_ToUppercase
+
+#else
+
+# define PyUnicode_AsASCIIString PyUnicodeUCS4_AsASCIIString
+# define PyUnicode_AsCharmapString PyUnicodeUCS4_AsCharmapString
+# define PyUnicode_AsEncodedObject PyUnicodeUCS4_AsEncodedObject
+# define PyUnicode_AsEncodedString PyUnicodeUCS4_AsEncodedString
+# define PyUnicode_AsLatin1String PyUnicodeUCS4_AsLatin1String
+# define PyUnicode_AsRawUnicodeEscapeString PyUnicodeUCS4_AsRawUnicodeEscapeString
+# define PyUnicode_AsUTF16String PyUnicodeUCS4_AsUTF16String
+# define PyUnicode_AsUTF8String PyUnicodeUCS4_AsUTF8String
+# define PyUnicode_AsUnicode PyUnicodeUCS4_AsUnicode
+# define PyUnicode_AsUnicodeEscapeString PyUnicodeUCS4_AsUnicodeEscapeString
+# define PyUnicode_AsWideChar PyUnicodeUCS4_AsWideChar
+# define PyUnicode_Compare PyUnicodeUCS4_Compare
+# define PyUnicode_Concat PyUnicodeUCS4_Concat
+# define PyUnicode_Contains PyUnicodeUCS4_Contains
+# define PyUnicode_Count PyUnicodeUCS4_Count
+# define PyUnicode_Decode PyUnicodeUCS4_Decode
+# define PyUnicode_DecodeASCII PyUnicodeUCS4_DecodeASCII
+# define PyUnicode_DecodeCharmap PyUnicodeUCS4_DecodeCharmap
+# define PyUnicode_DecodeLatin1 PyUnicodeUCS4_DecodeLatin1
+# define PyUnicode_DecodeRawUnicodeEscape PyUnicodeUCS4_DecodeRawUnicodeEscape
+# define PyUnicode_DecodeUTF16 PyUnicodeUCS4_DecodeUTF16
+# define PyUnicode_DecodeUTF16Stateful PyUnicodeUCS4_DecodeUTF16Stateful
+# define PyUnicode_DecodeUTF8 PyUnicodeUCS4_DecodeUTF8
+# define PyUnicode_DecodeUTF8Stateful PyUnicodeUCS4_DecodeUTF8Stateful
+# define PyUnicode_DecodeUnicodeEscape PyUnicodeUCS4_DecodeUnicodeEscape
+# define PyUnicode_Encode PyUnicodeUCS4_Encode
+# define PyUnicode_EncodeASCII PyUnicodeUCS4_EncodeASCII
+# define PyUnicode_EncodeCharmap PyUnicodeUCS4_EncodeCharmap
+# define PyUnicode_EncodeDecimal PyUnicodeUCS4_EncodeDecimal
+# define PyUnicode_EncodeLatin1 PyUnicodeUCS4_EncodeLatin1
+# define PyUnicode_EncodeRawUnicodeEscape PyUnicodeUCS4_EncodeRawUnicodeEscape
+# define PyUnicode_EncodeUTF16 PyUnicodeUCS4_EncodeUTF16
+# define PyUnicode_EncodeUTF8 PyUnicodeUCS4_EncodeUTF8
+# define PyUnicode_EncodeUnicodeEscape PyUnicodeUCS4_EncodeUnicodeEscape
+# define PyUnicode_Find PyUnicodeUCS4_Find
+# define PyUnicode_Format PyUnicodeUCS4_Format
+# define PyUnicode_FromEncodedObject PyUnicodeUCS4_FromEncodedObject
+# define PyUnicode_FromObject PyUnicodeUCS4_FromObject
+# define PyUnicode_FromOrdinal PyUnicodeUCS4_FromOrdinal
+# define PyUnicode_FromUnicode PyUnicodeUCS4_FromUnicode
+# define PyUnicode_FromWideChar PyUnicodeUCS4_FromWideChar
+# define PyUnicode_GetDefaultEncoding PyUnicodeUCS4_GetDefaultEncoding
+# define PyUnicode_GetMax PyUnicodeUCS4_GetMax
+# define PyUnicode_GetSize PyUnicodeUCS4_GetSize
+# define PyUnicode_Join PyUnicodeUCS4_Join
+# define PyUnicode_Replace PyUnicodeUCS4_Replace
+# define PyUnicode_Resize PyUnicodeUCS4_Resize
+# define PyUnicode_SetDefaultEncoding PyUnicodeUCS4_SetDefaultEncoding
+# define PyUnicode_Split PyUnicodeUCS4_Split
+# define PyUnicode_Splitlines PyUnicodeUCS4_Splitlines
+# define PyUnicode_Tailmatch PyUnicodeUCS4_Tailmatch
+# define PyUnicode_Translate PyUnicodeUCS4_Translate
+# define PyUnicode_TranslateCharmap PyUnicodeUCS4_TranslateCharmap
+# define _PyUnicode_AsDefaultEncodedString _PyUnicodeUCS4_AsDefaultEncodedString
+# define _PyUnicode_Fini _PyUnicodeUCS4_Fini
+# define _PyUnicode_Init _PyUnicodeUCS4_Init
+# define _PyUnicode_IsAlpha _PyUnicodeUCS4_IsAlpha
+# define _PyUnicode_IsDecimalDigit _PyUnicodeUCS4_IsDecimalDigit
+# define _PyUnicode_IsDigit _PyUnicodeUCS4_IsDigit
+# define _PyUnicode_IsLinebreak _PyUnicodeUCS4_IsLinebreak
+# define _PyUnicode_IsLowercase _PyUnicodeUCS4_IsLowercase
+# define _PyUnicode_IsNumeric _PyUnicodeUCS4_IsNumeric
+# define _PyUnicode_IsTitlecase _PyUnicodeUCS4_IsTitlecase
+# define _PyUnicode_IsUppercase _PyUnicodeUCS4_IsUppercase
+# define _PyUnicode_IsWhitespace _PyUnicodeUCS4_IsWhitespace
+# define _PyUnicode_ToDecimalDigit _PyUnicodeUCS4_ToDecimalDigit
+# define _PyUnicode_ToDigit _PyUnicodeUCS4_ToDigit
+# define _PyUnicode_ToLowercase _PyUnicodeUCS4_ToLowercase
+# define _PyUnicode_ToNumeric _PyUnicodeUCS4_ToNumeric
+# define _PyUnicode_ToTitlecase _PyUnicodeUCS4_ToTitlecase
+# define _PyUnicode_ToUppercase _PyUnicodeUCS4_ToUppercase
+
+
+#endif
+
+/* --- Internal Unicode Operations ---------------------------------------- */
+
+/* If you want Python to use the compiler's wctype.h functions instead
+   of the ones supplied with Python, define WANT_WCTYPE_FUNCTIONS or
+   configure Python using --with-wctype-functions.  This reduces the
+   interpreter's code size. */
+
+#if defined(HAVE_USABLE_WCHAR_T) &amp;&amp; defined(WANT_WCTYPE_FUNCTIONS)
+
+#include &lt;wctype.h&gt;
+
+#define Py_UNICODE_ISSPACE(ch) iswspace(ch)
+
+#define Py_UNICODE_ISLOWER(ch) iswlower(ch)
+#define Py_UNICODE_ISUPPER(ch) iswupper(ch)
+#define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
+#define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)
+
+#define Py_UNICODE_TOLOWER(ch) towlower(ch)
+#define Py_UNICODE_TOUPPER(ch) towupper(ch)
+#define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)
+
+#define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
+#define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
+#define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
+
+#define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
+#define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
+#define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)
+
+#define Py_UNICODE_ISALPHA(ch) iswalpha(ch)
+
+#else
+
+#define Py_UNICODE_ISSPACE(ch) _PyUnicode_IsWhitespace(ch)
+
+#define Py_UNICODE_ISLOWER(ch) _PyUnicode_IsLowercase(ch)
+#define Py_UNICODE_ISUPPER(ch) _PyUnicode_IsUppercase(ch)
+#define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
+#define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)
+
+#define Py_UNICODE_TOLOWER(ch) _PyUnicode_ToLowercase(ch)
+#define Py_UNICODE_TOUPPER(ch) _PyUnicode_ToUppercase(ch)
+#define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)
+
+#define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
+#define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
+#define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
+
+#define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
+#define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
+#define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)
+
+#define Py_UNICODE_ISALPHA(ch) _PyUnicode_IsAlpha(ch)
+
+#endif
+
+#define Py_UNICODE_ISALNUM(ch) \
+       (Py_UNICODE_ISALPHA(ch) || \
+        Py_UNICODE_ISDECIMAL(ch) || \
+        Py_UNICODE_ISDIGIT(ch) || \
+        Py_UNICODE_ISNUMERIC(ch))
+
+#define Py_UNICODE_COPY(target, source, length)\
+    (memcpy((target), (source), (length)*sizeof(Py_UNICODE)))
+
+#define Py_UNICODE_FILL(target, value, length) do\
+    {int i; for (i = 0; i &lt; (length); i++) (target)[i] = (value);}\
+    while (0)
+
+#define Py_UNICODE_MATCH(string, offset, substring)\
+    ((*((string)-&gt;str + (offset)) == *((substring)-&gt;str)) &amp;&amp;\
+     !memcmp((string)-&gt;str + (offset), (substring)-&gt;str,\
+             (substring)-&gt;length*sizeof(Py_UNICODE)))
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* --- Unicode Type ------------------------------------------------------- */
+
+typedef struct {
+    PyObject_HEAD
+    int length;			/* Length of raw Unicode data in buffer */
+    Py_UNICODE *str;		/* Raw Unicode buffer */
+    long hash;			/* Hash value; -1 if not set */
+    PyObject *defenc;		/* (Default) Encoded version as Python
+				   string, or NULL; this is used for
+				   implementing the buffer protocol */
+} PyUnicodeObject;
+
+PyAPI_DATA(PyTypeObject) PyUnicode_Type;
+
+#define PyUnicode_Check(op) PyObject_TypeCheck(op, &amp;PyUnicode_Type)
+#define PyUnicode_CheckExact(op) ((op)-&gt;ob_type == &amp;PyUnicode_Type)
+
+/* Fast access macros */
+#define PyUnicode_GET_SIZE(op) \
+        (((PyUnicodeObject *)(op))-&gt;length)
+#define PyUnicode_GET_DATA_SIZE(op) \
+        (((PyUnicodeObject *)(op))-&gt;length * sizeof(Py_UNICODE))
+#define PyUnicode_AS_UNICODE(op) \
+        (((PyUnicodeObject *)(op))-&gt;str)
+#define PyUnicode_AS_DATA(op) \
+        ((const char *)((PyUnicodeObject *)(op))-&gt;str)
+
+/* --- Constants ---------------------------------------------------------- */
+
+/* This Unicode character will be used as replacement character during
+   decoding if the errors argument is set to &quot;replace&quot;. Note: the
+   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
+   Unicode 3.0. */
+
+#define Py_UNICODE_REPLACEMENT_CHARACTER ((Py_UNICODE) 0xFFFD)
+
+/* === Public API ========================================================= */
+
+/* --- Plain Py_UNICODE --------------------------------------------------- */
+
+/* Create a Unicode Object from the Py_UNICODE buffer u of the given
+   size. 
+
+   u may be NULL which causes the contents to be undefined. It is the
+   user's responsibility to fill in the needed data afterwards. Note
+   that modifying the Unicode object contents after construction is
+   only allowed if u was set to NULL.
+
+   The buffer is copied into the new object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromUnicode(
+    const Py_UNICODE *u,        /* Unicode buffer */
+    int size                    /* size of buffer */
+    );
+
+/* Return a read-only pointer to the Unicode object's internal
+   Py_UNICODE buffer. */
+
+PyAPI_FUNC(Py_UNICODE *) PyUnicode_AsUnicode(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Get the length of the Unicode object. */
+
+PyAPI_FUNC(int) PyUnicode_GetSize(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Get the maximum ordinal for a Unicode character. */
+PyAPI_FUNC(Py_UNICODE) PyUnicode_GetMax(void);
+
+/* Resize an already allocated Unicode object to the new size length.
+
+   *unicode is modified to point to the new (resized) object and 0
+   returned on success.
+
+   This API may only be called by the function which also called the
+   Unicode constructor. The refcount on the object must be 1. Otherwise,
+   an error is returned.
+
+   Error handling is implemented as follows: an exception is set, -1
+   is returned and *unicode left untouched.
+
+*/
+
+PyAPI_FUNC(int) PyUnicode_Resize(
+    PyObject **unicode,		/* Pointer to the Unicode object */
+    int length			/* New length */
+    );
+
+/* Coerce obj to an Unicode object and return a reference with
+   *incremented* refcount.
+
+   Coercion is done in the following way:
+
+   1. String and other char buffer compatible objects are decoded
+      under the assumptions that they contain data using the current
+      default encoding. Decoding is done in &quot;strict&quot; mode.
+
+   2. All other objects (including Unicode objects) raise an
+      exception.
+
+   The API returns NULL in case of an error. The caller is responsible
+   for decref'ing the returned objects.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
+    register PyObject *obj, 	/* Object */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Coerce obj to an Unicode object and return a reference with
+   *incremented* refcount.
+   
+   Unicode objects are passed back as-is (subclasses are converted to
+   true Unicode objects), all other objects are delegated to
+   PyUnicode_FromEncodedObject(obj, NULL, &quot;strict&quot;) which results in
+   using the default encoding as basis for decoding the object.
+
+   The API returns NULL in case of an error. The caller is responsible
+   for decref'ing the returned objects.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
+    register PyObject *obj 	/* Object */
+    );
+
+/* --- wchar_t support for platforms which support it --------------------- */
+
+#ifdef HAVE_WCHAR_H
+
+/* Create a Unicode Object from the whcar_t buffer w of the given
+   size.
+
+   The buffer is copied into the new object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
+    register const wchar_t *w,  /* wchar_t buffer */
+    int size                    /* size of buffer */
+    );
+
+/* Copies the Unicode Object contents into the wchar_t buffer w.  At
+   most size wchar_t characters are copied.
+
+   Note that the resulting wchar_t string may or may not be
+   0-terminated.  It is the responsibility of the caller to make sure
+   that the wchar_t string is 0-terminated in case this is required by
+   the application.
+
+   Returns the number of wchar_t characters copied (excluding a
+   possibly trailing 0-termination character) or -1 in case of an
+   error. */
+
+PyAPI_FUNC(int) PyUnicode_AsWideChar(
+    PyUnicodeObject *unicode,   /* Unicode object */
+    register wchar_t *w,        /* wchar_t buffer */
+    int size                    /* size of buffer */
+    );
+
+#endif
+
+/* --- Unicode ordinals --------------------------------------------------- */
+
+/* Create a Unicode Object from the given Unicode code point ordinal. 
+ 
+   The ordinal must be in range(0x10000) on narrow Python builds
+   (UCS2), and range(0x110000) on wide builds (UCS4). A ValueError is
+   raised in case it is not.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);
+
+/* === Builtin Codecs ===================================================== 
+
+   Many of these APIs take two arguments encoding and errors. These
+   parameters encoding and errors have the same semantics as the ones
+   of the builtin unicode() API. 
+
+   Setting encoding to NULL causes the default encoding to be used.
+
+   Error handling is set by errors which may also be set to NULL
+   meaning to use the default handling defined for the codec. Default
+   error handling for all builtin codecs is &quot;strict&quot; (ValueErrors are
+   raised).
+
+   The codecs all use a similar interface. Only deviation from the
+   generic ones are documented.
+
+*/
+
+/* --- Manage the default encoding ---------------------------------------- */
+
+/* Return a Python string holding the default encoded value of the
+   Unicode object. 
+
+   The resulting string is cached in the Unicode object for subsequent
+   usage by this function. The cached version is needed to implement
+   the character buffer interface and will live (at least) as long as
+   the Unicode object itself.
+
+   The refcount of the string is *not* incremented.
+
+   *** Exported for internal use by the interpreter only !!! ***
+
+*/
+
+PyAPI_FUNC(PyObject *) _PyUnicode_AsDefaultEncodedString(
+    PyObject *, const char *);
+
+/* Returns the currently active default encoding.
+
+   The default encoding is currently implemented as run-time settable
+   process global.  This may change in future versions of the
+   interpreter to become a parameter which is managed on a per-thread
+   basis.
+   
+ */
+
+PyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);
+
+/* Sets the currently active default encoding.
+
+   Returns 0 on success, -1 in case of an error.
+   
+ */
+
+PyAPI_FUNC(int) PyUnicode_SetDefaultEncoding(
+    const char *encoding	/* Encoding name in standard form */
+    );
+
+/* --- Generic Codecs ----------------------------------------------------- */
+
+/* Create a Unicode object by decoding the encoded string s of the
+   given size. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Decode(
+    const char *s,              /* encoded string */
+    int size,                   /* size of buffer */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a Py_UNICODE buffer of the given size and returns a 
+   Python string object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Encode(
+    const Py_UNICODE *s,        /* Unicode char buffer */
+    int size,                   /* number of Py_UNICODE chars to encode */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a Unicode object and returns the result as Python
+   object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(
+    PyObject *unicode,	 	/* Unicode object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Encodes a Unicode object and returns the result as Python string
+   object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(
+    PyObject *unicode,	 	/* Unicode object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-7 Codecs ------------------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(
+    const char *string, 	/* UTF-7 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF7(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    int encodeSetO,             /* force the encoder to encode characters in
+                                   Set O, as described in RFC2152 */
+    int encodeWhiteSpace,       /* force the encoder to encode space, tab,
+                                   carriage return and linefeed characters */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-8 Codecs ------------------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(
+    const char *string, 	/* UTF-8 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(
+    const char *string, 	/* UTF-8 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *consumed		/* bytes consumed */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF8(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-16 Codecs ------------------------------------------------------ */
+
+/* Decodes length bytes from a UTF-16 encoded buffer string and returns
+   the corresponding Unicode object.
+
+   errors (if non-NULL) defines the error handling. It defaults
+   to &quot;strict&quot;. 
+
+   If byteorder is non-NULL, the decoder starts decoding using the
+   given byte order:
+
+	*byteorder == -1: little endian
+	*byteorder == 0:  native order
+	*byteorder == 1:  big endian
+
+   In native mode, the first two bytes of the stream are checked for a
+   BOM mark. If found, the BOM mark is analysed, the byte order
+   adjusted and the BOM skipped.  In the other modes, no BOM mark
+   interpretation is done. After completion, *byteorder is set to the
+   current byte order at the end of input data.
+
+   If byteorder is NULL, the codec starts in native order mode.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(
+    const char *string, 	/* UTF-16 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *byteorder		/* pointer to byteorder to use
+				   0=native;-1=LE,1=BE; updated on
+				   exit */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(
+    const char *string, 	/* UTF-16 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *byteorder,		/* pointer to byteorder to use
+				   0=native;-1=LE,1=BE; updated on
+				   exit */
+    int *consumed		/* bytes consumed */
+    );
+
+/* Returns a Python string using the UTF-16 encoding in native byte
+   order. The string always starts with a BOM mark.  */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Returns a Python string object holding the UTF-16 encoded value of
+   the Unicode data.
+
+   If byteorder is not 0, output is written according to the following
+   byte order:
+
+   byteorder == -1: little endian
+   byteorder == 0:  native byte order (writes a BOM mark)
+   byteorder == 1:  big endian
+
+   If byteorder is 0, the output string will always start with the
+   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
+   prepended.
+
+   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
+   UCS-2. This trick makes it possible to add full UTF-16 capabilities
+   at a later point without compromising the APIs.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF16(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    const char *errors,		/* error handling */
+    int byteorder		/* byteorder to use 0=BOM+native;-1=LE,1=BE */
+    );
+
+/* --- Unicode-Escape Codecs ---------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(
+    const char *string, 	/* Unicode-Escape encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUnicodeEscape(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length	 		/* Number of Py_UNICODE chars to encode */
+    );
+
+/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(
+    const char *string, 	/* Raw-Unicode-Escape encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeRawUnicodeEscape(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length	 		/* Number of Py_UNICODE chars to encode */
+    );
+
+/* --- Latin-1 Codecs ----------------------------------------------------- 
+
+   Note: Latin-1 corresponds to the first 256 Unicode ordinals.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(
+    const char *string, 	/* Latin-1 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeLatin1(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- ASCII Codecs ------------------------------------------------------- 
+
+   Only 7-bit ASCII data is excepted. All other codes generate errors.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(
+    const char *string, 	/* ASCII encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeASCII(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- Character Map Codecs ----------------------------------------------- 
+
+   This codec uses mappings to encode and decode characters. 
+
+   Decoding mappings must map single string characters to single
+   Unicode characters, integers (which are then interpreted as Unicode
+   ordinals) or None (meaning &quot;undefined mapping&quot; and causing an
+   error).
+
+   Encoding mappings must map single Unicode characters to single
+   string characters, integers (which are then interpreted as Latin-1
+   ordinals) or None (meaning &quot;undefined mapping&quot; and causing an
+   error).
+
+   If a character lookup fails with a LookupError, the character is
+   copied as-is meaning that its ordinal value will be interpreted as
+   Unicode or Latin-1 ordinal resp. Because of this mappings only need
+   to contain those mappings which map characters to different code
+   points.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(
+    const char *string, 	/* Encoded string */
+    int length,	 		/* size of string */
+    PyObject *mapping,		/* character mapping 
+				   (char ordinal -&gt; unicode ordinal) */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(
+    PyObject *unicode,	 	/* Unicode object */
+    PyObject *mapping		/* character mapping 
+				   (unicode ordinal -&gt; char ordinal) */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeCharmap(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    PyObject *mapping,		/* character mapping 
+				   (unicode ordinal -&gt; char ordinal) */
+    const char *errors		/* error handling */
+    );
+
+/* Translate a Py_UNICODE buffer of the given length by applying a
+   character mapping table to it and return the resulting Unicode
+   object.
+
+   The mapping table must map Unicode ordinal integers to Unicode
+   ordinal integers or None (causing deletion of the character). 
+
+   Mapping tables may be dictionaries or sequences. Unmapped character
+   ordinals (ones which cause a LookupError) are left untouched and
+   are copied as-is.
+
+*/
+
+PyAPI_FUNC(PyObject *) PyUnicode_TranslateCharmap(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    PyObject *table,		/* Translate table */
+    const char *errors		/* error handling */
+    );
+
+#ifdef MS_WIN32
+
+/* --- MBCS codecs for Windows -------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(
+    const char *string,         /* MBCS encoded string */
+    int length,                 /* size of string */
+    const char *errors          /* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(
+    PyObject *unicode           /* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeMBCS(
+    const Py_UNICODE *data,     /* Unicode char buffer */
+    int length,                 /* Number of Py_UNICODE chars to encode */
+    const char *errors          /* error handling */
+    );
+
+#endif /* MS_WIN32 */
+
+/* --- Decimal Encoder ---------------------------------------------------- */
+
+/* Takes a Unicode string holding a decimal value and writes it into
+   an output buffer using standard ASCII digit codes.
+
+   The output buffer has to provide at least length+1 bytes of storage
+   area. The output string is 0-terminated.
+
+   The encoder converts whitespace to ' ', decimal characters to their
+   corresponding ASCII digit and all other Latin-1 characters except
+   \0 as-is. Characters outside this range (Unicode ordinals 1-256)
+   are treated as errors. This includes embedded NULL bytes.
+
+   Error handling is defined by the errors argument:
+
+      NULL or &quot;strict&quot;: raise a ValueError
+      &quot;ignore&quot;: ignore the wrong characters (these are not copied to the
+		output buffer)
+      &quot;replace&quot;: replaces illegal characters with '?'
+
+   Returns 0 on success, -1 on failure.
+
+*/
+
+PyAPI_FUNC(int) PyUnicode_EncodeDecimal(
+    Py_UNICODE *s,		/* Unicode buffer */
+    int length,			/* Number of Py_UNICODE chars to encode */
+    char *output,		/* Output buffer; must have size &gt;= length */
+    const char *errors		/* error handling */
+    );
+
+/* --- Methods &amp; Slots ----------------------------------------------------
+
+   These are capable of handling Unicode objects and strings on input
+   (we refer to them as strings in the descriptions) and return
+   Unicode objects or integers as apporpriate. */
+
+/* Concat two strings giving a new Unicode string. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Concat(
+    PyObject *left,	 	/* Left string */
+    PyObject *right	 	/* Right string */
+    );
+
+/* Split a string giving a list of Unicode strings.
+
+   If sep is NULL, splitting will be done at all whitespace
+   substrings. Otherwise, splits occur at the given separator.
+
+   At most maxsplit splits will be done. If negative, no limit is set.
+
+   Separators are not included in the resulting list.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_Split(
+    PyObject *s,		/* String to split */
+    PyObject *sep,		/* String separator */
+    int maxsplit		/* Maxsplit count */
+    );		
+
+/* Dito, but split at line breaks.
+
+   CRLF is considered to be one line break. Line breaks are not
+   included in the resulting list. */
+    
+PyAPI_FUNC(PyObject*) PyUnicode_Splitlines(
+    PyObject *s,		/* String to split */
+    int keepends		/* If true, line end markers are included */
+    );		
+
+/* Split a string giving a list of Unicode strings.
+
+   If sep is NULL, splitting will be done at all whitespace
+   substrings. Otherwise, splits occur at the given separator.
+
+   At most maxsplit splits will be done. But unlike PyUnicode_Split
+   PyUnicode_RSplit splits from the end of the string. If negative,
+   no limit is set.
+
+   Separators are not included in the resulting list.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_RSplit(
+    PyObject *s,		/* String to split */
+    PyObject *sep,		/* String separator */
+    int maxsplit		/* Maxsplit count */
+    );		
+
+/* Translate a string by applying a character mapping table to it and
+   return the resulting Unicode object.
+
+   The mapping table must map Unicode ordinal integers to Unicode
+   ordinal integers or None (causing deletion of the character). 
+
+   Mapping tables may be dictionaries or sequences. Unmapped character
+   ordinals (ones which cause a LookupError) are left untouched and
+   are copied as-is.
+
+*/
+
+PyAPI_FUNC(PyObject *) PyUnicode_Translate(
+    PyObject *str,		/* String */ 
+    PyObject *table,		/* Translate table */
+    const char *errors		/* error handling */
+    );
+
+/* Join a sequence of strings using the given separator and return
+   the resulting Unicode string. */
+    
+PyAPI_FUNC(PyObject*) PyUnicode_Join(
+    PyObject *separator, 	/* Separator string */
+    PyObject *seq	 	/* Sequence object */
+    );
+
+/* Return 1 if substr matches str[start:end] at the given tail end, 0
+   otherwise. */
+
+PyAPI_FUNC(int) PyUnicode_Tailmatch(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Prefix or Suffix string */
+    int start,			/* Start index */
+    int end,			/* Stop index */
+    int direction		/* Tail end: -1 prefix, +1 suffix */
+    );
+
+/* Return the first position of substr in str[start:end] using the
+   given search direction or -1 if not found. -2 is returned in case
+   an error occurred and an exception is set. */
+
+PyAPI_FUNC(int) PyUnicode_Find(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to find */
+    int start,			/* Start index */
+    int end,			/* Stop index */
+    int direction		/* Find direction: +1 forward, -1 backward */
+    );
+
+/* Count the number of occurrences of substr in str[start:end]. */
+
+PyAPI_FUNC(int) PyUnicode_Count(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to count */
+    int start,			/* Start index */
+    int end			/* Stop index */
+    );
+
+/* Replace at most maxcount occurrences of substr in str with replstr
+   and return the resulting Unicode object. */
+
+PyAPI_FUNC(PyObject *) PyUnicode_Replace(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to find */
+    PyObject *replstr,		/* Substring to replace */
+    int maxcount		/* Max. number of replacements to apply;
+				   -1 = all */
+    );
+
+/* Compare two strings and return -1, 0, 1 for less than, equal,
+   greater than resp. */
+
+PyAPI_FUNC(int) PyUnicode_Compare(
+    PyObject *left,		/* Left string */ 
+    PyObject *right		/* Right string */
+    );
+
+/* Apply a argument tuple or dictionary to a format string and return
+   the resulting Unicode string. */
+
+PyAPI_FUNC(PyObject *) PyUnicode_Format(
+    PyObject *format,		/* Format string */ 
+    PyObject *args		/* Argument tuple or dictionary */
+    );
+
+/* Checks whether element is contained in container and return 1/0
+   accordingly.
+
+   element has to coerce to an one element Unicode string. -1 is
+   returned in case of an error. */
+
+PyAPI_FUNC(int) PyUnicode_Contains(
+    PyObject *container,	/* Container string */ 
+    PyObject *element		/* Element string */
+    );
+
+/* Externally visible for str.strip(unicode) */
+PyAPI_FUNC(PyObject *) _PyUnicode_XStrip(
+    PyUnicodeObject *self,
+    int striptype,
+    PyObject *sepobj
+    );
+
+/* === Characters Type APIs =============================================== */
+
+/* These should not be used directly. Use the Py_UNICODE_IS* and
+   Py_UNICODE_TO* macros instead. 
+
+   These APIs are implemented in Objects/unicodectype.c.
+
+*/
+
+PyAPI_FUNC(int) _PyUnicode_IsLowercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsUppercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsTitlecase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsWhitespace(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsLinebreak(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToLowercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToUppercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToTitlecase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_ToDecimalDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_ToDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(double) _PyUnicode_ToNumeric(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsDecimalDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsNumeric(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsAlpha(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* Py_USING_UNICODE */
+#endif /* !Py_UNICODEOBJECT_H */

Added: trunk/mingw-libs/include/weakrefobject.h
===================================================================
--- trunk/mingw-libs/include/weakrefobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/weakrefobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,75 @@
+/* Weak references objects for Python. */
+
+#ifndef Py_WEAKREFOBJECT_H
+#define Py_WEAKREFOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+typedef struct _PyWeakReference PyWeakReference;
+
+/* PyWeakReference is the base struct for the Python ReferenceType, ProxyType,
+ * and CallableProxyType.
+ */
+struct _PyWeakReference {
+    PyObject_HEAD
+
+    /* The object to which this is a weak reference, or Py_None if none.
+     * Note that this is a stealth reference:  wr_object's refcount is
+     * not incremented to reflect this pointer.
+     */
+    PyObject *wr_object;
+
+    /* A callable to invoke when wr_object dies, or NULL if none. */
+    PyObject *wr_callback;
+
+    /* A cache for wr_object's hash code.  As usual for hashes, this is -1
+     * if the hash code isn't known yet.
+     */
+    long hash;
+
+    /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL-
+     * terminated list of weak references to it.  These are the list pointers.
+     * If wr_object goes away, wr_object is set to Py_None, and these pointers
+     * have no meaning then.
+     */
+    PyWeakReference *wr_prev;
+    PyWeakReference *wr_next;
+};
+
+PyAPI_DATA(PyTypeObject) _PyWeakref_RefType;
+PyAPI_DATA(PyTypeObject) _PyWeakref_ProxyType;
+PyAPI_DATA(PyTypeObject) _PyWeakref_CallableProxyType;
+
+#define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &amp;_PyWeakref_RefType)
+#define PyWeakref_CheckRefExact(op) \
+        ((op)-&gt;ob_type == &amp;_PyWeakref_RefType)
+#define PyWeakref_CheckProxy(op) \
+        (((op)-&gt;ob_type == &amp;_PyWeakref_ProxyType) || \
+         ((op)-&gt;ob_type == &amp;_PyWeakref_CallableProxyType))
+
+/* This macro calls PyWeakref_CheckRef() last since that can involve a
+   function call; this makes it more likely that the function call
+   will be avoided. */
+#define PyWeakref_Check(op) \
+        (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
+
+
+PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
+                                              PyObject *callback);
+PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
+                                                PyObject *callback);
+PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+
+PyAPI_FUNC(long) _PyWeakref_GetWeakrefCount(PyWeakReference *head);
+
+PyAPI_FUNC(void) _PyWeakref_ClearRef(PyWeakReference *self);
+
+#define PyWeakref_GET_OBJECT(ref) (((PyWeakReference *)(ref))-&gt;wr_object)
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_WEAKREFOBJECT_H */

Added: trunk/mingw-libs/include/zconf.h
===================================================================
--- trunk/mingw-libs/include/zconf.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/zconf.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,326 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2004 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The &quot;standard&quot; zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) &amp;&amp; !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) &amp;&amp; !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) &amp;&amp; !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if (defined(_WIN32) || defined(__WIN32__)) &amp;&amp; !defined(WIN32)
+#  define WIN32
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) &amp;&amp; !defined(WIN32)
+#  if !defined(__GNUC__) &amp;&amp; !defined(__FLAT__) &amp;&amp; !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ &gt;= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) &amp;&amp; (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) &amp;&amp; !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) &amp;&amp; !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS=&quot;-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7&quot;
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 &lt;&lt; windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) &amp;&amp; (!defined(__BORLANDC__) || (__BORLANDC__ &gt;= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include &lt;windows.h&gt;
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#if 1           /* HAVE_UNISTD_H -- this line is updated by ./configure */
+#  include &lt;sys/types.h&gt; /* for off_t */
+#  include &lt;unistd.h&gt;    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include &lt;unixio.h&gt;   /* for off_t */
+#  endif
+#  define z_off_t off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus &quot;offset&quot; */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,&quot;DEIN&quot;)
+#   pragma map(deflateInit2_,&quot;DEIN2&quot;)
+#   pragma map(deflateEnd,&quot;DEEND&quot;)
+#   pragma map(deflateBound,&quot;DEBND&quot;)
+#   pragma map(inflateInit_,&quot;ININ&quot;)
+#   pragma map(inflateInit2_,&quot;ININ2&quot;)
+#   pragma map(inflateEnd,&quot;INEND&quot;)
+#   pragma map(inflateSync,&quot;INSY&quot;)
+#   pragma map(inflateSetDictionary,&quot;INSEDI&quot;)
+#   pragma map(compressBound,&quot;CMBND&quot;)
+#   pragma map(inflate_table,&quot;INTABL&quot;)
+#   pragma map(inflate_fast,&quot;INFA&quot;)
+#   pragma map(inflate_copyright,&quot;INCOPY&quot;)
+#endif
+
+#endif /* ZCONF_H */

Added: trunk/mingw-libs/include/zlib.h
===================================================================
--- trunk/mingw-libs/include/zlib.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/zlib.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,1200 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.2, October 3rd, 2004
+
+  Copyright (C) 1995-2004 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">jloup at gzip.org</A>          <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">madler at alumni.caltech.edu</A>
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files <A HREF="http://www.ietf.org/rfc/rfc1950.txt">http://www.ietf.org/rfc/rfc1950.txt</A>
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include &quot;zconf.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define ZLIB_VERSION &quot;1.2.2&quot;
+#define ZLIB_VERNUM 0x1220
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with &quot;gz&quot;.  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: ascii or binary */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions &lt; 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/*
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  the compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out is greater than six to avoid repeated flush markers due to
+  avail_out == 0 on return.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  the value returned by deflateBound (see below). If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm-&gt;adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update data_type if it can make a good guess about
+  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+  fatal, and deflate() can be called again with more input and more output
+  space to continue compressing.
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/*
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it get to the next deflate block boundary. When decoding the zlib
+  or gzip format, this will cause inflate() to return immediately after the
+  header and before the first block. When doing a raw inflate, inflate() will
+  go ahead and process the first block, and will return when it gets to the end
+  of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm-&gt;data_type to the
+  number of unused bits in the last byte taken from strm-&gt;next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm-&gt;next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm-&gt;adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm-&gt;adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer). It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+   determines the window size. deflate() will then generate raw deflate data
+   with no zlib header or trailer, and will not compute an adler32 check value.
+
+     windowBits can also be greater than 15 for optional gzip encoding. Add
+   16 to windowBits to write a simple gzip header and trailer around the
+   compressed data instead of a zlib wrapper. The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero),
+   no header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm-&gt;adler is a crc32 instead of an adler32.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match), or Z_RLE to limit match distances to one (run-length
+   encoding). Filtered data consists mostly of small values with a somewhat
+   random distribution. In this case, the compression algorithm is tuned to
+   compress them better. The effect of Z_FILTERED is to force more Huffman
+   coding and less string matching; it is somewhat intermediate between
+   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+   parameter only affects the compression ratio but not the correctness of the
+   compressed output even if it is not set appropriately.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front.
+
+     Upon return of this function, strm-&gt;adler is set to the adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.) If a raw deflate was requested, then the
+   adler32 value is not computed and strm-&gt;adler is not set.
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                      int level,
+                                      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm-&gt;avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm-&gt;avail_out was zero.
+*/
+
+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                       uLong sourceLen));
+/*
+     deflateBound() returns an upper bound on the compressed size after
+   deflation of sourceLen bytes.  It must be called after deflateInit()
+   or deflateInit2().  This would be used to allocate an output buffer
+   for deflation in a single pass, and so would be called before deflate().
+*/
+
+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     deflatePrime() inserts bits in the deflate output stream.  The intent
+  is that this function is used to start off the deflate output with the
+  bits leftover from a previous deflate stream when appending to it.  As such,
+  this function can only be used for raw deflate, and must be used before the
+  first deflate() call after a deflateInit2() or deflateReset().  bits must be
+  less than or equal to 16, and that many of the least significant bits of
+  value will be inserted in the output.
+
+      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. windowBits must be greater than or equal to the windowBits value
+   provided to deflateInit2() while compressing, or it must be equal to 15 if
+   deflateInit2() was not used. If a compressed stream with a larger window
+   size is given as input, inflate() will return with the error code
+   Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+   determines the window size. inflate() will then process raw deflate data,
+   not looking for a zlib or gzip header, not generating a check value, and not
+   looking for any check values for comparison at the end of the stream. This
+   is for use with other formats that use the deflate compressed data format
+   such as zip.  Those formats provide their own check values. If a custom
+   format is developed using the raw deflate format for compressed data, it is
+   recommended that a check value such as an adler32 or a crc32 be applied to
+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+   most applications, the zlib format should be used as is. Note that comments
+   above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+     windowBits can also be greater than 15 for optional gzip decoding. Add
+   32 to windowBits to enable zlib and gzip decoding with automatic header
+   detection, or add 16 to decode only the gzip format (the zlib format will
+   return a Z_DATA_ERROR.  If a gzip stream is being decoded, strm-&gt;adler is
+   a crc32 instead of an adler32.
+
+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
+   memLevel). msg is set to null if there is no error message.  inflateInit2
+   does not perform any decompression apart from reading the zlib header if
+   present: this will be done by inflate(). (So next_in and avail_in may be
+   modified, but next_out and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate
+   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by this call of
+   inflate. The compressor and decompressor must use exactly the same
+   dictionary (see deflateSetDictionary).
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/*
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when randomly accessing a large stream.  The
+   first pass through the stream can periodically record the inflate state,
+   allowing restarting inflate at those points when randomly accessing the
+   stream.
+
+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateBackInit OF((z_stream FAR *strm, int windowBits,
+                                        unsigned char FAR *window));
+
+     Initialize the internal stream state for decompression using inflateBack()
+   calls.  The fields zalloc, zfree and opaque in strm must be initialized
+   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   derived memory allocation routines are used.  windowBits is the base two
+   logarithm of the window size, in the range 8..15.  window is a caller
+   supplied buffer of that size.  Except for special applications where it is
+   assured that deflate was used with small window sizes, windowBits must be 15
+   and a 32K byte window must be supplied to be able to decompress general
+   deflate streams.
+
+     See inflateBack() for the usage of these routines.
+
+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+   be allocated, or Z_VERSION_ERROR if the version of the library does not
+   match the version of the header file.
+*/
+
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
+
+ZEXTERN int ZEXPORT inflateBack OF((z_stream FAR *strm,
+                                    in_func in, void FAR *in_desc,
+                                    out_func out, void FAR *out_desc));
+/*
+     inflateBack() does a raw inflate with a single call using a call-back
+   interface for input and output.  This is more efficient than inflate() for
+   file i/o applications in that it avoids copying between the output and the
+   sliding window by simply making the window itself the output buffer.  This
+   function trusts the application to not change the output buffer passed by
+   the output function, at least until inflateBack() returns.
+
+     inflateBackInit() must be called first to allocate the internal state
+   and to initialize the state with the user-provided window buffer.
+   inflateBack() may then be used multiple times to inflate a complete, raw
+   deflate stream with each call.  inflateBackEnd() is then called to free
+   the allocated state.
+
+     A raw deflate stream is one with no zlib or gzip header or trailer.
+   This routine would normally be used in a utility that reads zip or gzip
+   files and writes out uncompressed files.  The utility would decode the
+   header and process the trailer on its own, hence this routine expects
+   only the raw deflate stream to decompress.  This is different from the
+   normal behavior of inflate(), which expects either a zlib or gzip header and
+   trailer around the deflate stream.
+
+     inflateBack() uses two subroutines supplied by the caller that are then
+   called by inflateBack() for input and output.  inflateBack() calls those
+   routines until it reads a complete deflate stream and writes out all of the
+   uncompressed data, or until it encounters an error.  The function's
+   parameters and return types are defined above in the in_func and out_func
+   typedefs.  inflateBack() will call in(in_desc, &amp;buf) which should return the
+   number of bytes of provided input, and a pointer to that input in buf.  If
+   there is no input available, in() must return zero--buf is ignored in that
+   case--and inflateBack() will return a buffer error.  inflateBack() will call
+   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+   should return zero on success, or non-zero on failure.  If out() returns
+   non-zero, inflateBack() will return with an error.  Neither in() nor out()
+   are permitted to change the contents of the window provided to
+   inflateBackInit(), which is also the buffer that out() uses to write from.
+   The length written by out() will be at most the window size.  Any non-zero
+   amount of input may be provided by in().
+
+     For convenience, inflateBack() can be provided input on the first call by
+   setting strm-&gt;next_in and strm-&gt;avail_in.  If that input is exhausted, then
+   in() will be called.  Therefore strm-&gt;next_in must be initialized before
+   calling inflateBack().  If strm-&gt;next_in is Z_NULL, then in() will be called
+   immediately for input.  If strm-&gt;next_in is not Z_NULL, then strm-&gt;avail_in
+   must also be initialized, and then if strm-&gt;avail_in is not zero, input will
+   initially be taken from strm-&gt;next_in[0 .. strm-&gt;avail_in - 1].
+
+     The in_desc and out_desc parameters of inflateBack() is passed as the
+   first parameter of in() and out() respectively when they are called.  These
+   descriptors can be optionally used to pass any information that the caller-
+   supplied in() and out() functions need to do their job.
+
+     On return, inflateBack() will set strm-&gt;next_in and strm-&gt;avail_in to
+   pass back any unused input that was provided by the last in() call.  The
+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format
+   error in the deflate stream (in which case strm-&gt;msg is set to indicate the
+   nature of the error), or Z_STREAM_ERROR if the stream was not properly
+   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+   distinguished using strm-&gt;next_in which will be Z_NULL only if in() returned
+   an error.  If strm-&gt;next is not Z_NULL, then the Z_BUF_ERROR was due to
+   out() returning non-zero.  (in() will always be called before out(), so
+   strm-&gt;next_in is assured to be defined if out() returns non-zero.)  Note
+   that inflateBack() cannot return Z_OK.
+*/
+
+ZEXTERN int ZEXPORT inflateBackEnd OF((z_stream FAR *strm));
+/*
+     All memory allocated by inflateBackInit() is freed.
+
+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+   state was inconsistent.
+*/
+
+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+/* Return flags indicating compile-time options.
+
+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+     1.0: size of uInt
+     3.2: size of uLong
+     5.4: size of voidpf (pointer)
+     7.6: size of z_off_t
+
+    Compiler, assembler, and debug options:
+     8: DEBUG
+     9: ASMV or ASMINF -- use ASM code
+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+     11: 0 (reserved)
+
+    One-time table building (smaller code, but not thread-safe if true):
+     12: BUILDFIXED -- build static block decoding tables when needed
+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+     14,15: 0 (reserved)
+
+    Library content (indicates missing functionality):
+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                          deflate code when not needed)
+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                    and decode gzip streams (to avoid linking crc code)
+     18-19: 0 (reserved)
+
+    Operation variations (changes in library functionality):
+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+     21: FASTEST -- deflate algorithm with only one, lowest compression level
+     22,23: 0 (reserved)
+
+    The sprintf variant used by gzprintf (zero is best):
+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+    Remainder:
+     27-31: 0 (reserved)
+ */
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least the value returned
+   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least the value returned by
+   compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+/*
+     compressBound() returns an upper bound on the compressed size after
+   compress() or compress2() on sourceLen bytes.  It would be used before
+   a compress() or compress2() call to allocate the destination buffer.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen (&quot;rb&quot; or &quot;wb&quot;) but can also include a compression level
+   (&quot;wb9&quot;) or a strategy: 'f' for filtered data as in &quot;wb6f&quot;, 'h' for
+   Huffman only compression as in &quot;wb1h&quot;, or 'R' for run-length encoding
+   as in &quot;wb1R&quot;. (See the description of deflateInit2 for more information
+   about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                   voidpc buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).  The number of
+   uncompressed bytes written is limited to 4095. The caller should assure that
+   this limit is not exceeded. If it is exceeded, then gzprintf() will return
+   return an error (0) with nothing written. In this case, there may also be a
+   buffer overflow with unpredictable consequences, which is possible only if
+   zlib was compiled with the insecure functions sprintf() or vsprintf()
+   because the secure snprintf() or vsnprintf() functions were not available.
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+/*
+      Push one character back onto the stream to be read again later.
+   Only one character of push-back is allowed.  gzungetc() returns the
+   character pushed, or -1 on failure.  gzungetc() will fail if a
+   character has been pushed but not read yet, or if c is -1. The pushed
+   character will be discarded if the stream is repositioned with gzseek()
+   or gzrewind().
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                      z_off_t offset, int whence));
+/*
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+/*
+     Clears the error and end-of-file flags for file. This is analogous to the
+   clearerr() function in stdio. This is useful for continuing to read a gzip
+   file that is being written concurrently.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running crc with the bytes buf[0..len-1] and return the updated
+   crc. If buf is NULL, this function returns the required initial value
+   for the crc. Pre- and post-conditioning (one's complement) is performed
+   within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_stream FAR *strm, int windowBits,
+                                         unsigned char FAR *window,
+                                         const char *version,
+                                         int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) &amp;&amp; !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */

Added: trunk/mingw-libs/lib/libpython24.a
===================================================================
(Binary files differ)


Property changes on: trunk/mingw-libs/lib/libpython24.a
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/mingw-libs/lib/libz.a
===================================================================
(Binary files differ)


Property changes on: trunk/mingw-libs/lib/libz.a
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/python24.dll
===================================================================
(Binary files differ)


Property changes on: trunk/python24.dll
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/games/ggob.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -47,6 +47,8 @@
 #include &quot;other/dialogs.h&quot;
 #include &quot;other/twconfig.h&quot;
 
+#include &quot;python/python_class.h&quot;
+
 #define gobgame ((GobGame*)game)
 
 ////////////////////////////////////////////////////////////////////////
@@ -253,10 +255,15 @@
   StarSystem* s = new StarSystem(&quot;FakeSystem_123&quot;, Vector2(0,0));
   _name = &quot;FakeSystem_123&quot;;
   _galaxy.add(s);
+
+  /*
   if(Load(data_full_path(&quot;xml/GOB/start.xml&quot;)) == 1)
     {
       tw_error(&quot;unable to locate start.xml&quot;);
     };  
+  */
+
+  python::exec_file(&quot;start&quot;);
   
   _galaxy._stars.remove(s);
   delete s;
@@ -530,6 +537,24 @@
   return;
 }
 
+void GobGame::add_stars()
+{
+  add(new Stars());
+}
+void GobGame::add_asteroid()
+{
+  add(new GobAsteroid());
+}
+void GobGame::add_system(std::string name, int x, int y)
+{
+  _galaxy.add(new StarSystem(name,Vector2(x,y)));
+  gobgame-&gt;switch_system(name);
+}
+void GobGame::add_player(std::string system, int x, int y)
+{
+  add_gobplayer(system, Vector2(x,y));
+}
+
 void GobEnemy::init(Ship *ship, int kill_starbucks, int kill_buckazoids) 
 {
   STACKTRACE;
@@ -589,7 +614,7 @@
   return;
 }
 
-GobPlayer::pair *GobPlayer::_get_pair(const char *id) 
+pair *GobPlayer::_get_pair(const char *id) 
 {
   STACKTRACE;
   if (!pair_list) 

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/games/ggob.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -29,6 +29,12 @@
 class Upgrade;
 class GobStation;
 
+struct pair 
+{
+  char *id;
+  int value;
+};
+
 /// Player possession (ship, money, upgrades)
 class GobPlayer 
 {
@@ -37,11 +43,6 @@
   ~GobPlayer()
 ;
   Ship *ship;
-  struct pair 
-  {
-    char *id;
-    int value;
-  };
   pair *pair_list;
   int num_pairs;
   void _add_pair(const char *id, int value);
@@ -100,6 +101,7 @@
   void add_gobplayer(const std::string&amp; system, Vector2 pos);
 
   GobGame();
+  static GobGame* get_this() {return gobgame;}
   virtual ~GobGame();
 
   ShipPanel *_player_panel;
@@ -126,8 +128,14 @@
   //	protected:
   virtual void fps ();
   
+
+  // For Python interface
   void add_new_enemy();
-  
+  void add_stars();
+  void add_asteroid();
+  void add_system(std::string name, int x, int y);;
+  void add_player(std::string name, int x, int y);
+ 
   int next_add_new_enemy_time;
   
   SpaceSprite *defenderSprite;

Added: trunk/source/generated/ggob.py
===================================================================
--- trunk/source/generated/ggob.py	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/generated/ggob.py	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,380 @@
+# This file was created automatically by SWIG.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _ggob
+
+def _swig_setattr(self,class_type,name,value):
+    if (name == &quot;this&quot;):
+        if isinstance(value, class_type):
+            self.__dict__[name] = value.this
+            if hasattr(value,&quot;thisown&quot;): self.__dict__[&quot;thisown&quot;] = value.thisown
+            del value.thisown
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    self.__dict__[name] = value
+
+def _swig_getattr(self,class_type,name):
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class pair(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, pair, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, pair, name)
+    def __repr__(self):
+        return &quot;&lt;C pair instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;id&quot;] = _ggob.pair_id_set
+    __swig_getmethods__[&quot;id&quot;] = _ggob.pair_id_get
+    if _newclass:id = property(_ggob.pair_id_get, _ggob.pair_id_set)
+    __swig_setmethods__[&quot;value&quot;] = _ggob.pair_value_set
+    __swig_getmethods__[&quot;value&quot;] = _ggob.pair_value_get
+    if _newclass:value = property(_ggob.pair_value_get, _ggob.pair_value_set)
+    def __init__(self, *args):
+        _swig_setattr(self, pair, 'this', _ggob.new_pair(*args))
+        _swig_setattr(self, pair, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_pair):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class pairPtr(pair):
+    def __init__(self, this):
+        _swig_setattr(self, pair, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, pair, 'thisown', 0)
+        _swig_setattr(self, pair,self.__class__,pair)
+_ggob.pair_swigregister(pairPtr)
+
+class GobPlayer(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobPlayer, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobPlayer, name)
+    def __repr__(self):
+        return &quot;&lt;C GobPlayer instance at %s&gt;&quot; % (self.this,)
+    def __init__(self, *args):
+        _swig_setattr(self, GobPlayer, 'this', _ggob.new_GobPlayer(*args))
+        _swig_setattr(self, GobPlayer, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobPlayer):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__[&quot;ship&quot;] = _ggob.GobPlayer_ship_set
+    __swig_getmethods__[&quot;ship&quot;] = _ggob.GobPlayer_ship_get
+    if _newclass:ship = property(_ggob.GobPlayer_ship_get, _ggob.GobPlayer_ship_set)
+    __swig_setmethods__[&quot;pair_list&quot;] = _ggob.GobPlayer_pair_list_set
+    __swig_getmethods__[&quot;pair_list&quot;] = _ggob.GobPlayer_pair_list_get
+    if _newclass:pair_list = property(_ggob.GobPlayer_pair_list_get, _ggob.GobPlayer_pair_list_set)
+    __swig_setmethods__[&quot;num_pairs&quot;] = _ggob.GobPlayer_num_pairs_set
+    __swig_getmethods__[&quot;num_pairs&quot;] = _ggob.GobPlayer_num_pairs_get
+    if _newclass:num_pairs = property(_ggob.GobPlayer_num_pairs_get, _ggob.GobPlayer_num_pairs_set)
+    def _add_pair(*args): return _ggob.GobPlayer__add_pair(*args)
+    def _get_pair(*args): return _ggob.GobPlayer__get_pair(*args)
+    def write_pair(*args): return _ggob.GobPlayer_write_pair(*args)
+    def read_pair(*args): return _ggob.GobPlayer_read_pair(*args)
+    __swig_setmethods__[&quot;total&quot;] = _ggob.GobPlayer_total_set
+    __swig_getmethods__[&quot;total&quot;] = _ggob.GobPlayer_total_get
+    if _newclass:total = property(_ggob.GobPlayer_total_get, _ggob.GobPlayer_total_set)
+    __swig_setmethods__[&quot;starbucks&quot;] = _ggob.GobPlayer_starbucks_set
+    __swig_getmethods__[&quot;starbucks&quot;] = _ggob.GobPlayer_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobPlayer_starbucks_get, _ggob.GobPlayer_starbucks_set)
+    __swig_setmethods__[&quot;buckazoids&quot;] = _ggob.GobPlayer_buckazoids_set
+    __swig_getmethods__[&quot;buckazoids&quot;] = _ggob.GobPlayer_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobPlayer_buckazoids_get, _ggob.GobPlayer_buckazoids_set)
+    __swig_setmethods__[&quot;kills&quot;] = _ggob.GobPlayer_kills_set
+    __swig_getmethods__[&quot;kills&quot;] = _ggob.GobPlayer_kills_get
+    if _newclass:kills = property(_ggob.GobPlayer_kills_get, _ggob.GobPlayer_kills_set)
+    __swig_setmethods__[&quot;value_starbucks&quot;] = _ggob.GobPlayer_value_starbucks_set
+    __swig_getmethods__[&quot;value_starbucks&quot;] = _ggob.GobPlayer_value_starbucks_get
+    if _newclass:value_starbucks = property(_ggob.GobPlayer_value_starbucks_get, _ggob.GobPlayer_value_starbucks_set)
+    __swig_setmethods__[&quot;value_buckazoids&quot;] = _ggob.GobPlayer_value_buckazoids_set
+    __swig_getmethods__[&quot;value_buckazoids&quot;] = _ggob.GobPlayer_value_buckazoids_get
+    if _newclass:value_buckazoids = property(_ggob.GobPlayer_value_buckazoids_get, _ggob.GobPlayer_value_buckazoids_set)
+    __swig_setmethods__[&quot;team&quot;] = _ggob.GobPlayer_team_set
+    __swig_getmethods__[&quot;team&quot;] = _ggob.GobPlayer_team_get
+    if _newclass:team = property(_ggob.GobPlayer_team_get, _ggob.GobPlayer_team_set)
+    def init(*args): return _ggob.GobPlayer_init(*args)
+    def died(*args): return _ggob.GobPlayer_died(*args)
+    def new_ship(*args): return _ggob.GobPlayer_new_ship(*args)
+    def charge(*args): return _ggob.GobPlayer_charge(*args)
+    __swig_setmethods__[&quot;upgrade_list&quot;] = _ggob.GobPlayer_upgrade_list_set
+    __swig_getmethods__[&quot;upgrade_list&quot;] = _ggob.GobPlayer_upgrade_list_get
+    if _newclass:upgrade_list = property(_ggob.GobPlayer_upgrade_list_get, _ggob.GobPlayer_upgrade_list_set)
+
+class GobPlayerPtr(GobPlayer):
+    def __init__(self, this):
+        _swig_setattr(self, GobPlayer, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobPlayer, 'thisown', 0)
+        _swig_setattr(self, GobPlayer,self.__class__,GobPlayer)
+_ggob.GobPlayer_swigregister(GobPlayerPtr)
+
+class GobEnemy(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobEnemy, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobEnemy, name)
+    def __repr__(self):
+        return &quot;&lt;C GobEnemy instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;ship&quot;] = _ggob.GobEnemy_ship_set
+    __swig_getmethods__[&quot;ship&quot;] = _ggob.GobEnemy_ship_get
+    if _newclass:ship = property(_ggob.GobEnemy_ship_get, _ggob.GobEnemy_ship_set)
+    __swig_setmethods__[&quot;starbucks&quot;] = _ggob.GobEnemy_starbucks_set
+    __swig_getmethods__[&quot;starbucks&quot;] = _ggob.GobEnemy_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobEnemy_starbucks_get, _ggob.GobEnemy_starbucks_set)
+    __swig_setmethods__[&quot;buckazoids&quot;] = _ggob.GobEnemy_buckazoids_set
+    __swig_getmethods__[&quot;buckazoids&quot;] = _ggob.GobEnemy_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobEnemy_buckazoids_get, _ggob.GobEnemy_buckazoids_set)
+    def init(*args): return _ggob.GobEnemy_init(*args)
+    def died(*args): return _ggob.GobEnemy_died(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobEnemy, 'this', _ggob.new_GobEnemy(*args))
+        _swig_setattr(self, GobEnemy, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobEnemy):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobEnemyPtr(GobEnemy):
+    def __init__(self, this):
+        _swig_setattr(self, GobEnemy, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobEnemy, 'thisown', 0)
+        _swig_setattr(self, GobEnemy,self.__class__,GobEnemy)
+_ggob.GobEnemy_swigregister(GobEnemyPtr)
+
+class GobAsteroid(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobAsteroid, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobAsteroid, name)
+    def __repr__(self):
+        return &quot;&lt;C GobAsteroid instance at %s&gt;&quot; % (self.this,)
+    def handle_damage(*args): return _ggob.GobAsteroid_handle_damage(*args)
+    def death(*args): return _ggob.GobAsteroid_death(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobAsteroid, 'this', _ggob.new_GobAsteroid(*args))
+        _swig_setattr(self, GobAsteroid, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobAsteroid):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobAsteroidPtr(GobAsteroid):
+    def __init__(self, this):
+        _swig_setattr(self, GobAsteroid, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobAsteroid, 'thisown', 0)
+        _swig_setattr(self, GobAsteroid,self.__class__,GobAsteroid)
+_ggob.GobAsteroid_swigregister(GobAsteroidPtr)
+
+class GobGame(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobGame, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobGame, name)
+    def __repr__(self):
+        return &quot;&lt;C GobGame instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;_galaxy&quot;] = _ggob.GobGame__galaxy_set
+    __swig_getmethods__[&quot;_galaxy&quot;] = _ggob.GobGame__galaxy_get
+    if _newclass:_galaxy = property(_ggob.GobGame__galaxy_get, _ggob.GobGame__galaxy_set)
+    __swig_setmethods__[&quot;gobplayer&quot;] = _ggob.GobGame_gobplayer_set
+    __swig_getmethods__[&quot;gobplayer&quot;] = _ggob.GobGame_gobplayer_get
+    if _newclass:gobplayer = property(_ggob.GobGame_gobplayer_get, _ggob.GobGame_gobplayer_set)
+    def switch_system(*args): return _ggob.GobGame_switch_system(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobGame, 'this', _ggob.new_GobGame(*args))
+        _swig_setattr(self, GobGame, 'thisown', 1)
+    __swig_getmethods__[&quot;get_this&quot;] = lambda x: _ggob.GobGame_get_this
+    if _newclass:get_this = staticmethod(_ggob.GobGame_get_this)
+    def __del__(self, destroy=_ggob.delete_GobGame):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__[&quot;_player_panel&quot;] = _ggob.GobGame__player_panel_set
+    __swig_getmethods__[&quot;_player_panel&quot;] = _ggob.GobGame__player_panel_get
+    if _newclass:_player_panel = property(_ggob.GobGame__player_panel_get, _ggob.GobGame__player_panel_set)
+    __swig_setmethods__[&quot;_player_control&quot;] = _ggob.GobGame__player_control_set
+    __swig_getmethods__[&quot;_player_control&quot;] = _ggob.GobGame__player_control_get
+    if _newclass:_player_control = property(_ggob.GobGame__player_control_get, _ggob.GobGame__player_control_set)
+    __swig_setmethods__[&quot;enemy_team&quot;] = _ggob.GobGame_enemy_team_set
+    __swig_getmethods__[&quot;enemy_team&quot;] = _ggob.GobGame_enemy_team_get
+    if _newclass:enemy_team = property(_ggob.GobGame_enemy_team_get, _ggob.GobGame_enemy_team_set)
+    def AddPanel(*args): return _ggob.GobGame_AddPanel(*args)
+    def calculate(*args): return _ggob.GobGame_calculate(*args)
+    def setGameDone(*args): return _ggob.GobGame_setGameDone(*args)
+    def ship_died(*args): return _ggob.GobGame_ship_died(*args)
+    def preinit(*args): return _ggob.GobGame_preinit(*args)
+    def init(*args): return _ggob.GobGame_init(*args)
+    def play_sound(*args): return _ggob.GobGame_play_sound(*args)
+    def add_gobplayer(*args): return _ggob.GobGame_add_gobplayer(*args)
+    def get_player(*args): return _ggob.GobGame_get_player(*args)
+    __swig_setmethods__[&quot;gobenemies&quot;] = _ggob.GobGame_gobenemies_set
+    __swig_getmethods__[&quot;gobenemies&quot;] = _ggob.GobGame_gobenemies_get
+    if _newclass:gobenemies = property(_ggob.GobGame_gobenemies_get, _ggob.GobGame_gobenemies_set)
+    __swig_setmethods__[&quot;max_enemies&quot;] = _ggob.GobGame_max_enemies_set
+    __swig_getmethods__[&quot;max_enemies&quot;] = _ggob.GobGame_max_enemies_get
+    if _newclass:max_enemies = property(_ggob.GobGame_max_enemies_get, _ggob.GobGame_max_enemies_set)
+    __swig_setmethods__[&quot;gobenemy&quot;] = _ggob.GobGame_gobenemy_set
+    __swig_getmethods__[&quot;gobenemy&quot;] = _ggob.GobGame_gobenemy_get
+    if _newclass:gobenemy = property(_ggob.GobGame_gobenemy_get, _ggob.GobGame_gobenemy_set)
+    def get_enemy_index(*args): return _ggob.GobGame_get_enemy_index(*args)
+    def prepare(*args): return _ggob.GobGame_prepare(*args)
+    def fps(*args): return _ggob.GobGame_fps(*args)
+    def add_new_enemy(*args): return _ggob.GobGame_add_new_enemy(*args)
+    def add_stars(*args): return _ggob.GobGame_add_stars(*args)
+    def add_asteroid(*args): return _ggob.GobGame_add_asteroid(*args)
+    def add_system(*args): return _ggob.GobGame_add_system(*args)
+    def add_player(*args): return _ggob.GobGame_add_player(*args)
+    __swig_setmethods__[&quot;next_add_new_enemy_time&quot;] = _ggob.GobGame_next_add_new_enemy_time_set
+    __swig_getmethods__[&quot;next_add_new_enemy_time&quot;] = _ggob.GobGame_next_add_new_enemy_time_get
+    if _newclass:next_add_new_enemy_time = property(_ggob.GobGame_next_add_new_enemy_time_get, _ggob.GobGame_next_add_new_enemy_time_set)
+    __swig_setmethods__[&quot;defenderSprite&quot;] = _ggob.GobGame_defenderSprite_set
+    __swig_getmethods__[&quot;defenderSprite&quot;] = _ggob.GobGame_defenderSprite_get
+    if _newclass:defenderSprite = property(_ggob.GobGame_defenderSprite_get, _ggob.GobGame_defenderSprite_set)
+    __swig_setmethods__[&quot;num_planets&quot;] = _ggob.GobGame_num_planets_set
+    __swig_getmethods__[&quot;num_planets&quot;] = _ggob.GobGame_num_planets_get
+    if _newclass:num_planets = property(_ggob.GobGame_num_planets_get, _ggob.GobGame_num_planets_set)
+    __swig_setmethods__[&quot;planet&quot;] = _ggob.GobGame_planet_set
+    __swig_getmethods__[&quot;planet&quot;] = _ggob.GobGame_planet_get
+    if _newclass:planet = property(_ggob.GobGame_planet_get, _ggob.GobGame_planet_set)
+    __swig_setmethods__[&quot;station&quot;] = _ggob.GobGame_station_set
+    __swig_getmethods__[&quot;station&quot;] = _ggob.GobGame_station_get
+    if _newclass:station = property(_ggob.GobGame_station_get, _ggob.GobGame_station_set)
+    def add_planet_and_station(*args): return _ggob.GobGame_add_planet_and_station(*args)
+
+class GobGamePtr(GobGame):
+    def __init__(self, this):
+        _swig_setattr(self, GobGame, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobGame, 'thisown', 0)
+        _swig_setattr(self, GobGame,self.__class__,GobGame)
+_ggob.GobGame_swigregister(GobGamePtr)
+
+GobGame_get_this = _ggob.GobGame_get_this
+
+class GobStation(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobStation, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobStation, name)
+    def __repr__(self):
+        return &quot;&lt;C GobStation instance at %s&gt;&quot; % (self.this,)
+    __swig_setmethods__[&quot;_build_type&quot;] = _ggob.GobStation__build_type_set
+    __swig_getmethods__[&quot;_build_type&quot;] = _ggob.GobStation__build_type_get
+    if _newclass:_build_type = property(_ggob.GobStation__build_type_get, _ggob.GobStation__build_type_set)
+    __swig_setmethods__[&quot;_background_pic&quot;] = _ggob.GobStation__background_pic_set
+    __swig_getmethods__[&quot;_background_pic&quot;] = _ggob.GobStation__background_pic_get
+    if _newclass:_background_pic = property(_ggob.GobStation__background_pic_get, _ggob.GobStation__background_pic_set)
+    def __init__(self, *args):
+        _swig_setattr(self, GobStation, 'this', _ggob.new_GobStation(*args))
+        _swig_setattr(self, GobStation, 'thisown', 1)
+    def buy_new_ship_menu(*args): return _ggob.GobStation_buy_new_ship_menu(*args)
+    def inflict_damage(*args): return _ggob.GobStation_inflict_damage(*args)
+    def station_screen(*args): return _ggob.GobStation_station_screen(*args)
+    def upgrade_menu(*args): return _ggob.GobStation_upgrade_menu(*args)
+    def __del__(self, destroy=_ggob.delete_GobStation):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobStationPtr(GobStation):
+    def __init__(self, this):
+        _swig_setattr(self, GobStation, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GobStation, 'thisown', 0)
+        _swig_setattr(self, GobStation,self.__class__,GobStation)
+_ggob.GobStation_swigregister(GobStationPtr)
+
+class Upgrade(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, Upgrade, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, Upgrade, name)
+    def __init__(self): raise RuntimeError, &quot;No constructor defined&quot;
+    def __repr__(self):
+        return &quot;&lt;C Upgrade instance at %s&gt;&quot; % (self.this,)
+    active = _ggob.Upgrade_active
+    inactive = _ggob.Upgrade_inactive
+    __swig_setmethods__[&quot;name&quot;] = _ggob.Upgrade_name_set
+    __swig_getmethods__[&quot;name&quot;] = _ggob.Upgrade_name_get
+    if _newclass:name = property(_ggob.Upgrade_name_get, _ggob.Upgrade_name_set)
+    __swig_setmethods__[&quot;starbucks&quot;] = _ggob.Upgrade_starbucks_set
+    __swig_getmethods__[&quot;starbucks&quot;] = _ggob.Upgrade_starbucks_get
+    if _newclass:starbucks = property(_ggob.Upgrade_starbucks_get, _ggob.Upgrade_starbucks_set)
+    __swig_setmethods__[&quot;buckazoids&quot;] = _ggob.Upgrade_buckazoids_set
+    __swig_getmethods__[&quot;buckazoids&quot;] = _ggob.Upgrade_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.Upgrade_buckazoids_get, _ggob.Upgrade_buckazoids_set)
+    __swig_setmethods__[&quot;status&quot;] = _ggob.Upgrade_status_set
+    __swig_getmethods__[&quot;status&quot;] = _ggob.Upgrade_status_get
+    if _newclass:status = property(_ggob.Upgrade_status_get, _ggob.Upgrade_status_set)
+    __swig_setmethods__[&quot;num&quot;] = _ggob.Upgrade_num_set
+    __swig_getmethods__[&quot;num&quot;] = _ggob.Upgrade_num_get
+    if _newclass:num = property(_ggob.Upgrade_num_get, _ggob.Upgrade_num_set)
+    __swig_setmethods__[&quot;index&quot;] = _ggob.Upgrade_index_set
+    __swig_getmethods__[&quot;index&quot;] = _ggob.Upgrade_index_get
+    if _newclass:index = property(_ggob.Upgrade_index_get, _ggob.Upgrade_index_set)
+    def update(*args): return _ggob.Upgrade_update(*args)
+    def execute(*args): return _ggob.Upgrade_execute(*args)
+    def charge(*args): return _ggob.Upgrade_charge(*args)
+    def clear(*args): return _ggob.Upgrade_clear(*args)
+    def duplicate(*args): return _ggob.Upgrade_duplicate(*args)
+    def __del__(self, destroy=_ggob.delete_Upgrade):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class UpgradePtr(Upgrade):
+    def __init__(self, this):
+        _swig_setattr(self, Upgrade, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, Upgrade, 'thisown', 0)
+        _swig_setattr(self, Upgrade,self.__class__,Upgrade)
+_ggob.Upgrade_swigregister(UpgradePtr)
+
+class RainbowRift(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, RainbowRift, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, RainbowRift, name)
+    def __repr__(self):
+        return &quot;&lt;C RainbowRift instance at %s&gt;&quot; % (self.this,)
+    n = _ggob.RainbowRift_n
+    __swig_setmethods__[&quot;p&quot;] = _ggob.RainbowRift_p_set
+    __swig_getmethods__[&quot;p&quot;] = _ggob.RainbowRift_p_get
+    if _newclass:p = property(_ggob.RainbowRift_p_get, _ggob.RainbowRift_p_set)
+    __swig_setmethods__[&quot;c&quot;] = _ggob.RainbowRift_c_set
+    __swig_getmethods__[&quot;c&quot;] = _ggob.RainbowRift_c_get
+    if _newclass:c = property(_ggob.RainbowRift_c_get, _ggob.RainbowRift_c_set)
+    __swig_setmethods__[&quot;next_time&quot;] = _ggob.RainbowRift_next_time_set
+    __swig_getmethods__[&quot;next_time&quot;] = _ggob.RainbowRift_next_time_get
+    if _newclass:next_time = property(_ggob.RainbowRift_next_time_get, _ggob.RainbowRift_next_time_set)
+    __swig_setmethods__[&quot;next_time2&quot;] = _ggob.RainbowRift_next_time2_set
+    __swig_getmethods__[&quot;next_time2&quot;] = _ggob.RainbowRift_next_time2_get
+    if _newclass:next_time2 = property(_ggob.RainbowRift_next_time2_get, _ggob.RainbowRift_next_time2_set)
+    def __init__(self, *args):
+        _swig_setattr(self, RainbowRift, 'this', _ggob.new_RainbowRift(*args))
+        _swig_setattr(self, RainbowRift, 'thisown', 1)
+    def animate(*args): return _ggob.RainbowRift_animate(*args)
+    def calculate(*args): return _ggob.RainbowRift_calculate(*args)
+    def squiggle(*args): return _ggob.RainbowRift_squiggle(*args)
+    def __del__(self, destroy=_ggob.delete_RainbowRift):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class RainbowRiftPtr(RainbowRift):
+    def __init__(self, this):
+        _swig_setattr(self, RainbowRift, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, RainbowRift, 'thisown', 0)
+        _swig_setattr(self, RainbowRift,self.__class__,RainbowRift)
+_ggob.RainbowRift_swigregister(RainbowRiftPtr)
+
+

Added: trunk/source/generated/ggob_wrap.cpp
===================================================================
--- trunk/source/generated/ggob_wrap.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/generated/ggob_wrap.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,3875 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
+ * Version 1.3.21
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGPYTHON
+
+#ifdef __cplusplus
+template&lt;class T&gt; class SwigValueWrapper {
+    T *tt;
+public:
+    SwigValueWrapper() : tt(0) { }
+    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
+    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
+    ~SwigValueWrapper() { delete tt; } 
+    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
+    operator T&amp;() const { return *tt; }
+    T *operator&amp;() { return tt; }
+private:
+    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
+};                                                    
+#endif
+
+
+#include &quot;Python.h&quot;
+
+/*************************************************************** -*- c -*-
+ * python/precommon.swg
+ *
+ * Rename all exported symbols from common.swg, to avoid symbol
+ * clashes if multiple interpreters are included
+ *
+ ************************************************************************/
+
+#define SWIG_TypeRegister    SWIG_Python_TypeRegister
+#define SWIG_TypeCheck       SWIG_Python_TypeCheck
+#define SWIG_TypeCast        SWIG_Python_TypeCast
+#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
+#define SWIG_TypeName        SWIG_Python_TypeName
+#define SWIG_TypeQuery       SWIG_Python_TypeQuery
+#define SWIG_TypeClientData  SWIG_Python_TypeClientData
+#define SWIG_PackData        SWIG_Python_PackData 
+#define SWIG_UnpackData      SWIG_Python_UnpackData 
+
+
+/***********************************************************************
+ * common.swg
+ *
+ *     This file contains generic SWIG runtime support for pointer
+ *     type checking as well as a few commonly used macros to control
+ *     external linkage.
+ *
+ * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
+ *
+ * Copyright (c) 1999-2000, The University of Chicago
+ * 
+ * This file may be freely redistributed without license or fee provided
+ * this copyright message remains intact.
+ ************************************************************************/
+
+#include &lt;string.h&gt;
+
+#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#  if defined(_MSC_VER) || defined(__GNUC__)
+#    if defined(STATIC_LINKED)
+#      define SWIGEXPORT(a) a
+#      define SWIGIMPORT(a) extern a
+#    else
+#      define SWIGEXPORT(a) __declspec(dllexport) a
+#      define SWIGIMPORT(a) extern a
+#    endif
+#  else
+#    if defined(__BORLANDC__)
+#      define SWIGEXPORT(a) a _export
+#      define SWIGIMPORT(a) a _export
+#    else
+#      define SWIGEXPORT(a) a
+#      define SWIGIMPORT(a) a
+#    endif
+#  endif
+#else
+#  define SWIGEXPORT(a) a
+#  define SWIGIMPORT(a) a
+#endif
+
+#ifdef SWIG_GLOBAL
+#  define SWIGRUNTIME(a) SWIGEXPORT(a)
+#else
+#  define SWIGRUNTIME(a) static a
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef void *(*swig_converter_func)(void *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+typedef struct swig_type_info {
+  const char             *name;
+  swig_converter_func     converter;
+  const char             *str;
+  void                   *clientdata;
+  swig_dycast_func        dcast;
+  struct swig_type_info  *next;
+  struct swig_type_info  *prev;
+} swig_type_info;
+
+#ifdef SWIG_NOINCLUDE
+
+SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
+SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
+SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
+SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
+SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
+SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);
+
+#else
+
+static swig_type_info *swig_type_list = 0;
+
+/* Register a type mapping with the type-checking */
+SWIGRUNTIME(swig_type_info *)
+SWIG_TypeRegister(swig_type_info *ti) {
+  swig_type_info *tc, *head, *ret, *next;
+  /* Check to see if this type has already been registered */
+  tc = swig_type_list;
+  while (tc) {
+    if (strcmp(tc-&gt;name, ti-&gt;name) == 0) {
+      /* Already exists in the table.  Just add additional types to the list */
+      if (tc-&gt;clientdata) ti-&gt;clientdata = tc-&gt;clientdata;
+      head = tc;
+      next = tc-&gt;next;
+      goto l1;
+    }
+    tc = tc-&gt;prev;
+  }
+  head = ti;
+  next = 0;
+
+  /* Place in list */
+  ti-&gt;prev = swig_type_list;
+  swig_type_list = ti;
+
+  /* Build linked lists */
+  l1:
+  ret = head;
+  tc = ti + 1;
+  /* Patch up the rest of the links */
+  while (tc-&gt;name) {
+    head-&gt;next = tc;
+    tc-&gt;prev = head;
+    head = tc;
+    tc++;
+  }
+  if (next) next-&gt;prev = head;
+  head-&gt;next = next;
+  return ret;
+}
+
+/* Check the typename */
+SWIGRUNTIME(swig_type_info *) 
+SWIG_TypeCheck(char *c, swig_type_info *ty) {
+  swig_type_info *s;
+  if (!ty) return 0;        /* Void pointer */
+  s = ty-&gt;next;             /* First element always just a name */
+  do {
+    if (strcmp(s-&gt;name,c) == 0) {
+      if (s == ty-&gt;next) return s;
+      /* Move s to the top of the linked list */
+      s-&gt;prev-&gt;next = s-&gt;next;
+      if (s-&gt;next) {
+        s-&gt;next-&gt;prev = s-&gt;prev;
+      }
+      /* Insert s as second element in the list */
+      s-&gt;next = ty-&gt;next;
+      if (ty-&gt;next) ty-&gt;next-&gt;prev = s;
+      ty-&gt;next = s;
+      s-&gt;prev = ty;
+      return s;
+    }
+    s = s-&gt;next;
+  } while (s &amp;&amp; (s != ty-&gt;next));
+  return 0;
+}
+
+/* Cast a pointer up an inheritance hierarchy */
+SWIGRUNTIME(void *) 
+SWIG_TypeCast(swig_type_info *ty, void *ptr) {
+  if ((!ty) || (!ty-&gt;converter)) return ptr;
+  return (*ty-&gt;converter)(ptr);
+}
+
+/* Dynamic pointer casting. Down an inheritance hierarchy */
+SWIGRUNTIME(swig_type_info *) 
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty-&gt;dcast) return ty;
+  while (ty &amp;&amp; (ty-&gt;dcast)) {
+    ty = (*ty-&gt;dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/* Return the name associated with this type */
+SWIGRUNTIME(const char *)
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty-&gt;name;
+}
+
+/* Search for a swig_type_info structure */
+SWIGRUNTIME(swig_type_info *)
+SWIG_TypeQuery(const char *name) {
+  swig_type_info *ty = swig_type_list;
+  while (ty) {
+    if (ty-&gt;str &amp;&amp; (strcmp(name,ty-&gt;str) == 0)) return ty;
+    if (ty-&gt;name &amp;&amp; (strcmp(name,ty-&gt;name) == 0)) return ty;
+    ty = ty-&gt;prev;
+  }
+  return 0;
+}
+
+/* Set the clientdata field for a type */
+SWIGRUNTIME(void)
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_type_info *tc, *equiv;
+  if (ti-&gt;clientdata == clientdata) return;
+  ti-&gt;clientdata = clientdata;
+  equiv = ti-&gt;next;
+  while (equiv) {
+    if (!equiv-&gt;converter) {
+      tc = swig_type_list;
+      while (tc) {
+        if ((strcmp(tc-&gt;name, equiv-&gt;name) == 0))
+          SWIG_TypeClientData(tc,clientdata);
+        tc = tc-&gt;prev;
+      }
+    }
+    equiv = equiv-&gt;next;
+  }
+}
+
+/* Pack binary data into a string */
+SWIGRUNTIME(char *)
+SWIG_PackData(char *c, void *ptr, int sz) {
+  static char hex[17] = &quot;0123456789abcdef&quot;;
+  int i;
+  unsigned char *u = (unsigned char *) ptr;
+  register unsigned char uu;
+  for (i = 0; i &lt; sz; i++,u++) {
+    uu = *u;
+    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
+    *(c++) = hex[uu &amp; 0xf];
+  }
+  return c;
+}
+
+/* Unpack binary data from a string */
+SWIGRUNTIME(char *)
+SWIG_UnpackData(char *c, void *ptr, int sz) {
+  register unsigned char uu = 0;
+  register int d;
+  unsigned char *u = (unsigned char *) ptr;
+  int i;
+  for (i = 0; i &lt; sz; i++, u++) {
+    d = *(c++);
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu = ((d - '0') &lt;&lt; 4);
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu = ((d - ('a'-10)) &lt;&lt; 4);
+    d = *(c++);
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu |= (d - '0');
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu |= (d - ('a'-10));
+    *u = uu;
+  }
+  return c;
+}
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/***********************************************************************
+ * python.swg
+ *
+ *     This file contains the runtime support for Python modules
+ *     and includes code for managing global variables and pointer
+ *     type checking.
+ *
+ * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
+ ************************************************************************/
+
+#include &quot;Python.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define SWIG_PY_INT     1
+#define SWIG_PY_FLOAT   2
+#define SWIG_PY_STRING  3
+#define SWIG_PY_POINTER 4
+#define SWIG_PY_BINARY  5
+
+/* Flags for pointer conversion */
+
+#define SWIG_POINTER_EXCEPTION     0x1
+#define SWIG_POINTER_DISOWN        0x2
+
+/* Exception handling in wrappers */
+#define SWIG_fail   goto fail
+
+/* Constant information structure */
+typedef struct swig_const_info {
+    int type;
+    char *name;
+    long lvalue;
+    double dvalue;
+    void   *pvalue;
+    swig_type_info **ptype;
+} swig_const_info;
+
+/* Common SWIG API */
+#define SWIG_ConvertPtr(obj, pp, type, flags) \
+  SWIG_Python_ConvertPtr(obj, pp, type, flags)
+#define SWIG_NewPointerObj(p, type, flags) \
+  SWIG_Python_NewPointerObj(p, type, flags)
+#define SWIG_MustGetPtr(p, type, argnum, flags) \
+  SWIG_Python_MustGetPtr(p, type, argnum, flags)
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink() \
+  SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr) \
+  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
+  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
+#define SWIG_NewPackedObj(ptr, sz, type) \
+  SWIG_Python_NewPackedObj(ptr, sz, type)
+#define SWIG_InstallConstants(d, constants) \
+  SWIG_Python_InstallConstants(d, constants)
+
+#ifdef SWIG_NOINCLUDE
+
+SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
+SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
+SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
+SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
+SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);
+
+#else
+
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+static PyObject *
+swig_varlink_repr(swig_varlinkobject *v) {
+  v = v;
+  return PyString_FromString(&quot;&lt;Global variables&gt;&quot;);
+}
+
+static int
+swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
+  swig_globalvar  *var;
+  flags = flags;
+  fprintf(fp,&quot;Global variables { &quot;);
+  for (var = v-&gt;vars; var; var=var-&gt;next) {
+    fprintf(fp,&quot;%s&quot;, var-&gt;name);
+    if (var-&gt;next) fprintf(fp,&quot;, &quot;);
+  }
+  fprintf(fp,&quot; }\n&quot;);
+  return 0;
+}
+
+static PyObject *
+swig_varlink_getattr(swig_varlinkobject *v, char *n) {
+  swig_globalvar *var = v-&gt;vars;
+  while (var) {
+    if (strcmp(var-&gt;name,n) == 0) {
+      return (*var-&gt;get_attr)();
+    }
+    var = var-&gt;next;
+  }
+  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+  return NULL;
+}
+
+static int
+swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
+  swig_globalvar *var = v-&gt;vars;
+  while (var) {
+    if (strcmp(var-&gt;name,n) == 0) {
+      return (*var-&gt;set_attr)(p);
+    }
+    var = var-&gt;next;
+  }
+  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+  return 1;
+}
+
+statichere PyTypeObject varlinktype = {
+  PyObject_HEAD_INIT(0)              
+  0,
+  (char *)&quot;swigvarlink&quot;,              /* Type name    */
+  sizeof(swig_varlinkobject),         /* Basic size   */
+  0,                                  /* Itemsize     */
+  0,                                  /* Deallocator  */ 
+  (printfunc) swig_varlink_print,     /* Print        */
+  (getattrfunc) swig_varlink_getattr, /* get attr     */
+  (setattrfunc) swig_varlink_setattr, /* Set attr     */
+  0,                                  /* tp_compare   */
+  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
+  0,                                  /* tp_as_number */
+  0,                                  /* tp_as_mapping*/
+  0,                                  /* tp_hash      */
+};
+
+/* Create a variable linking object for use later */
+SWIGRUNTIME(PyObject *)
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = 0;
+  result = PyMem_NEW(swig_varlinkobject,1);
+  varlinktype.ob_type = &amp;PyType_Type;    /* Patch varlinktype into a PyType */
+  result-&gt;ob_type = &varlinktype;
+  result-&gt;vars = 0;
+  result-&gt;ob_refcnt = 0;
+  Py_XINCREF((PyObject *) result);
+  return ((PyObject*) result);
+}
+
+SWIGRUNTIME(void)
+SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v;
+  swig_globalvar *gv;
+  v= (swig_varlinkobject *) p;
+  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  gv-&gt;name = (char *) malloc(strlen(name)+1);
+  strcpy(gv-&gt;name,name);
+  gv-&gt;get_attr = get_attr;
+  gv-&gt;set_attr = set_attr;
+  gv-&gt;next = v-&gt;vars;
+  v-&gt;vars = gv;
+}
+
+/* Convert a pointer value */
+SWIGRUNTIME(int)
+SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  char  *c = 0;
+  static PyObject *SWIG_this = 0;
+  int    newref = 0;
+  PyObject  *pyobj = 0;
+
+  if (!obj) return 0;
+  if (obj == Py_None) {
+    *ptr = 0;
+    return 0;
+  }
+#ifdef SWIG_COBJECT_TYPES
+  if (!(PyCObject_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString(&quot;this&quot;);
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PyCObject_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  }  
+  *ptr = PyCObject_AsVoidPtr(obj);
+  c = (char *) PyCObject_GetDesc(obj);
+  if (newref) Py_DECREF(obj);
+  goto cobject;
+#else
+  if (!(PyString_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString(&quot;this&quot;);
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PyString_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  } 
+  c = PyString_AsString(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') {
+    *ptr = (void *) 0;
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      if (newref) { Py_DECREF(obj); }
+      return 0;
+    } else {
+      if (newref) { Py_DECREF(obj); }
+      goto type_error;
+    }
+  }
+  c++;
+  c = SWIG_UnpackData(c,ptr,sizeof(void *));
+  if (newref) { Py_DECREF(obj); }
+#endif
+
+#ifdef SWIG_COBJECT_TYPES
+cobject:
+#endif
+
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
+  }
+
+  if ((pyobj) &amp;&amp; (flags &amp; SWIG_POINTER_DISOWN)) {
+    PyObject *zero = PyInt_FromLong(0);
+    PyObject_SetAttrString(pyobj,(char*)&quot;thisown&quot;,zero);
+    Py_DECREF(zero);
+  }
+  return 0;
+
+type_error:
+  if (flags &amp; SWIG_POINTER_EXCEPTION) {
+    if (ty &amp;&amp; c) {
+      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
+      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
+      PyErr_SetString(PyExc_TypeError, temp);
+      free((char *) temp);
+    } else {
+      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
+    }
+  }
+  return -1;
+}
+
+/* Convert a pointer value, signal an exception on a type mismatch */
+SWIGRUNTIME(void *)
+SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
+  void *result;
+  SWIG_Python_ConvertPtr(obj, &amp;result, ty, flags | SWIG_POINTER_EXCEPTION);
+  return result;
+}
+
+/* Convert a packed value value */
+SWIGRUNTIME(int)
+SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  char  *c = 0;
+
+  if ((!obj) || (!PyString_Check(obj))) goto type_error;
+  c = PyString_AsString(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') goto type_error;
+  c++;
+  c = SWIG_UnpackData(c,ptr,sz);
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+  }
+  return 0;
+
+type_error:
+
+  if (flags) {
+    if (ty &amp;&amp; c) {
+      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
+      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
+      PyErr_SetString(PyExc_TypeError, temp);
+      free((char *) temp);
+    } else {
+      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
+    }
+  }
+  return -1;
+}
+
+/* Create a new pointer object */
+SWIGRUNTIME(PyObject *)
+SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
+  PyObject *robj;
+  if (!ptr) {
+    Py_INCREF(Py_None);
+    return Py_None;
+  }
+#ifdef SWIG_COBJECT_TYPES
+  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type-&gt;name, NULL);
+#else
+  {
+    char result[1024];
+    char *r = result;
+    *(r++) = '_';
+    r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
+    strcpy(r,type-&gt;name);
+    robj = PyString_FromString(result);
+  }
+#endif
+  if (!robj || (robj == Py_None)) return robj;
+  if (type-&gt;clientdata) {
+    PyObject *inst;
+    PyObject *args = Py_BuildValue((char*)&quot;(O)&quot;, robj);
+    Py_DECREF(robj);
+    inst = PyObject_CallObject((PyObject *) type-&gt;clientdata, args);
+    Py_DECREF(args);
+    if (inst) {
+      if (own) {
+        PyObject *n = PyInt_FromLong(1);
+        PyObject_SetAttrString(inst,(char*)&quot;thisown&quot;,n);
+        Py_DECREF(n);
+      }
+      robj = inst;
+    }
+  }
+  return robj;
+}
+
+SWIGRUNTIME(PyObject *)
+SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+  char result[1024];
+  char *r = result;
+  if ((2*sz + 1 + strlen(type-&gt;name)) &gt; 1000) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  strcpy(r,type-&gt;name);
+  return PyString_FromString(result);
+}
+
+/* Install Constants */
+SWIGRUNTIME(void)
+SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
+  int i;
+  PyObject *obj;
+  for (i = 0; constants[i].type; i++) {
+    switch(constants[i].type) {
+    case SWIG_PY_INT:
+      obj = PyInt_FromLong(constants[i].lvalue);
+      break;
+    case SWIG_PY_FLOAT:
+      obj = PyFloat_FromDouble(constants[i].dvalue);
+      break;
+    case SWIG_PY_STRING:
+      obj = PyString_FromString((char *) constants[i].pvalue);
+      break;
+    case SWIG_PY_POINTER:
+      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+      break;
+    case SWIG_PY_BINARY:
+      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+      break;
+    default:
+      obj = 0;
+      break;
+    }
+    if (obj) {
+      PyDict_SetItemString(d,constants[i].name,obj);
+      Py_DECREF(obj);
+    }
+  }
+}
+
+#endif
+
+/* Contract support */
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define  SWIGTYPE_p_GobPlayer swig_types[0] 
+#define  SWIGTYPE_p_p_Upgrade swig_types[1] 
+#define  SWIGTYPE_p_SpaceLocation swig_types[2] 
+#define  SWIGTYPE_p_p_GobStation swig_types[3] 
+#define  SWIGTYPE_p_GobStation swig_types[4] 
+#define  SWIGTYPE_p_Upgrade swig_types[5] 
+#define  SWIGTYPE_p_RGB swig_types[6] 
+#define  SWIGTYPE_p_Log swig_types[7] 
+#define  SWIGTYPE_p_StarMap swig_types[8] 
+#define  SWIGTYPE_p_float swig_types[9] 
+#define  SWIGTYPE_p_GobAsteroid swig_types[10] 
+#define  SWIGTYPE_p_TeamCode swig_types[11] 
+#define  SWIGTYPE_p_GobEnemy swig_types[12] 
+#define  SWIGTYPE_p_p_GobEnemy swig_types[13] 
+#define  SWIGTYPE_p_p_Planet swig_types[14] 
+#define  SWIGTYPE_p_RainbowRift swig_types[15] 
+#define  SWIGTYPE_p_GobGame swig_types[16] 
+#define  SWIGTYPE_p_Vector2 swig_types[17] 
+#define  SWIGTYPE_p_std__string swig_types[18] 
+#define  SWIGTYPE_p_pair swig_types[19] 
+#define  SWIGTYPE_p_SpaceSprite swig_types[20] 
+#define  SWIGTYPE_p_Control swig_types[21] 
+#define  SWIGTYPE_p_SpaceObject swig_types[22] 
+#define  SWIGTYPE_p_Frame swig_types[23] 
+#define  SWIGTYPE_p_ShipPanel swig_types[24] 
+#define  SWIGTYPE_p_SAMPLE swig_types[25] 
+#define  SWIGTYPE_p_ShipType swig_types[26] 
+#define  SWIGTYPE_p_Ship swig_types[27] 
+static swig_type_info *swig_types[29];
+
+/* -------- TYPES TABLE (END) -------- */
+
+
+/*-----------------------------------------------
+              @(target):= _ggob.so
+  ------------------------------------------------*/
+#define SWIG_init    init_ggob
+
+#define SWIG_name    &quot;_ggob&quot;
+
+#include &quot;games/ggob.h&quot;
+
+
+#define  SWIG_MemoryError    1
+#define  SWIG_IOError        2
+#define  SWIG_RuntimeError   3
+#define  SWIG_IndexError     4
+#define  SWIG_TypeError      5
+#define  SWIG_DivisionByZero 6
+#define  SWIG_OverflowError  7
+#define  SWIG_SyntaxError    8
+#define  SWIG_ValueError     9
+#define  SWIG_SystemError   10
+#define  SWIG_UnknownError  99
+
+
+static void SWIG_exception_(int code, const char *msg) {
+  switch(code) {
+  case SWIG_MemoryError:
+    PyErr_SetString(PyExc_MemoryError,msg);
+    break;
+  case SWIG_IOError:
+    PyErr_SetString(PyExc_IOError,msg);
+    break;
+  case SWIG_RuntimeError:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  case SWIG_IndexError:
+    PyErr_SetString(PyExc_IndexError,msg);
+    break;
+  case SWIG_TypeError:
+    PyErr_SetString(PyExc_TypeError,msg);
+    break;
+  case SWIG_DivisionByZero:
+    PyErr_SetString(PyExc_ZeroDivisionError,msg);
+    break;
+  case SWIG_OverflowError:
+    PyErr_SetString(PyExc_OverflowError,msg);
+    break;
+  case SWIG_SyntaxError:
+    PyErr_SetString(PyExc_SyntaxError,msg);
+    break;
+  case SWIG_ValueError:
+    PyErr_SetString(PyExc_ValueError,msg);
+    break;
+  case SWIG_SystemError:
+    PyErr_SetString(PyExc_SystemError,msg);
+    break;
+  default:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  }
+}
+
+#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
+
+
+#include &lt;string&gt;
+
+
+#include &lt;string&gt;
+
+PyObject* SwigInt_FromBool(bool b) {
+    return PyInt_FromLong(b ? 1L : 0L);
+}
+double SwigNumber_Check(PyObject* o) {
+    return PyFloat_Check(o) || PyInt_Check(o) || PyLong_Check(o);
+}
+double SwigNumber_AsDouble(PyObject* o) {
+    return PyFloat_Check(o) ? PyFloat_AsDouble(o) 
+        : (PyInt_Check(o) ?   double(PyInt_AsLong(o))
+                            : double(PyLong_AsLong(o)));
+}
+PyObject* SwigString_FromString(const std::string&amp; s) {
+    return PyString_FromStringAndSize(s.data(),s.size());
+}
+std::string SwigString_AsString(PyObject* o) {
+    return std::string(PyString_AsString(o));
+}
+
+
+#include &lt;utility&gt;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+static PyObject *_wrap_pair_id_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    char *arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:pair_id_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (arg1-&gt;id) delete [] arg1-&gt;id;
+        if (arg2) {
+            arg1-&gt;id = (char *) (new char[strlen(arg2)+1]);
+            strcpy((char *) arg1-&gt;id,arg2);
+        } else {
+            arg1-&gt;id = 0;
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_id_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    char *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:pair_id_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (char *) ((arg1)-&gt;id);
+    
+    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)&quot;&quot;);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_value_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:pair_value_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;value = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_value_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:pair_value_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;value);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_pair&quot;)) goto fail;
+    result = (pair *)new pair();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_pair&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * pair_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_pair, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_new_GobPlayer(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobPlayer&quot;)) goto fail;
+    result = (GobPlayer *)new GobPlayer();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobPlayer(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobPlayer&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_ship_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_ship_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;ship = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_ship_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Ship *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_ship_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Ship *) ((arg1)-&gt;ship);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_pair_list_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    pair *arg2 = (pair *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_pair_list_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;pair_list = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_pair_list_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    pair *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_pair_list_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (pair *) ((arg1)-&gt;pair_list);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_num_pairs_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_num_pairs_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;num_pairs = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_num_pairs_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_num_pairs_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;num_pairs);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer__add_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Osi:GobPlayer__add_pair&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;_add_pair((char const *)arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer__get_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    pair *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:GobPlayer__get_pair&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (pair *)(arg1)-&gt;_get_pair((char const *)arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_write_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Osi:GobPlayer_write_pair&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;write_pair((char const *)arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_read_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:GobPlayer_read_pair&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;read_pair((char const *)arg2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_total_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_total_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;total = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_total_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_total_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;total);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_kills_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_kills_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;kills = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_kills_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_kills_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;kills);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_value_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;value_starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_value_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;value_starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_value_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;value_buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_value_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;value_buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_team_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_team_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)-&gt;team = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_team_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_team_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)-&gt;team);
+    
+    {
+        TeamCode * resultptr;
+        resultptr = new TeamCode((TeamCode &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_init&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    (arg1)-&gt;init(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_died&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;died(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_new_ship(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    ShipType *arg2 = (ShipType *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_new_ship&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_ShipType,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;new_ship(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_charge(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    int arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Osii:GobPlayer_charge&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;charge(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_upgrade_list_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Upgrade **arg2 = (Upgrade **) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_upgrade_list_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;upgrade_list = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_upgrade_list_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Upgrade **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_upgrade_list_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Upgrade **) ((arg1)-&gt;upgrade_list);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Upgrade, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobPlayer_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobPlayer, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobEnemy_ship_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobEnemy_ship_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;ship = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_ship_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_ship_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Ship *) ((arg1)-&gt;ship);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobEnemy_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobEnemy_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobEnemy_init&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;init(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobEnemy_died&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;died(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobEnemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobEnemy&quot;)) goto fail;
+    result = (GobEnemy *)new GobEnemy();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobEnemy, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobEnemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobEnemy&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobEnemy_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobEnemy, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobAsteroid_handle_damage(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOdd:GobAsteroid_handle_damage&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;handle_damage(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobAsteroid_death(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobAsteroid_death&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;death();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobAsteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobAsteroid&quot;)) goto fail;
+    result = (GobAsteroid *)new GobAsteroid();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobAsteroid, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobAsteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobAsteroid&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobAsteroid_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobAsteroid, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobGame__galaxy_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    StarMap arg2 ;
+    StarMap *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__galaxy_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_StarMap,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)-&gt;_galaxy = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__galaxy_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    StarMap result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__galaxy_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)-&gt;_galaxy);
+    
+    {
+        StarMap * resultptr;
+        resultptr = new StarMap((StarMap &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_StarMap, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobplayer_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_gobplayer_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;gobplayer = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobplayer_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobPlayer *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobplayer_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobPlayer *)&amp; ((arg1)-&gt;gobplayer);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_switch_system(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string *arg2 = 0 ;
+    std::string temp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_switch_system&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &amp;temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    (arg1)-&gt;switch_system((std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer__SWIG_0(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string *arg2 = 0 ;
+    Vector2 arg3 ;
+    std::string temp2 ;
+    Vector2 *argp3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_add_gobplayer&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &amp;temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;argp3, SWIGTYPE_p_Vector2,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg3 = *argp3; 
+    (arg1)-&gt;add_gobplayer((std::string const &amp;)*arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobGame(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobGame&quot;)) goto fail;
+    result = (GobGame *)new GobGame();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_this(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GobGame_get_this&quot;)) goto fail;
+    result = (GobGame *)GobGame::get_this();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobGame(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobGame&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_panel_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    ShipPanel *arg2 = (ShipPanel *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__player_panel_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_ShipPanel,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_player_panel = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_panel_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    ShipPanel *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__player_panel_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (ShipPanel *) ((arg1)-&gt;_player_panel);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ShipPanel, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_control_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *arg2 = (Control *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__player_control_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_player_control = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_control_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__player_control_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Control *) ((arg1)-&gt;_player_control);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Control, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_enemy_team_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_enemy_team_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)-&gt;enemy_team = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_enemy_team_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    TeamCode result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_enemy_team_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)-&gt;enemy_team);
+    
+    {
+        TeamCode * resultptr;
+        resultptr = new TeamCode((TeamCode &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_AddPanel(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_AddPanel&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;AddPanel();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_calculate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_calculate&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;calculate();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_setGameDone(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_setGameDone&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;setGameDone(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_ship_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_ship_died&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;ship_died(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_preinit(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_preinit&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;preinit();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Log *arg2 = (Log *) 0 ;
+    std::string *arg3 = 0 ;
+    std::string temp3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_init&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Log,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2)) {
+            temp3 = std::string(PyString_AsString(obj2),
+            PyString_Size(obj2));
+            arg3 = &amp;temp3;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    (arg1)-&gt;init(arg2,(std::string const &amp;)*arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_play_sound(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SAMPLE *arg2 = (SAMPLE *) 0 ;
+    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
+    int arg4 = (int) 256 ;
+    int arg5 = (int) 1000 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO|ii:GobGame_play_sound&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;arg4,&amp;arg5)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SAMPLE,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;play_sound(arg2,arg3,arg4,arg5);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer__SWIG_1(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *arg2 = (Control *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_add_gobplayer&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_gobplayer(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[4];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], (void **) &amp;ptr, SWIGTYPE_p_GobGame, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            {
+                void *ptr;
+                if (SWIG_ConvertPtr(argv[1], (void **) &amp;ptr, SWIGTYPE_p_Control, 0) == -1) {
+                    _v = 0;
+                    PyErr_Clear();
+                } else {
+                    _v = 1;
+                }
+            }
+            if (_v) {
+                return _wrap_GobGame_add_gobplayer__SWIG_1(self,args);
+            }
+        }
+    }
+    if (argc == 3) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], (void **) &amp;ptr, SWIGTYPE_p_GobGame, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            {
+                _v = PyString_Check(argv[1]) ? 1 : 0;
+            }
+            if (_v) {
+                {
+                    void *ptr;
+                    if (SWIG_ConvertPtr(argv[2], (void **) &amp;ptr, SWIGTYPE_p_Vector2, 0) == -1) {
+                        _v = 0;
+                        PyErr_Clear();
+                    } else {
+                        _v = 1;
+                    }
+                }
+                if (_v) {
+                    return _wrap_GobGame_add_gobplayer__SWIG_0(self,args);
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'GobGame_add_gobplayer'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_player(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    GobPlayer *result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_get_player&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobPlayer *)(arg1)-&gt;get_player(arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemies_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_gobenemies_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;gobenemies = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemies_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobenemies_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;gobenemies);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_max_enemies_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_max_enemies_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;max_enemies = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_max_enemies_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_max_enemies_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;max_enemies);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemy_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobEnemy **arg2 = (GobEnemy **) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_gobenemy_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;gobenemy = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemy_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobEnemy **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobenemy_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobEnemy **) ((arg1)-&gt;gobenemy);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobEnemy, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_enemy_index(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_get_enemy_index&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;get_enemy_index(arg2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_prepare(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_prepare&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;prepare();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_fps(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_fps&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;fps();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_new_enemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_new_enemy&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_new_enemy();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_stars(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_stars&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_stars();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_asteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_asteroid&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_asteroid();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_system(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string arg2 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobGame_add_system&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1))
+        arg2 = std::string(PyString_AsString(obj1),
+        PyString_Size(obj1));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    (arg1)-&gt;add_system(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_player(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string arg2 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobGame_add_player&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1))
+        arg2 = std::string(PyString_AsString(obj1),
+        PyString_Size(obj1));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    (arg1)-&gt;add_player(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_next_add_new_enemy_time_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_next_add_new_enemy_time_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;next_add_new_enemy_time = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_next_add_new_enemy_time_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_next_add_new_enemy_time_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;next_add_new_enemy_time);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_defenderSprite_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceSprite *arg2 = (SpaceSprite *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_defenderSprite_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;defenderSprite = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_defenderSprite_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceSprite *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_defenderSprite_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (SpaceSprite *) ((arg1)-&gt;defenderSprite);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SpaceSprite, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_num_planets_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_num_planets_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;num_planets = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_num_planets_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_num_planets_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;num_planets);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_planet_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Planet **arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_planet_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_Planet,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        Planet * *b = (Planet * *) arg1-&gt;planet;
+        for (ii = 0; ii &lt; 16; ii++) b[ii] = *((Planet * *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_planet_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Planet **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_planet_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Planet **)(Planet **) ((arg1)-&gt;planet);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Planet, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_station_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobStation **arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_station_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        GobStation * *b = (GobStation * *) arg1-&gt;station;
+        for (ii = 0; ii &lt; 16; ii++) b[ii] = *((GobStation * *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_station_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobStation **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_station_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobStation **)(GobStation **) ((arg1)-&gt;station);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobStation, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_planet_and_station(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    std::string arg3 ;
+    std::string arg4 ;
+    std::string arg5 ;
+    std::string arg6 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    PyObject * obj5 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OiOOOO:GobGame_add_planet_and_station&quot;,&amp;obj0,&amp;arg2,&amp;obj2,&amp;obj3,&amp;obj4,&amp;obj5)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2))
+        arg3 = std::string(PyString_AsString(obj2),
+        PyString_Size(obj2));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    {
+        if (PyString_Check(obj3))
+        arg4 = std::string(PyString_AsString(obj3),
+        PyString_Size(obj3));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    {
+        if (PyString_Check(obj4))
+        arg5 = std::string(PyString_AsString(obj4),
+        PyString_Size(obj4));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    {
+        if (PyString_Check(obj5))
+        arg6 = std::string(PyString_AsString(obj5),
+        PyString_Size(obj5));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    (arg1)-&gt;add_planet_and_station(arg2,arg3,arg4,arg5,arg6);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobGame_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobGame, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobStation__build_type_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *arg2 = (std::string *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation__build_type_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_build_type = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__build_type_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobStation__build_type_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::string *)&amp; ((arg1)-&gt;_build_type);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__background_pic_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *arg2 = (std::string *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation__background_pic_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_background_pic = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__background_pic_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobStation__background_pic_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::string *)&amp; ((arg1)-&gt;_background_pic);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobStation(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SpaceSprite *arg1 = (SpaceSprite *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    std::string *arg3 = 0 ;
+    std::string *arg4 = 0 ;
+    GobStation *result;
+    std::string temp3 ;
+    std::string temp4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:new_GobStation&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2)) {
+            temp3 = std::string(PyString_AsString(obj2),
+            PyString_Size(obj2));
+            arg3 = &amp;temp3;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    {
+        if (PyString_Check(obj3)) {
+            temp4 = std::string(PyString_AsString(obj3),
+            PyString_Size(obj3));
+            arg4 = &amp;temp4;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    result = (GobStation *)new GobStation(arg1,arg2,(std::string const &amp;)*arg3,(std::string const &amp;)*arg4);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobStation, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_buy_new_ship_menu(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_buy_new_ship_menu&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;buy_new_ship_menu(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_inflict_damage(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    SpaceObject *arg2 = (SpaceObject *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_inflict_damage&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceObject,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;inflict_damage(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_station_screen(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_station_screen&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;station_screen(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_upgrade_menu(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobStation *arg2 = (GobStation *) 0 ;
+    GobPlayer *arg3 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobStation_upgrade_menu&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;upgrade_menu(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobStation(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobStation&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobStation_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobStation, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_Upgrade_name_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    char *arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:Upgrade_name_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (arg1-&gt;name) delete [] arg1-&gt;name;
+        if (arg2) {
+            arg1-&gt;name = (char *) (new char[strlen(arg2)+1]);
+            strcpy((char *) arg1-&gt;name,arg2);
+        } else {
+            arg1-&gt;name = 0;
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_name_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    char *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_name_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (char *) ((arg1)-&gt;name);
+    
+    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)&quot;&quot;);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_status_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_status_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;status = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_status_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_status_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;status);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_num_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_num_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;num = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_num_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_num_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;num);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_index_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_index_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;index = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_index_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_index_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;index);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_update(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    GobStation *arg3 = (GobStation *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    bool result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_update&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (bool)(arg1)-&gt;update(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_execute(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    GobStation *arg3 = (GobStation *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_execute&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;execute(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_charge(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:Upgrade_charge&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;charge(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_clear(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    Ship *arg3 = (Ship *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_clear&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;clear(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_duplicate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Upgrade *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_duplicate&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Upgrade *)(arg1)-&gt;duplicate();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Upgrade, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_Upgrade(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_Upgrade&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * Upgrade_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_Upgrade, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_RainbowRift_p_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    float *arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_p_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_float,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        float *b = (float *) arg1-&gt;p;
+        for (ii = 0; ii &lt; RainbowRift::n*6+2; ii++) b[ii] = *((float *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_p_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    float *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_p_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (float *)(float *) ((arg1)-&gt;p);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_c_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    RGB *arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_c_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_RGB,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        RGB *b = (RGB *) arg1-&gt;c;
+        for (ii = 0; ii &lt; RainbowRift::n; ii++) b[ii] = *((RGB *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_c_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    RGB *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_c_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (RGB *)(RGB *) ((arg1)-&gt;c);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RGB, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:RainbowRift_next_time_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;next_time = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_next_time_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;next_time);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time2_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:RainbowRift_next_time2_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;next_time2 = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time2_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_next_time2_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;next_time2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_RainbowRift(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_RainbowRift&quot;)) goto fail;
+    result = (RainbowRift *)new RainbowRift();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RainbowRift, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_animate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    Frame *arg2 = (Frame *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_animate&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Frame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;animate(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_calculate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_calculate&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;calculate();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_squiggle(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_squiggle&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;squiggle();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_RainbowRift(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_RainbowRift&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * RainbowRift_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_RainbowRift, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyMethodDef SwigMethods[] = {
+	 { (char *)&quot;pair_id_set&quot;, _wrap_pair_id_set, METH_VARARGS },
+	 { (char *)&quot;pair_id_get&quot;, _wrap_pair_id_get, METH_VARARGS },
+	 { (char *)&quot;pair_value_set&quot;, _wrap_pair_value_set, METH_VARARGS },
+	 { (char *)&quot;pair_value_get&quot;, _wrap_pair_value_get, METH_VARARGS },
+	 { (char *)&quot;new_pair&quot;, _wrap_new_pair, METH_VARARGS },
+	 { (char *)&quot;delete_pair&quot;, _wrap_delete_pair, METH_VARARGS },
+	 { (char *)&quot;pair_swigregister&quot;, pair_swigregister, METH_VARARGS },
+	 { (char *)&quot;new_GobPlayer&quot;, _wrap_new_GobPlayer, METH_VARARGS },
+	 { (char *)&quot;delete_GobPlayer&quot;, _wrap_delete_GobPlayer, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_ship_set&quot;, _wrap_GobPlayer_ship_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_ship_get&quot;, _wrap_GobPlayer_ship_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_pair_list_set&quot;, _wrap_GobPlayer_pair_list_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_pair_list_get&quot;, _wrap_GobPlayer_pair_list_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_num_pairs_set&quot;, _wrap_GobPlayer_num_pairs_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_num_pairs_get&quot;, _wrap_GobPlayer_num_pairs_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer__add_pair&quot;, _wrap_GobPlayer__add_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer__get_pair&quot;, _wrap_GobPlayer__get_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_write_pair&quot;, _wrap_GobPlayer_write_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_read_pair&quot;, _wrap_GobPlayer_read_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_total_set&quot;, _wrap_GobPlayer_total_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_total_get&quot;, _wrap_GobPlayer_total_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_starbucks_set&quot;, _wrap_GobPlayer_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_starbucks_get&quot;, _wrap_GobPlayer_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_buckazoids_set&quot;, _wrap_GobPlayer_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_buckazoids_get&quot;, _wrap_GobPlayer_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_kills_set&quot;, _wrap_GobPlayer_kills_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_kills_get&quot;, _wrap_GobPlayer_kills_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_starbucks_set&quot;, _wrap_GobPlayer_value_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_starbucks_get&quot;, _wrap_GobPlayer_value_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_buckazoids_set&quot;, _wrap_GobPlayer_value_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_buckazoids_get&quot;, _wrap_GobPlayer_value_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_team_set&quot;, _wrap_GobPlayer_team_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_team_get&quot;, _wrap_GobPlayer_team_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_init&quot;, _wrap_GobPlayer_init, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_died&quot;, _wrap_GobPlayer_died, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_new_ship&quot;, _wrap_GobPlayer_new_ship, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_charge&quot;, _wrap_GobPlayer_charge, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_upgrade_list_set&quot;, _wrap_GobPlayer_upgrade_list_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_upgrade_list_get&quot;, _wrap_GobPlayer_upgrade_list_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_swigregister&quot;, GobPlayer_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_ship_set&quot;, _wrap_GobEnemy_ship_set, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_ship_get&quot;, _wrap_GobEnemy_ship_get, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_starbucks_set&quot;, _wrap_GobEnemy_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_starbucks_get&quot;, _wrap_GobEnemy_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_buckazoids_set&quot;, _wrap_GobEnemy_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_buckazoids_get&quot;, _wrap_GobEnemy_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_init&quot;, _wrap_GobEnemy_init, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_died&quot;, _wrap_GobEnemy_died, METH_VARARGS },
+	 { (char *)&quot;new_GobEnemy&quot;, _wrap_new_GobEnemy, METH_VARARGS },
+	 { (char *)&quot;delete_GobEnemy&quot;, _wrap_delete_GobEnemy, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_swigregister&quot;, GobEnemy_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobAsteroid_handle_damage&quot;, _wrap_GobAsteroid_handle_damage, METH_VARARGS },
+	 { (char *)&quot;GobAsteroid_death&quot;, _wrap_GobAsteroid_death, METH_VARARGS },
+	 { (char *)&quot;new_GobAsteroid&quot;, _wrap_new_GobAsteroid, METH_VARARGS },
+	 { (char *)&quot;delete_GobAsteroid&quot;, _wrap_delete_GobAsteroid, METH_VARARGS },
+	 { (char *)&quot;GobAsteroid_swigregister&quot;, GobAsteroid_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobGame__galaxy_set&quot;, _wrap_GobGame__galaxy_set, METH_VARARGS },
+	 { (char *)&quot;GobGame__galaxy_get&quot;, _wrap_GobGame__galaxy_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobplayer_set&quot;, _wrap_GobGame_gobplayer_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobplayer_get&quot;, _wrap_GobGame_gobplayer_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_switch_system&quot;, _wrap_GobGame_switch_system, METH_VARARGS },
+	 { (char *)&quot;new_GobGame&quot;, _wrap_new_GobGame, METH_VARARGS },
+	 { (char *)&quot;GobGame_get_this&quot;, _wrap_GobGame_get_this, METH_VARARGS },
+	 { (char *)&quot;delete_GobGame&quot;, _wrap_delete_GobGame, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_panel_set&quot;, _wrap_GobGame__player_panel_set, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_panel_get&quot;, _wrap_GobGame__player_panel_get, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_control_set&quot;, _wrap_GobGame__player_control_set, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_control_get&quot;, _wrap_GobGame__player_control_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_enemy_team_set&quot;, _wrap_GobGame_enemy_team_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_enemy_team_get&quot;, _wrap_GobGame_enemy_team_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_AddPanel&quot;, _wrap_GobGame_AddPanel, METH_VARARGS },
+	 { (char *)&quot;GobGame_calculate&quot;, _wrap_GobGame_calculate, METH_VARARGS },
+	 { (char *)&quot;GobGame_setGameDone&quot;, _wrap_GobGame_setGameDone, METH_VARARGS },
+	 { (char *)&quot;GobGame_ship_died&quot;, _wrap_GobGame_ship_died, METH_VARARGS },
+	 { (char *)&quot;GobGame_preinit&quot;, _wrap_GobGame_preinit, METH_VARARGS },
+	 { (char *)&quot;GobGame_init&quot;, _wrap_GobGame_init, METH_VARARGS },
+	 { (char *)&quot;GobGame_play_sound&quot;, _wrap_GobGame_play_sound, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_gobplayer&quot;, _wrap_GobGame_add_gobplayer, METH_VARARGS },
+	 { (char *)&quot;GobGame_get_player&quot;, _wrap_GobGame_get_player, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemies_set&quot;, _wrap_GobGame_gobenemies_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemies_get&quot;, _wrap_GobGame_gobenemies_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_max_enemies_set&quot;, _wrap_GobGame_max_enemies_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_max_enemies_get&quot;, _wrap_GobGame_max_enemies_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemy_set&quot;, _wrap_GobGame_gobenemy_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemy_get&quot;, _wrap_GobGame_gobenemy_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_get_enemy_index&quot;, _wrap_GobGame_get_enemy_index, METH_VARARGS },
+	 { (char *)&quot;GobGame_prepare&quot;, _wrap_GobGame_prepare, METH_VARARGS },
+	 { (char *)&quot;GobGame_fps&quot;, _wrap_GobGame_fps, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_new_enemy&quot;, _wrap_GobGame_add_new_enemy, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_stars&quot;, _wrap_GobGame_add_stars, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_asteroid&quot;, _wrap_GobGame_add_asteroid, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_system&quot;, _wrap_GobGame_add_system, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_player&quot;, _wrap_GobGame_add_player, METH_VARARGS },
+	 { (char *)&quot;GobGame_next_add_new_enemy_time_set&quot;, _wrap_GobGame_next_add_new_enemy_time_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_next_add_new_enemy_time_get&quot;, _wrap_GobGame_next_add_new_enemy_time_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_defenderSprite_set&quot;, _wrap_GobGame_defenderSprite_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_defenderSprite_get&quot;, _wrap_GobGame_defenderSprite_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_num_planets_set&quot;, _wrap_GobGame_num_planets_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_num_planets_get&quot;, _wrap_GobGame_num_planets_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_planet_set&quot;, _wrap_GobGame_planet_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_planet_get&quot;, _wrap_GobGame_planet_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_station_set&quot;, _wrap_GobGame_station_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_station_get&quot;, _wrap_GobGame_station_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_planet_and_station&quot;, _wrap_GobGame_add_planet_and_station, METH_VARARGS },
+	 { (char *)&quot;GobGame_swigregister&quot;, GobGame_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobStation__build_type_set&quot;, _wrap_GobStation__build_type_set, METH_VARARGS },
+	 { (char *)&quot;GobStation__build_type_get&quot;, _wrap_GobStation__build_type_get, METH_VARARGS },
+	 { (char *)&quot;GobStation__background_pic_set&quot;, _wrap_GobStation__background_pic_set, METH_VARARGS },
+	 { (char *)&quot;GobStation__background_pic_get&quot;, _wrap_GobStation__background_pic_get, METH_VARARGS },
+	 { (char *)&quot;new_GobStation&quot;, _wrap_new_GobStation, METH_VARARGS },
+	 { (char *)&quot;GobStation_buy_new_ship_menu&quot;, _wrap_GobStation_buy_new_ship_menu, METH_VARARGS },
+	 { (char *)&quot;GobStation_inflict_damage&quot;, _wrap_GobStation_inflict_damage, METH_VARARGS },
+	 { (char *)&quot;GobStation_station_screen&quot;, _wrap_GobStation_station_screen, METH_VARARGS },
+	 { (char *)&quot;GobStation_upgrade_menu&quot;, _wrap_GobStation_upgrade_menu, METH_VARARGS },
+	 { (char *)&quot;delete_GobStation&quot;, _wrap_delete_GobStation, METH_VARARGS },
+	 { (char *)&quot;GobStation_swigregister&quot;, GobStation_swigregister, METH_VARARGS },
+	 { (char *)&quot;Upgrade_name_set&quot;, _wrap_Upgrade_name_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_name_get&quot;, _wrap_Upgrade_name_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_starbucks_set&quot;, _wrap_Upgrade_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_starbucks_get&quot;, _wrap_Upgrade_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_buckazoids_set&quot;, _wrap_Upgrade_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_buckazoids_get&quot;, _wrap_Upgrade_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_status_set&quot;, _wrap_Upgrade_status_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_status_get&quot;, _wrap_Upgrade_status_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_num_set&quot;, _wrap_Upgrade_num_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_num_get&quot;, _wrap_Upgrade_num_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_index_set&quot;, _wrap_Upgrade_index_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_index_get&quot;, _wrap_Upgrade_index_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_update&quot;, _wrap_Upgrade_update, METH_VARARGS },
+	 { (char *)&quot;Upgrade_execute&quot;, _wrap_Upgrade_execute, METH_VARARGS },
+	 { (char *)&quot;Upgrade_charge&quot;, _wrap_Upgrade_charge, METH_VARARGS },
+	 { (char *)&quot;Upgrade_clear&quot;, _wrap_Upgrade_clear, METH_VARARGS },
+	 { (char *)&quot;Upgrade_duplicate&quot;, _wrap_Upgrade_duplicate, METH_VARARGS },
+	 { (char *)&quot;delete_Upgrade&quot;, _wrap_delete_Upgrade, METH_VARARGS },
+	 { (char *)&quot;Upgrade_swigregister&quot;, Upgrade_swigregister, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_p_set&quot;, _wrap_RainbowRift_p_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_p_get&quot;, _wrap_RainbowRift_p_get, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_c_set&quot;, _wrap_RainbowRift_c_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_c_get&quot;, _wrap_RainbowRift_c_get, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time_set&quot;, _wrap_RainbowRift_next_time_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time_get&quot;, _wrap_RainbowRift_next_time_get, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time2_set&quot;, _wrap_RainbowRift_next_time2_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time2_get&quot;, _wrap_RainbowRift_next_time2_get, METH_VARARGS },
+	 { (char *)&quot;new_RainbowRift&quot;, _wrap_new_RainbowRift, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_animate&quot;, _wrap_RainbowRift_animate, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_calculate&quot;, _wrap_RainbowRift_calculate, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_squiggle&quot;, _wrap_RainbowRift_squiggle, METH_VARARGS },
+	 { (char *)&quot;delete_RainbowRift&quot;, _wrap_delete_RainbowRift, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_swigregister&quot;, RainbowRift_swigregister, METH_VARARGS },
+	 { NULL, NULL }
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static void *_p_RainbowRiftTo_p_SpaceLocation(void *x) {
+    return (void *)((SpaceLocation *)  ((RainbowRift *) x));
+}
+static swig_type_info _swigt__p_GobPlayer[] = {{&quot;_p_GobPlayer&quot;, 0, &quot;GobPlayer *&quot;, 0},{&quot;_p_GobPlayer&quot;},{0}};
+static swig_type_info _swigt__p_p_Upgrade[] = {{&quot;_p_p_Upgrade&quot;, 0, &quot;Upgrade **&quot;, 0},{&quot;_p_p_Upgrade&quot;},{0}};
+static swig_type_info _swigt__p_SpaceLocation[] = {{&quot;_p_SpaceLocation&quot;, 0, &quot;SpaceLocation *&quot;, 0},{&quot;_p_SpaceLocation&quot;},{&quot;_p_RainbowRift&quot;, _p_RainbowRiftTo_p_SpaceLocation},{0}};
+static swig_type_info _swigt__p_p_GobStation[] = {{&quot;_p_p_GobStation&quot;, 0, &quot;GobStation **&quot;, 0},{&quot;_p_p_GobStation&quot;},{0}};
+static swig_type_info _swigt__p_GobStation[] = {{&quot;_p_GobStation&quot;, 0, &quot;GobStation *&quot;, 0},{&quot;_p_GobStation&quot;},{0}};
+static swig_type_info _swigt__p_Upgrade[] = {{&quot;_p_Upgrade&quot;, 0, &quot;Upgrade *&quot;, 0},{&quot;_p_Upgrade&quot;},{0}};
+static swig_type_info _swigt__p_RGB[] = {{&quot;_p_RGB&quot;, 0, &quot;RGB *&quot;, 0},{&quot;_p_RGB&quot;},{0}};
+static swig_type_info _swigt__p_Log[] = {{&quot;_p_Log&quot;, 0, &quot;Log *&quot;, 0},{&quot;_p_Log&quot;},{0}};
+static swig_type_info _swigt__p_StarMap[] = {{&quot;_p_StarMap&quot;, 0, &quot;StarMap *&quot;, 0},{&quot;_p_StarMap&quot;},{0}};
+static swig_type_info _swigt__p_float[] = {{&quot;_p_float&quot;, 0, &quot;float *&quot;, 0},{&quot;_p_float&quot;},{0}};
+static swig_type_info _swigt__p_GobAsteroid[] = {{&quot;_p_GobAsteroid&quot;, 0, &quot;GobAsteroid *&quot;, 0},{&quot;_p_GobAsteroid&quot;},{0}};
+static swig_type_info _swigt__p_TeamCode[] = {{&quot;_p_TeamCode&quot;, 0, &quot;TeamCode *&quot;, 0},{&quot;_p_TeamCode&quot;},{0}};
+static swig_type_info _swigt__p_GobEnemy[] = {{&quot;_p_GobEnemy&quot;, 0, &quot;GobEnemy *&quot;, 0},{&quot;_p_GobEnemy&quot;},{0}};
+static swig_type_info _swigt__p_p_GobEnemy[] = {{&quot;_p_p_GobEnemy&quot;, 0, &quot;GobEnemy **&quot;, 0},{&quot;_p_p_GobEnemy&quot;},{0}};
+static swig_type_info _swigt__p_p_Planet[] = {{&quot;_p_p_Planet&quot;, 0, &quot;Planet **&quot;, 0},{&quot;_p_p_Planet&quot;},{0}};
+static swig_type_info _swigt__p_RainbowRift[] = {{&quot;_p_RainbowRift&quot;, 0, &quot;RainbowRift *&quot;, 0},{&quot;_p_RainbowRift&quot;},{0}};
+static swig_type_info _swigt__p_GobGame[] = {{&quot;_p_GobGame&quot;, 0, &quot;GobGame *&quot;, 0},{&quot;_p_GobGame&quot;},{0}};
+static swig_type_info _swigt__p_Vector2[] = {{&quot;_p_Vector2&quot;, 0, &quot;Vector2 *&quot;, 0},{&quot;_p_Vector2&quot;},{0}};
+static swig_type_info _swigt__p_std__string[] = {{&quot;_p_std__string&quot;, 0, &quot;std::string *&quot;, 0},{&quot;_p_std__string&quot;},{0}};
+static swig_type_info _swigt__p_pair[] = {{&quot;_p_pair&quot;, 0, &quot;pair *&quot;, 0},{&quot;_p_pair&quot;},{0}};
+static swig_type_info _swigt__p_SpaceSprite[] = {{&quot;_p_SpaceSprite&quot;, 0, &quot;SpaceSprite *&quot;, 0},{&quot;_p_SpaceSprite&quot;},{0}};
+static swig_type_info _swigt__p_Control[] = {{&quot;_p_Control&quot;, 0, &quot;Control *&quot;, 0},{&quot;_p_Control&quot;},{0}};
+static swig_type_info _swigt__p_SpaceObject[] = {{&quot;_p_SpaceObject&quot;, 0, &quot;SpaceObject *&quot;, 0},{&quot;_p_SpaceObject&quot;},{0}};
+static swig_type_info _swigt__p_Frame[] = {{&quot;_p_Frame&quot;, 0, &quot;Frame *&quot;, 0},{&quot;_p_Frame&quot;},{0}};
+static swig_type_info _swigt__p_ShipPanel[] = {{&quot;_p_ShipPanel&quot;, 0, &quot;ShipPanel *&quot;, 0},{&quot;_p_ShipPanel&quot;},{0}};
+static swig_type_info _swigt__p_SAMPLE[] = {{&quot;_p_SAMPLE&quot;, 0, &quot;SAMPLE *&quot;, 0},{&quot;_p_SAMPLE&quot;},{0}};
+static swig_type_info _swigt__p_ShipType[] = {{&quot;_p_ShipType&quot;, 0, &quot;ShipType *&quot;, 0},{&quot;_p_ShipType&quot;},{0}};
+static swig_type_info _swigt__p_Ship[] = {{&quot;_p_Ship&quot;, 0, &quot;Ship *&quot;, 0},{&quot;_p_Ship&quot;},{0}};
+
+static swig_type_info *swig_types_initial[] = {
+_swigt__p_GobPlayer, 
+_swigt__p_p_Upgrade, 
+_swigt__p_SpaceLocation, 
+_swigt__p_p_GobStation, 
+_swigt__p_GobStation, 
+_swigt__p_Upgrade, 
+_swigt__p_RGB, 
+_swigt__p_Log, 
+_swigt__p_StarMap, 
+_swigt__p_float, 
+_swigt__p_GobAsteroid, 
+_swigt__p_TeamCode, 
+_swigt__p_GobEnemy, 
+_swigt__p_p_GobEnemy, 
+_swigt__p_p_Planet, 
+_swigt__p_RainbowRift, 
+_swigt__p_GobGame, 
+_swigt__p_Vector2, 
+_swigt__p_std__string, 
+_swigt__p_pair, 
+_swigt__p_SpaceSprite, 
+_swigt__p_Control, 
+_swigt__p_SpaceObject, 
+_swigt__p_Frame, 
+_swigt__p_ShipPanel, 
+_swigt__p_SAMPLE, 
+_swigt__p_ShipType, 
+_swigt__p_Ship, 
+0
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+static swig_const_info swig_const_table[] = {
+{ SWIG_PY_INT,     (char *)&quot;Upgrade_active&quot;, (long) Upgrade::active, 0, 0, 0},
+{ SWIG_PY_INT,     (char *)&quot;Upgrade_inactive&quot;, (long) Upgrade::inactive, 0, 0, 0},
+{ SWIG_PY_INT,     (char *)&quot;RainbowRift_n&quot;, (long) RainbowRift::n, 0, 0, 0},
+{0}};
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+SWIGEXPORT(void) SWIG_init(void) {
+    static PyObject *SWIG_globals = 0; 
+    static int       typeinit = 0;
+    PyObject *m, *d;
+    int       i;
+    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
+    m = Py_InitModule((char *) SWIG_name, SwigMethods);
+    d = PyModule_GetDict(m);
+    
+    if (!typeinit) {
+        for (i = 0; swig_types_initial[i]; i++) {
+            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
+        }
+        typeinit = 1;
+    }
+    SWIG_InstallConstants(d,swig_const_table);
+    
+}
+

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mframe.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -1270,6 +1270,7 @@
   else
     return false;
 }
+
 void Physics::animate (Frame *frame) {
   STACKTRACE;
   
@@ -1279,7 +1280,7 @@
 
   presence.sort(presence_cmp);
   item.sort(presence_cmp);
-  
+
   std::copy(item.begin(),item.end(),back_inserter(animate_buffer));
   animate_buffer2 = presence;
   animate_buffer.merge(animate_buffer2,presence_cmp);
@@ -1289,7 +1290,10 @@
   aa_set_background ( back );
   for(std::list&lt;Presence*&gt;::iterator i=animate_buffer.begin();i!=animate_buffer.end();i++)
     {
-      if ((*i)-&gt;exists()) (*i)-&gt;animate(frame);
+      if ((*i)-&gt;exists()) 
+	{
+	  (*i)-&gt;animate(frame);
+	}
     }
   return;
 }

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mframe.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -134,7 +134,7 @@
   virtual void ship_died(Ship *who, SpaceLocation *source);
 };
 
-/// \brief Any item in the game
+/// \brief Any item in the game without location
 class Presence : public BaseClass 
 { 
   friend class Physics;

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mgame.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -46,7 +46,6 @@
 
 #include &quot;other/twconfig.h&quot;
 #include &quot;other/dialogs.h&quot;
-#include &quot;xslt/twexslt.h&quot;
 
 int random_seed[2];
 
@@ -860,7 +859,6 @@
   indteamtoggle = 0;
   indhealthtoggle = 0;
   _targrettrack = 0;
-  indhealthtoggle = ~indhealthtoggle;
 }
 
 void Game::init(Log *_log, const std::string&amp; save) 
@@ -1368,21 +1366,6 @@
 
 int Game::Load(std::string xml)
 {
-  if(!exists(xml.c_str()))
-    return 1;
-
-  // parse the input XML document
-  xml::tree_parser parser(xml.c_str());
-  xml::document &amp;doc = parser.get_document();
-  
-  // parse the stylesheet
-  xslt::stylesheet style(data_full_path(&quot;xslt/load.xsl&quot;).c_str());
-  
-  // transform the XML document using the stylesheet
-  //xml::document &amp;result = style.apply(doc);
-  style.apply(doc);
-
-  //  std::cout &lt;&lt; result;
   return 0;
 }
 

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mhelpers.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -610,6 +610,7 @@
 
 void ScrollText(std::vector&lt;std::string&gt;&amp; text, FONT* font, int color, const std::string&amp; backgr, const std::string&amp; align, int speed)
 {
+  STACKTRACE;
   BITMAP* d_buf = create_bitmap(SCREEN_W, SCREEN_H);
   clear(d_buf);
   copy_buf();

Modified: trunk/source/melee/mitems.cpp
===================================================================
--- trunk/source/melee/mitems.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mitems.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -44,7 +44,6 @@
 		state = 0;
 		return;
 	}
-
 }
 
 

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/msprite.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -1026,6 +1026,34 @@
       iy = iround_down(pos.y);
       iw = iround_up(pos.x+size.x) + 1 - ix;
       ih = iround_up(pos.y+size.y) + 1 - iy;
+      ///////////////////////////////////////////////////////////////////////////////////
+      /*
+      BITMAP* blt;
+      int key = (int)size.abs()*1000 + index;
+      std::map&lt;int,BITMAP*&gt;::iterator i = _cache.find(key);
+      if(i!= _cache.end())
+	{
+	  blt = (*i).second;
+	}
+      else
+	{
+	  blt = create_bitmap(size.x, size.y);
+          clear_to_color(blt, bitmap_mask_color(blt));
+	  stretch_blit(bmp, blt, 0, 0, bmp-&gt;w,bmp-&gt;h, 
+			  0, 0, size.x, size.y);
+	  _cache[key] = blt;
+	}
+      draw_sprite(frame-&gt;surface, blt, pos.x, pos.y);
+      if(_cache.size()&gt;128)
+	{
+	  for(std::map&lt;int,BITMAP*&gt;::iterator i = _cache.begin(); i!= _cache.end(); i++)
+	    {
+	      destroy_bitmap((*i).second);
+	    }
+	  _cache.clear();
+	}
+      */
+      ///////////////////////////////////////////////////////////////////////////////////
       aa_stretch_blit(bmp, frame-&gt;surface, 0,0,bmp-&gt;w,bmp-&gt;h, 
 		      pos.x, pos.y, size.x, size.y);
     }
@@ -1035,8 +1063,9 @@
       iy = iround(pos.y);
       iw = iround(size.x);
       ih = iround(size.y);
+     
       aa_stretch_blit(bmp, frame-&gt;surface, 0,0,bmp-&gt;w,bmp-&gt;h, 
-		      ix, iy, iw, ih);
+      		      ix, iy, iw, ih);
     }
   frame-&gt;add_box(ix, iy, iw, ih);
   return;

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -30,6 +30,7 @@
 #include &lt;list&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
+#include &lt;map&gt;
 
 #ifndef PI
 #	define PI 3.14159265358979323846
@@ -430,6 +431,7 @@
 void animate_bmp(BITMAP *bmp, Vector2 pos, Frame *space);
 
 
+
 /// Sprite 
 class SpaceSprite 
 {
@@ -446,6 +448,10 @@
   struct PMASK **m;
   Surface **b[MAX_MIP_LEVELS];
 
+  
+  /// (int)size.abs()*1000 + index  - key for bitmap
+  std::map&lt;int,BITMAP*&gt; _cache;
+
   int references;
   char *attributes;
   enum 

Modified: trunk/source/other/starmap.cpp
===================================================================
--- trunk/source/other/starmap.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/other/starmap.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -224,7 +224,6 @@
 	     {
 	       _targetStar = NULL;
 	       _selectedStar = NULL;
-	       _text = &quot;&quot;;
 	       redraw();
 	     }
 	 }

Added: trunk/source/python/fileops.cpp
===================================================================
--- trunk/source/python/fileops.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/fileops.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,400 @@
+/*
+   $Id: fileops.cc,v 1.13 2003/01/24 22:15:43 ksterker Exp $
+
+   Copyright (C) 1999/2000/2001/2002/2003 Alexandre Courbot
+   Part of the Adonthell Project <A HREF="http://adonthell.linuxgames.com">http://adonthell.linuxgames.com</A>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+
+/**
+ * @file   fileops.cc
+ * @author Alexandre Courbot &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">alexandrecourbot at linuxgames.com</A>&gt;
+ * 
+ * @brief  Defines the igzstream, ogzstream and fileops classes.
+ * 
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;iostream&gt;
+#include &lt;SDL/SDL_endian.h&gt;
+#include &quot;fileops.h&quot;
+
+
+using namespace std;
+
+
+gz_file::gz_file ()
+{
+    opened = false;
+}
+
+gz_file::gz_file (const string &amp; fname, gz_type t)
+{
+    opened = false;
+    open (fname, t);
+}
+
+gz_file::~gz_file ()
+{
+    if (is_open ()) gzclose (file);
+}
+
+bool gz_file::open (const string &amp; fname, gz_type t)
+{
+    if (t == READ) file = gzopen (fname.c_str (),&quot;rb6&quot;);
+    else file = gzopen (fname.c_str (),&quot;wb6&quot;);
+    if (!file) return false;
+    opened = true;
+    return true;
+}
+
+void gz_file::close ()
+{
+    if (is_open ()) gzclose (file);
+    opened = false;
+}
+
+igzstream::igzstream () : gz_file ()
+{
+}
+
+igzstream::igzstream (const string &amp; fname) : gz_file (fname, READ)
+{
+}
+
+igzstream::~igzstream ()
+{
+}
+
+bool igzstream::open (const string &amp; fname)
+{
+    return gz_file::open (fname, READ);
+}
+
+/// Reads a boolean.
+bool&amp; operator &lt;&lt; (bool&amp; n, igzstream&amp; gfile)
+{
+    u_int8 b;
+    gzread (gfile.file, &amp;b, sizeof (b));
+    return (n = b);
+}
+
+/// Reads a boolean.
+bool igzstream::get_bool ()
+{
+    u_int8 b;
+    gzread (file, &amp;b, sizeof (b));
+    return b;
+}
+
+/// Reads a char.
+char&amp; operator &lt;&lt; (char&amp; n, igzstream&amp; gfile)
+{
+    gzread (gfile.file, &amp;n, sizeof (n));
+    return n;
+}
+
+/// Read a block of size chars
+void igzstream::get_block (void * to, u_int32 size)
+{
+    gzread (file, to, size); 
+}
+
+/// Reads a u_int8.
+u_int8&amp; operator &lt;&lt; (u_int8&amp; n, igzstream&amp; gfile)
+{
+    gzread(gfile.file, &amp;n, sizeof (n));
+    return n;
+}
+
+/// Reads a u_int8.
+u_int8 igzstream::get_uint8 ()
+{
+    u_int8 n;
+    gzread (file, &amp;n, sizeof (n));
+    return n;
+}
+
+/// Reads a s_int8.
+s_int8&amp; operator &lt;&lt; (s_int8&amp; n, igzstream&amp; gfile)
+{
+    gzread(gfile.file, &amp;n, sizeof (n));
+    return n;
+}
+
+/// Reads a s_int8.
+s_int8 igzstream::get_sint8 ()
+{
+    s_int8 n;
+    gzread (file, &amp;n, sizeof (n));
+    return n;
+}
+
+/// Reads a u_int16.
+u_int16&amp; operator &lt;&lt; (u_int16&amp; n, igzstream&amp; gfile)
+{
+    gzread(gfile.file, &amp;n, sizeof (n));
+    n = SDL_SwapLE16(n);
+    return n;
+}
+
+/// Reads a u_int16.
+u_int16 igzstream::get_uint16 ()
+{
+    u_int16 n;
+    gzread (file, &amp;n, sizeof (n));
+    return SDL_SwapLE16(n);
+}
+
+/// Reads a s_int16.
+s_int16&amp; operator &lt;&lt; (s_int16&amp; n, igzstream&amp; gfile)
+{
+    gzread(gfile.file, &amp;n, sizeof (n));
+    n = SDL_SwapLE16(n);
+    return n;
+}
+
+/// Reads a s_int16.
+s_int16 igzstream::get_sint16 ()
+{
+    s_int16 n;
+    gzread (file, &amp;n, sizeof (n));
+    return SDL_SwapLE16(n);
+}
+
+/// Reads a u_int32.
+u_int32&amp; operator &lt;&lt; (u_int32&amp; n, igzstream&amp; gfile)
+{
+    gzread(gfile.file, &amp;n, sizeof (n));
+    n = SDL_SwapLE32(n);
+    return n;
+}
+
+/// Reads a u_int32.
+u_int32 igzstream::get_uint32 ()
+{
+    u_int32 n;
+    gzread (file, &amp;n, sizeof (n));
+    return SDL_SwapLE32(n);
+}
+
+/// Reads a s_int32.
+s_int32&amp; operator &lt;&lt; (s_int32&amp; n, igzstream&amp; gfile)
+{
+    gzread(gfile.file, &amp;n, sizeof (n));
+    n = SDL_SwapLE32(n);
+    return n;
+}
+
+/// Reads a s_int32.
+s_int32 igzstream::get_sint32 ()
+{
+    s_int32 n;
+    gzread (file, &amp;n, sizeof (n));
+    return SDL_SwapLE32(n);
+}
+
+/// Reads a string.
+string&amp; operator &lt;&lt; (string&amp; s, igzstream&amp; gfile)
+{
+    u_int16 strl;
+    char c;
+    s = &quot;&quot;; 
+    strl &lt;&lt; gfile;
+    while (strl)
+    {
+	c &lt;&lt; gfile;
+	s += c;
+	strl --;
+    }
+    return s;
+}
+
+/// Reads a string.
+string igzstream::get_string ()
+{
+    string s;
+    s &lt;&lt; *this;
+    return s;
+}
+
+/// Reads a float.
+float&amp; operator &lt;&lt; (float&amp; f, igzstream&amp; gfile)
+{
+    string sf;
+    sf &lt;&lt; gfile;
+    
+    // floats saved as strings to remain independent of architecture
+    sscanf (sf.c_str (), &quot;%f&quot;, &amp;f);
+    
+    return f;
+}
+
+/// Reads a float.
+float igzstream::get_float ()
+{
+    float f;
+    f &lt;&lt; *this;
+    return f;
+}
+
+
+ogzstream::ogzstream () : gz_file ()
+{
+}
+
+ogzstream::ogzstream (const string &amp; fname) : gz_file (fname, WRITE)
+{
+}
+
+ogzstream::~ogzstream ()
+{
+}
+
+bool ogzstream::open (const string &amp; fname)
+{
+    return gz_file::open (fname, WRITE);
+}
+
+void ogzstream::put_block (void * to, u_int32 size)
+{
+    gzwrite (file, to, size); 
+}
+
+/// Writes a boolean.
+const bool&amp; operator &gt;&gt; (const bool&amp; n, ogzstream&amp; gfile)
+{
+    u_int8 b = n;
+    gzwrite (gfile.file, &amp;b, sizeof (b));
+    return n;
+}
+
+/// Writes a char.
+const char&amp; operator &gt;&gt; (const char&amp; n, ogzstream&amp; gfile)
+{
+    gzwrite (gfile.file, (char *) &amp;n, sizeof (n));
+    return n;
+}
+
+/// Writes a u_int8.
+const u_int8&amp; operator &gt;&gt; (const u_int8&amp; n, ogzstream&amp; gfile)
+{
+    gzwrite(gfile.file, (u_int8 *) &amp;n, sizeof (n));
+    return n;
+}
+
+/// Writes a s_int8.
+const s_int8&amp; operator &gt;&gt; (const s_int8&amp; n, ogzstream&amp; gfile)
+{
+    gzwrite(gfile.file, (s_int8 *) &amp;n, sizeof (n));
+    return n;
+}
+
+/// Writes a u_int16.
+const u_int16&amp; operator &gt;&gt; (const u_int16&amp; n, ogzstream&amp; gfile)
+{
+    u_int16 s = SDL_SwapLE16(n);
+    gzwrite(gfile.file, (u_int16 *) &amp;s, sizeof (n));
+    return n;
+}
+
+/// Writes a s_int16.
+const s_int16&amp; operator &gt;&gt; (const s_int16&amp; n, ogzstream&amp; gfile)
+{
+    s_int16 s = SDL_SwapLE16(n);
+    gzwrite(gfile.file, (s_int16 *) &amp;s, sizeof (n));
+    return n;
+}
+
+/// Writes a u_int32.
+const u_int32&amp; operator &gt;&gt; (const u_int32&amp; n, ogzstream&amp; gfile)
+{
+    u_int32 s = SDL_SwapLE32(n);
+    gzwrite(gfile.file, (u_int32 *) &amp;s, sizeof (n));
+    return n;
+}
+
+/// Writes a s_int32.
+const s_int32&amp; operator &gt;&gt; (const s_int32&amp; n, ogzstream&amp; gfile)
+{
+    s_int32 s = SDL_SwapLE32(n);
+    gzwrite(gfile.file, (s_int32 *) &amp;s, sizeof (n));
+    return n;
+}
+
+/// Writes a string.
+string&amp; operator &gt;&gt; (const string&amp; s, ogzstream&amp; gfile)
+{
+    u_int16 strl = s.length ();
+    string::iterator i; 
+    strl &gt;&gt;  gfile;
+    
+    for (i = ((string&amp;) s).begin (); i != ((string&amp;) s).end (); i++) 
+        (*i) &gt;&gt;  gfile;
+    return (string&amp;) s;
+}
+
+/// Writes a float.
+const float&amp; operator &gt;&gt; (const float&amp; f, ogzstream&amp; gfile)
+{
+    char sf[16];
+    
+    // floats saved as strings to remain independent of architecture
+    snprintf (sf, 16, &quot;%f&quot;, f);
+    sf &gt;&gt; gfile;
+    
+    return f;
+}
+
+void fileops::put_version (ogzstream&amp; file, u_int16 version)
+{
+    char c = 'v'; 
+    c &gt;&gt; file;
+    version &gt;&gt; file; 
+}
+
+// read version info from file and check whether we can handle it
+bool fileops::get_version (igzstream&amp; file, u_int16 min, u_int16 max, string name)
+{
+    char vinfo;
+    u_int16 version;
+
+    vinfo &lt;&lt; file;
+
+    if (name == &quot;&quot;) name = &quot;&lt;unknown&gt;&quot;;
+
+    // file contains no version info
+    if (vinfo != 'v')
+    {
+        cerr &lt;&lt; &quot;Version information missing in file \&quot;&quot; &lt;&lt; name &lt;&lt; endl;
+        cerr &lt;&lt; &quot;You should get a more recent data package.\n&quot;;
+        return false;
+    }
+    
+    // check whether file has the version we expect
+    version &lt;&lt; file;
+
+    if (version &lt; min || version &gt; max)
+    {
+        cerr &lt;&lt; &quot;File \&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\&quot; has\nversion number &quot; &lt;&lt; version &lt;&lt; &quot;, &quot;;
+        cerr &lt;&lt;  &quot;but I was expecting &quot; &lt;&lt; min &lt;&lt; &quot; &lt;= version &lt;= &quot; &lt;&lt; max &lt;&lt; endl;
+	
+        // file is newer than code
+        if (version &gt; max)
+            cerr &lt;&lt; &quot;You should get an up-to-date version of this program.\n\n&quot;;
+        // file is older than code
+        else
+            cerr &lt;&lt; &quot;You should probably get a more recent data package.\n&quot;;
+
+        return false;
+    } 
+    return true;
+}

Added: trunk/source/python/fileops.h
===================================================================
--- trunk/source/python/fileops.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/fileops.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,338 @@
+/*
+   $Id: fileops.h,v 1.17 2003/01/20 20:18:43 ksterker Exp $
+
+   Copyright (C) 2001/2003 Alexandre Courbot
+   Part of the Adonthell Project <A HREF="http://adonthell.linuxgames.com">http://adonthell.linuxgames.com</A>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+
+/**
+ * @file   fileops.h
+ * @author Alexandre Courbot &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">alexandrecourbot at linuxgames.com</A>&gt;
+ * 
+ * @brief  Declares the igzstream, ogzstream and fileops classes.
+ * 
+ */
+
+
+
+
+#ifndef FILEOPS_H_
+#define FILEOPS_H_
+
+#include &lt;zlib.h&gt;
+#include &lt;string&gt;
+#include &quot;types.h&quot;
+
+
+#ifndef SWIG
+//using namespace std; 
+#endif
+
+
+/**
+ * Enumeration to know whether a file is read or write opened.
+ * 
+ */ 
+typedef enum { READ, WRITE } gz_type;
+
+
+/**
+ * Base class for igzstream and ogzstream.
+ * 
+ */ 
+class gz_file
+{
+public:
+    /** 
+     * Default constructor.
+     * 
+     */
+    gz_file ();
+
+#ifndef SWIG
+    /** 
+     * 
+     * 
+     * @param fname name of the file to open.
+     * @param t access (READ or WRITE).
+     */
+    gz_file (const std::string &amp; fname, gz_type t);
+#endif
+
+    /** 
+     * Destructor.
+     * 
+     */
+    virtual ~gz_file ();
+    
+    /** 
+     * Opens a file.
+     * 
+     * @param fname name of the file to open.
+     * @param t access (READ or WRITE).
+     * 
+     * @return true if succeed, false otherwise.
+     */
+    bool open (const std::string &amp; fname, gz_type t);
+
+    /** 
+     * Close the file that was opened.
+     * 
+     */
+    void close ();
+
+    /** 
+     * Returns whether the file is opened or not.
+     * 
+     * 
+     * @return true if the file is opened, false otherwise.
+     */
+    bool is_open () { return opened; }
+
+    /** 
+     * Returns whether the file is at it's end or not.
+     * 
+     * 
+     * @return true if the end of file is reached, else otherwise.
+     */
+    bool eof () 
+    {
+        return gzeof (file); 
+    }
+    
+protected:
+    /** 
+     * The actual gzFile.
+     * 
+     */ 
+    gzFile file;
+
+private:
+    /// NEVER pass this by value.
+    gz_file (gz_file&amp; src); 
+    
+    /// Opened or not?
+    bool opened; 
+};
+
+
+/** 
+ * Class to read data from a Gzip compressed file.
+ */ 
+class igzstream : public gz_file
+{
+public:
+    /**
+     * Default constructor.
+     * 
+     */ 
+    igzstream ();
+
+#ifndef SWIG
+    /** 
+     * Opens a file for read access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     */ 
+    igzstream (const std::string &amp; fname);
+#endif
+    
+    /**
+     * Destructor.
+     * 
+     */ 
+    ~igzstream ();
+
+    /** 
+     * Opens a file for read access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     * @return true if succeed, false otherwise.
+     */
+    bool open (const std::string &amp; fname);
+
+    /** 
+     * Reads a block of bytes from the file.
+     * 
+     * @param to pointer to the buffer where to read.
+     * @param size number of bytes to read.
+     */
+    void get_block (void * to, u_int32 size); 
+
+#ifndef SWIG
+    /// Reads a boolean.
+    friend bool&amp; operator &lt;&lt; (bool&amp; n, igzstream&amp; gfile);
+
+    /// Reads a char.
+    friend char&amp; operator &lt;&lt; (char&amp; n, igzstream&amp; gfile);
+
+    /// Reads a u_int8.
+    friend u_int8&amp; operator &lt;&lt; (u_int8&amp; n, igzstream&amp; gfile);
+
+    /// Reads a s_int8.
+    friend s_int8&amp; operator &lt;&lt; (s_int8&amp; n, igzstream&amp; gfile);
+
+    /// Reads a u_int16.
+    friend u_int16&amp; operator &lt;&lt; (u_int16&amp; n, igzstream&amp; gfile);
+
+    /// Reads a s_int16.
+    friend s_int16&amp; operator &lt;&lt; (s_int16&amp; n, igzstream&amp; gfile);
+
+    /// Reads a u_int32.
+    friend u_int32&amp; operator &lt;&lt; (u_int32&amp; n, igzstream&amp; gfile);
+
+    /// Reads a s_int32.
+    friend s_int32&amp; operator &lt;&lt; (s_int32&amp; n, igzstream&amp; gfile);
+
+    /// Reads a string.
+    friend std::string&amp; operator &lt;&lt; (std::string&amp; s, igzstream&amp; gfile);
+    
+    /// Reads a float.
+    friend float&amp; operator &lt;&lt; (float&amp; s, igzstream&amp; gfile);
+#endif
+
+    bool get_bool ();
+    u_int8 get_uint8 ();
+    s_int8 get_sint8 ();
+    u_int16 get_uint16 ();
+    s_int16 get_sint16 ();
+    u_int32 get_uint32 ();
+    s_int32 get_sint32 ();
+    std::string get_string ();
+    float get_float ();
+
+private:
+    /// NEVER pass this by value.
+    igzstream (igzstream&amp; src);  
+};
+
+/** 
+ * Class to write data from a Gzip compressed file.
+ */ 
+class ogzstream : public gz_file
+{
+public:
+    /**
+     * Default constructor.
+     * 
+     */ 
+    ogzstream ();
+
+#ifndef SWIG
+    /** 
+     * Opens a file for write access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     */ 
+    ogzstream (const std::string &amp; fname);
+#endif
+    
+    /**
+     * Destructor.
+     * 
+     */
+    ~ogzstream ();
+
+    /** 
+     * Opens a file for write access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     * @return true if succeed, false otherwise.
+     */
+    bool open (const std::string &amp; fname);
+
+    /** 
+     * Writes a block of bytes to the file.
+     * 
+     * @param to pointer to the buffer to write.
+     * @param size number of bytes to write.
+     */
+    void put_block (void * to, u_int32 size); 
+
+#ifndef SWIG
+    /// Writes a boolean.
+    friend const bool&amp; operator &gt;&gt; (const bool&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a char.
+    friend const char&amp; operator &gt;&gt; (const char&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a u_int8.
+    friend const u_int8&amp; operator &gt;&gt; (const u_int8&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a s_int8.
+    friend const s_int8&amp; operator &gt;&gt; (const s_int8&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a u_int16.
+    friend const u_int16&amp; operator &gt;&gt; (const u_int16&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a s_int16.
+    friend const s_int16&amp; operator &gt;&gt; (const s_int16&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a u_int32.
+    friend const u_int32&amp; operator &gt;&gt; (const u_int32&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a s_int32.
+    friend const s_int32&amp; operator &gt;&gt; (const s_int32&amp; n, ogzstream&amp; gfile);
+
+    /// Writes a string.
+    friend std::string&amp; operator &gt;&gt; (const std::string&amp; s, ogzstream&amp; gfile);
+    
+    /// Writes a float.
+    friend const float&amp; operator &gt;&gt; (const float&amp; s, ogzstream&amp; gfile);
+#endif
+
+    void put_bool (const bool &amp;n)         { n &gt;&gt; *this; }
+    void put_uint8 (const u_int8 &amp;n)      { n &gt;&gt; *this; }
+    void put_sint8 (const s_int8 &amp;n)      { n &gt;&gt; *this; }
+    void put_uint16 (const u_int16 &amp;n)    { n &gt;&gt; *this; }
+    void put_sint16 (const s_int16 &amp;n)    { n &gt;&gt; *this; }
+    void put_uint32 (const u_int32 &amp;n)    { n &gt;&gt; *this; }
+    void put_sint32 (const s_int32 &amp;n)    { n &gt;&gt; *this; }
+    void put_string (const std::string&amp; s)     { s &gt;&gt; *this; }
+    void put_float (const float &amp;n)       { n &gt;&gt; *this; }
+    
+private:
+    /// NEVER pass this by value.
+    ogzstream (ogzstream&amp; src);   
+};
+
+/// File version control class.
+class fileops
+{
+public:
+    /** 
+     * Sets the version number of a file.
+     * 
+     * @param file file where to write the version number.
+     * @param version version number to write.
+     */
+    static void put_version (ogzstream&amp; file, u_int16 version);  // Set version of a file
+
+    /** 
+     * 
+     * 
+     * @param file file to check version.
+     * @param min minimum expected version number.
+     * @param max maximum expected version number.
+     * @param name filename of the passed file.
+     * 
+     * @return true if 
+     */
+    static bool get_version (igzstream&amp; file, u_int16 min, u_int16 max, std::string name); // Check version
+};
+
+
+#endif // __FILEOPS_H__

Added: trunk/source/python/game.cpp
===================================================================
--- trunk/source/python/game.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/game.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,122 @@
+/*
+   $Id: game.cc,v 1.28 2003/02/20 17:27:41 ksterker Exp $
+
+   Copyright (C) 1999/2000/2001/2002 Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+   Copyright (C) 2002 Alexandre Courbot &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">alexandrecourbot at linuxgames.com</A>&gt;
+   Part of the Adonthell Project <A HREF="http://adonthell.linuxgames.com">http://adonthell.linuxgames.com</A>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+/**
+ * @file   game.cc
+ * @author Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+ * @author Alexandre Courbot &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">alexandrecourbot at linuxgames.com</A>&gt;
+ * 
+ * @brief  Defines the game class.
+ * 
+ * 
+ */
+
+
+#include &quot;game.h&quot;
+#include &lt;stdlib.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;dirent.h&gt;
+
+
+std::string game::User_data_dir; 
+std::string game::Global_data_dir; 
+std::string game::Game_data_dir; 
+
+
+void game::init (std::string game_dir) 
+{
+    Global_data_dir = game_dir;
+#ifndef SINGLE_DIR_INST
+    User_data_dir = getenv (&quot;HOME&quot;);
+    User_data_dir += &quot;/.adonthell&quot;;
+#else
+    User_data_dir = Global_data_dir;
+#endif
+}
+
+void game::set_game_data_dir(std::string game_dir)
+{
+    Game_data_dir = game_dir;
+}
+
+bool game::directory_exist (const std::string &amp; dirname)
+{
+    DIR * dir = opendir (dirname.c_str ());
+
+    if (dir) 
+    {
+        closedir (dir);
+        return true; 
+    }
+
+    return false; 
+}
+
+bool game::file_exist (const std::string &amp; fname) 
+{
+    FILE * file = fopen (fname.c_str (), &quot;r&quot;);
+
+    if (file) 
+    {
+        fclose (file);
+        return true; 
+    }
+
+    return false; 
+}
+
+std::string game::find_file (const std::string &amp; fname) 
+{
+    std::string ret;
+
+    // If the name is already absolute, no need to search...
+    if (fname[0] == '/') return fname; 
+    
+    // First check in the current game directory
+    if ((ret = game_data_dir () + &quot;/&quot;) != &quot;/&quot; &amp;&amp; file_exist (ret + fname))
+        ret += fname; 
+    // Then check the global data directory
+    else if (file_exist ((ret = global_data_dir () + &quot;/&quot;) + fname)) 
+        ret += fname;
+    // Finally, try the user data directory
+    else if (file_exist ((ret = user_data_dir () + &quot;/&quot;) + fname))
+        ret += fname;
+    // Nothing found! So bad...
+    else ret = &quot;&quot;;
+
+    return ret; 
+}
+
+std::string game::find_directory (const std::string &amp; dirname) 
+{
+    std::string ret;
+
+    // If the name is already absolute, no need to search...
+    if (dirname[0] == '/') return dirname; 
+
+    // First check in the current game directory
+    if ((ret = game_data_dir () + &quot;/&quot;) != &quot;/&quot; &amp;&amp; directory_exist (ret + dirname))
+        ret += dirname; 
+    // Then check the global data directory
+    else if (directory_exist ((ret = global_data_dir () + &quot;/&quot;) + dirname)) 
+        ret += dirname;
+    // Finally, try the user data directory
+    else if (directory_exist ((ret = user_data_dir () + &quot;/&quot;) + dirname))
+        ret += dirname;
+    // Nothing found! So bad...
+    else ret = &quot;&quot;;
+
+    return ret; 
+}

Added: trunk/source/python/game.h
===================================================================
--- trunk/source/python/game.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/game.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,138 @@
+/*
+   $Id: game.h,v 1.25 2002/04/27 17:00:19 gnurou Exp $
+
+   Copyright (C) 1999/2000/2001 Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+   Copyright (C) 2002 Alexandre Courbot &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">alexandrecourbot at linuxgames.com</A>&gt;
+   Part of the Adonthell Project <A HREF="http://adonthell.linuxgames.com">http://adonthell.linuxgames.com</A>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+/**
+ * @file   game.h
+ * @author Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+ * @author Alexandre Courbot &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">alexandrecourbot at linuxgames.com</A>&gt;
+ * 
+ * @brief  Declares the game class.
+ * 
+ * 
+ */
+
+
+
+#ifndef GAME_H__
+#define GAME_H__
+
+
+#include &lt;string&gt;
+#include &quot;types.h&quot;
+
+#ifndef SWIG 
+//using std::string; 
+#endif
+
+/**
+ * Holds information about global settings.
+ *
+ * This static class should be the first to be initialised in your application,
+ * because many others depends on it's correct settings.
+ * 
+ */
+class game
+{
+public:
+    static std::string User_data_dir;
+    static std::string Global_data_dir;
+    static std::string Game_data_dir; 
+
+
+    /** 
+     * Initialise the game framework.
+     * 
+     * @param game_dir Global data directory.
+     */
+    static void init (std::string game_dir); 
+
+    /** 
+     * Specify an additional data directory containing game data.
+     * 
+     * @param game_dir Game data directory.
+     */
+    static void set_game_data_dir (std::string game_dir); 
+    
+    /** 
+     * Returns the absolute path to the user data directory (usually ~/.adonthell).
+     * 
+     * 
+     * @return user data directory
+     */
+    static std::string user_data_dir ()
+    {
+        return User_data_dir; 
+    }
+
+    /** 
+     * Returns the absolute path to the global data directory.
+     * 
+     * 
+     * @return global data directory
+     */
+    static std::string global_data_dir ()
+    {
+        return Global_data_dir; 
+    }
+
+    /** 
+     * Returns the absolute path to the current game's directory (if any).
+     * 
+     * 
+     * @return current game data directory, or empty string if none set.
+     */
+    static std::string game_data_dir ()
+    {
+        return Game_data_dir; 
+    }
+
+    /** 
+     * Finds a file in the directories hierarchy, starting searching from
+     * game_data_dir(), then global_data_dir() and finally user_data_dir().
+     *
+     * If a matching file is found, the full absolute path is returned, else
+     * an empty string &quot;&quot; is returned. If the path was already absolute, it is
+     * returned immediatly.
+     * 
+     * @param fname name of the find to search for.
+     * 
+     * @return complete absolute path to the file if found, passed string if the given
+     *         path was already absolute, or &quot;&quot; if the file wasn't found.
+     */
+    static std::string find_file (const std::string &amp; fname);
+
+    /** 
+     * Finds a directory in the directories hierarchy, starting searching from
+     * game_data_dir(), then global_data_dir() and finally user_data_dir().
+     *
+     * If a matching directory is found, the full absolute path is returned, else
+     * an empty string &quot;&quot; is returned. If the path was already absolute, it is
+     * returned immediatly.
+     * 
+     * @param fname name of the find to search for.
+     * 
+     * @return complete absolute path to the directory if found, passed string if the given
+     *         path was already absolute, or &quot;&quot; if the directory wasn't found.
+     */
+    static std::string find_directory (const std::string &amp; dirname); 
+    
+private:
+    static bool directory_exist (const std::string &amp; dirname); 
+    static bool file_exist (const std::string &amp; fname); 
+};
+
+
+#endif // GAME_H__

Added: trunk/source/python/python_class.cpp
===================================================================
--- trunk/source/python/python_class.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/python_class.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,226 @@
+/*
+   $Id: python_class.cc,v 1.10 2003/02/20 21:03:11 ksterker Exp $
+
+   Copyright (C) 2001 Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+   Part of the Adonthell Project <A HREF="http://adonthell.linuxgames.com">http://adonthell.linuxgames.com</A>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+/**
+ * @file   python_class.cc
+ * @author Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+ * 
+ * @brief  Declares the python class.
+ * 
+ * 
+ */
+
+#include &quot;python_class.h&quot;
+#include &quot;game.h&quot;
+#include &lt;iostream&gt; 
+
+//using namespace std;
+
+PyObject * data::globals;
+PyObject * python::module;
+
+/*
+ * Start Python
+ */
+void python::init ()
+{
+    Py_Initialize ();
+}
+
+void python::cleanup () 
+{
+    // Cleanup the global namespace of python interpreter
+    // Note that we don't have to DECREF data::globals, because they're a
+    // borrowed reference of py_module.
+    Py_XDECREF (module);
+    Py_Finalize ();
+}
+
+/*
+ * Insert a string into the module search path.
+ */
+void python::insert_path( char *name )
+{
+    char buf[256];
+    
+    sprintf ( buf, &quot;import sys ; sys.path.insert(0, \&quot;%s\&quot;)&quot;, name );
+    PyRun_SimpleString ( buf );
+}
+
+/*
+ * Some convenience functions
+ */
+
+/*
+ * Executes the Python statements in the string
+ */
+void python::exec_string(char * s)
+{
+    PyRun_SimpleString(s);
+}
+
+/*
+ * Execute the file given by 'filename'
+ */
+bool python::exec_file (std::string filename)
+{
+    PyObject *mod = python::import_module (filename);
+ 
+    if (!mod)
+    {
+        std::cerr &lt;&lt; &quot;exec_file: &quot; &lt;&lt; filename &lt;&lt; &quot; load failed: &quot; &lt;&lt; std::endl;
+        show_traceback ();
+
+        return false;
+    }
+
+    Py_DECREF (mod); 
+
+    return true; 
+}
+
+/*
+ * Dump any error information to stderr
+ */
+void python::show_traceback(void)
+{
+    if ( PyErr_Occurred() )
+    {
+        PyErr_Print();
+        fflush (stderr);
+    }
+}
+
+/* Import a module, return module ptr */
+PyObject *python::import_module (std::string filename)
+{
+    PyObject *result = PyImport_ImportModule ((char *) filename.c_str ());
+    
+#ifdef PY_DEBUG
+    show_traceback ();
+#endif
+    return result;
+}
+
+// Make a C++ instance available to Python
+PyObject *python::pass_instance (void *instance, const char *class_name)
+{
+    char class_ptr[256];
+    char class_addr[256];
+    char *buffer = class_addr;
+
+    // Construct the python shadow class matching the &quot;instance&quot; class 
+    strcat (strcpy (class_ptr, class_name), &quot;Ptr&quot;);
+    
+    // Construct SWIG's representation of the &quot;instance&quot; pointer
+    *(buffer++) = '_';
+    buffer = ptr_to_string (buffer, &amp;instance, sizeof (void *));
+    strcpy (buffer, &quot;_p_&quot;);
+    strcpy (buffer+3, class_name);
+
+    // Now create the Python object corresponding to &quot;instance&quot;
+    PyObject *cls = PyDict_GetItemString (data::globals, class_ptr);
+    PyObject *arg = Py_BuildValue (&quot;(s)&quot;, class_addr);
+    PyObject *res = PyObject_CallObject (cls, arg);
+    
+#ifdef PY_DEBUG
+    show_traceback ();
+#endif
+
+    // Clean up
+    Py_DECREF (arg);
+    
+    // Voila: &quot;res&quot; is 'identical' to &quot;instance&quot; :)
+    return res;
+}
+
+// Convert a pointer to a string (like SWIG 1.3.7 does)
+char *python::ptr_to_string (char *c, void *ptr, int sz)
+{
+    static char hex[17] = &quot;0123456789abcdef&quot;;
+    int i;
+    unsigned char *u = (unsigned char *) ptr;
+    register unsigned char uu;
+
+    for (i = 0; i &lt; sz; i++,u++)
+    {
+        uu = *u;
+        *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
+        *(c++) = hex[uu &amp; 0xf];
+    }
+
+    return c;
+}
+
+PyObject * python::get_tuple (igzstream &amp; file)
+{
+    PyObject * tuple; 
+    u_int32 l;
+    l &lt;&lt; file;
+
+    tuple = PyTuple_New (l);
+
+    for (u_int32 i = 0; i &lt; l; i++) 
+    {
+        std::string ms;
+        u_int32 j;
+        char c;
+        
+        c &lt;&lt; file;
+        switch (c) 
+        {
+            case 's':
+                ms &lt;&lt; file;
+                // Stolen reference
+                PyTuple_SetItem (tuple, i, PyString_FromString (ms.c_str ()));
+                break;
+                
+            case 'i':
+                j &lt;&lt; file;
+                // Stolen reference
+                PyTuple_SetItem (tuple, i, PyInt_FromLong (j));
+                break; 
+        }
+    }
+    return tuple; 
+}
+
+void python::put_tuple (PyObject * tuple, ogzstream &amp; file)
+{
+    u_int32 l = PyTuple_Size (tuple);
+    l &gt;&gt; file;
+    for (u_int32 i = 0; i &lt; l; i++) 
+    {
+        // Borrowed reference
+        PyObject * item = PyTuple_GetItem (tuple, i);
+        
+        // Check for the type of this object
+        // String?
+        if (PyString_Check (item)) 
+        {
+            's' &gt;&gt; file;
+            char * s = PyString_AsString (item); 
+            std::string (s) &gt;&gt; file;
+        }
+        
+        // Integer?
+        else if (PyInt_Check (item)) 
+        {
+            'i' &gt;&gt; file;
+            u_int32 li = PyInt_AsLong (item); 
+            li &gt;&gt; file;
+        }
+    }
+}

Added: trunk/source/python/python_class.h
===================================================================
--- trunk/source/python/python_class.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/python_class.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,146 @@
+/*
+   $Id: python_class.h,v 1.9 2003/02/23 23:14:34 ksterker Exp $
+
+   Copyright (C) 2001 Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+   Part of the Adonthell Project <A HREF="http://adonthell.linuxgames.com">http://adonthell.linuxgames.com</A>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+/**
+ * @file   python_class.h
+ * @author Kai Sterker &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">kaisterker at linuxgames.com</A>&gt;
+ * 
+ * @brief  Defines the python class. This file is named this way
+ *         so it doesn't conflicts with Python.h Python's include
+ *         file on non-case aware systems.
+ * 
+ * 
+ */
+ 
+
+#ifndef PYTHON_CLASS_H__
+#define PYTHON_CLASS_H__
+
+#include &quot;Python.h&quot;
+#include &quot;compile.h&quot;
+#include &quot;eval.h&quot;
+#include &quot;node.h&quot;
+#include &quot;fileops.h&quot;
+
+/**
+ * Grant simplified access to the Python interpreter.
+ * 
+ */ 
+class python
+{  
+public:
+    /** 
+     * Initialise Python and insert the Adonthell include paths.
+     * 
+     * 
+     * @return true in case of success, false otherwise.
+     */
+    static void init ();
+
+    /**
+     * Cleanup Python.
+     * 
+     */ 
+    static void cleanup (); 
+
+    /** 
+     * Adds a directory to Python's include path.
+     * 
+     * @param name directory to add to Python's include path.
+     */
+    static void insert_path( char * name);
+    
+    /** 
+     * Execute Python statements contained in a string.
+     * 
+     * @param s string containing Python statements to execute.
+     */
+    static void exec_string(char * s);
+    
+    /** 
+     * Executes a Python script.
+     * 
+     * @param filename name of the file to execute.
+     * 
+     * @return true in case of success, false otherwise.
+     */ 
+    static bool exec_file (std::string filename);
+    
+    /** 
+     * Imports a Python module.
+     * 
+     * @param filename file name of the module to import.
+     * 
+     * @return pointer to the imported module.
+     */
+    static PyObject *import_module (std::string filename);
+    
+    /** 
+     * Dumps any error information to stderr.
+     * 
+     */
+    static void show_traceback( void );
+    
+    /** 
+     * Magic function that makes any C object available to Python!
+     * 
+     * @param instance pointer to the instance to pass.
+     * @param class_name name of the class of the passed instance.
+     * 
+     * @return pointer to the passed %object.
+     */
+    static PyObject *pass_instance (void* instance, const char* class_name);
+
+    /** 
+     * Loads a Python tuple previously saved with put_tuple ().
+     * 
+     * @param file Opened file where to load the tuple from.
+     * 
+     * @return Restored Python tuple.
+     */
+    static PyObject * get_tuple (igzstream &amp; file); 
+
+    /** 
+     * Save a Python tuple into a file.
+     *
+     * @warning The Python tuple MUST ONLY be composed of Python strings
+     * or integers!
+     * 
+     * @param tuple Python tuple to save.
+     * @param file Opened file where to save the tuple to.
+     */
+    static void put_tuple (PyObject * tuple, ogzstream &amp; file);  
+
+    static PyObject *module;
+private:
+    /**
+     * Convert a Pointer to a String, like SWIG 1.3.7+ does
+     *
+     */
+    static char *python::ptr_to_string (char *c, void *ptr, int sz);
+};
+
+#ifndef SWIG
+namespace data
+{
+    /**
+     * Global namespace to use in scripts.
+     * 
+     */ 
+    extern PyObject *globals;
+}
+#endif
+
+#endif // PYTHON_CLASS_H__

Added: trunk/source/python/types.h
===================================================================
--- trunk/source/python/types.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/types.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,55 @@
+// $Id: types.h,v 1.16 2002/04/25 15:34:11 gnurou Exp $
+/*
+   Copyright (C) 1999/2000/2001 Alexandre Courbot.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+   See the COPYING file for more details.
+
+ */
+
+
+/** @file types.h
+ *  @author Alexandre Courbot &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">alexandrecourbot at linuxgames.com</A>&gt;
+ *  @brief Declares some basic types.
+ */ 
+
+ 
+#ifndef TYPES_H__
+#define TYPES_H__
+
+#include &quot;SDL.h&quot;
+
+// We should put ifdefs here to put the correct int values accordingly to the system type
+
+
+/// 8 bits long unsigned integer
+#define u_int8 unsigned char
+
+/// 16 bits long unsigned integer
+#define u_int16 unsigned short
+
+/// 32 bits long unsigned integer
+#define u_int32 unsigned int
+
+/// 8 bits long signed integer
+#define s_int8 signed char
+
+/// 16 bits long signed integer
+#define s_int16 signed short
+
+/// 32 bits long signed integer
+#define s_int32 signed int
+
+
+/* 
+typedef Uint8 u_int8;
+typedef Uint16 u_int16;
+typedef Uint32 u_int32;
+typedef Sint8 s_int8;
+typedef Sint16 s_int16;
+typedef Sint32 s_int32;
+*/ 
+#endif

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/scp.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -36,13 +36,17 @@
 
 #include &quot;tests/testmain.h&quot;
 
-#include &lt;xsltwrapp/xsltwrapp.h&gt;
-
 // standard includes
 #include &lt;iostream&gt;
 #include &lt;exception&gt;
-#include &quot;xslt/twexslt.h&quot;
 
+
+
+extern &quot;C&quot;
+{
+  void init_ggob(void);
+}
+
 #ifdef ALLEGRO_MSVC
 #pragma warning (disable:4786)
 #endif
@@ -69,6 +73,8 @@
 #include &quot;melee/mfleet.h&quot;
 
 
+#include &lt;Python.h&gt;
+#include &quot;python/python_class.h&quot;
 
 
 DATAFILE* g_game_data = NULL;
@@ -104,6 +110,7 @@
   f = pack_fopen (data_full_path(&quot;version.txt&quot;).c_str(), F_READ);
   if (!f)
     {
+      return &quot;Unknown&quot;;
       tw_error(&quot;Unable to retrive version information&quot;);
     }
   else 
@@ -787,9 +794,10 @@
       return RunTests();
     }
   
-  // prepare the XSLT engine and XML parser
-  xslt::init init;
-  exsltTW_LIGHTRegister();
+  python::init();  
+  python::insert_path(DATAFILE_PATH&quot;/python&quot;);
+  init_ggob();
+  python::module = python::import_module(&quot;ggob&quot;);
 
   int i;
   int auto_port = -1;
@@ -1042,6 +1050,7 @@
     if (__error_flag &amp; 1) throw;
   }
   
+  python::cleanup();  
   tw_exit(0);
   return 0;
 }

Modified: trunk/source/util/vector2.h
===================================================================
--- trunk/source/util/vector2.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/util/vector2.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -45,11 +45,11 @@
 	Vector2 rotate(double angle) const ;
 };
 
-inline Vector2 operator+ (Vector2 a, Vector2 b) { return Vector2(a.x+b.x,a.y+b.y); }
-inline Vector2 operator- (Vector2 a, Vector2 b) { return Vector2(a.x-b.x,a.y-b.y); }
-inline Vector2 operator* (Vector2 a, double b) { return Vector2(a.x*b,a.y*b); }
-inline Vector2 operator* (double b, Vector2 a) { return Vector2(a.x*b,a.y*b); }
-inline Vector2 operator/ (Vector2 a, double b) { double c = 1/b; return Vector2(a.x*c,a.y*c); }
+inline Vector2 operator+ (const Vector2&amp; a, const Vector2&amp; b) { return Vector2(a.x+b.x,a.y+b.y); }
+inline Vector2 operator- (const Vector2&amp; a, const Vector2&amp; b) { return Vector2(a.x-b.x,a.y-b.y); }
+inline Vector2 operator* (const Vector2&amp; a, const double&amp; b) { return Vector2(a.x*b,a.y*b); }
+inline Vector2 operator* (const double&amp; b, const Vector2&amp; a) { return Vector2(a.x*b,a.y*b); }
+inline Vector2 operator/ (const Vector2&amp; a, const double&amp; b) { double c = 1/b; return Vector2(a.x*c,a.y*c); }
 
 inline double magnitude_sqr ( Vector2 vect ) { return (vect.x*vect.x+vect.y*vect.y); }
 //returns the square of the magnitude of vect (fast)

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/sources.lst	2005-03-12 19:12:58 UTC (rev 136)
@@ -98,6 +98,7 @@
 source/libraries/jpgalleg/jpgalleg.c
 source/scp.cpp
 source/doxygen.cpp
+source/generated/ggob_wrap.cpp
 source/input.cpp
 source/sc1ships/shpearcr.cpp
 source/sc1ships/shpchebr.cpp
@@ -125,4 +126,6 @@
 source/sc2ships/shpslypr.cpp
 source/sc2ships/shpzfpst.cpp
 source/gui.cpp
-source/xslt/twexslt.cpp
+source/python/game.cpp
+source/python/python_class.cpp
+source/python/fileops.cpp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000081.html">[Tw-light-svn] r135 - in trunk: . gamedata/xml/GOB source source/games source/melee source/other
</A></li>
	<LI>Next message: <A HREF="000083.html">[Tw-light-svn] r137 - trunk/source/games
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#82">[ date ]</a>
              <a href="thread.html#82">[ thread ]</a>
              <a href="subject.html#82">[ subject ]</a>
              <a href="author.html#82">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
