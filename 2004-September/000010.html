<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r62 - in trunk: Util Util/deditor Util/deditor/lua Util/deditor/lua/lib web
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2004-September/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r62%20-%20in%20trunk%3A%20Util%20Util/deditor%20Util/deditor/lua%20Util/deditor/lua/lib%20web&In-Reply-To=%3C200409251633.i8PGXPfp009710%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000009.html">
   <LINK REL="Next"  HREF="000011.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r62 - in trunk: Util Util/deditor Util/deditor/lua Util/deditor/lua/lib web</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r62%20-%20in%20trunk%3A%20Util%20Util/deditor%20Util/deditor/lua%20Util/deditor/lua/lib%20web&In-Reply-To=%3C200409251633.i8PGXPfp009710%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r62 - in trunk: Util Util/deditor Util/deditor/lua Util/deditor/lua/lib web">yurand at sheep.berlios.de
       </A><BR>
    <I>Sat Sep 25 18:33:25 CEST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000009.html">[Tw-light-svn] r61 - in trunk: gamedata/default_ini/ships gamedata/ships source source/ais source/melee
</A></li>
        <LI>Next message: <A HREF="000011.html">[Tw-light-svn] r63 - in trunk/source: . melee other sc1ships sc2ships ships util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10">[ date ]</a>
              <a href="thread.html#10">[ thread ]</a>
              <a href="subject.html#10">[ subject ]</a>
              <a href="author.html#10">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2004-09-25 18:33:16 +0200 (Sat, 25 Sep 2004)
New Revision: 62

Added:
   trunk/Util/deditor/
   trunk/Util/deditor/MainDialog.ui
   trunk/Util/deditor/addplayeranswer.xpm
   trunk/Util/deditor/application.cpp
   trunk/Util/deditor/application.h
   trunk/Util/deditor/book.png
   trunk/Util/deditor/createnode.xpm
   trunk/Util/deditor/dialog.xml
   trunk/Util/deditor/dialogeditor.dsp
   trunk/Util/deditor/dialogeditor.dsw
   trunk/Util/deditor/dialogeditor.ncb
   trunk/Util/deditor/dialogeditor.opt
   trunk/Util/deditor/dialogeditor.plg
   trunk/Util/deditor/dialogeditor.sln
   trunk/Util/deditor/dialogeditor.suo
   trunk/Util/deditor/dialogeditor.vcproj
   trunk/Util/deditor/evalanswer.xpm
   trunk/Util/deditor/fileopen.xpm
   trunk/Util/deditor/filesave.xpm
   trunk/Util/deditor/gui.bat
   trunk/Util/deditor/helpers.cpp
   trunk/Util/deditor/helpers.h
   trunk/Util/deditor/itemdown.xpm
   trunk/Util/deditor/itemup.xpm
   trunk/Util/deditor/lua/
   trunk/Util/deditor/lua/Makefile
   trunk/Util/deditor/lua/README
   trunk/Util/deditor/lua/lapi.c
   trunk/Util/deditor/lua/lapi.h
   trunk/Util/deditor/lua/lauxlib.h
   trunk/Util/deditor/lua/lcode.c
   trunk/Util/deditor/lua/lcode.h
   trunk/Util/deditor/lua/ldebug.c
   trunk/Util/deditor/lua/ldebug.h
   trunk/Util/deditor/lua/ldo.c
   trunk/Util/deditor/lua/ldo.h
   trunk/Util/deditor/lua/ldump.c
   trunk/Util/deditor/lua/lfunc.c
   trunk/Util/deditor/lua/lfunc.h
   trunk/Util/deditor/lua/lgc.c
   trunk/Util/deditor/lua/lgc.h
   trunk/Util/deditor/lua/lib/
   trunk/Util/deditor/lua/lib/Makefile
   trunk/Util/deditor/lua/lib/README
   trunk/Util/deditor/lua/lib/lauxlib.c
   trunk/Util/deditor/lua/lib/lbaselib.c
   trunk/Util/deditor/lua/lib/ldblib.c
   trunk/Util/deditor/lua/lib/liolib.c
   trunk/Util/deditor/lua/lib/lmathlib.c
   trunk/Util/deditor/lua/lib/loadlib.c
   trunk/Util/deditor/lua/lib/lstrlib.c
   trunk/Util/deditor/lua/lib/ltablib.c
   trunk/Util/deditor/lua/llex.c
   trunk/Util/deditor/lua/llex.h
   trunk/Util/deditor/lua/llimits.h
   trunk/Util/deditor/lua/lmem.c
   trunk/Util/deditor/lua/lmem.h
   trunk/Util/deditor/lua/lobject.c
   trunk/Util/deditor/lua/lobject.h
   trunk/Util/deditor/lua/lopcodes.c
   trunk/Util/deditor/lua/lopcodes.h
   trunk/Util/deditor/lua/lparser.c
   trunk/Util/deditor/lua/lparser.h
   trunk/Util/deditor/lua/lstate.c
   trunk/Util/deditor/lua/lstate.h
   trunk/Util/deditor/lua/lstring.c
   trunk/Util/deditor/lua/lstring.h
   trunk/Util/deditor/lua/ltable.c
   trunk/Util/deditor/lua/ltable.h
   trunk/Util/deditor/lua/ltests.c
   trunk/Util/deditor/lua/ltm.c
   trunk/Util/deditor/lua/ltm.h
   trunk/Util/deditor/lua/lua.h
   trunk/Util/deditor/lua/lualib.h
   trunk/Util/deditor/lua/lundump.c
   trunk/Util/deditor/lua/lundump.h
   trunk/Util/deditor/lua/lvm.c
   trunk/Util/deditor/lua/lvm.h
   trunk/Util/deditor/lua/lzio.c
   trunk/Util/deditor/lua/lzio.h
   trunk/Util/deditor/main.cpp
   trunk/Util/deditor/maindialog.cpp
   trunk/Util/deditor/maindialog.h
   trunk/Util/deditor/mainwidget.cpp
   trunk/Util/deditor/mainwidget.h
   trunk/Util/deditor/moc_application.cpp
   trunk/Util/deditor/moc_maindialog.cpp
   trunk/Util/deditor/moc_node.cpp
   trunk/Util/deditor/node.cpp
   trunk/Util/deditor/node.h
   trunk/Util/deditor/removenode.xpm
   trunk/Util/deditor/rmplayeranswer.xpm
   trunk/Util/deditor/setalientext.xpm
   trunk/Util/deditor/setplayeranswertext.xpm
   trunk/Util/deditor/xmlparser.cpp
   trunk/Util/deditor/xmlparser.h
   trunk/web/3dlogo.jpg
   trunk/web/background.jpg
   trunk/web/dialog-editor-win32-62.zip
   trunk/web/downloads.html
   trunk/web/info.html
   trunk/web/links.html
   trunk/web/team.html
Removed:
   trunk/web/logo.png
Modified:
   trunk/web/index.html
   trunk/web/update.sh
Log:
Dialog Editor added to SVN tree
New web site added to SVN tree


Added: trunk/Util/deditor/MainDialog.ui
===================================================================
--- trunk/Util/deditor/MainDialog.ui	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/MainDialog.ui	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,1076 @@
+&lt;!DOCTYPE UI&gt;&lt;UI&gt;
+&lt;class&gt;DialogEditorGenerated&lt;/class&gt;
+&lt;widget&gt;
+    &lt;class&gt;QWidget&lt;/class&gt;
+    &lt;property stdset=&quot;1&quot;&gt;
+        &lt;name&gt;name&lt;/name&gt;
+        &lt;cstring&gt;DialogEditorGenerated&lt;/cstring&gt;
+    &lt;/property&gt;
+    &lt;property stdset=&quot;1&quot;&gt;
+        &lt;name&gt;geometry&lt;/name&gt;
+        &lt;rect&gt;
+            &lt;x&gt;0&lt;/x&gt;
+            &lt;y&gt;0&lt;/y&gt;
+            &lt;width&gt;785&lt;/width&gt;
+            &lt;height&gt;452&lt;/height&gt;
+        &lt;/rect&gt;
+    &lt;/property&gt;
+    &lt;property stdset=&quot;1&quot;&gt;
+        &lt;name&gt;caption&lt;/name&gt;
+        &lt;string&gt;Form1&lt;/string&gt;
+    &lt;/property&gt;
+    &lt;grid&gt;
+        &lt;property stdset=&quot;1&quot;&gt;
+            &lt;name&gt;margin&lt;/name&gt;
+            &lt;number&gt;11&lt;/number&gt;
+        &lt;/property&gt;
+        &lt;property stdset=&quot;1&quot;&gt;
+            &lt;name&gt;spacing&lt;/name&gt;
+            &lt;number&gt;6&lt;/number&gt;
+        &lt;/property&gt;
+        &lt;widget row=&quot;0&quot;  column=&quot;0&quot; &gt;
+            &lt;class&gt;QLayoutWidget&lt;/class&gt;
+            &lt;property stdset=&quot;1&quot;&gt;
+                &lt;name&gt;name&lt;/name&gt;
+                &lt;cstring&gt;Layout17&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;grid&gt;
+                &lt;property stdset=&quot;1&quot;&gt;
+                    &lt;name&gt;margin&lt;/name&gt;
+                    &lt;number&gt;0&lt;/number&gt;
+                &lt;/property&gt;
+                &lt;property stdset=&quot;1&quot;&gt;
+                    &lt;name&gt;spacing&lt;/name&gt;
+                    &lt;number&gt;6&lt;/number&gt;
+                &lt;/property&gt;
+                &lt;widget row=&quot;0&quot;  column=&quot;2&quot; &gt;
+                    &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                    &lt;property stdset=&quot;1&quot;&gt;
+                        &lt;name&gt;name&lt;/name&gt;
+                        &lt;cstring&gt;Layout19&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;vbox&gt;
+                        &lt;property stdset=&quot;1&quot;&gt;
+                            &lt;name&gt;margin&lt;/name&gt;
+                            &lt;number&gt;0&lt;/number&gt;
+                        &lt;/property&gt;
+                        &lt;property stdset=&quot;1&quot;&gt;
+                            &lt;name&gt;spacing&lt;/name&gt;
+                            &lt;number&gt;6&lt;/number&gt;
+                        &lt;/property&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;Layout18&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;hbox&gt;
+                                &lt;property stdset=&quot;1&quot;&gt;
+                                    &lt;name&gt;margin&lt;/name&gt;
+                                    &lt;number&gt;0&lt;/number&gt;
+                                &lt;/property&gt;
+                                &lt;property stdset=&quot;1&quot;&gt;
+                                    &lt;name&gt;spacing&lt;/name&gt;
+                                    &lt;number&gt;6&lt;/number&gt;
+                                &lt;/property&gt;
+                                &lt;widget&gt;
+                                    &lt;class&gt;QLabel&lt;/class&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;name&lt;/name&gt;
+                                        &lt;cstring&gt;TextLabel3&lt;/cstring&gt;
+                                    &lt;/property&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;text&lt;/name&gt;
+                                        &lt;string&gt;Triggers:&lt;/string&gt;
+                                    &lt;/property&gt;
+                                &lt;/widget&gt;
+                                &lt;widget&gt;
+                                    &lt;class&gt;QLabel&lt;/class&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;name&lt;/name&gt;
+                                        &lt;cstring&gt;TextLabel12&lt;/cstring&gt;
+                                    &lt;/property&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;text&lt;/name&gt;
+                                        &lt;string&gt;Name&lt;/string&gt;
+                                    &lt;/property&gt;
+                                &lt;/widget&gt;
+                                &lt;widget&gt;
+                                    &lt;class&gt;QLabel&lt;/class&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;name&lt;/name&gt;
+                                        &lt;cstring&gt;TextLabel13&lt;/cstring&gt;
+                                    &lt;/property&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;text&lt;/name&gt;
+                                        &lt;string&gt;Value&lt;/string&gt;
+                                    &lt;/property&gt;
+                                &lt;/widget&gt;
+                            &lt;/hbox&gt;
+                        &lt;/widget&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QTable&lt;/class&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;triggerTable&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;maximumSize&lt;/name&gt;
+                                &lt;size&gt;
+                                    &lt;width&gt;200&lt;/width&gt;
+                                    &lt;height&gt;32767&lt;/height&gt;
+                                &lt;/size&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;numRows&lt;/name&gt;
+                                &lt;number&gt;6&lt;/number&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;numCols&lt;/name&gt;
+                                &lt;number&gt;6&lt;/number&gt;
+                            &lt;/property&gt;
+                            &lt;property&gt;
+                                &lt;name&gt;whatsThis&lt;/name&gt;
+                                &lt;string&gt;First column - trigger name, second - value&lt;/string&gt;
+                            &lt;/property&gt;
+                        &lt;/widget&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QListView&lt;/class&gt;
+                            &lt;column&gt;
+                                &lt;property&gt;
+                                    &lt;name&gt;text&lt;/name&gt;
+                                    &lt;string&gt;ID&lt;/string&gt;
+                                &lt;/property&gt;
+                                &lt;property&gt;
+                                    &lt;name&gt;clickable&lt;/name&gt;
+                                    &lt;bool&gt;true&lt;/bool&gt;
+                                &lt;/property&gt;
+                                &lt;property&gt;
+                                    &lt;name&gt;resizeable&lt;/name&gt;
+                                    &lt;bool&gt;true&lt;/bool&gt;
+                                &lt;/property&gt;
+                            &lt;/column&gt;
+                            &lt;column&gt;
+                                &lt;property&gt;
+                                    &lt;name&gt;text&lt;/name&gt;
+                                    &lt;string&gt;Name&lt;/string&gt;
+                                &lt;/property&gt;
+                                &lt;property&gt;
+                                    &lt;name&gt;clickable&lt;/name&gt;
+                                    &lt;bool&gt;true&lt;/bool&gt;
+                                &lt;/property&gt;
+                                &lt;property&gt;
+                                    &lt;name&gt;resizeable&lt;/name&gt;
+                                    &lt;bool&gt;true&lt;/bool&gt;
+                                &lt;/property&gt;
+                            &lt;/column&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;nodeListView&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;sizePolicy&lt;/name&gt;
+                                &lt;sizepolicy&gt;
+                                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
+                                    &lt;vsizetype&gt;5&lt;/vsizetype&gt;
+                                &lt;/sizepolicy&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;maximumSize&lt;/name&gt;
+                                &lt;size&gt;
+                                    &lt;width&gt;200&lt;/width&gt;
+                                    &lt;height&gt;32767&lt;/height&gt;
+                                &lt;/size&gt;
+                            &lt;/property&gt;
+                            &lt;property&gt;
+                                &lt;name&gt;whatsThis&lt;/name&gt;
+                                &lt;string&gt;Browse nodes from here&lt;/string&gt;
+                            &lt;/property&gt;
+                        &lt;/widget&gt;
+                    &lt;/vbox&gt;
+                &lt;/widget&gt;
+                &lt;widget row=&quot;0&quot;  column=&quot;0&quot; &gt;
+                    &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                    &lt;property stdset=&quot;1&quot;&gt;
+                        &lt;name&gt;name&lt;/name&gt;
+                        &lt;cstring&gt;Layout20&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;vbox&gt;
+                        &lt;property stdset=&quot;1&quot;&gt;
+                            &lt;name&gt;margin&lt;/name&gt;
+                            &lt;number&gt;0&lt;/number&gt;
+                        &lt;/property&gt;
+                        &lt;property stdset=&quot;1&quot;&gt;
+                            &lt;name&gt;spacing&lt;/name&gt;
+                            &lt;number&gt;6&lt;/number&gt;
+                        &lt;/property&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QTextBrowser&lt;/class&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;alienTextBrowser&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;sizePolicy&lt;/name&gt;
+                                &lt;sizepolicy&gt;
+                                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
+                                    &lt;vsizetype&gt;7&lt;/vsizetype&gt;
+                                &lt;/sizepolicy&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;minimumSize&lt;/name&gt;
+                                &lt;size&gt;
+                                    &lt;width&gt;200&lt;/width&gt;
+                                    &lt;height&gt;200&lt;/height&gt;
+                                &lt;/size&gt;
+                            &lt;/property&gt;
+                            &lt;property&gt;
+                                &lt;name&gt;whatsThis&lt;/name&gt;
+                                &lt;string&gt;Alian picture, and text here&lt;/string&gt;
+                            &lt;/property&gt;
+                        &lt;/widget&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QLabel&lt;/class&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;TextLabel4&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;text&lt;/name&gt;
+                                &lt;string&gt;Place text here:&lt;/string&gt;
+                            &lt;/property&gt;
+                        &lt;/widget&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QMultiLineEdit&lt;/class&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;commonMultiLineEdit&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;minimumSize&lt;/name&gt;
+                                &lt;size&gt;
+                                    &lt;width&gt;0&lt;/width&gt;
+                                    &lt;height&gt;90&lt;/height&gt;
+                                &lt;/size&gt;
+                            &lt;/property&gt;
+                            &lt;property&gt;
+                                &lt;name&gt;whatsThis&lt;/name&gt;
+                                &lt;string&gt;Text in this edit can be set aso player or alian answer.&lt;/string&gt;
+                            &lt;/property&gt;
+                        &lt;/widget&gt;
+                    &lt;/vbox&gt;
+                &lt;/widget&gt;
+                &lt;widget row=&quot;1&quot;  column=&quot;0&quot;  rowspan=&quot;1&quot;  colspan=&quot;3&quot; &gt;
+                    &lt;class&gt;QListView&lt;/class&gt;
+                    &lt;column&gt;
+                        &lt;property&gt;
+                            &lt;name&gt;text&lt;/name&gt;
+                            &lt;string&gt;Player answers&lt;/string&gt;
+                        &lt;/property&gt;
+                        &lt;property&gt;
+                            &lt;name&gt;clickable&lt;/name&gt;
+                            &lt;bool&gt;true&lt;/bool&gt;
+                        &lt;/property&gt;
+                        &lt;property&gt;
+                            &lt;name&gt;resizeable&lt;/name&gt;
+                            &lt;bool&gt;true&lt;/bool&gt;
+                        &lt;/property&gt;
+                    &lt;/column&gt;
+                    &lt;property stdset=&quot;1&quot;&gt;
+                        &lt;name&gt;name&lt;/name&gt;
+                        &lt;cstring&gt;answersListView&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property&gt;
+                        &lt;name&gt;whatsThis&lt;/name&gt;
+                        &lt;string&gt;Player Answers&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget row=&quot;0&quot;  column=&quot;1&quot; &gt;
+                    &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                    &lt;property stdset=&quot;1&quot;&gt;
+                        &lt;name&gt;name&lt;/name&gt;
+                        &lt;cstring&gt;Layout14&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;vbox&gt;
+                        &lt;property stdset=&quot;1&quot;&gt;
+                            &lt;name&gt;margin&lt;/name&gt;
+                            &lt;number&gt;0&lt;/number&gt;
+                        &lt;/property&gt;
+                        &lt;property stdset=&quot;1&quot;&gt;
+                            &lt;name&gt;spacing&lt;/name&gt;
+                            &lt;number&gt;6&lt;/number&gt;
+                        &lt;/property&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QCheckBox&lt;/class&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;TestModeCheckBox&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;text&lt;/name&gt;
+                                &lt;string&gt;Test Mode (Hide not allowed answers)&lt;/string&gt;
+                            &lt;/property&gt;
+                        &lt;/widget&gt;
+                        &lt;widget&gt;
+                            &lt;class&gt;QTabWidget&lt;/class&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;name&lt;/name&gt;
+                                &lt;cstring&gt;TabWidget2&lt;/cstring&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;sizePolicy&lt;/name&gt;
+                                &lt;sizepolicy&gt;
+                                    &lt;hsizetype&gt;4&lt;/hsizetype&gt;
+                                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
+                                &lt;/sizepolicy&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;minimumSize&lt;/name&gt;
+                                &lt;size&gt;
+                                    &lt;width&gt;200&lt;/width&gt;
+                                    &lt;height&gt;250&lt;/height&gt;
+                                &lt;/size&gt;
+                            &lt;/property&gt;
+                            &lt;property stdset=&quot;1&quot;&gt;
+                                &lt;name&gt;margin&lt;/name&gt;
+                                &lt;number&gt;0&lt;/number&gt;
+                            &lt;/property&gt;
+                            &lt;widget&gt;
+                                &lt;class&gt;QWidget&lt;/class&gt;
+                                &lt;property stdset=&quot;1&quot;&gt;
+                                    &lt;name&gt;name&lt;/name&gt;
+                                    &lt;cstring&gt;tab&lt;/cstring&gt;
+                                &lt;/property&gt;
+                                &lt;attribute&gt;
+                                    &lt;name&gt;title&lt;/name&gt;
+                                    &lt;string&gt;Node&lt;/string&gt;
+                                &lt;/attribute&gt;
+                                &lt;grid&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;margin&lt;/name&gt;
+                                        &lt;number&gt;11&lt;/number&gt;
+                                    &lt;/property&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;spacing&lt;/name&gt;
+                                        &lt;number&gt;6&lt;/number&gt;
+                                    &lt;/property&gt;
+                                    &lt;widget row=&quot;0&quot;  column=&quot;0&quot; &gt;
+                                        &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                        &lt;property stdset=&quot;1&quot;&gt;
+                                            &lt;name&gt;name&lt;/name&gt;
+                                            &lt;cstring&gt;Layout15&lt;/cstring&gt;
+                                        &lt;/property&gt;
+                                        &lt;grid&gt;
+                                            &lt;property stdset=&quot;1&quot;&gt;
+                                                &lt;name&gt;margin&lt;/name&gt;
+                                                &lt;number&gt;0&lt;/number&gt;
+                                            &lt;/property&gt;
+                                            &lt;property stdset=&quot;1&quot;&gt;
+                                                &lt;name&gt;spacing&lt;/name&gt;
+                                                &lt;number&gt;6&lt;/number&gt;
+                                            &lt;/property&gt;
+                                            &lt;widget row=&quot;5&quot;  column=&quot;1&quot;  rowspan=&quot;1&quot;  colspan=&quot;2&quot; &gt;
+                                                &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;textLocationLineEdit&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;alignment&lt;/name&gt;
+                                                    &lt;set&gt;AlignLeft&lt;/set&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;hAlign&lt;/name&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Alien text location&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;1&quot;  column=&quot;1&quot;  rowspan=&quot;1&quot;  colspan=&quot;2&quot; &gt;
+                                                &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;NodeNameLineEdit&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;alignment&lt;/name&gt;
+                                                    &lt;set&gt;AlignLeft&lt;/set&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;hAlign&lt;/name&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Name is not used&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;4&quot;  column=&quot;0&quot; &gt;
+                                                &lt;class&gt;QLabel&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;TextLabel1_3&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;text&lt;/name&gt;
+                                                    &lt;string&gt;Font:&lt;/string&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Alien text font&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;4&quot;  column=&quot;1&quot;  rowspan=&quot;1&quot;  colspan=&quot;2&quot; &gt;
+                                                &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;fontLineEdit&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;alignment&lt;/name&gt;
+                                                    &lt;set&gt;AlignLeft&lt;/set&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;hAlign&lt;/name&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Alien text font&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;2&quot;  column=&quot;0&quot; &gt;
+                                                &lt;class&gt;QLabel&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;TextLabel3_2&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;text&lt;/name&gt;
+                                                    &lt;string&gt;Music&lt;/string&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Path to music file&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;0&quot;  column=&quot;0&quot; &gt;
+                                                &lt;class&gt;QLabel&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;TextLabel1&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;text&lt;/name&gt;
+                                                    &lt;string&gt;Node ID&lt;/string&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;unique identifier for node&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;5&quot;  column=&quot;0&quot; &gt;
+                                                &lt;class&gt;QLabel&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;TextLabel2_3&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;text&lt;/name&gt;
+                                                    &lt;string&gt;Text location:&lt;/string&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Alien text location&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;3&quot;  column=&quot;0&quot; &gt;
+                                                &lt;class&gt;QLabel&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;TextLabel4_2&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;text&lt;/name&gt;
+                                                    &lt;string&gt;Background&lt;/string&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Path to background picture&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;spacer row=&quot;0&quot;  column=&quot;1&quot; &gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;Spacer1&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;orientation&lt;/name&gt;
+                                                    &lt;enum&gt;Horizontal&lt;/enum&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;sizeType&lt;/name&gt;
+                                                    &lt;enum&gt;Expanding&lt;/enum&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;sizeHint&lt;/name&gt;
+                                                    &lt;size&gt;
+                                                        &lt;width&gt;20&lt;/width&gt;
+                                                        &lt;height&gt;20&lt;/height&gt;
+                                                    &lt;/size&gt;
+                                                &lt;/property&gt;
+                                            &lt;/spacer&gt;
+                                            &lt;widget row=&quot;2&quot;  column=&quot;1&quot;  rowspan=&quot;1&quot;  colspan=&quot;2&quot; &gt;
+                                                &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;MusicEdit&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;alignment&lt;/name&gt;
+                                                    &lt;set&gt;AlignLeft&lt;/set&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;hAlign&lt;/name&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Path to music file&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;3&quot;  column=&quot;1&quot;  rowspan=&quot;1&quot;  colspan=&quot;2&quot; &gt;
+                                                &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;BackgroundLineEdit&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;alignment&lt;/name&gt;
+                                                    &lt;set&gt;AlignLeft&lt;/set&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;hAlign&lt;/name&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Path to background picture&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;1&quot;  column=&quot;0&quot; &gt;
+                                                &lt;class&gt;QLabel&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;TextLabel2&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;text&lt;/name&gt;
+                                                    &lt;string&gt;Node Name&lt;/string&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;Name is not used&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget row=&quot;0&quot;  column=&quot;2&quot; &gt;
+                                                &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;nodeIdLineEdit&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;alignment&lt;/name&gt;
+                                                    &lt;set&gt;AlignRight&lt;/set&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;hAlign&lt;/name&gt;
+                                                &lt;/property&gt;
+                                                &lt;property&gt;
+                                                    &lt;name&gt;whatsThis&lt;/name&gt;
+                                                    &lt;string&gt;unique identifier for node&lt;/string&gt;
+                                                &lt;/property&gt;
+                                            &lt;/widget&gt;
+                                        &lt;/grid&gt;
+                                    &lt;/widget&gt;
+                                &lt;/grid&gt;
+                            &lt;/widget&gt;
+                            &lt;widget&gt;
+                                &lt;class&gt;QWidget&lt;/class&gt;
+                                &lt;property stdset=&quot;1&quot;&gt;
+                                    &lt;name&gt;name&lt;/name&gt;
+                                    &lt;cstring&gt;tab&lt;/cstring&gt;
+                                &lt;/property&gt;
+                                &lt;attribute&gt;
+                                    &lt;name&gt;title&lt;/name&gt;
+                                    &lt;string&gt;Answer&lt;/string&gt;
+                                &lt;/attribute&gt;
+                                &lt;vbox&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;margin&lt;/name&gt;
+                                        &lt;number&gt;11&lt;/number&gt;
+                                    &lt;/property&gt;
+                                    &lt;property stdset=&quot;1&quot;&gt;
+                                        &lt;name&gt;spacing&lt;/name&gt;
+                                        &lt;number&gt;6&lt;/number&gt;
+                                    &lt;/property&gt;
+                                    &lt;widget&gt;
+                                        &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                        &lt;property stdset=&quot;1&quot;&gt;
+                                            &lt;name&gt;name&lt;/name&gt;
+                                            &lt;cstring&gt;Layout12&lt;/cstring&gt;
+                                        &lt;/property&gt;
+                                        &lt;vbox&gt;
+                                            &lt;property stdset=&quot;1&quot;&gt;
+                                                &lt;name&gt;margin&lt;/name&gt;
+                                                &lt;number&gt;0&lt;/number&gt;
+                                            &lt;/property&gt;
+                                            &lt;property stdset=&quot;1&quot;&gt;
+                                                &lt;name&gt;spacing&lt;/name&gt;
+                                                &lt;number&gt;6&lt;/number&gt;
+                                            &lt;/property&gt;
+                                            &lt;widget&gt;
+                                                &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;Layout11&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;hbox&gt;
+                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                        &lt;name&gt;margin&lt;/name&gt;
+                                                        &lt;number&gt;0&lt;/number&gt;
+                                                    &lt;/property&gt;
+                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                        &lt;name&gt;spacing&lt;/name&gt;
+                                                        &lt;number&gt;6&lt;/number&gt;
+                                                    &lt;/property&gt;
+                                                    &lt;widget&gt;
+                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                            &lt;name&gt;name&lt;/name&gt;
+                                                            &lt;cstring&gt;TextLabel1_2&lt;/cstring&gt;
+                                                        &lt;/property&gt;
+                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                            &lt;name&gt;text&lt;/name&gt;
+                                                            &lt;string&gt;Appear condition:&lt;/string&gt;
+                                                        &lt;/property&gt;
+                                                    &lt;/widget&gt;
+                                                    &lt;widget&gt;
+                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                            &lt;name&gt;name&lt;/name&gt;
+                                                            &lt;cstring&gt;appearConditionLineEdit&lt;/cstring&gt;
+                                                        &lt;/property&gt;
+                                                        &lt;property&gt;
+                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                            &lt;string&gt;Answer will not show, if doesn.t match&lt;/string&gt;
+                                                        &lt;/property&gt;
+                                                    &lt;/widget&gt;
+                                                &lt;/hbox&gt;
+                                            &lt;/widget&gt;
+                                            &lt;widget&gt;
+                                                &lt;class&gt;QGroupBox&lt;/class&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;name&lt;/name&gt;
+                                                    &lt;cstring&gt;GroupBox1&lt;/cstring&gt;
+                                                &lt;/property&gt;
+                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                    &lt;name&gt;title&lt;/name&gt;
+                                                    &lt;string&gt;Actions&lt;/string&gt;
+                                                &lt;/property&gt;
+                                                &lt;hbox&gt;
+                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                        &lt;name&gt;margin&lt;/name&gt;
+                                                        &lt;number&gt;11&lt;/number&gt;
+                                                    &lt;/property&gt;
+                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                        &lt;name&gt;spacing&lt;/name&gt;
+                                                        &lt;number&gt;6&lt;/number&gt;
+                                                    &lt;/property&gt;
+                                                    &lt;widget&gt;
+                                                        &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                            &lt;name&gt;name&lt;/name&gt;
+                                                            &lt;cstring&gt;Layout10&lt;/cstring&gt;
+                                                        &lt;/property&gt;
+                                                        &lt;vbox&gt;
+                                                            &lt;property stdset=&quot;1&quot;&gt;
+                                                                &lt;name&gt;margin&lt;/name&gt;
+                                                                &lt;number&gt;0&lt;/number&gt;
+                                                            &lt;/property&gt;
+                                                            &lt;property stdset=&quot;1&quot;&gt;
+                                                                &lt;name&gt;spacing&lt;/name&gt;
+                                                                &lt;number&gt;6&lt;/number&gt;
+                                                            &lt;/property&gt;
+                                                            &lt;widget&gt;
+                                                                &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                                    &lt;name&gt;name&lt;/name&gt;
+                                                                    &lt;cstring&gt;Layout5&lt;/cstring&gt;
+                                                                &lt;/property&gt;
+                                                                &lt;hbox&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;margin&lt;/name&gt;
+                                                                        &lt;number&gt;0&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;spacing&lt;/name&gt;
+                                                                        &lt;number&gt;6&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel2_2&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;condition&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;condition1LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel7&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;do&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;action1LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                &lt;/hbox&gt;
+                                                            &lt;/widget&gt;
+                                                            &lt;widget&gt;
+                                                                &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                                    &lt;name&gt;name&lt;/name&gt;
+                                                                    &lt;cstring&gt;Layout6&lt;/cstring&gt;
+                                                                &lt;/property&gt;
+                                                                &lt;hbox&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;margin&lt;/name&gt;
+                                                                        &lt;number&gt;0&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;spacing&lt;/name&gt;
+                                                                        &lt;number&gt;6&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel3_3&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;condition&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;condition2LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel8&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;do&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;action2LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                &lt;/hbox&gt;
+                                                            &lt;/widget&gt;
+                                                            &lt;widget&gt;
+                                                                &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                                    &lt;name&gt;name&lt;/name&gt;
+                                                                    &lt;cstring&gt;Layout7&lt;/cstring&gt;
+                                                                &lt;/property&gt;
+                                                                &lt;hbox&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;margin&lt;/name&gt;
+                                                                        &lt;number&gt;0&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;spacing&lt;/name&gt;
+                                                                        &lt;number&gt;6&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel4_3&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;condition&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;condition3LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel9&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;do&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;action3LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                &lt;/hbox&gt;
+                                                            &lt;/widget&gt;
+                                                            &lt;widget&gt;
+                                                                &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                                    &lt;name&gt;name&lt;/name&gt;
+                                                                    &lt;cstring&gt;Layout8&lt;/cstring&gt;
+                                                                &lt;/property&gt;
+                                                                &lt;hbox&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;margin&lt;/name&gt;
+                                                                        &lt;number&gt;0&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;spacing&lt;/name&gt;
+                                                                        &lt;number&gt;6&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel5&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;condition&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;condition4LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel10&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;do&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;action4LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                &lt;/hbox&gt;
+                                                            &lt;/widget&gt;
+                                                            &lt;widget&gt;
+                                                                &lt;class&gt;QLayoutWidget&lt;/class&gt;
+                                                                &lt;property stdset=&quot;1&quot;&gt;
+                                                                    &lt;name&gt;name&lt;/name&gt;
+                                                                    &lt;cstring&gt;Layout9&lt;/cstring&gt;
+                                                                &lt;/property&gt;
+                                                                &lt;hbox&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;margin&lt;/name&gt;
+                                                                        &lt;number&gt;0&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;property stdset=&quot;1&quot;&gt;
+                                                                        &lt;name&gt;spacing&lt;/name&gt;
+                                                                        &lt;number&gt;6&lt;/number&gt;
+                                                                    &lt;/property&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel6&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;condition&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;condition5LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLabel&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;TextLabel11&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;text&lt;/name&gt;
+                                                                            &lt;string&gt;do&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                    &lt;widget&gt;
+                                                                        &lt;class&gt;QLineEdit&lt;/class&gt;
+                                                                        &lt;property stdset=&quot;1&quot;&gt;
+                                                                            &lt;name&gt;name&lt;/name&gt;
+                                                                            &lt;cstring&gt;action5LineEdit&lt;/cstring&gt;
+                                                                        &lt;/property&gt;
+                                                                        &lt;property&gt;
+                                                                            &lt;name&gt;whatsThis&lt;/name&gt;
+                                                                            &lt;string&gt;if condition match, coresponding action will be evaluated&lt;/string&gt;
+                                                                        &lt;/property&gt;
+                                                                    &lt;/widget&gt;
+                                                                &lt;/hbox&gt;
+                                                            &lt;/widget&gt;
+                                                        &lt;/vbox&gt;
+                                                    &lt;/widget&gt;
+                                                &lt;/hbox&gt;
+                                            &lt;/widget&gt;
+                                        &lt;/vbox&gt;
+                                    &lt;/widget&gt;
+                                &lt;/vbox&gt;
+                            &lt;/widget&gt;
+                        &lt;/widget&gt;
+                    &lt;/vbox&gt;
+                &lt;/widget&gt;
+            &lt;/grid&gt;
+        &lt;/widget&gt;
+    &lt;/grid&gt;
+&lt;/widget&gt;
+&lt;connections&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;nodeListView&lt;/sender&gt;
+        &lt;signal&gt;selectionChanged(QListViewItem*)&lt;/signal&gt;
+        &lt;receiver&gt;DialogEditorGenerated&lt;/receiver&gt;
+        &lt;slot&gt;nodeChangedSlot(QListViewItem* )&lt;/slot&gt;
+    &lt;/connection&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;answersListView&lt;/sender&gt;
+        &lt;signal&gt;returnPressed(QListViewItem*)&lt;/signal&gt;
+        &lt;receiver&gt;DialogEditorGenerated&lt;/receiver&gt;
+        &lt;slot&gt;processAnswerSlot(QListViewItem*)&lt;/slot&gt;
+    &lt;/connection&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;answersListView&lt;/sender&gt;
+        &lt;signal&gt;doubleClicked(QListViewItem*)&lt;/signal&gt;
+        &lt;receiver&gt;DialogEditorGenerated&lt;/receiver&gt;
+        &lt;slot&gt;processAnswerSlot(QListViewItem*)&lt;/slot&gt;
+    &lt;/connection&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;answersListView&lt;/sender&gt;
+        &lt;signal&gt;selectionChanged(QListViewItem*)&lt;/signal&gt;
+        &lt;receiver&gt;DialogEditorGenerated&lt;/receiver&gt;
+        &lt;slot&gt;answerChangedSlot(QListViewItem*)&lt;/slot&gt;
+    &lt;/connection&gt;
+    &lt;slot access=&quot;public&quot;&gt;answerChangedSlot(QListViewItem*)&lt;/slot&gt;
+    &lt;slot access=&quot;public&quot;&gt;answerPositionChanged(int)&lt;/slot&gt;
+    &lt;slot access=&quot;public&quot;&gt;nodeChangedSlot(QListViewItem* )&lt;/slot&gt;
+    &lt;slot access=&quot;public&quot;&gt;processAnswerSlot(QListViewItem*)&lt;/slot&gt;
+    &lt;slot access=&quot;public&quot;&gt;saveAnswer()&lt;/slot&gt;
+    &lt;slot access=&quot;public&quot;&gt;saveNodeInfo()&lt;/slot&gt;
+&lt;/connections&gt;
+&lt;tabstops&gt;
+    &lt;tabstop&gt;nodeIdLineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;NodeNameLineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;MusicEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;BackgroundLineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;commonMultiLineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;nodeListView&lt;/tabstop&gt;
+    &lt;tabstop&gt;triggerTable&lt;/tabstop&gt;
+    &lt;tabstop&gt;alienTextBrowser&lt;/tabstop&gt;
+    &lt;tabstop&gt;TabWidget2&lt;/tabstop&gt;
+    &lt;tabstop&gt;appearConditionLineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;condition1LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;action1LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;condition2LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;action2LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;condition3LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;action3LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;condition4LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;action4LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;condition5LineEdit&lt;/tabstop&gt;
+    &lt;tabstop&gt;action5LineEdit&lt;/tabstop&gt;
+&lt;/tabstops&gt;
+&lt;/UI&gt;

Added: trunk/Util/deditor/addplayeranswer.xpm
===================================================================
--- trunk/Util/deditor/addplayeranswer.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/addplayeranswer.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *addplayeranswer_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #00000&quot;,
+&quot;c c #f3f7f3&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaabbbbbbbaaaa&quot;,
+&quot;aaaaaaaabaaaaaaa&quot;,
+&quot;aaaaaaaabaaaaaaa&quot;,
+&quot;aaaaaaabbbaaaaaa&quot;,
+&quot;aaaaaaabbbaaaaaa&quot;,
+&quot;aaaaaabbbbbaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aabbbbbbbbbbbbaa&quot;,
+&quot;aabbbbbbbbbbbbaa&quot;,
+&quot;aabbbbbbbbbbbbaa&quot;,
+&quot;aabbbbbbbbbbbbaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;
+};

Added: trunk/Util/deditor/application.cpp
===================================================================
--- trunk/Util/deditor/application.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/application.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,542 @@
+
+#include &quot;application.h&quot;
+
+#include &lt;qimage.h&gt;
+#include &lt;qpixmap.h&gt;
+#include &lt;qtoolbar.h&gt;
+#include &lt;qtoolbutton.h&gt;
+#include &lt;qpopupmenu.h&gt;
+#include &lt;qmenubar.h&gt;
+#include &lt;qkeycode.h&gt;
+#include &lt;qmultilineedit.h&gt;
+#include &lt;qfile.h&gt;
+#include &lt;qfiledialog.h&gt;
+#include &lt;qstatusbar.h&gt;
+#include &lt;qmessagebox.h&gt;
+#include &lt;qprinter.h&gt;
+#include &lt;qapplication.h&gt;
+#include &lt;qaccel.h&gt;
+#include &lt;qtextstream.h&gt;
+#include &lt;qpainter.h&gt;
+#include &lt;qpaintdevicemetrics.h&gt;
+#include &lt;qwhatsthis.h&gt;
+
+#include &quot;mainwidget.h&quot;
+
+#include &quot;filesave.xpm&quot;
+#include &quot;fileopen.xpm&quot;
+#include &quot;createnode.xpm&quot;
+#include &quot;removenode.xpm&quot;
+#include &quot;setalientext.xpm&quot;
+
+#include &quot;addplayeranswer.xpm&quot;
+#include &quot;rmplayeranswer.xpm&quot;
+#include &quot;setplayeranswertext.xpm&quot;
+#include &quot;itemup.xpm&quot;
+#include &quot;itemdown.xpm&quot;
+#include &quot;evalanswer.xpm&quot;
+
+//file
+static const char * fileOpenText = &quot;&lt;img source=\&quot;fileopen\&quot;&gt; &quot;
+&quot;Click this button to open a &lt;em&gt;new file&lt;/em&gt;. &lt;br&gt;&lt;br&gt;&quot;
+&quot;You can also select the &lt;b&gt;Open command&lt;/b&gt; from the File menu.&quot;;
+
+static const char * fileSaveText = &quot;Click this button to save the file you are &quot;
+&quot;editing.  You will be prompted for a file name.\n\n&quot;
+&quot;You can also select the Save command from the File menu.\n\n&quot;;
+
+//Node
+static const char * addNewNodeText = &quot;Click this button to create new dialog node&quot;;
+static const char * removeNodeText = &quot;Click this button to destroy current dialog node&quot;;
+
+//Edit
+static const char * setAlienTextText = &quot;Click this button to replace current alien text &quot;
+&quot;with text in edit box&quot;;
+
+static const char * addNewPlayerAnswerText = &quot;Click this button to create new &quot; 
+&quot;answer choise&quot;;
+
+static const char * removePlayerAnswerText = &quot;Click this button to remove &quot;
+&quot;selected player answer&quot;;
+
+static const char * setPlayerAnswerTextText = &quot;Click this button to replace &quot;
+&quot;selected player answer with text in edit box&quot;;
+ 
+static const char * answerUpText = &quot;Move answer up&quot;;
+static const char * answerDownText = &quot;Move answer down&quot;;
+
+// Test
+static const char * hideNotAllowedAnswersText = &quot;Hide answer variants that does not &quot;
+&quot;match current trigger selections&quot;;
+
+static const char * evaluateAnswerText = &quot;Click this button to evaluate answer, &quot;
+&quot;it must change triggers and change current node&quot;;
+
+ApplicationWindow::ApplicationWindow()
+    : QMainWindow( 0, &quot;example application main window&quot;, WDestructiveClose )
+{
+	WriteLog(&quot;ApplicationWindow\n&quot;);
+	e = new DialogEditor( this, &quot;editor&quot; );
+
+    e-&gt;setFocus();
+    setCentralWidget( e );
+
+	InitFileTools();
+	InitNodeManagerTools();
+	InitEditTools();
+	InitTestTools();
+	InitHelpTools();
+
+	InitFileMenu();
+	InitNodeManagerMenu();
+	InitEditMenu();
+	InitTestMenu();
+	InitHelpMenu();
+
+	strXML = e-&gt;GetXML();
+
+    statusBar()-&gt;message( &quot;Ready&quot;, 2000 );
+	resize( 640, 480 );
+}
+
+ApplicationWindow::~ApplicationWindow()
+{
+	WriteLog(&quot;~ApplicationWindow\n&quot;);
+}
+
+
+void ApplicationWindow::InitFileMenu()
+{
+	WriteLog(&quot;ApplicationWindow::InitFileMenu\n&quot;);
+	int id;
+
+    QPixmap openIcon, saveIcon;
+    openIcon = QPixmap( fileopen );
+	saveIcon = QPixmap( filesave );
+
+	QPopupMenu * file = new QPopupMenu( this );
+    menuBar()-&gt;insertItem( &quot;&amp;File&quot;, file );
+
+    file-&gt;insertItem( &quot;&amp;New&quot;, this, SLOT(newDoc()), CTRL+Key_N );
+
+    id = file-&gt;insertItem( openIcon, &quot;&amp;Open&quot;,
+			   this, SLOT(load()), CTRL+Key_O );
+    file-&gt;setWhatsThis( id, fileOpenText );
+
+    id = file-&gt;insertItem( saveIcon, &quot;&amp;Save&quot;,
+			   this, SLOT(save()), CTRL+Key_S );
+    file-&gt;setWhatsThis( id, fileSaveText );
+    id = file-&gt;insertItem( &quot;Save &amp;as...&quot;, this, SLOT(saveAs()) );
+    file-&gt;setWhatsThis( id, fileSaveText );
+    file-&gt;insertSeparator();
+
+    file-&gt;insertSeparator();
+    file-&gt;insertItem( &quot;&amp;Close&quot;, this, SLOT(close()), CTRL+Key_W );
+    file-&gt;insertItem( &quot;&amp;Quit&quot;, qApp, SLOT( closeAllWindows() ), CTRL+Key_Q );
+}
+
+void ApplicationWindow::InitFileTools()
+{
+	WriteLog(&quot;ApplicationWindow::InitFileTools()\n&quot;);
+    QPixmap openIcon, saveIcon;
+
+    fileTools = new QToolBar( this, &quot;file operations&quot; );
+    fileTools-&gt;setLabel( tr( &quot;File Operations&quot; ) );
+
+    openIcon = QPixmap( fileopen );
+    QToolButton * fileOpen
+	= new QToolButton( openIcon, &quot;Open File&quot;, QString::null,
+			   this, SLOT(load()), fileTools, &quot;open file&quot; );
+
+    saveIcon = QPixmap( filesave );
+    QToolButton * fileSave
+	= new QToolButton( saveIcon, &quot;Save File&quot;, QString::null,
+			   this, SLOT(save()), fileTools, &quot;save file&quot; );
+
+    QWhatsThis::add( fileOpen, fileOpenText );
+    QMimeSourceFactory::defaultFactory()-&gt;setPixmap( &quot;fileopen&quot;, openIcon );
+    QWhatsThis::add( fileSave, fileSaveText );
+
+}
+
+
+void ApplicationWindow::InitNodeManagerMenu()
+{
+	WriteLog(&quot;ApplicationWindow::InitNodeManagerMenu()\n&quot;);
+	int id;
+
+    QPixmap createnodeIcon, removenodeIcon;
+	createnodeIcon = QPixmap( createnode_xpm );
+	removenodeIcon = QPixmap( removenode_xpm );
+
+	QPopupMenu * node = new QPopupMenu( this );
+    menuBar()-&gt;insertItem( &quot;&amp;Node&quot;, node );
+
+    id = node-&gt;insertItem( createnodeIcon, &quot;Add new node&quot;,
+			   this, SLOT(AddNewNodeSlot()), ALT+Key_N );
+
+    node-&gt;setWhatsThis( id, addNewNodeText );
+
+    id = node-&gt;insertItem( removenodeIcon, &quot;Remove node&quot;,
+			   this, SLOT(RemoveNodeSlot()), ALT+Key_K );
+    node-&gt;setWhatsThis( id, removeNodeText );
+}
+
+void ApplicationWindow::InitNodeManagerTools()
+{
+	WriteLog(&quot;ApplicationWindow::InitNodeManagerTools&quot;);
+	QPixmap createnodeIcon, removenodeIcon;
+	createnodeIcon = QPixmap( createnode_xpm );
+	removenodeIcon = QPixmap( removenode_xpm );
+
+	nodeTools = new QToolBar( this, &quot;Node manager operations&quot; );
+    nodeTools-&gt;setLabel( tr( &quot;Node manager Operations&quot; ) );
+
+	QToolButton * addNewNode
+	= new QToolButton( createnodeIcon, &quot;Add new node&quot;, QString::null,
+			   this, SLOT(AddNewNodeSlot()), nodeTools, &quot;open file&quot; );
+
+    QToolButton * removeNode
+	= new QToolButton( removenodeIcon, &quot;Remove node&quot;, QString::null,
+			   this, SLOT(RemoveNodeSlot()), nodeTools, &quot;open file&quot; );
+
+	QWhatsThis::add( addNewNode, addNewNodeText );
+    QWhatsThis::add( removeNode, removeNodeText );
+}
+
+void ApplicationWindow::InitEditMenu()
+{
+	WriteLog(&quot;ApplicationWindow::InitEditMenu()\n&quot;);
+		int id;
+
+    QPixmap setalientextIcon, addplayeranswerIcon;
+	QPixmap rmplayeranswerIcon, setplayeranswertextIcon;
+	QPixmap answerUpIcon, answerDownIcon;
+
+	setalientextIcon = QPixmap(setalientext_xpm);
+	addplayeranswerIcon = QPixmap(addplayeranswer_xpm);
+	rmplayeranswerIcon = QPixmap(rmplayeranswer_xpm);
+	setplayeranswertextIcon = QPixmap(setplayeranswertext_xpm);
+	answerUpIcon = QPixmap(answerup_xpm);
+	answerDownIcon = QPixmap(answerdown_xpm);
+
+	QPopupMenu * edit = new QPopupMenu( this );
+    menuBar()-&gt;insertItem( &quot;&amp;Edit&quot;, edit );
+
+    id = edit-&gt;insertItem( setalientextIcon, &quot;Set Alien Text&quot;,
+			   this, SLOT(SetAlienTextSlot()), ALT+Key_T );
+
+    edit-&gt;setWhatsThis( id, setAlienTextText );
+
+    id = edit-&gt;insertItem( addplayeranswerIcon, &quot;Add new player answer&quot;,
+			   this, SLOT(AddNewPlayerAnswerSlot()), ALT+Key_A );
+    edit-&gt;setWhatsThis( id, addNewPlayerAnswerText );
+
+
+	id = edit-&gt;insertItem( rmplayeranswerIcon, &quot;Remove player answer&quot;,
+			   this, SLOT(RemovePlayerAnswerSlot()), ALT+Key_R );
+
+    edit-&gt;setWhatsThis( id, removePlayerAnswerText );
+
+    id = edit-&gt;insertItem( setplayeranswertextIcon, &quot;Set Player Answer Text&quot;,
+			   this, SLOT(SetPlayerAnswerTextSlot()), ALT+Key_F );
+    edit-&gt;setWhatsThis( id, setPlayerAnswerTextText );
+
+	id = edit-&gt;insertItem( answerUpIcon, &quot;Move answer Up&quot;,
+			   this, SLOT(answerUpSlot()), 0 );
+    edit-&gt;setWhatsThis( id, answerUpText );
+
+	id = edit-&gt;insertItem( answerDownIcon, &quot;Move answer down&quot;,
+			   this, SLOT(answerDownSlot()), 0 );
+    edit-&gt;setWhatsThis( id, answerDownText );
+
+}
+
+void ApplicationWindow::InitEditTools()
+{
+	WriteLog(&quot;ApplicationWindow::InitEditTools()\n&quot;);
+    QPixmap setalientextIcon, addplayeranswerIcon;
+	QPixmap rmplayeranswerIcon, setplayeranswertextIcon;
+	QPixmap answerUpIcon, answerDownIcon;
+
+	setalientextIcon = QPixmap(setalientext_xpm);
+	addplayeranswerIcon = QPixmap(addplayeranswer_xpm);
+	rmplayeranswerIcon = QPixmap(rmplayeranswer_xpm);
+	setplayeranswertextIcon = QPixmap(setplayeranswertext_xpm);
+	answerUpIcon = QPixmap(answerup_xpm);
+	answerDownIcon = QPixmap(answerdown_xpm);
+
+	editTools = new QToolBar( this, &quot;edit operations&quot; );
+    editTools-&gt;setLabel( tr( &quot;Edit Operations&quot; ) );
+
+	QToolButton * setAlienText
+	= new QToolButton( setalientextIcon, &quot;Set Alien Text&quot;, QString::null,
+			   this, SLOT(SetAlienTextSlot()), editTools, &quot;open file&quot; );
+
+    QToolButton * addPlayerAnswer
+	= new QToolButton( addplayeranswerIcon, &quot;Add new player answer&quot;, QString::null,
+			   this, SLOT(AddNewPlayerAnswerSlot()), editTools, &quot;open file&quot; );
+
+	QToolButton * removePlayerAnswer
+	= new QToolButton( rmplayeranswerIcon, &quot;Remove player answer&quot;, QString::null,
+			   this, SLOT(RemovePlayerAnswerSlot()), editTools, &quot;open file&quot; );
+
+	QToolButton * setPlayerAnswer
+	= new QToolButton( setplayeranswertextIcon, &quot;Set Player Answer Text&quot;, QString::null,
+			   this, SLOT(SetPlayerAnswerTextSlot()), editTools, &quot;save file&quot; );
+
+	QToolButton * answerUp
+	= new QToolButton( answerUpIcon, &quot;Move Answer up&quot;, QString::null,
+			   this, SLOT(answerUpSlot()), editTools, &quot;save file&quot; );
+
+	QToolButton * answerDown
+	= new QToolButton( answerDownIcon, &quot;Move Unswer down&quot;, QString::null,
+			   this, SLOT(answerDownSlot()), editTools, &quot;save file&quot; );
+
+	QWhatsThis::add( setAlienText, setAlienTextText );
+    QWhatsThis::add( addPlayerAnswer, addNewPlayerAnswerText );
+    QWhatsThis::add( removePlayerAnswer, removePlayerAnswerText );
+	QWhatsThis::add( setPlayerAnswer, setPlayerAnswerTextText );
+	QWhatsThis::add( answerUp, answerUpText );
+	QWhatsThis::add( answerDown, answerDownText );
+}
+
+void ApplicationWindow::InitTestMenu()
+{
+	WriteLog(&quot;ApplicationWindow::InitTestMenu()\n&quot;);
+	int id;
+	QPixmap evalanswerIcon;
+    evalanswerIcon = QPixmap( evalanswer_xpm );
+
+	QPopupMenu * test = new QPopupMenu( this );
+    menuBar()-&gt;insertItem( &quot;&amp;Test&quot;, test );
+
+    id = test-&gt;insertItem( evalanswerIcon, &quot;Evaluate answer&quot;,
+			   this, SLOT(evaluateAnswerSlot()), CTRL+Key_R );
+    test-&gt;setWhatsThis( id, evaluateAnswerText );
+}
+
+void ApplicationWindow::InitTestTools()
+{
+	WriteLog(&quot;ApplicationWindow::InitTestTools()\n&quot;);
+	QPixmap evalanswerIcon;
+    evalanswerIcon = QPixmap( evalanswer_xpm );
+
+	testTools = new QToolBar( this, &quot;Dialog Test&quot; );
+    testTools-&gt;setLabel( tr( &quot;Dialog Test&quot; ) );
+
+    QToolButton * evalAnswer
+	= new QToolButton( evalanswerIcon, &quot;Evaluate answer&quot;, QString::null,
+			   this, SLOT(evaluateAnswerSlot()), testTools, &quot;open file&quot; );
+
+
+//	QWhatsThis::add( hideNotAllowed, hideNotAllowedAnswersText );
+    QWhatsThis::add( evalAnswer, evaluateAnswerText );
+};
+
+void ApplicationWindow::InitHelpMenu()
+{
+	WriteLog(&quot;ApplicationWindow::InitHelpMenu()\n&quot;);
+	QPopupMenu * help = new QPopupMenu( this );
+    menuBar()-&gt;insertSeparator();
+    menuBar()-&gt;insertItem( &quot;&amp;Help&quot;, help );
+
+    help-&gt;insertItem( &quot;&amp;About&quot;, this, SLOT(about()), Key_F1 );
+    help-&gt;insertSeparator();
+    help-&gt;insertItem( &quot;What's &amp;This&quot;, this, SLOT(whatsThis()), SHIFT+Key_F1 );
+}
+
+
+void ApplicationWindow::InitHelpTools()
+{
+	WriteLog(&quot;ApplicationWindow::InitHelpTools()\n&quot;);
+	helpTools = new QToolBar( this, &quot;What is this&quot; );
+    helpTools-&gt;setLabel( tr( &quot;What is this&quot; ) );
+
+	(void)QWhatsThis::whatsThisButton( helpTools );
+}
+
+
+void ApplicationWindow::newDoc()
+{
+	WriteLog(&quot;ApplicationWindow::newDoc()\n&quot;);
+    ApplicationWindow *ed = new ApplicationWindow;
+    ed-&gt;setCaption(&quot;TW-Light Dialog Editor&quot;);
+    ed-&gt;show();
+}
+
+void ApplicationWindow::load()
+{
+	WriteLog(&quot;ApplicationWindow::load()\n&quot;);
+    QString fn = QFileDialog::getOpenFileName( QString::null, &quot;XML files (*.xml)&quot;,
+					       this);
+    if ( !fn.isEmpty() )
+	load( fn );
+    else
+	statusBar()-&gt;message( &quot;Loading aborted&quot;, 2000 );
+}
+
+
+void ApplicationWindow::load( QString fileName )
+{
+	WriteLog(&quot;ApplicationWindow::load( const char *fileName )&quot;);
+	e-&gt;loadDoc(fileName);
+	strXML = e-&gt;GetXML();
+
+	filename = fileName;
+    setCaption( fileName );
+    QString s;
+    s.sprintf( &quot;Loaded document %s&quot;, fileName );
+    statusBar()-&gt;message( s, 2000 );
+}
+
+
+void ApplicationWindow::save()
+{
+	WriteLog(&quot;ApplicationWindow::save()&quot;);
+    if ( filename.isEmpty() ) {
+	saveAs();
+	return;
+    }
+
+    QString text = e-&gt;GetXML();
+    QFile f( filename );
+    if ( !f.open( IO_WriteOnly ) ) {
+	statusBar()-&gt;message( QString(&quot;Could not write to %1&quot;).arg(filename),
+			      2000 );
+	return;
+    }
+
+    QTextStream t( &amp;f );
+    t &lt;&lt; text;
+    f.close();
+
+    strXML = text;
+
+    setCaption( filename );
+    statusBar()-&gt;message( QString( &quot;File %1 saved&quot; ).arg( filename ), 2000 );
+}
+
+
+void ApplicationWindow::saveAs()
+{
+	WriteLog(&quot;ApplicationWindow::saveAs()&quot;);
+    QString fn = QFileDialog::getSaveFileName( QString::null, &quot;XML files (*.xml)&quot;,
+					       this );
+    if ( !fn.isEmpty() ) {
+		if(fn.find(&quot;.xml&quot;, 0, FALSE)==-1)
+		{
+			fn += &quot;.xml&quot;;
+		}
+	filename = fn;
+	save();
+    } else {
+	statusBar()-&gt;message( &quot;Saving aborted&quot;, 2000 );
+    }
+}
+
+void ApplicationWindow::closeEvent( QCloseEvent* ce )
+{
+	WriteLog(&quot;ApplicationWindow::closeEvent( QCloseEvent* ce )\n&quot;);
+	if ( strXML == e-&gt;GetXML() ) {
+	ce-&gt;accept();
+	return;
+    }
+
+    switch( QMessageBox::information( this, &quot;TW-Light Dialog Editor&quot;,
+				      &quot;The document has been changed since &quot;
+				      &quot;the last save.&quot;,
+				      &quot;Save Now&quot;, &quot;Cancel&quot;, &quot;Leave Anyway&quot;,
+				      0, 1 ) ) {
+    case 0:
+	save();
+	ce-&gt;accept();
+	break;
+    case 1:
+    default: // just for sanity
+	ce-&gt;ignore();
+	break;
+    case 2:
+	ce-&gt;accept();
+	break;
+    }
+}
+
+// node
+void ApplicationWindow::AddNewNodeSlot()
+{
+	WriteLog(&quot;ApplicationWindow::AddNewNodeSlot()\n&quot;);
+	e-&gt;CreateNewNode();
+}
+
+void ApplicationWindow::RemoveNodeSlot()
+{
+	WriteLog(&quot;ApplicationWindow::RemoveNodeSlot()\n&quot;);
+	e-&gt;removeNode();
+}
+
+// edit
+void ApplicationWindow::SetAlienTextSlot()
+{
+	WriteLog(&quot;ApplicationWindow::SetAlienTextSlot()\n&quot;);
+	e-&gt;setAlienText();
+}
+
+void ApplicationWindow::AddNewPlayerAnswerSlot()
+{
+	WriteLog(&quot;ApplicationWindow::AddNewPlayerAnswerSlot()\n&quot;);
+	e-&gt;AddPlayerAnswer();
+}
+
+void ApplicationWindow::RemovePlayerAnswerSlot()
+{
+	WriteLog(&quot;ApplicationWindow::RemovePlayerAnswerSlot()\n&quot;);
+	e-&gt;removeAnswer();
+}
+
+void ApplicationWindow::SetPlayerAnswerTextSlot()
+{
+	WriteLog(&quot;ApplicationWindow::SetPlayerAnswerTextSlot()\n&quot;);
+	e-&gt;setPlayerAnswerText();
+}
+
+void ApplicationWindow::answerUpSlot()
+{
+	e-&gt;answerUp();
+}
+
+void ApplicationWindow::answerDownSlot()
+{
+	e-&gt;answerDown();
+}
+
+
+// Test
+void ApplicationWindow::hideNotAllowedAnswersSlot()
+{
+	WriteLog(&quot;ApplicationWindow::hideNotAllowedAnswersSlot()\n&quot;);
+		QMessageBox::information( this, &quot;hideNotAllowedAnswersSlot&quot;,
+                              &quot;Not implemented yet&quot;);
+}
+void ApplicationWindow::evaluateAnswerSlot()
+{
+	WriteLog(&quot;ApplicationWindow::evaluateAnswerSlot()\n&quot;);
+	QListViewItem * answ = e-&gt;answersListView-&gt;currentItem();
+	if(answ)
+		e-&gt;processAnswerSlot(answ);
+}
+
+// Help
+void ApplicationWindow::about()
+{
+	WriteLog(&quot;ApplicationWindow::about()\n&quot;);
+    QMessageBox::about( this, &quot;TW-Light Dialog Editor&quot;,
+			&quot;Copyright (C) 2004 Yura Semasko aka Yurand.\n&quot;
+			&quot;<A HREF="http://www.tw-light.berlios.de">http://www.tw-light.berlios.de</A> <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">yurand at land.ru</A>\n\n&quot;
+			&quot;This program is free software; you can redistribute\n&quot;
+			&quot;it and/or modify it under the terms of the GNU General\n&quot;
+			&quot;Public License as published by the Free Software\n&quot;
+			&quot;Foundation; either version 2 of the License, or (at \n&quot;
+			&quot;your option) any later version.&quot;);
+}
+

Added: trunk/Util/deditor/application.h
===================================================================
--- trunk/Util/deditor/application.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/application.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,75 @@
+
+#ifndef APPLICATION_H
+#define APPLICATION_H
+
+#include &lt;qmainwindow.h&gt;
+
+class DialogEditor;
+class QToolBar;
+class QPopupMenu;
+
+class ApplicationWindow: public QMainWindow
+{
+    Q_OBJECT
+public:
+    ApplicationWindow();
+    ~ApplicationWindow();
+    
+protected:
+    void closeEvent( QCloseEvent* );
+
+	void InitFileTools();
+	void InitNodeManagerTools();
+	void InitEditTools();
+	void InitTestTools();
+	void InitHelpTools();
+
+	void InitFileMenu();
+	void InitNodeManagerMenu();
+	void InitEditMenu();
+	void InitTestMenu();
+	void InitHelpMenu();
+
+private slots:
+	// file 
+    void newDoc();
+    void load();
+    void load( QString fileName );
+    void save();
+    void saveAs();
+   
+	// node
+	void AddNewNodeSlot();
+	void RemoveNodeSlot();
+
+	// edit
+	void SetAlienTextSlot();
+	void AddNewPlayerAnswerSlot();
+	void RemovePlayerAnswerSlot();
+	void SetPlayerAnswerTextSlot();
+
+	void answerUpSlot();
+	void answerDownSlot();
+
+	// test
+	void hideNotAllowedAnswersSlot();
+	void evaluateAnswerSlot();
+
+	// about
+    void about();
+
+private:
+	QString strXML;
+
+    DialogEditor *e;
+    QToolBar *fileTools;
+	QToolBar *nodeTools;
+	QToolBar *editTools;
+	QToolBar *testTools;
+	QToolBar *helpTools;
+
+    QString filename;
+};
+
+
+#endif

Added: trunk/Util/deditor/book.png
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/book.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/createnode.xpm
===================================================================
--- trunk/Util/deditor/createnode.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/createnode.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *createnode_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #f3f704&quot;,
+&quot;c c #f3f7f3&quot;,
+&quot;................&quot;,
+&quot;................&quot;,
+&quot;......a....a....&quot;,
+&quot;..bb..a....a....&quot;,
+&quot;.b..b.aa...a....&quot;,
+&quot;.b....a.a..a....&quot;,
+&quot;.b....a.a..a....&quot;,
+&quot;.b..b.a..a.a....&quot;,
+&quot;..bb..a..a.a....&quot;,
+&quot;......a...aa....&quot;,
+&quot;................&quot;,
+&quot;................&quot;,
+&quot;................&quot;
+};

Added: trunk/Util/deditor/dialog.xml
===================================================================
--- trunk/Util/deditor/dialog.xml	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialog.xml	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,2 @@
+&lt;NODES&gt;&lt;NODE id=&quot;0&quot; name=&quot;Start&quot; music=&quot;&quot; background=&quot;a.png&quot; alien_text=&quot;TW-Light Dialog Editor. 
+   &lt;br&gt; Test dialog&quot; font=&quot;&quot; text_location=&quot;&quot;&gt;&lt;PLAYER_ANSWER text=&quot;We come in peace&quot; appear_condition=&quot;1&quot;&gt;&lt;ACTION condition=&quot;1&quot; action=&quot;goto(&quot;2&quot;)&quot;&gt;&lt;/ACTION&gt;&lt;/PLAYER_ANSWER&gt;&lt;PLAYER_ANSWER text=&quot;Die supid alien!&quot; appear_condition=&quot;1&quot;&gt;&lt;ACTION condition=&quot;1&quot; action=&quot;goto(&quot;1&quot;)&quot;&gt;&lt;/ACTION&gt;&lt;/PLAYER_ANSWER&gt;&lt;/NODE&gt;&lt;NODE id=&quot;1&quot; name=&quot;Batte&quot; music=&quot;&quot; background=&quot;&quot; alien_text=&quot;You have bad manners, die&quot; font=&quot;&quot; text_location=&quot;&quot;&gt;&lt;PLAYER_ANSWER text=&quot;Ok!!&quot; appear_condition=&quot;1&quot;&gt;&lt;/PLAYER_ANSWER&gt;&lt;/NODE&gt;&lt;NODE id=&quot;2&quot; name=&quot;Bye&quot; music=&quot;&quot; background=&quot;a.png&quot; alien_text=&quot;Have to go, sorry&quot; font=&quot;&quot; text_location=&quot;&quot;&gt;&lt;PLAYER_ANSWER text=&quot;Bye&quot; appear_condition=&quot;1&quot;&gt;&lt;/PLAYER_ANSWER&gt;&lt;/NODE&gt;&lt;/NODES&gt;
\ No newline at end of file

Added: trunk/Util/deditor/dialogeditor.dsp
===================================================================
--- trunk/Util/deditor/dialogeditor.dsp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.dsp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,363 @@
+# Microsoft Developer Studio Project File - Name=&quot;dialogeditor&quot; - Package Owner=&lt;4&gt;
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE &quot;Win32 (x86) Application&quot; 0x0101
+
+CFG=dialogeditor - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;dialogeditor.mak&quot;.
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f &quot;dialogeditor.mak&quot; CFG=&quot;dialogeditor - Win32 Debug&quot;
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE &quot;dialogeditor - Win32 Release&quot; (based on &quot;Win32 (x86) Application&quot;)
+!MESSAGE &quot;dialogeditor - Win32 Debug&quot; (based on &quot;Win32 (x86) Application&quot;)
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName &quot;&quot;
+# PROP Scc_LocalPath &quot;&quot;
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  &quot;$(CFG)&quot; == &quot;dialogeditor - Win32 Release&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir &quot;Release&quot;
+# PROP BASE Intermediate_Dir &quot;Release&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir &quot;Release&quot;
+# PROP Intermediate_Dir &quot;Release&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /GX /O2 /D &quot;WIN32&quot; /D &quot;NDEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I &quot;./lua&quot; /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;QT_DLL&quot; /D &quot;QT_THREAD_SUPPORT&quot; /YX /FD /c
+# ADD BASE MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
+# ADD MTL /nologo /D &quot;NDEBUG&quot; /mktyplib203 /win32
+# ADD BASE RSC /l 0x423 /d &quot;NDEBUG&quot;
+# ADD RSC /l 0x423 /d &quot;NDEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
+# ADD LINK32 qt-mt230nc.lib qtmain.lib qutil.lib /nologo /subsystem:windows /machine:I386
+
+!ELSEIF  &quot;$(CFG)&quot; == &quot;dialogeditor - Win32 Debug&quot;
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir &quot;Debug&quot;
+# PROP BASE Intermediate_Dir &quot;Debug&quot;
+# PROP BASE Target_Dir &quot;&quot;
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir &quot;Debug&quot;
+# PROP Intermediate_Dir &quot;Debug&quot;
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir &quot;&quot;
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D &quot;WIN32&quot; /D &quot;_DEBUG&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I &quot;./lua&quot; /D &quot;_DEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;QT_DLL&quot; /D &quot;QT_THREAD_SUPPORT&quot; /YX /FD /GZ /c
+# ADD BASE MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
+# ADD MTL /nologo /D &quot;_DEBUG&quot; /mktyplib203 /win32
+# ADD BASE RSC /l 0x423 /d &quot;_DEBUG&quot;
+# ADD RSC /l 0x423 /d &quot;_DEBUG&quot;
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 qt-mt230nc.lib qtmain.lib qutil.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name &quot;dialogeditor - Win32 Release&quot;
+# Name &quot;dialogeditor - Win32 Debug&quot;
+# Begin Group &quot;Source Files&quot;
+
+# PROP Default_Filter &quot;cpp;c;cxx;rc;def;r;odl;idl;hpj;bat&quot;
+# Begin Source File
+
+SOURCE=.\application.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\application.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\helpers.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\helpers.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\main.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\mainwidget.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\mainwidget.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\node.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\node.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\xmlparser.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\xmlparser.h
+# End Source File
+# End Group
+# Begin Group &quot;Resource Files&quot;
+
+# PROP Default_Filter &quot;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe&quot;
+# End Group
+# Begin Group &quot;generated&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=.\maindialog.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\maindialog.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\moc_application.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\moc_maindialog.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\moc_node.cpp
+# End Source File
+# End Group
+# Begin Group &quot;lua&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Group &quot;lib&quot;
+
+# PROP Default_Filter &quot;&quot;
+# Begin Source File
+
+SOURCE=.\lua\lib\lauxlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\lbaselib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\ldblib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\liolib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\lmathlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\loadlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\lstrlib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lib\ltablib.c
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=.\lua\lapi.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lapi.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lcode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lcode.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldebug.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldebug.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldo.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldo.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ldump.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lfunc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lfunc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lgc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lgc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\llex.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\llex.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\llimits.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lmem.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lmem.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lobject.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lobject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lopcodes.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lopcodes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lparser.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lparser.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstate.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstring.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lstring.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltable.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltable.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltests.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltm.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\ltm.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lundump.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lundump.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lvm.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lvm.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lzio.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\lua\lzio.h
+# End Source File
+# End Group
+# End Target
+# End Project

Added: trunk/Util/deditor/dialogeditor.dsw
===================================================================
--- trunk/Util/deditor/dialogeditor.dsw	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.dsw	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: &quot;dialogeditor&quot;=&quot;.\dialogeditor.dsp&quot; - Package Owner=&lt;4&gt;
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;4&gt;
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=&lt;5&gt;
+{{{
+}}}
+
+Package=&lt;3&gt;
+{{{
+}}}
+
+###############################################################################
+

Added: trunk/Util/deditor/dialogeditor.ncb
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/dialogeditor.ncb
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/dialogeditor.opt
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/dialogeditor.opt
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/dialogeditor.plg
===================================================================
--- trunk/Util/deditor/dialogeditor.plg	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.plg	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,145 @@
+&lt;html&gt;
+&lt;body&gt;
+&lt;pre&gt;
+&lt;h1&gt;Build Log&lt;/h1&gt;
+&lt;h3&gt;
+--------------------Configuration: dialogeditor - Win32 Release--------------------
+&lt;/h3&gt;
+&lt;h3&gt;Command Lines&lt;/h3&gt;
+Creating temporary file &quot;C:\DOCUME~1\Yura\LOCALS~1\Temp\RSPF.tmp&quot; with contents
+[
+/nologo /ML /W3 /GX /O2 /I &quot;./lua&quot; /D &quot;NDEBUG&quot; /D &quot;WIN32&quot; /D &quot;_WINDOWS&quot; /D &quot;_MBCS&quot; /D &quot;QT_DLL&quot; /D &quot;QT_THREAD_SUPPORT&quot; /Fp&quot;Release/dialogeditor.pch&quot; /YX /Fo&quot;Release/&quot; /Fd&quot;Release/&quot; /FD /c 
+&quot;C:\Projects\TW-Light Dialog Editor\application.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\helpers.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\main.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\mainwidget.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\node.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\xmlparser.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\maindialog.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\moc_application.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\moc_maindialog.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\moc_node.cpp&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\lauxlib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\lbaselib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\ldblib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\liolib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\lmathlib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\loadlib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\lstrlib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lib\ltablib.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lapi.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lcode.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\ldebug.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\ldo.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\ldump.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lfunc.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lgc.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\llex.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lmem.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lobject.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lopcodes.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lparser.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lstate.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lstring.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\ltable.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\ltests.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\ltm.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lundump.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lvm.c&quot;
+&quot;C:\Projects\TW-Light Dialog Editor\lua\lzio.c&quot;
+]
+Creating command line &quot;cl.exe @C:\DOCUME~1\Yura\LOCALS~1\Temp\RSPF.tmp&quot; 
+Creating temporary file &quot;C:\DOCUME~1\Yura\LOCALS~1\Temp\RSP10.tmp&quot; with contents
+[
+qt-mt230nc.lib qtmain.lib qutil.lib /nologo /subsystem:windows /incremental:no /pdb:&quot;Release/dialogeditor.pdb&quot; /machine:I386 /out:&quot;Release/dialogeditor.exe&quot; 
+&quot;.\Release\application.obj&quot;
+&quot;.\Release\helpers.obj&quot;
+&quot;.\Release\main.obj&quot;
+&quot;.\Release\mainwidget.obj&quot;
+&quot;.\Release\node.obj&quot;
+&quot;.\Release\xmlparser.obj&quot;
+&quot;.\Release\maindialog.obj&quot;
+&quot;.\Release\moc_application.obj&quot;
+&quot;.\Release\moc_maindialog.obj&quot;
+&quot;.\Release\moc_node.obj&quot;
+&quot;.\Release\lauxlib.obj&quot;
+&quot;.\Release\lbaselib.obj&quot;
+&quot;.\Release\ldblib.obj&quot;
+&quot;.\Release\liolib.obj&quot;
+&quot;.\Release\lmathlib.obj&quot;
+&quot;.\Release\loadlib.obj&quot;
+&quot;.\Release\lstrlib.obj&quot;
+&quot;.\Release\ltablib.obj&quot;
+&quot;.\Release\lapi.obj&quot;
+&quot;.\Release\lcode.obj&quot;
+&quot;.\Release\ldebug.obj&quot;
+&quot;.\Release\ldo.obj&quot;
+&quot;.\Release\ldump.obj&quot;
+&quot;.\Release\lfunc.obj&quot;
+&quot;.\Release\lgc.obj&quot;
+&quot;.\Release\llex.obj&quot;
+&quot;.\Release\lmem.obj&quot;
+&quot;.\Release\lobject.obj&quot;
+&quot;.\Release\lopcodes.obj&quot;
+&quot;.\Release\lparser.obj&quot;
+&quot;.\Release\lstate.obj&quot;
+&quot;.\Release\lstring.obj&quot;
+&quot;.\Release\ltable.obj&quot;
+&quot;.\Release\ltests.obj&quot;
+&quot;.\Release\ltm.obj&quot;
+&quot;.\Release\lundump.obj&quot;
+&quot;.\Release\lvm.obj&quot;
+&quot;.\Release\lzio.obj&quot;
+]
+Creating command line &quot;link.exe @C:\DOCUME~1\Yura\LOCALS~1\Temp\RSP10.tmp&quot;
+&lt;h3&gt;Output Window&lt;/h3&gt;
+Compiling...
+application.cpp
+helpers.cpp
+main.cpp
+mainwidget.cpp
+C:\Projects\TW-Light Dialog Editor\mainwidget.cpp(495) : warning C4018: '==' : signed/unsigned mismatch
+node.cpp
+xmlparser.cpp
+maindialog.cpp
+moc_application.cpp
+moc_maindialog.cpp
+moc_node.cpp
+lauxlib.c
+lbaselib.c
+ldblib.c
+liolib.c
+lmathlib.c
+loadlib.c
+lstrlib.c
+ltablib.c
+lapi.c
+lcode.c
+ldebug.c
+ldo.c
+ldump.c
+lfunc.c
+lgc.c
+llex.c
+lmem.c
+lobject.c
+lopcodes.c
+lparser.c
+lstate.c
+lstring.c
+ltable.c
+ltests.c
+ltm.c
+lundump.c
+lvm.c
+lzio.c
+Linking...
+LIBC.lib(crt0init.obj) : warning LNK4098: defaultlib &quot;msvcrt.lib&quot; conflicts with use of other libs; use /NODEFAULTLIB:library
+
+
+
+&lt;h3&gt;Results&lt;/h3&gt;
+dialogeditor.exe - 0 error(s), 2 warning(s)
+&lt;/pre&gt;
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/Util/deditor/dialogeditor.sln
===================================================================
--- trunk/Util/deditor/dialogeditor.sln	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.sln	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;dialogeditor&quot;, &quot;dialogeditor.vcproj&quot;, &quot;{62A63641-279C-47A0-9F16-C166FB146EE6}&quot;
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Debug.ActiveCfg = Debug|Win32
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Debug.Build.0 = Debug|Win32
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Release.ActiveCfg = Release|Win32
+		{62A63641-279C-47A0-9F16-C166FB146EE6}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal

Added: trunk/Util/deditor/dialogeditor.suo
===================================================================
(Binary files differ)


Property changes on: trunk/Util/deditor/dialogeditor.suo
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/Util/deditor/dialogeditor.vcproj
===================================================================
--- trunk/Util/deditor/dialogeditor.vcproj	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/dialogeditor.vcproj	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,300 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
+&lt;VisualStudioProject
+	ProjectType=&quot;Visual C++&quot;
+	Version=&quot;7.10&quot;
+	Name=&quot;dialogeditor&quot;
+	SccProjectName=&quot;&quot;
+	SccLocalPath=&quot;&quot;&gt;
+	&lt;Platforms&gt;
+		&lt;Platform
+			Name=&quot;Win32&quot;/&gt;
+	&lt;/Platforms&gt;
+	&lt;Configurations&gt;
+		&lt;Configuration
+			Name=&quot;Debug|Win32&quot;
+			OutputDirectory=&quot;.\Debug&quot;
+			IntermediateDirectory=&quot;.\Debug&quot;
+			ConfigurationType=&quot;1&quot;
+			UseOfMFC=&quot;0&quot;
+			ATLMinimizesCRunTimeLibraryUsage=&quot;FALSE&quot;
+			CharacterSet=&quot;2&quot;&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				Optimization=&quot;0&quot;
+				AdditionalIncludeDirectories=&quot;c:\qt\include&quot;
+				PreprocessorDefinitions=&quot;QT_DLL;QT_THREAD_SUPPORT&quot;
+				BasicRuntimeChecks=&quot;3&quot;
+				RuntimeLibrary=&quot;5&quot;
+				UsePrecompiledHeader=&quot;2&quot;
+				PrecompiledHeaderFile=&quot;.\Debug/dialogeditor.pch&quot;
+				AssemblerListingLocation=&quot;.\Debug/&quot;
+				ObjectFile=&quot;.\Debug/&quot;
+				ProgramDataBaseFileName=&quot;.\Debug/&quot;
+				WarningLevel=&quot;3&quot;
+				SuppressStartupBanner=&quot;TRUE&quot;
+				DebugInformationFormat=&quot;4&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				AdditionalDependencies=&quot;qt-mt230nc.lib qtmain.lib qutil.lib&quot;
+				OutputFile=&quot;.\Debug/dialogeditor.exe&quot;
+				LinkIncremental=&quot;1&quot;
+				SuppressStartupBanner=&quot;TRUE&quot;
+				AdditionalLibraryDirectories=&quot;c:\qt\lib&quot;
+				GenerateDebugInformation=&quot;TRUE&quot;
+				ProgramDatabaseFile=&quot;.\Debug/dialogeditor.pdb&quot;
+				SubSystem=&quot;2&quot;
+				TargetMachine=&quot;1&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+				PreprocessorDefinitions=&quot;_DEBUG&quot;
+				MkTypLibCompatible=&quot;TRUE&quot;
+				SuppressStartupBanner=&quot;TRUE&quot;
+				TargetEnvironment=&quot;1&quot;
+				TypeLibraryName=&quot;.\Debug/dialogeditor.tlb&quot;
+				HeaderFileName=&quot;&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+				PreprocessorDefinitions=&quot;_DEBUG&quot;
+				Culture=&quot;1059&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedWrapperGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCAuxiliaryManagedWrapperGeneratorTool&quot;/&gt;
+		&lt;/Configuration&gt;
+		&lt;Configuration
+			Name=&quot;Release|Win32&quot;
+			OutputDirectory=&quot;.\Release&quot;
+			IntermediateDirectory=&quot;.\Release&quot;
+			ConfigurationType=&quot;1&quot;
+			UseOfMFC=&quot;0&quot;
+			ATLMinimizesCRunTimeLibraryUsage=&quot;FALSE&quot;
+			CharacterSet=&quot;2&quot;&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				Optimization=&quot;2&quot;
+				InlineFunctionExpansion=&quot;1&quot;
+				AdditionalIncludeDirectories=&quot;c:\qt\include&quot;
+				PreprocessorDefinitions=&quot;QT_DLL;QT_THREAD_SUPPORT&quot;
+				StringPooling=&quot;TRUE&quot;
+				RuntimeLibrary=&quot;4&quot;
+				EnableFunctionLevelLinking=&quot;TRUE&quot;
+				UsePrecompiledHeader=&quot;2&quot;
+				PrecompiledHeaderFile=&quot;.\Release/dialogeditor.pch&quot;
+				AssemblerListingLocation=&quot;.\Release/&quot;
+				ObjectFile=&quot;.\Release/&quot;
+				ProgramDataBaseFileName=&quot;.\Release/&quot;
+				WarningLevel=&quot;3&quot;
+				SuppressStartupBanner=&quot;TRUE&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				AdditionalDependencies=&quot;qt-mt230nc.lib qtmain.lib qutil.lib&quot;
+				OutputFile=&quot;.\Release/dialogeditor.exe&quot;
+				LinkIncremental=&quot;1&quot;
+				SuppressStartupBanner=&quot;TRUE&quot;
+				AdditionalLibraryDirectories=&quot;c:\qt\lib&quot;
+				ProgramDatabaseFile=&quot;.\Release/dialogeditor.pdb&quot;
+				SubSystem=&quot;2&quot;
+				TargetMachine=&quot;1&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+				PreprocessorDefinitions=&quot;NDEBUG&quot;
+				MkTypLibCompatible=&quot;TRUE&quot;
+				SuppressStartupBanner=&quot;TRUE&quot;
+				TargetEnvironment=&quot;1&quot;
+				TypeLibraryName=&quot;.\Release/dialogeditor.tlb&quot;
+				HeaderFileName=&quot;&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+				PreprocessorDefinitions=&quot;NDEBUG&quot;
+				Culture=&quot;1059&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCWebDeploymentTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedWrapperGeneratorTool&quot;/&gt;
+			&lt;Tool
+				Name=&quot;VCAuxiliaryManagedWrapperGeneratorTool&quot;/&gt;
+		&lt;/Configuration&gt;
+	&lt;/Configurations&gt;
+	&lt;References&gt;
+	&lt;/References&gt;
+	&lt;Files&gt;
+		&lt;Filter
+			Name=&quot;Source Files&quot;
+			Filter=&quot;cpp;c;cxx;rc;def;r;odl;idl;hpj;bat&quot;&gt;
+			&lt;File
+				RelativePath=&quot;application.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;0&quot;
+						PreprocessorDefinitions=&quot;&quot;
+						BasicRuntimeChecks=&quot;3&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;2&quot;
+						PreprocessorDefinitions=&quot;&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;application.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;main.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;0&quot;
+						PreprocessorDefinitions=&quot;&quot;
+						BasicRuntimeChecks=&quot;3&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;2&quot;
+						PreprocessorDefinitions=&quot;&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;mainwidget.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;0&quot;
+						PreprocessorDefinitions=&quot;&quot;
+						BasicRuntimeChecks=&quot;3&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;2&quot;
+						PreprocessorDefinitions=&quot;&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;mainwidget.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;node.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;0&quot;
+						PreprocessorDefinitions=&quot;&quot;
+						BasicRuntimeChecks=&quot;3&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;2&quot;
+						PreprocessorDefinitions=&quot;&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;node.h&quot;&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;generated&quot;
+			Filter=&quot;&quot;&gt;
+			&lt;File
+				RelativePath=&quot;maindialog.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;0&quot;
+						PreprocessorDefinitions=&quot;&quot;
+						BasicRuntimeChecks=&quot;3&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;2&quot;
+						PreprocessorDefinitions=&quot;&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;maindialog.h&quot;&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;moc_application.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;0&quot;
+						PreprocessorDefinitions=&quot;&quot;
+						BasicRuntimeChecks=&quot;3&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;2&quot;
+						PreprocessorDefinitions=&quot;&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;moc_maindialog.cpp&quot;&gt;
+				&lt;FileConfiguration
+					Name=&quot;Debug|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;0&quot;
+						PreprocessorDefinitions=&quot;&quot;
+						BasicRuntimeChecks=&quot;3&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+				&lt;FileConfiguration
+					Name=&quot;Release|Win32&quot;&gt;
+					&lt;Tool
+						Name=&quot;VCCLCompilerTool&quot;
+						Optimization=&quot;2&quot;
+						PreprocessorDefinitions=&quot;&quot;/&gt;
+				&lt;/FileConfiguration&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Resource Files&quot;
+			Filter=&quot;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe&quot;&gt;
+		&lt;/Filter&gt;
+	&lt;/Files&gt;
+	&lt;Globals&gt;
+	&lt;/Globals&gt;
+&lt;/VisualStudioProject&gt;

Added: trunk/Util/deditor/evalanswer.xpm
===================================================================
--- trunk/Util/deditor/evalanswer.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/evalanswer.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *evalanswer_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #00000&quot;,
+&quot;c c #f3f7f3&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaca.......aacaa&quot;,
+&quot;aa..aa...aa..aaa&quot;,
+&quot;a.aaca...aaaa.aa&quot;,
+&quot;a.aaac...aaaa.aa&quot;,
+&quot;aa.aaa...aaa.aaa&quot;,
+&quot;aaa..a...a..aaaa&quot;,
+&quot;aaaaa.....aaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaac...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;
+};

Added: trunk/Util/deditor/fileopen.xpm
===================================================================
--- trunk/Util/deditor/fileopen.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/fileopen.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *fileopen[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #f3f704&quot;,
+&quot;c c #f3f7f3&quot;,
+&quot;aaaaaaaaa...aaaa&quot;,
+&quot;aaaaaaaa.aaa.a.a&quot;,
+&quot;aaaaaaaaaaaaa..a&quot;,
+&quot;a...aaaaaaaa...a&quot;,
+&quot;.bcb.......aaaaa&quot;,
+&quot;.cbcbcbcbc.aaaaa&quot;,
+&quot;.bcbcbcbcb.aaaaa&quot;,
+&quot;.cbcb...........&quot;,
+&quot;.bcb.#########.a&quot;,
+&quot;.cb.#########.aa&quot;,
+&quot;.b.#########.aaa&quot;,
+&quot;..#########.aaaa&quot;,
+&quot;...........aaaaa&quot;
+};

Added: trunk/Util/deditor/filesave.xpm
===================================================================
--- trunk/Util/deditor/filesave.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/filesave.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *filesave[] = {
+&quot;    14    14        4            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c #bfc2bf&quot;,
+&quot;b c None&quot;,
+&quot;..............&quot;,
+&quot;.#.aaaaaaaa.a.&quot;,
+&quot;.#.aaaaaaaa...&quot;,
+&quot;.#.aaaaaaaa.#.&quot;,
+&quot;.#.aaaaaaaa.#.&quot;,
+&quot;.#.aaaaaaaa.#.&quot;,
+&quot;.#.aaaaaaaa.#.&quot;,
+&quot;.##........##.&quot;,
+&quot;.############.&quot;,
+&quot;.##.........#.&quot;,
+&quot;.##......aa.#.&quot;,
+&quot;.##......aa.#.&quot;,
+&quot;.##......aa.#.&quot;,
+&quot;b.............&quot;
+};

Added: trunk/Util/deditor/gui.bat
===================================================================
--- trunk/Util/deditor/gui.bat	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/gui.bat	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,5 @@
+uic -o maindialog.h MainDialog.ui
+uic -i maindialog.h -o maindialog.cpp MainDialog.ui
+moc -o moc_maindialog.cpp maindialog.h
+moc -o moc_application.cpp application.h
+moc -o moc_node.cpp node.h

Added: trunk/Util/deditor/helpers.cpp
===================================================================
--- trunk/Util/deditor/helpers.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/helpers.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,33 @@
+#include &lt;qstring.h&gt;
+#include &lt;qregexp.h&gt;
+#include &lt;qdir.h&gt;
+#include &lt;qmessagebox.h&gt;
+
+#include &lt;stdio.h&gt;
+
+static FILE * log = NULL;
+static int log_inited = 0;
+
+void WriteLog(QString str)
+{
+	if(!log_inited)
+	{
+		log_inited = 1;
+		log = fopen(QDir::currentDirPath() + &quot;/dedit.log&quot;, &quot;w+&quot;);
+	}
+	if(log)
+	{
+		fprintf(log, &quot;%s&quot;, (const char*)str);
+		fflush(log);
+	}
+}
+
+QString TWEscapeXML(QString str)
+{
+	str.replace(QRegExp(&quot;&amp;&quot;),&quot;&amp;&quot;);
+	str.replace(QRegExp(&quot;&gt;&quot;),&quot;&gt;&quot;);
+	str.replace(QRegExp(&quot;&lt;&quot;),&quot;&lt;&quot;);
+	str.replace(QRegExp(&quot;\&quot;&quot;),&quot;&quot;&quot;);
+
+	return str;
+}
\ No newline at end of file

Added: trunk/Util/deditor/helpers.h
===================================================================
--- trunk/Util/deditor/helpers.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/helpers.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,10 @@
+#ifndef __TW_HELPERS_H__
+#define __TW_HELPERS_H__
+
+#include &lt;qstring.h&gt;
+
+
+QString TWEscapeXML(QString str);
+void WriteLog(QString str);
+
+#endif

Added: trunk/Util/deditor/itemdown.xpm
===================================================================
--- trunk/Util/deditor/itemdown.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/itemdown.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *answerdown_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #ffff00&quot;,
+&quot;c c #00ffff&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;..aaaaaaaaaaa..a&quot;,
+&quot;..aaaaaaaaaaa..a&quot;,
+&quot;a..aaaaaaaaa..aa&quot;,
+&quot;aa..aaaaaaa..aaa&quot;,
+&quot;aaa..aaaaa..aaaa&quot;,
+&quot;aaaa..aaa..aaaaa&quot;,
+&quot;aaaaa..a..aaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaaaa.aaaaaaaa&quot;
+};

Added: trunk/Util/deditor/itemup.xpm
===================================================================
--- trunk/Util/deditor/itemup.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/itemup.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *answerup_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #ffff00&quot;,
+&quot;c c #00ffff&quot;,
+&quot;aaaaaaaa.aaaaaaa&quot;,
+&quot;aaaaaaa...aaaaaa&quot;,
+&quot;aaaaaa..a..aaaaa&quot;,
+&quot;aaaaa..aaa..aaaa&quot;,
+&quot;aaaa..aaaaa..aaa&quot;,
+&quot;aaa..aaaaaaa..aa&quot;,
+&quot;aa..aaaaaaaaa..a&quot;,
+&quot;a..aaaaaaaaaaa..&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;
+};

Added: trunk/Util/deditor/lua/Makefile
===================================================================
--- trunk/Util/deditor/lua/Makefile	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/Makefile	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,85 @@
+# makefile for Lua core library
+
+LUA= ..
+
+include $(LUA)/config
+
+OBJS=	\
+	lapi.o \
+	lcode.o \
+	ldebug.o \
+	ldo.o \
+	ldump.o \
+	lfunc.o \
+	lgc.o \
+	llex.o \
+	lmem.o \
+	lobject.o \
+	lopcodes.o \
+	lparser.o \
+	lstate.o \
+	lstring.o \
+	ltable.o \
+	ltests.o \
+	ltm.o \
+	lundump.o \
+	lvm.o \
+	lzio.o
+
+SRCS=	\
+	lapi.c \
+	lcode.c \
+	ldebug.c \
+	ldo.c \
+	ldump.c \
+	lfunc.c \
+	lgc.c \
+	llex.c \
+	lmem.c \
+	lobject.c \
+	lopcodes.c \
+	lparser.c \
+	lstate.c \
+	lstring.c \
+	ltable.c \
+	ltests.c \
+	ltm.c \
+	lundump.c \
+	lvm.c \
+	lzio.c \
+	lapi.h \
+	lcode.h \
+	ldebug.h \
+	ldo.h \
+	lfunc.h \
+	lgc.h \
+	llex.h \
+	llimits.h \
+	lmem.h \
+	lobject.h \
+	lopcodes.h \
+	lparser.h \
+	lstate.h \
+	lstring.h \
+	ltable.h \
+	ltm.h \
+	lundump.h \
+	lvm.h \
+	lzio.h
+
+T= $(LIB)/liblua.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/Util/deditor/lua/README
===================================================================
--- trunk/Util/deditor/lua/README	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/README	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,5 @@
+This is the Lua core.
+
+The standard Lua library are in lib/.
+A sample interpreter is in lua/.
+A standalone compiler is in luac/.

Added: trunk/Util/deditor/lua/lapi.c
===================================================================
--- trunk/Util/deditor/lua/lapi.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lapi.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,922 @@
+/*
+** $Id: lapi.c,v 1.235 2003/04/07 14:36:08 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#define lapi_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lapi.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lundump.h&quot;
+#include &quot;lvm.h&quot;
+
+
+const char lua_ident[] =
+  &quot;$Lua: &quot; LUA_VERSION &quot; &quot; LUA_COPYRIGHT &quot; $\n&quot;
+  &quot;$Authors: &quot; LUA_AUTHORS &quot; $\n&quot;
+  &quot;$URL: www.lua.org $\n&quot;;
+
+
+
+#ifndef api_check
+#define api_check(L, o)		/*{ assert(o); }*/
+#endif
+
+#define api_checknelems(L, n)	api_check(L, (n) &lt;= (L-&gt;top - L-&gt;base))
+
+#define api_incr_top(L)   {api_check(L, L-&gt;top &lt; L-&gt;ci-&gt;top); L-&gt;top++;}
+
+
+
+
+static TObject *negindex (lua_State *L, int idx) {
+  if (idx &gt; LUA_REGISTRYINDEX) {
+    api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);
+    return L-&gt;top+idx;
+  }
+  else switch (idx) {  /* pseudo-indices */
+    case LUA_REGISTRYINDEX: return registry(L);
+    case LUA_GLOBALSINDEX: return gt(L);
+    default: {
+      TObject *func = (L-&gt;base - 1);
+      idx = LUA_GLOBALSINDEX - idx;
+      lua_assert(iscfunction(func));
+      return (idx &lt;= clvalue(func)-&gt;c.nupvalues)
+                ? &amp;clvalue(func)-&gt;c.upvalue[idx-1]
+                : NULL;
+    }
+  }
+}
+
+
+static TObject *luaA_index (lua_State *L, int idx) {
+  if (idx &gt; 0) {
+    api_check(L, idx &lt;= L-&gt;top - L-&gt;base);
+    return L-&gt;base + idx - 1;
+  }
+  else {
+    TObject *o = negindex(L, idx);
+    api_check(L, o != NULL);
+    return o;
+  }
+}
+
+
+static TObject *luaA_indexAcceptable (lua_State *L, int idx) {
+  if (idx &gt; 0) {
+    TObject *o = L-&gt;base+(idx-1);
+    api_check(L, idx &lt;= L-&gt;stack_last - L-&gt;base);
+    if (o &gt;= L-&gt;top) return NULL;
+    else return o;
+  }
+  else
+    return negindex(L, idx);
+}
+
+
+void luaA_pushobject (lua_State *L, const TObject *o) {
+  setobj2s(L-&gt;top, o);
+  incr_top(L);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  lua_lock(L);
+  if ((L-&gt;top - L-&gt;base + size) &gt; LUA_MAXCSTACK)
+    res = 0;  /* stack overflow */
+  else {
+    luaD_checkstack(L, size);
+    if (L-&gt;ci-&gt;top &lt; L-&gt;top + size)
+      L-&gt;ci-&gt;top = L-&gt;top + size;
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  lua_lock(to);
+  api_checknelems(from, n);
+  from-&gt;top -= n;
+  for (i = 0; i &lt; n; i++) {
+    setobj2s(to-&gt;top, from-&gt;top + i);
+    api_incr_top(to);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)-&gt;panic;
+  G(L)-&gt;panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = luaE_newthread(L);
+  setthvalue(L-&gt;top, L1);
+  api_incr_top(L);
+  lua_unlock(L);
+  lua_userstateopen(L1);
+  return L1;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return (L-&gt;top - L-&gt;base);
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  lua_lock(L);
+  if (idx &gt;= 0) {
+    api_check(L, idx &lt;= L-&gt;stack_last - L-&gt;base);
+    while (L-&gt;top &lt; L-&gt;base + idx)
+      setnilvalue(L-&gt;top++);
+    L-&gt;top = L-&gt;base + idx;
+  }
+  else {
+    api_check(L, -(idx+1) &lt;= (L-&gt;top - L-&gt;base));
+    L-&gt;top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  while (++p &lt; L-&gt;top) setobjs2s(p-1, p);
+  L-&gt;top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  for (q = L-&gt;top; q&gt;p; q--) setobjs2s(q, q-1);
+  setobjs2s(p, L-&gt;top);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  setobj(luaA_index(L, idx), L-&gt;top - 1);  /* write barrier */
+  L-&gt;top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L-&gt;top, luaA_index(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -&gt; C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? LUA_TNONE : ttype(o);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return (t == LUA_TNONE) ? &quot;no value&quot; : luaT_typenames[t];
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? 0 : iscfunction(o);
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL &amp;&amp; tonumber(o, &amp;n));
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL &amp;&amp; (ttisuserdata(o) || ttislightuserdata(o)));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = luaA_indexAcceptable(L, index1);
+  StkId o2 = luaA_indexAcceptable(L, index2);
+  return (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                    : luaO_rawequalObj(o1, o2);
+}
+
+
+LUA_API int lua_equal (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                 : equalobj(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out-of-range */
+                                 : luaV_lessthan(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+
+LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  if (o != NULL &amp;&amp; tonumber(o, &amp;n))
+    return nvalue(o);
+  else
+    return 0;
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL) &amp;&amp; !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tostring (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return NULL;
+  else if (ttisstring(o))
+    return svalue(o);
+  else {
+    const char *s;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    s = (luaV_tostring(L, o) ? svalue(o) : NULL);
+    luaC_checkGC(L);
+    lua_unlock(L);
+    return s;
+  }
+}
+
+
+LUA_API size_t lua_strlen (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return 0;
+  else if (ttisstring(o))
+    return tsvalue(o)-&gt;tsv.len;
+  else {
+    size_t l;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    l = (luaV_tostring(L, o) ? tsvalue(o)-&gt;tsv.len : 0);
+    lua_unlock(L);
+    return l;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !iscfunction(o)) ? NULL : clvalue(o)-&gt;c.f;
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  switch (ttype(o)) {
+    case LUA_TUSERDATA: return (uvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  else {
+    switch (ttype(o)) {
+      case LUA_TTABLE: return hvalue(o);
+      case LUA_TFUNCTION: return clvalue(o);
+      case LUA_TTHREAD: return thvalue(o);
+      case LUA_TUSERDATA:
+      case LUA_TLIGHTUSERDATA:
+        return lua_touserdata(L, idx);
+      default: return NULL;
+    }
+  }
+}
+
+
+
+/*
+** push functions (C -&gt; stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L-&gt;top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L-&gt;top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  setsvalue2s(L-&gt;top, luaS_newlstr(L, s, len));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL)
+    lua_pushnil(L);
+  else
+    lua_pushlstring(L, s, strlen(s));
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  Closure *cl;
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  cl = luaF_newCclosure(L, n);
+  cl-&gt;c.f = fn;
+  L-&gt;top -= n;
+  while (n--)
+    setobj2n(&amp;cl-&gt;c.upvalue[n], L-&gt;top+n);
+  setclvalue(L-&gt;top, cl);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L-&gt;top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L-&gt;top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** get functions (Lua -&gt; stack)
+*/
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  setobj2s(L-&gt;top - 1, luaV_gettable(L, t, L-&gt;top - 1, 0));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2s(L-&gt;top - 1, luaH_get(hvalue(t), L-&gt;top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2s(L-&gt;top, luaH_getnum(hvalue(o), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_newtable (lua_State *L) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  sethvalue(L-&gt;top, luaH_new(L, 0, 0));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TObject *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = luaA_indexAcceptable(L, objindex);
+  if (obj != NULL) {
+    switch (ttype(obj)) {
+      case LUA_TTABLE:
+        mt = hvalue(obj)-&gt;metatable;
+        break;
+      case LUA_TUSERDATA:
+        mt = uvalue(obj)-&gt;uv.metatable;
+        break;
+    }
+  }
+  if (mt == NULL || mt == hvalue(defaultmeta(L)))
+    res = 0;
+  else {
+    sethvalue(L-&gt;top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getfenv (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  setobj2s(L-&gt;top, isLfunction(o) ? &amp;clvalue(o)-&gt;l.g : gt(L));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -&gt; Lua)
+*/
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  luaV_settable(L, t, L-&gt;top - 2, L-&gt;top - 1);
+  L-&gt;top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2t(luaH_set(L, hvalue(t), L-&gt;top-2), L-&gt;top-1);  /* write barrier */
+  L-&gt;top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2t(luaH_setnum(L, hvalue(o), n), L-&gt;top-1);  /* write barrier */
+  L-&gt;top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TObject *obj, *mt;
+  int res = 1;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = luaA_index(L, objindex);
+  mt = (!ttisnil(L-&gt;top - 1)) ? L-&gt;top - 1 : defaultmeta(L);
+  api_check(L, ttistable(mt));
+  switch (ttype(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)-&gt;metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)-&gt;uv.metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    default: {
+      res = 0;  /* cannot set */
+      break;
+    }
+  }
+  L-&gt;top--;
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API int lua_setfenv (lua_State *L, int idx) {
+  StkId o;
+  int res = 0;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  L-&gt;top--;
+  api_check(L, ttistable(L-&gt;top));
+  if (isLfunction(o)) {
+    res = 1;
+    clvalue(o)-&gt;l.g = *(L-&gt;top);
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
+  StkId func;
+  lua_lock(L);
+  api_checknelems(L, nargs+1);
+  func = L-&gt;top - (nargs+1);
+  luaD_call(L, func, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c-&gt;func, c-&gt;nresults);
+}
+
+
+
+LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  func = (errfunc == 0) ? 0 : savestack(L, luaA_index(L, errfunc));
+  c.func = L-&gt;top - (nargs+1);  /* function to be called */
+  c.nresults = nresults;
+  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Execute a protected C call.
+*/
+struct CCallS {  /* data to `f_Ccall' */
+  lua_CFunction func;
+  void *ud;
+};
+
+
+static void f_Ccall (lua_State *L, void *ud) {
+  struct CCallS *c = cast(struct CCallS *, ud);
+  Closure *cl;
+  cl = luaF_newCclosure(L, 0);
+  cl-&gt;c.f = c-&gt;func;
+  setclvalue(L-&gt;top, cl);  /* push function */
+  incr_top(L);
+  setpvalue(L-&gt;top, c-&gt;ud);  /* push only argument */
+  incr_top(L);
+  luaD_call(L, L-&gt;top - 2, 0);
+}
+
+
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
+  struct CCallS c;
+  int status;
+  lua_lock(L);
+  c.func = func;
+  c.ud = ud;
+  status = luaD_pcall(L, f_Ccall, &amp;c, savestack(L, L-&gt;top), 0);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Chunkreader reader, void *data,
+                      const char *chunkname) {
+  ZIO z;
+  int status;
+  int c;
+  lua_lock(L);
+  if (!chunkname) chunkname = &quot;?&quot;;
+  luaZ_init(&amp;z, reader, data, chunkname);
+  c = luaZ_lookahead(&amp;z);
+  status = luaD_protectedparser(L, &amp;z, (c == LUA_SIGNATURE[0]));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data) {
+  int status;
+  TObject *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L-&gt;top - 1;
+  if (isLfunction(o) &amp;&amp; clvalue(o)-&gt;l.nupvalues == 0) {
+    luaU_dump(L, clvalue(o)-&gt;l.p, writer, data);
+    status = 1;
+  }
+  else
+    status = 0;
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Garbage-collection functions
+*/
+
+/* GC values are expressed in Kbytes: #bytes/2^10 */
+#define GCscalel(x)		((x)&gt;&gt;10)
+#define GCscale(x)		(cast(int, GCscalel(x)))
+#define GCunscale(x)		(cast(lu_mem, x)&lt;&lt;10)
+
+LUA_API int lua_getgcthreshold (lua_State *L) {
+  int threshold;
+  lua_lock(L);
+  threshold = GCscale(G(L)-&gt;GCthreshold);
+  lua_unlock(L);
+  return threshold;
+}
+
+LUA_API int lua_getgccount (lua_State *L) {
+  int count;
+  lua_lock(L);
+  count = GCscale(G(L)-&gt;nblocks);
+  lua_unlock(L);
+  return count;
+}
+
+LUA_API void lua_setgcthreshold (lua_State *L, int newthreshold) {
+  lua_lock(L);
+  if (cast(lu_mem, newthreshold) &gt; GCscalel(MAX_LUMEM))
+    G(L)-&gt;GCthreshold = MAX_LUMEM;
+  else
+    G(L)-&gt;GCthreshold = GCunscale(newthreshold);
+  luaC_checkGC(L);
+  lua_unlock(L);
+}
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API const char *lua_version (void) {
+  return LUA_VERSION;
+}
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  lua_unlock(L);
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  more = luaH_next(L, hvalue(t), L-&gt;top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L-&gt;top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  if (n &gt;= 2) {
+    luaV_concat(L, n, L-&gt;top - L-&gt;base - 1);
+    L-&gt;top -= (n-1);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L-&gt;top, luaS_newlstr(L, NULL, 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size);
+  setuvalue(L-&gt;top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+LUA_API int lua_pushupvalues (lua_State *L) {
+  Closure *func;
+  int n, i;
+  lua_lock(L);
+  api_check(L, iscfunction(L-&gt;base - 1));
+  func = clvalue(L-&gt;base - 1);
+  n = func-&gt;c.nupvalues;
+  luaD_checkstack(L, n + LUA_MINSTACK);
+  for (i=0; i&lt;n; i++) {
+    setobj2s(L-&gt;top, &amp;func-&gt;c.upvalue[i]);
+    L-&gt;top++;
+  }
+  lua_unlock(L);
+  return n;
+}
+
+
+static const char *aux_upvalue (lua_State *L, int funcindex, int n,
+                                TObject **val) {
+  Closure *f;
+  StkId fi = luaA_index(L, funcindex);
+  if (!ttisfunction(fi)) return NULL;
+  f = clvalue(fi);
+  if (f-&gt;c.isC) {
+    if (n &gt; f-&gt;c.nupvalues) return NULL;
+    *val = &amp;f-&gt;c.upvalue[n-1];
+    return &quot;&quot;;
+  }
+  else {
+    Proto *p = f-&gt;l.p;
+    if (n &gt; p-&gt;sizeupvalues) return NULL;
+    *val = f-&gt;l.upvals[n-1]-&gt;v;
+    return getstr(p-&gt;upvalues[n-1]);
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  name = aux_upvalue(L, funcindex, n, &amp;val);
+  if (name) {
+    setobj2s(L-&gt;top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  name = aux_upvalue(L, funcindex, n, &amp;val);
+  if (name) {
+    L-&gt;top--;
+    setobj(val, L-&gt;top);  /* write barrier */
+  }
+  lua_unlock(L);
+  return name;
+}
+

Added: trunk/Util/deditor/lua/lapi.h
===================================================================
--- trunk/Util/deditor/lua/lapi.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lapi.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,16 @@
+/*
+** $Id: lapi.h,v 1.21 2002/03/04 21:29:41 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include &quot;lobject.h&quot;
+
+
+void luaA_pushobject (lua_State *L, const TObject *o);
+
+#endif

Added: trunk/Util/deditor/lua/lauxlib.h
===================================================================
--- trunk/Util/deditor/lua/lauxlib.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lauxlib.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,145 @@
+/*
+** $Id: lauxlib.h,v 1.60 2003/04/03 13:35:34 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include &lt;stddef.h&gt;
+#include &lt;stdio.h&gt;
+
+#include &quot;lua.h&quot;
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+
+typedef struct luaL_reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_reg;
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_reg *l, int nup);
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname);
+LUALIB_API int luaL_argerror (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *luaL_checklstring (lua_State *L, int numArg, size_t *l);
+LUALIB_API const char *luaL_optlstring (lua_State *L, int numArg,
+                                           const char *def, size_t *l);
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int numArg);
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API void luaL_checkstack (lua_State *L, int sz, const char *msg);
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t);
+LUALIB_API void luaL_checkany (lua_State *L, int narg);
+
+LUALIB_API int   luaL_newmetatable (lua_State *L, const char *tname);
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname);
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void luaL_where (lua_State *L, int lvl);
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int luaL_findstring (const char *st, const char *const lst[]);
+
+LUALIB_API int luaL_ref (lua_State *L, int t);
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref);
+
+LUALIB_API int luaL_getn (lua_State *L, int t);
+LUALIB_API void luaL_setn (lua_State *L, int t, int n);
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename);
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz,
+                                const char *name);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define luaL_argcheck(L, cond,numarg,extramsg) if (!(cond)) \
+                                               luaL_argerror(L, numarg,extramsg)
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checknumber(L, n))
+#define luaL_checklong(L,n)	((long)luaL_checknumber(L, n))
+#define luaL_optint(L,n,d)	((int)luaL_optnumber(L, n,(lua_Number)(d)))
+#define luaL_optlong(L,n,d)	((long)luaL_optnumber(L, n,(lua_Number)(d)))
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#ifndef LUAL_BUFFERSIZE
+#define LUAL_BUFFERSIZE	  BUFSIZ
+#endif
+
+
+typedef struct luaL_Buffer {
+  char *p;			/* current position in buffer */
+  int lvl;  /* number of strings in the stack (level) */
+  lua_State *L;
+  char buffer[LUAL_BUFFERSIZE];
+} luaL_Buffer;
+
+#define luaL_putchar(B,c) \
+  ((void)((B)-&gt;p &lt; ((B)-&gt;buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
+   (*(B)-&gt;p++ = (char)(c)))
+
+#define luaL_addsize(B,n)	((B)-&gt;p += (n))
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B);
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s);
+LUALIB_API void luaL_addvalue (luaL_Buffer *B);
+LUALIB_API void luaL_pushresult (luaL_Buffer *B);
+
+
+/* }====================================================== */
+
+
+
+/*
+** Compatibility macros and functions
+*/
+
+LUALIB_API int   lua_dofile (lua_State *L, const char *filename);
+LUALIB_API int   lua_dostring (lua_State *L, const char *str);
+LUALIB_API int   lua_dobuffer (lua_State *L, const char *buff, size_t sz,
+                               const char *n);
+
+
+#define luaL_check_lstr 	luaL_checklstring
+#define luaL_opt_lstr 	luaL_optlstring 
+#define luaL_check_number 	luaL_checknumber 
+#define luaL_opt_number	luaL_optnumber
+#define luaL_arg_check	luaL_argcheck
+#define luaL_check_string	luaL_checkstring
+#define luaL_opt_string	luaL_optstring
+#define luaL_check_int	luaL_checkint
+#define luaL_check_long	luaL_checklong
+#define luaL_opt_int	luaL_optint
+#define luaL_opt_long	luaL_optlong
+
+
+#endif
+
+

Added: trunk/Util/deditor/lua/lcode.c
===================================================================
--- trunk/Util/deditor/lua/lcode.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lcode.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,714 @@
+/*
+** $Id: lcode.c,v 1.117 2003/04/03 13:35:34 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lcode_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;ltable.h&quot;
+
+
+#define hasjumps(e)	((e)-&gt;t != (e)-&gt;f)
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  if (fs-&gt;pc &gt; fs-&gt;lasttarget &amp;&amp;  /* no jumps to current position? */
+      GET_OPCODE(*(previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1])) == OP_LOADNIL) {
+    int pfrom = GETARG_A(*previous);
+    int pto = GETARG_B(*previous);
+    if (pfrom &lt;= from &amp;&amp; from &lt;= pto+1) {  /* can connect both? */
+      if (from+n-1 &gt; pto)
+        SETARG_B(*previous, from+n-1);
+      return;
+    }
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, from+n-1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs-&gt;jpc;  /* save list of jumps to here */
+  int j;
+  fs-&gt;jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &amp;j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+static int luaK_condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void luaK_fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &amp;fs-&gt;f-&gt;code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) &gt; MAXARG_sBx)
+    luaX_syntaxerror(fs-&gt;ls, &quot;control structure too long&quot;);
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs-&gt;lasttarget = fs-&gt;pc;
+  return fs-&gt;pc;
+}
+
+
+static int luaK_getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs-&gt;f-&gt;code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &amp;fs-&gt;f-&gt;code[pc];
+  if (pc &gt;= 1 &amp;&amp; testOpMode(GET_OPCODE(*(pi-1)), OpModeT))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list, int cond) {
+  for (; list != NO_JUMP; list = luaK_getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TEST || GETARG_C(i) != cond) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static void patchtestreg (Instruction *i, int reg) {
+  if (reg == NO_REG) reg = GETARG_B(*i);
+  SETARG_A(*i, reg);
+}
+
+
+static void luaK_patchlistaux (FuncState *fs, int list,
+          int ttarget, int treg, int ftarget, int freg, int dtarget) {
+  while (list != NO_JUMP) {
+    int next = luaK_getjump(fs, list);
+    Instruction *i = getjumpcontrol(fs, list);
+    if (GET_OPCODE(*i) != OP_TEST) {
+      lua_assert(dtarget != NO_JUMP);
+      luaK_fixjump(fs, list, dtarget);  /* jump to default target */
+    }
+    else {
+      if (GETARG_C(*i)) {
+        lua_assert(ttarget != NO_JUMP);
+        patchtestreg(i, treg);
+        luaK_fixjump(fs, list, ttarget);
+      }
+      else {
+        lua_assert(ftarget != NO_JUMP);
+        patchtestreg(i, freg);
+        luaK_fixjump(fs, list, ftarget);
+      }
+    }
+    list = next;
+  }
+}
+
+
+static void luaK_dischargejpc (FuncState *fs) {
+  luaK_patchlistaux(fs, fs-&gt;jpc, fs-&gt;pc, NO_REG, fs-&gt;pc, NO_REG, fs-&gt;pc);
+  fs-&gt;jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs-&gt;pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target &lt; fs-&gt;pc);
+    luaK_patchlistaux(fs, list, target, NO_REG, target, NO_REG, target);
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &amp;fs-&gt;jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = luaK_getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    luaK_fixjump(fs, list, l2);
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs-&gt;freereg + n;
+  if (newstack &gt; fs-&gt;f-&gt;maxstacksize) {
+    if (newstack &gt;= MAXSTACK)
+      luaX_syntaxerror(fs-&gt;ls, &quot;function or expression too complex&quot;);
+    fs-&gt;f-&gt;maxstacksize = cast(lu_byte, newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs-&gt;freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (reg &gt;= fs-&gt;nactvar &amp;&amp; reg &lt; MAXSTACK) {
+    fs-&gt;freereg--;
+    lua_assert(reg == fs-&gt;freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e-&gt;k == VNONRELOC)
+    freereg(fs, e-&gt;info);
+}
+
+
+static int addk (FuncState *fs, TObject *k, TObject *v) {
+  const TObject *idx = luaH_get(fs-&gt;h, k);
+  if (ttisnumber(idx)) {
+    lua_assert(luaO_rawequalObj(&amp;fs-&gt;f-&gt;k[cast(int, nvalue(idx))], v));
+    return cast(int, nvalue(idx));
+  }
+  else {  /* constant not found; create a new entry */
+    Proto *f = fs-&gt;f;
+    luaM_growvector(fs-&gt;L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TObject,
+                    MAXARG_Bx, &quot;constant table overflow&quot;);
+    setobj2n(&amp;f-&gt;k[fs-&gt;nk], v);
+    setnvalue(luaH_set(fs-&gt;L, fs-&gt;h, k), cast(lua_Number, fs-&gt;nk));
+    return fs-&gt;nk++;
+  }
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TObject o;
+  setsvalue(&amp;o, s);
+  return addk(fs, &amp;o, &amp;o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  TObject o;
+  setnvalue(&amp;o, r);
+  return addk(fs, &amp;o, &amp;o);
+}
+
+
+static int nil_constant (FuncState *fs) {
+  TObject k, v;
+  setnilvalue(&amp;v);
+  sethvalue(&amp;k, fs-&gt;h);  /* cannot use nil as key; instead use table itself */
+  return addk(fs, &amp;k, &amp;v);
+}
+
+
+void luaK_setcallreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e-&gt;k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+    if (nresults == 1) {  /* `regular' expression? */
+      e-&gt;k = VNONRELOC;
+      e-&gt;info = GETARG_A(getcode(fs, e));
+    }
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e-&gt;k) {
+    case VLOCAL: {
+      e-&gt;k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e-&gt;info = luaK_codeABC(fs, OP_GETUPVAL, 0, e-&gt;info, 0);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    case VGLOBAL: {
+      e-&gt;info = luaK_codeABx(fs, OP_GETGLOBAL, 0, e-&gt;info);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      freereg(fs, e-&gt;aux);
+      freereg(fs, e-&gt;info);
+      e-&gt;info = luaK_codeABC(fs, OP_GETTABLE, 0, e-&gt;info, e-&gt;aux);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    case VCALL: {
+      luaK_setcallreturns(fs, e, 1);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE:  case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e-&gt;k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codeABx(fs, OP_LOADK, reg, e-&gt;info);
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &amp;getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e-&gt;info)
+        luaK_codeABC(fs, OP_MOVE, reg, e-&gt;info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e-&gt;k == VVOID || e-&gt;k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e-&gt;info = reg;
+  e-&gt;k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e-&gt;k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs-&gt;freereg-1);
+  }
+}
+
+
+static void luaK_exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e-&gt;k == VJMP)
+    luaK_concat(fs, &amp;e-&gt;t, e-&gt;info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e-&gt;t, 1) || need_value(fs, e-&gt;f, 0)) {
+      int fj = NO_JUMP;  /* first jump (over LOAD ops.) */
+      if (e-&gt;k != VJMP)
+        fj = luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    luaK_patchlistaux(fs, e-&gt;f, p_f, NO_REG, final, reg, p_f);
+    luaK_patchlistaux(fs, e-&gt;t, final, reg, p_t, NO_REG, p_t);
+  }
+  e-&gt;f = e-&gt;t = NO_JUMP;
+  e-&gt;info = reg;
+  e-&gt;k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  luaK_exp2reg(fs, e, fs-&gt;freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e-&gt;k == VNONRELOC) {
+    if (!hasjumps(e)) return e-&gt;info;  /* exp is already in a register */ 
+    if (e-&gt;info &gt;= fs-&gt;nactvar) {  /* reg. is not a local? */
+      luaK_exp2reg(fs, e, e-&gt;info);  /* put value on it */
+      return e-&gt;info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e-&gt;info;
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: {
+      if (fs-&gt;nk + MAXSTACK &lt;= MAXARG_C) {  /* constant fit in argC? */
+        e-&gt;info = nil_constant(fs);
+        e-&gt;k = VK;
+        return e-&gt;info + MAXSTACK;
+      }
+      else break;
+    }
+    case VK: {
+      if (e-&gt;info + MAXSTACK &lt;= MAXARG_C)  /* constant fit in argC? */
+        return e-&gt;info + MAXSTACK;
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *exp) {
+  switch (var-&gt;k) {
+    case VLOCAL: {
+      freeexp(fs, exp);
+      luaK_exp2reg(fs, exp, var-&gt;info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var-&gt;info, 0);
+      break;
+    }
+    case VGLOBAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABx(fs, OP_SETGLOBAL, e, var-&gt;info);
+      break;
+    }
+    case VINDEXED: {
+      int e = luaK_exp2RK(fs, exp);
+      luaK_codeABC(fs, OP_SETTABLE, var-&gt;info, var-&gt;aux, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, exp);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int func;
+  luaK_exp2anyreg(fs, e);
+  freeexp(fs, e);
+  func = fs-&gt;freereg;
+  luaK_reserveregs(fs, 2);
+  luaK_codeABC(fs, OP_SELF, func, e-&gt;info, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+  e-&gt;info = func;
+  e-&gt;k = VNONRELOC;
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e-&gt;info);
+  lua_assert(testOpMode(GET_OPCODE(*pc), OpModeT) &amp;&amp;
+             GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e-&gt;k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs-&gt;pc--;  /* remove previous OP_NOT */
+      return luaK_condjump(fs, OP_TEST, NO_REG, GETARG_B(ie), !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return luaK_condjump(fs, OP_TEST, NO_REG, e-&gt;info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VK: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    case VFALSE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e-&gt;info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &amp;e-&gt;f, pc);  /* insert last jump in `f' list */
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    case VTRUE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      pc = e-&gt;info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &amp;e-&gt;t, pc);  /* insert last jump in `t' list */
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: case VFALSE: {
+      e-&gt;k = VTRUE;
+      break;
+    }
+    case VK: case VTRUE: {
+      e-&gt;k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e-&gt;info = luaK_codeABC(fs, OP_NOT, 0, e-&gt;info, 0);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  t-&gt;aux = luaK_exp2RK(fs, k);
+  t-&gt;k = VINDEXED;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
+  if (op == OPR_MINUS) {
+    luaK_exp2val(fs, e);
+    if (e-&gt;k == VK &amp;&amp; ttisnumber(&amp;fs-&gt;f-&gt;k[e-&gt;info]))
+      e-&gt;info = luaK_numberK(fs, -nvalue(&amp;fs-&gt;f-&gt;k[e-&gt;info]));
+    else {
+      luaK_exp2anyreg(fs, e);
+      freeexp(fs, e);
+      e-&gt;info = luaK_codeABC(fs, OP_UNM, 0, e-&gt;info, 0);
+      e-&gt;k = VRELOCABLE;
+    }
+  }
+  else  /* op == NOT */
+    codenot(fs, e);
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      luaK_patchtohere(fs, v-&gt;t);
+      v-&gt;t = NO_JUMP;
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      luaK_patchtohere(fs, v-&gt;f);
+      v-&gt;f = NO_JUMP;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+static void codebinop (FuncState *fs, expdesc *res, BinOpr op,
+                       int o1, int o2) {
+  if (op &lt;= OPR_POW) {  /* arithmetic operator? */
+    OpCode opc = cast(OpCode, (op - OPR_ADD) + OP_ADD);  /* ORDER OP */
+    res-&gt;info = luaK_codeABC(fs, opc, 0, o1, o2);
+    res-&gt;k = VRELOCABLE;
+  }
+  else {  /* test operator */
+    static const OpCode ops[] = {OP_EQ, OP_EQ, OP_LT, OP_LE, OP_LT, OP_LE};
+    int cond = 1;
+    if (op &gt;= OPR_GT) {  /* `&gt;' or `&gt;='? */
+      int temp;  /* exchange args and replace by `&lt;' or `&lt;=' */
+      temp = o1; o1 = o2; o2 = temp;  /* o1 &lt;==&gt; o2 */
+    }
+    else if (op == OPR_NE) cond = 0;
+    res-&gt;info = luaK_condjump(fs, ops[op - OPR_NE], cond, o1, o2);
+    res-&gt;k = VJMP;
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1-&gt;t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &amp;e1-&gt;f, e2-&gt;f);
+      e1-&gt;k = e2-&gt;k; e1-&gt;info = e2-&gt;info; e1-&gt;aux = e2-&gt;aux; e1-&gt;t = e2-&gt;t;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1-&gt;f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &amp;e1-&gt;t, e2-&gt;t);
+      e1-&gt;k = e2-&gt;k; e1-&gt;info = e2-&gt;info; e1-&gt;aux = e2-&gt;aux; e1-&gt;f = e2-&gt;f;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2-&gt;k == VRELOCABLE &amp;&amp; GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1-&gt;info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1-&gt;info);
+        e1-&gt;k = e2-&gt;k; e1-&gt;info = e2-&gt;info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);
+        freeexp(fs, e2);
+        freeexp(fs, e1);
+        e1-&gt;info = luaK_codeABC(fs, OP_CONCAT, 0, e1-&gt;info, e2-&gt;info);
+        e1-&gt;k = VRELOCABLE;
+      }
+      break;
+    }
+    default: {
+      int o1 = luaK_exp2RK(fs, e1);
+      int o2 = luaK_exp2RK(fs, e2);
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+      codebinop(fs, e1, op, o1, o2);
+    }
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs-&gt;f-&gt;lineinfo[fs-&gt;pc - 1] = line;
+}
+
+
+int luaK_code (FuncState *fs, Instruction i, int line) {
+  Proto *f = fs-&gt;f;
+  luaK_dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,
+                  MAX_INT, &quot;code size overflow&quot;);
+  f-&gt;code[fs-&gt;pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, int,
+                  MAX_INT, &quot;code size overflow&quot;);
+  f-&gt;lineinfo[fs-&gt;pc] = line;
+  return fs-&gt;pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c), fs-&gt;ls-&gt;lastline);
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc), fs-&gt;ls-&gt;lastline);
+}
+

Added: trunk/Util/deditor/lua/lcode.h
===================================================================
--- trunk/Util/deditor/lua/lcode.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lcode.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,74 @@
+/*
+** $Id: lcode.h,v 1.38 2002/12/11 12:34:22 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include &quot;llex.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep &quot;ORDER OPR&quot; if you change these enums
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MULT, OPR_DIV, OPR_POW,
+  OPR_CONCAT,
+  OPR_NE, OPR_EQ,
+  OPR_LT, OPR_LE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+#define binopistest(op)	((op) &gt;= OPR_NE)
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)-&gt;f-&gt;code[(e)-&gt;info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+int luaK_code (FuncState *fs, Instruction i, int line);
+int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+void luaK_fixline (FuncState *fs, int line);
+void luaK_nil (FuncState *fs, int from, int n);
+void luaK_reserveregs (FuncState *fs, int n);
+void luaK_checkstack (FuncState *fs, int n);
+int luaK_stringK (FuncState *fs, TString *s);
+int luaK_numberK (FuncState *fs, lua_Number r);
+void luaK_dischargevars (FuncState *fs, expdesc *e);
+int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+void luaK_exp2val (FuncState *fs, expdesc *e);
+int luaK_exp2RK (FuncState *fs, expdesc *e);
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+void luaK_goiftrue (FuncState *fs, expdesc *e);
+void luaK_goiffalse (FuncState *fs, expdesc *e);
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+void luaK_setcallreturns (FuncState *fs, expdesc *var, int nresults);
+int luaK_jump (FuncState *fs);
+void luaK_patchlist (FuncState *fs, int list, int target);
+void luaK_patchtohere (FuncState *fs, int list);
+void luaK_concat (FuncState *fs, int *l1, int l2);
+int luaK_getlabel (FuncState *fs);
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v);
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);
+
+
+#endif

Added: trunk/Util/deditor/lua/ldebug.c
===================================================================
--- trunk/Util/deditor/lua/ldebug.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldebug.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,585 @@
+/*
+** $Id: ldebug.c,v 1.150 2003/03/19 21:24:04 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ldebug_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lapi.h&quot;
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lvm.h&quot;
+
+
+
+static const char *getfuncname (CallInfo *ci, const char **name);
+
+
+#define isLua(ci)	(!((ci)-&gt;state &amp; CI_C))
+
+
+static int currentpc (CallInfo *ci) {
+  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
+  if (ci-&gt;state &amp; CI_HASFRAME)  /* function has a frame? */
+    ci-&gt;u.l.savedpc = *ci-&gt;u.l.pc;  /* use `pc' from there */
+  /* function's pc is saved */
+  return pcRel(ci-&gt;u.l.savedpc, ci_func(ci)-&gt;l.p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  int pc = currentpc(ci);
+  if (pc &lt; 0)
+    return -1;  /* only active lua functions have current-line information */
+  else
+    return getline(ci_func(ci)-&gt;l.p, pc);
+}
+
+
+void luaG_inithooks (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L-&gt;ci; ci != L-&gt;base_ci; ci--)  /* update all `savedpc's */
+    currentpc(ci);
+  L-&gt;hookinit = 1;
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  L-&gt;hook = func;
+  L-&gt;basehookcount = count;
+  resethookcount(L);
+  L-&gt;hookmask = cast(lu_byte, mask);
+  L-&gt;hookinit = 0;
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L-&gt;hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L-&gt;hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L-&gt;basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  lua_lock(L);
+  for (ci = L-&gt;ci; level &gt; 0 &amp;&amp; ci &gt; L-&gt;base_ci; ci--) {
+    level--;
+    if (!(ci-&gt;state &amp; CI_C))  /* Lua function? */
+      level -= ci-&gt;u.l.tailcalls;  /* skip lost tail calls */
+  }
+  if (level &gt; 0 || ci == L-&gt;base_ci) status = 0;  /* there is no such level */
+  else if (level &lt; 0) {  /* level is of a lost tail call */
+    status = 1;
+    ar-&gt;i_ci = 0;
+  }
+  else {
+    status = 1;
+    ar-&gt;i_ci = ci - L-&gt;base_ci;
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+static Proto *getluaproto (CallInfo *ci) {
+  return (isLua(ci) ? ci_func(ci)-&gt;l.p : NULL);
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L-&gt;base_ci + ar-&gt;i_ci;
+  fp = getluaproto(ci);
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (name)
+      luaA_pushobject(L, ci-&gt;base+(n-1));  /* push value */
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L-&gt;base_ci + ar-&gt;i_ci;
+  fp = getluaproto(ci);
+  L-&gt;top--;  /* pop new value */
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (!name || name[0] == '(')  /* `(' starts private locals */
+      name = NULL;
+    else
+      setobjs2s(ci-&gt;base+(n-1), L-&gt;top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, StkId func) {
+  Closure *cl = clvalue(func);
+  if (cl-&gt;c.isC) {
+    ar-&gt;source = &quot;=[C]&quot;;
+    ar-&gt;linedefined = -1;
+    ar-&gt;what = &quot;C&quot;;
+  }
+  else {
+    ar-&gt;source = getstr(cl-&gt;l.p-&gt;source);
+    ar-&gt;linedefined = cl-&gt;l.p-&gt;lineDefined;
+    ar-&gt;what = (ar-&gt;linedefined == 0) ? &quot;main&quot; : &quot;Lua&quot;;
+  }
+  luaO_chunkid(ar-&gt;short_src, ar-&gt;source, LUA_IDSIZE);
+}
+
+
+static const char *travglobals (lua_State *L, const TObject *o) {
+  Table *g = hvalue(gt(L));
+  int i = sizenode(g);
+  while (i--) {
+    Node *n = gnode(g, i);
+    if (luaO_rawequalObj(o, gval(n)) &amp;&amp; ttisstring(gkey(n)))
+      return getstr(tsvalue(gkey(n)));
+  }
+  return NULL;
+}
+
+
+static void info_tailcall (lua_State *L, lua_Debug *ar) {
+  ar-&gt;name = ar-&gt;namewhat = &quot;&quot;;
+  ar-&gt;what = &quot;tail&quot;;
+  ar-&gt;linedefined = ar-&gt;currentline = -1;
+  ar-&gt;source = &quot;=(tail call)&quot;;
+  luaO_chunkid(ar-&gt;short_src, ar-&gt;source, LUA_IDSIZE);
+  ar-&gt;nups = 0;
+  setnilvalue(L-&gt;top);
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                    StkId f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar-&gt;currentline = (ci) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar-&gt;nups = clvalue(f)-&gt;c.nupvalues;
+        break;
+      }
+      case 'n': {
+        ar-&gt;namewhat = (ci) ? getfuncname(ci, &amp;ar-&gt;name) : NULL;
+        if (ar-&gt;namewhat == NULL) {
+          /* try to find a global name */
+          if ((ar-&gt;name = travglobals(L, f)) != NULL)
+            ar-&gt;namewhat = &quot;global&quot;;
+          else ar-&gt;namewhat = &quot;&quot;;  /* not found */
+        }
+        break;
+      }
+      case 'f': {
+        setobj2s(L-&gt;top, f);
+        break;
+      }
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status = 1;
+  lua_lock(L);
+  if (*what == '&gt;') {
+    StkId f = L-&gt;top - 1;
+    if (!ttisfunction(f))
+      luaG_runerror(L, &quot;value for `lua_getinfo' is not a function&quot;);
+    status = auxgetinfo(L, what + 1, ar, f, NULL);
+    L-&gt;top--;  /* pop function */
+  }
+  else if (ar-&gt;i_ci != 0) {  /* no tail call? */
+    CallInfo *ci = L-&gt;base_ci + ar-&gt;i_ci;
+    lua_assert(ttisfunction(ci-&gt;base - 1));
+    status = auxgetinfo(L, what, ar, ci-&gt;base - 1, ci);
+  }
+  else
+    info_tailcall(L, ar);
+  if (strchr(what, 'f')) incr_top(L);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution and code checker
+** =======================================================
+*/
+
+#define check(x)		if (!(x)) return 0;
+
+#define checkjump(pt,pc)	check(0 &lt;= pc &amp;&amp; pc &lt; pt-&gt;sizecode)
+
+#define checkreg(pt,reg)	check((reg) &lt; (pt)-&gt;maxstacksize)
+
+
+
+static int precheck (const Proto *pt) {
+  check(pt-&gt;maxstacksize &lt;= MAXSTACK);
+  check(pt-&gt;sizelineinfo == pt-&gt;sizecode || pt-&gt;sizelineinfo == 0);
+  lua_assert(pt-&gt;numparams+pt-&gt;is_vararg &lt;= pt-&gt;maxstacksize);
+  check(GET_OPCODE(pt-&gt;code[pt-&gt;sizecode-1]) == OP_RETURN);
+  return 1;
+}
+
+
+static int checkopenop (const Proto *pt, int pc) {
+  Instruction i = pt-&gt;code[pc+1];
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:
+    case OP_RETURN: {
+      check(GETARG_B(i) == 0);
+      return 1;
+    }
+    case OP_SETLISTO: return 1;
+    default: return 0;  /* invalid instruction after an open call */
+  }
+}
+
+
+static int checkRK (const Proto *pt, int r) {
+  return (r &lt; pt-&gt;maxstacksize || (r &gt;= MAXSTACK &amp;&amp; r-MAXSTACK &lt; pt-&gt;sizek));
+}
+
+
+static Instruction luaG_symbexec (const Proto *pt, int lastpc, int reg) {
+  int pc;
+  int last;  /* stores position of last instruction that changed `reg' */
+  last = pt-&gt;sizecode-1;  /* points to final return (a `neutral' instruction) */
+  check(precheck(pt));
+  for (pc = 0; pc &lt; lastpc; pc++) {
+    const Instruction i = pt-&gt;code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    int b = 0;
+    int c = 0;
+    checkreg(pt, a);
+    switch (getOpMode(op)) {
+      case iABC: {
+        b = GETARG_B(i);
+        c = GETARG_C(i);
+        if (testOpMode(op, OpModeBreg)) {
+          checkreg(pt, b);
+        }
+        else if (testOpMode(op, OpModeBrk))
+          check(checkRK(pt, b));
+        if (testOpMode(op, OpModeCrk))
+          check(checkRK(pt, c));
+        break;
+      }
+      case iABx: {
+        b = GETARG_Bx(i);
+        if (testOpMode(op, OpModeK)) check(b &lt; pt-&gt;sizek);
+        break;
+      }
+      case iAsBx: {
+        b = GETARG_sBx(i);
+        break;
+      }
+    }
+    if (testOpMode(op, OpModesetA)) {
+      if (a == reg) last = pc;  /* change register `a' */
+    }
+    if (testOpMode(op, OpModeT)) {
+      check(pc+2 &lt; pt-&gt;sizecode);  /* check skip */
+      check(GET_OPCODE(pt-&gt;code[pc+1]) == OP_JMP);
+    }
+    switch (op) {
+      case OP_LOADBOOL: {
+        check(c == 0 || pc+2 &lt; pt-&gt;sizecode);  /* check its jump */
+        break;
+      }
+      case OP_LOADNIL: {
+        if (a &lt;= reg &amp;&amp; reg &lt;= b)
+          last = pc;  /* set registers from `a' to `b' */
+        break;
+      }
+      case OP_GETUPVAL:
+      case OP_SETUPVAL: {
+        check(b &lt; pt-&gt;nups);
+        break;
+      }
+      case OP_GETGLOBAL:
+      case OP_SETGLOBAL: {
+        check(ttisstring(&amp;pt-&gt;k[b]));
+        break;
+      }
+      case OP_SELF: {
+        checkreg(pt, a+1);
+        if (reg == a+1) last = pc;
+        break;
+      }
+      case OP_CONCAT: {
+        /* `c' is a register, and at least two operands */
+        check(c &lt; MAXSTACK &amp;&amp; b &lt; c);
+        break;
+      }
+      case OP_TFORLOOP:
+        checkreg(pt, a+c+5);
+        if (reg &gt;= a) last = pc;  /* affect all registers above base */
+        /* go through */
+      case OP_FORLOOP:
+        checkreg(pt, a+2);
+        /* go through */
+      case OP_JMP: {
+        int dest = pc+1+b;
+	check(0 &lt;= dest &amp;&amp; dest &lt; pt-&gt;sizecode);
+        /* not full check and jump is forward and do not skip `lastpc'? */
+        if (reg != NO_REG &amp;&amp; pc &lt; dest &amp;&amp; dest &lt;= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (b != 0) {
+          checkreg(pt, a+b-1);
+        }
+        c--;  /* c = num. returns */
+        if (c == LUA_MULTRET) {
+          check(checkopenop(pt, pc));
+        }
+        else if (c != 0)
+          checkreg(pt, a+c-1);
+        if (reg &gt;= a) last = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_RETURN: {
+        b--;  /* b = num. returns */
+        if (b &gt; 0) checkreg(pt, a+b-1);
+        break;
+      }
+      case OP_SETLIST: {
+        checkreg(pt, a + (b&amp;(LFIELDS_PER_FLUSH-1)) + 1);
+        break;
+      }
+      case OP_CLOSURE: {
+        int nup;
+        check(b &lt; pt-&gt;sizep);
+        nup = pt-&gt;p[b]-&gt;nups;
+        check(pc + nup &lt; pt-&gt;sizecode);
+        for (; nup&gt;0; nup--) {
+          OpCode op1 = GET_OPCODE(pt-&gt;code[pc+nup]);
+          check(op1 == OP_GETUPVAL || op1 == OP_MOVE);
+        }
+        break;
+      }
+      default: break;
+    }
+  }
+  return pt-&gt;code[last];
+}
+
+#undef check
+#undef checkjump
+#undef checkreg
+
+/* }====================================================== */
+
+
+int luaG_checkcode (const Proto *pt) {
+  return luaG_symbexec(pt, pt-&gt;sizecode, NO_REG);
+}
+
+
+static const char *kname (Proto *p, int c) {
+  c = c - MAXSTACK;
+  if (c &gt;= 0 &amp;&amp; ttisstring(&amp;p-&gt;k[c]))
+    return svalue(&amp;p-&gt;k[c]);
+  else
+    return &quot;?&quot;;
+}
+
+
+static const char *getobjname (CallInfo *ci, int stackpos, const char **name) {
+  if (isLua(ci)) {  /* a Lua function? */
+    Proto *p = ci_func(ci)-&gt;l.p;
+    int pc = currentpc(ci);
+    Instruction i;
+    *name = luaF_getlocalname(p, stackpos+1, pc);
+    if (*name)  /* is a local? */
+      return &quot;local&quot;;
+    i = luaG_symbexec(p, pc, stackpos);  /* try symbolic execution */
+    lua_assert(pc != -1);
+    switch (GET_OPCODE(i)) {
+      case OP_GETGLOBAL: {
+        int g = GETARG_Bx(i);  /* global index */
+        lua_assert(ttisstring(&amp;p-&gt;k[g]));
+        *name = svalue(&amp;p-&gt;k[g]);
+        return &quot;global&quot;;
+      }
+      case OP_MOVE: {
+        int a = GETARG_A(i);
+        int b = GETARG_B(i);  /* move from `b' to `a' */
+        if (b &lt; a)
+          return getobjname(ci, b, name);  /* get name for `b' */
+        break;
+      }
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return &quot;field&quot;;
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return &quot;method&quot;;
+      }
+      default: break;
+    }
+  }
+  return NULL;  /* no useful name found */
+}
+
+
+static const char *getfuncname (CallInfo *ci, const char **name) {
+  Instruction i;
+  if ((isLua(ci) &amp;&amp; ci-&gt;u.l.tailcalls &gt; 0) || !isLua(ci - 1))
+    return NULL;  /* calling function is not Lua (or is unknown) */
+  ci--;  /* calling function */
+  i = ci_func(ci)-&gt;l.p-&gt;code[currentpc(ci)];
+  if (GET_OPCODE(i) == OP_CALL || GET_OPCODE(i) == OP_TAILCALL)
+    return getobjname(ci, GETARG_A(i), name);
+  else
+    return NULL;  /* no useful name can be found */
+}
+
+
+/* only ANSI way to check whether a pointer points to an array */
+static int isinstack (CallInfo *ci, const TObject *o) {
+  StkId p;
+  for (p = ci-&gt;base; p &lt; ci-&gt;top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+void luaG_typeerror (lua_State *L, const TObject *o, const char *op) {
+  const char *name = NULL;
+  const char *t = luaT_typenames[ttype(o)];
+  const char *kind = (isinstack(L-&gt;ci, o)) ?
+                         getobjname(L-&gt;ci, o - L-&gt;base, &amp;name) : NULL;
+  if (kind)
+    luaG_runerror(L, &quot;attempt to %s %s `%s' (a %s value)&quot;,
+                op, kind, name, t);
+  else
+    luaG_runerror(L, &quot;attempt to %s a %s value&quot;, op, t);
+}
+
+
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1));
+  luaG_typeerror(L, p1, &quot;concatenate&quot;);
+}
+
+
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2) {
+  TObject temp;
+  if (luaV_tonumber(p1, &amp;temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, &quot;perform arithmetic on&quot;);
+}
+
+
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2) {
+  const char *t1 = luaT_typenames[ttype(p1)];
+  const char *t2 = luaT_typenames[ttype(p2)];
+  if (t1[2] == t2[2])
+    luaG_runerror(L, &quot;attempt to compare two %s values&quot;, t1);
+  else
+    luaG_runerror(L, &quot;attempt to compare %s with %s&quot;, t1, t2);
+  return 0;
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L-&gt;ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    luaO_chunkid(buff, getstr(getluaproto(ci)-&gt;source), LUA_IDSIZE);
+    luaO_pushfstring(L, &quot;%s:%d: %s&quot;, buff, line, msg);
+  }
+}
+
+
+void luaG_errormsg (lua_State *L) {
+  if (L-&gt;errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L-&gt;errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L-&gt;top, L-&gt;top - 1);  /* move argument */
+    setobjs2s(L-&gt;top - 1, errfunc);  /* push function */
+    incr_top(L);
+    luaD_call(L, L-&gt;top - 2, 1);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+void luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+

Added: trunk/Util/deditor/lua/ldebug.h
===================================================================
--- trunk/Util/deditor/lua/ldebug.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldebug.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,31 @@
+/*
+** $Id: ldebug.h,v 1.32 2002/11/18 11:01:55 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include &quot;lstate.h&quot;
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)-&gt;code) - 1)
+
+#define getline(f,pc)	(((f)-&gt;lineinfo) ? (f)-&gt;lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L-&gt;hookcount = L-&gt;basehookcount)
+
+
+void luaG_inithooks (lua_State *L);
+void luaG_typeerror (lua_State *L, const TObject *o, const char *opname);
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2);
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2);
+void luaG_runerror (lua_State *L, const char *fmt, ...);
+void luaG_errormsg (lua_State *L);
+int luaG_checkcode (const Proto *pt);
+
+
+#endif

Added: trunk/Util/deditor/lua/ldo.c
===================================================================
--- trunk/Util/deditor/lua/ldo.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldo.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,458 @@
+/*
+** $Id: ldo.c,v 1.217 2003/04/03 13:35:34 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;setjmp.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ldo_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lundump.h&quot;
+#include &quot;lvm.h&quot;
+#include &quot;lzio.h&quot;
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions (based on long jumps)
+** =======================================================
+*/
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  jmp_buf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {
+      setsvalue2s(oldtop, luaS_new(L, MEMERRMSG));
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(oldtop, luaS_new(L, &quot;error in error handling&quot;));
+      break;
+    }
+    case LUA_ERRSYNTAX:
+    case LUA_ERRRUN: {
+      setobjs2s(oldtop, L-&gt;top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L-&gt;top = oldtop + 1;
+}
+
+
+void luaD_throw (lua_State *L, int errcode) {
+  if (L-&gt;errorJmp) {
+    L-&gt;errorJmp-&gt;status = errcode;
+    longjmp(L-&gt;errorJmp-&gt;b, 1);
+  }
+  else {
+    G(L)-&gt;panic(L);
+    exit(EXIT_FAILURE);
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  struct lua_longjmp lj;
+  lj.status = 0;
+  lj.previous = L-&gt;errorJmp;  /* chain new error handler */
+  L-&gt;errorJmp = &lj;
+  if (setjmp(lj.b) == 0)
+    (*f)(L, ud);
+  L-&gt;errorJmp = lj.previous;  /* restore old error handler */
+  return lj.status;
+}
+
+
+static void restore_stack_limit (lua_State *L) {
+  L-&gt;stack_last = L-&gt;stack+L-&gt;stacksize-1;
+  if (L-&gt;size_ci &gt; LUA_MAXCALLS) {  /* there was an overflow? */
+    int inuse = (L-&gt;ci - L-&gt;base_ci);
+    if (inuse + 1 &lt; LUA_MAXCALLS)  /* can `undo' overflow? */
+      luaD_reallocCI(L, LUA_MAXCALLS);
+  }
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TObject *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L-&gt;top = (L-&gt;top - oldstack) + L-&gt;stack;
+  for (up = L-&gt;openupval; up != NULL; up = up-&gt;gch.next)
+    gcotouv(up)-&gt;v = (gcotouv(up)-&gt;v - oldstack) + L-&gt;stack;
+  for (ci = L-&gt;base_ci; ci &lt;= L-&gt;ci; ci++) {
+    ci-&gt;top = (ci-&gt;top - oldstack) + L-&gt;stack;
+    ci-&gt;base = (ci-&gt;base - oldstack) + L-&gt;stack;
+  }
+  L-&gt;base = L-&gt;ci-&gt;base;
+}
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TObject *oldstack = L-&gt;stack;
+  luaM_reallocvector(L, L-&gt;stack, L-&gt;stacksize, newsize, TObject);
+  L-&gt;stacksize = newsize;
+  L-&gt;stack_last = L-&gt;stack+newsize-1-EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_reallocCI (lua_State *L, int newsize) {
+  CallInfo *oldci = L-&gt;base_ci;
+  luaM_reallocvector(L, L-&gt;base_ci, L-&gt;size_ci, newsize, CallInfo);
+  L-&gt;size_ci = cast(unsigned short, newsize);
+  L-&gt;ci = (L-&gt;ci - oldci) + L-&gt;base_ci;
+  L-&gt;end_ci = L-&gt;base_ci + L-&gt;size_ci;
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  if (n &lt;= L-&gt;stacksize)  /* double size is enough? */
+    luaD_reallocstack(L, 2*L-&gt;stacksize);
+  else
+    luaD_reallocstack(L, L-&gt;stacksize + n + EXTRA_STACK);
+}
+
+
+static void luaD_growCI (lua_State *L) {
+  if (L-&gt;size_ci &gt; LUA_MAXCALLS)  /* overflow while handling overflow? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    luaD_reallocCI(L, 2*L-&gt;size_ci);
+    if (L-&gt;size_ci &gt; LUA_MAXCALLS)
+      luaG_runerror(L, &quot;stack overflow&quot;);
+  }
+}
+
+
+void luaD_callhook (lua_State *L, int event, int line) {
+  lua_Hook hook = L-&gt;hook;
+  if (hook &amp;&amp; L-&gt;allowhook) {
+    ptrdiff_t top = savestack(L, L-&gt;top);
+    ptrdiff_t ci_top = savestack(L, L-&gt;ci-&gt;top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    if (event == LUA_HOOKTAILRET)
+      ar.i_ci = 0;  /* tail call; no debug information about it */
+    else
+      ar.i_ci = L-&gt;ci - L-&gt;base_ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    L-&gt;ci-&gt;top = L-&gt;top + LUA_MINSTACK;
+    L-&gt;allowhook = 0;  /* cannot call hooks inside a hook */
+    lua_unlock(L);
+    (*hook)(L, &amp;ar);
+    lua_lock(L);
+    lua_assert(!L-&gt;allowhook);
+    L-&gt;allowhook = 1;
+    L-&gt;ci-&gt;top = restorestack(L, ci_top);
+    L-&gt;top = restorestack(L, top);
+  }
+}
+
+
+static void adjust_varargs (lua_State *L, int nfixargs, StkId base) {
+  int i;
+  Table *htab;
+  TObject nname;
+  int actual = L-&gt;top - base;  /* actual number of arguments */
+  if (actual &lt; nfixargs) {
+    luaD_checkstack(L, nfixargs - actual);
+    for (; actual &lt; nfixargs; ++actual)
+      setnilvalue(L-&gt;top++);
+  }
+  actual -= nfixargs;  /* number of extra arguments */
+  htab = luaH_new(L, actual, 1);  /* create `arg' table */
+  for (i=0; i&lt;actual; i++)  /* put extra arguments into `arg' table */
+    setobj2n(luaH_setnum(L, htab, i+1), L-&gt;top - actual + i);
+  /* store counter in field `n' */
+  setsvalue(&amp;nname, luaS_newliteral(L, &quot;n&quot;));
+  setnvalue(luaH_set(L, htab, &amp;nname), cast(lua_Number, actual));
+  L-&gt;top -= actual;  /* remove extra elements from the stack */
+  sethvalue(L-&gt;top, htab);
+  incr_top(L);
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TObject *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, &quot;call&quot;);
+  /* Open a hole inside the stack at `func' */
+  for (p = L-&gt;top; p &gt; func; p--) setobjs2s(p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+StkId luaD_precall (lua_State *L, StkId func) {
+  LClosure *cl;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(func)) /* `func' is not a function? */
+    func = tryfuncTM(L, func);  /* check the `function' tag method */
+  if (L-&gt;ci + 1 == L-&gt;end_ci) luaD_growCI(L);
+  else condhardstacktests(luaD_reallocCI(L, L-&gt;size_ci));
+  cl = &amp;clvalue(func)-&gt;l;
+  if (!cl-&gt;isC) {  /* Lua function? prepare its call */
+    CallInfo *ci;
+    Proto *p = cl-&gt;p;
+    if (p-&gt;is_vararg)  /* varargs? */
+      adjust_varargs(L, p-&gt;numparams, func+1);
+    luaD_checkstack(L, p-&gt;maxstacksize);
+    ci = ++L-&gt;ci;  /* now `enter' new function */
+    L-&gt;base = L-&gt;ci-&gt;base = restorestack(L, funcr) + 1;
+    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;
+    ci-&gt;u.l.savedpc = p-&gt;code;  /* starting point */
+    ci-&gt;u.l.tailcalls = 0;
+    ci-&gt;state = CI_SAVEDPC;
+    while (L-&gt;top &lt; ci-&gt;top)
+      setnilvalue(L-&gt;top++);
+    L-&gt;top = ci-&gt;top;
+    return NULL;
+  }
+  else {  /* if is a C function, call it */
+    CallInfo *ci;
+    int n;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci = ++L-&gt;ci;  /* now `enter' new function */
+    L-&gt;base = L-&gt;ci-&gt;base = restorestack(L, funcr) + 1;
+    ci-&gt;top = L-&gt;top + LUA_MINSTACK;
+    ci-&gt;state = CI_C;  /* a C function */
+    if (L-&gt;hookmask &amp; LUA_MASKCALL)
+      luaD_callhook(L, LUA_HOOKCALL, -1);
+    lua_unlock(L);
+#ifdef LUA_COMPATUPVALUES
+    lua_pushupvalues(L);
+#endif
+    n = (*clvalue(L-&gt;base - 1)-&gt;c.f)(L);  /* do the actual call */
+    lua_lock(L);
+    return L-&gt;top - n;
+  }
+}
+
+
+static StkId callrethooks (lua_State *L, StkId firstResult) {
+  ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
+  luaD_callhook(L, LUA_HOOKRET, -1);
+  if (!(L-&gt;ci-&gt;state &amp; CI_C)) {  /* Lua function? */
+    while (L-&gt;ci-&gt;u.l.tailcalls--)  /* call hook for eventual tail calls */
+      luaD_callhook(L, LUA_HOOKTAILRET, -1);
+  }
+  return restorestack(L, fr);
+}
+
+
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult) { 
+  StkId res;
+  if (L-&gt;hookmask &amp; LUA_MASKRET)
+    firstResult = callrethooks(L, firstResult);
+  res = L-&gt;base - 1;  /* res == final position of 1st result */
+  L-&gt;ci--;
+  L-&gt;base = L-&gt;ci-&gt;base;  /* restore base */
+  /* move results to correct place */
+  while (wanted != 0 &amp;&amp; firstResult &lt; L-&gt;top) {
+    setobjs2s(res++, firstResult++);
+    wanted--;
+  }
+  while (wanted-- &gt; 0)
+    setnilvalue(res++);
+  L-&gt;top = res;
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/ 
+void luaD_call (lua_State *L, StkId func, int nResults) {
+  StkId firstResult;
+  lua_assert(!(L-&gt;ci-&gt;state &amp; CI_CALLING));
+  if (++L-&gt;nCcalls &gt;= LUA_MAXCCALLS) {
+    if (L-&gt;nCcalls == LUA_MAXCCALLS)
+      luaG_runerror(L, &quot;C stack overflow&quot;);
+    else if (L-&gt;nCcalls &gt;= (LUA_MAXCCALLS + (LUA_MAXCCALLS&gt;&gt;3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  firstResult = luaD_precall(L, func);
+  if (firstResult == NULL)  /* is a Lua function? */
+    firstResult = luaV_execute(L);  /* call it */
+  luaD_poscall(L, nResults, firstResult);
+  L-&gt;nCcalls--;
+  luaC_checkGC(L);
+}
+
+
+static void resume (lua_State *L, void *ud) {
+  StkId firstResult;
+  int nargs = *cast(int *, ud);
+  CallInfo *ci = L-&gt;ci;
+  if (ci == L-&gt;base_ci) {  /* no activation record? */
+    if (nargs &gt;= L-&gt;top - L-&gt;base)
+      luaG_runerror(L, &quot;cannot resume dead coroutine&quot;);
+    luaD_precall(L, L-&gt;top - (nargs + 1));  /* start coroutine */
+  }
+  else if (ci-&gt;state &amp; CI_YIELD) {  /* inside a yield? */
+    if (ci-&gt;state &amp; CI_C) {  /* `common' yield? */
+      /* finish interrupted execution of `OP_CALL' */
+      int nresults;
+      lua_assert((ci-1)-&gt;state &amp; CI_SAVEDPC);
+      lua_assert(GET_OPCODE(*((ci-1)-&gt;u.l.savedpc - 1)) == OP_CALL ||
+                 GET_OPCODE(*((ci-1)-&gt;u.l.savedpc - 1)) == OP_TAILCALL);
+      nresults = GETARG_C(*((ci-1)-&gt;u.l.savedpc - 1)) - 1;
+      luaD_poscall(L, nresults, L-&gt;top - nargs);  /* complete it */
+      if (nresults &gt;= 0) L-&gt;top = L-&gt;ci-&gt;top;
+    }
+    else {  /* yielded inside a hook: just continue its execution */
+      ci-&gt;state &amp;= ~CI_YIELD;
+    }
+  }
+  else
+    luaG_runerror(L, &quot;cannot resume non-suspended coroutine&quot;);
+  firstResult = luaV_execute(L);
+  if (firstResult != NULL)   /* return? */
+    luaD_poscall(L, LUA_MULTRET, firstResult);  /* finalize this coroutine */
+}
+
+
+LUA_API int lua_resume (lua_State *L, int nargs) {
+  int status;
+  lu_byte old_allowhooks;
+  lua_lock(L);
+  old_allowhooks = L-&gt;allowhook;
+  lua_assert(L-&gt;errfunc == 0 &amp;&amp; L-&gt;nCcalls == 0);
+  status = luaD_rawrunprotected(L, resume, &amp;nargs);
+  if (status != 0) {  /* error? */
+    L-&gt;ci = L-&gt;base_ci;  /* go back to initial level */
+    L-&gt;base = L-&gt;ci-&gt;base;
+    L-&gt;nCcalls = 0;
+    luaF_close(L, L-&gt;base);  /* close eventual pending closures */
+    seterrorobj(L, status, L-&gt;base);
+    L-&gt;allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yield (lua_State *L, int nresults) {
+  CallInfo *ci;
+  lua_lock(L);
+  ci = L-&gt;ci;
+  if (L-&gt;nCcalls &gt; 0)
+    luaG_runerror(L, &quot;attempt to yield across metamethod/C-call boundary&quot;);
+  if (ci-&gt;state &amp; CI_C) {  /* usual yield */
+    if ((ci-1)-&gt;state &amp; CI_C)
+      luaG_runerror(L, &quot;cannot yield a C function&quot;);
+    if (L-&gt;top - nresults &gt; L-&gt;base) {  /* is there garbage in the stack? */
+      int i;
+      for (i=0; i&lt;nresults; i++)  /* move down results */
+        setobjs2s(L-&gt;base + i, L-&gt;top - nresults + i);
+      L-&gt;top = L-&gt;base + nresults;
+    }
+  } /* else it's an yield inside a hook: nothing to do */
+  ci-&gt;state |= CI_YIELD;
+  lua_unlock(L);
+  return -1;
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  unsigned short oldnCcalls = L-&gt;nCcalls;
+  ptrdiff_t old_ci = saveci(L, L-&gt;ci);
+  lu_byte old_allowhooks = L-&gt;allowhook;
+  ptrdiff_t old_errfunc = L-&gt;errfunc;
+  L-&gt;errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != 0) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close eventual pending closures */
+    seterrorobj(L, status, oldtop);
+    L-&gt;nCcalls = oldnCcalls;
+    L-&gt;ci = restoreci(L, old_ci);
+    L-&gt;base = L-&gt;ci-&gt;base;
+    L-&gt;allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  L-&gt;errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* buffer to be used by the scanner */
+  int bin;
+};
+
+static void f_parser (lua_State *L, void *ud) {
+  struct SParser *p;
+  Proto *tf;
+  Closure *cl;
+  luaC_checkGC(L);
+  p = cast(struct SParser *, ud);
+  tf = p-&gt;bin ? luaU_undump(L, p-&gt;z, &amp;p-&gt;buff) : luaY_parser(L, p-&gt;z, &amp;p-&gt;buff);
+  cl = luaF_newLclosure(L, 0, gt(L));
+  cl-&gt;l.p = tf;
+  setclvalue(L-&gt;top, cl);
+  incr_top(L);
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin) {
+  struct SParser p;
+  int status;
+  ptrdiff_t oldtopr = savestack(L, L-&gt;top);  /* save current top */
+  p.z = z; p.bin = bin;
+  luaZ_initbuffer(L, &amp;p.buff);
+  status = luaD_rawrunprotected(L, f_parser, &amp;p);
+  luaZ_freebuffer(L, &amp;p.buff);
+  if (status != 0) {  /* error? */
+    StkId oldtop = restorestack(L, oldtopr);
+    seterrorobj(L, status, oldtop);
+  }
+  return status;
+}
+
+

Added: trunk/Util/deditor/lua/ldo.h
===================================================================
--- trunk/Util/deditor/lua/ldo.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldo.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,60 @@
+/*
+** $Id: ldo.h,v 1.56 2002/12/04 17:29:32 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lzio.h&quot;
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/ 
+#ifndef HARDSTACKTESTS
+#define condhardstacktests(x)	{ /* empty */ }
+#else
+#define condhardstacktests(x)	x
+#endif
+
+
+#define luaD_checkstack(L,n)	\
+  if ((char *)L-&gt;stack_last - (char *)L-&gt;top &lt;= (n)*(int)sizeof(TObject)) \
+    luaD_growstack(L, n); \
+  else condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize));
+
+
+#define incr_top(L) {luaD_checkstack(L,1); L-&gt;top++;}
+
+#define savestack(L,p)		((char *)(p) - (char *)L-&gt;stack)
+#define restorestack(L,n)	((TObject *)((char *)L-&gt;stack + (n)))
+
+#define saveci(L,p)		((char *)(p) - (char *)L-&gt;base_ci)
+#define restoreci(L,n)		((CallInfo *)((char *)L-&gt;base_ci + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+void luaD_resetprotection (lua_State *L);
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin);
+void luaD_callhook (lua_State *L, int event, int line);
+StkId luaD_precall (lua_State *L, StkId func);
+void luaD_call (lua_State *L, StkId func, int nResults);
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t oldtop, ptrdiff_t ef);
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult);
+void luaD_reallocCI (lua_State *L, int newsize);
+void luaD_reallocstack (lua_State *L, int newsize);
+void luaD_growstack (lua_State *L, int n);
+
+void luaD_throw (lua_State *L, int errcode);
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+
+#endif

Added: trunk/Util/deditor/lua/ldump.c
===================================================================
--- trunk/Util/deditor/lua/ldump.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ldump.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,170 @@
+/*
+** $Id: ldump.c,v 1.4 2003/02/11 23:52:12 lhf Exp $
+** save bytecodes
+** See Copyright Notice in lua.h
+*/
+
+#include &lt;stddef.h&gt;
+
+#define ldump_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lundump.h&quot;
+
+#define DumpVector(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpLiteral(s,D)	DumpBlock(&quot;&quot; s,(sizeof(s))-1,D)
+
+typedef struct {
+ lua_State* L;
+ lua_Chunkwriter write;
+ void* data;
+} DumpState;
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ lua_unlock(D-&gt;L);
+ (*D-&gt;write)(D-&gt;L,b,size,D-&gt;data);
+ lua_lock(D-&gt;L);
+}
+
+static void DumpByte(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpSize(size_t x, DumpState* D)
+{
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpString(TString* s, DumpState* D)
+{
+ if (s==NULL || getstr(s)==NULL)
+  DumpSize(0,D);
+ else
+ {
+  size_t size=s-&gt;tsv.len+1;		/* include trailing '\0' */
+  DumpSize(size,D);
+  DumpBlock(getstr(s),size,D);
+ }
+}
+
+static void DumpCode(const Proto* f, DumpState* D)
+{
+ DumpInt(f-&gt;sizecode,D);
+ DumpVector(f-&gt;code,f-&gt;sizecode,sizeof(*f-&gt;code),D);
+}
+
+static void DumpLocals(const Proto* f, DumpState* D)
+{
+ int i,n=f-&gt;sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i&lt;n; i++)
+ {
+  DumpString(f-&gt;locvars[i].varname,D);
+  DumpInt(f-&gt;locvars[i].startpc,D);
+  DumpInt(f-&gt;locvars[i].endpc,D);
+ }
+}
+
+static void DumpLines(const Proto* f, DumpState* D)
+{
+ DumpInt(f-&gt;sizelineinfo,D);
+ DumpVector(f-&gt;lineinfo,f-&gt;sizelineinfo,sizeof(*f-&gt;lineinfo),D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f-&gt;sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i&lt;n; i++) DumpString(f-&gt;upvalues[i],D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpInt(n=f-&gt;sizek,D);
+ for (i=0; i&lt;n; i++)
+ {
+  const TObject* o=&amp;f-&gt;k[i];
+  DumpByte(ttype(o),D);
+  switch (ttype(o))
+  {
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(tsvalue(o),D);
+	break;
+   case LUA_TNIL:
+	break;
+   default:
+	lua_assert(0);			/* cannot happen */
+	break;
+  }
+ }
+ DumpInt(n=f-&gt;sizep,D);
+ for (i=0; i&lt;n; i++) DumpFunction(f-&gt;p[i],f-&gt;source,D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
+{
+ DumpString((f-&gt;source==p) ? NULL : f-&gt;source,D);
+ DumpInt(f-&gt;lineDefined,D);
+ DumpByte(f-&gt;nups,D);
+ DumpByte(f-&gt;numparams,D);
+ DumpByte(f-&gt;is_vararg,D);
+ DumpByte(f-&gt;maxstacksize,D);
+ DumpLines(f,D);
+ DumpLocals(f,D);
+ DumpUpvalues(f,D);
+ DumpConstants(f,D);
+ DumpCode(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ DumpLiteral(LUA_SIGNATURE,D);
+ DumpByte(VERSION,D);
+ DumpByte(luaU_endianness(),D);
+ DumpByte(sizeof(int),D);
+ DumpByte(sizeof(size_t),D);
+ DumpByte(sizeof(Instruction),D);
+ DumpByte(SIZE_OP,D);
+ DumpByte(SIZE_A,D);
+ DumpByte(SIZE_B,D);
+ DumpByte(SIZE_C,D);
+ DumpByte(sizeof(lua_Number),D);
+ DumpNumber(TEST_NUMBER,D);
+}
+
+/*
+** dump function as precompiled chunk
+*/
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data)
+{
+ DumpState D;
+ D.L=L;
+ D.write=w;
+ D.data=data;
+ DumpHeader(&amp;D);
+ DumpFunction(Main,NULL,&amp;D);
+}
+

Added: trunk/Util/deditor/lua/lfunc.c
===================================================================
--- trunk/Util/deditor/lua/lfunc.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lfunc.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,135 @@
+/*
+** $Id: lfunc.c,v 1.67 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lfunc_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TObject)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TObject *)*((n)-1)))
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int nelems) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c-&gt;c.isC = 1;
+  c-&gt;c.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c-&gt;l.isC = 0;
+  c-&gt;l.g = *e;
+  c-&gt;l.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  GCObject **pp = &amp;L-&gt;openupval;
+  UpVal *p;
+  UpVal *v;
+  while ((p = ngcotouv(*pp)) != NULL &amp;&amp; p-&gt;v &gt;= level) {
+    if (p-&gt;v == level) return p;
+    pp = &amp;p-&gt;next;
+  }
+  v = luaM_new(L, UpVal);  /* not found: create a new one */
+  v-&gt;tt = LUA_TUPVAL;
+  v-&gt;marked = 1;  /* open upvalues should not be collected */
+  v-&gt;v = level;  /* current value lives in the stack */
+  v-&gt;next = *pp;  /* chain it in the proper position */
+  *pp = valtogco(v);
+  return v;
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *p;
+  while ((p = ngcotouv(L-&gt;openupval)) != NULL &amp;&amp; p-&gt;v &gt;= level) {
+    setobj(&amp;p-&gt;value, p-&gt;v);  /* save current value (write barrier) */
+    p-&gt;v = &amp;p-&gt;value;  /* now current value lives here */
+    L-&gt;openupval = p-&gt;next;  /* remove from `open' list */
+    luaC_link(L, valtogco(p), LUA_TUPVAL);
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = luaM_new(L, Proto);
+  luaC_link(L, valtogco(f), LUA_TPROTO);
+  f-&gt;k = NULL;
+  f-&gt;sizek = 0;
+  f-&gt;p = NULL;
+  f-&gt;sizep = 0;
+  f-&gt;code = NULL;
+  f-&gt;sizecode = 0;
+  f-&gt;sizelineinfo = 0;
+  f-&gt;sizeupvalues = 0;
+  f-&gt;nups = 0;
+  f-&gt;upvalues = NULL;
+  f-&gt;numparams = 0;
+  f-&gt;is_vararg = 0;
+  f-&gt;maxstacksize = 0;
+  f-&gt;lineinfo = NULL;
+  f-&gt;sizelocvars = 0;
+  f-&gt;locvars = NULL;
+  f-&gt;lineDefined = 0;
+  f-&gt;source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f-&gt;code, f-&gt;sizecode, Instruction);
+  luaM_freearray(L, f-&gt;p, f-&gt;sizep, Proto *);
+  luaM_freearray(L, f-&gt;k, f-&gt;sizek, TObject);
+  luaM_freearray(L, f-&gt;lineinfo, f-&gt;sizelineinfo, int);
+  luaM_freearray(L, f-&gt;locvars, f-&gt;sizelocvars, struct LocVar);
+  luaM_freearray(L, f-&gt;upvalues, f-&gt;sizeupvalues, TString *);
+  luaM_freelem(L, f);
+}
+
+
+void luaF_freeclosure (lua_State *L, Closure *c) {
+  int size = (c-&gt;c.isC) ? sizeCclosure(c-&gt;c.nupvalues) :
+                          sizeLclosure(c-&gt;l.nupvalues);
+  luaM_free(L, c, size);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i&lt;f-&gt;sizelocvars &amp;&amp; f-&gt;locvars[i].startpc &lt;= pc; i++) {
+    if (pc &lt; f-&gt;locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f-&gt;locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+

Added: trunk/Util/deditor/lua/lfunc.h
===================================================================
--- trunk/Util/deditor/lua/lfunc.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lfunc.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,25 @@
+/*
+** $Id: lfunc.h,v 1.21 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include &quot;lobject.h&quot;
+
+
+Proto *luaF_newproto (lua_State *L);
+Closure *luaF_newCclosure (lua_State *L, int nelems);
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e);
+UpVal *luaF_findupval (lua_State *L, StkId level);
+void luaF_close (lua_State *L, StkId level);
+void luaF_freeproto (lua_State *L, Proto *f);
+void luaF_freeclosure (lua_State *L, Closure *c);
+
+const char *luaF_getlocalname (const Proto *func, int local_number, int pc);
+
+
+#endif

Added: trunk/Util/deditor/lua/lgc.c
===================================================================
--- trunk/Util/deditor/lua/lgc.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lgc.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,493 @@
+/*
+** $Id: lgc.c,v 1.171 2003/04/03 13:35:34 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include &lt;string.h&gt;
+
+#define lgc_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+
+
+typedef struct GCState {
+  GCObject *tmark;  /* list of marked objects to be traversed */
+  GCObject *wk;  /* list of traversed key-weak tables (to be cleared) */
+  GCObject *wv;  /* list of traversed value-weak tables */
+  GCObject *wkv;  /* list of traversed key-value weak tables */
+  global_State *g;
+} GCState;
+
+
+/*
+** some userful bit tricks
+*/
+#define setbit(x,b)	((x) |= (1&lt;&lt;(b)))
+#define resetbit(x,b)	((x) &amp;= cast(lu_byte, ~(1&lt;&lt;(b))))
+#define testbit(x,b)	((x) &amp; (1&lt;&lt;(b)))
+
+#define unmark(x)	resetbit((x)-&gt;gch.marked, 0)
+#define ismarked(x)	((x)-&gt;gch.marked &amp; ((1&lt;&lt;4)|1))
+
+#define stringmark(s)	setbit((s)-&gt;tsv.marked, 0)
+
+
+#define isfinalized(u)		(!testbit((u)-&gt;uv.marked, 1))
+#define markfinalized(u)	resetbit((u)-&gt;uv.marked, 1)
+
+
+#define KEYWEAKBIT    1
+#define VALUEWEAKBIT  2
+#define KEYWEAK         (1&lt;&lt;KEYWEAKBIT)
+#define VALUEWEAK       (1&lt;&lt;VALUEWEAKBIT)
+
+
+
+#define markobject(st,o) { checkconsistency(o); \
+  if (iscollectable(o) &amp;&amp; !ismarked(gcvalue(o))) reallymarkobject(st,gcvalue(o)); }
+
+#define condmarkobject(st,o,c) { checkconsistency(o); \
+  if (iscollectable(o) &amp;&amp; !ismarked(gcvalue(o)) &amp;&amp; (c)) \
+    reallymarkobject(st,gcvalue(o)); }
+
+#define markvalue(st,t) { if (!ismarked(valtogco(t))) \
+		reallymarkobject(st, valtogco(t)); }
+
+
+
+static void reallymarkobject (GCState *st, GCObject *o) {
+  lua_assert(!ismarked(o));
+  setbit(o-&gt;gch.marked, 0);  /* mark object */
+  switch (o-&gt;gch.tt) {
+    case LUA_TUSERDATA: {
+      markvalue(st, gcotou(o)-&gt;uv.metatable);
+      break;
+    }
+    case LUA_TFUNCTION: {
+      gcotocl(o)-&gt;c.gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    case LUA_TTABLE: {
+      gcotoh(o)-&gt;gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    case LUA_TTHREAD: {
+      gcototh(o)-&gt;gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    case LUA_TPROTO: {
+      gcotop(o)-&gt;gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    default: lua_assert(o-&gt;gch.tt == LUA_TSTRING);
+  }
+}
+
+
+static void marktmu (GCState *st) {
+  GCObject *u;
+  for (u = st-&gt;g-&gt;tmudata; u; u = u-&gt;gch.next) {
+    unmark(u);  /* may be marked, if left from previous GC */
+    reallymarkobject(st, u);
+  }
+}
+
+
+/* move `dead' udata that need finalization to list `tmudata' */
+void luaC_separateudata (lua_State *L) {
+  GCObject **p = &amp;G(L)-&gt;rootudata;
+  GCObject *curr;
+  GCObject *collected = NULL;  /* to collect udata with gc event */
+  GCObject **lastcollected = &collected;
+  while ((curr = *p) != NULL) {
+    lua_assert(curr-&gt;gch.tt == LUA_TUSERDATA);
+    if (ismarked(curr) || isfinalized(gcotou(curr)))
+      p = &amp;curr-&gt;gch.next;  /* don't bother with them */
+
+    else if (fasttm(L, gcotou(curr)-&gt;uv.metatable, TM_GC) == NULL) {
+      markfinalized(gcotou(curr));  /* don't need finalization */
+      p = &amp;curr-&gt;gch.next;
+    }
+    else {  /* must call its gc method */
+      *p = curr-&gt;gch.next;
+      curr-&gt;gch.next = NULL;  /* link `curr' at the end of `collected' list */
+      *lastcollected = curr;
+      lastcollected = &amp;curr-&gt;gch.next;
+    }
+  }
+  /* insert collected udata with gc event into `tmudata' list */
+  *lastcollected = G(L)-&gt;tmudata;
+  G(L)-&gt;tmudata = collected;
+}
+
+
+static void removekey (Node *n) {
+  setnilvalue(gval(n));  /* remove corresponding value ... */
+  if (iscollectable(gkey(n)))
+    setttype(gkey(n), LUA_TNONE);  /* dead key; remove it */
+}
+
+
+static void traversetable (GCState *st, Table *h) {
+  int i;
+  int weakkey = 0;
+  int weakvalue = 0;
+  const TObject *mode;
+  markvalue(st, h-&gt;metatable);
+  lua_assert(h-&gt;lsizenode || h-&gt;node == st-&gt;g-&gt;dummynode);
+  mode = gfasttm(st-&gt;g, h-&gt;metatable, TM_MODE);
+  if (mode &amp;&amp; ttisstring(mode)) {  /* is there a weak mode? */
+    weakkey = (strchr(svalue(mode), 'k') != NULL);
+    weakvalue = (strchr(svalue(mode), 'v') != NULL);
+    if (weakkey || weakvalue) {  /* is really weak? */
+      GCObject **weaklist;
+      h-&gt;marked &amp;= ~(KEYWEAK | VALUEWEAK);  /* clear bits */
+      h-&gt;marked |= cast(lu_byte, (weakkey &lt;&lt; KEYWEAKBIT) |
+                                 (weakvalue &lt;&lt; VALUEWEAKBIT));
+      weaklist = (weakkey &amp;&amp; weakvalue) ? &amp;st-&gt;wkv :
+                              (weakkey) ? &amp;st-&gt;wk :
+                                          &amp;st-&gt;wv;
+      h-&gt;gclist = *weaklist;  /* must be cleared after GC, ... */
+      *weaklist = valtogco(h);  /* ... so put in the appropriate list */
+    }
+  }
+  if (!weakvalue) {
+    i = h-&gt;sizearray;
+    while (i--)
+      markobject(st, &amp;h-&gt;array[i]);
+  }
+  i = sizenode(h);
+  while (i--) {
+    Node *n = gnode(h, i);
+    if (!ttisnil(gval(n))) {
+      lua_assert(!ttisnil(gkey(n)));
+      condmarkobject(st, gkey(n), !weakkey);
+      condmarkobject(st, gval(n), !weakvalue);
+    }
+  }
+}
+
+
+static void traverseproto (GCState *st, Proto *f) {
+  int i;
+  stringmark(f-&gt;source);
+  for (i=0; i&lt;f-&gt;sizek; i++) {  /* mark literal strings */
+    if (ttisstring(f-&gt;k+i))
+      stringmark(tsvalue(f-&gt;k+i));
+  }
+  for (i=0; i&lt;f-&gt;sizeupvalues; i++)  /* mark upvalue names */
+    stringmark(f-&gt;upvalues[i]);
+  for (i=0; i&lt;f-&gt;sizep; i++)  /* mark nested protos */
+    markvalue(st, f-&gt;p[i]);
+  for (i=0; i&lt;f-&gt;sizelocvars; i++)  /* mark local-variable names */
+    stringmark(f-&gt;locvars[i].varname);
+  lua_assert(luaG_checkcode(f));
+}
+
+
+
+static void traverseclosure (GCState *st, Closure *cl) {
+  if (cl-&gt;c.isC) {
+    int i;
+    for (i=0; i&lt;cl-&gt;c.nupvalues; i++)  /* mark its upvalues */
+      markobject(st, &amp;cl-&gt;c.upvalue[i]);
+  }
+  else {
+    int i;
+    lua_assert(cl-&gt;l.nupvalues == cl-&gt;l.p-&gt;nups);
+    markvalue(st, hvalue(&amp;cl-&gt;l.g));
+    markvalue(st, cl-&gt;l.p);
+    for (i=0; i&lt;cl-&gt;l.nupvalues; i++) {  /* mark its upvalues */
+      UpVal *u = cl-&gt;l.upvals[i];
+      if (!u-&gt;marked) {
+        markobject(st, &amp;u-&gt;value);
+        u-&gt;marked = 1;
+      }
+    }
+  }
+}
+
+
+static void checkstacksizes (lua_State *L, StkId max) {
+  int used = L-&gt;ci - L-&gt;base_ci;  /* number of `ci' in use */
+  if (4*used &lt; L-&gt;size_ci &amp;&amp; 2*BASIC_CI_SIZE &lt; L-&gt;size_ci)
+    luaD_reallocCI(L, L-&gt;size_ci/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocCI(L, L-&gt;size_ci));
+  used = max - L-&gt;stack;  /* part of stack in use */
+  if (4*used &lt; L-&gt;stacksize &amp;&amp; 2*(BASIC_STACK_SIZE+EXTRA_STACK) &lt; L-&gt;stacksize)
+    luaD_reallocstack(L, L-&gt;stacksize/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize));
+}
+
+
+static void traversestack (GCState *st, lua_State *L1) {
+  StkId o, lim;
+  CallInfo *ci;
+  markobject(st, gt(L1));
+  lim = L1-&gt;top;
+  for (ci = L1-&gt;base_ci; ci &lt;= L1-&gt;ci; ci++) {
+    lua_assert(ci-&gt;top &lt;= L1-&gt;stack_last);
+    lua_assert(ci-&gt;state &amp; (CI_C | CI_HASFRAME | CI_SAVEDPC));
+    if (!(ci-&gt;state &amp; CI_C) &amp;&amp; lim &lt; ci-&gt;top)
+      lim = ci-&gt;top;
+  }
+  for (o = L1-&gt;stack; o &lt; L1-&gt;top; o++)
+    markobject(st, o);
+  for (; o &lt;= lim; o++)
+    setnilvalue(o);
+  checkstacksizes(L1, lim);
+}
+
+
+static void propagatemarks (GCState *st) {
+  while (st-&gt;tmark) {  /* traverse marked objects */
+    switch (st-&gt;tmark-&gt;gch.tt) {
+      case LUA_TTABLE: {
+        Table *h = gcotoh(st-&gt;tmark);
+        st-&gt;tmark = h-&gt;gclist;
+        traversetable(st, h);
+        break;
+      }
+      case LUA_TFUNCTION: {
+        Closure *cl = gcotocl(st-&gt;tmark);
+        st-&gt;tmark = cl-&gt;c.gclist;
+        traverseclosure(st, cl);
+        break;
+      }
+      case LUA_TTHREAD: {
+        lua_State *th = gcototh(st-&gt;tmark);
+        st-&gt;tmark = th-&gt;gclist;
+        traversestack(st, th);
+        break;
+      }
+      case LUA_TPROTO: {
+        Proto *p = gcotop(st-&gt;tmark);
+        st-&gt;tmark = p-&gt;gclist;
+        traverseproto(st, p);
+        break;
+      }
+      default: lua_assert(0);
+    }
+  }
+}
+
+
+static int valismarked (const TObject *o) {
+  if (ttisstring(o))
+    stringmark(tsvalue(o));  /* strings are `values', so are never weak */
+  return !iscollectable(o) || testbit(o-&gt;value.gc-&gt;gch.marked, 0);
+}
+
+
+/*
+** clear collected keys from weaktables
+*/
+static void cleartablekeys (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = sizenode(h);
+    lua_assert(h-&gt;marked &amp; KEYWEAK);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gkey(n)))  /* key was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h-&gt;gclist;
+  }
+}
+
+
+/*
+** clear collected values from weaktables
+*/
+static void cleartablevalues (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = h-&gt;sizearray;
+    lua_assert(h-&gt;marked &amp; VALUEWEAK);
+    while (i--) {
+      TObject *o = &amp;h-&gt;array[i];
+      if (!valismarked(o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    i = sizenode(h);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gval(n)))  /* value was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h-&gt;gclist;
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (o-&gt;gch.tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gcotop(o)); break;
+    case LUA_TFUNCTION: luaF_freeclosure(L, gcotocl(o)); break;
+    case LUA_TUPVAL: luaM_freelem(L, gcotouv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gcotoh(o)); break;
+    case LUA_TTHREAD: {
+      lua_assert(gcototh(o) != L &amp;&amp; gcototh(o) != G(L)-&gt;mainthread);
+      luaE_freethread(L, gcototh(o));
+      break;
+    }
+    case LUA_TSTRING: {
+      luaM_free(L, o, sizestring(gcotots(o)-&gt;tsv.len));
+      break;
+    }
+    case LUA_TUSERDATA: {
+      luaM_free(L, o, sizeudata(gcotou(o)-&gt;uv.len));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+static int sweeplist (lua_State *L, GCObject **p, int limit) {
+  GCObject *curr;
+  int count = 0;  /* number of collected items */
+  while ((curr = *p) != NULL) {
+    if (curr-&gt;gch.marked &gt; limit) {
+      unmark(curr);
+      p = &amp;curr-&gt;gch.next;
+    }
+    else {
+      count++;
+      *p = curr-&gt;gch.next;
+      freeobj(L, curr);
+    }
+  }
+  return count;
+}
+
+
+static void sweepstrings (lua_State *L, int all) {
+  int i;
+  for (i=0; i&lt;G(L)-&gt;strt.size; i++) {  /* for each list */
+    G(L)-&gt;strt.nuse -= sweeplist(L, &amp;G(L)-&gt;strt.hash[i], all);
+  }
+}
+
+
+static void checkSizes (lua_State *L) {
+  /* check size of string hash */
+  if (G(L)-&gt;strt.nuse &lt; cast(ls_nstr, G(L)-&gt;strt.size/4) &amp;&amp;
+      G(L)-&gt;strt.size &gt; MINSTRTABSIZE*2)
+    luaS_resize(L, G(L)-&gt;strt.size/2);  /* table is too big */
+  /* check size of buffer */
+  if (luaZ_sizebuffer(&amp;G(L)-&gt;buff) &gt; LUA_MINBUFFER*2) {  /* buffer too big? */
+    size_t newsize = luaZ_sizebuffer(&amp;G(L)-&gt;buff) / 2;
+    luaZ_resizebuffer(L, &amp;G(L)-&gt;buff, newsize);
+  }
+  G(L)-&gt;GCthreshold = 2*G(L)-&gt;nblocks;  /* new threshold */
+}
+
+
+static void do1gcTM (lua_State *L, Udata *udata) {
+  const TObject *tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);
+  if (tm != NULL) {
+    setobj2s(L-&gt;top, tm);
+    setuvalue(L-&gt;top+1, udata);
+    L-&gt;top += 2;
+    luaD_call(L, L-&gt;top - 2, 0);
+  }
+}
+
+
+void luaC_callGCTM (lua_State *L) {
+  lu_byte oldah = L-&gt;allowhook;
+  L-&gt;allowhook = 0;  /* stop debug hooks during GC tag methods */
+  L-&gt;top++;  /* reserve space to keep udata while runs its gc method */
+  while (G(L)-&gt;tmudata != NULL) {
+    GCObject *o = G(L)-&gt;tmudata;
+    Udata *udata = gcotou(o);
+    G(L)-&gt;tmudata = udata-&gt;uv.next;  /* remove udata from `tmudata' */
+    udata-&gt;uv.next = G(L)-&gt;rootudata;  /* return it to `root' list */
+    G(L)-&gt;rootudata = o;
+    setuvalue(L-&gt;top - 1, udata);  /* keep a reference to it */
+    unmark(o);
+    markfinalized(udata);
+    do1gcTM(L, udata);
+  }
+  L-&gt;top--;
+  L-&gt;allowhook = oldah;  /* restore hooks */
+}
+
+
+void luaC_sweep (lua_State *L, int all) {
+  if (all) all = 256;  /* larger than any mark */
+  sweeplist(L, &amp;G(L)-&gt;rootudata, all);
+  sweepstrings(L, all);
+  sweeplist(L, &amp;G(L)-&gt;rootgc, all);
+}
+
+
+/* mark root set */
+static void markroot (GCState *st, lua_State *L) {
+  global_State *g = st-&gt;g;
+  markobject(st, defaultmeta(L));
+  markobject(st, registry(L));
+  traversestack(st, g-&gt;mainthread);
+  if (L != g-&gt;mainthread)  /* another thread is running? */
+    markvalue(st, L);  /* cannot collect it */
+}
+
+
+static void mark (lua_State *L) {
+  GCState st;
+  GCObject *wkv;
+  st.g = G(L);
+  st.tmark = NULL;
+  st.wkv = st.wk = st.wv = NULL;
+  markroot(&amp;st, L);
+  propagatemarks(&amp;st);  /* mark all reachable objects */
+  cleartablevalues(st.wkv);
+  cleartablevalues(st.wv);
+  wkv = st.wkv;  /* keys must be cleared after preserving udata */
+  st.wkv = NULL;
+  st.wv = NULL;
+  luaC_separateudata(L);  /* separate userdata to be preserved */
+  marktmu(&amp;st);  /* mark `preserved' userdata */
+  propagatemarks(&amp;st);  /* remark, to propagate `preserveness' */
+  cleartablekeys(wkv);
+  /* `propagatemarks' may resuscitate some weak tables; clear them too */
+  cleartablekeys(st.wk);
+  cleartablevalues(st.wv);
+  cleartablekeys(st.wkv);
+  cleartablevalues(st.wkv);
+}
+
+
+void luaC_collectgarbage (lua_State *L) {
+  mark(L);
+  luaC_sweep(L, 0);
+  checkSizes(L);
+  luaC_callGCTM(L);
+}
+
+
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
+  o-&gt;gch.next = G(L)-&gt;rootgc;
+  G(L)-&gt;rootgc = o;
+  o-&gt;gch.marked = 0;
+  o-&gt;gch.tt = tt;
+}
+

Added: trunk/Util/deditor/lua/lgc.h
===================================================================
--- trunk/Util/deditor/lua/lgc.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lgc.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,25 @@
+/*
+** $Id: lgc.h,v 1.19 2003/02/28 19:45:15 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include &quot;lobject.h&quot;
+
+
+#define luaC_checkGC(L) { lua_assert(!(L-&gt;ci-&gt;state &amp; CI_CALLING)); \
+	if (G(L)-&gt;nblocks &gt;= G(L)-&gt;GCthreshold) luaC_collectgarbage(L); }
+
+
+void luaC_separateudata (lua_State *L);
+void luaC_callGCTM (lua_State *L);
+void luaC_sweep (lua_State *L, int all);
+void luaC_collectgarbage (lua_State *L);
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
+
+
+#endif

Added: trunk/Util/deditor/lua/lib/Makefile
===================================================================
--- trunk/Util/deditor/lua/lib/Makefile	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/Makefile	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,27 @@
+# makefile for Lua standard library
+
+LUA= ../..
+
+include $(LUA)/config
+
+EXTRA_DEFS= $(POPEN) $(TMPNAM) $(DEGREES) $(LOADLIB)
+
+OBJS= lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o ltablib.o lstrlib.o loadlib.o
+SRCS= lauxlib.c lbaselib.c ldblib.c liolib.c lmathlib.c ltablib.c lstrlib.c loadlib.c
+
+T= $(LIB)/liblualib.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/Util/deditor/lua/lib/README
===================================================================
--- trunk/Util/deditor/lua/lib/README	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/README	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,8 @@
+This is the standard Lua library.
+
+The code of the standard library can be read as an example of how to export
+C functions to Lua. The easiest library to read is lmathlib.c.
+
+The library is implemented entirely on top of the official Lua API as declared
+in lua.h, using lauxlib.c, which contains several useful functions for writing
+libraries. We encourage developers to use lauxlib.c in their own libraries.

Added: trunk/Util/deditor/lua/lib/lauxlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lauxlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lauxlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,591 @@
+/*
+** $Id: lauxlib.c,v 1.100 2003/04/07 14:35:00 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+
+
+/* number of prereserved references (for internal use) */
+#define RESERVED_REFS	2
+
+/* reserved references */
+#define FREELIST_REF	1	/* free list of references */
+#define ARRAYSIZE_REF	2	/* array sizes */
+
+
+/* convert a stack index to positive */
+#define abs_index(L, i)		((i) &gt; 0 || (i) &lt;= LUA_REGISTRYINDEX ? (i) : \
+					lua_gettop(L) + (i) + 1)
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  lua_getstack(L, 0, &amp;ar);
+  lua_getinfo(L, &quot;n&quot;, &amp;ar);
+  if (strcmp(ar.namewhat, &quot;method&quot;) == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, &quot;calling `%s' on bad self (%s)&quot;, ar.name, extramsg);
+  }
+  if (ar.name == NULL)
+    ar.name = &quot;?&quot;;
+  return luaL_error(L, &quot;bad argument #%d to `%s' (%s)&quot;,
+                        narg, ar.name, extramsg);
+}
+
+
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, &quot;%s expected, got %s&quot;,
+                                    tname, lua_typename(L, lua_type(L,narg)));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  luaL_typerror(L, narg, lua_typename(L, tag)); 
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &amp;ar)) {  /* check function at level */
+    lua_getinfo(L, &quot;Snl&quot;, &amp;ar);  /* get info about it */
+    if (ar.currentline &gt; 0) {  /* is there info? */
+      lua_pushfstring(L, &quot;%s:%d: &quot;, ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, &quot;&quot;);  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_findstring (const char *name, const char *const list[]) {
+  int i;
+  for (i=0; list[i]; i++)
+    if (strcmp(list[i], name) == 0)
+      return i;
+  return -1;  /* name not found */
+}
+
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry.name */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushstring(L, tname);
+  lua_pushvalue(L, -2);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry.name = metatable */
+  lua_pushvalue(L, -1);
+  lua_pushstring(L, tname);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry[metatable] = name */
+  return 1;
+}
+
+
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  const char *tn;
+  if (!lua_getmetatable(L, ud)) return NULL;  /* no metatable? */
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry[metatable] */
+  tn = lua_tostring(L, -1);
+  if (tn &amp;&amp; (strcmp(tn, tname) == 0)) {
+    lua_pop(L, 1);
+    return lua_touserdata(L, ud);
+  }
+  else {
+    lua_pop(L, 1);
+    return NULL;
+  }
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
+  if (!lua_checkstack(L, space))
+    luaL_error(L, &quot;stack overflow (%s)&quot;, mes);
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, &quot;value expected&quot;);
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tostring(L, narg);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  if (len) *len = lua_strlen(L, narg);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  lua_Number d = lua_tonumber(L, narg);
+  if (d == 0 &amp;&amp; !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  if (lua_isnoneornil(L, narg)) return def;
+  else return luaL_checknumber(L, narg);
+}
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = abs_index(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                              const luaL_reg *l, int nup) {
+  if (libname) {
+    lua_pushstring(L, libname);
+    lua_gettable(L, LUA_GLOBALSINDEX);  /* check whether lib already exists */
+    if (lua_isnil(L, -1)) {  /* no? */
+      lua_pop(L, 1);
+      lua_newtable(L);  /* create it */
+      lua_pushstring(L, libname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, LUA_GLOBALSINDEX);  /* register it with given name */
+    }
+    lua_insert(L, -(nup+1));  /* move library table to below upvalues */
+  }
+  for (; l-&gt;name; l++) {
+    int i;
+    lua_pushstring(L, l-&gt;name);
+    for (i=0; i&lt;nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -(nup+1));
+    lua_pushcclosure(L, l-&gt;func, nup);
+    lua_settable(L, -(nup+3));
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+
+/*
+** {======================================================
+** getn-setn: size for arrays
+** =======================================================
+*/
+
+static int checkint (lua_State *L, int topop) {
+  int n = (int)lua_tonumber(L, -1);
+  if (n == 0 &amp;&amp; !lua_isnumber(L, -1)) n = -1;
+  lua_pop(L, topop);
+  return n;
+}
+
+
+static void getsizes (lua_State *L) {
+  lua_rawgeti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);
+  if (lua_isnil(L, -1)) {  /* no `size' table? */
+    lua_pop(L, 1);  /* remove nil */
+    lua_newtable(L);  /* create it */
+    lua_pushvalue(L, -1);  /* `size' will be its own metatable */
+    lua_setmetatable(L, -2);
+    lua_pushliteral(L, &quot;__mode&quot;);
+    lua_pushliteral(L, &quot;k&quot;);
+    lua_rawset(L, -3);  /* metatable(N).__mode = &quot;k&quot; */
+    lua_pushvalue(L, -1);
+    lua_rawseti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);  /* store in register */
+  }
+}
+
+
+void luaL_setn (lua_State *L, int t, int n) {
+  t = abs_index(L, t);
+  lua_pushliteral(L, &quot;n&quot;);
+  lua_rawget(L, t);
+  if (checkint(L, 1) &gt;= 0) {  /* is there a numeric field `n'? */
+    lua_pushliteral(L, &quot;n&quot;);  /* use it */
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, t);
+  }
+  else {  /* use `sizes' */
+    getsizes(L);
+    lua_pushvalue(L, t);
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, -3);  /* sizes[t] = n */
+    lua_pop(L, 1);  /* remove `sizes' */
+  }
+}
+
+
+int luaL_getn (lua_State *L, int t) {
+  int n;
+  t = abs_index(L, t);
+  lua_pushliteral(L, &quot;n&quot;);  /* try t.n */
+  lua_rawget(L, t);
+  if ((n = checkint(L, 1)) &gt;= 0) return n;
+  getsizes(L);  /* else try sizes[t] */
+  lua_pushvalue(L, t);
+  lua_rawget(L, -2);
+  if ((n = checkint(L, 2)) &gt;= 0) return n;
+  for (n = 1; ; n++) {  /* else must count elements */
+    lua_rawgeti(L, t, n);
+    if (lua_isnil(L, -1)) break;
+    lua_pop(L, 1);
+  }
+  lua_pop(L, 1);
+  return n - 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#define bufflen(B)	((B)-&gt;p - (B)-&gt;buffer)
+#define bufffree(B)	((size_t)(LUAL_BUFFERSIZE - bufflen(B)))
+
+#define LIMIT	(LUA_MINSTACK/2)
+
+
+static int emptybuffer (luaL_Buffer *B) {
+  size_t l = bufflen(B);
+  if (l == 0) return 0;  /* put nothing on stack */
+  else {
+    lua_pushlstring(B-&gt;L, B-&gt;buffer, l);
+    B-&gt;p = B-&gt;buffer;
+    B-&gt;lvl++;
+    return 1;
+  }
+}
+
+
+static void adjuststack (luaL_Buffer *B) {
+  if (B-&gt;lvl &gt; 1) {
+    lua_State *L = B-&gt;L;
+    int toget = 1;  /* number of levels to concat */
+    size_t toplen = lua_strlen(L, -1);
+    do {
+      size_t l = lua_strlen(L, -(toget+1));
+      if (B-&gt;lvl - toget + 1 &gt;= LIMIT || toplen &gt; l) {
+        toplen += l;
+        toget++;
+      }
+      else break;
+    } while (toget &lt; B-&gt;lvl);
+    lua_concat(L, toget);
+    B-&gt;lvl = B-&gt;lvl - toget + 1;
+  }
+}
+
+
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
+  if (emptybuffer(B))
+    adjuststack(B);
+  return B-&gt;buffer;
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  while (l--)
+    luaL_putchar(B, *s++);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  emptybuffer(B);
+  lua_concat(B-&gt;L, B-&gt;lvl);
+  B-&gt;lvl = 1;
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B-&gt;L;
+  size_t vl = lua_strlen(L, -1);
+  if (vl &lt;= bufffree(B)) {  /* fit into buffer? */
+    memcpy(B-&gt;p, lua_tostring(L, -1), vl);  /* put it there */
+    B-&gt;p += vl;
+    lua_pop(L, 1);  /* remove from stack */
+  }
+  else {
+    if (emptybuffer(B))
+      lua_insert(L, -2);  /* put buffer before new value */
+    B-&gt;lvl++;  /* add new value into B stack */
+    adjuststack(B);
+  }
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B-&gt;L = L;
+  B-&gt;p = B-&gt;buffer;
+  B-&gt;lvl = 0;
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  t = abs_index(L, t);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
+  ref = (int)lua_tonumber(L, -1);  /* ref = t[FREELIST_REF] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */
+  }
+  else {  /* no free elements */
+    ref = luaL_getn(L, t);
+    if (ref &lt; RESERVED_REFS)
+      ref = RESERVED_REFS;  /* skip reserved references */
+    ref++;  /* create new reference */
+    luaL_setn(L, t, ref);
+  }
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref &gt;= 0) {
+    t = abs_index(L, t);
+    lua_rawgeti(L, t, FREELIST_REF);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[FREELIST_REF] */
+    lua_pushnumber(L, (lua_Number)ref);
+    lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
+  }
+}
+
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  FILE *f;
+  char buff[LUAL_BUFFERSIZE];
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;
+  if (feof(lf-&gt;f)) return NULL;
+  *size = fread(lf-&gt;buff, 1, LUAL_BUFFERSIZE, lf-&gt;f);
+  return (*size &gt; 0) ? lf-&gt;buff : NULL;
+}
+
+
+static int errfile (lua_State *L, int fnameindex) {
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, &quot;cannot read %s: %s&quot;, filename, strerror(errno));
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, &quot;=stdin&quot;);
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, &quot;@%s&quot;, filename);
+    lf.f = fopen(filename, &quot;r&quot;);
+  }
+  if (lf.f == NULL) return errfile(L, fnameindex);  /* unable to open file */
+  c = ungetc(getc(lf.f), lf.f);
+  if (!(isspace(c) || isprint(c)) &amp;&amp; lf.f != stdin) {  /* binary file? */
+    fclose(lf.f);
+    lf.f = fopen(filename, &quot;rb&quot;);  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, fnameindex); /* unable to reopen file */
+  }
+  status = lua_load(L, getF, &amp;lf, lua_tostring(L, -1));
+  readstatus = ferror(lf.f);
+  if (lf.f != stdin) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;
+  if (ls-&gt;size == 0) return NULL;
+  *size = ls-&gt;size;
+  ls-&gt;size = 0;
+  return ls-&gt;s;
+}
+
+
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
+                                const char *name) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &amp;ls, name);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** compatibility code
+** =======================================================
+*/
+
+
+static void callalert (lua_State *L, int status) {
+  if (status != 0) {
+    lua_getglobal(L, &quot;_ALERT&quot;);
+    if (lua_isfunction(L, -1)) {
+      lua_insert(L, -2);
+      lua_call(L, 1, 0);
+    }
+    else {  /* no _ALERT function; print it on stderr */
+      fprintf(stderr, &quot;%s\n&quot;, lua_tostring(L, -2));
+      lua_pop(L, 2);  /* remove error message and _ALERT */
+    }
+  }
+}
+
+
+static int aux_do (lua_State *L, int status) {
+  if (status == 0) {  /* parse OK? */
+    status = lua_pcall(L, 0, LUA_MULTRET, 0);  /* call main */
+  }
+  callalert(L, status);
+  return status;
+}
+
+
+LUALIB_API int lua_dofile (lua_State *L, const char *filename) {
+  return aux_do(L, luaL_loadfile(L, filename));
+}
+
+
+LUALIB_API int lua_dobuffer (lua_State *L, const char *buff, size_t size,
+                          const char *name) {
+  return aux_do(L, luaL_loadbuffer(L, buff, size, name));
+}
+
+
+LUALIB_API int lua_dostring (lua_State *L, const char *str) {
+  return lua_dobuffer(L, str, strlen(str), str);
+}
+
+/* }====================================================== */

Added: trunk/Util/deditor/lua/lib/lbaselib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lbaselib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lbaselib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,674 @@
+/*
+** $Id: lbaselib.c,v 1.130 2003/04/03 13:35:34 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include &lt;ctype.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define lbaselib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+
+/*
+** If your system does not support `stdout', you can just remove this function.
+** If you need, you can define your own `print' function, following this
+** model but changing `fputs' to put the strings at a proper place
+** (a console window or a log file, for instance).
+*/
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, &quot;tostring&quot;);
+  for (i=1; i&lt;=n; i++) {
+    const char *s;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tostring(L, -1);  /* get result */
+    if (s == NULL)
+      return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
+    if (i&gt;1) fputs(&quot;\t&quot;, stdout);
+    fputs(s, stdout);
+    lua_pop(L, 1);  /* pop result */
+  }
+  fputs(&quot;\n&quot;, stdout);
+  return 0;
+}
+
+
+static int luaB_tonumber (lua_State *L) {
+  int base = luaL_optint(L, 2, 10);
+  if (base == 10) {  /* standard conversion */
+    luaL_checkany(L, 1);
+    if (lua_isnumber(L, 1)) {
+      lua_pushnumber(L, lua_tonumber(L, 1));
+      return 1;
+    }
+  }
+  else {
+    const char *s1 = luaL_checkstring(L, 1);
+    char *s2;
+    unsigned long n;
+    luaL_argcheck(L, 2 &lt;= base &amp;&amp; base &lt;= 36, 2, &quot;base out of range&quot;);
+    n = strtoul(s1, &amp;s2, base);
+    if (s1 != s2) {  /* at least one valid digit? */
+      while (isspace((unsigned char)(*s2))) s2++;  /* skip trailing spaces */
+      if (*s2 == '\0') {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (lua_Number)n);
+        return 1;
+      }
+    }
+  }
+  lua_pushnil(L);  /* else not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  if (!lua_isstring(L, 1) || level == 0)
+    lua_pushvalue(L, 1);  /* propagate error message without changes */
+  else {  /* add extra information */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, &quot;__metatable&quot;);
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    &quot;nil or table expected&quot;);
+  if (luaL_getmetafield(L, 1, &quot;__metatable&quot;))
+    luaL_error(L, &quot;cannot change a protected metatable&quot;);
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static void getfunc (lua_State *L) {
+  if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
+  else {
+    lua_Debug ar;
+    int level = luaL_optint(L, 1, 1);
+    luaL_argcheck(L, level &gt;= 0, 1, &quot;level must be non-negative&quot;);
+    if (lua_getstack(L, level, &amp;ar) == 0)
+      luaL_argerror(L, 1, &quot;invalid level&quot;);
+    lua_getinfo(L, &quot;f&quot;, &amp;ar);
+    if (lua_isnil(L, -1))
+      luaL_error(L, &quot;no function environment for tail call at level %d&quot;,
+                    level);
+  }
+}
+
+
+static int aux_getfenv (lua_State *L) {
+  lua_getfenv(L, -1);
+  lua_pushliteral(L, &quot;__fenv&quot;);
+  lua_rawget(L, -2);
+  return !lua_isnil(L, -1);
+}
+
+
+static int luaB_getfenv (lua_State *L) {
+  getfunc(L);
+  if (!aux_getfenv(L))  /* __fenv not defined? */
+    lua_pop(L, 1);  /* remove it, to return real environment */
+  return 1;
+}
+
+
+static int luaB_setfenv (lua_State *L) {
+  luaL_checktype(L, 2, LUA_TTABLE);
+  getfunc(L);
+  if (aux_getfenv(L))  /* __fenv defined? */
+    luaL_error(L, &quot;`setfenv' cannot change a protected environment&quot;);
+  else
+    lua_pop(L, 2);  /* remove __fenv and real environment table */
+  lua_pushvalue(L, 2);
+  if (lua_isnumber(L, 1) &amp;&amp; lua_tonumber(L, 1) == 0)
+    lua_replace(L, LUA_GLOBALSINDEX);
+  else if (lua_setfenv(L, -2) == 0)
+    luaL_error(L, &quot;`setfenv' cannot change environment of given function&quot;);
+  return 0;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_gcinfo (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)lua_getgccount(L));
+  lua_pushnumber(L, (lua_Number)lua_getgcthreshold(L));
+  return 2;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  lua_setgcthreshold(L, luaL_optint(L, 1, 0));
+  return 0;
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, lua_typename(L, lua_type(L, 1)));
+  return 1;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushliteral(L, &quot;next&quot;);
+  lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+  lua_pushvalue(L, 1);  /* state, */
+  lua_pushnil(L);  /* and initial value */
+  return 3;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  lua_Number i = lua_tonumber(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (i == 0 &amp;&amp; lua_isnone(L, 2)) {  /* `for' start? */
+    lua_pushliteral(L, &quot;ipairs&quot;);
+    lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    lua_pushnumber(L, 0);  /* and initial value */
+    return 3;
+  }
+  else {  /* `for' step */
+    i++;  /* next value */
+    lua_pushnumber(L, i);
+    lua_rawgeti(L, 1, (int)i);
+    return (lua_isnil(L, -1)) ? 0 : 2;
+  }
+}
+
+
+static int load_aux (lua_State *L, int status) {
+  if (status == 0)  /* OK? */
+    return 1;
+  else {
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadstring (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  const char *chunkname = luaL_optstring(L, 2, s);
+  return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  return load_aux(L, luaL_loadfile(L, fname));
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  int status = luaL_loadfile(L, fname);
+  if (status != 0) lua_error(L);
+  lua_call(L, 0, LUA_MULTRET);
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_assert (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, &quot;%s&quot;, luaL_optstring(L, 2, &quot;assertion failed!&quot;));
+  lua_settop(L, 1);
+  return 1;
+}
+
+
+static int luaB_unpack (lua_State *L) {
+  int n, i;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  n = luaL_getn(L, 1);
+  luaL_checkstack(L, n, &quot;table too big to unpack&quot;);
+  for (i=1; i&lt;=n; i++)  /* push arg[1...n] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
+  lua_pushboolean(L, (status == 0));
+  lua_insert(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_insert(L, 1);  /* put error function under function to be called */
+  status = lua_pcall(L, 0, LUA_MULTRET, 1);
+  lua_pushboolean(L, (status == 0));
+  lua_replace(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  char buff[64];
+  luaL_checkany(L, 1);
+  if (luaL_callmeta(L, 1, &quot;__tostring&quot;))  /* is there a metafield? */
+    return 1;  /* use its value */
+  switch (lua_type(L, 1)) {
+    case LUA_TNUMBER:
+      lua_pushstring(L, lua_tostring(L, 1));
+      return 1;
+    case LUA_TSTRING:
+      lua_pushvalue(L, 1);
+      return 1;
+    case LUA_TBOOLEAN:
+      lua_pushstring(L, (lua_toboolean(L, 1) ? &quot;true&quot; : &quot;false&quot;));
+      return 1;
+    case LUA_TTABLE:
+      sprintf(buff, &quot;table: %p&quot;, lua_topointer(L, 1));
+      break;
+    case LUA_TFUNCTION:
+      sprintf(buff, &quot;function: %p&quot;, lua_topointer(L, 1));
+      break;
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      sprintf(buff, &quot;userdata: %p&quot;, lua_touserdata(L, 1));
+      break;
+    case LUA_TTHREAD:
+      sprintf(buff, &quot;thread: %p&quot;, (void *)lua_tothread(L, 1));
+      break;
+    case LUA_TNIL:
+      lua_pushliteral(L, &quot;nil&quot;);
+      return 1;
+  }
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int luaB_newproxy (lua_State *L) {
+  lua_settop(L, 1);
+  lua_newuserdata(L, 0);  /* create proxy */
+  if (lua_toboolean(L, 1) == 0)
+    return 1;  /* no metatable */
+  else if (lua_isboolean(L, 1)) {
+    lua_newtable(L);  /* create a new metatable `m' ... */
+    lua_pushvalue(L, -1);  /* ... and mark `m' as a valid metatable */
+    lua_pushboolean(L, 1);
+    lua_rawset(L, lua_upvalueindex(1));  /* weaktable[m] = true */
+  }
+  else {
+    int validproxy = 0;  /* to check if weaktable[metatable(u)] == true */
+    if (lua_getmetatable(L, 1)) {
+      lua_rawget(L, lua_upvalueindex(1));
+      validproxy = lua_toboolean(L, -1);
+      lua_pop(L, 1);  /* remove value */
+    }
+    luaL_argcheck(L, validproxy, 1, &quot;boolean or proxy expected&quot;);
+    lua_getmetatable(L, 1);  /* metatable is valid; get it */
+  }
+  lua_setmetatable(L, 2);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** `require' function
+** =======================================================
+*/
+
+
+/* name of global that holds table with loaded packages */
+#define REQTAB		&quot;_LOADED&quot;
+
+/* name of global that holds the search path for packages */
+#define LUA_PATH	&quot;LUA_PATH&quot;
+
+#ifndef LUA_PATH_SEP
+#define LUA_PATH_SEP	';'
+#endif
+
+#ifndef LUA_PATH_MARK
+#define LUA_PATH_MARK	'?'
+#endif
+
+#ifndef LUA_PATH_DEFAULT
+#define LUA_PATH_DEFAULT	&quot;?;?.lua&quot;
+#endif
+
+
+static const char *getpath (lua_State *L) {
+  const char *path;
+  lua_getglobal(L, LUA_PATH);  /* try global variable */
+  path = lua_tostring(L, -1);
+  lua_pop(L, 1);
+  if (path) return path;
+  path = getenv(LUA_PATH);  /* else try environment variable */
+  if (path) return path;
+  return LUA_PATH_DEFAULT;  /* else use default */
+}
+
+
+static const char *pushnextpath (lua_State *L, const char *path) {
+  const char *l;
+  if (*path == '\0') return NULL;  /* no more paths */
+  if (*path == LUA_PATH_SEP) path++;  /* skip separator */
+  l = strchr(path, LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path+strlen(path);
+  lua_pushlstring(L, path, l - path);  /* directory name */
+  return l;
+}
+
+
+static void pushcomposename (lua_State *L) {
+  const char *path = lua_tostring(L, -1);
+  const char *wild;
+  int n = 1;
+  while ((wild = strchr(path, LUA_PATH_MARK)) != NULL) {
+    /* is there stack space for prefix, name, and eventual last sufix? */
+    luaL_checkstack(L, 3, &quot;too many marks in a path component&quot;);
+    lua_pushlstring(L, path, wild - path);  /* push prefix */
+    lua_pushvalue(L, 1);  /* push package name (in place of MARK) */
+    path = wild + 1;  /* continue after MARK */
+    n += 2;
+  }
+  lua_pushstring(L, path);  /* push last sufix (`n' already includes this) */
+  lua_concat(L, n);
+}
+
+
+static int luaB_require (lua_State *L) {
+  const char *path;
+  int status = LUA_ERRFILE;  /* not found (yet) */
+  luaL_checkstring(L, 1);
+  lua_settop(L, 1);
+  lua_getglobal(L, REQTAB);
+  if (!lua_istable(L, 2)) return luaL_error(L, &quot;`&quot; REQTAB &quot;' is not a table&quot;);
+  path = getpath(L);
+  lua_pushvalue(L, 1);  /* check package's name in book-keeping table */
+  lua_rawget(L, 2);
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded; return its result */
+  else {  /* must load it */
+    while (status == LUA_ERRFILE) {
+      lua_settop(L, 3);  /* reset stack position */
+      if ((path = pushnextpath(L, path)) == NULL) break;
+      pushcomposename(L);
+      status = luaL_loadfile(L, lua_tostring(L, -1));  /* try to load it */
+    }
+  }
+  switch (status) {
+    case 0: {
+      lua_getglobal(L, &quot;_REQUIREDNAME&quot;);  /* save previous name */
+      lua_insert(L, -2);  /* put it below function */
+      lua_pushvalue(L, 1);
+      lua_setglobal(L, &quot;_REQUIREDNAME&quot;);  /* set new name */
+      lua_call(L, 0, 1);  /* run loaded module */
+      lua_insert(L, -2);  /* put result below previous name */
+      lua_setglobal(L, &quot;_REQUIREDNAME&quot;);  /* reset to previous name */
+      if (lua_isnil(L, -1)) {  /* no/nil return? */
+        lua_pushboolean(L, 1);
+        lua_replace(L, -2);  /* replace to true */
+      }
+      lua_pushvalue(L, 1);
+      lua_pushvalue(L, -2);
+      lua_rawset(L, 2);  /* mark it as loaded */
+      return 1;  /* return value */
+    }
+    case LUA_ERRFILE: {  /* file not found */
+      return luaL_error(L, &quot;could not load package `%s' from path `%s'&quot;,
+                            lua_tostring(L, 1), getpath(L));
+    }
+    default: {
+      return luaL_error(L, &quot;error loading package `%s' (%s)&quot;,
+                           lua_tostring(L, 1), lua_tostring(L, -1));
+    }
+  }
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg base_funcs[] = {
+  {&quot;error&quot;, luaB_error},
+  {&quot;getmetatable&quot;, luaB_getmetatable},
+  {&quot;setmetatable&quot;, luaB_setmetatable},
+  {&quot;getfenv&quot;, luaB_getfenv},
+  {&quot;setfenv&quot;, luaB_setfenv},
+  {&quot;next&quot;, luaB_next},
+  {&quot;ipairs&quot;, luaB_ipairs},
+  {&quot;pairs&quot;, luaB_pairs},
+  {&quot;print&quot;, luaB_print},
+  {&quot;tonumber&quot;, luaB_tonumber},
+  {&quot;tostring&quot;, luaB_tostring},
+  {&quot;type&quot;, luaB_type},
+  {&quot;assert&quot;, luaB_assert},
+  {&quot;unpack&quot;, luaB_unpack},
+  {&quot;rawequal&quot;, luaB_rawequal},
+  {&quot;rawget&quot;, luaB_rawget},
+  {&quot;rawset&quot;, luaB_rawset},
+  {&quot;pcall&quot;, luaB_pcall},
+  {&quot;xpcall&quot;, luaB_xpcall},
+  {&quot;collectgarbage&quot;, luaB_collectgarbage},
+  {&quot;gcinfo&quot;, luaB_gcinfo},
+  {&quot;loadfile&quot;, luaB_loadfile},
+  {&quot;dofile&quot;, luaB_dofile},
+  {&quot;loadstring&quot;, luaB_loadstring},
+  {&quot;require&quot;, luaB_require},
+  {NULL, NULL}
+};
+
+
+/*
+** {======================================================
+** Coroutine library
+** =======================================================
+*/
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg))
+    luaL_error(L, &quot;too many arguments to resume&quot;);
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, narg);
+  if (status == 0) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres))
+      luaL_error(L, &quot;too many results to resume&quot;);
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r &lt; 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r &lt; 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL = lua_newthread(L);
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1), 1,
+    &quot;Lua function expected&quot;);
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
+  if (L == co) lua_pushliteral(L, &quot;running&quot;);
+  else {
+    lua_Debug ar;
+    if (lua_getstack(co, 0, &amp;ar) == 0 &amp;&amp; lua_gettop(co) == 0)
+      lua_pushliteral(L, &quot;dead&quot;);
+    else
+      lua_pushliteral(L, &quot;suspended&quot;);
+  }
+  return 1;
+}
+
+
+static const luaL_reg co_funcs[] = {
+  {&quot;create&quot;, luaB_cocreate},
+  {&quot;wrap&quot;, luaB_cowrap},
+  {&quot;resume&quot;, luaB_coresume},
+  {&quot;yield&quot;, luaB_yield},
+  {&quot;status&quot;, luaB_costatus},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+static void base_open (lua_State *L) {
+  lua_pushliteral(L, &quot;_G&quot;);
+  lua_pushvalue(L, LUA_GLOBALSINDEX);
+  luaL_openlib(L, NULL, base_funcs, 0);  /* open lib into global table */
+  lua_pushliteral(L, &quot;_VERSION&quot;);
+  lua_pushliteral(L, LUA_VERSION);
+  lua_rawset(L, -3);  /* set global _VERSION */
+  /* `newproxy' needs a weaktable as upvalue */
+  lua_pushliteral(L, &quot;newproxy&quot;);
+  lua_newtable(L);  /* new table `w' */
+  lua_pushvalue(L, -1);  /* `w' will be its own metatable */
+  lua_setmetatable(L, -2);
+  lua_pushliteral(L, &quot;__mode&quot;);
+  lua_pushliteral(L, &quot;k&quot;);
+  lua_rawset(L, -3);  /* metatable(w).__mode = &quot;k&quot; */
+  lua_pushcclosure(L, luaB_newproxy, 1);
+  lua_rawset(L, -3);  /* set global `newproxy' */
+  lua_rawset(L, -1);  /* set global _G */
+}
+
+
+LUALIB_API int luaopen_base (lua_State *L) {
+  base_open(L);
+  luaL_openlib(L, LUA_COLIBNAME, co_funcs, 0);
+  lua_newtable(L);
+  lua_setglobal(L, REQTAB);
+  return 0;
+}
+

Added: trunk/Util/deditor/lua/lib/ldblib.c
===================================================================
--- trunk/Util/deditor/lua/lib/ldblib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/ldblib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,299 @@
+/*
+** $Id: ldblib.c,v 1.80 2003/04/03 13:35:34 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ldblib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, i);
+  lua_pushstring(L, v);
+  lua_rawset(L, -3);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushstring(L, i);
+  lua_pushnumber(L, (lua_Number)v);
+  lua_rawset(L, -3);
+}
+
+
+static int getinfo (lua_State *L) {
+  lua_Debug ar;
+  const char *options = luaL_optstring(L, 2, &quot;flnSu&quot;);
+  if (lua_isnumber(L, 1)) {
+    if (!lua_getstack(L, (int)(lua_tonumber(L, 1)), &amp;ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, 1)) {
+    lua_pushfstring(L, &quot;&gt;%s&quot;, options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, 1);
+  }
+  else
+    return luaL_argerror(L, 1, &quot;function or level expected&quot;);
+  if (!lua_getinfo(L, options, &amp;ar))
+    return luaL_argerror(L, 2, &quot;invalid option&quot;);
+  lua_newtable(L);
+  for (; *options; options++) {
+    switch (*options) {
+      case 'S':
+        settabss(L, &quot;source&quot;, ar.source);
+        settabss(L, &quot;short_src&quot;, ar.short_src);
+        settabsi(L, &quot;linedefined&quot;, ar.linedefined);
+        settabss(L, &quot;what&quot;, ar.what);
+        break;
+      case 'l':
+        settabsi(L, &quot;currentline&quot;, ar.currentline);
+        break;
+      case 'u':
+        settabsi(L, &quot;nups&quot;, ar.nups);
+        break;
+      case 'n':
+        settabss(L, &quot;name&quot;, ar.name);
+        settabss(L, &quot;namewhat&quot;, ar.namewhat);
+        break;
+      case 'f':
+        lua_pushliteral(L, &quot;func&quot;);
+        lua_pushvalue(L, -3);
+        lua_rawset(L, -3);
+        break;
+    }
+  }
+  return 1;  /* return table */
+}
+    
+
+static int getlocal (lua_State *L) {
+  lua_Debug ar;
+  const char *name;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &amp;ar))  /* level out of range? */
+    return luaL_argerror(L, 1, &quot;level out of range&quot;);
+  name = lua_getlocal(L, &amp;ar, luaL_checkint(L, 2));
+  if (name) {
+    lua_pushstring(L, name);
+    lua_pushvalue(L, -2);
+    return 2;
+  }
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int setlocal (lua_State *L) {
+  lua_Debug ar;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &amp;ar))  /* level out of range? */
+    return luaL_argerror(L, 1, &quot;level out of range&quot;);
+  luaL_checkany(L, 3);
+  lua_pushstring(L, lua_setlocal(L, &amp;ar, luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_iscfunction(L, 1)) return 0;  /* cannot touch C upvalues from Lua */
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+
+static const char KEY_HOOK = 'h';
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {&quot;call&quot;, &quot;return&quot;, &quot;line&quot;, &quot;count&quot;, &quot;tail return&quot;};
+  lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar-&gt;event]);
+    if (ar-&gt;currentline &gt;= 0)
+      lua_pushnumber(L, (lua_Number)ar-&gt;currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, &quot;lS&quot;, ar));
+    lua_call(L, 2, 0);
+  }
+  else
+    lua_pop(L, 1);  /* pop result from gettable */
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count &gt; 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask &amp; LUA_MASKCALL) smask[i++] = 'c';
+  if (mask &amp; LUA_MASKRET) smask[i++] = 'r';
+  if (mask &amp; LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int sethook (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {
+    lua_settop(L, 1);
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, 2);
+    int count = luaL_optint(L, 3, 0);
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_sethook(L, hookf, makemask(smask, count), count);
+  }
+  lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
+  lua_pushvalue(L, 1);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* set new hook */
+  return 0;
+}
+
+
+static int gethook (lua_State *L) {
+  char buff[5];
+  int mask = lua_gethookmask(L);
+  lua_Hook hook = lua_gethook(L);
+  if (hook != NULL &amp;&amp; hook != hookf)  /* external hook? */
+    lua_pushliteral(L, &quot;external hook&quot;);
+  else {
+    lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
+    lua_rawget(L, LUA_REGISTRYINDEX);   /* get hook */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushnumber(L, (lua_Number)lua_gethookcount(L));
+  return 3;
+}
+
+
+static int debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    fputs(&quot;lua_debug&gt; &quot;, stderr);
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, &quot;cont\n&quot;) == 0)
+      return 0;
+    lua_dostring(L, buffer);
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+static int errorfb (lua_State *L) {
+  int level = 1;  /* skip level 0 (it's this function) */
+  int firstpart = 1;  /* still before eventual `...' */
+  lua_Debug ar;
+  if (lua_gettop(L) == 0)
+    lua_pushliteral(L, &quot;&quot;);
+  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
+  else lua_pushliteral(L, &quot;\n&quot;);
+  lua_pushliteral(L, &quot;stack traceback:&quot;);
+  while (lua_getstack(L, level++, &amp;ar)) {
+    if (level &gt; LEVELS1 &amp;&amp; firstpart) {
+      /* no more than `LEVELS2' more levels? */
+      if (!lua_getstack(L, level+LEVELS2, &amp;ar))
+        level--;  /* keep going */
+      else {
+        lua_pushliteral(L, &quot;\n\t...&quot;);  /* too many levels */
+        while (lua_getstack(L, level+LEVELS2, &amp;ar))  /* find last levels */
+          level++;
+      }
+      firstpart = 0;
+      continue;
+    }
+    lua_pushliteral(L, &quot;\n\t&quot;);
+    lua_getinfo(L, &quot;Snl&quot;, &amp;ar);
+    lua_pushfstring(L, &quot;%s:&quot;, ar.short_src);
+    if (ar.currentline &gt; 0)
+      lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
+    switch (*ar.namewhat) {
+      case 'g':  /* global */ 
+      case 'l':  /* local */
+      case 'f':  /* field */
+      case 'm':  /* method */
+        lua_pushfstring(L, &quot; in function `%s'&quot;, ar.name);
+        break;
+      default: {
+        if (*ar.what == 'm')  /* main? */
+          lua_pushfstring(L, &quot; in main chunk&quot;);
+        else if (*ar.what == 'C' || *ar.what == 't')
+          lua_pushliteral(L, &quot; ?&quot;);  /* C function or tail call */
+        else
+          lua_pushfstring(L, &quot; in function &lt;%s:%d&gt;&quot;,
+                             ar.short_src, ar.linedefined);
+      }
+    }
+    lua_concat(L, lua_gettop(L));
+  }
+  lua_concat(L, lua_gettop(L));
+  return 1;
+}
+
+
+static const luaL_reg dblib[] = {
+  {&quot;getlocal&quot;, getlocal},
+  {&quot;getinfo&quot;, getinfo},
+  {&quot;gethook&quot;, gethook},
+  {&quot;getupvalue&quot;, getupvalue},
+  {&quot;sethook&quot;, sethook},
+  {&quot;setlocal&quot;, setlocal},
+  {&quot;setupvalue&quot;, setupvalue},
+  {&quot;debug&quot;, debug},
+  {&quot;traceback&quot;, errorfb},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_debug (lua_State *L) {
+  luaL_openlib(L, LUA_DBLIBNAME, dblib, 0);
+  lua_pushliteral(L, &quot;_TRACEBACK&quot;);
+  lua_pushcfunction(L, errorfb);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/liolib.c
===================================================================
--- trunk/Util/deditor/lua/lib/liolib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/liolib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,750 @@
+/*
+** $Id: liolib.c,v 2.39 2003/03/19 21:16:12 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;errno.h&gt;
+#include &lt;locale.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;time.h&gt;
+
+#define liolib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+/*
+** by default, gcc does not get `tmpname'
+*/
+#ifndef USE_TMPNAME
+#ifdef __GNUC__
+#define USE_TMPNAME	0
+#else
+#define USE_TMPNAME	1
+#endif
+#endif
+
+
+/*
+** by default, posix systems get `popen'
+*/
+#ifndef USE_POPEN
+#ifdef _POSIX_C_SOURCE
+#if _POSIX_C_SOURCE &gt;= 2
+#define USE_POPEN	1
+#endif
+#endif
+#endif
+
+#ifndef USE_POPEN
+#define USE_POPEN	0
+#endif
+
+
+
+
+/*
+** {======================================================
+** FILE Operations
+** =======================================================
+*/
+
+
+#if !USE_POPEN
+#define pclose(f)    (-1)
+#endif
+
+
+#define FILEHANDLE		&quot;FILE*&quot;
+
+#define IO_INPUT		&quot;_input&quot;
+#define IO_OUTPUT		&quot;_output&quot;
+
+
+static int pushresult (lua_State *L, int i, const char *filename) {
+  if (i) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (filename)
+      lua_pushfstring(L, &quot;%s: %s&quot;, filename, strerror(errno));
+    else
+      lua_pushfstring(L, &quot;%s&quot;, strerror(errno));
+    lua_pushnumber(L, errno);
+    return 3;
+  }
+}
+
+
+static FILE **topfile (lua_State *L, int findex) {
+  FILE **f = (FILE **)luaL_checkudata(L, findex, FILEHANDLE);
+  if (f == NULL) luaL_argerror(L, findex, &quot;bad file&quot;);
+  return f;
+}
+
+
+static int io_type (lua_State *L) {
+  FILE **f = (FILE **)luaL_checkudata(L, 1, FILEHANDLE);
+  if (f == NULL) lua_pushnil(L);
+  else if (*f == NULL)
+    lua_pushliteral(L, &quot;closed file&quot;);
+  else
+    lua_pushliteral(L, &quot;file&quot;);
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L, int findex) {
+  FILE **f = topfile(L, findex);
+  if (*f == NULL)
+    luaL_error(L, &quot;attempt to use a closed file&quot;);
+  return *f;
+}
+
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static FILE **newfile (lua_State *L) {
+  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));
+  *pf = NULL;  /* file handle is currently `closed' */
+  luaL_getmetatable(L, FILEHANDLE);
+  lua_setmetatable(L, -2);
+  return pf;
+}
+
+
+/*
+** assumes that top of the stack is the `io' library, and next is
+** the `io' metatable
+*/
+static void registerfile (lua_State *L, FILE *f, const char *name,
+                                                 const char *impname) {
+  lua_pushstring(L, name);
+  *newfile(L) = f;
+  if (impname) {
+    lua_pushstring(L, impname);
+    lua_pushvalue(L, -2);
+    lua_settable(L, -6);  /* metatable[impname] = file */
+  }
+  lua_settable(L, -3);  /* io[name] = file */
+}
+
+
+static int aux_close (lua_State *L) {
+  FILE *f = tofile(L, 1);
+  if (f == stdin || f == stdout || f == stderr)
+    return 0;  /* file cannot be closed */
+  else {
+    int ok = (pclose(f) != -1) || (fclose(f) == 0);
+    if (ok)
+      *(FILE **)lua_touserdata(L, 1) = NULL;  /* mark file as closed */
+    return ok;
+  }
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushstring(L, IO_OUTPUT);
+    lua_rawget(L, lua_upvalueindex(1));
+  }
+  return pushresult(L, aux_close(L), NULL);
+}
+
+
+static int io_gc (lua_State *L) {
+  FILE **f = topfile(L, 1);
+  if (*f != NULL)  /* ignore closed files */
+    aux_close(L);
+  return 0;
+}
+
+
+static int io_tostring (lua_State *L) {
+  char buff[32];
+  FILE **f = topfile(L, 1);
+  if (*f == NULL)
+    strcpy(buff, &quot;closed&quot;);
+  else
+    sprintf(buff, &quot;%p&quot;, lua_touserdata(L, 1));
+  lua_pushfstring(L, &quot;file (%s)&quot;, buff);
+  return 1;
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
+  FILE **pf = newfile(L);
+  *pf = fopen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+}
+
+
+static int io_popen (lua_State *L) {
+#if !USE_POPEN
+  luaL_error(L, &quot;`popen' not supported&quot;);
+  return 0;
+#else
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
+  FILE **pf = newfile(L);
+  *pf = popen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+#endif
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  FILE **pf = newfile(L);
+  *pf = tmpfile();
+  return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *name) {
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return tofile(L, -1);
+}
+
+
+static int g_iofile (lua_State *L, const char *name, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    lua_pushstring(L, name);
+    if (filename) {
+      FILE **pf = newfile(L);
+      *pf = fopen(filename, mode);
+      if (*pf == NULL) {
+        lua_pushfstring(L, &quot;%s: %s&quot;, filename, strerror(errno));
+        luaL_argerror(L, 1, lua_tostring(L, -1));
+      }
+    }
+    else {
+      tofile(L, 1);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_rawset(L, lua_upvalueindex(1));
+  }
+  /* return current value */
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, &quot;r&quot;);
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, &quot;w&quot;);
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int idx, int close) {
+  lua_pushliteral(L, FILEHANDLE);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  lua_pushvalue(L, idx);
+  lua_pushboolean(L, close);  /* close/not close file when finished */
+  lua_pushcclosure(L, io_readline, 3);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L, 1);  /* check that it's a valid file handle */
+  aux_lines(L, 1, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {  /* no arguments? */
+    lua_pushstring(L, IO_INPUT);
+    lua_rawget(L, lua_upvalueindex(1));  /* will iterate over default input */
+    return f_lines(L);
+  }
+  else {
+    const char *filename = luaL_checkstring(L, 1);
+    FILE **pf = newfile(L);
+    *pf = fopen(filename, &quot;r&quot;);
+    luaL_argcheck(L, *pf, 1,  strerror(errno));
+    aux_lines(L, lua_gettop(L), 1);
+    return 1;
+  }
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &amp;d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else return 0;  /* read fails */
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&amp;b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&amp;b);  /* close buffer */
+      return (lua_strlen(L, -1) &gt; 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (p[l-1] != '\n')
+      luaL_addsize(&amp;b, l);
+    else {
+      luaL_addsize(&amp;b, l - 1);  /* do not include `eol' */
+      luaL_pushresult(&amp;b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t rlen;  /* how much to read */
+  size_t nr;  /* number of chars actually read */
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  rlen = LUAL_BUFFERSIZE;  /* try to read that much each time */
+  do {
+    char *p = luaL_prepbuffer(&amp;b);
+    if (rlen &gt; n) rlen = n;  /* cannot read more than asked */
+    nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&amp;b, nr);
+    n -= nr;  /* still have to read `n' chars */
+  } while (n &gt; 0 &amp;&amp; nr == rlen);  /* until end of count or eof */
+  luaL_pushresult(&amp;b);  /* close buffer */
+  return (n == 0 || lua_strlen(L, -1) &gt; 0);
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, &quot;too many arguments&quot;);
+    success = 1;
+    for (n = first; nargs-- &amp;&amp; success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tonumber(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p &amp;&amp; p[0] == '*', n, &quot;invalid option&quot;);
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f);
+            break;
+          case 'a':  /* file */
+            read_chars(L, f, ~((size_t)0));  /* read MAX_SIZE_T chars */
+            success = 1; /* always success */
+            break;
+          case 'w':  /* word */
+            return luaL_error(L, &quot;obsolete option `*w' to `read'&quot;);
+          default:
+            return luaL_argerror(L, n, &quot;invalid format&quot;);
+        }
+      }
+    }
+  }
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L, 1), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  FILE *f = *(FILE **)lua_touserdata(L, lua_upvalueindex(2));
+  if (f == NULL)  /* file is already closed? */
+    luaL_error(L, &quot;file is already closed&quot;);
+  if (read_line(L, f)) return 1;
+  else {  /* EOF */
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(2));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - 1;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &amp;&amp;
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) &gt; 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &amp;l);
+      status = status &amp;&amp; (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  return pushresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  return g_write(L, tofile(L, 1), 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {&quot;set&quot;, &quot;cur&quot;, &quot;end&quot;, NULL};
+  FILE *f = tofile(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, &quot;cur&quot;), modenames);
+  long offset = luaL_optlong(L, 3, 0);
+  luaL_argcheck(L, op != -1, 2, &quot;invalid mode&quot;);
+  op = fseek(f, offset, mode[op]);
+  if (op)
+    return pushresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, ftell(f));
+    return 1;
+  }
+}
+
+
+static int io_flush (lua_State *L) {
+  return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return pushresult(L, fflush(tofile(L, 1)) == 0, NULL);
+}
+
+
+static const luaL_reg iolib[] = {
+  {&quot;input&quot;, io_input},
+  {&quot;output&quot;, io_output},
+  {&quot;lines&quot;, io_lines},
+  {&quot;close&quot;, io_close},
+  {&quot;flush&quot;, io_flush},
+  {&quot;open&quot;, io_open},
+  {&quot;popen&quot;, io_popen},
+  {&quot;read&quot;, io_read},
+  {&quot;tmpfile&quot;, io_tmpfile},
+  {&quot;type&quot;, io_type},
+  {&quot;write&quot;, io_write},
+  {NULL, NULL}
+};
+
+
+static const luaL_reg flib[] = {
+  {&quot;flush&quot;, f_flush},
+  {&quot;read&quot;, f_read},
+  {&quot;lines&quot;, f_lines},
+  {&quot;seek&quot;, f_seek},
+  {&quot;write&quot;, f_write},
+  {&quot;close&quot;, io_close},
+  {&quot;__gc&quot;, io_gc},
+  {&quot;__tostring&quot;, io_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, FILEHANDLE);  /* create new metatable for file handles */
+  /* file methods */
+  lua_pushliteral(L, &quot;__index&quot;);
+  lua_pushvalue(L, -2);  /* push metatable */
+  lua_rawset(L, -3);  /* metatable.__index = metatable */
+  luaL_openlib(L, NULL, flib, 0);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Other O.S. Operations
+** =======================================================
+*/
+
+static int io_execute (lua_State *L) {
+  lua_pushnumber(L, system(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+
+static int io_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return pushresult(L, remove(filename) == 0, filename);
+}
+
+
+static int io_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return pushresult(L, rename(fromname, toname) == 0, fromname);
+}
+
+
+static int io_tmpname (lua_State *L) {
+#if !USE_TMPNAME
+  luaL_error(L, &quot;`tmpname' not supported&quot;);
+  return 0;
+#else
+  char buff[L_tmpnam];
+  if (tmpnam(buff) != buff)
+    return luaL_error(L, &quot;unable to generate a unique filename in `tmpname'&quot;);
+  lua_pushstring(L, buff);
+  return 1;
+#endif
+}
+
+
+static int io_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int io_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushnumber(L, value);
+  lua_rawset(L, -3);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushboolean(L, value);
+  lua_rawset(L, -3);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  res = lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  if (lua_isnumber(L, -1))
+    res = (int)(lua_tonumber(L, -1));
+  else {
+    if (d == -2)
+      return luaL_error(L, &quot;field `%s' missing in date table&quot;, key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int io_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, &quot;%c&quot;);
+  time_t t = (time_t)(luaL_optnumber(L, 2, -1));
+  struct tm *stm;
+  if (t == (time_t)(-1))  /* no time given? */
+    t = time(NULL);  /* use current time */
+  if (*s == '!') {  /* UTC? */
+    stm = gmtime(&amp;t);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = localtime(&amp;t);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, &quot;*t&quot;) == 0) {
+    lua_newtable(L);
+    setfield(L, &quot;sec&quot;, stm-&gt;tm_sec);
+    setfield(L, &quot;min&quot;, stm-&gt;tm_min);
+    setfield(L, &quot;hour&quot;, stm-&gt;tm_hour);
+    setfield(L, &quot;day&quot;, stm-&gt;tm_mday);
+    setfield(L, &quot;month&quot;, stm-&gt;tm_mon+1);
+    setfield(L, &quot;year&quot;, stm-&gt;tm_year+1900);
+    setfield(L, &quot;wday&quot;, stm-&gt;tm_wday+1);
+    setfield(L, &quot;yday&quot;, stm-&gt;tm_yday+1);
+    setboolfield(L, &quot;isdst&quot;, stm-&gt;tm_isdst);
+  }
+  else {
+    char b[256];
+    if (strftime(b, sizeof(b), s, stm))
+      lua_pushstring(L, b);
+    else
+      return luaL_error(L, &quot;`date' format too long&quot;);
+  }
+  return 1;
+}
+
+
+static int io_time (lua_State *L) {
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    lua_pushnumber(L, time(NULL));  /* return current time */
+  else {
+    time_t t;
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, &quot;sec&quot;, 0);
+    ts.tm_min = getfield(L, &quot;min&quot;, 0);
+    ts.tm_hour = getfield(L, &quot;hour&quot;, 12);
+    ts.tm_mday = getfield(L, &quot;day&quot;, -2);
+    ts.tm_mon = getfield(L, &quot;month&quot;, -2) - 1;
+    ts.tm_year = getfield(L, &quot;year&quot;, -2) - 1900;
+    ts.tm_isdst = getboolfield(L, &quot;isdst&quot;);
+    t = mktime(&amp;ts);
+    if (t == (time_t)(-1))
+      lua_pushnil(L);
+    else
+      lua_pushnumber(L, t);
+  }
+  return 1;
+}
+
+
+static int io_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int io_setloc (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {&quot;all&quot;, &quot;collate&quot;, &quot;ctype&quot;, &quot;monetary&quot;,
+     &quot;numeric&quot;, &quot;time&quot;, NULL};
+  const char *l = lua_tostring(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, &quot;all&quot;), catnames);
+  luaL_argcheck(L, l || lua_isnoneornil(L, 1), 1, &quot;string expected&quot;);
+  luaL_argcheck(L, op != -1, 2, &quot;invalid option&quot;);
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int io_exit (lua_State *L) {
+  exit(luaL_optint(L, 1, EXIT_SUCCESS));
+  return 0;  /* to avoid warnings */
+}
+
+static const luaL_reg syslib[] = {
+  {&quot;clock&quot;,     io_clock},
+  {&quot;date&quot;,      io_date},
+  {&quot;difftime&quot;,  io_difftime},
+  {&quot;execute&quot;,   io_execute},
+  {&quot;exit&quot;,      io_exit},
+  {&quot;getenv&quot;,    io_getenv},
+  {&quot;remove&quot;,    io_remove},
+  {&quot;rename&quot;,    io_rename},
+  {&quot;setlocale&quot;, io_setloc},
+  {&quot;time&quot;,      io_time},
+  {&quot;tmpname&quot;,   io_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaopen_io (lua_State *L) {
+  luaL_openlib(L, LUA_OSLIBNAME, syslib, 0);
+  createmeta(L);
+  lua_pushvalue(L, -1);
+  luaL_openlib(L, LUA_IOLIBNAME, iolib, 1);
+  /* put predefined file handles into `io' table */
+  registerfile(L, stdin, &quot;stdin&quot;, IO_INPUT);
+  registerfile(L, stdout, &quot;stdout&quot;, IO_OUTPUT);
+  registerfile(L, stderr, &quot;stderr&quot;, NULL);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/lmathlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lmathlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lmathlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,246 @@
+/*
+** $Id: lmathlib.c,v 1.56 2003/03/11 12:30:37 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+#define lmathlib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+#undef PI
+#define PI (3.14159265358979323846)
+#define RADIANS_PER_DEGREE (PI/180.0)
+
+
+
+/*
+** If you want Lua to operate in degrees (instead of radians),
+** define USE_DEGREES
+*/
+#ifdef USE_DEGREES
+#define FROMRAD(a)	((a)/RADIANS_PER_DEGREE)
+#define TORAD(a)	((a)*RADIANS_PER_DEGREE)
+#else
+#define FROMRAD(a)	(a)
+#define TORAD(a)	(a)
+#endif
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, sin(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, cos(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, tan(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(asin(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(acos(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2))));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_mod (lua_State *L) {
+  lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_pushnumber(L, log(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &amp;e));
+  lua_pushnumber(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i&lt;=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d &lt; dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i&lt;=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d &gt; dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      int u = luaL_checkint(L, 1);
+      luaL_argcheck(L, 1&lt;=u, 1, &quot;interval is empty&quot;);
+      lua_pushnumber(L, (int)floor(r*u)+1);  /* int between 1 and `u' */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      int l = luaL_checkint(L, 1);
+      int u = luaL_checkint(L, 2);
+      luaL_argcheck(L, l&lt;=u, 2, &quot;interval is empty&quot;);
+      lua_pushnumber(L, (int)floor(r*(u-l+1))+l);  /* int between `l' and `u' */
+      break;
+    }
+    default: return luaL_error(L, &quot;wrong number of arguments&quot;);
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkint(L, 1));
+  return 0;
+}
+
+
+static const luaL_reg mathlib[] = {
+  {&quot;abs&quot;,   math_abs},
+  {&quot;sin&quot;,   math_sin},
+  {&quot;cos&quot;,   math_cos},
+  {&quot;tan&quot;,   math_tan},
+  {&quot;asin&quot;,  math_asin},
+  {&quot;acos&quot;,  math_acos},
+  {&quot;atan&quot;,  math_atan},
+  {&quot;atan2&quot;, math_atan2},
+  {&quot;ceil&quot;,  math_ceil},
+  {&quot;floor&quot;, math_floor},
+  {&quot;mod&quot;,   math_mod},
+  {&quot;frexp&quot;, math_frexp},
+  {&quot;ldexp&quot;, math_ldexp},
+  {&quot;sqrt&quot;,  math_sqrt},
+  {&quot;min&quot;,   math_min},
+  {&quot;max&quot;,   math_max},
+  {&quot;log&quot;,   math_log},
+  {&quot;log10&quot;, math_log10},
+  {&quot;exp&quot;,   math_exp},
+  {&quot;deg&quot;,   math_deg},
+  {&quot;pow&quot;,   math_pow},
+  {&quot;rad&quot;,   math_rad},
+  {&quot;random&quot;,     math_random},
+  {&quot;randomseed&quot;, math_randomseed},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUALIB_API int luaopen_math (lua_State *L) {
+  luaL_openlib(L, LUA_MATHLIBNAME, mathlib, 0);
+  lua_pushliteral(L, &quot;pi&quot;);
+  lua_pushnumber(L, PI);
+  lua_settable(L, -3);
+  lua_pushliteral(L, &quot;__pow&quot;);
+  lua_pushcfunction(L, math_pow);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/loadlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/loadlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/loadlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,205 @@
+/*
+** $Id: loadlib.c,v 1.4 2003/04/07 20:11:53 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+*
+* This  Lua library  exports a  single function,  called loadlib,  which is
+* called from Lua  as loadlib(lib,init), where lib is the  full name of the
+* library to be  loaded (including the complete path) and  init is the name
+* of a function  to be called after the library  is loaded. Typically, this
+* function will register other functions,  thus making the complete library
+* available  to Lua.  The init  function is  *not* automatically  called by
+* loadlib. Instead,  loadlib returns  the init function  as a  Lua function
+* that the client  can call when it  thinks is appropriate. In  the case of
+* errors,  loadlib  returns  nil  and two  strings  describing  the  error.
+* The  first string  is  supplied by  the operating  system;  it should  be
+* informative and useful  for error messages. The second  string is &quot;open&quot;,
+* &quot;init&quot;, or  &quot;absent&quot; to identify  the error and is  meant to be  used for
+* making  decisions without  having to  look into  the first  string (whose
+* format is system-dependent).
+*
+* This module contains  an implementation of loadlib for  Unix systems that
+* have dlfcn, an implementation for Windows,  and a stub for other systems.
+* See  the list  at  the end  of  this  file for  some  links to  available
+* implementations of dlfcn  and interfaces to other  native dynamic loaders
+* on top of which loadlib could be implemented.
+*
+*/
+
+#include &quot;lua.h&quot;
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+#undef LOADLIB
+
+
+#ifdef USE_DLOPEN
+#define LOADLIB
+/*
+* This is an implementation of loadlib based on the dlfcn interface.
+* The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+* NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+* as an emulation layer on top of native functions.
+*/
+
+#include &lt;dlfcn.h&gt;
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ void *lib=dlopen(path,RTLD_NOW);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) dlsym(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ /* else return appropriate error messages */
+ lua_pushnil(L);
+ lua_pushstring(L,dlerror());
+ lua_pushstring(L,(lib!=NULL) ? &quot;init&quot; : &quot;open&quot;);
+ if (lib!=NULL) dlclose(lib);
+ return 3;
+}
+
+#endif
+
+
+
+/*
+** In Windows, default is to use dll; otherwise, default is not to use dll
+*/
+#ifndef USE_DLL
+#ifdef _WIN32
+#define USE_DLL	1
+#else
+#define USE_DLL	0
+#endif
+#endif
+
+
+#if USE_DLL
+#define LOADLIB
+/*
+* This is an implementation of loadlib for Windows using native functions.
+*/
+
+#include &lt;windows.h&gt;
+
+static void pusherror(lua_State *L)
+{
+ int error=GetLastError();
+ char buffer[128];
+ if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+	0, error, 0, buffer, sizeof(buffer), 0))
+  lua_pushstring(L,buffer);
+ else
+  lua_pushfstring(L,&quot;system error %d\n&quot;,error);
+}
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ HINSTANCE lib=LoadLibrary(path);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) GetProcAddress(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ lua_pushnil(L);
+ pusherror(L);
+ lua_pushstring(L,(lib!=NULL) ? &quot;init&quot; : &quot;open&quot;);
+ if (lib!=NULL) FreeLibrary(lib);
+ return 3;
+}
+
+#endif
+
+
+
+#ifndef LOADLIB
+/* Fallback for other systems */
+
+/*
+** Those systems support dlopen, so they should have defined USE_DLOPEN.
+** The default (no)implementation gives them a special error message.
+*/
+#ifdef linux
+#define LOADLIB
+#endif
+
+#ifdef sun
+#define LOADLIB
+#endif
+
+#ifdef sgi
+#define LOADLIB
+#endif
+
+#ifdef BSD
+#define LOADLIB
+#endif
+
+#ifdef _WIN32
+#define LOADLIB
+#endif
+
+#ifdef LOADLIB
+#undef LOADLIB
+#define LOADLIB	&quot;`loadlib' not installed (check your Lua configuration)&quot;
+#else
+#define LOADLIB	&quot;`loadlib' not supported&quot;
+#endif
+
+static int loadlib(lua_State *L)
+{
+ lua_pushnil(L);
+ lua_pushliteral(L,LOADLIB);
+ lua_pushliteral(L,&quot;absent&quot;);
+ return 3;
+}
+#endif
+
+LUALIB_API int luaopen_loadlib (lua_State *L)
+{
+ lua_register(L,&quot;loadlib&quot;,loadlib);
+ return 0;
+}
+
+/*
+* Here are some links to available implementations of dlfcn and
+* interfaces to other native dynamic loaders on top of which loadlib
+* could be implemented. Please send contributions and corrections to us.
+*
+* AIX
+* Starting with AIX 4.2, dlfcn is included in the base OS.
+* There is also an emulation package available.
+* <A HREF="http://www.faqs.org/faqs/aix-faq/part4/section-21.html">http://www.faqs.org/faqs/aix-faq/part4/section-21.html</A>
+*
+* HPUX 
+* HPUX 11 has dlfcn. For HPUX 10 use shl_*.
+* <A HREF="http://www.geda.seul.org/mailinglist/geda-dev37/msg00094.html">http://www.geda.seul.org/mailinglist/geda-dev37/msg00094.html</A>
+* <A HREF="http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html">http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html</A>
+*
+* Macintosh, Windows
+* <A HREF="http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html">http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html</A>
+*
+* Mac OS X/Darwin
+* <A HREF="http://www.opendarwin.org/projects/dlcompat/">http://www.opendarwin.org/projects/dlcompat/</A>
+*
+* GLIB has wrapper code for BeOS, OS2, Unix and Windows
+* <A HREF="http://cvs.gnome.org/lxr/source/glib/gmodule/">http://cvs.gnome.org/lxr/source/glib/gmodule/</A>
+*
+*/

Added: trunk/Util/deditor/lua/lib/lstrlib.c
===================================================================
--- trunk/Util/deditor/lua/lib/lstrlib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/lstrlib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,770 @@
+/*
+** $Id: lstrlib.c,v 1.98 2003/04/03 13:35:34 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;stddef.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define lstrlib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+/* macro to `unsign' a character */
+#ifndef uchar
+#define uchar(c)        ((unsigned char)(c))
+#endif
+
+
+typedef long sint32;	/* a signed version for size_t */
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &amp;l);
+  lua_pushnumber(L, (lua_Number)l);
+  return 1;
+}
+
+
+static sint32 posrelat (sint32 pos, size_t len) {
+  /* relative string position: negative means back from end */
+  return (pos&gt;=0) ? pos : (sint32)len+pos+1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  sint32 start = posrelat(luaL_checklong(L, 2), l);
+  sint32 end = posrelat(luaL_optlong(L, 3, -1), l);
+  if (start &lt; 1) start = 1;
+  if (end &gt; (sint32)l) end = (sint32)l;
+  if (start &lt;= end)
+    lua_pushlstring(L, s+start-1, end-start+1);
+  else lua_pushliteral(L, &quot;&quot;);
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  luaL_buffinit(L, &amp;b);
+  for (i=0; i&lt;l; i++)
+    luaL_putchar(&amp;b, tolower(uchar(s[i])));
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  luaL_buffinit(L, &amp;b);
+  for (i=0; i&lt;l; i++)
+    luaL_putchar(&amp;b, toupper(uchar(s[i])));
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+static int str_rep (lua_State *L) {
+  size_t l;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  int n = luaL_checkint(L, 2);
+  luaL_buffinit(L, &amp;b);
+  while (n-- &gt; 0)
+    luaL_addlstring(&amp;b, s, l);
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  sint32 pos = posrelat(luaL_optlong(L, 2, 1), l);
+  if (pos &lt;= 0 || (size_t)(pos) &gt; l)  /* index out of range? */
+    return 0;  /* no answer */
+  lua_pushnumber(L, uchar(s[pos-1]));
+  return 1;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  for (i=1; i&lt;=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, &quot;invalid value&quot;);
+    luaL_putchar(&amp;b, uchar(c));
+  }
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 1;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  luaL_buffinit(L,&amp;b);
+  if (!lua_dump(L, writer, &amp;b))
+    luaL_error(L, &quot;unable to dump given function&quot;);
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+#ifndef MAX_CAPTURES
+#define MAX_CAPTURES 32  /* arbitrary limit */
+#endif
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+typedef struct MatchState {
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end (`\0') of source string */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    sint32 len;
+  } capture[MAX_CAPTURES];
+} MatchState;
+
+
+#define ESC		'%'
+#define SPECIALS	&quot;^$*+?.([%-&quot;
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l &lt; 0 || l &gt;= ms-&gt;level || ms-&gt;capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms-&gt;level;
+  for (level--; level&gt;=0; level--)
+    if (ms-&gt;capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms-&gt;L, &quot;invalid pattern capture&quot;);
+}
+
+
+static const char *luaI_classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case ESC: {
+      if (*p == '\0')
+        luaL_error(ms-&gt;L, &quot;malformed pattern (ends with `%')&quot;);
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (*p == '\0')
+          luaL_error(ms-&gt;L, &quot;malformed pattern (missing `]')&quot;);
+        if (*(p++) == ESC &amp;&amp; *p != '\0')
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p &lt; ec) {
+    if (*p == ESC) {
+      p++;
+      if (match_class(c, *p))
+        return sig;
+    }
+    else if ((*(p+1) == '-') &amp;&amp; (p+2 &lt; ec)) {
+      p+=2;
+      if (uchar(*(p-2)) &lt;= c &amp;&amp; c &lt;= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int luaI_singlematch (int c, const char *p, const char *ep) {
+  switch (*p) {
+    case '.': return 1;  /* matches any char */
+    case ESC: return match_class(c, *(p+1));
+    case '[': return matchbracketclass(c, p, ep-1);
+    default:  return (uchar(*p) == c);
+  }
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (*p == 0 || *(p+1) == 0)
+    luaL_error(ms-&gt;L, &quot;unbalanced pattern&quot;);
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s &lt; ms-&gt;src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  sint32 i = 0;  /* counts maximum expand for item */
+  while ((s+i)&lt;ms-&gt;src_end &amp;&amp; luaI_singlematch(uchar(*(s+i)), p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i&gt;=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (s&lt;ms-&gt;src_end &amp;&amp; luaI_singlematch(uchar(*s), p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms-&gt;level;
+  if (level &gt;= MAX_CAPTURES) luaL_error(ms-&gt;L, &quot;too many captures&quot;);
+  ms-&gt;capture[level].init = s;
+  ms-&gt;capture[level].len = what;
+  ms-&gt;level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms-&gt;level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms-&gt;capture[l].len = s - ms-&gt;capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms-&gt;capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms-&gt;capture[l].len;
+  if ((size_t)(ms-&gt;src_end-s) &gt;= len &amp;&amp;
+      memcmp(ms-&gt;capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  init: /* using goto's to optimize tail recursion */
+  switch (*p) {
+    case '(': {  /* start capture */
+      if (*(p+1) == ')')  /* position capture? */
+        return start_capture(ms, s, p+2, CAP_POSITION);
+      else
+        return start_capture(ms, s, p+1, CAP_UNFINISHED);
+    }
+    case ')': {  /* end capture */
+      return end_capture(ms, s, p+1);
+    }
+    case ESC: {
+      switch (*(p+1)) {
+        case 'b': {  /* balanced string? */
+          s = matchbalance(ms, s, p+2);
+          if (s == NULL) return NULL;
+          p+=4; goto init;  /* else return match(ms, s, p+4); */
+        }
+        case 'f': {  /* frontier? */
+          const char *ep; char previous;
+          p += 2;
+          if (*p != '[')
+            luaL_error(ms-&gt;L, &quot;missing `[' after `%%f' in pattern&quot;);
+          ep = luaI_classend(ms, p);  /* points to what is next */
+          previous = (s == ms-&gt;src_init) ? '\0' : *(s-1);
+          if (matchbracketclass(uchar(previous), p, ep-1) ||
+             !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
+          p=ep; goto init;  /* else return match(ms, s, ep); */
+        }
+        default: {
+          if (isdigit(uchar(*(p+1)))) {  /* capture results (%0-%9)? */
+            s = match_capture(ms, s, *(p+1));
+            if (s == NULL) return NULL;
+            p+=2; goto init;  /* else return match(ms, s, p+2) */
+          }
+          goto dflt;  /* case default */
+        }
+      }
+    }
+    case '\0': {  /* end of pattern */
+      return s;  /* match succeeded */
+    }
+    case '$': {
+      if (*(p+1) == '\0')  /* is the `$' the last char in pattern? */
+        return (s == ms-&gt;src_end) ? s : NULL;  /* check end of string */
+      else goto dflt;
+    }
+    default: dflt: {  /* it is a pattern item */
+      const char *ep = luaI_classend(ms, p);  /* points to what is next */
+      int m = s&lt;ms-&gt;src_end &amp;&amp; luaI_singlematch(uchar(*s), p, ep);
+      switch (*ep) {
+        case '?': {  /* optional */
+          const char *res;
+          if (m &amp;&amp; ((res=match(ms, s+1, ep+1)) != NULL))
+            return res;
+          p=ep+1; goto init;  /* else return match(ms, s, ep+1); */
+        }
+        case '*': {  /* 0 or more repetitions */
+          return max_expand(ms, s, p, ep);
+        }
+        case '+': {  /* 1 or more repetitions */
+          return (m ? max_expand(ms, s+1, p, ep) : NULL);
+        }
+        case '-': {  /* 0 or more repetitions (minimum) */
+          return min_expand(ms, s, p, ep);
+        }
+        default: {
+          if (!m) return NULL;
+          s++; p=ep; goto init;  /* else return match(ms, s+1, ep); */
+        }
+      }
+    }
+  }
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 &gt; l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 &gt; 0 &amp;&amp; (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i) {
+  int l = ms-&gt;capture[i].len;
+  if (l == CAP_UNFINISHED) luaL_error(ms-&gt;L, &quot;unfinished capture&quot;);
+  if (l == CAP_POSITION)
+    lua_pushnumber(ms-&gt;L, (lua_Number)(ms-&gt;capture[i].init - ms-&gt;src_init + 1));
+  else
+    lua_pushlstring(ms-&gt;L, ms-&gt;capture[i].init, l);
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  luaL_checkstack(ms-&gt;L, ms-&gt;level, &quot;too many captures&quot;);
+  if (ms-&gt;level == 0 &amp;&amp; s) {  /* no explicit captures? */
+    lua_pushlstring(ms-&gt;L, s, e-s);  /* return whole match */
+    return 1;
+  }
+  else {  /* return all captures */
+    for (i=0; i&lt;ms-&gt;level; i++)
+      push_onecapture(ms, i);
+    return ms-&gt;level;  /* number of strings pushed */
+  }
+}
+
+
+static int str_find (lua_State *L) {
+  size_t l1, l2;
+  const char *s = luaL_checklstring(L, 1, &amp;l1);
+  const char *p = luaL_checklstring(L, 2, &amp;l2);
+  sint32 init = posrelat(luaL_optlong(L, 3, 1), l1) - 1;
+  if (init &lt; 0) init = 0;
+  else if ((size_t)(init) &gt; l1) init = (sint32)l1;
+  if (lua_toboolean(L, 4) ||  /* explicit request? */
+      strpbrk(p, SPECIALS) == NULL) {  /* or no special characters? */
+    /* do a plain search */
+    const char *s2 = lmemfind(s+init, l1-init, p, l2);
+    if (s2) {
+      lua_pushnumber(L, (lua_Number)(s2-s+1));
+      lua_pushnumber(L, (lua_Number)(s2-s+l2));
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    int anchor = (*p == '^') ? (p++, 1) : 0;
+    const char *s1=s+init;
+    ms.L = L;
+    ms.src_init = s;
+    ms.src_end = s+l1;
+    do {
+      const char *res;
+      ms.level = 0;
+      if ((res=match(&amp;ms, s1, p)) != NULL) {
+        lua_pushnumber(L, (lua_Number)(s1-s+1));  /* start */
+        lua_pushnumber(L, (lua_Number)(res-s));   /* end */
+        return push_captures(&amp;ms, NULL, 0) + 2;
+      }
+    } while (s1++&lt;ms.src_end &amp;&amp; !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int gfind_aux (lua_State *L) {
+  MatchState ms;
+  const char *s = lua_tostring(L, lua_upvalueindex(1));
+  size_t ls = lua_strlen(L, lua_upvalueindex(1));
+  const char *p = lua_tostring(L, lua_upvalueindex(2));
+  const char *src;
+  ms.L = L;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  for (src = s + (size_t)lua_tonumber(L, lua_upvalueindex(3));
+       src &lt;= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    if ((e = match(&amp;ms, src, p)) != NULL) {
+      int newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushnumber(L, (lua_Number)newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&amp;ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gfind (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushnumber(L, 0);
+  lua_pushcclosure(L, gfind_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b,
+                   const char *s, const char *e) {
+  lua_State *L = ms-&gt;L;
+  if (lua_isstring(L, 3)) {
+    const char *news = lua_tostring(L, 3);
+    size_t l = lua_strlen(L, 3);
+    size_t i;
+    for (i=0; i&lt;l; i++) {
+      if (news[i] != ESC)
+        luaL_putchar(b, news[i]);
+      else {
+        i++;  /* skip ESC */
+        if (!isdigit(uchar(news[i])))
+          luaL_putchar(b, news[i]);
+        else {
+          int level = check_capture(ms, news[i]);
+          push_onecapture(ms, level);
+          luaL_addvalue(b);  /* add capture to accumulated result */
+        }
+      }
+    }
+  }
+  else {  /* is a function */
+    int n;
+    lua_pushvalue(L, 3);
+    n = push_captures(ms, s, e);
+    lua_call(L, n, 1);
+    if (lua_isstring(L, -1))
+      luaL_addvalue(b);  /* add return to accumulated result */
+    else
+      lua_pop(L, 1);  /* function result is not a string: pop it */
+  }
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl;
+  const char *src = luaL_checklstring(L, 1, &amp;srcl);
+  const char *p = luaL_checkstring(L, 2);
+  int max_s = luaL_optint(L, 4, srcl+1);
+  int anchor = (*p == '^') ? (p++, 1) : 0;
+  int n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L,
+    lua_gettop(L) &gt;= 3 &amp;&amp; (lua_isstring(L, 3) || lua_isfunction(L, 3)),
+    3, &quot;string or function expected&quot;);
+  luaL_buffinit(L, &amp;b);
+  ms.L = L;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  while (n &lt; max_s) {
+    const char *e;
+    ms.level = 0;
+    e = match(&amp;ms, src, p);
+    if (e) {
+      n++;
+      add_s(&amp;ms, &amp;b, src, e);
+    }
+    if (e &amp;&amp; e&gt;src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src &lt; ms.src_end)
+      luaL_putchar(&amp;b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&amp;b, src, ms.src_end-src);
+  luaL_pushresult(&amp;b);
+  lua_pushnumber(L, (lua_Number)n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+/* maximum size of each formatted item (&gt; len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* maximum size of each format specification (such as '%-099.99d') */
+#define MAX_FORMAT	20
+
+
+static void luaI_addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &amp;l);
+  luaL_putchar(b, '&quot;');
+  while (l--) {
+    switch (*s) {
+      case '&quot;': case '\\': case '\n': {
+        luaL_putchar(b, '\\');
+        luaL_putchar(b, *s);
+        break;
+      }
+      case '\0': {
+        luaL_addlstring(b, &quot;\\000&quot;, 4);
+        break;
+      }
+      default: {
+        luaL_putchar(b, *s);
+        break;
+      }
+    }
+    s++;
+  }
+  luaL_putchar(b, '&quot;');
+}
+
+
+static const char *scanformat (lua_State *L, const char *strfrmt,
+                                 char *form, int *hasprecision) {
+  const char *p = strfrmt;
+  while (strchr(&quot;-+ #0&quot;, *p)) p++;  /* skip flags */
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    *hasprecision = 1;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, &quot;invalid format (width or precision too long)&quot;);
+  if (p-strfrmt+2 &gt; MAX_FORMAT)  /* +2 to include `%' and the specifier */
+    luaL_error(L, &quot;invalid format (too long)&quot;);
+  form[0] = '%';
+  strncpy(form+1, strfrmt, p-strfrmt+1);
+  form[p-strfrmt+2] = 0;
+  return p;
+}
+
+
+static int str_format (lua_State *L) {
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &amp;sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  while (strfrmt &lt; strfrmt_end) {
+    if (*strfrmt != '%')
+      luaL_putchar(&amp;b, *strfrmt++);
+    else if (*++strfrmt == '%')
+      luaL_putchar(&amp;b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char buff[MAX_ITEM];  /* to store the formatted item */
+      int hasprecision = 0;
+      if (isdigit(uchar(*strfrmt)) &amp;&amp; *(strfrmt+1) == '$')
+        return luaL_error(L, &quot;obsolete option (d$) to `format'&quot;);
+      arg++;
+      strfrmt = scanformat(L, strfrmt, form, &amp;hasprecision);
+      switch (*strfrmt++) {
+        case 'c':  case 'd':  case 'i': {
+          sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'o':  case 'u':  case 'x':  case 'X': {
+          sprintf(buff, form, (unsigned int)(luaL_checknumber(L, arg)));
+          break;
+        }
+        case 'e':  case 'E': case 'f':
+        case 'g': case 'G': {
+          sprintf(buff, form, luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          luaI_addquoted(L, &amp;b, arg);
+          continue;  /* skip the `addsize' at the end */
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_checklstring(L, arg, &amp;l);
+          if (!hasprecision &amp;&amp; l &gt;= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            lua_pushvalue(L, arg);
+            luaL_addvalue(&amp;b);
+            continue;  /* skip the `addsize' at the end */
+          }
+          else {
+            sprintf(buff, form, s);
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, &quot;invalid option to `format'&quot;);
+        }
+      }
+      luaL_addlstring(&amp;b, buff, strlen(buff));
+    }
+  }
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static const luaL_reg strlib[] = {
+  {&quot;len&quot;, str_len},
+  {&quot;sub&quot;, str_sub},
+  {&quot;lower&quot;, str_lower},
+  {&quot;upper&quot;, str_upper},
+  {&quot;char&quot;, str_char},
+  {&quot;rep&quot;, str_rep},
+  {&quot;byte&quot;, str_byte},
+  {&quot;format&quot;, str_format},
+  {&quot;dump&quot;, str_dump},
+  {&quot;find&quot;, str_find},
+  {&quot;gfind&quot;, gfind},
+  {&quot;gsub&quot;, str_gsub},
+  {NULL, NULL}
+};
+
+
+/*
+** Open string library
+*/
+LUALIB_API int luaopen_string (lua_State *L) {
+  luaL_openlib(L, LUA_STRLIBNAME, strlib, 0);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/lib/ltablib.c
===================================================================
--- trunk/Util/deditor/lua/lib/ltablib.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lib/ltablib.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,250 @@
+/*
+** $Id: ltablib.c,v 1.21 2003/04/03 13:35:34 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stddef.h&gt;
+
+#define ltablib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_getn(L, n))
+
+
+static int luaB_foreachi (lua_State *L) {
+  int i;
+  int n = aux_getn(L, 1);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  for (i=1; i&lt;=n; i++) {
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushnumber(L, (lua_Number)i);  /* 1st argument */
+    lua_rawgeti(L, 1, i);  /* 2nd argument */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 1);  /* remove nil result */
+  }
+  return 0;
+}
+
+
+static int luaB_foreach (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_pushnil(L);  /* first key */
+  for (;;) {
+    if (lua_next(L, 1) == 0)
+      return 0;
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushvalue(L, -3);  /* key */
+    lua_pushvalue(L, -3);  /* value */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 2);  /* remove value and result */
+  }
+}
+
+
+static int luaB_getn (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)aux_getn(L, 1));
+  return 1;
+}
+
+
+static int luaB_setn (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_setn(L, 1, luaL_checkint(L, 2));
+  return 0;
+}
+
+
+static int luaB_tinsert (lua_State *L) {
+  int v = lua_gettop(L);  /* number of arguments */
+  int n = aux_getn(L, 1) + 1;
+  int pos;  /* where to insert new element */
+  if (v == 2)  /* called with only 2 arguments */
+    pos = n;  /* insert new element at the end */
+  else {
+    pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+    if (pos &gt; n) n = pos;  /* `grow' array if necessary */
+    v = 3;  /* function may be called with more than 3 args */
+  }
+  luaL_setn(L, 1, n);  /* new size */
+  while (--n &gt;= pos) {  /* move up elements */
+    lua_rawgeti(L, 1, n);
+    lua_rawseti(L, 1, n+1);  /* t[n+1] = t[n] */
+  }
+  lua_pushvalue(L, v);
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int luaB_tremove (lua_State *L) {
+  int n = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, n);
+  if (n &lt;= 0) return 0;  /* table is `empty' */
+  luaL_setn(L, 1, n-1);  /* t.n = n-1 */
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ;pos&lt;n; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, n);  /* t[n] = nil */
+  return 1;
+}
+
+
+static int str_concat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  const char *sep = luaL_optlstring(L, 2, &quot;&quot;, &amp;lsep);
+  int i = luaL_optint(L, 3, 1);
+  int n = luaL_optint(L, 4, 0);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (n == 0) n = luaL_getn(L, 1);
+  luaL_buffinit(L, &amp;b);
+  for (; i &lt;= n; i++) {
+    lua_rawgeti(L, 1, i);
+    luaL_argcheck(L, lua_isstring(L, -1), 1, &quot;table contains non-strings&quot;);
+    luaL_addvalue(&amp;b);
+    if (i != n)
+      luaL_addlstring(&amp;b, sep, lsep);
+  }
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a &lt; b? */
+    return lua_lessthan(L, a, b);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l &lt; u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] &lt; a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]&lt;a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]&lt;a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] &lt;= P == a[u-1] &lt;= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] &lt;= P &lt;= a[j..u] */
+      /* repeat ++i until a[i] &gt;= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i&gt;u) luaL_error(L, &quot;invalid order function for sorting&quot;);
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] &lt;= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j&lt;l) luaL_error(L, &quot;invalid order function for sorting&quot;);
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j&lt;i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] &lt;= a[i] == P &lt;= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l &lt; u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int luaB_sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, &quot;&quot;);  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg tab_funcs[] = {
+  {&quot;concat&quot;, str_concat},
+  {&quot;foreach&quot;, luaB_foreach},
+  {&quot;foreachi&quot;, luaB_foreachi},
+  {&quot;getn&quot;, luaB_getn},
+  {&quot;setn&quot;, luaB_setn},
+  {&quot;sort&quot;, luaB_sort},
+  {&quot;insert&quot;, luaB_tinsert},
+  {&quot;remove&quot;, luaB_tremove},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_table (lua_State *L) {
+  luaL_openlib(L, LUA_TABLIBNAME, tab_funcs, 0);
+  return 1;
+}
+

Added: trunk/Util/deditor/lua/llex.c
===================================================================
--- trunk/Util/deditor/lua/llex.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/llex.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,417 @@
+/*
+** $Id: llex.c,v 1.119 2003/03/24 12:39:34 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;string.h&gt;
+
+#define llex_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldo.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;lzio.h&quot;
+
+
+
+#define next(LS) (LS-&gt;current = zgetc(LS-&gt;z))
+
+
+
+/* ORDER RESERVED */
+static const char *const token2string [] = {
+    &quot;and&quot;, &quot;break&quot;, &quot;do&quot;, &quot;else&quot;, &quot;elseif&quot;,
+    &quot;end&quot;, &quot;false&quot;, &quot;for&quot;, &quot;function&quot;, &quot;if&quot;,
+    &quot;in&quot;, &quot;local&quot;, &quot;nil&quot;, &quot;not&quot;, &quot;or&quot;, &quot;repeat&quot;,
+    &quot;return&quot;, &quot;then&quot;, &quot;true&quot;, &quot;until&quot;, &quot;while&quot;, &quot;*name&quot;,
+    &quot;..&quot;, &quot;...&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;~=&quot;,
+    &quot;*number&quot;, &quot;*string&quot;, &quot;&lt;eof&gt;&quot;
+};
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i&lt;NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, token2string[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    lua_assert(strlen(token2string[i])+1 &lt;= TOKEN_LEN);
+    ts-&gt;tsv.reserved = cast(lu_byte, i+1);  /* reserved word */
+  }
+}
+
+
+#define MAXSRC          80
+
+
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg) {
+  if (val &gt; limit) {
+    msg = luaO_pushfstring(ls-&gt;L, &quot;too many %s (limit=%d)&quot;, msg, limit);
+    luaX_syntaxerror(ls, msg);
+  }
+}
+
+
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line) {
+  lua_State *L = ls-&gt;L;
+  char buff[MAXSRC];
+  luaO_chunkid(buff, getstr(ls-&gt;source), MAXSRC);
+  luaO_pushfstring(L, &quot;%s:%d: %s near `%s'&quot;, buff, line, s, token); 
+  luaD_throw(L, LUA_ERRSYNTAX);
+}
+
+
+static void luaX_error (LexState *ls, const char *s, const char *token) {
+  luaX_errorline(ls, s, token, ls-&gt;linenumber);
+}
+
+
+void luaX_syntaxerror (LexState *ls, const char *msg) {
+  const char *lasttoken;
+  switch (ls-&gt;t.token) {
+    case TK_NAME:
+      lasttoken = getstr(ls-&gt;t.seminfo.ts);
+      break;
+    case TK_STRING:
+    case TK_NUMBER:
+      lasttoken = luaZ_buffer(ls-&gt;buff);
+      break;
+    default:
+      lasttoken = luaX_token2str(ls, ls-&gt;t.token);
+      break;
+  }
+  luaX_error(ls, msg, lasttoken);
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token &lt; FIRST_RESERVED) {
+    lua_assert(token == (unsigned char)token);
+    return luaO_pushfstring(ls-&gt;L, &quot;%c&quot;, token);
+  }
+  else
+    return token2string[token-FIRST_RESERVED];
+}
+
+
+static void luaX_lexerror (LexState *ls, const char *s, int token) {
+  if (token == TK_EOS)
+    luaX_error(ls, s, luaX_token2str(ls, token));
+  else
+    luaX_error(ls, s, luaZ_buffer(ls-&gt;buff));
+}
+
+
+static void inclinenumber (LexState *LS) {
+  next(LS);  /* skip `\n' */
+  ++LS-&gt;linenumber;
+  luaX_checklimit(LS, LS-&gt;linenumber, MAX_INT, &quot;lines in a chunk&quot;);
+}
+
+
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source) {
+  LS-&gt;L = L;
+  LS-&gt;lookahead.token = TK_EOS;  /* no look-ahead token */
+  LS-&gt;z = z;
+  LS-&gt;fs = NULL;
+  LS-&gt;linenumber = 1;
+  LS-&gt;lastline = 1;
+  LS-&gt;source = source;
+  next(LS);  /* read first char */
+  if (LS-&gt;current == '#') {
+    do {  /* skip first line */
+      next(LS);
+    } while (LS-&gt;current != '\n' &amp;&amp; LS-&gt;current != EOZ);
+  }
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+/* use buffer to store names, literal strings and numbers */
+
+/* extra space to allocate when growing buffer */
+#define EXTRABUFF	32
+
+/* maximum number of chars that can be read without checking buffer size */
+#define MAXNOCHECK	5
+
+#define checkbuffer(LS, len)	\
+    if (((len)+MAXNOCHECK)*sizeof(char) &gt; luaZ_sizebuffer((LS)-&gt;buff)) \
+      luaZ_openspace((LS)-&gt;L, (LS)-&gt;buff, (len)+EXTRABUFF)
+
+#define save(LS, c, l) \
+	(luaZ_buffer((LS)-&gt;buff)[l++] = cast(char, c))
+#define save_and_next(LS, l)  (save(LS, LS-&gt;current, l), next(LS))
+
+
+static size_t readname (LexState *LS) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  do {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  } while (isalnum(LS-&gt;current) || LS-&gt;current == '_');
+  save(LS, '\0', l);
+  return l-1;
+}
+
+
+/* LUA_NUMBER */
+static void read_numeral (LexState *LS, int comma, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  if (comma) save(LS, '.', l);
+  while (isdigit(LS-&gt;current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS-&gt;current == '.') {
+    save_and_next(LS, l);
+    if (LS-&gt;current == '.') {
+      save_and_next(LS, l);
+      save(LS, '\0', l);
+      luaX_lexerror(LS,
+                 &quot;ambiguous syntax (decimal point x string concatenation)&quot;,
+                 TK_NUMBER);
+    }
+  }
+  while (isdigit(LS-&gt;current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS-&gt;current == 'e' || LS-&gt;current == 'E') {
+    save_and_next(LS, l);  /* read `E' */
+    if (LS-&gt;current == '+' || LS-&gt;current == '-')
+      save_and_next(LS, l);  /* optional exponent sign */
+    while (isdigit(LS-&gt;current)) {
+      checkbuffer(LS, l);
+      save_and_next(LS, l);
+    }
+  }
+  save(LS, '\0', l);
+  if (!luaO_str2d(luaZ_buffer(LS-&gt;buff), &amp;seminfo-&gt;r))
+    luaX_lexerror(LS, &quot;malformed number&quot;, TK_NUMBER);
+}
+
+
+static void read_long_string (LexState *LS, SemInfo *seminfo) {
+  int cont = 0;
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save(LS, '[', l);  /* save first `[' */
+  save_and_next(LS, l);  /* pass the second `[' */
+  if (LS-&gt;current == '\n')  /* string starts with a newline? */
+    inclinenumber(LS);  /* skip it */
+  for (;;) {
+    checkbuffer(LS, l);
+    switch (LS-&gt;current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, (seminfo) ? &quot;unfinished long string&quot; :
+                                   &quot;unfinished long comment&quot;, TK_EOS);
+        break;  /* to avoid warnings */
+      case '[':
+        save_and_next(LS, l);
+        if (LS-&gt;current == '[') {
+          cont++;
+          save_and_next(LS, l);
+        }
+        continue;
+      case ']':
+        save_and_next(LS, l);
+        if (LS-&gt;current == ']') {
+          if (cont == 0) goto endloop;
+          cont--;
+          save_and_next(LS, l);
+        }
+        continue;
+      case '\n':
+        save(LS, '\n', l);
+        inclinenumber(LS);
+        if (!seminfo) l = 0;  /* reset buffer to avoid wasting space */
+        continue;
+      default:
+        save_and_next(LS, l);
+    }
+  } endloop:
+  save_and_next(LS, l);  /* skip the second `]' */
+  save(LS, '\0', l);
+  if (seminfo)
+    seminfo-&gt;ts = luaS_newlstr(LS-&gt;L, luaZ_buffer(LS-&gt;buff) + 2, l - 5);
+}
+
+
+static void read_string (LexState *LS, int del, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save_and_next(LS, l);
+  while (LS-&gt;current != del) {
+    checkbuffer(LS, l);
+    switch (LS-&gt;current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, &quot;unfinished string&quot;, TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+        save(LS, '\0', l);
+        luaX_lexerror(LS, &quot;unfinished string&quot;, TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\':
+        next(LS);  /* do not save the `\' */
+        switch (LS-&gt;current) {
+          case 'a': save(LS, '\a', l); next(LS); break;
+          case 'b': save(LS, '\b', l); next(LS); break;
+          case 'f': save(LS, '\f', l); next(LS); break;
+          case 'n': save(LS, '\n', l); next(LS); break;
+          case 'r': save(LS, '\r', l); next(LS); break;
+          case 't': save(LS, '\t', l); next(LS); break;
+          case 'v': save(LS, '\v', l); next(LS); break;
+          case '\n': save(LS, '\n', l); inclinenumber(LS); break;
+          case EOZ: break;  /* will raise an error next loop */
+          default: {
+            if (!isdigit(LS-&gt;current))
+              save_and_next(LS, l);  /* handles \\, \&quot;, \', and \? */
+            else {  /* \xxx */
+              int c = 0;
+              int i = 0;
+              do {
+                c = 10*c + (LS-&gt;current-'0');
+                next(LS);
+              } while (++i&lt;3 &amp;&amp; isdigit(LS-&gt;current));
+              if (c &gt; UCHAR_MAX) {
+                save(LS, '\0', l);
+                luaX_lexerror(LS, &quot;escape sequence too large&quot;, TK_STRING);
+              }
+              save(LS, c, l);
+            }
+          }
+        }
+        break;
+      default:
+        save_and_next(LS, l);
+    }
+  }
+  save_and_next(LS, l);  /* skip delimiter */
+  save(LS, '\0', l);
+  seminfo-&gt;ts = luaS_newlstr(LS-&gt;L, luaZ_buffer(LS-&gt;buff) + 1, l - 3);
+}
+
+
+int luaX_lex (LexState *LS, SemInfo *seminfo) {
+  for (;;) {
+    switch (LS-&gt;current) {
+
+      case '\n': {
+        inclinenumber(LS);
+        continue;
+      }
+      case '-': {
+        next(LS);
+        if (LS-&gt;current != '-') return '-';
+        /* else is a comment */
+        next(LS);
+        if (LS-&gt;current == '[' &amp;&amp; (next(LS), LS-&gt;current == '['))
+          read_long_string(LS, NULL);  /* long comment */
+        else  /* short comment */
+          while (LS-&gt;current != '\n' &amp;&amp; LS-&gt;current != EOZ)
+            next(LS);
+        continue;
+      }
+      case '[': {
+        next(LS);
+        if (LS-&gt;current != '[') return '[';
+        else {
+          read_long_string(LS, seminfo);
+          return TK_STRING;
+        }
+      }
+      case '=': {
+        next(LS);
+        if (LS-&gt;current != '=') return '=';
+        else { next(LS); return TK_EQ; }
+      }
+      case '&lt;': {
+        next(LS);
+        if (LS-&gt;current != '=') return '&lt;';
+        else { next(LS); return TK_LE; }
+      }
+      case '&gt;': {
+        next(LS);
+        if (LS-&gt;current != '=') return '&gt;';
+        else { next(LS); return TK_GE; }
+      }
+      case '~': {
+        next(LS);
+        if (LS-&gt;current != '=') return '~';
+        else { next(LS); return TK_NE; }
+      }
+      case '&quot;':
+      case '\'': {
+        read_string(LS, LS-&gt;current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {
+        next(LS);
+        if (LS-&gt;current == '.') {
+          next(LS);
+          if (LS-&gt;current == '.') {
+            next(LS);
+            return TK_DOTS;   /* ... */
+          }
+          else return TK_CONCAT;   /* .. */
+        }
+        else if (!isdigit(LS-&gt;current)) return '.';
+        else {
+          read_numeral(LS, 1, seminfo);
+          return TK_NUMBER;
+        }
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (isspace(LS-&gt;current)) {
+          next(LS);
+          continue;
+        }
+        else if (isdigit(LS-&gt;current)) {
+          read_numeral(LS, 0, seminfo);
+          return TK_NUMBER;
+        }
+        else if (isalpha(LS-&gt;current) || LS-&gt;current == '_') {
+          /* identifier or reserved word */
+          size_t l = readname(LS);
+          TString *ts = luaS_newlstr(LS-&gt;L, luaZ_buffer(LS-&gt;buff), l);
+          if (ts-&gt;tsv.reserved &gt; 0)  /* reserved word? */
+            return ts-&gt;tsv.reserved - 1 + FIRST_RESERVED;
+          seminfo-&gt;ts = ts;
+          return TK_NAME;
+        }
+        else {
+          int c = LS-&gt;current;
+          if (iscntrl(c))
+            luaX_error(LS, &quot;invalid control char&quot;,
+                           luaO_pushfstring(LS-&gt;L, &quot;char(%d)&quot;, c));
+          next(LS);
+          return c;  /* single-char tokens (+ - / ...) */
+        }
+      }
+    }
+  }
+}
+
+#undef next

Added: trunk/Util/deditor/lua/llex.h
===================================================================
--- trunk/Util/deditor/lua/llex.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/llex.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,75 @@
+/*
+** $Id: llex.h,v 1.47 2003/02/28 17:19:47 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include &quot;lobject.h&quot;
+#include &quot;lzio.h&quot;
+
+
+#define FIRST_RESERVED	257
+
+/* maximum length of a reserved word */
+#define TOKEN_LEN	(sizeof(&quot;function&quot;)/sizeof(char))
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep &quot;ORDER RESERVED&quot;
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_NAME, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
+  TK_STRING, TK_EOS
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* `FuncState' is private to the parser */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  TString *source;  /* current source name */
+  int nestlevel;  /* level of nested non-terminals */
+} LexState;
+
+
+void luaX_init (lua_State *L);
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source);
+int luaX_lex (LexState *LS, SemInfo *seminfo);
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg);
+void luaX_syntaxerror (LexState *ls, const char *s);
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line);
+const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif

Added: trunk/Util/deditor/lua/llimits.h
===================================================================
--- trunk/Util/deditor/lua/llimits.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/llimits.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,185 @@
+/*
+** $Id: llimits.h,v 1.52 2003/02/20 19:33:23 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include &lt;limits.h&gt;
+#include &lt;stddef.h&gt;
+
+
+#include &quot;lua.h&quot;
+
+
+/*
+** try to find number of bits in an integer
+*/
+#ifndef BITS_INT
+/* avoid overflows in comparison */
+#if INT_MAX-20 &lt; 32760
+#define	BITS_INT	16
+#else
+#if INT_MAX &gt; 2147483640L
+/* machine has at least 32 bits */
+#define BITS_INT	32
+#else
+#error &quot;you must define BITS_INT with number of bits in an integer&quot;
+#endif
+#endif
+#endif
+
+
+/*
+** the following types define integer types for values that may not
+** fit in a `small int' (16 bits), but may waste space in a
+** `large long' (64 bits). The current definitions should work in
+** any machine, but may not be optimal.
+*/
+
+/* an unsigned integer to hold hash values */
+typedef unsigned int lu_hash;
+/* its signed equivalent */
+typedef int ls_hash;
+
+/* an unsigned integer big enough to count the total memory used by Lua; */
+/* it should be at least as large as size_t */
+typedef unsigned long lu_mem;
+
+#define MAX_LUMEM	ULONG_MAX
+
+
+/* an integer big enough to count the number of strings in use */
+typedef long ls_nstr;
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((lu_hash)(p))
+
+
+
+/* type to ensure maximum alignment */
+#ifndef LUSER_ALIGNMENT_T
+typedef union { double u; void *s; long l; } L_Umaxalign;
+#else
+typedef LUSER_ALIGNMENT_T L_Umaxalign;
+#endif
+
+
+/* result of `usual argument conversion' over lua_Number */
+#ifndef LUA_UACNUMBER
+typedef double l_uacNumber;
+#else
+typedef LUA_UACNUMBER l_uacNumber;
+#endif
+
+
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+#ifndef check_exp
+#define check_exp(c,e)	(e)
+#endif
+
+
+#ifndef UNUSED
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#ifndef cast
+#define cast(t, exp)	((t)(exp))
+#endif
+
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef unsigned long Instruction;
+
+
+/* maximum depth for calls (unsigned short) */
+#ifndef LUA_MAXCALLS
+#define LUA_MAXCALLS        4096
+#endif
+
+
+/*
+** maximum depth for C calls (unsigned short): Not too big, or may
+** overflow the C stack...
+*/
+
+#ifndef LUA_MAXCCALLS
+#define LUA_MAXCCALLS        200
+#endif
+
+
+/* maximum size for the C stack */
+#ifndef LUA_MAXCSTACK
+#define LUA_MAXCSTACK        2048
+#endif
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+/* maximum number of variables declared in a function */
+#ifndef MAXVARS
+#define MAXVARS 200           /* arbitrary limit (&lt;MAXSTACK) */
+#endif
+
+
+/* maximum number of upvalues per function */
+#ifndef MAXUPVALUES
+#define MAXUPVALUES	32
+#endif
+
+
+/* maximum number of parameters in a function */
+#ifndef MAXPARAMS
+#define MAXPARAMS 100           /* arbitrary limit (&lt;MAXLOCALS) */
+#endif
+
+
+/* minimum size for the string table (must be power of 2) */
+#ifndef MINSTRTABSIZE
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#ifndef LUA_MINBUFFER
+#define LUA_MINBUFFER	32
+#endif
+
+
+/*
+** maximum number of syntactical nested non-terminals: Not too big,
+** or may overflow the C stack...
+*/
+#ifndef LUA_MAXPARSERLEVEL
+#define LUA_MAXPARSERLEVEL	200
+#endif
+
+
+#endif

Added: trunk/Util/deditor/lua/lmem.c
===================================================================
--- trunk/Util/deditor/lua/lmem.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lmem.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,91 @@
+/*
+** $Id: lmem.c,v 1.61 2002/12/04 17:38:31 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lmem_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+
+
+
+/*
+** definition for realloc function. It must assure that l_realloc(NULL,
+** 0, x) allocates a new block (ANSI C assures that). (`os' is the old
+** block size; some allocators may use that.)
+*/
+#ifndef l_realloc
+#define l_realloc(b,os,s)	realloc(b,s)
+#endif
+
+/*
+** definition for free function. (`os' is the old block size; some
+** allocators may use that.)
+*/
+#ifndef l_free
+#define l_free(b,os)	free(b)
+#endif
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elems,
+                    int limit, const char *errormsg) {
+  void *newblock;
+  int newsize = (*size)*2;
+  if (newsize &lt; MINSIZEARRAY)
+    newsize = MINSIZEARRAY;  /* minimum size */
+  else if (*size &gt;= limit/2) {  /* cannot double it? */
+    if (*size &lt; limit - MINSIZEARRAY)  /* try something smaller... */
+      newsize = limit;  /* still have at least MINSIZEARRAY free places */
+    else luaG_runerror(L, errormsg);
+  }
+  newblock = luaM_realloc(L, block,
+                          cast(lu_mem, *size)*cast(lu_mem, size_elems),
+                          cast(lu_mem, newsize)*cast(lu_mem, size_elems));
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc (lua_State *L, void *block, lu_mem oldsize, lu_mem size) {
+  lua_assert((oldsize == 0) == (block == NULL));
+  if (size == 0) {
+    if (block != NULL) {
+      l_free(block, oldsize);
+      block = NULL;
+    }
+    else return NULL;  /* avoid `nblocks' computations when oldsize==size==0 */
+  }
+  else if (size &gt;= MAX_SIZET)
+    luaG_runerror(L, &quot;memory allocation error: block too big&quot;);
+  else {
+    block = l_realloc(block, oldsize, size);
+    if (block == NULL) {
+      if (L)
+        luaD_throw(L, LUA_ERRMEM);
+      else return NULL;  /* error before creating state! */
+    }
+  }
+  if (L) {
+    lua_assert(G(L) != NULL &amp;&amp; G(L)-&gt;nblocks &gt; 0);
+    G(L)-&gt;nblocks -= oldsize;
+    G(L)-&gt;nblocks += size;
+  }
+  return block;
+}
+

Added: trunk/Util/deditor/lua/lmem.h
===================================================================
--- trunk/Util/deditor/lua/lmem.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lmem.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,44 @@
+/*
+** $Id: lmem.h,v 1.26 2002/05/01 20:40:42 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include &lt;stddef.h&gt;
+
+#include &quot;llimits.h&quot;
+#include &quot;lua.h&quot;
+
+#define MEMERRMSG	&quot;not enough memory&quot;
+
+
+void *luaM_realloc (lua_State *L, void *oldblock, lu_mem oldsize, lu_mem size);
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elem,
+                    int limit, const char *errormsg);
+
+#define luaM_free(L, b, s)	luaM_realloc(L, (b), (s), 0)
+#define luaM_freelem(L, b)	luaM_realloc(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n, t)	luaM_realloc(L, (b), \
+                                      cast(lu_mem, n)*cast(lu_mem, sizeof(t)), 0)
+
+#define luaM_malloc(L, t)	luaM_realloc(L, NULL, 0, (t))
+#define luaM_new(L, t)          cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L, n,t)  cast(t *, luaM_malloc(L, \
+                                         cast(lu_mem, n)*cast(lu_mem, sizeof(t))))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if (((nelems)+1) &gt; (size)) \
+            ((v)=cast(t *, luaM_growaux(L,v,&amp;(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_realloc(L, v,cast(lu_mem, oldn)*cast(lu_mem, sizeof(t)), \
+                                    cast(lu_mem, n)*cast(lu_mem, sizeof(t)))))
+
+
+#endif
+

Added: trunk/Util/deditor/lua/lobject.c
===================================================================
--- trunk/Util/deditor/lua/lobject.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lobject.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,195 @@
+/*
+** $Id: lobject.c,v 1.97 2003/04/03 13:35:34 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include &lt;ctype.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define lobject_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldo.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;lvm.h&quot;
+
+
+/* function to convert a string to a lua_Number */
+#ifndef lua_str2number
+#define lua_str2number(s,p)     strtod((s), (p))
+#endif
+
+
+const TObject luaO_nilobject = {LUA_TNIL, {NULL}};
+
+
+/*
+** converts an integer to a &quot;floating point byte&quot;, represented as
+** (mmmmmxxx), where the real value is (xxx) * 2^(mmmmm)
+*/
+int luaO_int2fb (unsigned int x) {
+  int m = 0;  /* mantissa */
+  while (x &gt;= (1&lt;&lt;3)) {
+    x = (x+1) &gt;&gt; 1;
+    m++;
+  }
+  return (m &lt;&lt; 3) | cast(int, x);
+}
+
+
+int luaO_log2 (unsigned int x) {
+  static const lu_byte log_8[255] = {
+    0,
+    1,1,
+    2,2,2,2,
+    3,3,3,3,3,3,3,3,
+    4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+  };
+  if (x &gt;= 0x00010000) {
+    if (x &gt;= 0x01000000) return log_8[((x&gt;&gt;24) &amp; 0xff) - 1]+24;
+    else return log_8[((x&gt;&gt;16) &amp; 0xff) - 1]+16;
+  }
+  else {
+    if (x &gt;= 0x00000100) return log_8[((x&gt;&gt;8) &amp; 0xff) - 1]+8;
+    else if (x) return log_8[(x &amp; 0xff) - 1];
+    return -1;  /* special `log' for 0 */
+  }
+}
+
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2) {
+  if (ttype(t1) != ttype(t2)) return 0;
+  else switch (ttype(t1)) {
+    case LUA_TNIL:
+      return 1;
+    case LUA_TNUMBER:
+      return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN:
+      return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
+    case LUA_TLIGHTUSERDATA:
+      return pvalue(t1) == pvalue(t2);
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+}
+
+
+int luaO_str2d (const char *s, lua_Number *result) {
+  char *endptr;
+  lua_Number res = lua_str2number(s, &amp;endptr);
+  if (endptr == s) return 0;  /* no conversion */
+  while (isspace((unsigned char)(*endptr))) endptr++;
+  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
+  *result = res;
+  return 1;
+}
+
+
+
+static void pushstr (lua_State *L, const char *str) {
+  setsvalue2s(L-&gt;top, luaS_new(L, str));
+  incr_top(L);
+}
+
+
+/* this function handles only `%d', `%c', %f, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 1;
+  pushstr(L, &quot;&quot;);
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    setsvalue2s(L-&gt;top, luaS_newlstr(L, fmt, e-fmt));
+    incr_top(L);
+    switch (*(e+1)) {
+      case 's':
+        pushstr(L, va_arg(argp, char *));
+        break;
+      case 'c': {
+        char buff[2];
+        buff[0] = cast(char, va_arg(argp, int));
+        buff[1] = '\0';
+        pushstr(L, buff);
+        break;
+      }
+      case 'd':
+        setnvalue(L-&gt;top, cast(lua_Number, va_arg(argp, int)));
+        incr_top(L);
+        break;
+      case 'f':
+        setnvalue(L-&gt;top, cast(lua_Number, va_arg(argp, l_uacNumber)));
+        incr_top(L);
+        break;
+      case '%':
+        pushstr(L, &quot;%&quot;);
+        break;
+      default: lua_assert(0);
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  pushstr(L, fmt);
+  luaV_concat(L, n+1, L-&gt;top - L-&gt;base - 1);
+  L-&gt;top -= n;
+  return svalue(L-&gt;top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+void luaO_chunkid (char *out, const char *source, int bufflen) {
+  if (*source == '=') {
+    strncpy(out, source+1, bufflen);  /* remove first char */
+    out[bufflen-1] = '\0';  /* ensures null termination */
+  }
+  else {  /* out = &quot;source&quot;, or &quot;...source&quot; */
+    if (*source == '@') {
+      int l;
+      source++;  /* skip the `@' */
+      bufflen -= sizeof(&quot; `...' &quot;);
+      l = strlen(source);
+      strcpy(out, &quot;&quot;);
+      if (l&gt;bufflen) {
+        source += (l-bufflen);  /* get last part of file name */
+        strcat(out, &quot;...&quot;);
+      }
+      strcat(out, source);
+    }
+    else {  /* out = [string &quot;string&quot;] */
+      int len = strcspn(source, &quot;\n&quot;);  /* stop at first newline */
+      bufflen -= sizeof(&quot; [string \&quot;...\&quot;] &quot;);
+      if (len &gt; bufflen) len = bufflen;
+      strcpy(out, &quot;[string \&quot;&quot;);
+      if (source[len] != '\0') {  /* must truncate? */
+        strncat(out, source, len);
+        strcat(out, &quot;...&quot;);
+      }
+      else
+        strcat(out, source);
+      strcat(out, &quot;\&quot;]&quot;);
+    }
+  }
+}

Added: trunk/Util/deditor/lua/lobject.h
===================================================================
--- trunk/Util/deditor/lua/lobject.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lobject.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,336 @@
+/*
+** $Id: lobject.h,v 1.159 2003/03/18 12:50:04 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include &quot;llimits.h&quot;
+#include &quot;lua.h&quot;
+
+
+/* tags for values visible from Lua */
+#define NUM_TAGS	LUA_TTHREAD
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	(NUM_TAGS+1)
+#define LUA_TUPVAL	(NUM_TAGS+2)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union {
+  GCObject *gc;
+  void *p;
+  lua_Number n;
+  int b;
+} Value;
+
+
+/*
+** Lua values (or `tagged objects')
+*/
+typedef struct lua_TObject {
+  int tt;
+  Value value;
+} TObject;
+
+
+/* Macros to test type */
+#define ttisnil(o)	(ttype(o) == LUA_TNIL)
+#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)
+#define ttisstring(o)	(ttype(o) == LUA_TSTRING)
+#define ttistable(o)	(ttype(o) == LUA_TTABLE)
+#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)
+#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)
+#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)
+#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)
+#define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)
+
+/* Macros to access values */
+#define ttype(o)	((o)-&gt;tt)
+#define gcvalue(o)	check_exp(iscollectable(o), (o)-&gt;value.gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), (o)-&gt;value.p)
+#define nvalue(o)	check_exp(ttisnumber(o), (o)-&gt;value.n)
+#define tsvalue(o)	check_exp(ttisstring(o), &amp;(o)-&gt;value.gc-&gt;ts)
+#define uvalue(o)	check_exp(ttisuserdata(o), &amp;(o)-&gt;value.gc-&gt;u)
+#define clvalue(o)	check_exp(ttisfunction(o), &amp;(o)-&gt;value.gc-&gt;cl)
+#define hvalue(o)	check_exp(ttistable(o), &amp;(o)-&gt;value.gc-&gt;h)
+#define bvalue(o)	check_exp(ttisboolean(o), (o)-&gt;value.b)
+#define thvalue(o)	check_exp(ttisthread(o), &amp;(o)-&gt;value.gc-&gt;th)
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) &amp;&amp; bvalue(o) == 0))
+
+/* Macros to set values */
+#define setnvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TNUMBER; i_o-&gt;value.n=(x); }
+
+#define chgnvalue(obj,x) \
+	check_exp(ttype(obj)==LUA_TNUMBER, (obj)-&gt;value.n=(x))
+
+#define setpvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TLIGHTUSERDATA; i_o-&gt;value.p=(x); }
+
+#define setbvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TBOOLEAN; i_o-&gt;value.b=(x); }
+
+#define setsvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TSTRING; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TSTRING); }
+
+#define setuvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TUSERDATA; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TUSERDATA); }
+
+#define setthvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TTHREAD; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TTHREAD); }
+
+#define setclvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TFUNCTION; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TFUNCTION); }
+
+#define sethvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TTABLE; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TTABLE); }
+
+#define setnilvalue(obj) ((obj)-&gt;tt=LUA_TNIL)
+
+
+
+/*
+** for internal debug only
+*/
+#define checkconsistency(obj) \
+  lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)-&gt;value.gc-&gt;gch.tt))
+
+
+#define setobj(obj1,obj2) \
+  { const TObject *o2=(obj2); TObject *o1=(obj1); \
+    checkconsistency(o2); \
+    o1-&gt;tt=o2-&gt;tt; o1-&gt;value = o2-&gt;value; }
+
+
+/*
+** different types of sets, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+#define setttype(obj, tt) (ttype(obj) = (tt))
+
+
+#define iscollectable(o)	(ttype(o) &gt;= LUA_TSTRING)
+
+
+
+typedef TObject *StkId;  /* index to stack elements */
+
+
+/*
+** String headers for string table
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte reserved;
+    lu_hash hash;
+    size_t len;
+  } tsv;
+} TString;
+
+
+#define getstr(ts)	cast(const char *, (ts) + 1)
+#define svalue(o)       getstr(tsvalue(o))
+
+
+
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    size_t len;
+  } uv;
+} Udata;
+
+
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TObject *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines */
+  struct LocVar *locvars;  /* information about local variables */
+  TString **upvalues;  /* upvalue names */
+  TString  *source;
+  int sizeupvalues;
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int lineDefined;
+  GCObject *gclist;
+  lu_byte nups;  /* number of upvalues */
+  lu_byte numparams;
+  lu_byte is_vararg;
+  lu_byte maxstacksize;
+} Proto;
+
+
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+
+/*
+** Upvalues
+*/
+
+typedef struct UpVal {
+  CommonHeader;
+  TObject *v;  /* points to stack or to its own value */
+  TObject value;  /* the value (when closed) */
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TObject upvalue[1];
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  TObject g;  /* global table for this closure */
+  UpVal *upvals[1];
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION &amp;&amp; clvalue(o)-&gt;c.isC)
+#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION &amp;&amp; !clvalue(o)-&gt;c.isC)
+
+
+/*
+** Tables
+*/
+
+typedef struct Node {
+  TObject i_key;
+  TObject i_val;
+  struct Node *next;  /* for chaining */
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1&lt;&lt;p means tagmethod(p) is not present */ 
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TObject *array;  /* array part */
+  Node *node;
+  Node *firstfree;  /* this position is free; all positions after it are full */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	check_exp((size&amp;(size-1))==0, (cast(int, (s) &amp; ((size)-1))))
+
+
+#define twoto(x)	(1&lt;&lt;(x))
+#define sizenode(t)	(twoto((t)-&gt;lsizenode))
+
+
+
+extern const TObject luaO_nilobject;
+
+int luaO_log2 (unsigned int x);
+int luaO_int2fb (unsigned int x);
+#define fb2int(x)	(((x) &amp; 7) &lt;&lt; ((x) &gt;&gt; 3))
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2);
+int luaO_str2d (const char *s, lua_Number *result);
+
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp);
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+void luaO_chunkid (char *out, const char *source, int len);
+
+
+#endif

Added: trunk/Util/deditor/lua/lopcodes.c
===================================================================
--- trunk/Util/deditor/lua/lopcodes.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lopcodes.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,102 @@
+/*
+** $Id: lopcodes.c,v 1.22 2002/12/04 17:38:31 roberto Exp $
+** extracted automatically from lopcodes.h by mkprint.lua
+** DO NOT EDIT
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+
+
+#ifdef LUA_OPNAMES
+
+const char *const luaP_opnames[] = {
+  &quot;MOVE&quot;,
+  &quot;LOADK&quot;,
+  &quot;LOADBOOL&quot;,
+  &quot;LOADNIL&quot;,
+  &quot;GETUPVAL&quot;,
+  &quot;GETGLOBAL&quot;,
+  &quot;GETTABLE&quot;,
+  &quot;SETGLOBAL&quot;,
+  &quot;SETUPVAL&quot;,
+  &quot;SETTABLE&quot;,
+  &quot;NEWTABLE&quot;,
+  &quot;SELF&quot;,
+  &quot;ADD&quot;,
+  &quot;SUB&quot;,
+  &quot;MUL&quot;,
+  &quot;DIV&quot;,
+  &quot;POW&quot;,
+  &quot;UNM&quot;,
+  &quot;NOT&quot;,
+  &quot;CONCAT&quot;,
+  &quot;JMP&quot;,
+  &quot;EQ&quot;,
+  &quot;LT&quot;,
+  &quot;LE&quot;,
+  &quot;TEST&quot;,
+  &quot;CALL&quot;,
+  &quot;TAILCALL&quot;,
+  &quot;RETURN&quot;,
+  &quot;FORLOOP&quot;,
+  &quot;TFORLOOP&quot;,
+  &quot;TFORPREP&quot;,
+  &quot;SETLIST&quot;,
+  &quot;SETLISTO&quot;,
+  &quot;CLOSE&quot;,
+  &quot;CLOSURE&quot;
+};
+
+#endif
+
+#define opmode(t,b,bk,ck,sa,k,m) (((t)&lt;&lt;OpModeT) | \
+   ((b)&lt;&lt;OpModeBreg) | ((bk)&lt;&lt;OpModeBrk) | ((ck)&lt;&lt;OpModeCrk) | \
+   ((sa)&lt;&lt;OpModesetA) | ((k)&lt;&lt;OpModeK) | (m))
+
+
+const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  B Bk Ck sA  K  mode			   opcode    */
+  opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_MOVE */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_LOADK */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_GETGLOBAL */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, 0, 0, 0, 1, iABx)		/* OP_SETGLOBAL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, 1, 1, 0, 0, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_SELF */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_ADD */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_SUB */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_MUL */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_DIV */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_POW */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_UNM */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_NOT */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_EQ */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LT */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LE */
+ ,opmode(1, 1, 0, 0, 1, 0, iABC)		/* OP_TEST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_RETURN */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_FORLOOP */
+ ,opmode(1, 0, 0, 0, 0, 0, iABC)		/* OP_TFORLOOP */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_TFORPREP */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLIST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLISTO */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CLOSE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABx)		/* OP_CLOSURE */
+};
+

Added: trunk/Util/deditor/lua/lopcodes.h
===================================================================
--- trunk/Util/deditor/lua/lopcodes.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lopcodes.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,238 @@
+/*
+** $Id: lopcodes.h,v 1.102 2002/08/21 18:56:09 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include &quot;llimits.h&quot;
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+
+#define SIZE_OP		6
+
+#define POS_C		SIZE_OP
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_A		(POS_B + SIZE_B)
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in BITS_INT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx &lt; BITS_INT-1
+#define MAXARG_Bx        ((1&lt;&lt;SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx&gt;&gt;1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1&lt;&lt;SIZE_A)-1)
+#define MAXARG_B        ((1&lt;&lt;SIZE_B)-1)
+#define MAXARG_C        ((1&lt;&lt;SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)&lt;&lt;n))&lt;&lt;p)
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, (i)&amp;MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&amp;MASK0(SIZE_OP,0)) | cast(Instruction, o)))
+
+#define GETARG_A(i)	(cast(int, (i)&gt;&gt;POS_A))
+#define SETARG_A(i,u)	((i) = (((i)&amp;MASK0(SIZE_A,POS_A)) | \
+		((cast(Instruction, u)&lt;&lt;POS_A)&amp;MASK1(SIZE_A,POS_A))))
+
+#define GETARG_B(i)	(cast(int, ((i)&gt;&gt;POS_B) &amp; MASK1(SIZE_B,0)))
+#define SETARG_B(i,b)	((i) = (((i)&amp;MASK0(SIZE_B,POS_B)) | \
+		((cast(Instruction, b)&lt;&lt;POS_B)&amp;MASK1(SIZE_B,POS_B))))
+
+#define GETARG_C(i)	(cast(int, ((i)&gt;&gt;POS_C) &amp; MASK1(SIZE_C,0)))
+#define SETARG_C(i,b)	((i) = (((i)&amp;MASK0(SIZE_C,POS_C)) | \
+		((cast(Instruction, b)&lt;&lt;POS_C)&amp;MASK1(SIZE_C,POS_C))))
+
+#define GETARG_Bx(i)	(cast(int, ((i)&gt;&gt;POS_Bx) &amp; MASK1(SIZE_Bx,0)))
+#define SETARG_Bx(i,b)	((i) = (((i)&amp;MASK0(SIZE_Bx,POS_Bx)) | \
+		((cast(Instruction, b)&lt;&lt;POS_Bx)&amp;MASK1(SIZE_Bx,POS_Bx))))
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	(cast(Instruction, o) \
+			| (cast(Instruction, a)&lt;&lt;POS_A) \
+			| (cast(Instruction, b)&lt;&lt;POS_B) \
+			| (cast(Instruction, c)&lt;&lt;POS_C))
+
+#define CREATE_ABx(o,a,bc)	(cast(Instruction, o) \
+			| (cast(Instruction, a)&lt;&lt;POS_A) \
+			| (cast(Instruction, bc)&lt;&lt;POS_Bx))
+
+
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if x &lt; MAXSTACK then R(x) else Kst(x-MAXSTACK)
+*/
+
+
+/*
+** grep &quot;ORDER OP&quot; if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) PC++			*/
+OP_LOADNIL,/*	A B	R(A) := ... := R(B) := nil			*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETGLOBAL,/*	A Bx	R(A) := Gbl[Kst(Bx)]				*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETGLOBAL,/*	A Bx	Gbl[Kst(Bx)] := R(A)				*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	sBx	PC += sBx					*/
+
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) &lt;  RK(C)) ~= A) then pc++  		*/
+OP_LE,/*	A B C	if ((RK(B) &lt;= RK(C)) ~= A) then pc++  		*/
+
+OP_TEST,/*	A B C	if (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++	*/ 
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2); if R(A) &lt;?= R(A+1) then PC+= sBx	*/
+
+OP_TFORLOOP,/*	A C	R(A+2), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
+                        if R(A+2) ~= nil then pc++			*/
+OP_TFORPREP,/*	A sBx	if type(R(A)) == table then R(A+1):=R(A), R(A):=next;
+			PC += sBx					*/
+
+OP_SETLIST,/*	A Bx	R(A)[Bx-Bx%FPF+i] := R(A+i), 1 &lt;= i &lt;= Bx%FPF+1	*/
+OP_SETLISTO,/*	A Bx							*/
+
+OP_CLOSE,/*	A 	close all variables in the stack up to (&gt;=) R(A)*/
+OP_CLOSURE/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_CLOSURE+1))
+
+
+
+/*===========================================================================
+  Notes:
+  (1) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
+      and can be 0: OP_CALL then sets `top' to last_result+1, so
+      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use `top'.
+
+  (2) In OP_RETURN, if (B == 0) then return up to `top'
+
+  (3) For comparisons, B specifies what conditions the test should accept.
+
+  (4) All `skips' (pc++) assume that next instruction is a jump
+===========================================================================*/
+
+
+/*
+** masks for instruction properties
+*/  
+enum OpModeMask {
+  OpModeBreg = 2,       /* B is a register */
+  OpModeBrk,		/* B is a register/constant */
+  OpModeCrk,           /* C is a register/constant */
+  OpModesetA,           /* instruction set register A */
+  OpModeK,              /* Bx is a constant */
+  OpModeT		/* operator is a test */
+  
+};
+
+
+extern const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)            (cast(enum OpMode, luaP_opmodes[m] &amp; 3))
+#define testOpMode(m, b)        (luaP_opmodes[m] &amp; (1 &lt;&lt; (b)))
+
+
+#ifdef LUA_OPNAMES
+extern const char *const luaP_opnames[];  /* opcode names */
+#endif
+
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+/* (must be a power of 2) */
+#define LFIELDS_PER_FLUSH	32
+
+
+#endif

Added: trunk/Util/deditor/lua/lparser.c
===================================================================
--- trunk/Util/deditor/lua/lparser.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lparser.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,1329 @@
+/*
+** $Id: lparser.c,v 1.208 2003/04/03 13:35:34 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define lparser_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+
+
+
+
+#define getlocvar(fs, i)	((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])
+
+
+#define enterlevel(ls)	if (++(ls)-&gt;nestlevel &gt; LUA_MAXPARSERLEVEL) \
+		luaX_syntaxerror(ls, &quot;too many syntax levels&quot;);
+#define leavelevel(ls)	((ls)-&gt;nestlevel--)
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  int breaklist;  /* list of jumps out of this loop */
+  int nactvar;  /* # active local variables outside the breakable structure */
+  int upval;  /* true if some variable in the block is an upvalue */
+  int isbreakable;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void chunk (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+
+static void next (LexState *ls) {
+  ls-&gt;lastline = ls-&gt;linenumber;
+  if (ls-&gt;lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls-&gt;t = ls-&gt;lookahead;  /* use this one */
+    ls-&gt;lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls-&gt;t.token = luaX_lex(ls, &amp;ls-&gt;t.seminfo);  /* read next token */
+}
+
+
+static void lookahead (LexState *ls) {
+  lua_assert(ls-&gt;lookahead.token == TK_EOS);
+  ls-&gt;lookahead.token = luaX_lex(ls, &amp;ls-&gt;lookahead.seminfo);
+}
+
+
+static void error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+         luaO_pushfstring(ls-&gt;L, &quot;`%s' expected&quot;, luaX_token2str(ls, token)));
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls-&gt;t.token == c) {
+    next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (!testnext(ls, c))
+    error_expected(ls, c);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls-&gt;linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls-&gt;L,
+             &quot;`%s' expected (to close `%s' at line %d)&quot;,
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check_condition(ls, (ls-&gt;t.token == TK_NAME), &quot;&lt;name&gt; expected&quot;);
+  ts = ls-&gt;t.seminfo.ts;
+  next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e-&gt;f = e-&gt;t = NO_JUMP;
+  e-&gt;k = k;
+  e-&gt;info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls-&gt;fs, s));
+}
+
+
+static void checkname(LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int luaI_registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls-&gt;fs;
+  Proto *f = fs-&gt;f;
+  luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
+                  LocVar, MAX_INT, &quot;&quot;);
+  f-&gt;locvars[fs-&gt;nlocvars].varname = varname;
+  return fs-&gt;nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name, int n) {
+  FuncState *fs = ls-&gt;fs;
+  luaX_checklimit(ls, fs-&gt;nactvar+n+1, MAXVARS, &quot;local variables&quot;);
+  fs-&gt;actvar[fs-&gt;nactvar+n] = luaI_registerlocalvar(ls, name);
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls-&gt;fs;
+  fs-&gt;nactvar += nvars;
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs-&gt;nactvar - nvars).startpc = fs-&gt;pc;
+  }
+}
+
+
+static void removevars (LexState *ls, int tolevel) {
+  FuncState *fs = ls-&gt;fs;
+  while (fs-&gt;nactvar &gt; tolevel)
+    getlocvar(fs, --fs-&gt;nactvar).endpc = fs-&gt;pc;
+}
+
+
+static void new_localvarstr (LexState *ls, const char *name, int n) {
+  new_localvar(ls, luaS_new(ls-&gt;L, name), n);
+}
+
+
+static void create_local (LexState *ls, const char *name) {
+  new_localvarstr(ls, name, 0);
+  adjustlocalvars(ls, 1);
+}
+
+
+static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
+  int i;
+  Proto *f = fs-&gt;f;
+  for (i=0; i&lt;f-&gt;nups; i++) {
+    if (fs-&gt;upvalues[i].k == v-&gt;k &amp;&amp; fs-&gt;upvalues[i].info == v-&gt;info) {
+      lua_assert(fs-&gt;f-&gt;upvalues[i] == name);
+      return i;
+    }
+  }
+  /* new one */
+  luaX_checklimit(fs-&gt;ls, f-&gt;nups + 1, MAXUPVALUES, &quot;upvalues&quot;);
+  luaM_growvector(fs-&gt;L, fs-&gt;f-&gt;upvalues, f-&gt;nups, fs-&gt;f-&gt;sizeupvalues,
+                  TString *, MAX_INT, &quot;&quot;);
+  fs-&gt;f-&gt;upvalues[f-&gt;nups] = name;
+  fs-&gt;upvalues[f-&gt;nups] = *v;
+  return f-&gt;nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i=fs-&gt;nactvar-1; i &gt;= 0; i--) {
+    if (n == getlocvar(fs, i).varname)
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs-&gt;bl;
+  while (bl &amp;&amp; bl-&gt;nactvar &gt; level) bl = bl-&gt;previous;
+  if (bl) bl-&gt;upval = 1;
+}
+
+
+static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */
+  else {
+    int v = searchvar(fs, n);  /* look up at current level */
+    if (v &gt;= 0) {
+      init_exp(var, VLOCAL, v);
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+    }
+    else {  /* not found at current level; try upper one */
+      singlevaraux(fs-&gt;prev, n, var, 0);
+      if (var-&gt;k == VGLOBAL) {
+        if (base)
+          var-&gt;info = luaK_stringK(fs, n);  /* info points to global name */
+      }
+      else {  /* LOCAL or UPVAL */
+        var-&gt;info = indexupvalue(fs, n, var);
+        var-&gt;k = VUPVAL;  /* upvalue in this level */
+      }
+    }
+  }
+}
+
+
+static TString *singlevar (LexState *ls, expdesc *var, int base) {
+  TString *varname = str_checkname(ls);
+  singlevaraux(ls-&gt;fs, varname, var, base);
+  return varname;
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls-&gt;fs;
+  int extra = nvars - nexps;
+  if (e-&gt;k == VCALL) {
+    extra++;  /* includes call itself */
+    if (extra &lt;= 0) extra = 0;
+    else luaK_reserveregs(fs, extra-1);
+    luaK_setcallreturns(fs, e, extra);  /* call provides the difference */
+  }
+  else {
+    if (e-&gt;k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra &gt; 0) {
+      int reg = fs-&gt;freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void code_params (LexState *ls, int nparams, int dots) {
+  FuncState *fs = ls-&gt;fs;
+  adjustlocalvars(ls, nparams);
+  luaX_checklimit(ls, fs-&gt;nactvar, MAXPARAMS, &quot;parameters&quot;);
+  fs-&gt;f-&gt;numparams = cast(lu_byte, fs-&gt;nactvar);
+  fs-&gt;f-&gt;is_vararg = cast(lu_byte, dots);
+  if (dots)
+    create_local(ls, &quot;arg&quot;);
+  luaK_reserveregs(fs, fs-&gt;nactvar);  /* reserve register for parameters */
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, int isbreakable) {
+  bl-&gt;breaklist = NO_JUMP;
+  bl-&gt;isbreakable = isbreakable;
+  bl-&gt;nactvar = fs-&gt;nactvar;
+  bl-&gt;upval = 0;
+  bl-&gt;previous = fs-&gt;bl;
+  fs-&gt;bl = bl;
+  lua_assert(fs-&gt;freereg == fs-&gt;nactvar);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs-&gt;bl;
+  fs-&gt;bl = bl-&gt;previous;
+  removevars(fs-&gt;ls, bl-&gt;nactvar);
+  if (bl-&gt;upval)
+    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
+  lua_assert(bl-&gt;nactvar == fs-&gt;nactvar);
+  fs-&gt;freereg = fs-&gt;nactvar;  /* free registers */
+  luaK_patchtohere(fs, bl-&gt;breaklist);
+}
+
+
+static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
+  FuncState *fs = ls-&gt;fs;
+  Proto *f = fs-&gt;f;
+  int i;
+  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,
+                  MAXARG_Bx, &quot;constant table overflow&quot;);
+  f-&gt;p[fs-&gt;np++] = func-&gt;f;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));
+  for (i=0; i&lt;func-&gt;f-&gt;nups; i++) {
+    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);
+  }
+}
+
+
+static void open_func (LexState *ls, FuncState *fs) {
+  Proto *f = luaF_newproto(ls-&gt;L);
+  fs-&gt;f = f;
+  fs-&gt;prev = ls-&gt;fs;  /* linked list of funcstates */
+  fs-&gt;ls = ls;
+  fs-&gt;L = ls-&gt;L;
+  ls-&gt;fs = fs;
+  fs-&gt;pc = 0;
+  fs-&gt;lasttarget = 0;
+  fs-&gt;jpc = NO_JUMP;
+  fs-&gt;freereg = 0;
+  fs-&gt;nk = 0;
+  fs-&gt;h = luaH_new(ls-&gt;L, 0, 0);
+  fs-&gt;np = 0;
+  fs-&gt;nlocvars = 0;
+  fs-&gt;nactvar = 0;
+  fs-&gt;bl = NULL;
+  f-&gt;source = ls-&gt;source;
+  f-&gt;maxstacksize = 2;  /* registers 0/1 are always valid */
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls-&gt;L;
+  FuncState *fs = ls-&gt;fs;
+  Proto *f = fs-&gt;f;
+  removevars(ls, 0);
+  luaK_codeABC(fs, OP_RETURN, 0, 1, 0);  /* final return */
+  luaM_reallocvector(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, Instruction);
+  f-&gt;sizecode = fs-&gt;pc;
+  luaM_reallocvector(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, int);
+  f-&gt;sizelineinfo = fs-&gt;pc;
+  luaM_reallocvector(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, TObject);
+  f-&gt;sizek = fs-&gt;nk;
+  luaM_reallocvector(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, Proto *);
+  f-&gt;sizep = fs-&gt;np;
+  luaM_reallocvector(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, LocVar);
+  f-&gt;sizelocvars = fs-&gt;nlocvars;
+  luaM_reallocvector(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, TString *);
+  f-&gt;sizeupvalues = f-&gt;nups;
+  lua_assert(luaG_checkcode(f));
+  lua_assert(fs-&gt;bl == NULL);
+  ls-&gt;fs = fs-&gt;prev;
+}
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff) {
+  struct LexState lexstate;
+  struct FuncState funcstate;
+  lexstate.buff = buff;
+  lexstate.nestlevel = 0;
+  luaX_setinput(L, &amp;lexstate, z, luaS_new(L, zname(z)));
+  open_func(&amp;lexstate, &amp;funcstate);
+  next(&amp;lexstate);  /* read first token */
+  chunk(&amp;lexstate);
+  check_condition(&amp;lexstate, (lexstate.t.token == TK_EOS), &quot;&lt;eof&gt; expected&quot;);
+  close_func(&amp;lexstate);
+  lua_assert(funcstate.prev == NULL);
+  lua_assert(funcstate.f-&gt;nups == 0);
+  lua_assert(lexstate.nestlevel == 0);
+  return funcstate.f;
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+static void luaY_field (LexState *ls, expdesc *v) {
+  /* field -&gt; ['.' | ':'] NAME */
+  FuncState *fs = ls-&gt;fs;
+  expdesc key;
+  luaK_exp2anyreg(fs, v);
+  next(ls);  /* skip the dot or colon */
+  checkname(ls, &amp;key);
+  luaK_indexed(fs, v, &amp;key);
+}
+
+
+static void luaY_index (LexState *ls, expdesc *v) {
+  /* index -&gt; '[' expr ']' */
+  next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls-&gt;fs, v);
+  check(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -&gt; (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls-&gt;fs;
+  int reg = ls-&gt;fs-&gt;freereg;
+  expdesc key, val;
+  if (ls-&gt;t.token == TK_NAME) {
+    luaX_checklimit(ls, cc-&gt;nh, MAX_INT, &quot;items in a constructor&quot;);
+    cc-&gt;nh++;
+    checkname(ls, &amp;key);
+  }
+  else  /* ls-&gt;t.token == '[' */
+    luaY_index(ls, &amp;key);
+  check(ls, '=');
+  luaK_exp2RK(fs, &amp;key);
+  expr(ls, &amp;val);
+  luaK_codeABC(fs, OP_SETTABLE, cc-&gt;t-&gt;info, luaK_exp2RK(fs, &amp;key),
+                                             luaK_exp2RK(fs, &amp;val));
+  fs-&gt;freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc-&gt;v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &amp;cc-&gt;v);
+  cc-&gt;v.k = VVOID;
+  if (cc-&gt;tostore == LFIELDS_PER_FLUSH) {
+    luaK_codeABx(fs, OP_SETLIST, cc-&gt;t-&gt;info, cc-&gt;na-1);  /* flush */
+    cc-&gt;tostore = 0;  /* no more items pending */
+    fs-&gt;freereg = cc-&gt;t-&gt;info + 1;  /* free registers */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc-&gt;tostore == 0) return;
+  if (cc-&gt;v.k == VCALL) {
+    luaK_setcallreturns(fs, &amp;cc-&gt;v, LUA_MULTRET);
+    luaK_codeABx(fs, OP_SETLISTO, cc-&gt;t-&gt;info, cc-&gt;na-1);
+  }
+  else {
+    if (cc-&gt;v.k != VVOID)
+      luaK_exp2nextreg(fs, &amp;cc-&gt;v);
+    luaK_codeABx(fs, OP_SETLIST, cc-&gt;t-&gt;info, cc-&gt;na-1);
+  }
+  fs-&gt;freereg = cc-&gt;t-&gt;info + 1;  /* free registers */
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  expr(ls, &amp;cc-&gt;v);
+  luaX_checklimit(ls, cc-&gt;na, MAXARG_Bx, &quot;items in a constructor&quot;);
+  cc-&gt;na++;
+  cc-&gt;tostore++;
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -&gt; ?? */
+  FuncState *fs = ls-&gt;fs;
+  int line = ls-&gt;linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&amp;cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls-&gt;fs, t);  /* fix it at stack top (for gc) */
+  check(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0);
+    testnext(ls, ';');  /* compatibility only */
+    if (ls-&gt;t.token == '}') break;
+    closelistfield(fs, &amp;cc);
+    switch(ls-&gt;t.token) {
+      case TK_NAME: {  /* may be listfields or recfields */
+        lookahead(ls);
+        if (ls-&gt;lookahead.token != '=')  /* expression? */
+          listfield(ls, &amp;cc);
+        else
+          recfield(ls, &amp;cc);
+        break;
+      }
+      case '[': {  /* constructor_item -&gt; recfield */
+        recfield(ls, &amp;cc);
+        break;
+      }
+      default: {  /* constructor_part -&gt; listfield */
+        listfield(ls, &amp;cc);
+        break;
+      }
+    }
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &amp;cc);
+  SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs-&gt;f-&gt;code[pc], luaO_log2(cc.nh)+1);  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -&gt; [ param { `,' param } ] */
+  int nparams = 0;
+  int dots = 0;
+  if (ls-&gt;t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls-&gt;t.token) {
+        case TK_DOTS: dots = 1; next(ls); break;
+        case TK_NAME: new_localvar(ls, str_checkname(ls), nparams++); break;
+        default: luaX_syntaxerror(ls, &quot;&lt;name&gt; or `...' expected&quot;);
+      }
+    } while (!dots &amp;&amp; testnext(ls, ','));
+  }
+  code_params(ls, nparams, dots);
+}
+
+
+static void body (LexState *ls, expdesc *e, int needself, int line) {
+  /* body -&gt;  `(' parlist `)' chunk END */
+  FuncState new_fs;
+  open_func(ls, &amp;new_fs);
+  new_fs.f-&gt;lineDefined = line;
+  check(ls, '(');
+  if (needself)
+    create_local(ls, &quot;self&quot;);
+  parlist(ls);
+  check(ls, ')');
+  chunk(ls);
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  close_func(ls);
+  pushclosure(ls, &amp;new_fs, e);
+}
+
+
+static int explist1 (LexState *ls, expdesc *v) {
+  /* explist1 -&gt; expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls-&gt;fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f) {
+  FuncState *fs = ls-&gt;fs;
+  expdesc args;
+  int base, nparams;
+  int line = ls-&gt;linenumber;
+  switch (ls-&gt;t.token) {
+    case '(': {  /* funcargs -&gt; `(' [ explist1 ] `)' */
+      if (line != ls-&gt;lastline)
+        luaX_syntaxerror(ls,&quot;ambiguous syntax (function call x new statement)&quot;);
+      next(ls);
+      if (ls-&gt;t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist1(ls, &amp;args);
+        luaK_setcallreturns(fs, &amp;args, LUA_MULTRET);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -&gt; constructor */
+      constructor(ls, &amp;args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -&gt; STRING */
+      codestring(ls, &amp;args, ls-&gt;t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, &quot;function arguments expected&quot;);
+      return;
+    }
+  }
+  lua_assert(f-&gt;k == VNONRELOC);
+  base = f-&gt;info;  /* base register for call */
+  if (args.k == VCALL)
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &amp;args);  /* close last argument */
+    nparams = fs-&gt;freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs-&gt;freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void prefixexp (LexState *ls, expdesc *v) {
+  /* prefixexp -&gt; NAME | '(' expr ')' */
+  switch (ls-&gt;t.token) {
+    case '(': {
+      int line = ls-&gt;linenumber;
+      next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls-&gt;fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v, 1);
+      return;
+    }
+#ifdef LUA_COMPATUPSYNTAX
+    case '%': {  /* for compatibility only */
+      TString *varname;
+      int line = ls-&gt;linenumber;
+      next(ls);  /* skip `%' */
+      varname = singlevar(ls, v, 1);
+      if (v-&gt;k != VUPVAL)
+        luaX_errorline(ls, &quot;global upvalues are obsolete&quot;,
+                           getstr(varname), line);
+      return;
+    }
+#endif
+    default: {
+      luaX_syntaxerror(ls, &quot;unexpected symbol&quot;);
+      return;
+    }
+  }
+}
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp -&gt;
+        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */
+  FuncState *fs = ls-&gt;fs;
+  prefixexp(ls, v);
+  for (;;) {
+    switch (ls-&gt;t.token) {
+      case '.': {  /* field */
+        luaY_field(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyreg(fs, v);
+        luaY_index(ls, &amp;key);
+        luaK_indexed(fs, v, &amp;key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        next(ls);
+        checkname(ls, &amp;key);
+        luaK_self(fs, v, &amp;key);
+        funcargs(ls, v);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -&gt; NUMBER | STRING | NIL | constructor | FUNCTION body
+               | primaryexp */
+  switch (ls-&gt;t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VK, luaK_numberK(ls-&gt;fs, ls-&gt;t.seminfo.r));
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls-&gt;t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      next(ls);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      next(ls);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      next(ls);
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      break;
+    }
+    case TK_FUNCTION: {
+      next(ls);
+      body(ls, v, 0, ls-&gt;linenumber);
+      break;
+    }
+    default: {
+      primaryexp(ls, v);
+      break;
+    }
+  }
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MULT;
+    case '/': return OPR_DIV;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '&lt;': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '&gt;': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7},  /* arithmetic */
+   {10, 9}, {5, 4},                 /* power and concat (right associative) */
+   {3, 3}, {3, 3},                  /* equality */
+   {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
+   {2, 2}, {1, 1}                   /* logical (and/or) */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -&gt; (simplexep | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls-&gt;t.token);
+  if (uop != OPR_NOUNOPR) {
+    next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls-&gt;fs, uop, v);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls-&gt;t.token);
+  while (op != OPR_NOBINOPR &amp;&amp; cast(int, priority[op].left) &gt; limit) {
+    expdesc v2;
+    BinOpr nextop;
+    next(ls);
+    luaK_infix(ls-&gt;fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &amp;v2, cast(int, priority[op].right));
+    luaK_posfix(ls-&gt;fs, op, v, &amp;v2);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, -1);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static int block_follow (int token) {
+  switch (token) {
+    case TK_ELSE: case TK_ELSEIF: case TK_END:
+    case TK_UNTIL: case TK_EOS:
+      return 1;
+    default: return 0;
+  }
+}
+
+
+static void block (LexState *ls) {
+  /* block -&gt; chunk */
+  FuncState *fs = ls-&gt;fs;
+  BlockCnt bl;
+  enterblock(fs, &amp;bl, 0);
+  chunk(ls);
+  lua_assert(bl.breaklist == NO_JUMP);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to a local variable, the local variable
+** is needed in a previous assignment (to a table). If so, save original
+** local value in a safe place and use this safe copy in the previous
+** assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls-&gt;fs;
+  int extra = fs-&gt;freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh-&gt;prev) {
+    if (lh-&gt;v.k == VINDEXED) {
+      if (lh-&gt;v.info == v-&gt;info) {  /* conflict? */
+        conflict = 1;
+        lh-&gt;v.info = extra;  /* previous assignment will use safe copy */
+      }
+      if (lh-&gt;v.aux == v-&gt;info) {  /* conflict? */
+        conflict = 1;
+        lh-&gt;v.aux = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    luaK_codeABC(fs, OP_MOVE, fs-&gt;freereg, v-&gt;info, 0);  /* make copy */
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, VLOCAL &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= VINDEXED,
+                      &quot;syntax error&quot;);
+  if (testnext(ls, ',')) {  /* assignment -&gt; `,' primaryexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    primaryexp(ls, &amp;nv.v);
+    if (nv.v.k == VLOCAL)
+      check_conflict(ls, lh, &amp;nv.v);
+    assignment(ls, &amp;nv, nvars+1);
+  }
+  else {  /* assignment -&gt; `=' explist1 */
+    int nexps;
+    check(ls, '=');
+    nexps = explist1(ls, &amp;e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &amp;e);
+      if (nexps &gt; nvars)
+        ls-&gt;fs-&gt;freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setcallreturns(ls-&gt;fs, &amp;e, 1);  /* close last expression */
+      luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  /* default assignment */
+  luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
+}
+
+
+static void cond (LexState *ls, expdesc *v) {
+  /* cond -&gt; exp */
+  expr(ls, v);  /* read condition */
+  if (v-&gt;k == VNIL) v-&gt;k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls-&gt;fs, v);
+  luaK_patchtohere(ls-&gt;fs, v-&gt;t);
+}
+
+
+/*
+** The while statement optimizes its code by coding the condition
+** after its body (and thus avoiding one jump in the loop).
+*/
+
+/*
+** maximum size of expressions for optimizing `while' code
+*/
+#ifndef MAXEXPWHILE
+#define MAXEXPWHILE	100
+#endif
+
+/*
+** the call `luaK_goiffalse' may grow the size of an expression by
+** at most this:
+*/
+#define EXTRAEXP	5
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -&gt; WHILE cond DO block END */
+  Instruction codeexp[MAXEXPWHILE + EXTRAEXP];
+  int lineexp;
+  int i;
+  int sizeexp;
+  FuncState *fs = ls-&gt;fs;
+  int whileinit, blockinit, expinit;
+  expdesc v;
+  BlockCnt bl;
+  next(ls);  /* skip WHILE */
+  whileinit = luaK_jump(fs);  /* jump to condition (which will be moved) */
+  expinit = luaK_getlabel(fs);
+  expr(ls, &amp;v);  /* parse condition */
+  if (v.k == VK) v.k = VTRUE;  /* `trues' are all equal here */
+  lineexp = ls-&gt;linenumber;
+  luaK_goiffalse(fs, &amp;v);
+  luaK_concat(fs, &amp;v.f, fs-&gt;jpc);
+  fs-&gt;jpc = NO_JUMP;
+  sizeexp = fs-&gt;pc - expinit;  /* size of expression code */
+  if (sizeexp &gt; MAXEXPWHILE) 
+    luaX_syntaxerror(ls, &quot;`while' condition too complex&quot;);
+  for (i = 0; i &lt; sizeexp; i++)  /* save `exp' code */
+    codeexp[i] = fs-&gt;f-&gt;code[expinit + i];
+  fs-&gt;pc = expinit;  /* remove `exp' code */
+  enterblock(fs, &amp;bl, 1);
+  check(ls, TK_DO);
+  blockinit = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, whileinit);  /* initial jump jumps to here */
+  /* move `exp' back to code */
+  if (v.t != NO_JUMP) v.t += fs-&gt;pc - expinit;
+  if (v.f != NO_JUMP) v.f += fs-&gt;pc - expinit;
+  for (i=0; i&lt;sizeexp; i++)
+    luaK_code(fs, codeexp[i], lineexp);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchlist(fs, v.t, blockinit);  /* true conditions go back to loop */
+  luaK_patchtohere(fs, v.f);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -&gt; REPEAT block UNTIL cond */
+  FuncState *fs = ls-&gt;fs;
+  int repeat_init = luaK_getlabel(fs);
+  expdesc v;
+  BlockCnt bl;
+  enterblock(fs, &amp;bl, 1);
+  next(ls);
+  block(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  cond(ls, &amp;v);
+  luaK_patchlist(fs, v.f, repeat_init);
+  leaveblock(fs);
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int k;
+  expr(ls, &amp;e);
+  k = e.k;
+  luaK_exp2nextreg(ls-&gt;fs, &amp;e);
+  return k;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  BlockCnt bl;
+  FuncState *fs = ls-&gt;fs;
+  int prep, endfor;
+  adjustlocalvars(ls, nvars);  /* scope for all variables */
+  check(ls, TK_DO);
+  enterblock(fs, &amp;bl, 1);  /* loop block */
+  prep = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, prep-1);
+  endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) :
+                     luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars - 3);
+  luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
+  luaK_patchlist(fs, (isnum) ? endfor : luaK_jump(fs), prep);
+  leaveblock(fs);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -&gt; NAME = exp1,exp1[,exp1] DO body */
+  FuncState *fs = ls-&gt;fs;
+  int base = fs-&gt;freereg;
+  new_localvar(ls, varname, 0);
+  new_localvarstr(ls, &quot;(for limit)&quot;, 1);
+  new_localvarstr(ls, &quot;(for step)&quot;, 2);
+  check(ls, '=');
+  exp1(ls);  /* initial value */
+  check(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codeABx(fs, OP_LOADK, fs-&gt;freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  luaK_codeABC(fs, OP_SUB, fs-&gt;freereg - 3, fs-&gt;freereg - 3, fs-&gt;freereg - 1);
+  luaK_jump(fs);
+  forbody(ls, base, line, 3, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -&gt; NAME {,NAME} IN explist1 DO body */
+  FuncState *fs = ls-&gt;fs;
+  expdesc e;
+  int nvars = 0;
+  int line;
+  int base = fs-&gt;freereg;
+  new_localvarstr(ls, &quot;(for generator)&quot;, nvars++);
+  new_localvarstr(ls, &quot;(for state)&quot;, nvars++);
+  new_localvar(ls, indexname, nvars++);
+  while (testnext(ls, ','))
+    new_localvar(ls, str_checkname(ls), nvars++);
+  check(ls, TK_IN);
+  line = ls-&gt;linenumber;
+  adjust_assign(ls, nvars, explist1(ls, &amp;e), &amp;e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  luaK_codeAsBx(fs, OP_TFORPREP, base, NO_JUMP);
+  forbody(ls, base, line, nvars, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -&gt; fornum | forlist */
+  FuncState *fs = ls-&gt;fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &amp;bl, 0);  /* block to control variable scope */
+  next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls-&gt;t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, &quot;`=' or `in' expected&quot;);
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);
+}
+
+
+static void test_then_block (LexState *ls, expdesc *v) {
+  /* test_then_block -&gt; [IF | ELSEIF] cond THEN block */
+  next(ls);  /* skip IF or ELSEIF */
+  cond(ls, v);
+  check(ls, TK_THEN);
+  block(ls);  /* `then' part */
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls-&gt;fs;
+  expdesc v;
+  int escapelist = NO_JUMP;
+  test_then_block(ls, &amp;v);  /* IF cond THEN block */
+  while (ls-&gt;t.token == TK_ELSEIF) {
+    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    test_then_block(ls, &amp;v);  /* ELSEIF cond THEN block */
+  }
+  if (ls-&gt;t.token == TK_ELSE) {
+    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    next(ls);  /* skip ELSE (after patch, for correct line info) */
+    block(ls);  /* `else' part */
+  }
+  else
+    luaK_concat(fs, &amp;escapelist, v.f);
+  luaK_patchtohere(fs, escapelist);
+  check_match(ls, TK_END, TK_IF, line);
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc v, b;
+  new_localvar(ls, str_checkname(ls), 0);
+  init_exp(&amp;v, VLOCAL, ls-&gt;fs-&gt;freereg++);
+  adjustlocalvars(ls, 1);
+  body(ls, &amp;b, 0, ls-&gt;linenumber);
+  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls), nvars++);
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist1(ls, &amp;e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &amp;e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -&gt; NAME {field} [`:' NAME] */
+  int needself = 0;
+  singlevar(ls, v, 1);
+  while (ls-&gt;t.token == '.')
+    luaY_field(ls, v);
+  if (ls-&gt;t.token == ':') {
+    needself = 1;
+    luaY_field(ls, v);
+  }
+  return needself;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -&gt; FUNCTION funcname body */
+  int needself;
+  expdesc v, b;
+  next(ls);  /* skip FUNCTION */
+  needself = funcname(ls, &amp;v);
+  body(ls, &amp;b, needself, line);
+  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);
+  luaK_fixline(ls-&gt;fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -&gt; func | assignment */
+  FuncState *fs = ls-&gt;fs;
+  struct LHS_assign v;
+  primaryexp(ls, &amp;v.v);
+  if (v.v.k == VCALL) {  /* stat -&gt; func */
+    luaK_setcallreturns(fs, &amp;v.v, 0);  /* call statement uses no results */
+  }
+  else {  /* stat -&gt; assignment */
+    v.prev = NULL;
+    assignment(ls, &amp;v, 1);
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -&gt; RETURN explist */
+  FuncState *fs = ls-&gt;fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  next(ls);  /* skip RETURN */
+  if (block_follow(ls-&gt;t.token) || ls-&gt;t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist1(ls, &amp;e);  /* optional return values */
+    if (e.k == VCALL) {
+      luaK_setcallreturns(fs, &amp;e, LUA_MULTRET);
+      if (nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&amp;e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&amp;e)) == fs-&gt;nactvar);
+      }
+      first = fs-&gt;nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &amp;e);
+      else {
+        luaK_exp2nextreg(fs, &amp;e);  /* values must go to the `stack' */
+        first = fs-&gt;nactvar;  /* return all `active' values */
+        lua_assert(nret == fs-&gt;freereg - first);
+      }
+    }
+  }
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static void breakstat (LexState *ls) {
+  /* stat -&gt; BREAK [NAME] */
+  FuncState *fs = ls-&gt;fs;
+  BlockCnt *bl = fs-&gt;bl;
+  int upval = 0;
+  next(ls);  /* skip BREAK */
+  while (bl &amp;&amp; !bl-&gt;isbreakable) {
+    upval |= bl-&gt;upval;
+    bl = bl-&gt;previous;
+  }
+  if (!bl)
+    luaX_syntaxerror(ls, &quot;no loop to break&quot;);
+  if (upval)
+    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
+  luaK_concat(fs, &amp;bl-&gt;breaklist, luaK_jump(fs));
+}
+
+
+static int statement (LexState *ls) {
+  int line = ls-&gt;linenumber;  /* may be needed for error messages */
+  switch (ls-&gt;t.token) {
+    case TK_IF: {  /* stat -&gt; ifstat */
+      ifstat(ls, line);
+      return 0;
+    }
+    case TK_WHILE: {  /* stat -&gt; whilestat */
+      whilestat(ls, line);
+      return 0;
+    }
+    case TK_DO: {  /* stat -&gt; DO block END */
+      next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      return 0;
+    }
+    case TK_FOR: {  /* stat -&gt; forstat */
+      forstat(ls, line);
+      return 0;
+    }
+    case TK_REPEAT: {  /* stat -&gt; repeatstat */
+      repeatstat(ls, line);
+      return 0;
+    }
+    case TK_FUNCTION: {
+      funcstat(ls, line);  /* stat -&gt; funcstat */
+      return 0;
+    }
+    case TK_LOCAL: {  /* stat -&gt; localstat */
+      next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      return 0;
+    }
+    case TK_RETURN: {  /* stat -&gt; retstat */
+      retstat(ls);
+      return 1;  /* must be last statement */
+    }
+    case TK_BREAK: {  /* stat -&gt; breakstat */
+      breakstat(ls);
+      return 1;  /* must be last statement */
+    }
+    default: {
+      exprstat(ls);
+      return 0;  /* to avoid warnings */
+    }
+  }
+}
+
+
+static void chunk (LexState *ls) {
+  /* chunk -&gt; { stat [`;'] } */
+  int islast = 0;
+  enterlevel(ls);
+  while (!islast &amp;&amp; !block_follow(ls-&gt;t.token)) {
+    islast = statement(ls);
+    testnext(ls, ';');
+    lua_assert(ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);
+    ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  /* free registers */
+  }
+  leavelevel(ls);
+}
+
+/* }====================================================================== */

Added: trunk/Util/deditor/lua/lparser.h
===================================================================
--- trunk/Util/deditor/lua/lparser.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lparser.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,71 @@
+/*
+** $Id: lparser.h,v 1.47 2003/02/11 10:46:24 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include &quot;llimits.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;lzio.h&quot;
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in `upvalues' */
+  VGLOBAL,	/* info = index of table; aux = index of global name in `k' */
+  VINDEXED,	/* info = table register; aux = index register (or `k') */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VNONRELOC,	/* info = result register */
+  VCALL		/* info = result register */
+} expkind;
+
+typedef struct expdesc {
+  expkind k;
+  int info, aux;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct lua_State *L;  /* copy of the Lua state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* `pc' of last `jump target' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int freereg;  /* first free register */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int nlocvars;  /* number of elements in `locvars' */
+  int nactvar;  /* number of active local variables */
+  expdesc upvalues[MAXUPVALUES];  /* upvalues */
+  int actvar[MAXVARS];  /* declared-variable stack */
+} FuncState;
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff);
+
+
+#endif

Added: trunk/Util/deditor/lua/lstate.c
===================================================================
--- trunk/Util/deditor/lua/lstate.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstate.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,220 @@
+/*
+** $Id: lstate.c,v 1.123 2003/04/03 13:35:34 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lstate_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+
+
+/*
+** macro to allow the inclusion of user information in Lua state
+*/
+#ifndef LUA_USERSTATE
+#define EXTRASPACE	0
+#else
+union UEXTRASPACE {L_Umaxalign a; LUA_USERSTATE b;};
+#define EXTRASPACE (sizeof(union UEXTRASPACE))
+#endif
+
+
+
+/*
+** you can change this function through the official API:
+** call `lua_setpanicf'
+*/
+static int default_panic (lua_State *L) {
+  UNUSED(L);
+  return 0;
+}
+
+
+static lua_State *mallocstate (lua_State *L) {
+  lu_byte *block = (lu_byte *)luaM_malloc(L, sizeof(lua_State) + EXTRASPACE);
+  if (block == NULL) return NULL;
+  else {
+    block += EXTRASPACE;
+    return cast(lua_State *, block);
+  }
+}
+
+
+static void freestate (lua_State *L, lua_State *L1) {
+  luaM_free(L, cast(lu_byte *, L1) - EXTRASPACE,
+               sizeof(lua_State) + EXTRASPACE);
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TObject);
+  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
+  L1-&gt;top = L1-&gt;stack;
+  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;
+  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
+  L1-&gt;ci = L1-&gt;base_ci;
+  L1-&gt;ci-&gt;state = CI_C;  /*  not a Lua function */
+  setnilvalue(L1-&gt;top++);  /* `function' entry for this `ci' */
+  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;
+  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;
+  L1-&gt;size_ci = BASIC_CI_SIZE;
+  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci;
+}
+
+
+static void freestack (lua_State *L, lua_State *L1) {
+  luaM_freearray(L, L1-&gt;base_ci, L1-&gt;size_ci, CallInfo);
+  luaM_freearray(L, L1-&gt;stack, L1-&gt;stacksize, TObject);
+}
+
+
+/*
+** open parts that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  /* create a new global state */
+  global_State *g = luaM_new(NULL, global_State);
+  UNUSED(ud);
+  if (g == NULL) luaD_throw(L, LUA_ERRMEM);
+  L-&gt;l_G = g;
+  g-&gt;mainthread = L;
+  g-&gt;GCthreshold = 0;  /* mark it as unfinished state */
+  g-&gt;strt.size = 0;
+  g-&gt;strt.nuse = 0;
+  g-&gt;strt.hash = NULL;
+  setnilvalue(defaultmeta(L));
+  setnilvalue(registry(L));
+  luaZ_initbuffer(L, &amp;g-&gt;buff);
+  g-&gt;panic = default_panic;
+  g-&gt;rootgc = NULL;
+  g-&gt;rootudata = NULL;
+  g-&gt;tmudata = NULL;
+  setnilvalue(gkey(g-&gt;dummynode));
+  setnilvalue(gval(g-&gt;dummynode));
+  g-&gt;dummynode-&gt;next = NULL;
+  g-&gt;nblocks = sizeof(lua_State) + sizeof(global_State);
+  stack_init(L, L);  /* init stack */
+  /* create default meta table with a dummy table, and then close the loop */
+  defaultmeta(L)-&gt;tt = LUA_TTABLE;
+  sethvalue(defaultmeta(L), luaH_new(L, 0, 0));
+  hvalue(defaultmeta(L))-&gt;metatable = hvalue(defaultmeta(L));
+  sethvalue(gt(L), luaH_new(L, 0, 4));  /* table of globals */
+  sethvalue(registry(L), luaH_new(L, 4, 4));  /* registry */
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  luaS_fix(luaS_newliteral(L, MEMERRMSG));
+  g-&gt;GCthreshold = 4*G(L)-&gt;nblocks;
+}
+
+
+static void preinit_state (lua_State *L) {
+  L-&gt;stack = NULL;
+  L-&gt;stacksize = 0;
+  L-&gt;errorJmp = NULL;
+  L-&gt;hook = NULL;
+  L-&gt;hookmask = L-&gt;hookinit = 0;
+  L-&gt;basehookcount = 0;
+  L-&gt;allowhook = 1;
+  resethookcount(L);
+  L-&gt;openupval = NULL;
+  L-&gt;size_ci = 0;
+  L-&gt;nCcalls = 0;
+  L-&gt;base_ci = L-&gt;ci = NULL;
+  L-&gt;errfunc = 0;
+  setnilvalue(gt(L));
+}
+
+
+static void close_state (lua_State *L) {
+  luaF_close(L, L-&gt;stack);  /* close all upvalues for this thread */
+  if (G(L)) {  /* close global state */
+    luaC_sweep(L, 1);  /* collect all elements */
+    lua_assert(G(L)-&gt;rootgc == NULL);
+    lua_assert(G(L)-&gt;rootudata == NULL);
+    luaS_freeall(L);
+    luaZ_freebuffer(L, &amp;G(L)-&gt;buff);
+  }
+  freestack(L, L);
+  if (G(L)) {
+    lua_assert(G(L)-&gt;nblocks == sizeof(lua_State) + sizeof(global_State));
+    luaM_freelem(NULL, G(L));
+  }
+  freestate(NULL, L);
+}
+
+
+lua_State *luaE_newthread (lua_State *L) {
+  lua_State *L1 = mallocstate(L);
+  luaC_link(L, valtogco(L1), LUA_TTHREAD);
+  preinit_state(L1);
+  L1-&gt;l_G = L-&gt;l_G;
+  stack_init(L1, L);  /* init stack */
+  setobj2n(gt(L1), gt(L));  /* share table of globals */
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  luaF_close(L1, L1-&gt;stack);  /* close all upvalues for this thread */
+  lua_assert(L1-&gt;openupval == NULL);
+  freestack(L, L1);
+  freestate(L, L1);
+}
+
+
+LUA_API lua_State *lua_open (void) {
+  lua_State *L = mallocstate(NULL);
+  if (L) {  /* allocation OK? */
+    L-&gt;tt = LUA_TTHREAD;
+    L-&gt;marked = 0;
+    L-&gt;next = L-&gt;gclist = NULL;
+    preinit_state(L);
+    L-&gt;l_G = NULL;
+    if (luaD_rawrunprotected(L, f_luaopen, NULL) != 0) {
+      /* memory allocation error: free partial state */
+      close_state(L);
+      L = NULL;
+    }
+  }
+  lua_userstateopen(L);
+  return L;
+}
+
+
+static void callallgcTM (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaC_callGCTM(L);  /* call GC metamethods for all udata */
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  lua_lock(L);
+  L = G(L)-&gt;mainthread;  /* only the main thread can be closed */
+  luaF_close(L, L-&gt;stack);  /* close all upvalues for this thread */
+  luaC_separateudata(L);  /* separate udata that have GC metamethods */
+  L-&gt;errfunc = 0;  /* no error function during GC metamethods */
+  do {  /* repeat until no more errors */
+    L-&gt;ci = L-&gt;base_ci;
+    L-&gt;base = L-&gt;top = L-&gt;ci-&gt;base;
+    L-&gt;nCcalls = 0;
+  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
+  lua_assert(G(L)-&gt;tmudata == NULL);
+  close_state(L);
+}
+

Added: trunk/Util/deditor/lua/lstate.h
===================================================================
--- trunk/Util/deditor/lua/lstate.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstate.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,195 @@
+/*
+** $Id: lstate.h,v 1.109 2003/02/27 11:52:30 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lzio.h&quot;
+
+
+/*
+** macros for thread synchronization inside Lua core machine:
+** all accesses to the global state and to global objects are synchronized.
+** Because threads can read the stack of other threads
+** (when running garbage collection),
+** a thread must also synchronize any write-access to its own stack.
+** Unsynchronized accesses are allowed only when reading its own stack,
+** or when reading immutable fields from global objects
+** (such as string values and udata values). 
+*/
+#ifndef lua_lock
+#define lua_lock(L)	((void) 0)
+#endif
+
+#ifndef lua_unlock
+#define lua_unlock(L)	((void) 0)
+#endif
+
+
+#ifndef lua_userstateopen
+#define lua_userstateopen(l)
+#endif
+
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+/* default meta table (both for tables and udata) */
+#define defaultmeta(L)	(&amp;G(L)-&gt;_defaultmeta)
+
+/* table of globals */
+#define gt(L)	(&amp;L-&gt;_gt)
+
+/* registry */
+#define registry(L)	(&amp;G(L)-&gt;_registry)
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_CI_SIZE           8
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  ls_nstr nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** informations about a call
+*/
+typedef struct CallInfo {
+  StkId base;  /* base for called function */
+  StkId	top;  /* top for this function */
+  int state;  /* bit fields; see below */
+  union {
+    struct {  /* for Lua functions */
+      const Instruction *savedpc;
+      const Instruction **pc;  /* points to `pc' variable in `luaV_execute' */
+      int tailcalls;  /* number of tail calls lost under this entry */
+    } l;
+    struct {  /* for C functions */
+      int dummy;  /* just to avoid an empty struct */
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** bit fields for `CallInfo.state'
+*/
+#define CI_C		(1&lt;&lt;0)  /* 1 if function is a C function */
+/* 1 if (Lua) function has an active `luaV_execute' running it */
+#define CI_HASFRAME	(1&lt;&lt;1)
+/* 1 if Lua function is calling another Lua function (and therefore its
+   `pc' is being used by the other, and therefore CI_SAVEDPC is 1 too) */
+#define CI_CALLING	(1&lt;&lt;2)
+#define CI_SAVEDPC	(1&lt;&lt;3)  /* 1 if `savedpc' is updated */
+#define CI_YIELD	(1&lt;&lt;4)  /* 1 if thread is suspended */
+
+
+#define ci_func(ci)	(clvalue((ci)-&gt;base - 1))
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  stringtable strt;  /* hash table for strings */
+  GCObject *rootgc;  /* list of (almost) all collectable objects */
+  GCObject *rootudata;   /* (separated) list of all userdata */
+  GCObject *tmudata;  /* list of userdata to be GC */
+  Mbuffer buff;  /* temporary buffer for string concatentation */
+  lu_mem GCthreshold;
+  lu_mem nblocks;  /* number of `bytes' currently allocated */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  TObject _registry;
+  TObject _defaultmeta;
+  struct lua_State *mainthread;
+  Node dummynode[1];  /* common node array for all empty tables */
+  TString *tmname[TM_N];  /* array with tag-method names */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  StkId top;  /* first free slot in the stack */
+  StkId base;  /* base of current function */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  CallInfo *end_ci;  /* points after end of ci array*/
+  CallInfo *base_ci;  /* array of CallInfo's */
+  unsigned short size_ci;  /* size of array `base_ci' */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  lu_byte hookinit;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  TObject _gt;  /* table of globals */
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+};
+
+
+#define G(L)	(L-&gt;l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+/* macros to convert a GCObject into a specific value */
+#define gcotots(o)	check_exp((o)-&gt;gch.tt == LUA_TSTRING, &amp;((o)-&gt;ts))
+#define gcotou(o)	check_exp((o)-&gt;gch.tt == LUA_TUSERDATA, &amp;((o)-&gt;u))
+#define gcotocl(o)	check_exp((o)-&gt;gch.tt == LUA_TFUNCTION, &amp;((o)-&gt;cl))
+#define gcotoh(o)	check_exp((o)-&gt;gch.tt == LUA_TTABLE, &amp;((o)-&gt;h))
+#define gcotop(o)	check_exp((o)-&gt;gch.tt == LUA_TPROTO, &amp;((o)-&gt;p))
+#define gcotouv(o)	check_exp((o)-&gt;gch.tt == LUA_TUPVAL, &amp;((o)-&gt;uv))
+#define ngcotouv(o) \
+	check_exp((o) == NULL || (o)-&gt;gch.tt == LUA_TUPVAL, &amp;((o)-&gt;uv))
+#define gcototh(o)	check_exp((o)-&gt;gch.tt == LUA_TTHREAD, &amp;((o)-&gt;th))
+
+/* macro to convert any value into a GCObject */
+#define valtogco(v)	(cast(GCObject *, (v)))
+
+
+lua_State *luaE_newthread (lua_State *L);
+void luaE_freethread (lua_State *L, lua_State *L1);
+
+#endif
+

Added: trunk/Util/deditor/lua/lstring.c
===================================================================
--- trunk/Util/deditor/lua/lstring.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstring.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,102 @@
+/*
+** $Id: lstring.c,v 1.78 2002/12/04 17:38:31 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define lstring_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+
+
+
+void luaS_freeall (lua_State *L) {
+  lua_assert(G(L)-&gt;strt.nuse==0);
+  luaM_freearray(L, G(L)-&gt;strt.hash, G(L)-&gt;strt.size, TString *);
+}
+
+
+void luaS_resize (lua_State *L, int newsize) {
+  GCObject **newhash = luaM_newvector(L, newsize, GCObject *);
+  stringtable *tb = &amp;G(L)-&gt;strt;
+  int i;
+  for (i=0; i&lt;newsize; i++) newhash[i] = NULL;
+  /* rehash */
+  for (i=0; i&lt;tb-&gt;size; i++) {
+    GCObject *p = tb-&gt;hash[i];
+    while (p) {  /* for each node in the list */
+      GCObject *next = p-&gt;gch.next;  /* save next */
+      lu_hash h = gcotots(p)-&gt;tsv.hash;
+      int h1 = lmod(h, newsize);  /* new position */
+      lua_assert(cast(int, h%newsize) == lmod(h, newsize));
+      p-&gt;gch.next = newhash[h1];  /* chain it */
+      newhash[h1] = p;
+      p = next;
+    }
+  }
+  luaM_freearray(L, tb-&gt;hash, tb-&gt;size, TString *);
+  tb-&gt;size = newsize;
+  tb-&gt;hash = newhash;
+}
+
+
+static TString *newlstr (lua_State *L, const char *str, size_t l, lu_hash h) {
+  TString *ts = cast(TString *, luaM_malloc(L, sizestring(l)));
+  stringtable *tb;
+  ts-&gt;tsv.len = l;
+  ts-&gt;tsv.hash = h;
+  ts-&gt;tsv.marked = 0;
+  ts-&gt;tsv.tt = LUA_TSTRING;
+  ts-&gt;tsv.reserved = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  tb = &amp;G(L)-&gt;strt;
+  h = lmod(h, tb-&gt;size);
+  ts-&gt;tsv.next = tb-&gt;hash[h];  /* chain new entry */
+  tb-&gt;hash[h] = valtogco(ts);
+  tb-&gt;nuse++;
+  if (tb-&gt;nuse &gt; cast(ls_nstr, tb-&gt;size) &amp;&amp; tb-&gt;size &lt;= MAX_INT/2)
+    luaS_resize(L, tb-&gt;size*2);  /* too crowded */
+  return ts;
+}
+
+
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  lu_hash h = (lu_hash)l;  /* seed */
+  size_t step = (l&gt;&gt;5)+1;  /* if string is too long, don't hash all its chars */
+  size_t l1;
+  for (l1=l; l1&gt;=step; l1-=step)  /* compute hash */
+    h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+(unsigned char)(str[l1-1]));
+  for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];
+       o != NULL;
+       o = o-&gt;gch.next) {
+    TString *ts = gcotots(o);
+    if (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == 0))
+      return ts;
+  }
+  return newlstr(L, str, l, h);  /* not found */
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s) {
+  Udata *u;
+  u = cast(Udata *, luaM_malloc(L, sizeudata(s)));
+  u-&gt;uv.marked = (1&lt;&lt;1);  /* is not finalized */
+  u-&gt;uv.tt = LUA_TUSERDATA;
+  u-&gt;uv.len = s;
+  u-&gt;uv.metatable = hvalue(defaultmeta(L));
+  /* chain it on udata list */
+  u-&gt;uv.next = G(L)-&gt;rootudata;
+  G(L)-&gt;rootudata = valtogco(u);
+  return u;
+}
+

Added: trunk/Util/deditor/lua/lstring.h
===================================================================
--- trunk/Util/deditor/lua/lstring.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lstring.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,33 @@
+/*
+** $Id: lstring.h,v 1.37 2002/08/16 14:45:55 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+
+
+
+#define sizestring(l)	(cast(lu_mem, sizeof(union TString))+ \
+                         (cast(lu_mem, l)+1)*sizeof(char))
+
+#define sizeudata(l)	(cast(lu_mem, sizeof(union Udata))+(l))
+
+#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, &quot;&quot; s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	((s)-&gt;tsv.marked |= (1&lt;&lt;4))
+
+void luaS_resize (lua_State *L, int newsize);
+Udata *luaS_newudata (lua_State *L, size_t s);
+void luaS_freeall (lua_State *L);
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+
+
+#endif

Added: trunk/Util/deditor/lua/ltable.c
===================================================================
--- trunk/Util/deditor/lua/ltable.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltable.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,509 @@
+/*
+** $Id: ltable.c,v 1.132 2003/04/03 13:35:34 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** In other words, there are collisions only when two elements have the
+** same main position (i.e. the same hash values for that table size).
+** Because of that, the load factor of these tables can be 100% without
+** performance penalties.
+*/
+
+#include &lt;string.h&gt;
+
+#define ltable_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;ltable.h&quot;
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if BITS_INT &gt; 26
+#define MAXBITS		24
+#else
+#define MAXBITS		(BITS_INT-2)
+#endif
+
+/* check whether `x' &lt; 2^MAXBITS */
+#define toobig(x)	((((x)-1) &gt;&gt; MAXBITS) != 0)
+
+
+/* function to convert a lua_Number to int (with any rounding method) */
+#ifndef lua_number2int
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+
+#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
+  
+#define hashstr(t,str)  hashpow2(t, (str)-&gt;tsv.hash)
+#define hashboolean(t,p)        hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+/*
+** number of ints inside a lua_Number
+*/
+#define numints		cast(int, sizeof(lua_Number)/sizeof(int))
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  unsigned int a[numints];
+  int i;
+  n += 1;  /* normalize number (avoid -0) */
+  lua_assert(sizeof(a) &lt;= sizeof(n));
+  memcpy(a, &amp;n, sizeof(a));
+  for (i = 1; i &lt; numints; i++) a[0] += a[i];
+  return hashmod(t, cast(lu_hash, a[0]));
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+Node *luaH_mainposition (const Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TSTRING:
+      return hashstr(t, tsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TObject *key) {
+  if (ttisnumber(key)) {
+    int k;
+    lua_number2int(k, (nvalue(key)));
+    if (cast(lua_Number, k) == nvalue(key) &amp;&amp; k &gt;= 1 &amp;&amp; !toobig(k))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning and end of a traversal are signalled by -1.
+*/
+static int luaH_index (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 &lt;= i &amp;&amp; i &lt;= t-&gt;sizearray) {  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  }
+  else {
+    const TObject *v = luaH_get(t, key);
+    if (v == &amp;luaO_nilobject)
+      luaG_runerror(L, &quot;invalid key for `next'&quot;);
+    i = cast(int, (cast(const lu_byte *, v) -
+                   cast(const lu_byte *, gval(gnode(t, 0)))) / sizeof(Node));
+    return i + t-&gt;sizearray;  /* hash elements are numbered after array ones */
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = luaH_index(L, t, key);  /* find original element */
+  for (i++; i &lt; t-&gt;sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&amp;t-&gt;array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast(lua_Number, i+1));
+      setobj2s(key+1, &amp;t-&gt;array[i]);
+      return 1;
+    }
+  }
+  for (i -= t-&gt;sizearray; i &lt; sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(key, gkey(gnode(t, i)));
+      setobj2s(key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static void computesizes  (int nums[], int ntotal, int *narray, int *nhash) {
+  int i;
+  int a = nums[0];  /* number of elements smaller than 2^i */
+  int na = a;  /* number of elements to go to array part */
+  int n = (na == 0) ? -1 : 0;  /* (log of) optimal size for array part */
+  for (i = 1; a &lt; *narray &amp;&amp; *narray &gt;= twoto(i-1); i++) {
+    if (nums[i] &gt; 0) {
+      a += nums[i];
+      if (a &gt;= twoto(i-1)) {  /* more than half elements in use? */
+        n = i;
+        na = a;
+      }
+    }
+  }
+  lua_assert(na &lt;= *narray &amp;&amp; *narray &lt;= ntotal);
+  *nhash = ntotal - na;
+  *narray = (n == -1) ? 0 : twoto(n);
+  lua_assert(na &lt;= *narray &amp;&amp; na &gt;= *narray/2);
+}
+
+
+static void numuse (const Table *t, int *narray, int *nhash) {
+  int nums[MAXBITS+1];
+  int i, lg;
+  int totaluse = 0;
+  /* count elements in array part */
+  for (i=0, lg=0; lg&lt;=MAXBITS; lg++) {  /* for each slice [2^(lg-1) to 2^lg) */
+    int ttlg = twoto(lg);  /* 2^lg */
+    if (ttlg &gt; t-&gt;sizearray) {
+      ttlg = t-&gt;sizearray;
+      if (i &gt;= ttlg) break;
+    }
+    nums[lg] = 0;
+    for (; i&lt;ttlg; i++) {
+      if (!ttisnil(&amp;t-&gt;array[i])) {
+        nums[lg]++;
+        totaluse++;
+      }
+    }
+  }
+  for (; lg&lt;=MAXBITS; lg++) nums[lg] = 0;  /* reset other counts */
+  *narray = totaluse;  /* all previous uses were in array part */
+  /* count elements in hash part */
+  i = sizenode(t);
+  while (i--) {
+    Node *n = &amp;t-&gt;node[i];
+    if (!ttisnil(gval(n))) {
+      int k = arrayindex(gkey(n));
+      if (k &gt;= 0) {  /* is `key' an appropriate array index? */
+        nums[luaO_log2(k-1)+1]++;  /* count as such */
+        (*narray)++;
+      }
+      totaluse++;
+    }
+  }
+  computesizes(nums, totaluse, narray, nhash);
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t-&gt;array, t-&gt;sizearray, size, TObject);
+  for (i=t-&gt;sizearray; i&lt;size; i++)
+     setnilvalue(&amp;t-&gt;array[i]);
+  t-&gt;sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int lsize) {
+  int i;
+  int size = twoto(lsize);
+  if (lsize &gt; MAXBITS)
+    luaG_runerror(L, &quot;table overflow&quot;);
+  if (lsize == 0) {  /* no elements to hash part? */
+    t-&gt;node = G(L)-&gt;dummynode;  /* use common `dummynode' */
+    lua_assert(ttisnil(gkey(t-&gt;node)));  /* assert invariants: */
+    lua_assert(ttisnil(gval(t-&gt;node)));
+    lua_assert(t-&gt;node-&gt;next == NULL);  /* (`dummynode' must be empty) */
+  }
+  else {
+    t-&gt;node = luaM_newvector(L, size, Node);
+    for (i=0; i&lt;size; i++) {
+      t-&gt;node[i].next = NULL;
+      setnilvalue(gkey(gnode(t, i)));
+      setnilvalue(gval(gnode(t, i)));
+    }
+  }
+  t-&gt;lsizenode = cast(lu_byte, lsize);
+  t-&gt;firstfree = gnode(t, size-1);  /* first free position to be used */
+}
+
+
+static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t-&gt;sizearray;
+  int oldhsize = t-&gt;lsizenode;
+  Node *nold;
+  Node temp[1];
+  if (oldhsize)
+    nold = t-&gt;node;  /* save old hash ... */
+  else {  /* old hash is `dummynode' */
+    lua_assert(t-&gt;node == G(L)-&gt;dummynode);
+    temp[0] = t-&gt;node[0];  /* copy it to `temp' */
+    nold = temp;
+    setnilvalue(gkey(G(L)-&gt;dummynode));  /* restate invariant */
+    setnilvalue(gval(G(L)-&gt;dummynode));
+    lua_assert(G(L)-&gt;dummynode-&gt;next == NULL);
+  }
+  if (nasize &gt; oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);  
+  /* re-insert elements */
+  if (nasize &lt; oldasize) {  /* array part must shrink? */
+    t-&gt;sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i&lt;oldasize; i++) {
+      if (!ttisnil(&amp;t-&gt;array[i]))
+        setobjt2t(luaH_setnum(L, t, i+1), &amp;t-&gt;array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t-&gt;array, oldasize, nasize, TObject);
+  }
+  /* re-insert elements in hash part */
+  for (i = twoto(oldhsize) - 1; i &gt;= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old)))
+      setobjt2t(luaH_set(L, t, gkey(old)), gval(old));
+  }
+  if (oldhsize)
+    luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
+}
+
+
+static void rehash (lua_State *L, Table *t) {
+  int nasize, nhsize;
+  numuse(t, &amp;nasize, &amp;nhsize);  /* compute new sizes for array and hash parts */
+  resize(L, t, nasize, luaO_log2(nhsize)+1);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L, int narray, int lnhash) {
+  Table *t = luaM_new(L, Table);
+  luaC_link(L, valtogco(t), LUA_TTABLE);
+  t-&gt;metatable = hvalue(defaultmeta(L));
+  t-&gt;flags = cast(lu_byte, ~0);
+  /* temporary values (kept only if some malloc fails) */
+  t-&gt;array = NULL;
+  t-&gt;sizearray = 0;
+  t-&gt;lsizenode = 0;
+  t-&gt;node = NULL;
+  setarrayvector(L, t, narray);
+  setnodevector(L, t, lnhash);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (t-&gt;lsizenode)
+    luaM_freearray(L, t-&gt;node, sizenode(t), Node);
+  luaM_freearray(L, t-&gt;array, t-&gt;sizearray, TObject);
+  luaM_freelem(L, t);
+}
+
+
+#if 0
+/*
+** try to remove an element from a hash table; cannot move any element
+** (because gc can call `remove' during a table traversal)
+*/
+void luaH_remove (Table *t, Node *e) {
+  Node *mp = luaH_mainposition(t, gkey(e));
+  if (e != mp) {  /* element not in its main position? */
+    while (mp-&gt;next != e) mp = mp-&gt;next;  /* find previous */
+    mp-&gt;next = e-&gt;next;  /* remove `e' from its list */
+  }
+  else {
+    if (e-&gt;next != NULL) ??
+  }
+  lua_assert(ttisnil(gval(node)));
+  setnilvalue(gkey(e));  /* clear node `e' */
+  e-&gt;next = NULL;
+}
+#endif
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main 
+** position is free. If not, check whether colliding node is in its main 
+** position or not: if it is not, move colliding node to an empty place and 
+** put new key in its main position; otherwise (colliding node is in its main 
+** position), new key goes to an empty position. 
+*/
+static TObject *newkey (lua_State *L, Table *t, const TObject *key) {
+  TObject *val;
+  Node *mp = luaH_mainposition(t, key);
+  if (!ttisnil(gval(mp))) {  /* main position is not free? */
+    Node *othern = luaH_mainposition(t, gkey(mp));  /* `mp' of colliding node */
+    Node *n = t-&gt;firstfree;  /* get a free place */
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (othern-&gt;next != mp) othern = othern-&gt;next;  /* find previous */
+      othern-&gt;next = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp-&gt;next also goes) */
+      mp-&gt;next = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      n-&gt;next = mp-&gt;next;  /* chain new position */
+      mp-&gt;next = n;
+      mp = n;
+    }
+  }
+  setobj2t(gkey(mp), key);  /* write barrier */
+  lua_assert(ttisnil(gval(mp)));
+  for (;;) {  /* correct `firstfree' */
+    if (ttisnil(gkey(t-&gt;firstfree)))
+      return gval(mp);  /* OK; table still has a free place */
+    else if (t-&gt;firstfree == t-&gt;node) break;  /* cannot decrement from here */
+    else (t-&gt;firstfree)--;
+  }
+  /* no more free places; must create one */
+  setbvalue(gval(mp), 0);  /* avoid new key being removed */
+  rehash(L, t);  /* grow table */
+  val = cast(TObject *, luaH_get(t, key));  /* get new position */
+  lua_assert(ttisboolean(val));
+  setnilvalue(val);
+  return val;
+}
+
+
+/*
+** generic search function
+*/
+static const TObject *luaH_getany (Table *t, const TObject *key) {
+  if (ttisnil(key)) return &amp;luaO_nilobject;
+  else {
+    Node *n = luaH_mainposition(t, key);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (luaO_rawequalObj(gkey(n), key)) return gval(n);  /* that's it */
+      else n = n-&gt;next;
+    } while (n);
+    return &amp;luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for integers
+*/
+const TObject *luaH_getnum (Table *t, int key) {
+  if (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray)
+    return &amp;t-&gt;array[key-1];
+  else {
+    lua_Number nk = cast(lua_Number, key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) &amp;&amp; nvalue(gkey(n)) == nk)
+        return gval(n);  /* that's it */
+      else n = n-&gt;next;
+    } while (n);
+    return &amp;luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for strings
+*/
+const TObject *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisstring(gkey(n)) &amp;&amp; tsvalue(gkey(n)) == key)
+      return gval(n);  /* that's it */
+    else n = n-&gt;next;
+  } while (n);
+  return &amp;luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TObject *luaH_get (Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TSTRING: return luaH_getstr(t, tsvalue(key));
+    case LUA_TNUMBER: {
+      int k;
+      lua_number2int(k, (nvalue(key)));
+      if (cast(lua_Number, k) == nvalue(key))  /* is an integer index? */
+        return luaH_getnum(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: return luaH_getany(t, key);
+  }
+}
+
+
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key) {
+  const TObject *p = luaH_get(t, key);
+  t-&gt;flags = 0;
+  if (p != &amp;luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    if (ttisnil(key)) luaG_runerror(L, &quot;table index is nil&quot;);
+    else if (ttisnumber(key) &amp;&amp; nvalue(key) != nvalue(key))
+      luaG_runerror(L, &quot;table index is NaN&quot;);
+    return newkey(L, t, key);
+  }
+}
+
+
+TObject *luaH_setnum (lua_State *L, Table *t, int key) {
+  const TObject *p = luaH_getnum(t, key);
+  if (p != &amp;luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    TObject k;
+    setnvalue(&amp;k, cast(lua_Number, key));
+    return newkey(L, t, &amp;k);
+  }
+}
+

Added: trunk/Util/deditor/lua/ltable.h
===================================================================
--- trunk/Util/deditor/lua/ltable.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltable.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,31 @@
+/*
+** $Id: ltable.h,v 1.44 2003/03/18 12:50:04 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include &quot;lobject.h&quot;
+
+
+#define gnode(t,i)	(&amp;(t)-&gt;node[i])
+#define gkey(n)		(&amp;(n)-&gt;i_key)
+#define gval(n)		(&amp;(n)-&gt;i_val)
+
+
+const TObject *luaH_getnum (Table *t, int key);
+TObject *luaH_setnum (lua_State *L, Table *t, int key);
+const TObject *luaH_getstr (Table *t, TString *key);
+const TObject *luaH_get (Table *t, const TObject *key);
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key);
+Table *luaH_new (lua_State *L, int narray, int lnhash);
+void luaH_free (lua_State *L, Table *t);
+int luaH_next (lua_State *L, Table *t, StkId key);
+
+/* exported only for debugging */
+Node *luaH_mainposition (const Table *t, const TObject *key);
+
+
+#endif

Added: trunk/Util/deditor/lua/ltests.c
===================================================================
--- trunk/Util/deditor/lua/ltests.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltests.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,852 @@
+/*
+** $Id: ltests.c,v 1.158 2003/04/07 14:35:00 roberto Exp $
+** Internal Module for Debugging of the Lua Implementation
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ltests_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lapi.h&quot;
+#include &quot;lauxlib.h&quot;
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+/*
+** The whole module only makes sense with LUA_DEBUG on
+*/
+#ifdef LUA_DEBUG
+
+
+#define lua_pushintegral(L,i)	lua_pushnumber(L, cast(lua_Number, (i)))
+
+
+static lua_State *lua_state = NULL;
+
+int islocked = 0;
+
+
+#define func_at(L,k)	(L-&gt;ci-&gt;base+(k) - 1)
+
+
+static void setnameval (lua_State *L, const char *name, int val) {
+  lua_pushstring(L, name);
+  lua_pushintegral(L, val);
+  lua_settable(L, -3);
+}
+
+
+/*
+** {======================================================================
+** Controlled version for realloc.
+** =======================================================================
+*/
+
+#define MARK		0x55  /* 01010101 (a nice pattern) */
+
+#ifndef EXTERNMEMCHECK
+/* full memory check */
+#define HEADER	(sizeof(L_Umaxalign)) /* ensures maximum alignment for HEADER */
+#define MARKSIZE	16  /* size of marks after each block */
+#define blockhead(b)	(cast(char *, b) - HEADER)
+#define setsize(newblock, size)	(*cast(size_t *, newblock) = size)
+#define checkblocksize(b, size) (size == (*cast(size_t *, blockhead(b))))
+#define fillmem(mem,size)	memset(mem, -MARK, size)
+#else
+/* external memory check: don't do it twice */
+#define HEADER		0
+#define MARKSIZE	0
+#define blockhead(b)	(b)
+#define setsize(newblock, size)	/* empty */
+#define checkblocksize(b,size)	(1)
+#define fillmem(mem,size)	/* empty */
+#endif
+
+unsigned long memdebug_numblocks = 0;
+unsigned long memdebug_total = 0;
+unsigned long memdebug_maxmem = 0;
+unsigned long memdebug_memlimit = ULONG_MAX;
+
+
+static void *checkblock (void *block, size_t size) {
+  void *b = blockhead(block);
+  int i;
+  for (i=0;i&lt;MARKSIZE;i++)
+    lua_assert(*(cast(char *, b)+HEADER+size+i) == MARK+i); /* corrupted block? */
+  return b;
+}
+
+
+static void freeblock (void *block, size_t size) {
+  if (block) {
+    lua_assert(checkblocksize(block, size));
+    block = checkblock(block, size);
+    fillmem(block, size+HEADER+MARKSIZE);  /* erase block */
+    free(block);  /* free original block */
+    memdebug_numblocks--;
+    memdebug_total -= size;
+  }
+}
+
+
+void *debug_realloc (void *block, size_t oldsize, size_t size) {
+  lua_assert(oldsize == 0 || checkblocksize(block, oldsize));
+  /* ISO does not specify what realloc(NULL, 0) does */
+  lua_assert(block != NULL || size &gt; 0);
+  if (size == 0) {
+    freeblock(block, oldsize);
+    return NULL;
+  }
+  else if (size &gt; oldsize &amp;&amp; memdebug_total+size-oldsize &gt; memdebug_memlimit)
+    return NULL;  /* to test memory allocation errors */
+  else {
+    void *newblock;
+    int i;
+    size_t realsize = HEADER+size+MARKSIZE;
+    size_t commonsize = (oldsize &lt; size) ? oldsize : size;
+    if (realsize &lt; size) return NULL;  /* overflow! */
+    newblock = malloc(realsize);  /* alloc a new block */
+    if (newblock == NULL) return NULL;
+    if (block) {
+      memcpy(cast(char *, newblock)+HEADER, block, commonsize);
+      freeblock(block, oldsize);  /* erase (and check) old copy */
+    }
+    /* initialize new part of the block with something `weird' */
+    fillmem(cast(char *, newblock)+HEADER+commonsize, size-commonsize);
+    memdebug_total += size;
+    if (memdebug_total &gt; memdebug_maxmem)
+      memdebug_maxmem = memdebug_total;
+    memdebug_numblocks++;
+    setsize(newblock, size);
+    for (i=0;i&lt;MARKSIZE;i++)
+      *(cast(char *, newblock)+HEADER+size+i) = cast(char, MARK+i);
+    return cast(char *, newblock)+HEADER;
+  }
+}
+
+
+/* }====================================================================== */
+
+
+
+/*
+** {======================================================
+** Disassembler
+** =======================================================
+*/
+
+
+static char *buildop (Proto *p, int pc, char *buff) {
+  Instruction i = p-&gt;code[pc];
+  OpCode o = GET_OPCODE(i);
+  const char *name = luaP_opnames[o];
+  int line = getline(p, pc);
+  sprintf(buff, &quot;(%4d) %4d - &quot;, line, pc);
+  switch (getOpMode(o)) {  
+    case iABC:
+      sprintf(buff+strlen(buff), &quot;%-12s%4d %4d %4d&quot;, name,
+              GETARG_A(i), GETARG_B(i), GETARG_C(i));
+      break;
+    case iABx:
+      sprintf(buff+strlen(buff), &quot;%-12s%4d %4d&quot;, name, GETARG_A(i), GETARG_Bx(i));
+      break;
+    case iAsBx:
+      sprintf(buff+strlen(buff), &quot;%-12s%4d %4d&quot;, name, GETARG_A(i), GETARG_sBx(i));
+      break;
+  }
+  return buff;
+}
+
+
+#if 0
+void luaI_printcode (Proto *pt, int size) {
+  int pc;
+  for (pc=0; pc&lt;size; pc++) {
+    char buff[100];
+    printf(&quot;%s\n&quot;, buildop(pt, pc, buff));
+  }
+  printf(&quot;-------\n&quot;);
+}
+#endif
+
+
+static int listcode (lua_State *L) {
+  int pc;
+  Proto *p;
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1),
+                 1, &quot;Lua function expected&quot;);
+  p = clvalue(func_at(L, 1))-&gt;l.p;
+  lua_newtable(L);
+  setnameval(L, &quot;maxstack&quot;, p-&gt;maxstacksize);
+  setnameval(L, &quot;numparams&quot;, p-&gt;numparams);
+  for (pc=0; pc&lt;p-&gt;sizecode; pc++) {
+    char buff[100];
+    lua_pushintegral(L, pc+1);
+    lua_pushstring(L, buildop(p, pc, buff));
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listk (lua_State *L) {
+  Proto *p;
+  int i;
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1),
+                 1, &quot;Lua function expected&quot;);
+  p = clvalue(func_at(L, 1))-&gt;l.p;
+  lua_newtable(L);
+  for (i=0; i&lt;p-&gt;sizek; i++) {
+    lua_pushintegral(L, i+1);
+    luaA_pushobject(L, p-&gt;k+i);
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listlocals (lua_State *L) {
+  Proto *p;
+  int pc = luaL_checkint(L, 2) - 1;
+  int i = 0;
+  const char *name;
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1),
+                 1, &quot;Lua function expected&quot;);
+  p = clvalue(func_at(L, 1))-&gt;l.p;
+  while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)
+    lua_pushstring(L, name);
+  return i-1;
+}
+
+/* }====================================================== */
+
+
+
+
+static int get_limits (lua_State *L) {
+  lua_newtable(L);
+  setnameval(L, &quot;BITS_INT&quot;, BITS_INT);
+  setnameval(L, &quot;LFPF&quot;, LFIELDS_PER_FLUSH);
+  setnameval(L, &quot;MAXVARS&quot;, MAXVARS);
+  setnameval(L, &quot;MAXPARAMS&quot;, MAXPARAMS);
+  setnameval(L, &quot;MAXSTACK&quot;, MAXSTACK);
+  setnameval(L, &quot;MAXUPVALUES&quot;, MAXUPVALUES);
+  return 1;
+}
+
+
+static int mem_query (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushintegral(L, memdebug_total);
+    lua_pushintegral(L, memdebug_numblocks);
+    lua_pushintegral(L, memdebug_maxmem);
+    return 3;
+  }
+  else {
+    memdebug_memlimit = luaL_checkint(L, 1);
+    return 0;
+  }
+}
+
+
+static int hash_query (lua_State *L) {
+  if (lua_isnone(L, 2)) {
+    luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, &quot;string expected&quot;);
+    lua_pushintegral(L, tsvalue(func_at(L, 1))-&gt;tsv.hash);
+  }
+  else {
+    TObject *o = func_at(L, 1);
+    Table *t;
+    luaL_checktype(L, 2, LUA_TTABLE);
+    t = hvalue(func_at(L, 2));
+    lua_pushintegral(L, luaH_mainposition(t, o) - t-&gt;node);
+  }
+  return 1;
+}
+
+
+static int stacklevel (lua_State *L) {
+  unsigned long a = 0;
+  lua_pushintegral(L, (int)(L-&gt;top - L-&gt;stack));
+  lua_pushintegral(L, (int)(L-&gt;stack_last - L-&gt;stack));
+  lua_pushintegral(L, (int)(L-&gt;ci - L-&gt;base_ci));
+  lua_pushintegral(L, (int)(L-&gt;end_ci - L-&gt;base_ci));
+  lua_pushintegral(L, (unsigned long)&amp;a);
+  return 5;
+}
+
+
+static int table_query (lua_State *L) {
+  const Table *t;
+  int i = luaL_optint(L, 2, -1);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  t = hvalue(func_at(L, 1));
+  if (i == -1) {
+    lua_pushintegral(L, t-&gt;sizearray);
+    lua_pushintegral(L, sizenode(t));
+    lua_pushintegral(L, t-&gt;firstfree - t-&gt;node);
+  }
+  else if (i &lt; t-&gt;sizearray) {
+    lua_pushintegral(L, i);
+    luaA_pushobject(L, &amp;t-&gt;array[i]);
+    lua_pushnil(L); 
+  }
+  else if ((i -= t-&gt;sizearray) &lt; sizenode(t)) {
+    if (!ttisnil(gval(gnode(t, i))) ||
+        ttisnil(gkey(gnode(t, i))) ||
+        ttisnumber(gkey(gnode(t, i)))) {
+      luaA_pushobject(L, gkey(gnode(t, i)));
+    }
+    else
+      lua_pushstring(L, &quot;&lt;undef&gt;&quot;);
+    luaA_pushobject(L, gval(gnode(t, i)));
+    if (t-&gt;node[i].next)
+      lua_pushintegral(L, t-&gt;node[i].next - t-&gt;node);
+    else
+      lua_pushnil(L);
+  }
+  return 3;
+}
+
+
+static int string_query (lua_State *L) {
+  stringtable *tb = &amp;G(L)-&gt;strt;
+  int s = luaL_optint(L, 2, 0) - 1;
+  if (s==-1) {
+    lua_pushintegral(L ,tb-&gt;nuse);
+    lua_pushintegral(L ,tb-&gt;size);
+    return 2;
+  }
+  else if (s &lt; tb-&gt;size) {
+    GCObject *ts;
+    int n = 0;
+    for (ts = tb-&gt;hash[s]; ts; ts = ts-&gt;gch.next) {
+      setsvalue2s(L-&gt;top, gcotots(ts));
+      incr_top(L);
+      n++;
+    }
+    return n;
+  }
+  return 0;
+}
+
+
+static int tref (lua_State *L) {
+  int level = lua_gettop(L);
+  int lock = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  lua_pushvalue(L, 1);
+  lua_pushintegral(L, lua_ref(L, lock));
+  assert(lua_gettop(L) == level+1);  /* +1 for result */
+  return 1;
+}
+
+static int getref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_getref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level+1);
+  return 1;
+}
+
+static int unref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_unref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level);
+  return 0;
+}
+
+static int metatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (lua_isnone(L, 2)) {
+    if (lua_getmetatable(L, 1) == 0)
+      lua_pushnil(L);
+  }
+  else {
+    lua_settop(L, 2);
+    luaL_checktype(L, 2, LUA_TTABLE);
+    lua_setmetatable(L, 1);
+  }
+  return 1;
+}
+
+
+static int upvalue (lua_State *L) {
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_isnone(L, 3)) {
+    const char *name = lua_getupvalue(L, 1, n);
+    if (name == NULL) return 0;
+    lua_pushstring(L, name);
+    return 2;
+  }
+  else {
+    const char *name = lua_setupvalue(L, 1, n);
+    lua_pushstring(L, name);
+    return 1;
+  }
+}
+
+
+static int newuserdata (lua_State *L) {
+  size_t size = luaL_checkint(L, 1);
+  char *p = cast(char *, lua_newuserdata(L, size));
+  while (size--) *p++ = '\0';
+  return 1;
+}
+
+
+static int pushuserdata (lua_State *L) {
+  lua_pushlightuserdata(L, cast(void *, luaL_checkint(L, 1)));
+  return 1;
+}
+
+
+static int udataval (lua_State *L) {
+  lua_pushintegral(L, cast(int, lua_touserdata(L, 1)));
+  return 1;
+}
+
+
+static int doonnewstack (lua_State *L) {
+  lua_State *L1 = lua_newthread(L);
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  int status = luaL_loadbuffer(L1, s, l, s);
+  if (status == 0)
+    status = lua_pcall(L1, 0, 0, 0);
+  lua_pushintegral(L, status);
+  return 1;
+}
+
+
+static int s2d (lua_State *L) {
+  lua_pushnumber(L, *cast(const double *, luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int d2s (lua_State *L) {
+  double d = luaL_checknumber(L, 1);
+  lua_pushlstring(L, cast(char *, &amp;d), sizeof(d));
+  return 1;
+}
+
+
+static int newstate (lua_State *L) {
+  lua_State *L1 = lua_open();
+  if (L1) {
+    lua_userstateopen(L1);  /* init lock */
+    lua_pushintegral(L, (unsigned long)L1);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+
+static int loadlib (lua_State *L) {
+  static const luaL_reg libs[] = {
+    {&quot;mathlibopen&quot;, luaopen_math},
+    {&quot;strlibopen&quot;, luaopen_string},
+    {&quot;iolibopen&quot;, luaopen_io},
+    {&quot;tablibopen&quot;, luaopen_table},
+    {&quot;dblibopen&quot;, luaopen_debug},
+    {&quot;baselibopen&quot;, luaopen_base},
+    {NULL, NULL}
+  };
+  lua_State *L1 = cast(lua_State *,
+                       cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_pushvalue(L1, LUA_GLOBALSINDEX);
+  luaL_openlib(L1, NULL, libs, 0);
+  return 0;
+}
+
+static int closestate (lua_State *L) {
+  lua_State *L1 = cast(lua_State *, cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_close(L1);
+  lua_unlock(L);  /* close cannot unlock that */
+  return 0;
+}
+
+static int doremote (lua_State *L) {
+  lua_State *L1 = cast(lua_State *,cast(unsigned long,luaL_checknumber(L, 1)));
+  size_t lcode;
+  const char *code = luaL_checklstring(L, 2, &amp;lcode);
+  int status;
+  lua_settop(L1, 0);
+  status = luaL_loadbuffer(L1, code, lcode, code);
+  if (status == 0)
+    status = lua_pcall(L1, 0, LUA_MULTRET, 0);
+  if (status != 0) {
+    lua_pushnil(L);
+    lua_pushintegral(L, status);
+    lua_pushstring(L, lua_tostring(L1, -1));
+    return 3;
+  }
+  else {
+    int i = 0;
+    while (!lua_isnone(L1, ++i))
+      lua_pushstring(L, lua_tostring(L1, i));
+    lua_pop(L1, i-1);
+    return i-1;
+  }
+}
+
+
+static int log2_aux (lua_State *L) {
+  lua_pushintegral(L, luaO_log2(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int int2fb_aux (lua_State *L) {
+  int b = luaO_int2fb(luaL_checkint(L, 1));
+  lua_pushintegral(L, b);
+  lua_pushintegral(L, fb2int(b));
+  return 2;
+}
+
+
+static int test_do (lua_State *L) {
+  const char *p = luaL_checkstring(L, 1);
+  if (*p == '@')
+    lua_dofile(L, p+1);
+  else
+    lua_dostring(L, p);
+  return lua_gettop(L);
+}
+
+
+
+/*
+** {======================================================
+** function to test the API with C. It interprets a kind of assembler
+** language with calls to the API, so the test can be driven by Lua code
+** =======================================================
+*/
+
+static const char *const delimits = &quot; \t\n,;&quot;;
+
+static void skip (const char **pc) {
+  while (**pc != '\0' &amp;&amp; strchr(delimits, **pc)) (*pc)++;
+}
+
+static int getnum_aux (lua_State *L, const char **pc) {
+  int res = 0;
+  int sig = 1;
+  skip(pc);
+  if (**pc == '.') {
+    res = cast(int, lua_tonumber(L, -1));
+    lua_pop(L, 1);
+    (*pc)++;
+    return res;
+  }
+  else if (**pc == '-') {
+    sig = -1;
+    (*pc)++;
+  }
+  while (isdigit(cast(int, **pc))) res = res*10 + (*(*pc)++) - '0';
+  return sig*res;
+}
+  
+static const char *getname_aux (char *buff, const char **pc) {
+  int i = 0;
+  skip(pc);
+  while (**pc != '\0' &amp;&amp; !strchr(delimits, **pc))
+    buff[i++] = *(*pc)++;
+  buff[i] = '\0';
+  return buff;
+}
+
+
+#define EQ(s1)	(strcmp(s1, inst) == 0)
+
+#define getnum	(getnum_aux(L, &amp;pc))
+#define getname	(getname_aux(buff, &amp;pc))
+
+
+static int testC (lua_State *L) {
+  char buff[30];
+  const char *pc = luaL_checkstring(L, 1);
+  for (;;) {
+    const char *inst = getname;
+    if EQ(&quot;&quot;) return 0;
+    else if EQ(&quot;isnumber&quot;) {
+      lua_pushintegral(L, lua_isnumber(L, getnum));
+    }
+    else if EQ(&quot;isstring&quot;) {
+      lua_pushintegral(L, lua_isstring(L, getnum));
+    }
+    else if EQ(&quot;istable&quot;) {
+      lua_pushintegral(L, lua_istable(L, getnum));
+    }
+    else if EQ(&quot;iscfunction&quot;) {
+      lua_pushintegral(L, lua_iscfunction(L, getnum));
+    }
+    else if EQ(&quot;isfunction&quot;) {
+      lua_pushintegral(L, lua_isfunction(L, getnum));
+    }
+    else if EQ(&quot;isuserdata&quot;) {
+      lua_pushintegral(L, lua_isuserdata(L, getnum));
+    }
+    else if EQ(&quot;isudataval&quot;) {
+      lua_pushintegral(L, lua_islightuserdata(L, getnum));
+    }
+    else if EQ(&quot;isnil&quot;) {
+      lua_pushintegral(L, lua_isnil(L, getnum));
+    }
+    else if EQ(&quot;isnull&quot;) {
+      lua_pushintegral(L, lua_isnone(L, getnum));
+    }
+    else if EQ(&quot;tonumber&quot;) {
+      lua_pushnumber(L, lua_tonumber(L, getnum));
+    }
+    else if EQ(&quot;tostring&quot;) {
+      const char *s = lua_tostring(L, getnum);
+      lua_pushstring(L, s);
+    }
+    else if EQ(&quot;strlen&quot;) {
+      lua_pushintegral(L, lua_strlen(L, getnum));
+    }
+    else if EQ(&quot;tocfunction&quot;) {
+      lua_pushcfunction(L, lua_tocfunction(L, getnum));
+    }
+    else if EQ(&quot;return&quot;) {
+      return getnum;
+    }
+    else if EQ(&quot;gettop&quot;) {
+      lua_pushintegral(L, lua_gettop(L));
+    }
+    else if EQ(&quot;settop&quot;) {
+      lua_settop(L, getnum);
+    }
+    else if EQ(&quot;pop&quot;) {
+      lua_pop(L, getnum);
+    }
+    else if EQ(&quot;pushnum&quot;) {
+      lua_pushintegral(L, getnum);
+    }
+    else if EQ(&quot;pushnil&quot;) {
+      lua_pushnil(L);
+    }
+    else if EQ(&quot;pushbool&quot;) {
+      lua_pushboolean(L, getnum);
+    }
+    else if EQ(&quot;tobool&quot;) {
+      lua_pushintegral(L, lua_toboolean(L, getnum));
+    }
+    else if EQ(&quot;pushvalue&quot;) {
+      lua_pushvalue(L, getnum);
+    }
+    else if EQ(&quot;pushcclosure&quot;) {
+      lua_pushcclosure(L, testC, getnum);
+    }
+    else if EQ(&quot;pushupvalues&quot;) {
+      lua_pushupvalues(L);
+    }
+    else if EQ(&quot;remove&quot;) {
+      lua_remove(L, getnum);
+    }
+    else if EQ(&quot;insert&quot;) {
+      lua_insert(L, getnum);
+    }
+    else if EQ(&quot;replace&quot;) {
+      lua_replace(L, getnum);
+    }
+    else if EQ(&quot;gettable&quot;) {
+      lua_gettable(L, getnum);
+    }
+    else if EQ(&quot;settable&quot;) {
+      lua_settable(L, getnum);
+    }
+    else if EQ(&quot;next&quot;) {
+      lua_next(L, -2);
+    }
+    else if EQ(&quot;concat&quot;) {
+      lua_concat(L, getnum);
+    }
+    else if EQ(&quot;lessthan&quot;) {
+      int a = getnum;
+      lua_pushboolean(L, lua_lessthan(L, a, getnum));
+    }
+    else if EQ(&quot;equal&quot;) {
+      int a = getnum;
+      lua_pushboolean(L, lua_equal(L, a, getnum));
+    }
+    else if EQ(&quot;rawcall&quot;) {
+      int narg = getnum;
+      int nres = getnum;
+      lua_call(L, narg, nres);
+    }
+    else if EQ(&quot;call&quot;) {
+      int narg = getnum;
+      int nres = getnum;
+      lua_pcall(L, narg, nres, 0);
+    }
+    else if EQ(&quot;loadstring&quot;) {
+      size_t sl;
+      const char *s = luaL_checklstring(L, getnum, &amp;sl);
+      luaL_loadbuffer(L, s, sl, s);
+    }
+    else if EQ(&quot;loadfile&quot;) {
+      luaL_loadfile(L, luaL_checkstring(L, getnum));
+    }
+    else if EQ(&quot;setmetatable&quot;) {
+      lua_setmetatable(L, getnum);
+    }
+    else if EQ(&quot;getmetatable&quot;) {
+      if (lua_getmetatable(L, getnum) == 0)
+        lua_pushnil(L);
+    }
+    else if EQ(&quot;type&quot;) {
+      lua_pushstring(L, lua_typename(L, lua_type(L, getnum)));
+    }
+    else if EQ(&quot;getn&quot;) {
+      int i = getnum;
+      lua_pushintegral(L, luaL_getn(L, i));
+    }
+    else if EQ(&quot;setn&quot;) {
+      int i = getnum;
+      int n = cast(int, lua_tonumber(L, -1));
+      luaL_setn(L, i, n);
+      lua_pop(L, 1);
+    }
+    else luaL_error(L, &quot;unknown instruction %s&quot;, buff);
+  }
+  return 0;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** tests for yield inside hooks
+** =======================================================
+*/
+
+static void yieldf (lua_State *L, lua_Debug *ar) {
+  lua_yield(L, 0);
+}
+
+static int setyhook (lua_State *L) {
+  if (lua_isnoneornil(L, 1))
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  else {
+    const char *smask = luaL_checkstring(L, 1);
+    int count = luaL_optint(L, 2, 0);
+    int mask = 0;
+    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+    if (count &gt; 0) mask |= LUA_MASKCOUNT;
+    lua_sethook(L, yieldf, mask, count);
+  }
+  return 0;
+}
+
+
+static int coresume (lua_State *L) {
+  int status;
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
+  status = lua_resume(co, 0);
+  if (status != 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+}
+
+/* }====================================================== */
+
+
+
+static const struct luaL_reg tests_funcs[] = {
+  {&quot;hash&quot;, hash_query},
+  {&quot;limits&quot;, get_limits},
+  {&quot;listcode&quot;, listcode},
+  {&quot;listk&quot;, listk},
+  {&quot;listlocals&quot;, listlocals},
+  {&quot;loadlib&quot;, loadlib},
+  {&quot;stacklevel&quot;, stacklevel},
+  {&quot;querystr&quot;, string_query},
+  {&quot;querytab&quot;, table_query},
+  {&quot;doit&quot;, test_do},
+  {&quot;testC&quot;, testC},
+  {&quot;ref&quot;, tref},
+  {&quot;getref&quot;, getref},
+  {&quot;unref&quot;, unref},
+  {&quot;d2s&quot;, d2s},
+  {&quot;s2d&quot;, s2d},
+  {&quot;metatable&quot;, metatable},
+  {&quot;upvalue&quot;, upvalue},
+  {&quot;newuserdata&quot;, newuserdata},
+  {&quot;pushuserdata&quot;, pushuserdata},
+  {&quot;udataval&quot;, udataval},
+  {&quot;doonnewstack&quot;, doonnewstack},
+  {&quot;newstate&quot;, newstate},
+  {&quot;closestate&quot;, closestate},
+  {&quot;doremote&quot;, doremote},
+  {&quot;log2&quot;, log2_aux},
+  {&quot;int2fb&quot;, int2fb_aux},
+  {&quot;totalmem&quot;, mem_query},
+  {&quot;resume&quot;, coresume},
+  {&quot;setyhook&quot;, setyhook},
+  {NULL, NULL}
+};
+
+
+static void fim (void) {
+  if (!islocked)
+    lua_close(lua_state);
+  lua_assert(memdebug_numblocks == 0);
+  lua_assert(memdebug_total == 0);
+}
+
+
+static int l_panic (lua_State *L) {
+  UNUSED(L);
+  fprintf(stderr, &quot;unable to recover; exiting\n&quot;);
+  return 0;
+}
+
+
+int luaB_opentests (lua_State *L) {
+  lua_atpanic(L, l_panic);
+  lua_userstateopen(L);  /* init lock */
+  lua_state = L;  /* keep first state to be opened */
+  luaL_openlib(L, &quot;T&quot;, tests_funcs, 0);
+  atexit(fim);
+  return 0;
+}
+
+
+#undef main
+int main (int argc, char *argv[]) {
+  char *limit = getenv(&quot;MEMLIMIT&quot;);
+  if (limit)
+    memdebug_memlimit = strtoul(limit, NULL, 10);
+  l_main(argc, argv);
+  return 0;
+}
+
+#endif

Added: trunk/Util/deditor/lua/ltm.c
===================================================================
--- trunk/Util/deditor/lua/ltm.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltm.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,70 @@
+/*
+** $Id: ltm.c,v 1.106 2003/04/03 13:35:34 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define ltm_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+
+
+
+const char *const luaT_typenames[] = {
+  &quot;nil&quot;, &quot;boolean&quot;, &quot;userdata&quot;, &quot;number&quot;,
+  &quot;string&quot;, &quot;table&quot;, &quot;function&quot;, &quot;userdata&quot;, &quot;thread&quot;
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    &quot;__index&quot;, &quot;__newindex&quot;,
+    &quot;__gc&quot;, &quot;__mode&quot;, &quot;__eq&quot;,
+    &quot;__add&quot;, &quot;__sub&quot;, &quot;__mul&quot;, &quot;__div&quot;,
+    &quot;__pow&quot;, &quot;__unm&quot;, &quot;__lt&quot;, &quot;__le&quot;,
+    &quot;__concat&quot;, &quot;__call&quot;
+  };
+  int i;
+  for (i=0; i&lt;TM_N; i++) {
+    G(L)-&gt;tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)-&gt;tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro &quot;fasttm&quot;: optimized for absence of
+** tag methods
+*/
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TObject *tm = luaH_getstr(events, ename);
+  lua_assert(event &lt;= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events-&gt;flags |= cast(lu_byte, 1u&lt;&lt;event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event) {
+  TString *ename = G(L)-&gt;tmname[event];
+  switch (ttype(o)) {
+    case LUA_TTABLE:
+      return luaH_getstr(hvalue(o)-&gt;metatable, ename);
+    case LUA_TUSERDATA:
+      return luaH_getstr(uvalue(o)-&gt;uv.metatable, ename);
+    default:
+      return &amp;luaO_nilobject;
+  }
+}
+

Added: trunk/Util/deditor/lua/ltm.h
===================================================================
--- trunk/Util/deditor/lua/ltm.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/ltm.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,51 @@
+/*
+** $Id: ltm.h,v 1.41 2002/11/14 11:51:50 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include &quot;lobject.h&quot;
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep &quot;ORDER TM&quot;
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) \
+  (((et)-&gt;flags &amp; (1u&lt;&lt;(e))) ? NULL : luaT_gettm(et, e, (g)-&gt;tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename);
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event);
+void luaT_init (lua_State *L);
+
+extern const char *const luaT_typenames[];
+
+#endif

Added: trunk/Util/deditor/lua/lua.h
===================================================================
--- trunk/Util/deditor/lua/lua.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lua.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,391 @@
+/*
+** $Id: lua.h,v 1.175 2003/03/18 12:31:39 roberto Exp $
+** Lua - An Extensible Extension Language
+** Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil
+** <A HREF="http://www.lua.org">http://www.lua.org</A>	mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">info at lua.org</A>
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include &lt;stdarg.h&gt;
+#include &lt;stddef.h&gt;
+
+
+#define LUA_VERSION	&quot;Lua 5.0&quot;
+#define LUA_COPYRIGHT	&quot;Copyright (C) 1994-2003 Tecgraf, PUC-Rio&quot;
+#define LUA_AUTHORS 	&quot;R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes&quot;
+
+
+
+/* option for multiple returns in `lua_pcall' and `lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	(-10000)
+#define LUA_GLOBALSINDEX	(-10001)
+#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))
+
+
+/* error codes for `lua_load' and `lua_pcall' */
+#define LUA_ERRRUN	1
+#define LUA_ERRFILE	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRERR	5
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Chunkreader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Chunkwriter) (lua_State *L, const void* p,
+                                size_t sz, void* ud);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE	(-1)
+
+#define LUA_TNIL	0
+#define LUA_TBOOLEAN	1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER	3
+#define LUA_TSTRING	4
+#define LUA_TTABLE	5
+#define LUA_TFUNCTION	6
+#define LUA_TUSERDATA	7
+#define LUA_TTHREAD	8
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/*
+** generic extra include file
+*/
+#ifdef LUA_USER_H
+#include LUA_USER_H
+#endif
+
+
+/* type of numbers in Lua */
+#ifndef LUA_NUMBER
+typedef double lua_Number;
+#else
+typedef LUA_NUMBER lua_Number;
+#endif
+
+
+/* mark for all API functions */
+#ifndef LUA_API
+#define LUA_API		extern
+#endif
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *lua_open (void);
+LUA_API void       lua_close (lua_State *L);
+LUA_API lua_State *lua_newthread (lua_State *L);
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   lua_gettop (lua_State *L);
+LUA_API void  lua_settop (lua_State *L, int idx);
+LUA_API void  lua_pushvalue (lua_State *L, int idx);
+LUA_API void  lua_remove (lua_State *L, int idx);
+LUA_API void  lua_insert (lua_State *L, int idx);
+LUA_API void  lua_replace (lua_State *L, int idx);
+LUA_API int   lua_checkstack (lua_State *L, int sz);
+
+LUA_API void  lua_xmove (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -&gt; C)
+*/
+
+LUA_API int             lua_isnumber (lua_State *L, int idx);
+LUA_API int             lua_isstring (lua_State *L, int idx);
+LUA_API int             lua_iscfunction (lua_State *L, int idx);
+LUA_API int             lua_isuserdata (lua_State *L, int idx);
+LUA_API int             lua_type (lua_State *L, int idx);
+LUA_API const char     *lua_typename (lua_State *L, int tp);
+
+LUA_API int            lua_equal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_rawequal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_lessthan (lua_State *L, int idx1, int idx2);
+
+LUA_API lua_Number      lua_tonumber (lua_State *L, int idx);
+LUA_API int             lua_toboolean (lua_State *L, int idx);
+LUA_API const char     *lua_tostring (lua_State *L, int idx);
+LUA_API size_t          lua_strlen (lua_State *L, int idx);
+LUA_API lua_CFunction   lua_tocfunction (lua_State *L, int idx);
+LUA_API void	       *lua_touserdata (lua_State *L, int idx);
+LUA_API lua_State      *lua_tothread (lua_State *L, int idx);
+LUA_API const void     *lua_topointer (lua_State *L, int idx);
+
+
+/*
+** push functions (C -&gt; stack)
+*/
+LUA_API void  lua_pushnil (lua_State *L);
+LUA_API void  lua_pushnumber (lua_State *L, lua_Number n);
+LUA_API void  lua_pushlstring (lua_State *L, const char *s, size_t l);
+LUA_API void  lua_pushstring (lua_State *L, const char *s);
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                                    va_list argp);
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
+LUA_API void  lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  lua_pushboolean (lua_State *L, int b);
+LUA_API void  lua_pushlightuserdata (lua_State *L, void *p);
+
+
+/*
+** get functions (Lua -&gt; stack)
+*/
+LUA_API void  lua_gettable (lua_State *L, int idx);
+LUA_API void  lua_rawget (lua_State *L, int idx);
+LUA_API void  lua_rawgeti (lua_State *L, int idx, int n);
+LUA_API void  lua_newtable (lua_State *L);
+LUA_API void *lua_newuserdata (lua_State *L, size_t sz);
+LUA_API int   lua_getmetatable (lua_State *L, int objindex);
+LUA_API void  lua_getfenv (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -&gt; Lua)
+*/
+LUA_API void  lua_settable (lua_State *L, int idx);
+LUA_API void  lua_rawset (lua_State *L, int idx);
+LUA_API void  lua_rawseti (lua_State *L, int idx, int n);
+LUA_API int   lua_setmetatable (lua_State *L, int objindex);
+LUA_API int   lua_setfenv (lua_State *L, int idx);
+
+
+/*
+** `load' and `call' functions (load and run Lua code)
+*/
+LUA_API void  lua_call (lua_State *L, int nargs, int nresults);
+LUA_API int   lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
+LUA_API int   lua_load (lua_State *L, lua_Chunkreader reader, void *dt,
+                        const char *chunkname);
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  lua_yield (lua_State *L, int nresults);
+LUA_API int  lua_resume (lua_State *L, int narg);
+
+/*
+** garbage-collection functions
+*/
+LUA_API int   lua_getgcthreshold (lua_State *L);
+LUA_API int   lua_getgccount (lua_State *L);
+LUA_API void  lua_setgcthreshold (lua_State *L, int newthreshold);
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API const char *lua_version (void);
+
+LUA_API int   lua_error (lua_State *L);
+
+LUA_API int   lua_next (lua_State *L, int idx);
+
+LUA_API void  lua_concat (lua_State *L, int n);
+
+
+
+/* 
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_boxpointer(L,u) \
+	(*(void **)(lua_newuserdata(L, sizeof(void *))) = (u))
+
+#define lua_unboxpointer(L,i)	(*(void **)(lua_touserdata(L, i)))
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_register(L,n,f) \
+	(lua_pushstring(L, n), \
+	 lua_pushcfunction(L, f), \
+	 lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, f, 0)
+
+#define lua_isfunction(L,n)	(lua_type(L,n) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L,n) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L,n) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L,n) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L,n) == LUA_TBOOLEAN)
+#define lua_isnone(L,n)		(lua_type(L,n) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L,n) &lt;= 0)
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, &quot;&quot; s, (sizeof(s)/sizeof(char))-1)
+
+
+
+/*
+** compatibility macros and functions
+*/
+
+
+LUA_API int lua_pushupvalues (lua_State *L);
+
+#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)
+#define lua_setglobal(L,s)	\
+   (lua_pushstring(L, s), lua_insert(L, -2), lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_getglobal(L,s)	\
+		(lua_pushstring(L, s), lua_gettable(L, LUA_GLOBALSINDEX))
+
+
+/* compatibility with ref system */
+
+/* pre-defined references */
+#define LUA_NOREF	(-2)
+#define LUA_REFNIL	(-1)
+
+#define lua_ref(L,lock)	((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
+      (lua_pushstring(L, &quot;unlocked references are obsolete&quot;), lua_error(L), 0))
+
+#define lua_unref(L,ref)	luaL_unref(L, LUA_REGISTRYINDEX, (ref))
+
+#define lua_getref(L,ref)	lua_rawgeti(L, LUA_REGISTRYINDEX, ref)
+
+
+
+/*
+** {======================================================================
+** useful definitions for Lua kernel and libraries
+** =======================================================================
+*/
+
+/* formats for Lua numbers */
+#ifndef LUA_NUMBER_SCAN
+#define LUA_NUMBER_SCAN		&quot;%lf&quot;
+#endif
+
+#ifndef LUA_NUMBER_FMT
+#define LUA_NUMBER_FMT		&quot;%.14g&quot;
+#endif
+
+/* }====================================================================== */
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILRET 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 &lt;&lt; LUA_HOOKCALL)
+#define LUA_MASKRET	(1 &lt;&lt; LUA_HOOKRET)
+#define LUA_MASKLINE	(1 &lt;&lt; LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 &lt;&lt; LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);
+
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook lua_gethook (lua_State *L);
+LUA_API int lua_gethookmask (lua_State *L);
+LUA_API int lua_gethookcount (lua_State *L);
+
+
+#define LUA_IDSIZE	60
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) `global', `local', `field', `method' */
+  const char *what;	/* (S) `Lua', `C', `main', `tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int nups;		/* (u) number of upvalues */
+  int linedefined;	/* (S) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  int i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2003 Tecgraf, PUC-Rio.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* &quot;Software&quot;), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif

Added: trunk/Util/deditor/lua/lualib.h
===================================================================
--- trunk/Util/deditor/lua/lualib.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lualib.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,56 @@
+/*
+** $Id: lualib.h,v 1.28 2003/03/18 12:24:26 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include &quot;lua.h&quot;
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+#define LUA_COLIBNAME	&quot;coroutine&quot;
+LUALIB_API int luaopen_base (lua_State *L);
+
+#define LUA_TABLIBNAME	&quot;table&quot;
+LUALIB_API int luaopen_table (lua_State *L);
+
+#define LUA_IOLIBNAME	&quot;io&quot;
+#define LUA_OSLIBNAME	&quot;os&quot;
+LUALIB_API int luaopen_io (lua_State *L);
+
+#define LUA_STRLIBNAME	&quot;string&quot;
+LUALIB_API int luaopen_string (lua_State *L);
+
+#define LUA_MATHLIBNAME	&quot;math&quot;
+LUALIB_API int luaopen_math (lua_State *L);
+
+#define LUA_DBLIBNAME	&quot;debug&quot;
+LUALIB_API int luaopen_debug (lua_State *L);
+
+
+LUALIB_API int luaopen_loadlib (lua_State *L);
+
+
+/* to help testing the libraries */
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+/* compatibility code */
+#define lua_baselibopen	luaopen_base
+#define lua_tablibopen	luaopen_table
+#define lua_iolibopen	luaopen_io
+#define lua_strlibopen	luaopen_string
+#define lua_mathlibopen	luaopen_math
+#define lua_dblibopen	luaopen_debug
+
+#endif

Added: trunk/Util/deditor/lua/lundump.c
===================================================================
--- trunk/Util/deditor/lua/lundump.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lundump.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,286 @@
+/*
+** $Id: lundump.c,v 1.49 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#define lundump_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;lundump.h&quot;
+#include &quot;lzio.h&quot;
+
+#define	LoadByte	(lu_byte) ezgetc
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ int swap;
+ const char* name;
+} LoadState;
+
+static void unexpectedEOZ (LoadState* S)
+{
+ luaG_runerror(S-&gt;L,&quot;unexpected end of file in %s&quot;,S-&gt;name);
+}
+
+static int ezgetc (LoadState* S)
+{
+ int c=zgetc(S-&gt;Z);
+ if (c==EOZ) unexpectedEOZ(S);
+ return c;
+}
+
+static void ezread (LoadState* S, void* b, int n)
+{
+ int r=luaZ_read(S-&gt;Z,b,n);
+ if (r!=0) unexpectedEOZ(S);
+}
+
+static void LoadBlock (LoadState* S, void* b, size_t size)
+{
+ if (S-&gt;swap)
+ {
+  char* p=(char*) b+size-1;
+  int n=size;
+  while (n--) *p--=(char)ezgetc(S);
+ }
+ else
+  ezread(S,b,size);
+}
+
+static void LoadVector (LoadState* S, void* b, int m, size_t size)
+{
+ if (S-&gt;swap)
+ {
+  char* q=(char*) b;
+  while (m--)
+  {
+   char* p=q+size-1;
+   int n=size;
+   while (n--) *p--=(char)ezgetc(S);
+   q+=size;
+  }
+ }
+ else
+  ezread(S,b,m*size);
+}
+
+static int LoadInt (LoadState* S)
+{
+ int x;
+ LoadBlock(S,&amp;x,sizeof(x));
+ if (x&lt;0) luaG_runerror(S-&gt;L,&quot;bad integer in %s&quot;,S-&gt;name);
+ return x;
+}
+
+static size_t LoadSize (LoadState* S)
+{
+ size_t x;
+ LoadBlock(S,&amp;x,sizeof(x));
+ return x;
+}
+
+static lua_Number LoadNumber (LoadState* S)
+{
+ lua_Number x;
+ LoadBlock(S,&amp;x,sizeof(x));
+ return x;
+}
+
+static TString* LoadString (LoadState* S)
+{
+ size_t size=LoadSize(S);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S-&gt;L,S-&gt;b,size);
+  ezread(S,s,size);
+  return luaS_newlstr(S-&gt;L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f-&gt;code=luaM_newvector(S-&gt;L,size,Instruction);
+ f-&gt;sizecode=size;
+ LoadVector(S,f-&gt;code,size,sizeof(*f-&gt;code));
+}
+
+static void LoadLocals (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f-&gt;locvars=luaM_newvector(S-&gt;L,n,LocVar);
+ f-&gt;sizelocvars=n;
+ for (i=0; i&lt;n; i++)
+ {
+  f-&gt;locvars[i].varname=LoadString(S);
+  f-&gt;locvars[i].startpc=LoadInt(S);
+  f-&gt;locvars[i].endpc=LoadInt(S);
+ }
+}
+
+static void LoadLines (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f-&gt;lineinfo=luaM_newvector(S-&gt;L,size,int);
+ f-&gt;sizelineinfo=size;
+ LoadVector(S,f-&gt;lineinfo,size,sizeof(*f-&gt;lineinfo));
+}
+
+static void LoadUpvalues (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ if (n!=0 &amp;&amp; n!=f-&gt;nups) 
+  luaG_runerror(S-&gt;L,&quot;bad nupvalues in %s: read %d; expected %d&quot;,
+		S-&gt;name,n,f-&gt;nups);
+ f-&gt;upvalues=luaM_newvector(S-&gt;L,n,TString*);
+ f-&gt;sizeupvalues=n;
+ for (i=0; i&lt;n; i++) f-&gt;upvalues[i]=LoadString(S);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p);
+
+static void LoadConstants (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f-&gt;k=luaM_newvector(S-&gt;L,n,TObject);
+ f-&gt;sizek=n;
+ for (i=0; i&lt;n; i++)
+ {
+  TObject* o=&amp;f-&gt;k[i];
+  int t=LoadByte(S);
+  switch (t)
+  {
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(o,LoadString(S));
+	break;
+   case LUA_TNIL:
+   	setnilvalue(o);
+	break;
+   default:
+	luaG_runerror(S-&gt;L,&quot;bad constant type (%d) in %s&quot;,t,S-&gt;name);
+	break;
+  }
+ }
+ n=LoadInt(S);
+ f-&gt;p=luaM_newvector(S-&gt;L,n,Proto*);
+ f-&gt;sizep=n;
+ for (i=0; i&lt;n; i++) f-&gt;p[i]=LoadFunction(S,f-&gt;source);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p)
+{
+ Proto* f=luaF_newproto(S-&gt;L);
+ f-&gt;source=LoadString(S); if (f-&gt;source==NULL) f-&gt;source=p;
+ f-&gt;lineDefined=LoadInt(S);
+ f-&gt;nups=LoadByte(S);
+ f-&gt;numparams=LoadByte(S);
+ f-&gt;is_vararg=LoadByte(S);
+ f-&gt;maxstacksize=LoadByte(S);
+ LoadLines(S,f);
+ LoadLocals(S,f);
+ LoadUpvalues(S,f);
+ LoadConstants(S,f);
+ LoadCode(S,f);
+#ifndef TRUST_BINARIES
+ if (!luaG_checkcode(f)) luaG_runerror(S-&gt;L,&quot;bad code in %s&quot;,S-&gt;name);
+#endif
+ return f;
+}
+
+static void LoadSignature (LoadState* S)
+{
+ const char* s=LUA_SIGNATURE;
+ while (*s!=0 &amp;&amp; ezgetc(S)==*s)
+  ++s;
+ if (*s!=0) luaG_runerror(S-&gt;L,&quot;bad signature in %s&quot;,S-&gt;name);
+}
+
+static void TestSize (LoadState* S, int s, const char* what)
+{
+ int r=LoadByte(S);
+ if (r!=s)
+  luaG_runerror(S-&gt;L,&quot;virtual machine mismatch in %s: &quot;
+	&quot;size of %s is %d but read %d&quot;,S-&gt;name,what,s,r);
+}
+
+#define TESTSIZE(s,w)	TestSize(S,s,w)
+#define V(v)		v/16,v%16
+
+static void LoadHeader (LoadState* S)
+{
+ int version;
+ lua_Number x,tx=TEST_NUMBER;
+ LoadSignature(S);
+ version=LoadByte(S);
+ if (version&gt;VERSION)
+  luaG_runerror(S-&gt;L,&quot;%s too new: &quot;
+	&quot;read version %d.%d; expected at most %d.%d&quot;,
+	S-&gt;name,V(version),V(VERSION));
+ if (version&lt;VERSION0)				/* check last major change */
+  luaG_runerror(S-&gt;L,&quot;%s too old: &quot;
+	&quot;read version %d.%d; expected at least %d.%d&quot;,
+	S-&gt;name,V(version),V(VERSION0));
+ S-&gt;swap=(luaU_endianness()!=LoadByte(S));	/* need to swap bytes? */
+ TESTSIZE(sizeof(int),&quot;int&quot;);
+ TESTSIZE(sizeof(size_t), &quot;size_t&quot;);
+ TESTSIZE(sizeof(Instruction), &quot;Instruction&quot;);
+ TESTSIZE(SIZE_OP, &quot;OP&quot;);
+ TESTSIZE(SIZE_A, &quot;A&quot;);
+ TESTSIZE(SIZE_B, &quot;B&quot;);
+ TESTSIZE(SIZE_C, &quot;C&quot;);
+ TESTSIZE(sizeof(lua_Number), &quot;number&quot;);
+ x=LoadNumber(S);
+ if ((long)x!=(long)tx)		/* disregard errors in last bits of fraction */
+  luaG_runerror(S-&gt;L,&quot;unknown number format in %s&quot;,S-&gt;name);
+}
+
+static Proto* LoadChunk (LoadState* S)
+{
+ LoadHeader(S);
+ return LoadFunction(S,NULL);
+}
+
+/*
+** load precompiled chunk
+*/
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff)
+{
+ LoadState S;
+ const char* s=zname(Z);
+ if (*s=='@' || *s=='=')
+  S.name=s+1;
+ else if (*s==LUA_SIGNATURE[0])
+  S.name=&quot;binary string&quot;;
+ else
+  S.name=s;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ return LoadChunk(&amp;S);
+}
+
+/*
+** find byte order
+*/
+int luaU_endianness (void)
+{
+ int x=1;
+ return *(char*)&x;
+}

Added: trunk/Util/deditor/lua/lundump.h
===================================================================
--- trunk/Util/deditor/lua/lundump.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lundump.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,34 @@
+/*
+** $Id: lundump.h,v 1.30 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include &quot;lobject.h&quot;
+#include &quot;lzio.h&quot;
+
+/* load one chunk; from lundump.c */
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff);
+
+/* find byte order; from lundump.c */
+int luaU_endianness (void);
+
+/* dump one chunk; from ldump.c */
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data);
+
+/* print one chunk; from print.c */
+void luaU_print (const Proto* Main);
+
+/* definitions for headers of binary files */
+#define	LUA_SIGNATURE	&quot;\033Lua&quot;	/* binary files start with &quot;&lt;esc&gt;Lua&quot; */
+#define	VERSION		0x50		/* last format change was in 5.0 */
+#define	VERSION0	0x50		/* last major  change was in 5.0 */
+
+/* a multiple of PI for testing native format */
+/* multiplying by 1E7 gives non-trivial integer values */
+#define	TEST_NUMBER	((lua_Number)3.14159265358979323846E7)
+
+#endif

Added: trunk/Util/deditor/lua/lvm.c
===================================================================
--- trunk/Util/deditor/lua/lvm.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lvm.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,780 @@
+/*
+** $Id: lvm.c,v 1.284 2003/04/03 13:35:34 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdarg.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+/* needed only when `lua_number2str' uses `sprintf' */
+#include &lt;stdio.h&gt;
+
+#define lvm_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lvm.h&quot;
+
+
+
+/* function to convert a lua_Number to a string */
+#ifndef lua_number2str
+#define lua_number2str(s,n)     sprintf((s), LUA_NUMBER_FMT, (n))
+#endif
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TObject *luaV_tonumber (const TObject *obj, TObject *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) &amp;&amp; luaO_str2d(svalue(obj), &amp;num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[32];  /* 16 digits, sign, point and \0  (+ some extra...) */
+    lua_number2str(s, nvalue(obj));
+    setsvalue2s(obj, luaS_new(L, s));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  lu_byte mask = L-&gt;hookmask;
+  if (mask &gt; LUA_MASKLINE) {  /* instruction-hook set? */
+    if (L-&gt;hookcount == 0) {
+      resethookcount(L);
+      luaD_callhook(L, LUA_HOOKCOUNT, -1);
+      return;
+    }
+  }
+  if (mask &amp; LUA_MASKLINE) {
+    CallInfo *ci = L-&gt;ci;
+    Proto *p = ci_func(ci)-&gt;l.p;
+    int newline = getline(p, pcRel(*ci-&gt;u.l.pc, p));
+    if (!L-&gt;hookinit) {
+      luaG_inithooks(L);
+      return;
+    }
+    lua_assert(ci-&gt;state &amp; CI_HASFRAME);
+    if (pcRel(*ci-&gt;u.l.pc, p) == 0)  /* tracing may be starting now? */
+      ci-&gt;u.l.savedpc = *ci-&gt;u.l.pc;  /* initialize `savedpc' */
+    /* calls linehook when enters a new line or jumps back (loop) */
+    if (*ci-&gt;u.l.pc &lt;= ci-&gt;u.l.savedpc ||
+        newline != getline(p, pcRel(ci-&gt;u.l.savedpc, p))) {
+      luaD_callhook(L, LUA_HOOKLINE, newline);
+      ci = L-&gt;ci;  /* previous call may reallocate `ci' */
+    }
+    ci-&gt;u.l.savedpc = *ci-&gt;u.l.pc;
+  }
+}
+
+
+static void callTMres (lua_State *L, const TObject *f,
+                       const TObject *p1, const TObject *p2) {
+  setobj2s(L-&gt;top, f);  /* push function */
+  setobj2s(L-&gt;top+1, p1);  /* 1st argument */
+  setobj2s(L-&gt;top+2, p2);  /* 2nd argument */
+  luaD_checkstack(L, 3);  /* cannot check before (could invalidate p1, p2) */
+  L-&gt;top += 3;
+  luaD_call(L, L-&gt;top - 3, 1);
+  L-&gt;top--;  /* result will be in L-&gt;top */
+}
+
+
+
+static void callTM (lua_State *L, const TObject *f,
+                    const TObject *p1, const TObject *p2, const TObject *p3) {
+  setobj2s(L-&gt;top, f);  /* push function */
+  setobj2s(L-&gt;top+1, p1);  /* 1st argument */
+  setobj2s(L-&gt;top+2, p2);  /* 2nd argument */
+  setobj2s(L-&gt;top+3, p3);  /* 3th argument */
+  luaD_checkstack(L, 4);  /* cannot check before (could invalidate p1...p3) */
+  L-&gt;top += 4;
+  luaD_call(L, L-&gt;top - 4, 0);
+}
+
+
+static const TObject *luaV_index (lua_State *L, const TObject *t,
+                                  TObject *key, int loop) {
+  const TObject *tm = fasttm(L, hvalue(t)-&gt;metatable, TM_INDEX);
+  if (tm == NULL) return &amp;luaO_nilobject;  /* no TM */
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L-&gt;top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+static const TObject *luaV_getnotable (lua_State *L, const TObject *t,
+                                       TObject *key, int loop) {
+  const TObject *tm = luaT_gettmbyobj(L, t, TM_INDEX);
+  if (ttisnil(tm))
+    luaG_typeerror(L, t, &quot;index&quot;);
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L-&gt;top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+
+/*
+** Function to index a table.
+** Receives the table at `t' and the key at `key'.
+** leaves the result at `res'.
+*/
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop) {
+  if (loop &gt; MAXTAGLOOP)
+    luaG_runerror(L, &quot;loop in gettable&quot;);
+  if (ttistable(t)) {  /* `t' is a table? */
+    Table *h = hvalue(t);
+    const TObject *v = luaH_get(h, key);  /* do a primitive get */
+    if (!ttisnil(v)) return v;
+    else return luaV_index(L, t, key, loop+1);
+  }
+  else return luaV_getnotable(L, t, key, loop+1);
+}
+
+
+/*
+** Receives table at `t', key at `key' and value at `val'.
+*/
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val) {
+  const TObject *tm;
+  int loop = 0;
+  do {
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TObject *oldval = luaH_set(L, h, key); /* do a primitive set */
+      if (!ttisnil(oldval) ||  /* result is no nil? */
+          (tm = fasttm(L, h-&gt;metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */
+        setobj2t(oldval, val);  /* write barrier */
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+      luaG_typeerror(L, t, &quot;index&quot;);
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val);
+      return;
+    }
+    t = tm;  /* else repeat with `tm' */ 
+  } while (++loop &lt;= MAXTAGLOOP);
+  luaG_runerror(L, &quot;loop in settable&quot;);
+}
+
+
+static int call_binTM (lua_State *L, const TObject *p1, const TObject *p2,
+                       StkId res, TMS event) {
+  ptrdiff_t result = savestack(L, res);
+  const TObject *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (!ttisfunction(tm)) return 0;
+  callTMres(L, tm, p1, p2);
+  res = restorestack(L, result);  /* previous call may change stack */
+  setobjs2s(res, L-&gt;top);
+  return 1;
+}
+
+
+static const TObject *get_compTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TObject *tm1 = fasttm(L, mt1, event);
+  const TObject *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables =&gt; same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TObject *p1, const TObject *p2,
+                         TMS event) {
+  const TObject *tm1 = luaT_gettmbyobj(L, p1, event);
+  const TObject *tm2;
+  if (ttisnil(tm1)) return -1;  /* no metamethod? */
+  tm2 = luaT_gettmbyobj(L, p2, event);
+  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
+    return -1;
+  callTMres(L, tm1, p1, p2);
+  return !l_isfalse(L-&gt;top);
+}
+
+
+static int luaV_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls-&gt;tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs-&gt;tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) &lt; nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) &lt; 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
+    return res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+static int luaV_lessequal (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) &lt;= nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) &lt;= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
+    return !res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2) {
+  const TObject *tm;
+  lua_assert(ttype(t1) == ttype(t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      tm = get_compTM(L, uvalue(t1)-&gt;uv.metatable, uvalue(t2)-&gt;uv.metatable,
+                         TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      tm = get_compTM(L, hvalue(t1)-&gt;metatable, hvalue(t2)-&gt;metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default: return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTMres(L, tm, t1, t2);  /* call TM */
+  return !l_isfalse(L-&gt;top);
+}
+
+
+void luaV_concat (lua_State *L, int total, int last) {
+  do {
+    StkId top = L-&gt;base + last + 1;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!tostring(L, top-2) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    } else if (tsvalue(top-1)-&gt;tsv.len &gt; 0) {  /* if len=0, do nothing */
+      /* at least two string values; get as many as possible */
+      lu_mem tl = cast(lu_mem, tsvalue(top-1)-&gt;tsv.len) +
+                  cast(lu_mem, tsvalue(top-2)-&gt;tsv.len);
+      char *buffer;
+      int i;
+      while (n &lt; total &amp;&amp; tostring(L, top-n-1)) {  /* collect total length */
+        tl += tsvalue(top-n-1)-&gt;tsv.len;
+        n++;
+      }
+      if (tl &gt; MAX_SIZET) luaG_runerror(L, &quot;string size overflow&quot;);
+      buffer = luaZ_openspace(L, &amp;G(L)-&gt;buff, tl);
+      tl = 0;
+      for (i=n; i&gt;0; i--) {  /* concat all strings */
+        size_t l = tsvalue(top-i)-&gt;tsv.len;
+        memcpy(buffer+tl, svalue(top-i), l);
+        tl += l;
+      }
+      setsvalue2s(top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got `n' strings to create 1 new */
+    last -= n-1;
+  } while (total &gt; 1);  /* repeat until only 1 result left */
+}
+
+
+static void Arith (lua_State *L, StkId ra,
+                   const TObject *rb, const TObject *rc, TMS op) {
+  TObject tempb, tempc;
+  const TObject *b, *c;
+  if ((b = luaV_tonumber(rb, &amp;tempb)) != NULL &amp;&amp;
+      (c = luaV_tonumber(rc, &amp;tempc)) != NULL) {
+    switch (op) {
+      case TM_ADD: setnvalue(ra, nvalue(b) + nvalue(c)); break;
+      case TM_SUB: setnvalue(ra, nvalue(b) - nvalue(c)); break;
+      case TM_MUL: setnvalue(ra, nvalue(b) * nvalue(c)); break;
+      case TM_DIV: setnvalue(ra, nvalue(b) / nvalue(c)); break;
+      case TM_POW: {
+        const TObject *f = luaH_getstr(hvalue(gt(L)), G(L)-&gt;tmname[TM_POW]);
+        ptrdiff_t res = savestack(L, ra);
+        if (!ttisfunction(f))
+          luaG_runerror(L, &quot;`__pow' (`^' operator) is not a function&quot;);
+        callTMres(L, f, b, c);
+        ra = restorestack(L, res);  /* previous call may change stack */
+        setobjs2s(ra, L-&gt;top);
+        break;
+      }
+      default: lua_assert(0); break;
+    }
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#define runtime_check(L, c)	{ if (!(c)) return 0; }
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define XRA(i)	(L-&gt;base+GETARG_A(i))
+#define RB(i)	(base+GETARG_B(i))
+#define RKB(i)	((GETARG_B(i) &lt; MAXSTACK) ? RB(i) : k+GETARG_B(i)-MAXSTACK)
+#define RC(i)	(base+GETARG_C(i))
+#define RKC(i)	((GETARG_C(i) &lt; MAXSTACK) ? RC(i) : k+GETARG_C(i)-MAXSTACK)
+#define KBx(i)	(k+GETARG_Bx(i))
+
+
+#define dojump(pc, i)	((pc) += (i))
+
+
+StkId luaV_execute (lua_State *L) {
+  LClosure *cl;
+  TObject *k;
+  const Instruction *pc;
+ callentry:  /* entry point when calling new functions */
+  L-&gt;ci-&gt;u.l.pc = &pc;
+  if (L-&gt;hookmask &amp; LUA_MASKCALL)
+    luaD_callhook(L, LUA_HOOKCALL, -1);
+ retentry:  /* entry point when returning to old functions */
+  lua_assert(L-&gt;ci-&gt;state == CI_SAVEDPC ||
+             L-&gt;ci-&gt;state == (CI_SAVEDPC | CI_CALLING));
+  L-&gt;ci-&gt;state = CI_HASFRAME;  /* activate frame */
+  pc = L-&gt;ci-&gt;u.l.savedpc;
+  cl = &amp;clvalue(L-&gt;base - 1)-&gt;l;
+  k = cl-&gt;p-&gt;k;
+  /* main loop of interpreter */
+  for (;;) {
+    const Instruction i = *pc++;
+    StkId base, ra;
+    if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;
+        (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {
+      traceexec(L);
+      if (L-&gt;ci-&gt;state &amp; CI_YIELD) {  /* did hook yield? */
+        L-&gt;ci-&gt;u.l.savedpc = pc - 1;
+        L-&gt;ci-&gt;state = CI_YIELD | CI_SAVEDPC;
+        return NULL;
+      }
+    }
+    /* warning!! several calls may realloc the stack and invalidate `ra' */
+    base = L-&gt;base;
+    ra = RA(i);
+    lua_assert(L-&gt;ci-&gt;state &amp; CI_HASFRAME);
+    lua_assert(base == L-&gt;ci-&gt;base);
+    lua_assert(L-&gt;top &lt;= L-&gt;stack + L-&gt;stacksize &amp;&amp; L-&gt;top &gt;= base);
+    lua_assert(L-&gt;top == L-&gt;ci-&gt;top ||
+         GET_OPCODE(i) == OP_CALL ||   GET_OPCODE(i) == OP_TAILCALL ||
+         GET_OPCODE(i) == OP_RETURN || GET_OPCODE(i) == OP_SETLISTO);
+    switch (GET_OPCODE(i)) {
+      case OP_MOVE: {
+        setobjs2s(ra, RB(i));
+        break;
+      }
+      case OP_LOADK: {
+        setobj2s(ra, KBx(i));
+        break;
+      }
+      case OP_LOADBOOL: {
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) pc++;  /* skip next instruction (if C) */
+        break;
+      }
+      case OP_LOADNIL: {
+        TObject *rb = RB(i);
+        do {
+          setnilvalue(rb--);
+        } while (rb &gt;= ra);
+        break;
+      }
+      case OP_GETUPVAL: {
+        int b = GETARG_B(i);
+        setobj2s(ra, cl-&gt;upvals[b]-&gt;v);
+        break;
+      }
+      case OP_GETGLOBAL: {
+        TObject *rb = KBx(i);
+        const TObject *v;
+        lua_assert(ttisstring(rb) &amp;&amp; ttistable(&amp;cl-&gt;g));
+        v = luaH_getstr(hvalue(&amp;cl-&gt;g), tsvalue(rb));
+        if (!ttisnil(v)) { setobj2s(ra, v); }
+        else
+          setobj2s(XRA(i), luaV_index(L, &amp;cl-&gt;g, rb, 0));
+        break;
+      }
+      case OP_GETTABLE: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_get(hvalue(rb), rc);
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_SETGLOBAL: {
+        lua_assert(ttisstring(KBx(i)) &amp;&amp; ttistable(&amp;cl-&gt;g));
+        luaV_settable(L, &amp;cl-&gt;g, KBx(i), ra);
+        break;
+      }
+      case OP_SETUPVAL: {
+        int b = GETARG_B(i);
+        setobj(cl-&gt;upvals[b]-&gt;v, ra);  /* write barrier */
+        break;
+      }
+      case OP_SETTABLE: {
+        luaV_settable(L, ra, RKB(i), RKC(i));
+        break;
+      }
+      case OP_NEWTABLE: {
+        int b = GETARG_B(i);
+        b = fb2int(b);
+        sethvalue(ra, luaH_new(L, b, GETARG_C(i)));
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_SELF: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        runtime_check(L, ttisstring(rc));
+        setobjs2s(ra+1, rb);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_getstr(hvalue(rb), tsvalue(rc));
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_ADD: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) + nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_ADD);
+        break;
+      }
+      case OP_SUB: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) - nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_SUB);
+        break;
+      }
+      case OP_MUL: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) * nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_MUL);
+        break;
+      }
+      case OP_DIV: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) / nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_DIV);
+        break;
+      }
+      case OP_POW: {
+        Arith(L, ra, RKB(i), RKC(i), TM_POW);
+        break;
+      }
+      case OP_UNM: {
+        const TObject *rb = RB(i);
+        TObject temp;
+        if (tonumber(rb, &amp;temp)) {
+          setnvalue(ra, -nvalue(rb));
+        }
+        else {
+          setnilvalue(&amp;temp);
+          if (!call_binTM(L, RB(i), &amp;temp, ra, TM_UNM))
+            luaG_aritherror(L, RB(i), &amp;temp);
+        }
+        break;
+      }
+      case OP_NOT: {
+        int res = l_isfalse(RB(i));  /* next assignment may change this value */
+        setbvalue(ra, res);
+        break;
+      }
+      case OP_CONCAT: {
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        luaV_concat(L, c-b+1, c);  /* may change `base' (and `ra') */
+        base = L-&gt;base;
+        setobjs2s(RA(i), base+b);
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_JMP: {
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_EQ: {
+        if (equalobj(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LT: {
+        if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LE: {
+        if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_TEST: {
+        TObject *rb = RB(i);
+        if (l_isfalse(rb) == GETARG_C(i)) pc++;
+        else {
+          setobjs2s(ra, rb);
+          dojump(pc, GETARG_sBx(*pc) + 1);
+        }
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        StkId firstResult;
+        int b = GETARG_B(i);
+        int nresults;
+        if (b != 0) L-&gt;top = ra+b;  /* else previous instruction set top */
+        nresults = GETARG_C(i) - 1;
+        firstResult = luaD_precall(L, ra);
+        if (firstResult) {
+          if (firstResult &gt; L-&gt;top) {  /* yield? */
+            lua_assert(L-&gt;ci-&gt;state == (CI_C | CI_YIELD));
+            (L-&gt;ci - 1)-&gt;u.l.savedpc = pc;
+            (L-&gt;ci - 1)-&gt;state = CI_SAVEDPC;
+            return NULL;
+          }
+          /* it was a C function (`precall' called it); adjust results */
+          luaD_poscall(L, nresults, firstResult);
+          if (nresults &gt;= 0) L-&gt;top = L-&gt;ci-&gt;top;
+        }
+        else {  /* it is a Lua function */
+          if (GET_OPCODE(i) == OP_CALL) {  /* regular call? */
+            (L-&gt;ci-1)-&gt;u.l.savedpc = pc;  /* save `pc' to return later */
+            (L-&gt;ci-1)-&gt;state = (CI_SAVEDPC | CI_CALLING);
+          }
+          else {  /* tail call: put new frame in place of previous one */
+            int aux;
+            base = (L-&gt;ci - 1)-&gt;base;  /* `luaD_precall' may change the stack */
+            ra = RA(i);
+            if (L-&gt;openupval) luaF_close(L, base);
+            for (aux = 0; ra+aux &lt; L-&gt;top; aux++)  /* move frame down */
+              setobjs2s(base+aux-1, ra+aux);
+            (L-&gt;ci - 1)-&gt;top = L-&gt;top = base+aux;  /* correct top */
+            lua_assert(L-&gt;ci-&gt;state &amp; CI_SAVEDPC);
+            (L-&gt;ci - 1)-&gt;u.l.savedpc = L-&gt;ci-&gt;u.l.savedpc;
+            (L-&gt;ci - 1)-&gt;u.l.tailcalls++;  /* one more call lost */
+            (L-&gt;ci - 1)-&gt;state = CI_SAVEDPC;
+            L-&gt;ci--;  /* remove new frame */
+            L-&gt;base = L-&gt;ci-&gt;base;
+          }
+          goto callentry;
+        }
+        break;
+      }
+      case OP_RETURN: {
+        CallInfo *ci = L-&gt;ci - 1;  /* previous function frame */
+        int b = GETARG_B(i);
+        if (b != 0) L-&gt;top = ra+b-1;
+        lua_assert(L-&gt;ci-&gt;state &amp; CI_HASFRAME);
+        if (L-&gt;openupval) luaF_close(L, base);
+        L-&gt;ci-&gt;state = CI_SAVEDPC;  /* deactivate current function */
+        L-&gt;ci-&gt;u.l.savedpc = pc;
+        /* previous function was running `here'? */
+        if (!(ci-&gt;state &amp; CI_CALLING)) {
+          lua_assert((ci-&gt;state &amp; CI_C) || ci-&gt;u.l.pc != &amp;pc);
+          return ra;  /* no: return */
+        }
+        else {  /* yes: continue its execution */
+          int nresults;
+          lua_assert(ci-&gt;u.l.pc == &amp;pc &amp;&amp;
+                     ttisfunction(ci-&gt;base - 1) &amp;&amp;
+                     (ci-&gt;state &amp; CI_SAVEDPC));
+          lua_assert(GET_OPCODE(*(ci-&gt;u.l.savedpc - 1)) == OP_CALL);
+          nresults = GETARG_C(*(ci-&gt;u.l.savedpc - 1)) - 1;
+          luaD_poscall(L, nresults, ra);
+          if (nresults &gt;= 0) L-&gt;top = L-&gt;ci-&gt;top;
+          goto retentry;
+        }
+      }
+      case OP_FORLOOP: {
+        lua_Number step, idx, limit;
+        const TObject *plimit = ra+1;
+        const TObject *pstep = ra+2;
+        if (!ttisnumber(ra))
+          luaG_runerror(L, &quot;`for' initial value must be a number&quot;);
+        if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, &quot;`for' limit must be a number&quot;);
+        if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, &quot;`for' step must be a number&quot;);
+        step = nvalue(pstep);
+        idx = nvalue(ra) + step;  /* increment index */
+        limit = nvalue(plimit);
+        if (step &gt; 0 ? idx &lt;= limit : idx &gt;= limit) {
+          dojump(pc, GETARG_sBx(i));  /* jump back */
+          chgnvalue(ra, idx);  /* update index */
+        }
+        break;
+      }
+      case OP_TFORLOOP: {
+        int nvar = GETARG_C(i) + 1;
+        StkId cb = ra + nvar + 2;  /* call base */
+        setobjs2s(cb, ra);
+        setobjs2s(cb+1, ra+1);
+        setobjs2s(cb+2, ra+2);
+        L-&gt;top = cb+3;  /* func. + 2 args (state and index) */
+        luaD_call(L, cb, nvar);
+        L-&gt;top = L-&gt;ci-&gt;top;
+        ra = XRA(i) + 2;  /* final position of first result */
+        cb = ra + nvar;
+        do {  /* move results to proper positions */
+          nvar--;
+          setobjs2s(ra+nvar, cb+nvar);
+        } while (nvar &gt; 0);
+        if (ttisnil(ra))  /* break loop? */
+          pc++;  /* skip jump (break loop) */
+        else
+          dojump(pc, GETARG_sBx(*pc) + 1);  /* jump back */
+        break;
+      }
+      case OP_TFORPREP: {  /* for compatibility only */
+        if (ttistable(ra)) {
+          setobjs2s(ra+1, ra);
+          setobj2s(ra, luaH_getstr(hvalue(gt(L)), luaS_new(L, &quot;next&quot;)));
+        }
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_SETLIST:
+      case OP_SETLISTO: {
+        int bc;
+        int n;
+        Table *h;
+        runtime_check(L, ttistable(ra));
+        h = hvalue(ra);
+        bc = GETARG_Bx(i);
+        if (GET_OPCODE(i) == OP_SETLIST)
+          n = (bc&amp;(LFIELDS_PER_FLUSH-1)) + 1;
+        else {
+          n = L-&gt;top - ra - 1;
+          L-&gt;top = L-&gt;ci-&gt;top;
+        }
+        bc &amp;= ~(LFIELDS_PER_FLUSH-1);  /* bc = bc - bc%FPF */
+        for (; n &gt; 0; n--)
+          setobj2t(luaH_setnum(L, h, bc+n), ra+n);  /* write barrier */
+        break;
+      }
+      case OP_CLOSE: {
+        luaF_close(L, ra);
+        break;
+      }
+      case OP_CLOSURE: {
+        Proto *p;
+        Closure *ncl;
+        int nup, j;
+        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];
+        nup = p-&gt;nups;
+        ncl = luaF_newLclosure(L, nup, &amp;cl-&gt;g);
+        ncl-&gt;l.p = p;
+        for (j=0; j&lt;nup; j++, pc++) {
+          if (GET_OPCODE(*pc) == OP_GETUPVAL)
+            ncl-&gt;l.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];
+          else {
+            lua_assert(GET_OPCODE(*pc) == OP_MOVE);
+            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
+          }
+        }
+        setclvalue(ra, ncl);
+        luaC_checkGC(L);
+        break;
+      }
+    }
+  }
+}
+

Added: trunk/Util/deditor/lua/lvm.h
===================================================================
--- trunk/Util/deditor/lua/lvm.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lvm.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,35 @@
+/*
+** $Id: lvm.h,v 1.47 2002/11/14 16:16:21 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include &quot;ldo.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;ltm.h&quot;
+
+
+#define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
+                         (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2) \
+	(ttype(o1) == ttype(o2) &amp;&amp; luaV_equalval(L, o1, o2))
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r);
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2);
+const TObject *luaV_tonumber (const TObject *obj, TObject *n);
+int luaV_tostring (lua_State *L, StkId obj);
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop);
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val);
+StkId luaV_execute (lua_State *L);
+void luaV_concat (lua_State *L, int total, int last);
+
+#endif

Added: trunk/Util/deditor/lua/lzio.c
===================================================================
--- trunk/Util/deditor/lua/lzio.c	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lzio.c	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,81 @@
+/*
+** $Id: lzio.c,v 1.24 2003/03/20 16:00:56 roberto Exp $
+** a generic input stream interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define lzio_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;llimits.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lzio.h&quot;
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  const char *buff = z-&gt;reader(NULL, z-&gt;data, &amp;size);
+  if (buff == NULL || size == 0) return EOZ;
+  z-&gt;n = size - 1;
+  z-&gt;p = buff;
+  return char2int(*(z-&gt;p++));
+}
+
+
+int luaZ_lookahead (ZIO *z) {
+  if (z-&gt;n == 0) {
+    int c = luaZ_fill(z);
+    if (c == EOZ) return c;
+    z-&gt;n++;
+    z-&gt;p--;
+  }
+  return char2int(*z-&gt;p);
+}
+
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name) {
+  z-&gt;reader = reader;
+  z-&gt;data = data;
+  z-&gt;name = name;
+  z-&gt;n = 0;
+  z-&gt;p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z-&gt;n == 0) {
+      if (luaZ_fill(z) == EOZ)
+        return n;  /* return number of missing bytes */
+      else {
+        ++z-&gt;n;  /* filbuf removed first byte; put back it */
+        --z-&gt;p;
+      }
+    }
+    m = (n &lt;= z-&gt;n) ? n : z-&gt;n;  /* min. between n and z-&gt;n */
+    memcpy(b, z-&gt;p, m);
+    z-&gt;n -= m;
+    z-&gt;p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n &gt; buff-&gt;buffsize) {
+    if (n &lt; LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaM_reallocvector(L, buff-&gt;buffer, buff-&gt;buffsize, n, char);
+    buff-&gt;buffsize = n;
+  }
+  return buff-&gt;buffer;
+}
+
+

Added: trunk/Util/deditor/lua/lzio.h
===================================================================
--- trunk/Util/deditor/lua/lzio.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/lua/lzio.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,64 @@
+/*
+** $Id: lzio.h,v 1.15 2003/03/20 16:00:56 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include &quot;lua.h&quot;
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+
+#define char2int(c)	cast(int, cast(unsigned char, (c)))
+
+#define zgetc(z)  (((z)-&gt;n--)&gt;0 ?  char2int(*(z)-&gt;p++) : luaZ_fill(z))
+
+#define zname(z)	((z)-&gt;name)
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name);
+size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+int luaZ_lookahead (ZIO *z);
+
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t buffsize;
+} Mbuffer;
+
+
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+
+#define luaZ_initbuffer(L, buff) ((buff)-&gt;buffer = NULL, (buff)-&gt;buffsize = 0)
+
+#define luaZ_sizebuffer(buff)	((buff)-&gt;buffsize)
+#define luaZ_buffer(buff)	((buff)-&gt;buffer)
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)-&gt;buffer, (buff)-&gt;buffsize, size, char), \
+	(buff)-&gt;buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Chunkreader reader;
+  void* data;			/* additional data */
+  const char *name;
+};
+
+
+int luaZ_fill (ZIO *z);
+
+#endif

Added: trunk/Util/deditor/main.cpp
===================================================================
--- trunk/Util/deditor/main.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/main.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,25 @@
+
+#include &lt;qapplication.h&gt;
+#include &quot;helpers.h&quot;
+#include &quot;application.h&quot;
+
+#ifdef WIN32
+#include &lt;windows.h&gt;
+#endif
+
+int main( int argc, char ** argv ) {
+	#ifdef WIN32
+	char szPath[MAX_PATH];
+	GetModuleFileName(NULL, szPath, sizeof(szPath));
+	if (strrchr(szPath, '\\')) *strrchr(szPath, '\\') = '\0';
+	SetCurrentDirectory(szPath);
+	#endif
+
+	WriteLog(&quot;main\n&quot;);
+    QApplication a( argc, argv );
+    ApplicationWindow * mw = new ApplicationWindow();
+    mw-&gt;setCaption( &quot;TW-Light Dialog Editor&quot; );
+    mw-&gt;show();
+    a.connect( &amp;a, SIGNAL(lastWindowClosed()), &amp;a, SLOT(quit()) );
+    return a.exec();
+}

Added: trunk/Util/deditor/maindialog.cpp
===================================================================
--- trunk/Util/deditor/maindialog.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/maindialog.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,425 @@
+/****************************************************************************
+** Form implementation generated from reading ui file 'MainDialog.ui'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by:  The User Interface Compiler (uic)
+**
+** WARNING! All changes made in this file will be lost!
+****************************************************************************/
+#include &quot;maindialog.h&quot;
+
+#include &lt;qcheckbox.h&gt;
+#include &lt;qgroupbox.h&gt;
+#include &lt;qheader.h&gt;
+#include &lt;qlabel.h&gt;
+#include &lt;qlineedit.h&gt;
+#include &lt;qlistview.h&gt;
+#include &lt;qmultilineedit.h&gt;
+#include &lt;qpushbutton.h&gt;
+#include &lt;qtable.h&gt;
+#include &lt;qtabwidget.h&gt;
+#include &lt;qtextbrowser.h&gt;
+#include &lt;qlayout.h&gt;
+#include &lt;qvariant.h&gt;
+#include &lt;qtooltip.h&gt;
+#include &lt;qwhatsthis.h&gt;
+
+/* 
+ *  Constructs a DialogEditorGenerated which is a child of 'parent', with the 
+ *  name 'name' and widget flags set to 'f' 
+ */
+DialogEditorGenerated::DialogEditorGenerated( QWidget* parent,  const char* name, WFlags fl )
+    : QWidget( parent, name, fl )
+{
+    if ( !name )
+	setName( &quot;DialogEditorGenerated&quot; );
+    resize( 785, 452 ); 
+    setCaption( tr( &quot;Form1&quot; ) );
+    DialogEditorGeneratedLayout = new QGridLayout( this ); 
+    DialogEditorGeneratedLayout-&gt;setSpacing( 6 );
+    DialogEditorGeneratedLayout-&gt;setMargin( 11 );
+
+    Layout17 = new QGridLayout; 
+    Layout17-&gt;setSpacing( 6 );
+    Layout17-&gt;setMargin( 0 );
+
+    Layout19 = new QVBoxLayout; 
+    Layout19-&gt;setSpacing( 6 );
+    Layout19-&gt;setMargin( 0 );
+
+    Layout18 = new QHBoxLayout; 
+    Layout18-&gt;setSpacing( 6 );
+    Layout18-&gt;setMargin( 0 );
+
+    TextLabel3 = new QLabel( this, &quot;TextLabel3&quot; );
+    TextLabel3-&gt;setText( tr( &quot;Triggers:&quot; ) );
+    Layout18-&gt;addWidget( TextLabel3 );
+
+    TextLabel12 = new QLabel( this, &quot;TextLabel12&quot; );
+    TextLabel12-&gt;setText( tr( &quot;Name&quot; ) );
+    Layout18-&gt;addWidget( TextLabel12 );
+
+    TextLabel13 = new QLabel( this, &quot;TextLabel13&quot; );
+    TextLabel13-&gt;setText( tr( &quot;Value&quot; ) );
+    Layout18-&gt;addWidget( TextLabel13 );
+    Layout19-&gt;addLayout( Layout18 );
+
+    triggerTable = new QTable( this, &quot;triggerTable&quot; );
+    triggerTable-&gt;setMaximumSize( QSize( 200, 32767 ) );
+    triggerTable-&gt;setNumRows( 6 );
+    triggerTable-&gt;setNumCols( 6 );
+    QWhatsThis::add(  triggerTable, tr( &quot;First column - trigger name, second - value&quot; ) );
+    Layout19-&gt;addWidget( triggerTable );
+
+    nodeListView = new QListView( this, &quot;nodeListView&quot; );
+    nodeListView-&gt;addColumn( tr( &quot;ID&quot; ) );
+    nodeListView-&gt;addColumn( tr( &quot;Name&quot; ) );
+    nodeListView-&gt;setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)7, (QSizePolicy::SizeType)5, nodeListView-&gt;sizePolicy().hasHeightForWidth() ) );
+    nodeListView-&gt;setMaximumSize( QSize( 200, 32767 ) );
+    QWhatsThis::add(  nodeListView, tr( &quot;Browse nodes from here&quot; ) );
+    Layout19-&gt;addWidget( nodeListView );
+
+    Layout17-&gt;addLayout( Layout19, 0, 2 );
+
+    Layout20 = new QVBoxLayout; 
+    Layout20-&gt;setSpacing( 6 );
+    Layout20-&gt;setMargin( 0 );
+
+    alienTextBrowser = new QTextBrowser( this, &quot;alienTextBrowser&quot; );
+    alienTextBrowser-&gt;setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)7, (QSizePolicy::SizeType)7, alienTextBrowser-&gt;sizePolicy().hasHeightForWidth() ) );
+    alienTextBrowser-&gt;setMinimumSize( QSize( 200, 200 ) );
+    QWhatsThis::add(  alienTextBrowser, tr( &quot;Alian picture, and text here&quot; ) );
+    Layout20-&gt;addWidget( alienTextBrowser );
+
+    TextLabel4 = new QLabel( this, &quot;TextLabel4&quot; );
+    TextLabel4-&gt;setText( tr( &quot;Place text here:&quot; ) );
+    Layout20-&gt;addWidget( TextLabel4 );
+
+    commonMultiLineEdit = new QMultiLineEdit( this, &quot;commonMultiLineEdit&quot; );
+    commonMultiLineEdit-&gt;setMinimumSize( QSize( 0, 90 ) );
+    QWhatsThis::add(  commonMultiLineEdit, tr( &quot;Text in this edit can be set aso player or alian answer.&quot; ) );
+    Layout20-&gt;addWidget( commonMultiLineEdit );
+
+    Layout17-&gt;addLayout( Layout20, 0, 0 );
+
+    answersListView = new QListView( this, &quot;answersListView&quot; );
+    answersListView-&gt;addColumn( tr( &quot;Player answers&quot; ) );
+    QWhatsThis::add(  answersListView, tr( &quot;Player Answers&quot; ) );
+
+    Layout17-&gt;addMultiCellWidget( answersListView, 1, 1, 0, 2 );
+
+    Layout14 = new QVBoxLayout; 
+    Layout14-&gt;setSpacing( 6 );
+    Layout14-&gt;setMargin( 0 );
+
+    TestModeCheckBox = new QCheckBox( this, &quot;TestModeCheckBox&quot; );
+    TestModeCheckBox-&gt;setText( tr( &quot;Test Mode (Hide not allowed answers)&quot; ) );
+    Layout14-&gt;addWidget( TestModeCheckBox );
+
+    TabWidget2 = new QTabWidget( this, &quot;TabWidget2&quot; );
+    TabWidget2-&gt;setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)4, (QSizePolicy::SizeType)4, TabWidget2-&gt;sizePolicy().hasHeightForWidth() ) );
+    TabWidget2-&gt;setMinimumSize( QSize( 200, 250 ) );
+    TabWidget2-&gt;setMargin( 0 );
+
+    tab = new QWidget( TabWidget2, &quot;tab&quot; );
+    tabLayout = new QGridLayout( tab ); 
+    tabLayout-&gt;setSpacing( 6 );
+    tabLayout-&gt;setMargin( 11 );
+
+    Layout15 = new QGridLayout; 
+    Layout15-&gt;setSpacing( 6 );
+    Layout15-&gt;setMargin( 0 );
+
+    textLocationLineEdit = new QLineEdit( tab, &quot;textLocationLineEdit&quot; );
+    textLocationLineEdit-&gt;setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  textLocationLineEdit, tr( &quot;Alien text location&quot; ) );
+
+    Layout15-&gt;addMultiCellWidget( textLocationLineEdit, 5, 5, 1, 2 );
+
+    NodeNameLineEdit = new QLineEdit( tab, &quot;NodeNameLineEdit&quot; );
+    NodeNameLineEdit-&gt;setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  NodeNameLineEdit, tr( &quot;Name is not used&quot; ) );
+
+    Layout15-&gt;addMultiCellWidget( NodeNameLineEdit, 1, 1, 1, 2 );
+
+    TextLabel1_3 = new QLabel( tab, &quot;TextLabel1_3&quot; );
+    TextLabel1_3-&gt;setText( tr( &quot;Font:&quot; ) );
+    QWhatsThis::add(  TextLabel1_3, tr( &quot;Alien text font&quot; ) );
+
+    Layout15-&gt;addWidget( TextLabel1_3, 4, 0 );
+
+    fontLineEdit = new QLineEdit( tab, &quot;fontLineEdit&quot; );
+    fontLineEdit-&gt;setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  fontLineEdit, tr( &quot;Alien text font&quot; ) );
+
+    Layout15-&gt;addMultiCellWidget( fontLineEdit, 4, 4, 1, 2 );
+
+    TextLabel3_2 = new QLabel( tab, &quot;TextLabel3_2&quot; );
+    TextLabel3_2-&gt;setText( tr( &quot;Music&quot; ) );
+    QWhatsThis::add(  TextLabel3_2, tr( &quot;Path to music file&quot; ) );
+
+    Layout15-&gt;addWidget( TextLabel3_2, 2, 0 );
+
+    TextLabel1 = new QLabel( tab, &quot;TextLabel1&quot; );
+    TextLabel1-&gt;setText( tr( &quot;Node ID&quot; ) );
+    QWhatsThis::add(  TextLabel1, tr( &quot;unique identifier for node&quot; ) );
+
+    Layout15-&gt;addWidget( TextLabel1, 0, 0 );
+
+    TextLabel2_3 = new QLabel( tab, &quot;TextLabel2_3&quot; );
+    TextLabel2_3-&gt;setText( tr( &quot;Text location:&quot; ) );
+    QWhatsThis::add(  TextLabel2_3, tr( &quot;Alien text location&quot; ) );
+
+    Layout15-&gt;addWidget( TextLabel2_3, 5, 0 );
+
+    TextLabel4_2 = new QLabel( tab, &quot;TextLabel4_2&quot; );
+    TextLabel4_2-&gt;setText( tr( &quot;Background&quot; ) );
+    QWhatsThis::add(  TextLabel4_2, tr( &quot;Path to background picture&quot; ) );
+
+    Layout15-&gt;addWidget( TextLabel4_2, 3, 0 );
+    QSpacerItem* spacer = new QSpacerItem( 20, 20, QSizePolicy::Expanding, QSizePolicy::Minimum );
+    Layout15-&gt;addItem( spacer, 0, 1 );
+
+    MusicEdit = new QLineEdit( tab, &quot;MusicEdit&quot; );
+    MusicEdit-&gt;setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  MusicEdit, tr( &quot;Path to music file&quot; ) );
+
+    Layout15-&gt;addMultiCellWidget( MusicEdit, 2, 2, 1, 2 );
+
+    BackgroundLineEdit = new QLineEdit( tab, &quot;BackgroundLineEdit&quot; );
+    BackgroundLineEdit-&gt;setAlignment( int( QLineEdit::AlignLeft ) );
+    QWhatsThis::add(  BackgroundLineEdit, tr( &quot;Path to background picture&quot; ) );
+
+    Layout15-&gt;addMultiCellWidget( BackgroundLineEdit, 3, 3, 1, 2 );
+
+    TextLabel2 = new QLabel( tab, &quot;TextLabel2&quot; );
+    TextLabel2-&gt;setText( tr( &quot;Node Name&quot; ) );
+    QWhatsThis::add(  TextLabel2, tr( &quot;Name is not used&quot; ) );
+
+    Layout15-&gt;addWidget( TextLabel2, 1, 0 );
+
+    nodeIdLineEdit = new QLineEdit( tab, &quot;nodeIdLineEdit&quot; );
+    nodeIdLineEdit-&gt;setAlignment( int( QLineEdit::AlignRight ) );
+    QWhatsThis::add(  nodeIdLineEdit, tr( &quot;unique identifier for node&quot; ) );
+
+    Layout15-&gt;addWidget( nodeIdLineEdit, 0, 2 );
+
+    tabLayout-&gt;addLayout( Layout15, 0, 0 );
+    TabWidget2-&gt;insertTab( tab, tr( &quot;Node&quot; ) );
+
+    tab_2 = new QWidget( TabWidget2, &quot;tab_2&quot; );
+    tabLayout_2 = new QVBoxLayout( tab_2 ); 
+    tabLayout_2-&gt;setSpacing( 6 );
+    tabLayout_2-&gt;setMargin( 11 );
+
+    Layout12 = new QVBoxLayout; 
+    Layout12-&gt;setSpacing( 6 );
+    Layout12-&gt;setMargin( 0 );
+
+    Layout11 = new QHBoxLayout; 
+    Layout11-&gt;setSpacing( 6 );
+    Layout11-&gt;setMargin( 0 );
+
+    TextLabel1_2 = new QLabel( tab_2, &quot;TextLabel1_2&quot; );
+    TextLabel1_2-&gt;setText( tr( &quot;Appear condition:&quot; ) );
+    Layout11-&gt;addWidget( TextLabel1_2 );
+
+    appearConditionLineEdit = new QLineEdit( tab_2, &quot;appearConditionLineEdit&quot; );
+    QWhatsThis::add(  appearConditionLineEdit, tr( &quot;Answer will not show, if doesn.t match&quot; ) );
+    Layout11-&gt;addWidget( appearConditionLineEdit );
+    Layout12-&gt;addLayout( Layout11 );
+
+    GroupBox1 = new QGroupBox( tab_2, &quot;GroupBox1&quot; );
+    GroupBox1-&gt;setTitle( tr( &quot;Actions&quot; ) );
+    GroupBox1-&gt;setColumnLayout(0, Qt::Vertical );
+    GroupBox1-&gt;layout()-&gt;setSpacing( 0 );
+    GroupBox1-&gt;layout()-&gt;setMargin( 0 );
+    GroupBox1Layout = new QHBoxLayout( GroupBox1-&gt;layout() );
+    GroupBox1Layout-&gt;setAlignment( Qt::AlignTop );
+    GroupBox1Layout-&gt;setSpacing( 6 );
+    GroupBox1Layout-&gt;setMargin( 11 );
+
+    Layout10 = new QVBoxLayout; 
+    Layout10-&gt;setSpacing( 6 );
+    Layout10-&gt;setMargin( 0 );
+
+    Layout5 = new QHBoxLayout; 
+    Layout5-&gt;setSpacing( 6 );
+    Layout5-&gt;setMargin( 0 );
+
+    TextLabel2_2 = new QLabel( GroupBox1, &quot;TextLabel2_2&quot; );
+    TextLabel2_2-&gt;setText( tr( &quot;condition&quot; ) );
+    Layout5-&gt;addWidget( TextLabel2_2 );
+
+    condition1LineEdit = new QLineEdit( GroupBox1, &quot;condition1LineEdit&quot; );
+    QWhatsThis::add(  condition1LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout5-&gt;addWidget( condition1LineEdit );
+
+    TextLabel7 = new QLabel( GroupBox1, &quot;TextLabel7&quot; );
+    TextLabel7-&gt;setText( tr( &quot;do&quot; ) );
+    Layout5-&gt;addWidget( TextLabel7 );
+
+    action1LineEdit = new QLineEdit( GroupBox1, &quot;action1LineEdit&quot; );
+    QWhatsThis::add(  action1LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout5-&gt;addWidget( action1LineEdit );
+    Layout10-&gt;addLayout( Layout5 );
+
+    Layout6 = new QHBoxLayout; 
+    Layout6-&gt;setSpacing( 6 );
+    Layout6-&gt;setMargin( 0 );
+
+    TextLabel3_3 = new QLabel( GroupBox1, &quot;TextLabel3_3&quot; );
+    TextLabel3_3-&gt;setText( tr( &quot;condition&quot; ) );
+    Layout6-&gt;addWidget( TextLabel3_3 );
+
+    condition2LineEdit = new QLineEdit( GroupBox1, &quot;condition2LineEdit&quot; );
+    QWhatsThis::add(  condition2LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout6-&gt;addWidget( condition2LineEdit );
+
+    TextLabel8 = new QLabel( GroupBox1, &quot;TextLabel8&quot; );
+    TextLabel8-&gt;setText( tr( &quot;do&quot; ) );
+    Layout6-&gt;addWidget( TextLabel8 );
+
+    action2LineEdit = new QLineEdit( GroupBox1, &quot;action2LineEdit&quot; );
+    QWhatsThis::add(  action2LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout6-&gt;addWidget( action2LineEdit );
+    Layout10-&gt;addLayout( Layout6 );
+
+    Layout7 = new QHBoxLayout; 
+    Layout7-&gt;setSpacing( 6 );
+    Layout7-&gt;setMargin( 0 );
+
+    TextLabel4_3 = new QLabel( GroupBox1, &quot;TextLabel4_3&quot; );
+    TextLabel4_3-&gt;setText( tr( &quot;condition&quot; ) );
+    Layout7-&gt;addWidget( TextLabel4_3 );
+
+    condition3LineEdit = new QLineEdit( GroupBox1, &quot;condition3LineEdit&quot; );
+    QWhatsThis::add(  condition3LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout7-&gt;addWidget( condition3LineEdit );
+
+    TextLabel9 = new QLabel( GroupBox1, &quot;TextLabel9&quot; );
+    TextLabel9-&gt;setText( tr( &quot;do&quot; ) );
+    Layout7-&gt;addWidget( TextLabel9 );
+
+    action3LineEdit = new QLineEdit( GroupBox1, &quot;action3LineEdit&quot; );
+    QWhatsThis::add(  action3LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout7-&gt;addWidget( action3LineEdit );
+    Layout10-&gt;addLayout( Layout7 );
+
+    Layout8 = new QHBoxLayout; 
+    Layout8-&gt;setSpacing( 6 );
+    Layout8-&gt;setMargin( 0 );
+
+    TextLabel5 = new QLabel( GroupBox1, &quot;TextLabel5&quot; );
+    TextLabel5-&gt;setText( tr( &quot;condition&quot; ) );
+    Layout8-&gt;addWidget( TextLabel5 );
+
+    condition4LineEdit = new QLineEdit( GroupBox1, &quot;condition4LineEdit&quot; );
+    QWhatsThis::add(  condition4LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout8-&gt;addWidget( condition4LineEdit );
+
+    TextLabel10 = new QLabel( GroupBox1, &quot;TextLabel10&quot; );
+    TextLabel10-&gt;setText( tr( &quot;do&quot; ) );
+    Layout8-&gt;addWidget( TextLabel10 );
+
+    action4LineEdit = new QLineEdit( GroupBox1, &quot;action4LineEdit&quot; );
+    QWhatsThis::add(  action4LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout8-&gt;addWidget( action4LineEdit );
+    Layout10-&gt;addLayout( Layout8 );
+
+    Layout9 = new QHBoxLayout; 
+    Layout9-&gt;setSpacing( 6 );
+    Layout9-&gt;setMargin( 0 );
+
+    TextLabel6 = new QLabel( GroupBox1, &quot;TextLabel6&quot; );
+    TextLabel6-&gt;setText( tr( &quot;condition&quot; ) );
+    Layout9-&gt;addWidget( TextLabel6 );
+
+    condition5LineEdit = new QLineEdit( GroupBox1, &quot;condition5LineEdit&quot; );
+    QWhatsThis::add(  condition5LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout9-&gt;addWidget( condition5LineEdit );
+
+    TextLabel11 = new QLabel( GroupBox1, &quot;TextLabel11&quot; );
+    TextLabel11-&gt;setText( tr( &quot;do&quot; ) );
+    Layout9-&gt;addWidget( TextLabel11 );
+
+    action5LineEdit = new QLineEdit( GroupBox1, &quot;action5LineEdit&quot; );
+    QWhatsThis::add(  action5LineEdit, tr( &quot;if condition match, coresponding action will be evaluated&quot; ) );
+    Layout9-&gt;addWidget( action5LineEdit );
+    Layout10-&gt;addLayout( Layout9 );
+    GroupBox1Layout-&gt;addLayout( Layout10 );
+    Layout12-&gt;addWidget( GroupBox1 );
+    tabLayout_2-&gt;addLayout( Layout12 );
+    TabWidget2-&gt;insertTab( tab_2, tr( &quot;Answer&quot; ) );
+    Layout14-&gt;addWidget( TabWidget2 );
+
+    Layout17-&gt;addLayout( Layout14, 0, 1 );
+
+    DialogEditorGeneratedLayout-&gt;addLayout( Layout17, 0, 0 );
+
+    // signals and slots connections
+    connect( nodeListView, SIGNAL( selectionChanged(QListViewItem*) ), this, SLOT( nodeChangedSlot(QListViewItem* ) ) );
+    connect( answersListView, SIGNAL( returnPressed(QListViewItem*) ), this, SLOT( processAnswerSlot(QListViewItem*) ) );
+    connect( answersListView, SIGNAL( doubleClicked(QListViewItem*) ), this, SLOT( processAnswerSlot(QListViewItem*) ) );
+    connect( answersListView, SIGNAL( selectionChanged(QListViewItem*) ), this, SLOT( answerChangedSlot(QListViewItem*) ) );
+
+    // tab order
+    setTabOrder( nodeIdLineEdit, NodeNameLineEdit );
+    setTabOrder( NodeNameLineEdit, MusicEdit );
+    setTabOrder( MusicEdit, BackgroundLineEdit );
+    setTabOrder( BackgroundLineEdit, commonMultiLineEdit );
+    setTabOrder( commonMultiLineEdit, nodeListView );
+    setTabOrder( nodeListView, triggerTable );
+    setTabOrder( triggerTable, alienTextBrowser );
+    setTabOrder( alienTextBrowser, TabWidget2 );
+    setTabOrder( TabWidget2, appearConditionLineEdit );
+    setTabOrder( appearConditionLineEdit, condition1LineEdit );
+    setTabOrder( condition1LineEdit, action1LineEdit );
+    setTabOrder( action1LineEdit, condition2LineEdit );
+    setTabOrder( condition2LineEdit, action2LineEdit );
+    setTabOrder( action2LineEdit, condition3LineEdit );
+    setTabOrder( condition3LineEdit, action3LineEdit );
+    setTabOrder( action3LineEdit, condition4LineEdit );
+    setTabOrder( condition4LineEdit, action4LineEdit );
+    setTabOrder( action4LineEdit, condition5LineEdit );
+    setTabOrder( condition5LineEdit, action5LineEdit );
+}
+
+/*  
+ *  Destroys the object and frees any allocated resources
+ */
+DialogEditorGenerated::~DialogEditorGenerated()
+{
+    // no need to delete child widgets, Qt does it all for us
+}
+
+void DialogEditorGenerated::answerChangedSlot(QListViewItem*)
+{
+    qWarning( &quot;DialogEditorGenerated::answerChangedSlot(QListViewItem*): Not implemented yet!&quot; );
+}
+
+void DialogEditorGenerated::answerPositionChanged(int)
+{
+    qWarning( &quot;DialogEditorGenerated::answerPositionChanged(int): Not implemented yet!&quot; );
+}
+
+void DialogEditorGenerated::nodeChangedSlot(QListViewItem* )
+{
+    qWarning( &quot;DialogEditorGenerated::nodeChangedSlot(QListViewItem* ): Not implemented yet!&quot; );
+}
+
+void DialogEditorGenerated::processAnswerSlot(QListViewItem*)
+{
+    qWarning( &quot;DialogEditorGenerated::processAnswerSlot(QListViewItem*): Not implemented yet!&quot; );
+}
+
+void DialogEditorGenerated::saveAnswer()
+{
+    qWarning( &quot;DialogEditorGenerated::saveAnswer(): Not implemented yet!&quot; );
+}
+
+void DialogEditorGenerated::saveNodeInfo()
+{
+    qWarning( &quot;DialogEditorGenerated::saveNodeInfo(): Not implemented yet!&quot; );
+}
+

Added: trunk/Util/deditor/maindialog.h
===================================================================
--- trunk/Util/deditor/maindialog.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/maindialog.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,114 @@
+/****************************************************************************
+** Form interface generated from reading ui file 'MainDialog.ui'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by:  The User Interface Compiler (uic)
+**
+** WARNING! All changes made in this file will be lost!
+****************************************************************************/
+#ifndef DIALOGEDITORGENERATED_H
+#define DIALOGEDITORGENERATED_H
+
+#include &lt;qvariant.h&gt;
+#include &lt;qwidget.h&gt;
+class QVBoxLayout; 
+class QHBoxLayout; 
+class QGridLayout; 
+class QCheckBox;
+class QGroupBox;
+class QLabel;
+class QLineEdit;
+class QListView;
+class QListViewItem;
+class QMultiLineEdit;
+class QTabWidget;
+class QTable;
+class QTextBrowser;
+
+class DialogEditorGenerated : public QWidget
+{ 
+    Q_OBJECT
+
+public:
+    DialogEditorGenerated( QWidget* parent = 0, const char* name = 0, WFlags fl = 0 );
+    ~DialogEditorGenerated();
+
+    QLabel* TextLabel3;
+    QLabel* TextLabel12;
+    QLabel* TextLabel13;
+    QTable* triggerTable;
+    QListView* nodeListView;
+    QTextBrowser* alienTextBrowser;
+    QLabel* TextLabel4;
+    QMultiLineEdit* commonMultiLineEdit;
+    QListView* answersListView;
+    QCheckBox* TestModeCheckBox;
+    QTabWidget* TabWidget2;
+    QWidget* tab;
+    QLineEdit* textLocationLineEdit;
+    QLineEdit* NodeNameLineEdit;
+    QLabel* TextLabel1_3;
+    QLineEdit* fontLineEdit;
+    QLabel* TextLabel3_2;
+    QLabel* TextLabel1;
+    QLabel* TextLabel2_3;
+    QLabel* TextLabel4_2;
+    QLineEdit* MusicEdit;
+    QLineEdit* BackgroundLineEdit;
+    QLabel* TextLabel2;
+    QLineEdit* nodeIdLineEdit;
+    QWidget* tab_2;
+    QLabel* TextLabel1_2;
+    QLineEdit* appearConditionLineEdit;
+    QGroupBox* GroupBox1;
+    QLabel* TextLabel2_2;
+    QLineEdit* condition1LineEdit;
+    QLabel* TextLabel7;
+    QLineEdit* action1LineEdit;
+    QLabel* TextLabel3_3;
+    QLineEdit* condition2LineEdit;
+    QLabel* TextLabel8;
+    QLineEdit* action2LineEdit;
+    QLabel* TextLabel4_3;
+    QLineEdit* condition3LineEdit;
+    QLabel* TextLabel9;
+    QLineEdit* action3LineEdit;
+    QLabel* TextLabel5;
+    QLineEdit* condition4LineEdit;
+    QLabel* TextLabel10;
+    QLineEdit* action4LineEdit;
+    QLabel* TextLabel6;
+    QLineEdit* condition5LineEdit;
+    QLabel* TextLabel11;
+    QLineEdit* action5LineEdit;
+
+public slots:
+    virtual void answerChangedSlot(QListViewItem*);
+    virtual void answerPositionChanged(int);
+    virtual void nodeChangedSlot(QListViewItem* );
+    virtual void processAnswerSlot(QListViewItem*);
+    virtual void saveAnswer();
+    virtual void saveNodeInfo();
+
+protected:
+    QGridLayout* DialogEditorGeneratedLayout;
+    QGridLayout* Layout17;
+    QVBoxLayout* Layout19;
+    QHBoxLayout* Layout18;
+    QVBoxLayout* Layout20;
+    QVBoxLayout* Layout14;
+    QGridLayout* tabLayout;
+    QGridLayout* Layout15;
+    QVBoxLayout* tabLayout_2;
+    QVBoxLayout* Layout12;
+    QHBoxLayout* Layout11;
+    QHBoxLayout* GroupBox1Layout;
+    QVBoxLayout* Layout10;
+    QHBoxLayout* Layout5;
+    QHBoxLayout* Layout6;
+    QHBoxLayout* Layout7;
+    QHBoxLayout* Layout8;
+    QHBoxLayout* Layout9;
+};
+
+#endif // DIALOGEDITORGENERATED_H

Added: trunk/Util/deditor/mainwidget.cpp
===================================================================
--- trunk/Util/deditor/mainwidget.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/mainwidget.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,514 @@
+
+#include &quot;mainwidget.h&quot;
+#include &lt;qtextbrowser.h&gt;
+#include &lt;qtable.h&gt; 
+#include &lt;qlistview.h&gt;
+#include &lt;qlineedit.h&gt;
+#include &lt;qxml.h&gt; 
+#include &lt;qfile.h&gt;
+#include &lt;qmessagebox.h&gt;
+#include &lt;qmultilineedit.h&gt;
+#include &lt;qimage.h&gt;
+#include &lt;qdir.h&gt;
+#include &lt;qcheckbox.h&gt;
+#include &lt;qspinbox.h&gt;
+
+#include &lt;assert.h&gt;
+
+#include &quot;node.h&quot;
+#include &quot;xmlparser.h&quot;
+#include &lt;io.h&gt;
+
+extern &quot;C&quot; {
+#	include &quot;lua.h&quot;
+#	include &quot;lualib.h&quot;
+#	include &quot;lauxlib.h&quot;
+}
+
+DialogEditor::DialogEditor( QWidget* parent, const char* name, WFlags fl ): DialogEditorGenerated(parent, name, fl)
+{
+	WriteLog(&quot;DialogEditor::DialogEditor\n&quot;);
+	alienTextBrowser-&gt;setFrameStyle( QFrame::Panel | QFrame::Sunken );
+	alienTextBrowser-&gt;setText(&quot;&lt;HTML&gt;&lt;BODY&gt;&lt;center&gt;&lt;img width=\&quot;100\&quot; height=\&quot;100\&quot; src=\&quot;./tw-logo.png\&quot;&gt;&lt;br&gt;Alien text and picture will be here&lt;/center&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;);
+	alienTextBrowser-&gt;mimeSourceFactory()-&gt;setExtensionType(&quot;qml&quot;, &quot;text/utf8&quot;);
+
+	CreateNewNode();
+	answersListView-&gt;setSorting(-1);
+}
+
+DialogEditor::~DialogEditor()
+{
+	WriteLog(&quot;DialogEditor::~DialogEditor\n&quot;);
+}
+
+
+PlayerAnswer* DialogEditor::getPlayerAnswer(QString&amp; text)
+{
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	PlayerAnswer * a;
+	for(a = node-&gt;m_answers.first();
+			a; a = node-&gt;m_answers.next())
+		if(a-&gt;m_strText == text)
+			break;
+	assert(a&amp;&amp;&quot;Answer was not found in node!!!&quot;);
+	return a;
+}
+
+int DialogEditor::getPlayerAnswerPos(QString&amp; text)
+{
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	PlayerAnswer * a;
+	int pos = 0;
+	for(a = node-&gt;m_answers.first();
+			a; a = node-&gt;m_answers.next())
+			{
+				if(a-&gt;m_strText == text)
+					break;
+				pos++;
+			}
+	assert(a&amp;&amp;&quot;Answer was not found in node!!!&quot;);
+	return pos;
+}
+
+void DialogEditor::removeAnswer()
+{		
+	WriteLog(&quot;DialogEditor::removeAnswer()\n&quot;);
+	QListViewItem * curAnsw = answersListView-&gt;currentItem();
+	if (!curAnsw)
+			return;
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	node-&gt;m_answers.remove(getPlayerAnswer(curAnsw-&gt;text(0)));
+
+	delete curAnsw;
+}
+
+void DialogEditor::removeNode()
+{
+	WriteLog(&quot;DialogEditor::removeNode()\n&quot;);
+	if(nodeListView-&gt;childCount()==1)
+		return;
+	
+	QListViewItem* item= nodeListView-&gt;currentItem();
+	QListViewItemIterator it( item );
+	it++;
+	if(it.current())
+	{
+		nodeListView-&gt;setCurrentItem(it.current());
+	}
+	else
+	{
+		QListViewItemIterator i( item );
+		i--;
+		nodeListView-&gt;setCurrentItem(i.current());
+	}
+	delete item;
+}
+
+void DialogEditor::CreateNewNode()
+{
+	WriteLog(&quot;DialogEditor::CreateNewNode()\n&quot;);
+	int nodeCount = nodeListView-&gt;childCount();
+	
+	QString strId;
+	if (nodeCount)
+	{
+		int id = 0;
+		QListViewItem* item = nodeListView-&gt;firstChild ();
+		QListViewItemIterator it( item );
+		for(;it.current();it++)
+		{
+			if(it.current()-&gt;text(0).toInt()&gt;id)
+				id = it.current()-&gt;text(0).toInt();
+		}
+		strId.sprintf(&quot;%d&quot;,id+1);
+	}
+	else
+	{
+		strId = &quot;0&quot;;
+	}
+	NodeItem* critem = new NodeItem ( nodeListView ) ;
+
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	if(node)
+	{
+		critem-&gt;setFont(node-&gt;m_strFont);
+		critem-&gt;setPicture(node-&gt;m_strPicture);
+		critem-&gt;setTextLocation(node-&gt;m_strTextLocation);
+		critem-&gt;setMusic(node-&gt;m_strMusic);
+	}
+	critem-&gt;setName(&quot;New node name&quot;);
+	critem-&gt;setID( strId );
+	nodeListView-&gt;setCurrentItem(critem);
+}
+
+void DialogEditor::nodeChangedSlot(QListViewItem* i)
+{
+	WriteLog(&quot;DialogEditor::nodeChangedSlot\n&quot;);
+	NodeItem * node = (NodeItem*)i;
+	if (!i)
+		return;
+
+	// disconnect edits from previous
+	disconnect( nodeIdLineEdit,     0, 0, 0 );
+	disconnect( NodeNameLineEdit,   0, 0, 0 );
+	disconnect( MusicEdit,          0, 0, 0 );
+	disconnect( BackgroundLineEdit, 0, 0, 0 );
+	disconnect( textLocationLineEdit, 0, 0, 0 );
+	disconnect( fontLineEdit, 0, 0, 0 );
+
+	connect( nodeIdLineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		node, SLOT(setID(const QString&amp;)));
+	connect( NodeNameLineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		node, SLOT(setName(const QString&amp;)));
+	connect( MusicEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		node, SLOT(setMusic(const QString&amp;)));
+	connect( BackgroundLineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		node, SLOT(setPicture(const QString&amp;)));
+	connect( textLocationLineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		node, SLOT(setTextLocation(const QString&amp;)));
+	connect( fontLineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		node, SLOT(setFont(const QString&amp;)));
+
+	nodeIdLineEdit      -&gt;setText(node-&gt;text(0));
+	NodeNameLineEdit    -&gt;setText(node-&gt;text(1));
+	MusicEdit           -&gt;setText(node-&gt;m_strMusic);
+	BackgroundLineEdit  -&gt;setText(node-&gt;m_strPicture);
+	textLocationLineEdit-&gt;setText(node-&gt;m_strTextLocation);
+	fontLineEdit        -&gt;setText(node-&gt;m_strFont);
+
+	// Set Browser
+	QString browserText;
+	browserText += &quot;&lt;HTML&gt;&lt;BODY&gt;&lt;CENTER&gt;&quot;;
+	if(node-&gt;m_strPicture!= &quot;&quot;)
+	{
+		browserText += QString(&quot;&quot;).sprintf(&quot;&lt;img width=\&quot;100\&quot; height=\&quot;100\&quot;&quot;
+			&quot;src=\&quot;alien\&quot; alt=\&quot;Home\&quot; border=\&quot;0\&quot;&gt;&lt;br&gt;&quot;);
+	}
+
+	browserText += node-&gt;m_strAlienText;
+	browserText += &quot;&lt;/CENTER&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;;
+
+	alienTextBrowser-&gt;mimeSourceFactory()-&gt;setFilePath( QDir::currentDirPath() );
+	alienTextBrowser-&gt;mimeSourceFactory()-&gt;setImage(&quot;alien&quot;,QImage(BackgroundLineEdit-&gt;text()));
+	alienTextBrowser-&gt;setText(browserText);
+
+	// Set Answers
+	disconnectAnswer();
+	answersListView-&gt;clear();
+	for(PlayerAnswer * a = node-&gt;m_answers. last();
+		a; a = node-&gt;m_answers.prev())
+	{
+		if (script_check_condition(a-&gt;m_strAppearCondition) || !TestModeCheckBox-&gt;isChecked ())
+			QListViewItem * item = new QListViewItem(answersListView,a-&gt;m_strText);
+	//	answersListView     -&gt;setCurrentItem(item);
+	}
+}
+
+
+void DialogEditor::disconnectAnswer()
+{
+	WriteLog(&quot;DialogEditor::disconnectAnswer()\n&quot;);
+	disconnect(condition1LineEdit, 0, 0, 0);
+	condition1LineEdit-&gt;setText(&quot;&quot;);
+	condition1LineEdit-&gt;setEnabled(FALSE);
+	disconnect(condition2LineEdit, 0, 0, 0);
+	condition2LineEdit-&gt;setText(&quot;&quot;);
+	condition2LineEdit-&gt;setEnabled(FALSE);
+	disconnect(condition3LineEdit, 0, 0, 0);
+	condition3LineEdit-&gt;setText(&quot;&quot;);
+	condition3LineEdit-&gt;setEnabled(FALSE);
+	disconnect(condition4LineEdit, 0, 0, 0);
+	condition4LineEdit-&gt;setText(&quot;&quot;);
+	condition4LineEdit-&gt;setEnabled(FALSE);
+	disconnect(condition5LineEdit, 0, 0, 0);
+	condition5LineEdit-&gt;setText(&quot;&quot;);
+	condition5LineEdit-&gt;setEnabled(FALSE);
+
+	disconnect(action1LineEdit, 0, 0, 0);
+	action1LineEdit-&gt;setText(&quot;&quot;);
+	action1LineEdit-&gt;setEnabled(FALSE);
+	disconnect(action2LineEdit, 0, 0, 0);
+	action2LineEdit-&gt;setText(&quot;&quot;);
+	action2LineEdit-&gt;setEnabled(FALSE);
+	disconnect(action3LineEdit, 0, 0, 0);
+	action3LineEdit-&gt;setText(&quot;&quot;);
+	action3LineEdit-&gt;setEnabled(FALSE);
+	disconnect(action4LineEdit, 0, 0, 0);
+	action4LineEdit-&gt;setText(&quot;&quot;);
+	action4LineEdit-&gt;setEnabled(FALSE);
+	disconnect(action5LineEdit, 0, 0, 0);
+	action5LineEdit-&gt;setText(&quot;&quot;);
+	action5LineEdit-&gt;setEnabled(FALSE);
+
+	disconnect(appearConditionLineEdit, 0, 0, 0);
+	appearConditionLineEdit-&gt;setText(&quot;&quot;);
+	appearConditionLineEdit-&gt;setEnabled(FALSE);
+}
+
+
+void DialogEditor::answerChangedSlot(QListViewItem* item)
+{
+	WriteLog(&quot;DialogEditor::answerChangedSlot(QListViewItem* item)\n&quot;);
+	disconnectAnswer();
+	if(!item)
+	{
+		condition1LineEdit-&gt;setEnabled ( FALSE ) ;
+		return;
+	}
+	
+
+	PlayerAnswer * pa = getPlayerAnswer(item-&gt;text(0));
+
+	connect( condition1LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setCondition1Line(const QString&amp;)));
+	condition1LineEdit-&gt;setEnabled(TRUE);
+	connect( condition2LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setCondition2Line(const QString&amp;)));
+	condition2LineEdit-&gt;setEnabled(TRUE);
+	connect( condition3LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setCondition3Line(const QString&amp;)));
+	condition3LineEdit-&gt;setEnabled(TRUE);
+	connect( condition4LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setCondition4Line(const QString&amp;)));
+	condition4LineEdit-&gt;setEnabled(TRUE);
+	connect( condition5LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setCondition5Line(const QString&amp;)));
+	condition5LineEdit-&gt;setEnabled(TRUE);
+
+	connect( action1LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setAction1Line(const QString&amp;)));
+	action1LineEdit-&gt;setEnabled(TRUE);
+	connect( action2LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setAction2Line(const QString&amp;)));
+	action2LineEdit-&gt;setEnabled(TRUE);
+	connect( action3LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setAction3Line(const QString&amp;)));
+	action3LineEdit-&gt;setEnabled(TRUE);
+	connect( action4LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setAction4Line(const QString&amp;)));
+	action4LineEdit-&gt;setEnabled(TRUE);
+	connect( action5LineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setAction5Line(const QString&amp;)));
+	action5LineEdit-&gt;setEnabled(TRUE);
+
+	connect( appearConditionLineEdit, SIGNAL( textChanged ( const QString&amp;)), 
+		pa, SLOT(setAppearCondition(const QString&amp;)));
+	appearConditionLineEdit-&gt;setEnabled(TRUE);
+
+	condition1LineEdit-&gt;setText(pa-&gt;m_strCond[0]);
+	condition2LineEdit-&gt;setText(pa-&gt;m_strCond[1]);
+	condition3LineEdit-&gt;setText(pa-&gt;m_strCond[2]);
+	condition4LineEdit-&gt;setText(pa-&gt;m_strCond[3]);
+	condition5LineEdit-&gt;setText(pa-&gt;m_strCond[4]);
+
+	action1LineEdit-&gt;setText(pa-&gt;m_strAct[0]);
+	action2LineEdit-&gt;setText(pa-&gt;m_strAct[1]);
+	action3LineEdit-&gt;setText(pa-&gt;m_strAct[2]);
+	action4LineEdit-&gt;setText(pa-&gt;m_strAct[3]);
+	action5LineEdit-&gt;setText(pa-&gt;m_strAct[4]);
+
+	appearConditionLineEdit-&gt;setText(pa-&gt;m_strAppearCondition);
+
+	commonMultiLineEdit-&gt;setText(item-&gt;text(0));
+}
+
+QString DialogEditor::GetXML()
+{
+	WriteLog(&quot;DialogEditor::edited()\n&quot;);
+	QString strRes;
+	strRes += &quot;&lt;NODES&gt;&quot;;
+	QListViewItem* item = nodeListView-&gt;firstChild ();
+	QListViewItemIterator it( item );
+	for(;it.current();it++)
+	{
+		NodeItem *item = (NodeItem*)it.current();
+		strRes += &quot;&lt;NODE id=\&quot;&quot;   + TWEscapeXML(item-&gt;text(0)) + &quot;\&quot;&quot;;
+		strRes += &quot; name=\&quot;&quot;      + TWEscapeXML(item-&gt;text(1)) + &quot;\&quot;&quot;;
+		strRes += &quot; music=\&quot;&quot;     + TWEscapeXML(item-&gt;m_strMusic) + &quot;\&quot;&quot;;
+		strRes += &quot; background=\&quot;&quot;+ TWEscapeXML(item-&gt;m_strPicture) + &quot;\&quot;&quot;;
+		strRes += &quot; alien_text=\&quot;&quot;+ TWEscapeXML(item-&gt;m_strAlienText) + &quot;\&quot;&quot;;
+		strRes += &quot; font=\&quot;&quot;+ TWEscapeXML(item-&gt;m_strFont) + &quot;\&quot;&quot;;
+		strRes += &quot; text_location=\&quot;&quot;+ TWEscapeXML(item-&gt;m_strTextLocation) + &quot;\&quot;&quot;;
+		strRes += &quot;&gt;&quot;;
+
+
+		for(PlayerAnswer * a = item-&gt;m_answers.first();
+			a; a = item-&gt;m_answers.next())
+		{	
+			strRes +=&quot;&lt;PLAYER_ANSWER &quot;;
+			strRes +=&quot;text=\&quot;&quot; + TWEscapeXML(a-&gt;m_strText) + &quot;\&quot; &quot;;
+			strRes +=&quot;appear_condition=\&quot;&quot; + TWEscapeXML(a-&gt;m_strAppearCondition) + &quot;\&quot;&gt;&quot;;
+			
+			for(int j=0;j&lt;5;j++)
+				if( !(a-&gt;m_strCond[j].isEmpty()) &amp;&amp; !(a-&gt;m_strAct[j].isEmpty()))
+				{
+					strRes += &quot;&lt;ACTION &quot;;
+					strRes += &quot;condition=\&quot;&quot; + TWEscapeXML(a-&gt;m_strCond[j]) + &quot;\&quot; &quot;;
+					strRes += &quot;action=\&quot;&quot; + TWEscapeXML(a-&gt;m_strAct[j]) + &quot;\&quot;&gt;&quot;;
+					strRes += &quot;&lt;/ACTION&gt;&quot;;
+				}
+			strRes +=&quot;&lt;/PLAYER_ANSWER&gt;&quot;;
+		}
+		strRes += &quot;&lt;/NODE&gt;&quot;;
+	}
+	strRes += &quot;&lt;/NODES&gt;&quot;;
+	return strRes;
+}
+
+void DialogEditor::loadDoc(QString fileName)
+{
+  WriteLog(&quot;DialogEditor::loadDoc(QString fileName)\n&quot;);
+
+  if(fileName.find(&quot;.xml&quot;, 0, FALSE)==-1)
+  {
+	  QString mes;
+	  mes.sprintf(&quot;file:\n%s\nDoes not have xml extension&quot;, fileName);
+
+	  QMessageBox::warning (this, &quot;TW-Light editor&quot;,
+			mes);
+  }
+
+  QFile f(fileName);
+  XMLParser handler(this);
+  QXmlInputSource source(f);
+
+  QXmlSimpleReader reader;
+  reader.setContentHandler( &amp;handler );
+  reader.parse( source );
+}
+
+void DialogEditor::setAlienText()
+{
+	WriteLog(&quot;DialogEditor::setAlienText()\n&quot;);
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	node-&gt;m_strAlienText = commonMultiLineEdit-&gt;text();
+	nodeChangedSlot(node);
+}
+
+void DialogEditor::setPlayerAnswerText()
+{
+	WriteLog(&quot;DialogEditor::setPlayerAnswerText()\n&quot;);
+	QListViewItem * curAnsw = answersListView-&gt;currentItem();
+	if(!curAnsw)
+		return;
+	PlayerAnswer * pa = getPlayerAnswer(curAnsw-&gt;text(0));
+	pa-&gt;m_strText = commonMultiLineEdit-&gt;text();
+	curAnsw-&gt;setText(0, commonMultiLineEdit-&gt;text());
+}
+
+void DialogEditor::AddPlayerAnswer()
+{
+	WriteLog(&quot;DialogEditor::AddPlayerAnswer()\n&quot;);
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	PlayerAnswer * item = new PlayerAnswer;
+	item-&gt;m_strText = commonMultiLineEdit-&gt;text();
+	item-&gt;m_strAppearCondition = &quot;1&quot;;
+
+	node-&gt;m_answers.append(item);
+	nodeChangedSlot(node);
+}
+
+// To be implemented
+bool DialogEditor::script_check_condition(QString &amp; condition)
+{
+	WriteLog(&quot;DialogEditor::script_check_condition(QString &amp; condition)\n&quot;);
+	return true;
+}
+
+NodeItem * DialogEditor::getNodeItem(QString&amp; id)
+{
+	WriteLog(&quot;DialogEditor::getNodeItem(QString&amp; id)\n&quot;);
+	QListViewItem* item = nodeListView-&gt;firstChild ();
+	QListViewItemIterator it( item );
+	for(;it.current();it++)
+	{
+		if(it.current()-&gt;text(0) == id)
+			return (NodeItem *)it.current();
+	}
+	return NULL;
+}
+
+
+void DialogEditor::processAnswerSlot(QListViewItem* item)
+{
+	WriteLog(&quot;DialogEditor::processAnswerSlot(QListViewItem* item)\n&quot;);
+	PlayerAnswer* answer = getPlayerAnswer(item-&gt;text(0));
+	for(int i=0;i&lt;5;i++)
+	{
+			lua_State * L = lua_open();
+			lua_baselibopen(L);
+			lua_iolibopen(L);
+			lua_strlibopen(L);
+			lua_mathlibopen(L);
+			bool eva = lua_dostring(L, &quot;function goto(id) gotoid = id; end&quot;);
+			eva = lua_dostring(L, answer-&gt;m_strAct[i]);
+			lua_getglobal(L, &quot;gotoid&quot;);
+			if (lua_isstring(L, -1)) 
+			{
+				const char * id = lua_tostring(L, -1);
+				NodeItem * node = getNodeItem(QString(id));
+				if(node)
+					nodeListView-&gt;setCurrentItem(node);
+			}
+			lua_close(L);
+	}
+}
+
+void DialogEditor::answerUp()
+{
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	QListViewItem * item = answersListView-&gt;currentItem();
+
+	if(!node || !item)
+		return;
+	
+	int pos = getPlayerAnswerPos(item-&gt;text(0));
+	if(pos==0)
+		return;
+	
+	QString strText = item-&gt;text(0);
+	PlayerAnswer* answer = node-&gt;m_answers.take(pos);
+	node-&gt;m_answers.insert(pos-1, answer);
+
+	nodeChangedSlot(node);	
+
+	QListViewItemIterator it( answersListView-&gt;firstChild () );
+	for(;it.current();it++)
+	{
+		if(it.current()-&gt;text(0)==strText)
+		{
+			answersListView-&gt;setCurrentItem(it.current());
+			break;
+		}
+	}
+}
+
+void DialogEditor::answerDown()
+{
+	NodeItem * node = (NodeItem*)nodeListView-&gt;currentItem();
+	QListViewItem * item = answersListView-&gt;currentItem();
+	
+	if(!node || !item)
+		return;
+
+	int pos = getPlayerAnswerPos(item-&gt;text(0));
+	if(pos==node-&gt;m_answers.count()-1 )
+		return;
+	
+	QString strText = item-&gt;text(0);
+
+	PlayerAnswer* answer = node-&gt;m_answers.take(pos);
+	node-&gt;m_answers.insert(pos+1, answer);
+
+	nodeChangedSlot(node);	
+	QListViewItemIterator it( answersListView-&gt;firstChild () );
+	for(;it.current();it++)
+	{
+		if(it.current()-&gt;text(0)==strText)
+		{
+			answersListView-&gt;setCurrentItem(it.current());
+			break;
+		}
+	}
+}
+

Added: trunk/Util/deditor/mainwidget.h
===================================================================
--- trunk/Util/deditor/mainwidget.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/mainwidget.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,52 @@
+#ifndef TW_MAINWIDGET_H
+#define TW_MAINWIDGET_H
+
+#include &quot;maindialog.h&quot;
+#include &lt;qmenubar.h&gt;
+#include &lt;qtoolbar.h&gt;
+#include &lt;qmainwindow.h&gt;
+#include &quot;helpers.h&quot;
+#include &quot;node.h&quot;
+
+class DialogEditor: public DialogEditorGenerated
+{
+private:
+
+public:
+	DialogEditor( QWidget* parent = 0, const char* name = 0, WFlags fl = 0 );
+	~DialogEditor();
+
+	void loadDoc(QString fileName);
+
+	/// Get XML 
+	QString GetXML();
+
+	virtual void setAlienText();
+	virtual void removeNode();
+	virtual void CreateNewNode();
+	virtual void nodeChangedSlot(QListViewItem* );
+	virtual void AddPlayerAnswer();
+	virtual void answerChangedSlot(QListViewItem* item);
+	virtual void removeAnswer();
+	virtual void setPlayerAnswerText();
+	virtual void disconnectAnswer();
+	virtual void processAnswerSlot(QListViewItem*);
+
+	virtual void answerUp();
+	virtual void answerDown();
+
+	NodeItem * getNodeItem(QString&amp; id);
+	PlayerAnswer* getPlayerAnswer(QString&amp; text);
+	int getPlayerAnswerPos(QString&amp; text);
+
+	bool script_check_condition(QString &amp; condition);
+protected:
+	QToolBar *fileTools;
+	QMenuBar *menu;
+
+	void InitMenu();
+	void InitToolBar();
+};
+
+
+#endif TW_MAINWIDGET

Added: trunk/Util/deditor/moc_application.cpp
===================================================================
--- trunk/Util/deditor/moc_application.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/moc_application.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,153 @@
+/****************************************************************************
+** ApplicationWindow meta object code from reading C++ file 'application.h'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by: The Qt MOC ($Id: //depot/qt/main/src/moc/moc.y#178 $)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#define Q_MOC_ApplicationWindow
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#define Q_MOC_OUTPUT_REVISION 8
+#elif Q_MOC_OUTPUT_REVISION != 8
+#error &quot;Moc format conflict - please regenerate all moc files&quot;
+#endif
+
+#include &quot;application.h&quot;
+#include &lt;qmetaobject.h&gt;
+#include &lt;qapplication.h&gt;
+
+#if defined(Q_SPARCWORKS_FUNCP_BUG)
+#define Q_AMPERSAND
+#else
+#define Q_AMPERSAND &amp;
+#endif
+
+
+const char *ApplicationWindow::className() const
+{
+    return &quot;ApplicationWindow&quot;;
+}
+
+QMetaObject *ApplicationWindow::metaObj = 0;
+
+void ApplicationWindow::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QMainWindow::className(), &quot;QMainWindow&quot;) != 0 )
+	badSuperclassWarning(&quot;ApplicationWindow&quot;,&quot;QMainWindow&quot;);
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString ApplicationWindow::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)-&gt;translate(&quot;ApplicationWindow&quot;,s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* ApplicationWindow::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QMainWindow::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(ApplicationWindow::*m1_t0)();
+    typedef void(ApplicationWindow::*m1_t1)();
+    typedef void(ApplicationWindow::*m1_t2)(QString);
+    typedef void(ApplicationWindow::*m1_t3)();
+    typedef void(ApplicationWindow::*m1_t4)();
+    typedef void(ApplicationWindow::*m1_t5)();
+    typedef void(ApplicationWindow::*m1_t6)();
+    typedef void(ApplicationWindow::*m1_t7)();
+    typedef void(ApplicationWindow::*m1_t8)();
+    typedef void(ApplicationWindow::*m1_t9)();
+    typedef void(ApplicationWindow::*m1_t10)();
+    typedef void(ApplicationWindow::*m1_t11)();
+    typedef void(ApplicationWindow::*m1_t12)();
+    typedef void(ApplicationWindow::*m1_t13)();
+    typedef void(ApplicationWindow::*m1_t14)();
+    typedef void(ApplicationWindow::*m1_t15)();
+    m1_t0 v1_0 = Q_AMPERSAND ApplicationWindow::newDoc;
+    m1_t1 v1_1 = Q_AMPERSAND ApplicationWindow::load;
+    m1_t2 v1_2 = Q_AMPERSAND ApplicationWindow::load;
+    m1_t3 v1_3 = Q_AMPERSAND ApplicationWindow::save;
+    m1_t4 v1_4 = Q_AMPERSAND ApplicationWindow::saveAs;
+    m1_t5 v1_5 = Q_AMPERSAND ApplicationWindow::AddNewNodeSlot;
+    m1_t6 v1_6 = Q_AMPERSAND ApplicationWindow::RemoveNodeSlot;
+    m1_t7 v1_7 = Q_AMPERSAND ApplicationWindow::SetAlienTextSlot;
+    m1_t8 v1_8 = Q_AMPERSAND ApplicationWindow::AddNewPlayerAnswerSlot;
+    m1_t9 v1_9 = Q_AMPERSAND ApplicationWindow::RemovePlayerAnswerSlot;
+    m1_t10 v1_10 = Q_AMPERSAND ApplicationWindow::SetPlayerAnswerTextSlot;
+    m1_t11 v1_11 = Q_AMPERSAND ApplicationWindow::answerUpSlot;
+    m1_t12 v1_12 = Q_AMPERSAND ApplicationWindow::answerDownSlot;
+    m1_t13 v1_13 = Q_AMPERSAND ApplicationWindow::hideNotAllowedAnswersSlot;
+    m1_t14 v1_14 = Q_AMPERSAND ApplicationWindow::evaluateAnswerSlot;
+    m1_t15 v1_15 = Q_AMPERSAND ApplicationWindow::about;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(16);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(16);
+    slot_tbl[0].name = &quot;newDoc()&quot;;
+    slot_tbl[0].ptr = *((QMember*)&amp;v1_0);
+    slot_tbl_access[0] = QMetaData::Private;
+    slot_tbl[1].name = &quot;load()&quot;;
+    slot_tbl[1].ptr = *((QMember*)&amp;v1_1);
+    slot_tbl_access[1] = QMetaData::Private;
+    slot_tbl[2].name = &quot;load(QString)&quot;;
+    slot_tbl[2].ptr = *((QMember*)&amp;v1_2);
+    slot_tbl_access[2] = QMetaData::Private;
+    slot_tbl[3].name = &quot;save()&quot;;
+    slot_tbl[3].ptr = *((QMember*)&amp;v1_3);
+    slot_tbl_access[3] = QMetaData::Private;
+    slot_tbl[4].name = &quot;saveAs()&quot;;
+    slot_tbl[4].ptr = *((QMember*)&amp;v1_4);
+    slot_tbl_access[4] = QMetaData::Private;
+    slot_tbl[5].name = &quot;AddNewNodeSlot()&quot;;
+    slot_tbl[5].ptr = *((QMember*)&amp;v1_5);
+    slot_tbl_access[5] = QMetaData::Private;
+    slot_tbl[6].name = &quot;RemoveNodeSlot()&quot;;
+    slot_tbl[6].ptr = *((QMember*)&amp;v1_6);
+    slot_tbl_access[6] = QMetaData::Private;
+    slot_tbl[7].name = &quot;SetAlienTextSlot()&quot;;
+    slot_tbl[7].ptr = *((QMember*)&amp;v1_7);
+    slot_tbl_access[7] = QMetaData::Private;
+    slot_tbl[8].name = &quot;AddNewPlayerAnswerSlot()&quot;;
+    slot_tbl[8].ptr = *((QMember*)&amp;v1_8);
+    slot_tbl_access[8] = QMetaData::Private;
+    slot_tbl[9].name = &quot;RemovePlayerAnswerSlot()&quot;;
+    slot_tbl[9].ptr = *((QMember*)&amp;v1_9);
+    slot_tbl_access[9] = QMetaData::Private;
+    slot_tbl[10].name = &quot;SetPlayerAnswerTextSlot()&quot;;
+    slot_tbl[10].ptr = *((QMember*)&amp;v1_10);
+    slot_tbl_access[10] = QMetaData::Private;
+    slot_tbl[11].name = &quot;answerUpSlot()&quot;;
+    slot_tbl[11].ptr = *((QMember*)&amp;v1_11);
+    slot_tbl_access[11] = QMetaData::Private;
+    slot_tbl[12].name = &quot;answerDownSlot()&quot;;
+    slot_tbl[12].ptr = *((QMember*)&amp;v1_12);
+    slot_tbl_access[12] = QMetaData::Private;
+    slot_tbl[13].name = &quot;hideNotAllowedAnswersSlot()&quot;;
+    slot_tbl[13].ptr = *((QMember*)&amp;v1_13);
+    slot_tbl_access[13] = QMetaData::Private;
+    slot_tbl[14].name = &quot;evaluateAnswerSlot()&quot;;
+    slot_tbl[14].ptr = *((QMember*)&amp;v1_14);
+    slot_tbl_access[14] = QMetaData::Private;
+    slot_tbl[15].name = &quot;about()&quot;;
+    slot_tbl[15].ptr = *((QMember*)&amp;v1_15);
+    slot_tbl_access[15] = QMetaData::Private;
+    metaObj = QMetaObject::new_metaobject(
+	&quot;ApplicationWindow&quot;, &quot;QMainWindow&quot;,
+	slot_tbl, 16,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj-&gt;set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}

Added: trunk/Util/deditor/moc_maindialog.cpp
===================================================================
--- trunk/Util/deditor/moc_maindialog.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/moc_maindialog.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,103 @@
+/****************************************************************************
+** DialogEditorGenerated meta object code from reading C++ file 'maindialog.h'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by: The Qt MOC ($Id: //depot/qt/main/src/moc/moc.y#178 $)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#define Q_MOC_DialogEditorGenerated
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#define Q_MOC_OUTPUT_REVISION 8
+#elif Q_MOC_OUTPUT_REVISION != 8
+#error &quot;Moc format conflict - please regenerate all moc files&quot;
+#endif
+
+#include &quot;maindialog.h&quot;
+#include &lt;qmetaobject.h&gt;
+#include &lt;qapplication.h&gt;
+
+#if defined(Q_SPARCWORKS_FUNCP_BUG)
+#define Q_AMPERSAND
+#else
+#define Q_AMPERSAND &amp;
+#endif
+
+
+const char *DialogEditorGenerated::className() const
+{
+    return &quot;DialogEditorGenerated&quot;;
+}
+
+QMetaObject *DialogEditorGenerated::metaObj = 0;
+
+void DialogEditorGenerated::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QWidget::className(), &quot;QWidget&quot;) != 0 )
+	badSuperclassWarning(&quot;DialogEditorGenerated&quot;,&quot;QWidget&quot;);
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString DialogEditorGenerated::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)-&gt;translate(&quot;DialogEditorGenerated&quot;,s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* DialogEditorGenerated::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QWidget::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(DialogEditorGenerated::*m1_t0)(QListViewItem*);
+    typedef void(DialogEditorGenerated::*m1_t1)(int);
+    typedef void(DialogEditorGenerated::*m1_t2)(QListViewItem*);
+    typedef void(DialogEditorGenerated::*m1_t3)(QListViewItem*);
+    typedef void(DialogEditorGenerated::*m1_t4)();
+    typedef void(DialogEditorGenerated::*m1_t5)();
+    m1_t0 v1_0 = Q_AMPERSAND DialogEditorGenerated::answerChangedSlot;
+    m1_t1 v1_1 = Q_AMPERSAND DialogEditorGenerated::answerPositionChanged;
+    m1_t2 v1_2 = Q_AMPERSAND DialogEditorGenerated::nodeChangedSlot;
+    m1_t3 v1_3 = Q_AMPERSAND DialogEditorGenerated::processAnswerSlot;
+    m1_t4 v1_4 = Q_AMPERSAND DialogEditorGenerated::saveAnswer;
+    m1_t5 v1_5 = Q_AMPERSAND DialogEditorGenerated::saveNodeInfo;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(6);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(6);
+    slot_tbl[0].name = &quot;answerChangedSlot(QListViewItem*)&quot;;
+    slot_tbl[0].ptr = *((QMember*)&amp;v1_0);
+    slot_tbl_access[0] = QMetaData::Public;
+    slot_tbl[1].name = &quot;answerPositionChanged(int)&quot;;
+    slot_tbl[1].ptr = *((QMember*)&amp;v1_1);
+    slot_tbl_access[1] = QMetaData::Public;
+    slot_tbl[2].name = &quot;nodeChangedSlot(QListViewItem*)&quot;;
+    slot_tbl[2].ptr = *((QMember*)&amp;v1_2);
+    slot_tbl_access[2] = QMetaData::Public;
+    slot_tbl[3].name = &quot;processAnswerSlot(QListViewItem*)&quot;;
+    slot_tbl[3].ptr = *((QMember*)&amp;v1_3);
+    slot_tbl_access[3] = QMetaData::Public;
+    slot_tbl[4].name = &quot;saveAnswer()&quot;;
+    slot_tbl[4].ptr = *((QMember*)&amp;v1_4);
+    slot_tbl_access[4] = QMetaData::Public;
+    slot_tbl[5].name = &quot;saveNodeInfo()&quot;;
+    slot_tbl[5].ptr = *((QMember*)&amp;v1_5);
+    slot_tbl_access[5] = QMetaData::Public;
+    metaObj = QMetaObject::new_metaobject(
+	&quot;DialogEditorGenerated&quot;, &quot;QWidget&quot;,
+	slot_tbl, 6,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj-&gt;set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}

Added: trunk/Util/deditor/moc_node.cpp
===================================================================
--- trunk/Util/deditor/moc_node.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/moc_node.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,211 @@
+/****************************************************************************
+** PlayerAnswer meta object code from reading C++ file 'node.h'
+**
+** Created: Wed Sep 1 19:55:28 2004
+**      by: The Qt MOC ($Id: //depot/qt/main/src/moc/moc.y#178 $)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#define Q_MOC_PlayerAnswer
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#define Q_MOC_OUTPUT_REVISION 8
+#elif Q_MOC_OUTPUT_REVISION != 8
+#error &quot;Moc format conflict - please regenerate all moc files&quot;
+#endif
+
+#include &quot;node.h&quot;
+#include &lt;qmetaobject.h&gt;
+#include &lt;qapplication.h&gt;
+
+#if defined(Q_SPARCWORKS_FUNCP_BUG)
+#define Q_AMPERSAND
+#else
+#define Q_AMPERSAND &amp;
+#endif
+
+
+const char *PlayerAnswer::className() const
+{
+    return &quot;PlayerAnswer&quot;;
+}
+
+QMetaObject *PlayerAnswer::metaObj = 0;
+
+void PlayerAnswer::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QObject::className(), &quot;QObject&quot;) != 0 )
+	badSuperclassWarning(&quot;PlayerAnswer&quot;,&quot;QObject&quot;);
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString PlayerAnswer::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)-&gt;translate(&quot;PlayerAnswer&quot;,s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* PlayerAnswer::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QObject::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(PlayerAnswer::*m1_t0)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t1)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t2)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t3)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t4)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t5)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t6)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t7)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t8)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t9)(const QString&amp;);
+    typedef void(PlayerAnswer::*m1_t10)(const QString&amp;);
+    m1_t0 v1_0 = Q_AMPERSAND PlayerAnswer::setCondition1Line;
+    m1_t1 v1_1 = Q_AMPERSAND PlayerAnswer::setCondition2Line;
+    m1_t2 v1_2 = Q_AMPERSAND PlayerAnswer::setCondition3Line;
+    m1_t3 v1_3 = Q_AMPERSAND PlayerAnswer::setCondition4Line;
+    m1_t4 v1_4 = Q_AMPERSAND PlayerAnswer::setCondition5Line;
+    m1_t5 v1_5 = Q_AMPERSAND PlayerAnswer::setAction1Line;
+    m1_t6 v1_6 = Q_AMPERSAND PlayerAnswer::setAction2Line;
+    m1_t7 v1_7 = Q_AMPERSAND PlayerAnswer::setAction3Line;
+    m1_t8 v1_8 = Q_AMPERSAND PlayerAnswer::setAction4Line;
+    m1_t9 v1_9 = Q_AMPERSAND PlayerAnswer::setAction5Line;
+    m1_t10 v1_10 = Q_AMPERSAND PlayerAnswer::setAppearCondition;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(11);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(11);
+    slot_tbl[0].name = &quot;setCondition1Line(const QString&amp;)&quot;;
+    slot_tbl[0].ptr = *((QMember*)&amp;v1_0);
+    slot_tbl_access[0] = QMetaData::Public;
+    slot_tbl[1].name = &quot;setCondition2Line(const QString&amp;)&quot;;
+    slot_tbl[1].ptr = *((QMember*)&amp;v1_1);
+    slot_tbl_access[1] = QMetaData::Public;
+    slot_tbl[2].name = &quot;setCondition3Line(const QString&amp;)&quot;;
+    slot_tbl[2].ptr = *((QMember*)&amp;v1_2);
+    slot_tbl_access[2] = QMetaData::Public;
+    slot_tbl[3].name = &quot;setCondition4Line(const QString&amp;)&quot;;
+    slot_tbl[3].ptr = *((QMember*)&amp;v1_3);
+    slot_tbl_access[3] = QMetaData::Public;
+    slot_tbl[4].name = &quot;setCondition5Line(const QString&amp;)&quot;;
+    slot_tbl[4].ptr = *((QMember*)&amp;v1_4);
+    slot_tbl_access[4] = QMetaData::Public;
+    slot_tbl[5].name = &quot;setAction1Line(const QString&amp;)&quot;;
+    slot_tbl[5].ptr = *((QMember*)&amp;v1_5);
+    slot_tbl_access[5] = QMetaData::Public;
+    slot_tbl[6].name = &quot;setAction2Line(const QString&amp;)&quot;;
+    slot_tbl[6].ptr = *((QMember*)&amp;v1_6);
+    slot_tbl_access[6] = QMetaData::Public;
+    slot_tbl[7].name = &quot;setAction3Line(const QString&amp;)&quot;;
+    slot_tbl[7].ptr = *((QMember*)&amp;v1_7);
+    slot_tbl_access[7] = QMetaData::Public;
+    slot_tbl[8].name = &quot;setAction4Line(const QString&amp;)&quot;;
+    slot_tbl[8].ptr = *((QMember*)&amp;v1_8);
+    slot_tbl_access[8] = QMetaData::Public;
+    slot_tbl[9].name = &quot;setAction5Line(const QString&amp;)&quot;;
+    slot_tbl[9].ptr = *((QMember*)&amp;v1_9);
+    slot_tbl_access[9] = QMetaData::Public;
+    slot_tbl[10].name = &quot;setAppearCondition(const QString&amp;)&quot;;
+    slot_tbl[10].ptr = *((QMember*)&amp;v1_10);
+    slot_tbl_access[10] = QMetaData::Public;
+    metaObj = QMetaObject::new_metaobject(
+	&quot;PlayerAnswer&quot;, &quot;QObject&quot;,
+	slot_tbl, 11,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj-&gt;set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}
+
+
+const char *NodeItem::className() const
+{
+    return &quot;NodeItem&quot;;
+}
+
+QMetaObject *NodeItem::metaObj = 0;
+
+void NodeItem::initMetaObject()
+{
+    if ( metaObj )
+	return;
+    if ( strcmp(QObject::className(), &quot;QObject&quot;) != 0 )
+	badSuperclassWarning(&quot;NodeItem&quot;,&quot;QObject&quot;);
+    (void) staticMetaObject();
+}
+
+#ifndef QT_NO_TRANSLATION
+QString NodeItem::tr(const char* s)
+{
+    return ((QNonBaseApplication*)qApp)-&gt;translate(&quot;NodeItem&quot;,s);
+}
+
+#endif // QT_NO_TRANSLATION
+QMetaObject* NodeItem::staticMetaObject()
+{
+    if ( metaObj )
+	return metaObj;
+    (void) QObject::staticMetaObject();
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    typedef void(NodeItem::*m1_t0)(const QString&amp;);
+    typedef void(NodeItem::*m1_t1)(const QString&amp;);
+    typedef void(NodeItem::*m1_t2)(const QString&amp;);
+    typedef void(NodeItem::*m1_t3)(const QString&amp;);
+    typedef void(NodeItem::*m1_t4)(const QString&amp;);
+    typedef void(NodeItem::*m1_t5)(const QString&amp;);
+    typedef void(NodeItem::*m1_t6)(const QString&amp;);
+    m1_t0 v1_0 = Q_AMPERSAND NodeItem::setID;
+    m1_t1 v1_1 = Q_AMPERSAND NodeItem::setName;
+    m1_t2 v1_2 = Q_AMPERSAND NodeItem::setMusic;
+    m1_t3 v1_3 = Q_AMPERSAND NodeItem::setPicture;
+    m1_t4 v1_4 = Q_AMPERSAND NodeItem::setAlienText;
+    m1_t5 v1_5 = Q_AMPERSAND NodeItem::setTextLocation;
+    m1_t6 v1_6 = Q_AMPERSAND NodeItem::setFont;
+    QMetaData *slot_tbl = QMetaObject::new_metadata(7);
+    QMetaData::Access *slot_tbl_access = QMetaObject::new_metaaccess(7);
+    slot_tbl[0].name = &quot;setID(const QString&amp;)&quot;;
+    slot_tbl[0].ptr = *((QMember*)&amp;v1_0);
+    slot_tbl_access[0] = QMetaData::Public;
+    slot_tbl[1].name = &quot;setName(const QString&amp;)&quot;;
+    slot_tbl[1].ptr = *((QMember*)&amp;v1_1);
+    slot_tbl_access[1] = QMetaData::Public;
+    slot_tbl[2].name = &quot;setMusic(const QString&amp;)&quot;;
+    slot_tbl[2].ptr = *((QMember*)&amp;v1_2);
+    slot_tbl_access[2] = QMetaData::Public;
+    slot_tbl[3].name = &quot;setPicture(const QString&amp;)&quot;;
+    slot_tbl[3].ptr = *((QMember*)&amp;v1_3);
+    slot_tbl_access[3] = QMetaData::Public;
+    slot_tbl[4].name = &quot;setAlienText(const QString&amp;)&quot;;
+    slot_tbl[4].ptr = *((QMember*)&amp;v1_4);
+    slot_tbl_access[4] = QMetaData::Public;
+    slot_tbl[5].name = &quot;setTextLocation(const QString&amp;)&quot;;
+    slot_tbl[5].ptr = *((QMember*)&amp;v1_5);
+    slot_tbl_access[5] = QMetaData::Public;
+    slot_tbl[6].name = &quot;setFont(const QString&amp;)&quot;;
+    slot_tbl[6].ptr = *((QMember*)&amp;v1_6);
+    slot_tbl_access[6] = QMetaData::Public;
+    metaObj = QMetaObject::new_metaobject(
+	&quot;NodeItem&quot;, &quot;QObject&quot;,
+	slot_tbl, 7,
+	0, 0,
+#ifndef QT_NO_PROPERTIES
+	0, 0,
+	0, 0,
+#endif // QT_NO_PROPERTIES
+	0, 0 );
+    metaObj-&gt;set_slot_access( slot_tbl_access );
+#ifndef QT_NO_PROPERTIES
+#endif // QT_NO_PROPERTIES
+    return metaObj;
+}

Added: trunk/Util/deditor/node.cpp
===================================================================
--- trunk/Util/deditor/node.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/node.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,111 @@
+
+#include &quot;node.h&quot;
+
+PlayerAnswer::PlayerAnswer()
+{
+	m_strAppearCondition = &quot;&quot;;
+	m_strText = &quot;&quot;;
+
+	m_strCond[0] = &quot;&quot;;
+	m_strCond[1] = &quot;&quot;;
+	m_strCond[2] = &quot;&quot;;
+	m_strCond[3] = &quot;&quot;;
+	m_strCond[4] = &quot;&quot;;
+
+	m_strAct[0] = &quot;&quot;;
+	m_strAct[1] = &quot;&quot;;
+	m_strAct[2] = &quot;&quot;;
+	m_strAct[3] = &quot;&quot;;
+	m_strAct[4] = &quot;&quot;;
+}
+
+void PlayerAnswer::setCondition1Line(const QString&amp; text)
+{
+	m_strCond[0] = text;
+}
+void PlayerAnswer::setCondition2Line(const QString&amp; text)
+{
+	m_strCond[1] = text;
+}
+void PlayerAnswer::setCondition3Line(const QString&amp; text)
+{
+	m_strCond[2] = text;
+}
+void PlayerAnswer::setCondition4Line(const QString&amp; text)
+{
+	m_strCond[3] = text;
+}
+void PlayerAnswer::setCondition5Line(const QString&amp; text)
+{
+	m_strCond[4] = text;
+}
+
+
+void PlayerAnswer::setAction1Line(const QString&amp; text)
+{
+	m_strAct[0] = text;
+}
+void PlayerAnswer::setAction2Line(const QString&amp; text)
+{
+	m_strAct[1] = text;
+}
+void PlayerAnswer::setAction3Line(const QString&amp; text)
+{
+	m_strAct[2] = text;
+}
+void PlayerAnswer::setAction4Line(const QString&amp; text)
+{
+	m_strAct[3] = text;
+}
+
+void PlayerAnswer::setAction5Line(const QString&amp; text)
+{
+	m_strAct[4] = text;
+}
+
+void PlayerAnswer::setAppearCondition(const QString&amp; text)
+{
+	m_strAppearCondition = text;
+}
+
+
+NodeItem::NodeItem ( QListView * parent ):
+	QListViewItem(parent) 
+{
+		m_strMusic = &quot;&quot;;
+		m_strPicture = &quot;&quot;;
+		m_strAlienText =&quot;&quot;;
+		m_strTextLocation = &quot;&quot;;
+		m_strFont = &quot;&quot;;
+}; 
+
+void NodeItem::setID       ( const QString &amp; text)
+{
+	setText(0,text);
+}
+void NodeItem::setName     ( const QString &amp; text)
+{
+	setText(1,text);
+}
+void NodeItem::setMusic    ( const QString &amp; text)
+{
+	m_strMusic = text;
+}
+void NodeItem::setPicture  ( const QString &amp; text)
+{
+	m_strPicture = text;
+}
+void NodeItem::setAlienText( const QString &amp; text)
+{
+	m_strAlienText = text;
+}
+void NodeItem::setTextLocation(const QString&amp; text)
+{
+	m_strTextLocation = text;
+}
+
+void NodeItem::setFont(const QString&amp; text)
+{
+	m_strFont = text;
+}
+

Added: trunk/Util/deditor/node.h
===================================================================
--- trunk/Util/deditor/node.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/node.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,62 @@
+#ifndef TW_DIALOG_EDITOR_NODE
+#define TW_DIALOG_EDITOR_NODE
+
+#include &lt;qlistview.h&gt;
+#include &lt;qstring.h&gt;
+#include &lt;qlistbox.h&gt;
+#include &lt;qsortedlist.h&gt;
+
+class PlayerAnswer : public QObject
+{
+	Q_OBJECT
+public:
+	PlayerAnswer();
+	
+	QString m_strText;
+	QString m_strAppearCondition;
+
+	QString m_strCond[5];
+	QString m_strAct[5];
+
+public slots:
+	virtual void setCondition1Line(const QString&amp;);
+	virtual void setCondition2Line(const QString&amp;);
+	virtual void setCondition3Line(const QString&amp;);
+	virtual void setCondition4Line(const QString&amp;);
+	virtual void setCondition5Line(const QString&amp;);
+	virtual void setAction1Line(const QString&amp;);
+	virtual void setAction2Line(const QString&amp;);
+	virtual void setAction3Line(const QString&amp;);
+	virtual void setAction4Line(const QString&amp;);
+	virtual void setAction5Line(const QString&amp;);
+	virtual void setAppearCondition(const QString&amp;);
+};
+
+
+class NodeItem : public QObject, public QListViewItem
+{ 
+  Q_OBJECT
+	// column 0 - String id, 1 - string name
+public:
+
+	NodeItem ( QListView * parent ); 
+
+	QString m_strMusic;
+	QString m_strPicture;
+	QString m_strAlienText;
+	QString m_strTextLocation;
+	QString m_strFont;
+
+	QList&lt;PlayerAnswer&gt; m_answers;
+public slots:
+	virtual void setID       ( const QString &amp; text);
+	virtual void setName     ( const QString &amp; text);
+	virtual void setMusic    ( const QString &amp; text);
+	virtual void setPicture  ( const QString &amp; text);
+	virtual void setAlienText( const QString &amp; text);
+	virtual void setTextLocation(const QString&amp; text);
+	virtual void setFont(const QString&amp; text);
+};
+
+
+#endif

Added: trunk/Util/deditor/removenode.xpm
===================================================================
--- trunk/Util/deditor/removenode.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/removenode.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *removenode_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #ffff00&quot;,
+&quot;c c #00ffff&quot;,
+&quot;c..............c&quot;,
+&quot;.c............c.&quot;,
+&quot;..c...a....a.c..&quot;,
+&quot;..bc..a....ac...&quot;,
+&quot;.b..c.aa...c....&quot;,
+&quot;.b...ca.a.ca....&quot;,
+&quot;.b....c.ac.a....&quot;,
+&quot;.b..b.acca.a....&quot;,
+&quot;..bb..acca.a....&quot;,
+&quot;......c..caa....&quot;,
+&quot;.....c....c.....&quot;,
+&quot;....c......c....&quot;,
+&quot;...c........c...&quot;
+};

Added: trunk/Util/deditor/rmplayeranswer.xpm
===================================================================
--- trunk/Util/deditor/rmplayeranswer.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/rmplayeranswer.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *rmplayeranswer_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #00000&quot;,
+&quot;c c #f3f7f3&quot;,
+&quot;caaaaaaaaaaaaaac&quot;,
+&quot;acaaabbbbbbbaaca&quot;,
+&quot;aacaaaaabaaaacaa&quot;,
+&quot;aaacaaaabaaacaaa&quot;,
+&quot;aaaacaabbbacaaaa&quot;,
+&quot;aaaaacabbbcaaaaa&quot;,
+&quot;aaaaaacbbcbaaaaa&quot;,
+&quot;aaaaaaaccaaaaaaa&quot;,
+&quot;aabbbbbccbbbbbaa&quot;,
+&quot;aabbbbcbbcbbbbaa&quot;,
+&quot;aabbbcbbbbcbbbaa&quot;,
+&quot;aabbcbbbbbbcbbaa&quot;,
+&quot;aaacaaaaaaaacaaa&quot;
+};

Added: trunk/Util/deditor/setalientext.xpm
===================================================================
--- trunk/Util/deditor/setalientext.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/setalientext.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *setalientext_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #00000&quot;,
+&quot;c c #f3f7f3&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaabbbbbbbaaaa&quot;,
+&quot;aaaaaaaabaaaaaaa&quot;,
+&quot;aaaaaaaabaaaaaaa&quot;,
+&quot;aaaaaaabbbaaaaaa&quot;,
+&quot;aaaaaaabbbaaaaaa&quot;,
+&quot;aaaaaabbbbbaaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;,
+&quot;aaaaa#########aa&quot;,
+&quot;aaaa#########aaa&quot;,
+&quot;aaa#########aaaa&quot;,
+&quot;aa#########aaaaa&quot;,
+&quot;aaaaaaaaaaaaaaaa&quot;
+};

Added: trunk/Util/deditor/setplayeranswertext.xpm
===================================================================
--- trunk/Util/deditor/setplayeranswertext.xpm	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/setplayeranswertext.xpm	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,22 @@
+/* XPM */
+static const char *setplayeranswertext_xpm[] = {
+&quot;    16    13        5            1&quot;,
+&quot;. c #040404&quot;,
+&quot;# c #808304&quot;,
+&quot;a c None&quot;,
+&quot;b c #00000&quot;,
+&quot;c c #f3f7f3&quot;,
+&quot;................&quot;,
+&quot;................&quot;,
+&quot;aacaaa...aaaacaa&quot;,
+&quot;aaacaa...aaacaaa&quot;,
+&quot;aaaaca...aaaaaaa&quot;,
+&quot;aaaaac...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaac...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;,
+&quot;aaaaaa...aaaaaaa&quot;
+};

Added: trunk/Util/deditor/xmlparser.cpp
===================================================================
--- trunk/Util/deditor/xmlparser.cpp	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/xmlparser.cpp	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,185 @@
+#include &quot;xmlparser.h&quot;
+#include &lt;iostream.h&gt;
+#include &lt;qstring.h&gt;
+#include &lt;qlineedit.h&gt;
+#include &lt;qmessagebox.h&gt; 
+#include &lt;assert.h&gt;
+
+#include &quot;mainwidget.h&quot;
+#include &quot;node.h&quot;
+
+
+XMLParser::XMLParser(DialogEditor* editor)
+{
+	WriteLog(&quot;XMLParser::XMLParser\n&quot;);
+	m_dialogEditor = editor;
+	curAnswer = NULL;
+	curNode   = NULL;
+}
+
+bool XMLParser::startDocument()
+{
+	WriteLog(&quot;XMLParser::startDocument()\n&quot;);
+	m_dialogEditor-&gt;nodeListView-&gt;clear();
+    return TRUE;
+}
+
+bool XMLParser::startElement( const QString&amp;, const QString&amp;, 
+                                    const QString&amp; qName, 
+                                    const QXmlAttributes&amp; attr)
+{
+	WriteLog(&quot;XMLParser::startElement\n&quot;);
+	if (qName==&quot;NODES&quot;)
+	{
+	}
+	else if (qName==&quot;NODE&quot;)
+	{
+		QString strId =&quot;&quot;, strName = &quot;&quot;, strMusic =&quot;&quot;, strBack =&quot;&quot;;
+		QString strAlienText = &quot;&quot;;
+		QString strFont = &quot;&quot;, strTextLocation =&quot;&quot;;
+
+		for(int i=0; i&lt; attr.length();i++)
+		{
+			if(attr.localName(i)==&quot;id&quot;)
+			{
+				strId = attr.value(i);
+			}
+			else
+			if(attr.localName(i)==&quot;name&quot;)
+			{
+				strName = attr.value(i);
+			}
+			else
+			if(attr.localName(i)==&quot;music&quot;)
+			{
+				strMusic = attr.value(i);
+			}
+			else
+			if(attr.localName(i)==&quot;background&quot;)
+			{
+				strBack = attr.value(i);
+			}
+			else
+			if(attr.localName(i)==&quot;alien_text&quot;)
+			{
+				strAlienText = attr.value(i);
+			}
+			else
+			if(attr.localName(i)==&quot;font&quot;)
+			{
+				strFont = attr.value(i);
+			}
+			else
+			if(attr.localName(i)==&quot;text_location&quot;)
+			{
+				strTextLocation = attr.value(i);
+			}
+			else
+			{
+				QMessageBox::warning (m_dialogEditor, &quot;TW-Light editor&quot;,
+				QString(&quot;Unknown attribute: &quot;) + attr.localName(i));
+			}
+		}
+		curNode = new NodeItem ( m_dialogEditor-&gt;nodeListView );
+
+		curNode-&gt;setID          ( strId );
+		curNode-&gt;setName        ( strName );
+		curNode-&gt;setMusic       ( strMusic );
+		curNode-&gt;setPicture     ( strBack);
+		curNode-&gt;setAlienText   ( strAlienText );
+		curNode-&gt;setFont        ( strFont );
+		curNode-&gt;setTextLocation( strTextLocation);
+
+	}
+	else if(qName==&quot;PLAYER_ANSWER&quot;)
+	{
+		assert(curNode&amp;&amp;&quot;Cant locate Dialog Node in XML!!!&quot;);
+		curAnswer = new PlayerAnswer;
+
+		QString strText = &quot;&quot;, strAppearCondition = &quot;&quot;;
+		for(int i=0; i&lt; attr.length();i++)
+		{
+			if(attr.localName(i)==&quot;text&quot;)
+			{
+				
+				strText = attr.value(i);
+			}
+			else if (attr.localName(i)==&quot;appear_condition&quot;)
+			{
+				strAppearCondition = attr.value(i);
+			}
+			else
+			{
+				QMessageBox::warning (m_dialogEditor, &quot;TW-Light editor&quot;,
+				QString(&quot;Unknown attribute: &quot;) + attr.localName(i));
+			}
+		}
+		curAnswer-&gt;m_strText = strText;
+		curAnswer-&gt;setAppearCondition( strAppearCondition);
+	}
+	else if(qName==&quot;ACTION&quot;)
+	{
+		assert(curAnswer);
+		int j;
+		for(j=0; j&lt;5;j++)
+			if(curAnswer-&gt;m_strAct[j].isEmpty()&amp;&amp;
+			   curAnswer-&gt;m_strCond[j].isEmpty())
+			    break;
+		QString strCondition = &quot;&quot;;
+		QString strAction    = &quot;&quot;;
+		for(int i=0; i&lt; attr.length();i++)
+		{
+			if(attr.localName(i)==&quot;condition&quot;)
+			{
+				
+				strCondition = attr.value(i);
+			}
+			else if (attr.localName(i)==&quot;action&quot;)
+			{
+				strAction = attr.value(i);
+			}
+			else
+			{
+				QMessageBox::warning (m_dialogEditor, &quot;TW-Light editor&quot;,
+				QString(&quot;Unknown attribute: &quot;) + attr.localName(i));
+			}
+		}
+		curAnswer-&gt;m_strAct[j] = strAction;
+		curAnswer-&gt;m_strCond[j] = strCondition;
+	}
+	else
+	{
+		QMessageBox::warning (m_dialogEditor, &quot;TW-Light editor&quot;,
+			QString(&quot;Unknown Node: &quot;) + qName);
+	}
+
+    return TRUE;
+}
+
+bool XMLParser::endElement( const QString &amp; namespaceURI, const QString &amp; localName, const QString &amp; qName ) 
+{
+	WriteLog(&quot;XMLParser::endElement\n&quot;);
+	if(qName==&quot;NODES&quot;)
+	{
+	}
+	else if (qName==&quot;NODE&quot;)
+	{
+		m_dialogEditor-&gt;nodeListView-&gt;setCurrentItem(curNode);
+		curNode=NULL;
+	}
+	else if(qName==&quot;PLAYER_ANSWER&quot;)
+	{
+		curNode-&gt;m_answers.append(curAnswer);
+		curAnswer = NULL;
+	}
+	else if(qName==&quot;ACTION&quot;)
+	{
+	}
+	else
+	{
+		QMessageBox::warning (m_dialogEditor, &quot;TW-Light editor&quot;,
+			QString(&quot;Unknown Node: &quot;) + qName);
+	}
+    return TRUE;
+}
+

Added: trunk/Util/deditor/xmlparser.h
===================================================================
--- trunk/Util/deditor/xmlparser.h	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/Util/deditor/xmlparser.h	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,30 @@
+#ifndef __TW_XMLPARSER_H__
+#define __TW_XMLPARSER_H__
+
+#include &lt;qxml.h&gt;
+
+class QString;
+class DialogEditor;
+class NodeItem;
+class PlayerAnswer;
+
+class XMLParser : public QXmlDefaultHandler
+{
+private:
+	DialogEditor * m_dialogEditor;
+
+	NodeItem * curNode;
+	PlayerAnswer * curAnswer;
+public:
+	XMLParser(DialogEditor* editor);
+    bool startDocument();
+    bool startElement( const QString&amp;, const QString&amp;, const QString&amp; , 
+                       const QXmlAttributes&amp; attr);
+    bool endElement( const QString&amp;, const QString&amp;, const QString&amp; );
+
+private:
+    QString indent;
+};                   
+
+#endif
+

Added: trunk/web/3dlogo.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/web/3dlogo.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/web/background.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/web/background.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/web/dialog-editor-win32-62.zip
===================================================================
(Binary files differ)


Property changes on: trunk/web/dialog-editor-win32-62.zip
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/web/downloads.html
===================================================================
--- trunk/web/downloads.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/downloads.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,54 @@
+&lt;html&gt;
+
+&lt;head&gt;
+&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; title=&quot;default&quot;/&gt;
+&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=windows-1251&quot;&gt;
+&lt;meta name=&quot;description&quot; content=&quot;Homepage of TW-Light.&quot;&gt;
+&lt;meta name=&quot;keywords&quot; content=&quot;TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW&quot;&gt;
+&lt;title&gt;TW-Light&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;div class=&quot;navbar&quot;&gt;
+  &lt;table class=&quot;navlinks&quot; summary=&quot;navigation bar&quot;&gt;
+    &lt;tr&gt;
+      &lt;td&gt;
+        &lt;img src=&quot;./3dlogo.jpg&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;120&quot; /&gt; 
+      &lt;/td&gt;
+      &lt;td&gt;
+      &lt;a href=&quot;./index.html&quot;&gt;News&lt;/a&gt; | &lt;a href=&quot;./info.html&quot;&gt;Info&lt;/a&gt; | &lt;a href=&quot;./team.html&quot;&gt;Team&lt;/a&gt; | &lt;a  id=&quot;curpagelink&quot; href=&quot;./downloads.html&quot;&gt;Downloads&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">http://openfacts.berlios.de/index-en.phtml?title=TW-Light</A>&quot;&gt;Wiki&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">http://bugs.cs.iupui.edu/cgi-bin/bugzilla/</A>&quot;&gt;Bug Database&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net/forum/index.php">http://timewarp.sourceforge.net/forum/index.php</A>&quot;&gt;Forum&lt;/a&gt; | &lt;a href=&quot;./links.html&quot;&gt;Links&lt;/a&gt;
+      &lt;/td&gt;
+    &lt;/tr&gt;
+  &lt;/table&gt;
+&lt;/div&gt;
+
+&lt;div class=&quot;main&quot;&gt;
+  &lt;h2&gt;Downloads&lt;/h2&gt;
+  
+&lt;p class=&quot;indented&quot;&gt;
+The latest version is &lt;b&gt;0.2r16&lt;/b&gt;. You can download it &lt;a href=&quot;<A HREF="http://developer.berlios.de/project/showfiles.php?group_id=2082&amp;release_id=3153">http://developer.berlios.de/project/showfiles.php?group_id=2082&amp;release_id=3153</A>&quot;&gt;here.&lt;/a&gt;
+
+&lt;p class=&quot;indented&quot;&gt;
+To successfully compile the sources and play the game on Linux/Unix you first need 
+&lt;a href=&quot;<A HREF="http://www.allegro.cc/files/index.html">http://www.allegro.cc/files/index.html</A>&quot;&gt;Allegro&lt;/a&gt;, SDL 1.2.5 (or newer),
+libogg and libvorbis installed, See makefile after unpacking for more instructions.
+	&lt;!--	
+	 and &lt;a href=&quot;<A HREF="http://www.lua.org">http://www.lua.org</A>&quot;&gt;Lua&lt;/a&gt;
+	View &lt;a href=&quot;&quot;&gt;ChangeLog&lt;/a&gt; to see the list of the latest changes.&lt;br&gt;
+	--&gt;
+&lt;/p&gt;
+&lt;p class=&quot;indented&quot;&gt;
+If you want to contribute TW-Light by writting good dialogs, download and use 
+our dialog editor. The latest version is &lt;b&gt;62&lt;/b&gt;. You can download Windows binaries 
+&lt;a href=&quot;./dialog-editor-win32-62.zip&quot;&gt;here&lt;/a&gt;.
+&lt;/p&gt;
+&lt;/div&gt;
+
+&lt;p align=&quot;left&quot;&gt;&lt;font size=&quot;3&quot;&gt;&lt;strong&gt;this page is hosted by&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
+&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
+&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;<A HREF="http://developer.berlios.de">http://developer.berlios.de</A>&quot; title=&quot;BerliOS Developer&quot;&gt; &lt;img src=&quot;<A HREF="http://developer.berlios.de/bslogo.php?group_id=2082">http://developer.berlios.de/bslogo.php?group_id=2082</A>&quot; width=&quot;124px&quot; height=&quot;32px&quot; border=&quot;0&quot; alt=&quot;BerliOS Developer Logo&quot;&gt;&lt;/a&gt;
+&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;	
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file

Modified: trunk/web/index.html
===================================================================
--- trunk/web/index.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/index.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -14,7 +14,7 @@
   &lt;table class=&quot;navlinks&quot; summary=&quot;navigation bar&quot;&gt;
     &lt;tr&gt;
       &lt;td&gt;
-        &lt;img src=&quot;./snapshot.png&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;120&quot; /&gt; 
+        &lt;img src=&quot;./3dlogo.jpg&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;120&quot; /&gt; 
       &lt;/td&gt;
       &lt;td&gt;
       &lt;a id=&quot;curpagelink&quot; href=&quot;./index.html&quot;&gt;News&lt;/a&gt; | &lt;a href=&quot;./info.html&quot;&gt;Info&lt;/a&gt; | &lt;a href=&quot;./team.html&quot;&gt;Team&lt;/a&gt; | &lt;a  href=&quot;./downloads.html&quot;&gt;Downloads&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">http://openfacts.berlios.de/index-en.phtml?title=TW-Light</A>&quot;&gt;Wiki&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">http://bugs.cs.iupui.edu/cgi-bin/bugzilla/</A>&quot;&gt;Bug Database&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net/forum/index.php">http://timewarp.sourceforge.net/forum/index.php</A>&quot;&gt;Forum&lt;/a&gt; | &lt;a href=&quot;./links.html&quot;&gt;Links&lt;/a&gt;

Added: trunk/web/info.html
===================================================================
--- trunk/web/info.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/info.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,122 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; title=&quot;default&quot;/&gt;
+&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=windows-1251&quot;&gt;
+&lt;meta name=&quot;description&quot; content=&quot;Homepage of TW-Light.&quot;&gt;
+&lt;meta name=&quot;keywords&quot; content=&quot;TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW&quot;&gt;
+&lt;title&gt;TW-Light&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;div class=&quot;navbar&quot;&gt;
+  &lt;table class=&quot;navlinks&quot; summary=&quot;navigation bar&quot;&gt;
+    &lt;tr&gt;
+      &lt;td&gt;
+        &lt;img src=&quot;./3dlogo.jpg&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;120&quot; /&gt; 
+      &lt;/td&gt;
+      &lt;td&gt;
+      &lt;a href=&quot;./index.html&quot;&gt;News&lt;/a&gt; | &lt;a id=&quot;curpagelink&quot; href=&quot;./info.html&quot;&gt;Info&lt;/a&gt; | &lt;a href=&quot;./team.html&quot;&gt;Team&lt;/a&gt; | &lt;a  href=&quot;./downloads.html&quot;&gt;Downloads&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">http://openfacts.berlios.de/index-en.phtml?title=TW-Light</A>&quot;&gt;Wiki&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">http://bugs.cs.iupui.edu/cgi-bin/bugzilla/</A>&quot;&gt;Bug Database&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net/forum/index.php">http://timewarp.sourceforge.net/forum/index.php</A>&quot;&gt;Forum&lt;/a&gt; | &lt;a href=&quot;./links.html&quot;&gt;Links&lt;/a&gt;
+      &lt;/td&gt;
+    &lt;/tr&gt;
+  &lt;/table&gt;
+&lt;/div&gt;
+
+&lt;div class=&quot;main&quot;&gt;
+  &lt;h2&gt;Game Info&lt;/h2&gt;
+  &lt;h3 class=&quot;important&quot;&gt;Story Info&lt;/h3&gt;
+  
+  &lt;p class=&quot;indented&quot;&gt;
+  The Ur-quan are defeated - the destruction of the Sa-matra threw them into chaos, 
+  making them easy prey for the New Alliance of Free Stars. Within weeks the NAFS 
+  forces managed to destroy most of the fleets of the two races who terrorized the 
+  galaxy for the past 20,000 years!
+  &lt;/p&gt;
+  
+  &lt;p class=&quot;indented&quot;&gt;
+  Thanks to you, hope is given to the entire galaxy, and especially to the human race. 
+  Now free from their prison under a Slaveshield it's Humanity's time to rebuild.
+  &lt;/p&gt;
+  
+  &lt;p class=&quot;indented&quot;&gt;
+  However, it seems there are more troubles ahead, according to a vision of 
+  the Pkunk Queen.
+  &lt;/p&gt;
+  
+  &lt;p class=&quot;indented&quot;&gt;
+  It is up to you to save the galaxy again. It's a dirty job, but someone got to do it!
+  &lt;/p&gt;
+  
+  &lt;p class=&quot;indented&quot;&gt;
+  And you must do it with nothing more then a mighty alliance of races 
+  and a bunch of powerful friends at your side! Or so you believe...
+  &lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;
+  TWX:Legacies will start right after StarControl II.
+  &lt;/p&gt;
+  
+  &lt;p class=&quot;indented&quot;&gt;
+  The player is back into the shoes of the famous captain from the last game and 
+  will be continuing his adventures.
+  &lt;/p&gt;
+  
+  &lt;p class=&quot;indented&quot;&gt;Game Features:&lt;/p&gt;
+
+&lt;blockquote&gt;
+  &lt;p class=&quot;indented&quot;&gt;1) All the races from SCII.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;&nbsp;2) Bigger and expended Starmap.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;3) 13 completly new alien races.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;4) Development of the Arilou, Orz and Precursor mysteries.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;5) New interesting quests, mysteries and quesions.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;6) The MarkII.&lt;/p&gt;
+
+  &lt;p class=&quot;indented&quot;&gt;7) The origin of the Mmrnmhrm.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;8) Dangerous Space Monsters. &lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;9) Many special missions and boss fights.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;10) Modular flagship (like SCII) and Precursor upgrades for normal ships.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;11) Bonus quests and hidden surprises.&lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;12) New characters that help the player during the game. &lt;/p&gt;
+
+  &lt;p class=&quot;indented&quot;&gt;13) Your chance to develop your relations with the beautiful Talana to the next level! &lt;/p&gt;
+  &lt;p class=&quot;indented&quot;&gt;14) And so much more...&lt;/p&gt;
+&lt;/blockquote&gt;
+  
+  &lt;h3&gt;development&lt;/h3&gt;
+  
+&lt;p class=&quot;indented&quot;&gt;
+TW-Light is developed by a group of Star Control fans. Though the game is quite playable 
+now, it is far from being complete. The development of this game is still going 
+on. Please note, that this is a &lt;b&gt;real project&lt;/b&gt;, not just a collection of 
+plans, ideas and dreams like in some other places in the net.
+&lt;/p&gt;
+&lt;p class=&quot;indented&quot;&gt;
+Things may seem to change slow, but there is real progress and every new version 
+is (we hope ;-) better than previous one. Anyway it is better to have a working 
+game than lots of ideas, but no code at all. All the work is done in our spare 
+time, so don't expect that your nice suggestion will be implemented in a short 
+time. If you are badly missing some feature and think that you can make it 
+youself, your patch will be welcome (if it does not break all the rest ;-)
+&lt;/p&gt;
+&lt;p class=&quot;indented&quot;&gt;
+You can support the project by participating discussion in 
+&lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net/forum/index.php">http://timewarp.sourceforge.net/forum/index.php</A>&quot;&gt;TimeWarp forum&lt;/a&gt;, 
+where you can post suggestions for future development or just any questions about TW-Light.
+&lt;/p&gt;
+&lt;p class=&quot;indented&quot;&gt;
+You can support the project by posting bugreports and patches in 
+&lt;a href=&quot;<A HREF="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">http://bugs.cs.iupui.edu/cgi-bin/bugzilla/</A>&quot;&gt;TW-Light Bugzilla&lt;/a&gt;
+&lt;/p&gt;
+
+&lt;p class=&quot;indented&quot;&gt;
+&lt;a href=&quot;<A HREF="http://svn.berlios.de/viewcvs/tw-light/">http://svn.berlios.de/viewcvs/tw-light/</A>&quot;&gt;TW-Light SVN repository&lt;/a&gt; 
+&lt;/p&gt;
+
+&lt;/div&gt;
+
+&lt;p align=&quot;left&quot;&gt;&lt;font size=&quot;3&quot;&gt;&lt;strong&gt;this page is hosted by&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
+&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
+&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;<A HREF="http://developer.berlios.de">http://developer.berlios.de</A>&quot; title=&quot;BerliOS Developer&quot;&gt; &lt;img src=&quot;<A HREF="http://developer.berlios.de/bslogo.php?group_id=2082">http://developer.berlios.de/bslogo.php?group_id=2082</A>&quot; width=&quot;124px&quot; height=&quot;32px&quot; border=&quot;0&quot; alt=&quot;BerliOS Developer Logo&quot;&gt;&lt;/a&gt;
+&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
+	
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file

Added: trunk/web/links.html
===================================================================
--- trunk/web/links.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/links.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,49 @@
+&lt;html&gt;
+
+&lt;head&gt;
+&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; title=&quot;default&quot;/&gt;
+&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=windows-1251&quot;&gt;
+&lt;meta name=&quot;description&quot; content=&quot;Homepage of TW-Light.&quot;&gt;
+&lt;meta name=&quot;keywords&quot; content=&quot;TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW&quot;&gt;
+&lt;title&gt;TW-Light&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;div class=&quot;navbar&quot;&gt;
+  &lt;table class=&quot;navlinks&quot; summary=&quot;navigation bar&quot;&gt;
+    &lt;tr&gt;
+      &lt;td&gt;
+        &lt;img src=&quot;./3dlogo.jpg&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;120&quot; /&gt; 
+      &lt;/td&gt;
+      &lt;td&gt;
+      &lt;a href=&quot;./index.html&quot;&gt;News&lt;/a&gt; | &lt;a href=&quot;./info.html&quot;&gt;Info&lt;/a&gt; | &lt;a href=&quot;./team.html&quot;&gt;Team&lt;/a&gt; | &lt;a href=&quot;./downloads.html&quot;&gt;Downloads&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">http://openfacts.berlios.de/index-en.phtml?title=TW-Light</A>&quot;&gt;Wiki&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">http://bugs.cs.iupui.edu/cgi-bin/bugzilla/</A>&quot;&gt;Bug Database&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net/forum/index.php">http://timewarp.sourceforge.net/forum/index.php</A>&quot;&gt;Forum&lt;/a&gt; | &lt;a id=&quot;curpagelink&quot; href=&quot;./links.html&quot;&gt;Links&lt;/a&gt;
+      &lt;/td&gt;
+    &lt;/tr&gt;
+  &lt;/table&gt;
+&lt;/div&gt;
+
+&lt;div class=&quot;main&quot;&gt;
+  &lt;h3&gt;TW-Light resources&lt;/h3&gt;
+  &lt;ul&gt;
+    &lt;li&gt;&lt;a href=&quot;<A HREF="http://developer.berlios.de/projects/tw-light/">http://developer.berlios.de/projects/tw-light/</A>&quot;&gt;BerliOS: TW-Light Project Info&lt;/a&gt;&lt;/li&gt;
+    &lt;li&gt;&lt;a href=&quot;<A HREF="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">http://bugs.cs.iupui.edu/cgi-bin/bugzilla/</A>&quot;&gt;TW-Light Bugzilla&lt;/a&gt; &lt;/li&gt;
+    &lt;li&gt;&lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net/forum/index.php">http://timewarp.sourceforge.net/forum/index.php</A>&quot;&gt;TimeWarp Forum (official)&lt;/a&gt; &lt;/li&gt;
+&lt;/ul&gt;
+
+&lt;h3&gt;Other Star Control inspired game projects in development&lt;/h3&gt;
+&lt;ul&gt;
+    &lt;li&gt;&lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net">http://timewarp.sourceforge.net</A>&quot;&gt;TimeWarp&lt;/a&gt; &lt;/li&gt;
+    &lt;li&gt;&lt;a href=&quot;<A HREF="http://sc2.sourceforge.net">http://sc2.sourceforge.net</A>&quot;&gt;The Ur-quan Masters&lt;/a&gt; &lt;/li&gt;
+    &lt;li&gt;&lt;a href=&quot;<A HREF="http://twx.sourceforge.net">http://twx.sourceforge.net</A>&quot;&gt;TWX&lt;/a&gt; &lt;/li&gt;
+&lt;/ul&gt;
+
+&lt;/div&gt;
+
+&lt;p align=&quot;left&quot;&gt;&lt;font size=&quot;3&quot;&gt;&lt;strong&gt;this page is hosted by&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
+&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
+&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;<A HREF="http://developer.berlios.de">http://developer.berlios.de</A>&quot; title=&quot;BerliOS Developer&quot;&gt; &lt;img src=&quot;<A HREF="http://developer.berlios.de/bslogo.php?group_id=2082">http://developer.berlios.de/bslogo.php?group_id=2082</A>&quot; width=&quot;124px&quot; height=&quot;32px&quot; border=&quot;0&quot; alt=&quot;BerliOS Developer Logo&quot;&gt;&lt;/a&gt;
+&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file

Deleted: trunk/web/logo.png
===================================================================
(Binary files differ)

Added: trunk/web/team.html
===================================================================
--- trunk/web/team.html	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/team.html	2004-09-25 16:33:16 UTC (rev 62)
@@ -0,0 +1,61 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; title=&quot;default&quot;/&gt;
+&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=windows-1251&quot;&gt;
+&lt;meta name=&quot;description&quot; content=&quot;Homepage of TW-Light.&quot;&gt;
+&lt;meta name=&quot;keywords&quot; content=&quot;TW-Light timewarp SC sc1 sc2 star control uqm the ur-quan masters ur-quan orz spathi adventure opensource game zip yurand fork TW&quot;&gt;
+&lt;title&gt;TW-Light&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;div class=&quot;navbar&quot;&gt;
+  &lt;table class=&quot;navlinks&quot; summary=&quot;navigation bar&quot;&gt;
+    &lt;tr&gt;
+      &lt;td&gt;
+        &lt;img src=&quot;./3dlogo.jpg&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;120&quot; /&gt; 
+      &lt;/td&gt;
+      &lt;td&gt;
+      &lt;a href=&quot;./index.html&quot;&gt;News&lt;/a&gt; | &lt;a href=&quot;./info.html&quot;&gt;Info&lt;/a&gt; | &lt;a id=&quot;curpagelink&quot; href=&quot;./team.html&quot;&gt;Team&lt;/a&gt; | &lt;a  href=&quot;./downloads.html&quot;&gt;Downloads&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://openfacts.berlios.de/index-en.phtml?title=TW-Light">http://openfacts.berlios.de/index-en.phtml?title=TW-Light</A>&quot;&gt;Wiki&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://bugs.cs.iupui.edu/cgi-bin/bugzilla/">http://bugs.cs.iupui.edu/cgi-bin/bugzilla/</A>&quot;&gt;Bug Database&lt;/a&gt; | &lt;a href=&quot;<A HREF="http://timewarp.sourceforge.net/forum/index.php">http://timewarp.sourceforge.net/forum/index.php</A>&quot;&gt;Forum&lt;/a&gt; | &lt;a href=&quot;./links.html&quot;&gt;Links&lt;/a&gt;
+      &lt;/td&gt;
+    &lt;/tr&gt;
+  &lt;/table&gt;
+&lt;/div&gt;
+
+&lt;div class=&quot;main&quot;&gt;
+  &lt;h2&gt;Team&lt;/h2&gt;
+  &lt;h4&gt;&lt;span id=&quot;core&quot;&gt;Programmers:&lt;/span&gt;&lt;/h4&gt;
+  &lt;ul&gt;
+    &lt;li&gt;Yura Semashko &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">yurand at land.ru</A>&quot;&gt;(Yurand)&lt;/a&gt;&lt;/li&gt;
+    &lt;li&gt;Paul Forest &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">youbastrd at users.sourceforge.net</A>&quot;&gt;(youBastrd)&lt;/a&gt;&lt;/li&gt;
+  &lt;/ul&gt;
+
+  &lt;h4&gt;Content and Plot manager:&lt;/h4&gt;
+
+  &lt;ul&gt;
+    &lt;li&gt;Asaf Hamtzany &lt;a href=&quot;&quot;&gt;(UAF)&lt;/a&gt;&lt;/li&gt;
+  &lt;/ul&gt;
+  
+  &lt;h4&gt;Dialog Writers&lt;/h4&gt;
+  
+  &lt;ul&gt;
+    &lt;li&gt;Pelorki&lt;/li&gt;
+  &lt;/ul&gt;
+  
+  &lt;h4&gt;Special Thanks:&lt;/h4&gt;
+  &lt;ul&gt;
+    &lt;li&gt;Tau&lt;/li&gt;
+    &lt;li&gt;Officer Flubbo&lt;/li&gt;
+    &lt;li&gt;Captain Maim&lt;/li&gt;
+    &lt;li&gt;Jumping Peppers&lt;/li&gt;
+  &lt;/ul&gt;
+
+&lt;/div&gt;
+
+&lt;p align=&quot;left&quot;&gt;&lt;font size=&quot;3&quot;&gt;&lt;strong&gt;this page is hosted by&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
+&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;100%&quot;&gt;
+&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;<A HREF="http://developer.berlios.de">http://developer.berlios.de</A>&quot; title=&quot;BerliOS Developer&quot;&gt; &lt;img src=&quot;<A HREF="http://developer.berlios.de/bslogo.php?group_id=2082">http://developer.berlios.de/bslogo.php?group_id=2082</A>&quot; width=&quot;124px&quot; height=&quot;32px&quot; border=&quot;0&quot; alt=&quot;BerliOS Developer Logo&quot;&gt;&lt;/a&gt;
+&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
+	
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2004-09-25 14:18:41 UTC (rev 61)
+++ trunk/web/update.sh	2004-09-25 16:33:16 UTC (rev 62)
@@ -1,2 +1,2 @@
 #!/bin/bash
-pscp index.html <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">yurand at shell.berlios.de</A>:/home/groups/tw-light/htdocs
\ No newline at end of file
+pscp 3dlogo.jpg background.jpg dialog-editor-win32-62.zip downloads.html index.html info.html links.html team.html style.css <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">yurand at shell.berlios.de</A>:/home/groups/tw-light/htdocs
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000009.html">[Tw-light-svn] r61 - in trunk: gamedata/default_ini/ships gamedata/ships source source/ais source/melee
</A></li>
	<LI>Next message: <A HREF="000011.html">[Tw-light-svn] r63 - in trunk/source: . melee other sc1ships sc2ships ships util
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10">[ date ]</a>
              <a href="thread.html#10">[ thread ]</a>
              <a href="subject.html#10">[ subject ]</a>
              <a href="author.html#10">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
