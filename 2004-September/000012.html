<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r64 - in trunk: . gamedata gamedata/ships source source/games source/libraries source/libraries/lua source/libraries/lua/lib source/other
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2004-September/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r64%20-%20in%20trunk%3A%20.%20gamedata%20gamedata/ships%20source%20source/games%20source/libraries%20source/libraries/lua%20source/libraries/lua/lib%20source/other&In-Reply-To=%3C200409260831.i8Q8V2NU015407%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000011.html">
   <LINK REL="Next"  HREF="000013.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r64 - in trunk: . gamedata gamedata/ships source source/games source/libraries source/libraries/lua source/libraries/lua/lib source/other</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r64%20-%20in%20trunk%3A%20.%20gamedata%20gamedata/ships%20source%20source/games%20source/libraries%20source/libraries/lua%20source/libraries/lua/lib%20source/other&In-Reply-To=%3C200409260831.i8Q8V2NU015407%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r64 - in trunk: . gamedata gamedata/ships source source/games source/libraries source/libraries/lua source/libraries/lua/lib source/other">yurand at sheep.berlios.de
       </A><BR>
    <I>Sun Sep 26 10:31:02 CEST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000011.html">[Tw-light-svn] r63 - in trunk/source: . melee other sc1ships sc2ships ships util
</A></li>
        <LI>Next message: <A HREF="000013.html">[Tw-light-svn] r65 - in trunk: . doc gamedata source source/games
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12">[ date ]</a>
              <a href="thread.html#12">[ thread ]</a>
              <a href="subject.html#12">[ subject ]</a>
              <a href="author.html#12">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2004-09-26 10:30:59 +0200 (Sun, 26 Sep 2004)
New Revision: 64

Added:
   trunk/gamedata/gob.dat
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/libraries/lua/
   trunk/source/libraries/lua/Makefile
   trunk/source/libraries/lua/README
   trunk/source/libraries/lua/lapi.c
   trunk/source/libraries/lua/lapi.h
   trunk/source/libraries/lua/lauxlib.h
   trunk/source/libraries/lua/lcode.c
   trunk/source/libraries/lua/lcode.h
   trunk/source/libraries/lua/ldebug.c
   trunk/source/libraries/lua/ldebug.h
   trunk/source/libraries/lua/ldo.c
   trunk/source/libraries/lua/ldo.h
   trunk/source/libraries/lua/ldump.c
   trunk/source/libraries/lua/lfunc.c
   trunk/source/libraries/lua/lfunc.h
   trunk/source/libraries/lua/lgc.c
   trunk/source/libraries/lua/lgc.h
   trunk/source/libraries/lua/lib/
   trunk/source/libraries/lua/lib/Makefile
   trunk/source/libraries/lua/lib/README
   trunk/source/libraries/lua/lib/lauxlib.c
   trunk/source/libraries/lua/lib/lbaselib.c
   trunk/source/libraries/lua/lib/ldblib.c
   trunk/source/libraries/lua/lib/liolib.c
   trunk/source/libraries/lua/lib/lmathlib.c
   trunk/source/libraries/lua/lib/loadlib.c
   trunk/source/libraries/lua/lib/lstrlib.c
   trunk/source/libraries/lua/lib/ltablib.c
   trunk/source/libraries/lua/llex.c
   trunk/source/libraries/lua/llex.h
   trunk/source/libraries/lua/llimits.h
   trunk/source/libraries/lua/lmem.c
   trunk/source/libraries/lua/lmem.h
   trunk/source/libraries/lua/lobject.c
   trunk/source/libraries/lua/lobject.h
   trunk/source/libraries/lua/lopcodes.c
   trunk/source/libraries/lua/lopcodes.h
   trunk/source/libraries/lua/lparser.c
   trunk/source/libraries/lua/lparser.h
   trunk/source/libraries/lua/lstate.c
   trunk/source/libraries/lua/lstate.h
   trunk/source/libraries/lua/lstring.c
   trunk/source/libraries/lua/lstring.h
   trunk/source/libraries/lua/ltable.c
   trunk/source/libraries/lua/ltable.h
   trunk/source/libraries/lua/ltests.c
   trunk/source/libraries/lua/ltm.c
   trunk/source/libraries/lua/ltm.h
   trunk/source/libraries/lua/lua.h
   trunk/source/libraries/lua/lualib.h
   trunk/source/libraries/lua/lundump.c
   trunk/source/libraries/lua/lundump.h
   trunk/source/libraries/lua/lvm.c
   trunk/source/libraries/lua/lvm.h
   trunk/source/libraries/lua/lzio.c
   trunk/source/libraries/lua/lzio.h
   trunk/source/other/gup.cpp
   trunk/source/other/gup.h
Modified:
   trunk/gamedata/ships/shpalabc.txt
   trunk/gamedata/ships/shpandgu.txt
   trunk/gamedata/ships/shpbipka.txt
   trunk/gamedata/ships/shpchebr.txt
   trunk/gamedata/ships/shpchmav.txt
   trunk/gamedata/ships/shpchoex.txt
   trunk/gamedata/ships/shpconca.txt
   trunk/gamedata/ships/shpconho.txt
   trunk/gamedata/ships/shpdruma.txt
   trunk/gamedata/ships/shpearc3.txt
   trunk/gamedata/ships/shpforsh.txt
   trunk/gamedata/ships/shpgarty.txt
   trunk/gamedata/ships/shpilwsp.txt
   trunk/gamedata/ships/shpkahbo.txt
   trunk/gamedata/ships/shporzne.txt
   trunk/gamedata/ships/shprogsq.txt
   trunk/gamedata/ships/shpsupbl.txt
   trunk/gamedata/ships/shpthrto.txt
   trunk/makefile
   trunk/source/games/gflmelee.cpp
   trunk/source/scp.h
   trunk/sources.lst
Log:
GOB added


Added: trunk/gamedata/gob.dat
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/gob.dat
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/gamedata/ships/shpalabc.txt
===================================================================
--- trunk/gamedata/ships/shpalabc.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpalabc.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -3,18 +3,13 @@
 
 Weapon:
 -------
-Heavy &quot;fire and forget&quot; MIRV torpedo. The torpedo is extremely slow though
-(even warheads have lower-than-average velocity).
+Heavy &quot;fire and forget&quot; MIRV torpedo. The torpedo is extremely slow though (even warheads have lower-than-average velocity).
 
 Note: Torpedo itself will not do damage on collisions (only launched warheads will). 
 
 Turrets:
 --------
-Press &quot;special&quot; to turn them on or off (look in the upper-right corner
-of the &quot;captain screen&quot; to see current state). When on, turrets will
-automatically shoot on possible targets in range. Priority list is
-(descending): your target, any enemy ship, non-damaging things,
-heavy shots.
+Press &quot;special&quot; to turn them on or off (look in the upper-right corner of the &quot;captain screen&quot; to see current state). When on, turrets will automatically shoot on possible targets in range. Priority list is (descending): your target, any enemy ship, non-damaging things, heavy shots.
 
 Note: Turrets can be damaged (disabled).
 
@@ -25,18 +20,14 @@
 
 Shield:
 -------
-Automatic absorbance shield can block most of the incoming damage.
-Does not work when/if overloaded by continuous heavy fire.
-The shield status indicator is located in the upper-left corner
-of the &quot;captain screen&quot;
+Automatic absorbance shield can block most of the incoming damage. Does not work when/if overloaded by continuous heavy fire. The shield status indicator is located in the upper-left corner of the &quot;captain screen&quot;
 
 Note: Shield does cover turrets and engines.
 
 
 Quirk #1:
 ---------
-Damage (even direct) cut in half (to make this ship really tough
-without going over 42 crew (for aesthetic reasons)).
+Damage (even direct) cut in half (to make this ship really tough without going over 42 crew (for aesthetic reasons)). 
 
 Quirk #2:
 ---------
@@ -46,5 +37,3 @@
 -----------------------------------
 *Tau* &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">twships at tau137.com</A>&gt;
 
-
-Last updated on 31 Jan 2003.

Modified: trunk/gamedata/ships/shpandgu.txt
===================================================================
--- trunk/gamedata/ships/shpandgu.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpandgu.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,7 +1,3 @@
-The Androsynth Guardians main weapon fires acid
-bubbles that slowly home in on enemies using the
-Chaos(tm) tracking system.  
+The Androsynth Guardians main weapon fires acid bubbles that slowly home in on enemies using the Chaos(tm) tracking system.  
 
-It's special weapon transforms it into a flaming comet,
-which is extremely fast and maneuverable, and inflicts
-damage upon impact.  
\ No newline at end of file
+It's special weapon transforms it into a flaming comet, which is extremely fast and maneuverable, and inflicts damage upon impact.  
\ No newline at end of file

Modified: trunk/gamedata/ships/shpbipka.txt
===================================================================
--- trunk/gamedata/ships/shpbipka.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpbipka.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,17 +1,14 @@
-Bipole Katamaran
-
-For a stone-like race. Maybe Taalo...
-
-Primary Weapon:
-  Both sideships have a simple projectile cannon.
-  
-Special:
-  Increases the distance between the sideships (if both exist) or accelerates
-  backwards (if only one of them exists).
-
-Notes:
-  This ship is made up of two 'sideships' each of which can survive the
-  destruction of the other. Their crew and battery is kept track of independently
-  but is shown on the panel summed.
-
- * created by: <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">cyhawk at sch.bme.hu</A> and <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">forevian at freemail.hu</A>
+Bipole Katamaran
+
+For a stone-like race. Maybe Taalo...
+
+Primary Weapon:
+  Both sideships have a simple projectile cannon.
+  
+Special:
+  Increases the distance between the sideships (if both exist) or accelerates backwards (if only one of them exists).
+
+Notes:
+  This ship is made up of two 'sideships' each of which can survive the destruction of the other. Their crew and battery is kept track of independently but is shown on the panel summed.
+
+ * created by: <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">cyhawk at sch.bme.hu</A> and <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">forevian at freemail.hu</A>

Modified: trunk/gamedata/ships/shpchebr.txt
===================================================================
--- trunk/gamedata/ships/shpchebr.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpchebr.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,13 +1,8 @@
-The Chenjesu Broodhome main weapon fires crystals
-that keep traveling until you lift the fire button,
-when they explode into many small fragments.  
+The Chenjesu Broodhome main weapon fires crystals that keep traveling until you lift the fire button, when they explode into many small fragments.  
 
-It's special weapon launches DOGIs that seek the
-Chenjesu's target and drain their battery.  
+It's special weapon launches DOGIs that seek the Chenjesu's target and drain their battery.  
 
 Chenjesu are a crystaline life form.  
 
-In Star Control 2, the Chenjesu were imprisoned on
-their homeworld with the Mmrnmhrmm before the game
-started, slowly transforming into Chmmr.  
+In Star Control 2, the Chenjesu were imprisoned on their homeworld with the Mmrnmhrmm before the game started, slowly transforming into Chmmr.  
 

Modified: trunk/gamedata/ships/shpchmav.txt
===================================================================
--- trunk/gamedata/ships/shpchmav.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpchmav.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,18 +1,9 @@
-The Chmmr Avatar is one of the original ships
-from Star Control 2.
-
 The ship's main weapon consists of an uberlaser.
 
-Three defense satellites circle the ship. Each is
-equipped with a short-range auto-targeting laser.
+Three defense satellites circle the ship. Each is equipped with a short-range auto-targeting laser.
 
 The special is a tractor beam with unlimited range.
 
-The Chmmr are a race born of two races, the Chenjesu 
-and the Mrmnmhrm, in an attempt to save the latter from 
-extinction.  The Chmmr are immensely powerful, hyper-
-intelligent, and possibly somewhat schizophenic.  
+The Chmmr are a race born of two races, the Chenjesu and the Mrmnmhrm, in an attempt to save the latter from extinction.  The Chmmr are immensely powerful, hyper-intelligent, and possibly somewhat schizophenic.  
 
-The Chmmr were slave-shielded by the Ur-Quan, but 
-when set free provided a valuable contribution to
-the fight for freedom.
\ No newline at end of file
+The Chmmr were slave-shielded by the Ur-Quan, but when set free provided a valuable contribution to the fight for freedom.
\ No newline at end of file

Modified: trunk/gamedata/ships/shpchoex.txt
===================================================================
--- trunk/gamedata/ships/shpchoex.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpchoex.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,30 +1,30 @@
-The Chorali Extractor
-CrewMax        = 10
-BattMax        = 20
-SpeedMax       = 40
-AccelRate      = 10
-TurnRate       = 2
-I've got the speed/turning set medium/high to compensate for my lack of skill.
-
-Appearance: Currently, it's a shiny gold colored ship.  It's physically large, but that's only because I wanted to have a spinning asteroid as part of the ship.  The front of the ship is flanged outward; this is where the ship's tractor beam comes from.
-
-Weapon: Multi-Use Tractor Beam.  
-Cost: 8 to activate or deactivate prematurely
-Range:6 (from center of ship)
-Time: The Beam lasts for 6000 frames (not sure what that is in seconds, 6?)
-Description:  The Chorali use their tractor beams for just about everything.  They didn't invent the beams, they found the technology on a dead world and replicated it, but they can at least come up with new uses.  First, the beams will draw any matter they come in contact with (currently just ships and asteroids, I tried to get the cargo chain from the confed cargotran to work, but I'm not sure what way would be proper).  The beams also turn any ships they draw, so that they will not continue to fire at the Extractor (watch out for B.U.T.T. missles). If the object is drawn completely to the Extractor, it will be held stationary (no thrust or turning, fire &amp; special still work) until the beam's duration is done.  If the fire button is pressed while an asteroid is held, the asteroid is lobbed at high velocity towards the current target.  Weak long range tractor beams will occasionally correct the trajectory of the missile. 
-[AsteroidMissile]
-Range    = 60
-Velocity = 80
-Damage   = 2
-Armour   = 1
-TurnRate = 2
-The beams will also push away any objects that the onboard computer thinks are dangerous.  Currently, the only homing missiles it can keep at bay are Mycon plasmoids and Khor-Ah blades.
-
-
-Special:  Planet-Fall.
-Cost: 1
-Rate: 0
-The Chorali have discovered that their tractor beams can also be used on nearby planets with surpising success.  If the beams are not focused, they will draw the ship towards the planet.  Used in combination with the main weapon, the Extractor can force enemy ships to crash into the planet.
-
-Quirk: If the highly focused beams of the main weapon are used on the planet, chunks of matter are lifted from the planet, making asteroids (of a non-regenerating type, to keep the amount of permanent asteroids to a minimum).
+The Chorali Extractor
+CrewMax        = 10
+BattMax        = 20
+SpeedMax       = 40
+AccelRate      = 10
+TurnRate       = 2
+I've got the speed/turning set medium/high to compensate for my lack of skill.
+
+Appearance: Currently, it's a shiny gold colored ship.  It's physically large, but that's only because I wanted to have a spinning asteroid as part of the ship.  The front of the ship is flanged outward; this is where the ship's tractor beam comes from.
+
+Weapon: Multi-Use Tractor Beam.  
+Cost: 8 to activate or deactivate prematurely
+Range:6 (from center of ship)
+Time: The Beam lasts for 6000 frames (not sure what that is in seconds, 6?)
+Description:  The Chorali use their tractor beams for just about everything.  They didn't invent the beams, they found the technology on a dead world and replicated it, but they can at least come up with new uses.  First, the beams will draw any matter they come in contact with (currently just ships and asteroids, I tried to get the cargo chain from the confed cargotran to work, but I'm not sure what way would be proper).  The beams also turn any ships they draw, so that they will not continue to fire at the Extractor (watch out for B.U.T.T. missles). If the object is drawn completely to the Extractor, it will be held stationary (no thrust or turning, fire &amp; special still work) until the beam's duration is done.  If the fire button is pressed while an asteroid is held, the asteroid is lobbed at high velocity towards the current target.  Weak long range tractor beams will occasionally correct the trajectory of the missile. 
+[AsteroidMissile]
+Range    = 60
+Velocity = 80
+Damage   = 2
+Armour   = 1
+TurnRate = 2
+The beams will also push away any objects that the onboard computer thinks are dangerous.  Currently, the only homing missiles it can keep at bay are Mycon plasmoids and Khor-Ah blades.
+
+
+Special:  Planet-Fall.
+Cost: 1
+Rate: 0
+The Chorali have discovered that their tractor beams can also be used on nearby planets with surpising success.  If the beams are not focused, they will draw the ship towards the planet.  Used in combination with the main weapon, the Extractor can force enemy ships to crash into the planet.
+
+Quirk: If the highly focused beams of the main weapon are used on the planet, chunks of matter are lifted from the planet, making asteroids (of a non-regenerating type, to keep the amount of permanent asteroids to a minimum).

Modified: trunk/gamedata/ships/shpconca.txt
===================================================================
--- trunk/gamedata/ships/shpconca.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpconca.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,28 +1,28 @@
-Ship		- Confed Cargotran
-Class		- Commercial cargo tug
-Crew		- 6
-Battery		- 4
-Acceleration	- Awe-inspiring
-Turning		- Average
-Top speed	- Slower than an Earthling Cruiser
-Creator		- Corona688, <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">tsm at accesscomm.ca</A>
-
-Weapons:
- Primary 	- Weak short-range laser
- Secondary	- Decelerate, straightens out the chain
- Teritary	- fire + special, ditch the cargo
-
-Weaknesses:	This is NOT a military vessel, and is not meant to
- enter combat.  It's single weapon is only really meant to crack
- asteroids.  Even worse, the structural integrity field used to
- chain the cargo containers behind it means that any damage on them is 
- transferred to the tug.  If forced to enter combat, the captain's
- only recourse is to ditch the cargo entirely and take refuge in the
- slowly growing cloud of containers.
-
-Strengths:	No military strengths.
-
-Quirks:		Although the tug itself has terrific acceleration, this
- is more than offset by the kilotons of cargo it tows.  If caught in a
- gravity well, the cargo can easily haul the whole mess into the planet
+Ship		- Confed Cargotran
+Class		- Commercial cargo tug
+Crew		- 6
+Battery		- 4
+Acceleration	- Awe-inspiring
+Turning		- Average
+Top speed	- Slower than an Earthling Cruiser
+Creator		- Corona688, <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">tsm at accesscomm.ca</A>
+
+Weapons:
+ Primary 	- Weak short-range laser
+ Secondary	- Decelerate, straightens out the chain
+ Teritary	- fire + special, ditch the cargo
+
+Weaknesses:	This is NOT a military vessel, and is not meant to
+ enter combat.  It's single weapon is only really meant to crack
+ asteroids.  Even worse, the structural integrity field used to
+ chain the cargo containers behind it means that any damage on them is 
+ transferred to the tug.  If forced to enter combat, the captain's
+ only recourse is to ditch the cargo entirely and take refuge in the
+ slowly growing cloud of containers.
+
+Strengths:	No military strengths.
+
+Quirks:		Although the tug itself has terrific acceleration, this
+ is more than offset by the kilotons of cargo it tows.  If caught in a
+ gravity well, the cargo can easily haul the whole mess into the planet
  unless the captain jettisons it immediately.
\ No newline at end of file

Modified: trunk/gamedata/ships/shpconho.txt
===================================================================
--- trunk/gamedata/ships/shpconho.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpconho.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,56 +1,56 @@
-Ship          - Confederation Hornet
-Class         - Medium Range Light Fighter
-crew          - 1
-battery       - 10
-accelleration - Good
-Turning       - Very Good
-Top Speed     - Very Good
-
-Weapons
- Primary   - Dual Ball Laser Cannons
- Secondary - Torpedoes (Direct Damage Missles, Slightly Homing)
-
-Extra - Recharging Shield
- Can absorb 8 points of damage, readout in crew-bar
-
-Limitations
- - killed instantly by any direct damage
-   - current known direct damages include :
-     - running into a planet
-     - Orz Marines
-     - Narool Acid
-     - *NEW* Torpedoes
-
-Strong-Points
- - Extremely Manouverable, an excellent pilot can challenge any ship in space
- - Strong destructive capability for a light fighter (lasers do 1 damage each, Torpedoes do 4)
- - Recharging Shield + High Manouverability = longer life, there is no suffering from length in battle
- - Perfect for circling enemies.
-
-/**************************************************************************************/
-03/02/2001
-  - corrected minor bug (i was 1 pixle off when blitting shield pictures)
-  - changed colors around ship in panel to all blue shades
-
-/**********/
-
-03/01/2001
-Torpedoes Implimented
-  - still 4 damage, but now split across normal and direct, (3 and 1 respectively)
-
-Shield Indicator Overlay Implimented
-  - Displays a color around the ship in the panel indicating how your shield is faring.
-
-mshppan.cpp updated to solve a problem with graphic artifacts being left when a hornet's dying, fixed now - if there are any side affects let me know.
-
-/**********/
-
-02/27/2001
-  - Shield indicator bar all blue now.
-  - added homing to missles.
-  - Minor initialization changes to strenthen ship. (not truly necessary in my opinion)
-
-/**********/
-
-02/26/2001
+Ship          - Confederation Hornet
+Class         - Medium Range Light Fighter
+crew          - 1
+battery       - 10
+accelleration - Good
+Turning       - Very Good
+Top Speed     - Very Good
+
+Weapons
+ Primary   - Dual Ball Laser Cannons
+ Secondary - Torpedoes (Direct Damage Missles, Slightly Homing)
+
+Extra - Recharging Shield
+ Can absorb 8 points of damage, readout in crew-bar
+
+Limitations
+ - killed instantly by any direct damage
+   - current known direct damages include :
+     - running into a planet
+     - Orz Marines
+     - Narool Acid
+     - *NEW* Torpedoes
+
+Strong-Points
+ - Extremely Manouverable, an excellent pilot can challenge any ship in space
+ - Strong destructive capability for a light fighter (lasers do 1 damage each, Torpedoes do 4)
+ - Recharging Shield + High Manouverability = longer life, there is no suffering from length in battle
+ - Perfect for circling enemies.
+
+/**************************************************************************************/
+03/02/2001
+  - corrected minor bug (i was 1 pixle off when blitting shield pictures)
+  - changed colors around ship in panel to all blue shades
+
+/**********/
+
+03/01/2001
+Torpedoes Implimented
+  - still 4 damage, but now split across normal and direct, (3 and 1 respectively)
+
+Shield Indicator Overlay Implimented
+  - Displays a color around the ship in the panel indicating how your shield is faring.
+
+mshppan.cpp updated to solve a problem with graphic artifacts being left when a hornet's dying, fixed now - if there are any side affects let me know.
+
+/**********/
+
+02/27/2001
+  - Shield indicator bar all blue now.
+  - added homing to missles.
+  - Minor initialization changes to strenthen ship. (not truly necessary in my opinion)
+
+/**********/
+
+02/26/2001
 First release, most features implimented
\ No newline at end of file

Modified: trunk/gamedata/ships/shpdruma.txt
===================================================================
--- trunk/gamedata/ships/shpdruma.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpdruma.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,18 +1,19 @@
+ General Overview
 
-The Druuge Mauler is one of the original ships
-from Star Control 2.
+One of the single most troublesome ships in the game. The Mauler is slow, ungainly reactions make it a difficult ship to play with. Mastering the correct usage of the high-recoil cannon is not easy and the slow battery regeneration turns the Mauler into a vulnerable ship. To compensate for the Mauler's weak battery recharging, Druuge captains have been known to order lower-ranking crew members to be thrown into the furnace. Yet, when correctly used against certain ships, the Mauler can prove a deadly adversary. Correct usage of recoil effects would allow for great targeting and quick evasion.
 
-The Druuge Mauler is a slow ship with a very powerful long-range weapon but a weak recharge system.
+Main Weapon: High-Recoil Cannon
 
-The Mauler's only weapon is a long-range, high-recoil cannon. Firing the cannon once will thrust the Mauler backwards slightly. Several shots will send it flying unless the captain thrusts his engines to resist the recoil.
+Takes four points of battery and does six points of damage. The high-recoil cannon's fast shots can pummel an unwary enemy from long distance. The recoil itself can propel the Mauler into &#8220;hyperspacing speed&#8221; which can be a double-edged sword. The recoil-effect, combined with the Furnace, nominate the Mauler as one of the few ships that are actually DANGEROUS to a Chmmr Avatar. Aiming takes a while to master but the shots are hard to evade.
 
-To compensate for the Mauler's weak battery recharging, Druuge captains have been known to order lower-ranking crew members to be thrown into the furnace. Although doing this costs the ship one crew member, it also recharges the Mauler's batteries halfway. 
+Special System: The Furnace
 
-The Druuge are a race living in a dystopian 
-corporate society, with an emphasis on trade, 
-profit, and cruelty.  
+At first, this appears to be the single most useless special system available. Throwing a crewman into the furnace to fill half-way of the battery. But when thinking of the possible action &#8211; The Mauler actually never runs out of battery power. This is especially useful against the Avatar where you can use the high-recoil cannon and the supply of battery power to keep out of the Avatar's Tractor-and-Laser tactic, pummeling it to dust. Other than that, it is recommended that you be as cheap as possible on throwing people into the furnace.
 
-The Druuge trade slaves, fuel and artifacts. They
-were responsible for the death of the Gg in order
-to save their own skin when the Kohr-Ah approached.
+Tactical Overview
 
+The Mauler is a very specific ship. It has its advantages only versus specific ships. It is very vulnerable.
+
+Strong against: Chmmr Avatar. Shofixti Scout - The high-recoil would allow the Mauler to stay out of the Glory Device&#8217;s range and it only needs one hit to send the Scout to hell. The Ilwrath Avenger will have a hard time against it too. When flown really masterfully it can also tear ships such as the Earthling (Humans) Cruiser apart.
+
+Weak Against: Whoa. What not? The Marauder's spinning blades, the Arilou Skiff can easily lay an ambush, the VUX Limpets, The Slylandro Probe and Pkunk Fury speed. The X-form&#8217;s long-range missiles, the Kzer-za Dreadnought]&#8217;s fighters, Chenjesu Broodhome DOGIs, the Orz Nemesis marines and the Mycon Podship Can easily wear-down the crew complement. The Utwig Jugger loves meeting the Mauler in battle. 
\ No newline at end of file

Modified: trunk/gamedata/ships/shpearc3.txt
===================================================================
--- trunk/gamedata/ships/shpearc3.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpearc3.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,24 +1,24 @@
-EARTHLING CRUISER MK3
-
-This ship represents yet another attempt to make a worthy &quot;new generation&quot; Earthling ship.
-Started a along time ago, it would never be competed if it was not for Starwreck, which
-inspired that last effort needed to bring this ship to life.  And, sure enough, this attempt
-brings the Earthling Cruiser a step or two closer to its 'Treck predecessors (which is not
-necessarily a bad thing).
-
-Primary weapon on this ship is the proton torpedo launcher, capable of firing highly destructive
-projectiles at long range.  Advanced targeting system automatically tracks all major targets in range
-and calculates optimum firing angle.  However, the launcher itself is limited to a relatively small
-firing arc, and can take some time to aim in on target.  The limited accuracy is an inherited problem
-of all existing proton torpedo launchers.
-
-Secondary weapon system is the short-range point defense laser (PDL).  The beam can be fired
-in short bursts, with some time required to cool down the emitter.   Each burst is automatically
-aimed at the nearest non-friendly object.  If the object is destroyed or is out of range, PDL can
-quickly acquire a new target.  This weapon is especially effective against projectile weapons.
-----------------------------
-
-
-*Tau* &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">twships at tau137.com</A>&gt;
-
-30 Jan 2003
+EARTHLING CRUISER MK3
+
+This ship represents yet another attempt to make a worthy &quot;new generation&quot; Earthling ship.
+Started a along time ago, it would never be competed if it was not for Starwreck, which
+inspired that last effort needed to bring this ship to life.  And, sure enough, this attempt
+brings the Earthling Cruiser a step or two closer to its 'Treck predecessors (which is not
+necessarily a bad thing).
+
+Primary weapon on this ship is the proton torpedo launcher, capable of firing highly destructive
+projectiles at long range.  Advanced targeting system automatically tracks all major targets in range
+and calculates optimum firing angle.  However, the launcher itself is limited to a relatively small
+firing arc, and can take some time to aim in on target.  The limited accuracy is an inherited problem
+of all existing proton torpedo launchers.
+
+Secondary weapon system is the short-range point defense laser (PDL).  The beam can be fired
+in short bursts, with some time required to cool down the emitter.   Each burst is automatically
+aimed at the nearest non-friendly object.  If the object is destroyed or is out of range, PDL can
+quickly acquire a new target.  This weapon is especially effective against projectile weapons.
+----------------------------
+
+
+*Tau* &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">twships at tau137.com</A>&gt;
+
+30 Jan 2003

Modified: trunk/gamedata/ships/shpforsh.txt
===================================================================
--- trunk/gamedata/ships/shpforsh.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpforsh.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,22 +1,22 @@
-----------------
-Zekfahan Shocker
-----------------
-
-The primary is the same but the graphics made it necessary
-to put the guns closer. If you think this a major drawback,
-I might redesign it to feature the original barrel distances.
-
-The secondary now is a chain lightning weapon. It will bounce
-towards every non-planet object after a hit, including the
-shocker itself. It does a reducing amount of damage with
-each bouncing, and the shocker is immune to its shot.
-
-Thanks for Richardyzo for allowing me to rework his ship idea.
-(I've done it because the original one had some copyright
-issues with StarCraft.)
-
-I'd like to thank &quot;the coder&quot; also for doing me this job.
-
-Have fun with the new Shocker! Richardyzo, I hope you enjoy it!
-
-	Forevian
+----------------
+Zekfahan Shocker
+----------------
+
+The primary is the same but the graphics made it necessary
+to put the guns closer. If you think this a major drawback,
+I might redesign it to feature the original barrel distances.
+
+The secondary now is a chain lightning weapon. It will bounce
+towards every non-planet object after a hit, including the
+shocker itself. It does a reducing amount of damage with
+each bouncing, and the shocker is immune to its shot.
+
+Thanks for Richardyzo for allowing me to rework his ship idea.
+(I've done it because the original one had some copyright
+issues with StarCraft.)
+
+I'd like to thank &quot;the coder&quot; also for doing me this job.
+
+Have fun with the new Shocker! Richardyzo, I hope you enjoy it!
+
+	Forevian

Modified: trunk/gamedata/ships/shpgarty.txt
===================================================================
--- trunk/gamedata/ships/shpgarty.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpgarty.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,32 +1,32 @@
-Ship          - Garash Tyrant
-Class         - Behemoth
-crew          - 42
-battery       - 42
-acceleration  - Poor
-Turning       - Very Good
-Top Speed     - Average
-
-Weapons
- Primary   - Charging weapon (damage depending on charge)
-  Stage 1: acts as shield and good at ramming
-  Stage 2: can be released.
-  Stage 3: same as stage two but a little bit powerful.
- Secondary - Repulsar wave  
-  Knockbacks opponent.
-  Knockouts control over ship at a very limited time.
-  Inflicts a modest damage.
-
-Weaknesses
- Slow rate of fire
- Cannot shoot at whim (there's a minimum charge required to shoot)
- Cannot hold on to the shot indefinitely (auto released at some max time   limit)
- Very big ship (easy to hit with high armored shots)
- 
- 
-Strenghts
- Good at long range.
- Good defense vs low armoured shots.
- Good at pillboxing tactics.
- Very good versus low range ships.
- Very powerful shot (absorbs everything or any other form of shots!)
-
+Ship          - Garash Tyrant
+Class         - Behemoth
+crew          - 42
+battery       - 42
+acceleration  - Poor
+Turning       - Very Good
+Top Speed     - Average
+
+Weapons
+ Primary   - Charging weapon (damage depending on charge)
+  Stage 1: acts as shield and good at ramming
+  Stage 2: can be released.
+  Stage 3: same as stage two but a little bit powerful.
+ Secondary - Repulsar wave  
+  Knockbacks opponent.
+  Knockouts control over ship at a very limited time.
+  Inflicts a modest damage.
+
+Weaknesses
+ Slow rate of fire
+ Cannot shoot at whim (there's a minimum charge required to shoot)
+ Cannot hold on to the shot indefinitely (auto released at some max time   limit)
+ Very big ship (easy to hit with high armored shots)
+ 
+ 
+Strenghts
+ Good at long range.
+ Good defense vs low armoured shots.
+ Good at pillboxing tactics.
+ Very good versus low range ships.
+ Very powerful shot (absorbs everything or any other form of shots!)
+

Modified: trunk/gamedata/ships/shpilwsp.txt
===================================================================
--- trunk/gamedata/ships/shpilwsp.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpilwsp.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,16 +1,16 @@
-Ilwrath Spider
-
-During the war against the Traddash the Ilwrath could salvage some Traddash
-technology and came out with this new prototype. (non-official concept)
-
-Primary Weapon:
-  Improved dual version of the original flamethrowers partially based on the Torch's
-  after burners.
-  
-Special:
-  Strange smoke that stops everything for a small amount of time. Even projectiles.
-  The smoke completly adsorbs laser.
-
- * created by: DOS and <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">cyhawk at sch.bme.hu</A> and <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">forevian at freemail.hu</A>
- * thank for the folks at Shipboard for suggesting some elements -- I don't
+Ilwrath Spider
+
+During the war against the Traddash the Ilwrath could salvage some Traddash
+technology and came out with this new prototype. (non-official concept)
+
+Primary Weapon:
+  Improved dual version of the original flamethrowers partially based on the Torch's
+  after burners.
+  
+Special:
+  Strange smoke that stops everything for a small amount of time. Even projectiles.
+  The smoke completly adsorbs laser.
+
+ * created by: DOS and <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">cyhawk at sch.bme.hu</A> and <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">forevian at freemail.hu</A>
+ * thank for the folks at Shipboard for suggesting some elements -- I don't
    remember their name and right now I'm lazy to check the topic
\ No newline at end of file

Modified: trunk/gamedata/ships/shpkahbo.txt
===================================================================
--- trunk/gamedata/ships/shpkahbo.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpkahbo.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,12 +1,12 @@
-Kahr Boomerang
-
-This ship has characteristics close to the Yehat Terminator.
-
-Weapon (3)
-Press Special to select (can be done at any time)
-
-Small boomerang : 1 damage that bounces of ships, short range. No limit.
-Medium boomerang : 3 damage, long range (otherwise same as small). limit 4.
-Large boomerang : 5 damage, controlable range, when you release fire will return.  If turning ship when released it will turn in rotation direction of ship.  Also industuctable like Kohr-ah FIRED system. Limit 1
-
+Kahr Boomerang
+
+This ship has characteristics close to the Yehat Terminator.
+
+Weapon (3)
+Press Special to select (can be done at any time)
+
+Small boomerang : 1 damage that bounces of ships, short range. No limit.
+Medium boomerang : 3 damage, long range (otherwise same as small). limit 4.
+Large boomerang : 5 damage, controlable range, when you release fire will return.  If turning ship when released it will turn in rotation direction of ship.  Also industuctable like Kohr-ah FIRED system. Limit 1
+
 Enjoy
\ No newline at end of file

Modified: trunk/gamedata/ships/shporzne.txt
===================================================================
--- trunk/gamedata/ships/shporzne.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shporzne.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,3 +1,21 @@
-The nemesis is a medium size, medium speed, medium to high manuverable ship. It's primary weapon is a turreted cannon with medium power. The turret can be rotated to face any direction, which is not that useful a feature, but looks nice.  You do this by holding down special and pressing the turn buttons.  
+ General Overview
 
-The secondary ability of the Nemesis is to launch it's crew members in armoured EVA suits. These &quot;space marines&quot; travel under their own power through space to board enemy ships and kill their crew. Go! Go! Go! They can stay in space indefinitely, but return when the target is destroyed.  To launch marines, press both the special key and the fire key at the same time.  
+Always a worthy adversary. Underestimating the Nemesis would likely be the last mistake anyone can ever make. Like its name suggests, the Orz ship is a goddess of revenge, coming to inflict pain and vengeance on the galaxy. The Nemesis is fairly quick and has a fair turn-rate. Never, under any circumstances, chase after the nemesis!
+
+Main Weapon/Special system: Rotating Howitzer
+
+The Howitzer inflicts deadly damage and its shots are fast and medium-ranged. The rotational turret allows usage as a strafing weapon or as a backwards utilized attacker-repellent.
+
+
+Special Action: Marines (GoGos)
+
+Using their armored exo-skeleton, Orzine marines exit the ship from the aft portholes and enter an enemy ship by burning a hole in the hull. They then start roaming the enemy ship&#8217;s corridors, killing every crewman in sight. Especially useful in large groups, the marines can blast a ship entirely by themselves. Warlike creatures such as Ur-Quan, Chmmr, Yehat and Shofixti usually put up a better resistance than peaceful or cowardly creatures like the Spathi, Chenjesu and Mycon. The marine tactic of using a planet wrap-around slingshot maneuver to gain speed aids them against some ships.
+
+Tactical Overview
+
+A very effective ship that rarely fails.
+
+Strong against: Kzer-Za Dreadnought and to some degree Kohr-Ah Marauder are both in danger. The Chenjesu Broodhome is virtually helpless against the marines as is the VUX Intruder and the Mycon Podship. The marines cling on to the Yehat Terminator until the shield goes down and while they are repelled by the Utwig Jugger Shield, no fuel is gained and so they can be used to take down the Jugger&#8217;s shield. Showing the Chmmr Avatar your aft and blasting her with the howitzer is a tricky thing but the Nemesis can break through the tractor beam and as soon as the Zap-sats are down, the Avatar is marine-meat
+
+Weak against: The Pkunk Fury, Slylandro Probe and Arilou Skiff can effortlessly pull out of marine&#8217;s grasp and use hit-n-run attacks to whack the unready Nemesis. The Androsynth Guardian is a bit tricky &#8211; if she get stuck without battery she&#8217;s Marine-meat but the Comet form destroys marines on impact and the Nemesis&#8217;s aft section appears to have been designed exactly to be wedged by a wicked blazer. So long as they manage to evade the marines, The X-form and the Spathi Eluder can pose a pain in the butt to any Nemesis captain. A very hot Shofixti Scout pilot can evade the marines long enough to use a wrap-around slingshot maneuver to catch the Nemesis unaware.
+

Modified: trunk/gamedata/ships/shprogsq.txt
===================================================================
--- trunk/gamedata/ships/shprogsq.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shprogsq.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,16 +1,16 @@
-
-Rogue Squadron
-
-background:
-
-A rogue squadron of former UQ crew, now lawless scavengers of the universe, a curious mixture of different races in a simple general ship design which is harmless on its own, but can be dangerous in large numbers.
-
-How to use this ship:
-
-main = pulse laser
-
-special = choose formations.
-
-In the ini file, you can edit formations. A formation is a list of x y points relative to the leader ship which you have to give a position (0,0), entered on a single line. The must be exactly as many x y pairs as there are crew members. I use an odd number of crew (11) to make the ships start in a symmetrical pattern around the leader.
-
-In melee, the player controls position (0,0) of the grid, which is indicated by a small arrow. Ships are distributed relative to the player position and angle.
+
+Rogue Squadron
+
+background:
+
+A rogue squadron of former UQ crew, now lawless scavengers of the universe, a curious mixture of different races in a simple general ship design which is harmless on its own, but can be dangerous in large numbers.
+
+How to use this ship:
+
+main = pulse laser
+
+special = choose formations.
+
+In the ini file, you can edit formations. A formation is a list of x y points relative to the leader ship which you have to give a position (0,0), entered on a single line. The must be exactly as many x y pairs as there are crew members. I use an odd number of crew (11) to make the ships start in a symmetrical pattern around the leader.
+
+In melee, the player controls position (0,0) of the grid, which is indicated by a small arrow. Ships are distributed relative to the player position and angle.

Modified: trunk/gamedata/ships/shpsupbl.txt
===================================================================
--- trunk/gamedata/ships/shpsupbl.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpsupbl.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,14 +1,19 @@
+ General review
 
-The Supox Blade is one of the original ships
-from Star Control 2.
+The Blade is a largely underrated ship. It's rapid fire capability can pound an unwary enemy and the lateral thrusting, when properly used, is nearly as good as the Arilou Hyperspace shunts in evading shots. The Blade is quick and agile with a fair turn-rate, allowing it to considerably hamper enemy targeting efforts. Its slender form makes it harder to hit her.
 
-The main weapon consists of a rapid-fire forward
-cannon.
+Main Weapon: Sprout Gun
 
-The special allows the ship to move almost instantly
-left, right, back, like a leaf in the wind.
+The rapid-fire Sprout Gun may cause small damage but it sure fires fast. Even when out of battery, the gun&#8217;s firing rate remains high and it's range, equaling the Ur-Quan Kzer-Za Dreadnought and the Syreen Penetrator can prove deadly.
 
-The Supox are the only sentient plant species known.
+Special System: Lateral Thrusting System
 
-The Supox formed peaceful allies of the Utwig, whom
-they helped in their time of distress.
+It takes a hell lot of practice to master the tricky Lateral Thrusting System but when correctly used, the Lateral Thrusting can be used to sidestep shots or strafe into a firing position. Especially effective against slow-firing ships such as the Dreadnought or Kohr-Ah Marauder.
+
+Tactical Overview
+
+The Blade is a fair adversary that shouldn't be taken lightly.
+
+Strong against: Syreen Penetrator, Kzer-Za Dreadnought, VUX Intruder, Ilwrath Avenger, Utwig Jugger.
+
+Weak against: Chenjesu Broodhome The crystalline shards put the Lateral-Sidestepping into a real problem. Arilou Skiff, Slylandro Probe and Pkunk Fury can convey quick hit-n-run attacks on the Blade. Chmmr Avatar. 

Modified: trunk/gamedata/ships/shpthrto.txt
===================================================================
--- trunk/gamedata/ships/shpthrto.txt	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/gamedata/ships/shpthrto.txt	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,4 +1,4 @@
-he Thraddash Torch is the pride and joy of Thraddash Culture Nineteen. It is very small, but its maneuverability and its powerful afterburners make it a serious contender even against large ships.
+The Thraddash Torch is the pride and joy of Thraddash Culture Nineteen. It is very small, but its maneuverability and its powerful afterburners make it a serious contender even against large ships.
 
 The Torch's main weapon is a medium-range blaster cannon. The blaster is pretty weak (although it can penetrate an Umgah Drone's anti-matter cone), so most Thraddash pilots use the Reeunk Afterburner as their main weapon. The afterburner accelerates the Torch to incredible speeds and leaves in its wake a fiery trail of ionized plasma that, while still hot, can cripple enemy ships in seconds should one be following too closely.
 

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/makefile	2004-09-26 08:30:59 UTC (rev 64)
@@ -74,7 +74,7 @@
         source/other source/ships source/sc1ships source/sc2ships \
         source/twgui source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
-        source/libraries/raknet
+        source/libraries/raknet source/libraries/lua source/libraries/lua/lib
 
 #FILELIST= ${shell find source -type f &quot;(&quot; -name &quot;*.c&quot; -o -name &quot;*.cpp&quot; &quot;)&quot;}
 FILELIST= ${shell cat sources.lst}
@@ -121,7 +121,8 @@
 	LIBS += ${shell allegro-config --libs} -pthread ${shell sdl-config --libs}
 endif
 
-CFLAGS += -I./source -I./source/libraries
+CFLAGS += -I./source -I./source/libraries -I./source/libraries/lua
+
 ifdef TEST
 CFLAGS += -DTEST ${shell cppunit-config --cflags }
 LIBS += ${shell cppunit-config --libs }

Modified: trunk/source/games/gflmelee.cpp
===================================================================
--- trunk/source/games/gflmelee.cpp	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/games/gflmelee.cpp	2004-09-26 08:30:59 UTC (rev 64)
@@ -1,7 +1,7 @@
 /* $Id: gflmelee.cpp,v 1.1.1.1 2004/08/01 10:21:21 Yura Exp $ */ 
 /*
 This file is part of &quot;TW-Light&quot; 
-                    <A HREF="http://timewarp.sourceforge.net/">http://timewarp.sourceforge.net/</A>
+                    <A HREF="http://tw-light.berlios.de/">http://tw-light.berlios.de/</A>
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Added: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/games/ggob.cpp	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,1000 @@
+/*
+This file is part of &quot;TW-Light&quot; 
+                    <A HREF="http://tw-light.berlios.de/">http://tw-light.berlios.de/</A>
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+
+#include &lt;allegro.h&gt;
+
+#include &quot;melee.h&quot;
+
+#include &quot;scp.h&quot;
+#include &quot;frame.h&quot;
+
+#include &quot;melee/mgame.h&quot;
+#include &quot;melee/mmain.h&quot;
+#include &quot;melee/mview.h&quot;
+#include &quot;melee/mcontrol.h&quot;
+#include &quot;melee/mcbodies.h&quot;
+#include &quot;melee/mshppan.h&quot;
+#include &quot;melee/mship.h&quot;
+#include &quot;melee/mshot.h&quot;
+#include &quot;melee/mlog.h&quot;
+#include &quot;melee/manim.h&quot;
+#include &quot;melee/mfleet.h&quot;
+
+#include &quot;util/aastr.h&quot;
+
+#include &quot;ggob.h&quot;
+#include &quot;sc1ships.h&quot;
+#include &quot;sc2ships.h&quot;
+
+#include &quot;other/gup.h&quot;
+#include &quot;other/dialogs.h&quot;
+#include &quot;other/twconfig.h&quot;
+
+#define gobgame ((GobGame*)game)
+
+////////////////////////////////////////////////////////////////////////
+//				Gob stuff
+////////////////////////////////////////////////////////////////////////
+
+int GobAsteroid::handle_damage (SpaceLocation *source, double normal, double direct) 
+{
+  STACKTRACE;
+  if (!exists()) 
+    return 0;
+  int i = Asteroid::handle_damage(source, normal, direct);
+  if (!exists()) 
+    {
+      GobPlayer *p = gobgame-&gt;get_player(source);
+      if (p) 
+	p-&gt;buckazoids += 1;
+    }
+  return i;
+}
+
+void GobAsteroid::death () 
+{
+  STACKTRACE;
+  Animation *a = new Animation(this, pos,
+			       explosion, 0, explosion-&gt;frames(), time_ratio, get_depth());
+  a-&gt;match_velocity(this);
+  game-&gt;add(a);
+
+  game-&gt;add ( new GobAsteroid() );
+  return;
+}
+
+void GobGame::preinit() 
+{
+  STACKTRACE;
+  Game::preinit();
+
+  gobplayers = 0;
+  gobplayer = NULL;
+  gobenemies = 0;
+  max_enemies = 0;
+  gobenemy = NULL;
+
+  int i;
+  for (i = 0; i &lt; 3; i += 1)
+    stationSprite[i] = NULL;
+  for (i = 0; i &lt; 3; i += 1)
+    station_pic_name[i] = NULL;
+  for (i = 0; i &lt; 3; i += 1)
+    station_build_name[i] = NULL;
+  defenderSprite = NULL;
+}
+
+void GobGame::add_gobplayer(Control *control) 
+{
+  STACKTRACE;
+  int i = gobplayers;
+  gobplayers += 1;
+  gobplayer = (GobPlayer**) realloc(gobplayer, sizeof(GobPlayer*) * gobplayers);
+  gobplayer[i] = new GobPlayer();
+  gobplayer[i]-&gt;init(control, new_team());
+  add_focus(control, control-&gt;channel);
+  return;
+}
+
+void GobPlayer::died(SpaceLocation *killer) 
+{
+  STACKTRACE;
+  if (upgrade_list[UpgradeIndex::divinefavor]-&gt;num &amp;&amp; (random()&amp;1)) 
+    { //divine favor
+      ship-&gt;crew = ship-&gt;crew_max;
+      ship-&gt;batt = ship-&gt;batt_max;
+      ship-&gt;translate(random(Vector2(-2048,-2048), Vector2(2048,2048)));
+      ship-&gt;state = 1;
+    }
+  else 
+    ship = NULL;
+  return;
+}
+
+
+void GobGame::play_sound (SAMPLE *sample, SpaceLocation *source, int vol, int freq) 
+{
+  return;
+  /*
+	double v;
+	Vector2 d = source-&gt;normal_pos() - space_center;
+	d = normalize(d + size/2, size) - size/2;
+	v = 1000;
+	if (space_zoom &gt; 0.01) v = 500 + space_view_size.x / space_zoom / 4;
+	v = 1 + magnitude_sqr(d) / (v*v);
+	Game::play_sound(sample, source, iround(vol/v), freq);
+  */
+}
+
+
+void GobGame::init(Log *_log) 
+{
+  STACKTRACE;
+  int i;
+  Game::init(_log);
+  
+  log_file(&quot;server.ini&quot;);
+  max_enemies = get_config_int(&quot;Gob&quot;, &quot;MaxEnemies&quot;, 32);
+  gobenemy = (GobEnemy**) malloc(sizeof(GobEnemy*) * max_enemies);
+  
+  size = Vector2(24000, 24000);
+  
+  enemy_team = new_team();
+  
+  DATAFILE *tmpdata; 
+  tmpdata = load_datafile_object(data_full_path(&quot;gob.dat&quot;).c_str(), &quot;station0sprite&quot;);
+  if (!tmpdata) 
+    tw_error( &quot;couldn't find gob.dat#station0sprite&quot;);
+  stationSprite[0] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
+  unload_datafile_object(tmpdata);
+  stationSprite[0]-&gt;permanent_phase_shift(8);
+
+  tmpdata = load_datafile_object(data_full_path(&quot;gob.dat&quot;).c_str(), &quot;station1sprite&quot;);
+  if (!tmpdata) 
+    tw_error (&quot;couldn't find gob.dat#station1sprite&quot;);
+  stationSprite[1] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
+  unload_datafile_object(tmpdata);
+  stationSprite[1]-&gt;permanent_phase_shift(8);
+  
+  tmpdata = load_datafile_object(data_full_path(&quot;gob.dat&quot;).c_str(), &quot;station2sprite&quot;);
+  if (!tmpdata) 
+    tw_error (&quot;couldn't find gob.dat#station2sprite&quot;);
+  stationSprite[2] = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED, 64);
+  unload_datafile_object(tmpdata);
+  stationSprite[2]-&gt;permanent_phase_shift(8);
+  
+  tmpdata = load_datafile_object(data_full_path(&quot;gob.dat&quot;).c_str(), &quot;defender&quot;);
+  if (!tmpdata) 
+    tw_error (&quot;couldn't find gob.dat#defender&quot;);
+  defenderSprite = new SpaceSprite(tmpdata, 1, SpaceSprite::MASKED | SpaceSprite::MIPMAPED);
+  unload_datafile_object(tmpdata);
+  
+	
+  station_pic_name[0] = &quot;gob.dat#station0picture.bmp&quot;;
+  station_pic_name[1] = &quot;gob.dat#station1picture.bmp&quot;;
+  station_pic_name[2] = &quot;gob.dat#station2picture.bmp&quot;;
+  station_build_name[0] = &quot;supbl&quot;;
+  station_build_name[1] = &quot;orzne&quot;;
+  station_build_name[2] = &quot;kohma&quot;;
+  
+  prepare();
+
+  add(new Stars());
+	
+	num_planets = 0;
+	i = 0;
+	add_planet_and_station(meleedata.planetSprite, i, 
+			       stationSprite[i], station_build_name[i], station_pic_name[i]);
+	i = 1;
+	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
+	i = 2;
+	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], station_build_name[i], station_pic_name[i]);
+	i = random() % 3;
+	add_planet_and_station(meleedata.planetSprite, i, stationSprite[i], &quot;utwju&quot;, station_pic_name[i]);
+
+	for (i = 0; i &lt; 19; i += 1) add(new GobAsteroid());
+
+
+
+	int server_players, client_players;
+	tw_set_config_file(&quot;client.ini&quot;);
+	server_players = client_players = get_config_int(&quot;Gob&quot;, &quot;NumPlayers&quot;, 1);
+	if (!lag_frames) client_players = 0;
+	log_int(channel_server, server_players);
+	log_int(channel_client, client_players);
+	for (i = 0; i &lt; server_players; i += 1) {
+		char buffy[256];
+		sprintf(buffy, &quot;Config%d&quot;, i);
+		add_gobplayer(create_control(channel_server, &quot;Human&quot;, buffy));
+		gobplayer[i]-&gt;new_ship(shiptype(&quot;supbl&quot;));
+		Ship *s = gobplayer[i]-&gt;ship;
+		s-&gt;translate(size/2-s-&gt;normal_pos());
+		double angle = PI2 * i / (client_players + server_players);
+		s-&gt;translate(rotate(Vector2(260, 120), angle));
+		s-&gt;accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
+	}
+	for (i = server_players; i &lt; client_players + server_players; i += 1) {
+		char buffy[256];
+		sprintf(buffy, &quot;Config%d&quot;, i - server_players);
+		add_gobplayer(create_control(channel_client, &quot;Human&quot;, buffy));
+		gobplayer[i]-&gt;new_ship(shiptype(&quot;supbl&quot;));
+		Ship *s = gobplayer[i]-&gt;ship;
+		s-&gt;translate(size/2-s-&gt;normal_pos());
+		double angle = PI2 * i / (client_players + server_players);
+		s-&gt;translate(rotate(Vector2(260, 120), angle));
+		s-&gt;accelerate(s, PI2/3 + angle, 0.17, MAX_SPEED);
+	}
+
+	for (i = 0; i &lt; gobplayers; i += 1) add ( new RainbowRift() );
+
+	next_add_new_enemy_time = 1000;
+	add_new_enemy();
+	this-&gt;change_view(&quot;Hero&quot;);
+	view-&gt;window-&gt;locate(
+		0,0,
+		0,0,
+		0,0.9,
+		0,1
+		);
+	return;
+}
+GobGame::~GobGame() {
+  delete stationSprite[0];
+  delete stationSprite[1];
+  delete stationSprite[2];
+  delete defenderSprite;
+  int i;
+  for (i = 0; i &lt; gobplayers; i += 1) 
+    {
+      delete gobplayer[i];
+    }
+  free(gobplayer);
+  for (i = 0; i &lt; gobenemies; i += 1) 
+    {
+      delete gobenemy[i];
+    }
+  free(gobenemy);
+  return;
+}
+
+void GobGame::add_planet_and_station ( SpaceSprite *planet_sprite, 
+				       int planet_index, SpaceSprite *station_sprite, 
+				       const char *builds, const char *background) 
+{
+  Planet *p = new Planet (size/2, planet_sprite, planet_index);
+  if (num_planets) while (true) 
+    {
+      SpaceLocation *n;
+      n = p-&gt;nearest_planet();
+      if (!n || (p-&gt;distance(n) &gt; 1500)) break;
+      p-&gt;translate(random(size));
+    }
+  add ( p );
+  
+  GobStation *gs = new GobStation(station_sprite, p, builds, background);
+  gs-&gt;collide_flag_sameship = ALL_LAYERS;
+  gs-&gt;collide_flag_sameteam = ALL_LAYERS;
+  gs-&gt;collide_flag_anyone = ALL_LAYERS;
+  add ( gs );
+  
+  gobgame-&gt;planet[gobgame-&gt;num_planets] = p;
+  gobgame-&gt;station[gobgame-&gt;num_planets] = gs;
+  gobgame-&gt;num_planets += 1;
+}
+
+void GobGame::fps() 
+{
+  STACKTRACE;
+  Game::fps();
+  
+  message.print((int)msecs_per_fps, 15, &quot;enemies: %d&quot;, (int)gobenemies);
+  message.print((int)msecs_per_fps, 15, &quot;time: %d&quot;, (int)(game_time / 1000));
+
+  int i = 0;
+  for (i = 0; i &lt; gobplayers; i += 1) 
+    {
+      if (!is_local(gobplayer[i]-&gt;channel)) 
+	continue;
+      
+      if (gobplayer[i]-&gt;ship) {
+	message.print((int)msecs_per_fps, 15-i, &quot;coordinates: %d x %d&quot;, 
+		      iround(gobplayer[i]-&gt;ship-&gt;normal_pos().x), 
+		      iround(gobplayer[i]-&gt;ship-&gt;normal_pos().y));
+      }
+      message.print((int)msecs_per_fps, 15-i, &quot;starbucks: %d&quot;, gobplayer[i]-&gt;starbucks);
+      message.print((int)msecs_per_fps, 15-i, &quot;buckazoids: %d&quot;, gobplayer[i]-&gt;buckazoids);
+      message.print((int)msecs_per_fps, 15-i, &quot;kills: %d&quot;, gobplayer[i]-&gt;kills);
+    }
+  return;
+}
+
+void GobGame::calculate() 
+{
+  STACKTRACE;
+  
+
+  if (next_add_new_enemy_time &lt;= game_time) {
+    next_add_new_enemy_time = game_time;
+    int t = 28;
+    if ((random() % t) &lt; 4) add_new_enemy();
+    int e = gobenemies;
+    e -= random() % (1 + game_time / (250 * 1000));
+    if (0) ;
+    else if (e &gt;=12) next_add_new_enemy_time += 15000;
+    else if (e &gt;= 7) next_add_new_enemy_time += 7000;
+    else if (e &gt;= 4) next_add_new_enemy_time += 5000;
+    else if (e &gt;= 2) next_add_new_enemy_time += 3000;
+    else if (e &gt;= 1) next_add_new_enemy_time += 2000;
+    else next_add_new_enemy_time += 1000;
+  }
+  Game::calculate();
+  return;
+}
+
+int GobGame::get_enemy_index(SpaceLocation *what) 
+{
+  STACKTRACE;
+  int i;
+  Ship *s = what-&gt;ship;
+  if (!s) return -1;
+  for (i = 0; i &lt; gobenemies; i += 1) 
+    {
+      if (gobenemy[i]-&gt;ship == s) return i;
+    }
+  return -1;
+}
+
+void GobGame::ship_died(Ship *who, SpaceLocation *source) 
+{
+  STACKTRACE;
+  
+  GobPlayer *p = this-&gt;get_player(who);
+  if (p &amp;&amp; (p-&gt;ship == who)) { //Player died
+    p-&gt;died(source);
+  }
+	int i = get_enemy_index(who);
+	if ((i != -1) &amp;&amp; (gobenemy[i]-&gt;ship == who)) {
+		GobEnemy *e = gobenemy[i];
+		e-&gt;died(source);
+		gobenemies -= 1;
+		GobEnemy *tmp = gobenemy[gobenemies];
+		gobenemy[i] = tmp;
+		p = get_player(source);
+	}
+
+	Game::ship_died(who, source);
+	return;
+}
+GobPlayer *GobGame::get_player(SpaceLocation *what) {
+  STACKTRACE;
+	int i;
+	for (i = 0; i &lt; gobplayers; i += 1) {		
+		if (what-&gt;get_team() == gobplayer[i]-&gt;team) return gobplayer[i];
+	}
+	return NULL;
+}
+void GobGame::add_new_enemy() 
+{
+  STACKTRACE;
+  
+  static char *enemy_types[] = {
+		&quot;thrto&quot;, &quot;zfpst&quot;, &quot;shosc&quot;, &quot;dragr&quot;, 
+		&quot;kahbo&quot;, &quot;ilwsp&quot;, 
+		&quot;syrpe&quot;, &quot;kzedr&quot;, &quot;mmrxf&quot;, 
+		&quot;druma&quot;, &quot;earcr&quot;, 
+		&quot;yehte&quot;, &quot;chmav&quot; 
+		};
+  const int num_enemy_types = sizeof(enemy_types)/sizeof(enemy_types[0]);
+  if (gobenemies == max_enemies) 
+    return;
+  GobEnemy *ge = new GobEnemy();
+
+  int base = game_time / 30 / 1000;
+  if (gobenemies &gt;= 4) 
+    base += (gobenemies*gobenemies - 10) / 5;
+  
+  gobenemy[gobenemies] = ge;
+  gobenemies += 1;
+  base = iround(base / 1.5);
+  int e = 99999;
+  while (e &gt;= num_enemy_types) {
+/*
+base	time	low		high
+
+  1		.5		-0.1	3.7
+  10	5		2.62	7.47
+  50	25		5.89	14.24
+ 100	50		8.1		17.3
+ 200	100		11.01	26.49
+
+
+
+*/
+    e = base;
+    e = random() % (e + 2);
+    e = random() % (e + 3);
+    if (e &lt; pow(2.5*base,0.4) - 1) 
+      e = random() % num_enemy_types;
+    if (e &gt; sqrt(3*base) + 2) 
+      e = random() % (e + 1);
+    //if (e &gt; num_enemy_types * 2) e = e % num_enemy_types;
+    e = e;
+  }
+  Ship *ship = create_ship(channel_server, enemy_types[e], &quot;WussieBot&quot;, random(size), random(PI2), enemy_team);
+  if (!strcmp(enemy_types[e], &quot;shosc&quot;)) ((ShofixtiScout*)ship)-&gt;specialDamage /= 4;
+  if (!strcmp(enemy_types[e], &quot;zfpst&quot;)) ((ZoqFotPikStinger*)ship)-&gt;specialDamage /= 2;
+  if (!strcmp(enemy_types[e], &quot;syrpe&quot;)) ((SyreenPenetrator*)ship)-&gt;specialDamage /= 2;
+  if (!strcmp(enemy_types[e], &quot;dragr&quot;)) ship-&gt;special_drain *= 2;
+  if (!strcmp(enemy_types[e], &quot;chmav&quot;)) {
+    ((ChmmrAvatar*)ship)-&gt;weaponDamage += 1;
+    ((ChmmrAvatar*)ship)-&gt;weaponDamage /= 2;
+    ((ChmmrAvatar*)ship)-&gt;specialForce *= 2;
+    ((ChmmrAvatar*)ship)-&gt;specialRange *= 2;
+  }
+  int sb, bz;
+  sb = 1 + e / 4;
+  if (sb &gt; 2) sb -= 1;
+  bz = (e - 9) / 2;
+  if (bz &gt; 1) bz -= 1;
+  if (sb &lt; 0) sb = 0;
+	if (bz &lt; 0) bz = 0;
+	ge-&gt;init(ship, sb, bz);
+	add(ship-&gt;get_ship_phaser());
+	//add(ship);
+	return;
+}
+
+void GobEnemy::init(Ship *ship, int kill_starbucks, int kill_buckazoids) {
+  STACKTRACE;
+	this-&gt;ship = ship;
+	this-&gt;starbucks = kill_starbucks;
+	this-&gt;buckazoids = kill_buckazoids;
+	return;
+	}
+void GobEnemy::died(SpaceLocation *what) {
+  STACKTRACE;
+	GobPlayer *p = gobgame-&gt;get_player(what);
+	if (p) {
+		p-&gt;starbucks += starbucks;
+		p-&gt;buckazoids += buckazoids;
+		p-&gt;kills += 1;
+	}
+	return;
+}
+
+
+GobPlayer::~GobPlayer() {
+	free (pair_list);
+}
+void GobPlayer::init(Control *c, TeamCode team) {
+  STACKTRACE;
+  channel = c-&gt;channel;
+  starbucks = 0;
+  buckazoids = 0;
+  kills = 0;
+  value_starbucks = 0;
+  value_buckazoids = 0;
+  num_pairs = 0;
+  pair_list = NULL;
+  ship = NULL;
+  panel = NULL;
+  control = c;
+  total = 0;
+  this-&gt;team = team;
+  int i, j;
+  for (i = 0; ::upgrade_list[i]; i += 1) ::upgrade_list[i]-&gt;index = i;
+  upgrade_list = new Upgrade*[i+1];
+  upgrade_list[i] = NULL;
+  for (j = 0; j &lt; i; j += 1) {
+    upgrade_list[j] = ::upgrade_list[j]-&gt;duplicate();
+    upgrade_list[j]-&gt;clear(NULL, NULL, this);
+  }
+  return;
+}
+GobPlayer::pair *GobPlayer::_get_pair(const char *id) {
+  STACKTRACE;
+  if (!pair_list) return NULL;
+  int i;
+  for (i = 0; i &lt; num_pairs; i += 1) {
+    if (!strcmp(pair_list[i].id, id)) 
+			return &amp;pair_list[i];
+  }
+  return NULL;
+}
+void GobPlayer::_add_pair(const char *id, int value) {
+  STACKTRACE;
+  if (_get_pair(id)) 
+    {
+      tw_error(&quot;GobPlayer::_add_pair - \&quot;%s\&quot; already exists&quot;, id);
+      return;
+    }
+  pair_list = (pair*)realloc(pair_list, sizeof(pair) * (num_pairs+1));
+  pair_list[num_pairs].id = strdup(id);
+  pair_list[num_pairs].value = value;
+  num_pairs += 1;
+  return;
+}
+
+int GobPlayer::read_pair(const char *id) {
+  STACKTRACE;
+  pair *p = _get_pair(id);
+  if (p) return p-&gt;value;
+  return -1;
+}
+
+void GobPlayer::write_pair(const char *id, int value) {
+  STACKTRACE;
+  pair *p = _get_pair(id);
+  if (p) p-&gt;value = value;
+  else _add_pair(id, value);
+  return;
+}
+int GobPlayer::charge (char *name, int price_starbucks, int price_buckazoids) {
+  char buffy1[512];
+  sprintf(buffy1, &quot;Price: %d starbucks plus %d buckazoids&quot;, price_starbucks, price_buckazoids);
+  if ((starbucks &lt; price_starbucks) || (buckazoids &lt; price_buckazoids)) {
+    if (game-&gt;is_local(channel)) 
+      alert(&quot;You don't have enough.&quot;, name, buffy1, &quot;Cancel&quot;, NULL, 0, 0);
+    return 0;
+  }
+  int r = 0;
+  if (game-&gt;is_local(channel)) 
+    r = alert (&quot;Do you wish to make this purchase?&quot;, name, buffy1, &quot;&amp;No&quot;, &quot;&amp;Yes&quot;, 'n', 'y');
+  game-&gt;log_int(channel, r);
+  if (r == 2) {
+    starbucks -= price_starbucks;
+    buckazoids -= price_buckazoids;
+    return 1;
+  }
+  return 0;
+}
+void GobPlayer::new_ship(ShipType *type) {
+  STACKTRACE;
+  Ship *old = ship;
+  Vector2 pos = 0;
+  double a = 0;
+  int i;
+  if (old) {
+    pos = old-&gt;normal_pos();
+    a = old-&gt;get_angle();
+  }
+  
+  ship = game-&gt;create_ship ( type-&gt;id, control, pos, a, team);
+  
+  
+  if (panel) panel-&gt;die();
+	panel = NULL;
+	panel = new ShipPanel(ship);
+	panel-&gt;always_redraw = true;
+	panel-&gt;window-&gt;init(game-&gt;window);
+	if (game-&gt;is_local(control-&gt;channel)) {
+		panel-&gt;window-&gt;locate(
+			0,0.9,
+			0,0,
+			0,0.1,
+			0,0.25
+		);
+	}
+	else {
+		panel-&gt;window-&gt;locate(
+			0,0.9,
+			0,0.25,
+			0,0.1,
+			0,0.25
+		);
+	}
+	panel-&gt;set_depth(10);
+	game-&gt;add(panel);
+
+	for (i = 0; upgrade_list[i]; i += 1) {
+		upgrade_list[i]-&gt;clear(old, ship, this);
+		}
+	if (old) {
+		old-&gt;die();
+		game-&gt;add(ship);
+		}
+	else game-&gt;add(ship-&gt;get_ship_phaser());
+	return;
+	}
+
+void GobStation::buy_new_ship_menu(GobPlayer *s) {
+  STACKTRACE;
+
+  char buffy1[512], buffy2[512];
+  ShipType *otype = s-&gt;ship-&gt;type;
+  ShipType *ntype = shiptype(build_type);
+  if (otype == ntype) {
+    sprintf (buffy1, &quot;You already have a %s&quot;, ntype-&gt;name);
+    if (game-&gt;is_local(s-&gt;channel)) 
+      alert(buffy1, NULL, NULL, &quot;&amp;Cancel&quot;, NULL, 'c', 0);
+    return;
+  }
+  int ossb = (s-&gt;value_starbucks*3) / 4 + (s-&gt;ship-&gt;type-&gt;cost*1)/1;
+  int osbz = (s-&gt;value_buckazoids*3) / 4 + (s-&gt;ship-&gt;type-&gt;cost*1)/1;
+  int nssb = ntype-&gt;cost;
+  int nsbz = ntype-&gt;cost;
+  sprintf (buffy1, &quot;You have a %s worth %d s$ / %d b$&quot;, otype-&gt;name, ossb, osbz);
+  sprintf (buffy2, &quot;A %s costs %d s$ / %d b$&quot;, ntype-&gt;name, nssb, nsbz);
+  if ((nssb &lt;= (ossb + s-&gt;starbucks)) &amp;&amp; (nsbz &lt;= (osbz + s-&gt;buckazoids))) {
+    int i = 0;
+    if (game-&gt;is_local(s-&gt;channel))
+      i = alert(buffy1, buffy2, &quot;Do you wish to buy it?&quot;, &quot;Yeah!&quot;, &quot;No&quot;, 'y', 'n');
+    game-&gt;log_int(s-&gt;channel, i);
+    if (i == 1) {
+      s-&gt;starbucks -= nssb - ossb;
+      s-&gt;buckazoids -= nsbz - osbz;
+      s-&gt;new_ship(ntype);
+    }
+  }
+  else {
+    if (game-&gt;is_local(s-&gt;channel)) 
+      alert (buffy1, buffy2, &quot;You don't have enough to buy it&quot;, &quot;Cancel&quot;, NULL, 0, 0);
+  }
+  return;
+}
+
+GobStation::GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, const char *background) : 
+  Orbiter(pic, orbit_me, random() % 200 + 500) 
+{
+  build_type = ship;
+  background_pic = background;
+  layer = LAYER_CBODIES;
+  mass = 99;
+}
+
+#define STATION_DIALOG_DEPART  0
+#define STATION_DIALOG_UPGRADE 1
+#define STATION_DIALOG_NEWSHIP 2
+#define STATION_DIALOG_REPAIR  3
+static DIALOG station_dialog[] =
+{// (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)     (d1)  (d2)  (dp)
+  { d_agup_button_proc,     385,  50,   150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)&quot;Depart Station&quot; , NULL, NULL },
+  { d_agup_button_proc,     385,  90,   150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)&quot;Upgrade Ship&quot; , NULL, NULL },
+  { d_agup_button_proc,     385,  130,  150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)&quot;Buy New Ship&quot; , NULL, NULL },
+  { d_agup_button_proc,     385,  170,  150,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)&quot;Repair Ship&quot; , NULL, NULL },
+  { d_agup_text_proc,       185,  420,  270,  30,   255,  0,    0,    0,          0,    0,    dialog_string[0], NULL, NULL },
+  { d_tw_yield_proc,        0,    0,    0,    0,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { NULL,              0,    0,    0,    0,    255,  0,    0,    0,          0,    0,    NULL, NULL, NULL }
+};
+void GobStation::station_screen(GobPlayer *s) 
+{
+  STACKTRACE;
+  BITMAP *background = load_bitmap(data_full_path(background_pic).c_str(), NULL);
+  if (!background) {
+    message.print(1000, 15, &quot;%s&quot;, background_pic);
+    tw_error (&quot;couldn't load station background&quot;);
+  }
+  game-&gt;window-&gt;lock();
+  aa_set_mode(AA_DITHER);
+  aa_stretch_blit(background, game-&gt;window-&gt;surface, 
+		  0,0,background-&gt;w,background-&gt;h, 
+		  game-&gt;window-&gt;x,game-&gt;window-&gt;y,game-&gt;window-&gt;w, game-&gt;window-&gt;h);
+  game-&gt;window-&gt;unlock();
+  while (true) {
+    sprintf(dialog_string[0], &quot;%03d Starbucks  %03d Buckazoids&quot;, s-&gt;starbucks, s-&gt;buckazoids);
+    int r = 0;
+    if (game-&gt;is_local(s-&gt;channel)) 
+      r = tw_do_dialog(game-&gt;window, station_dialog, STATION_DIALOG_DEPART);
+		game-&gt;log_int(s-&gt;channel, r);
+		switch (r) {
+		case STATION_DIALOG_UPGRADE: {
+		  upgrade_menu(this, s);
+				aa_set_mode(AA_DITHER);
+				aa_stretch_blit(background, game-&gt;window-&gt;surface, 
+						0,0,background-&gt;w,background-&gt;h, 
+						game-&gt;window-&gt;x,game-&gt;window-&gt;y,
+						game-&gt;window-&gt;w, game-&gt;window-&gt;h);
+		}
+		  break;
+		case STATION_DIALOG_NEWSHIP: {
+		  buy_new_ship_menu(s);
+		}
+			break;
+		case STATION_DIALOG_REPAIR: {
+		  if (s-&gt;ship-&gt;crew == s-&gt;ship-&gt;crew_max) {
+		    if (game-&gt;is_local(s-&gt;channel)) 
+		      alert(&quot;You don't need repairs&quot;, &quot;&quot;, &quot;&quot;, &quot;Oh, okay&quot;, &quot;I knew that&quot;, 0, 0);
+		    
+		    break;
+		  }
+		  int p = 0;
+		  if (game-&gt;is_local(s-&gt;channel)) 
+		    p = alert3(&quot;Which would you prefer&quot;, &quot;to pay for your repairs&quot;, &quot;&quot;, &quot;1 &amp;Starbuck&quot;, &quot;1 &amp;Buckazoid&quot;, &quot;&amp;Nothing!&quot;, 's', 'b', 'n');
+		  game-&gt;log_int(s-&gt;channel, p);
+		  switch (p) {
+		  case 1: {
+		    if (s-&gt;starbucks) {
+		      s-&gt;starbucks -= 1;
+		      s-&gt;ship-&gt;crew = s-&gt;ship-&gt;crew_max;
+		    }
+		    else {
+		      if (game-&gt;is_local(s-&gt;channel)) 
+			alert(&quot;You don't have enough!&quot;, NULL, NULL, &quot;&amp;Shit&quot;, NULL, 's', 0);
+		    }
+						}
+		    break;
+		  case 2: {
+		    if (s-&gt;buckazoids) {
+		      s-&gt;buckazoids -= 1;
+		      s-&gt;ship-&gt;crew = s-&gt;ship-&gt;crew_max;
+		    }
+		    else {
+							if (game-&gt;is_local(s-&gt;channel)) 
+							  alert(&quot;You don't have enough!&quot;, NULL, NULL, &quot;&amp;Shit&quot;, NULL, 's', 0);
+		    }
+		  }
+		    break;
+		  case 3: {
+		    r = STATION_DIALOG_DEPART;
+		  }
+					break;
+		  }
+		}
+		  break;
+			}
+		if (r == STATION_DIALOG_DEPART) break;
+  }
+  return;
+}
+void GobStation::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
+	SpaceObject::inflict_damage(other);
+	if (!other-&gt;isShip()) return;
+	GobPlayer *p = gobgame-&gt;get_player(other);
+	if (!p) return;
+	gobgame-&gt;pause();
+	char buffy[256];
+	int a;
+	sprintf(buffy, &quot;First visited station %s at time&quot;, build_type);
+	a = p-&gt;read_pair(buffy);
+	if (a == -1) p-&gt;write_pair(buffy, game-&gt;game_time);
+	sprintf(buffy, &quot;Visited station %s N times&quot;, build_type);
+	a = p-&gt;read_pair(buffy);
+	if (a == -1) a = 0;
+	p-&gt;write_pair(buffy, a+1);
+	station_screen(p);
+	gobgame-&gt;unpause();
+	return;
+	}
+
+
+
+int num_upgrade_indexes;
+int upgrade_index[999];
+GobPlayer *upgrade_list_for;
+char *upgradeListboxGetter(int index, int *list_size) {
+	static char tmp[150];
+	if(index &lt; 0) {
+		*list_size = num_upgrade_indexes;
+		return NULL;
+		}
+	int i = upgrade_index[index];
+	sprintf(tmp, &quot;%1d %3d s$ / %3d b$  :  %s&quot;, upgrade_list_for-&gt;upgrade_list[i]-&gt;num, upgrade_list_for-&gt;upgrade_list[i]-&gt;starbucks, upgrade_list_for-&gt;upgrade_list[i]-&gt;buckazoids, upgrade_list_for-&gt;upgrade_list[i]-&gt;name);
+	return tmp;
+	}
+#define UPGRADE_DIALOG_EXIT 0
+#define UPGRADE_DIALOG_LIST 3
+static DIALOG upgrade_dialog[] =
+{// (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)     (d1)  (d2)  (dp)
+  { d_agup_button_proc,     10,  415,  170,  30,   255,  0,    0,    D_EXIT,     0,    0,    (void *)&quot;Station menu&quot; , NULL, NULL },
+  { d_agup_textbox_proc,    20,  40,   250,  40,   255,  0,    0,    D_EXIT,     0,    0,    (void *)&quot;Upgrade Menu&quot;, NULL, NULL },
+  { d_agup_text_proc,       10,  100,  540,  20,   255,  0,    0,    D_EXIT,     0,    0,    (void *)&quot; # Starbucks Buckazoids Description                     &quot;, NULL, NULL },
+  { d_agup_list_proc,       10,  120,  540,  280,  255,  0,    0,    D_EXIT,     0,    0,    (void *) upgradeListboxGetter, NULL, NULL },
+  { d_agup_text_proc,       185, 420,  270,  30,   255,  0,    0,    0,          0,    0,    dialog_string[0], NULL, NULL },
+  { d_tw_yield_proc,        0,    0,    0,    0,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { NULL,              0,    0,    0,    0,   255,  0,    0,    0,          0,    0,    NULL, NULL, NULL }
+};
+
+void GobStation::upgrade_menu(GobStation *station, GobPlayer *gs) {
+  STACKTRACE;
+  int i;
+  upgrade_list_for = gs;
+  clear_to_color(screen, palette_color[8]);
+  while (true) {
+    sprintf(dialog_string[0], &quot;%03d Starbucks  %03d Buckazoids&quot;, gs-&gt;starbucks, gs-&gt;buckazoids);
+    int j = 0;
+    for (i = 0; gs-&gt;upgrade_list[i]; i += 1) {
+      if (gs-&gt;upgrade_list[i]-&gt;update(gs-&gt;ship, station, gs)) {
+	upgrade_index[j] = i;
+	j += 1;
+      }
+    }
+    num_upgrade_indexes = j;
+    int m = 0;
+    if (game-&gt;is_local(gs-&gt;channel))
+      m = tw_do_dialog(game-&gt;window, upgrade_dialog, UPGRADE_DIALOG_EXIT);
+    game-&gt;log_int(gs-&gt;channel, m);
+		if (m == UPGRADE_DIALOG_EXIT) return;
+		if (m == UPGRADE_DIALOG_LIST) {
+			int i = 0;
+			if (game-&gt;is_local(gs-&gt;channel))
+				i = upgrade_dialog[UPGRADE_DIALOG_LIST].d1;
+			game-&gt;log_int(gs-&gt;channel, i);
+			i = upgrade_index[i];
+			Upgrade *u = gs-&gt;upgrade_list[i];
+			if (gs-&gt;charge(u-&gt;name, u-&gt;starbucks, u-&gt;buckazoids)) {
+				u-&gt;execute(gs-&gt;ship, station, gs);
+				u-&gt;charge(gs);
+				}
+			}
+		}
+	return;
+	}
+
+GobDefender::GobDefender ( Ship *ship) 
+: SpaceObject (ship, ship-&gt;normal_pos(), 0, gobgame-&gt;defenderSprite)
+{
+	base_phase = 0;
+	next_shoot_time = 0;
+	collide_flag_anyone = 0;
+}
+void GobDefender::calculate() {
+  STACKTRACE;
+	SpaceObject::calculate();
+	if (!ship) {
+		die();
+		return;
+	}
+	if (next_shoot_time &lt; gobgame-&gt;game_time) {
+		SpaceObject *target = NULL;
+		Query q;
+		q.begin(this, OBJECT_LAYERS &amp;~ bit(LAYER_SHIPS), 300);
+		while (q.currento &amp;&amp; !target) {
+			if (!q.currento-&gt;sameTeam(ship)) {
+				SpaceLine *l = new PointLaser ( 
+					this, palette_color[4], 2, 150, 
+					this, q.currento
+					);
+				add(l);
+				if (l-&gt;exists()) target = q.currento;
+			}
+			q.next();
+		}
+		if (target) {
+			next_shoot_time = gobgame-&gt;game_time + 400;
+		}
+	}
+	double a = base_phase + (gobgame-&gt;game_time % 120000) * ( PI2 / 1000.0) / 6;
+	angle = normalize(a,PI2);
+	pos = normalize(ship-&gt;normal_pos() + 270 * unit_vector ( angle ));
+	return;
+}
+
+RainbowRift::RainbowRift () 
+//: SpaceLocation ( NULL, 12800, 12800, 0) 
+: SpaceLocation ( NULL, random(map_size), 0) 
+{
+	int i;
+	collide_flag_sameship = 0;
+	collide_flag_sameteam = 0;
+	collide_flag_anyone = 0;
+	for (i = n*6-6; i &lt; n*6+2; i += 1) {
+		p[i] = 75 + random(150.0);
+	}
+	for (i = 0; i &lt; n; i += 1) {
+		squiggle();
+	}
+	next_time = game-&gt;game_time;
+	next_time2 = game-&gt;game_time;
+}
+void RainbowRift::animate( Frame *frame ) {
+  STACKTRACE;
+	Vector2 s;
+	s = corner(pos, Vector2(300,300));
+	if ((s.x &lt; -500) || (s.x &gt; space_view_size.x + 500) || 
+		(s.y &lt; -500) || (s.y &gt; space_view_size.y + 500))
+		return;
+	int b[n*6+2];
+	int i;
+	for (i = 0; i &lt; n*6+2; i += 2) { 
+		b[i] = iround(s.x + p[i] * space_zoom);
+		b[i+1] = iround(s.y + p[i+1] * space_zoom);
+	}
+	for (i = 0; i &lt; n; i += 1) {
+		RGB tc = c[n-i-1];
+		int a = tw_color(tc.r, tc.g, tc.b);
+		spline ( frame-&gt;surface, &amp;b[i*6], a );
+	}
+	frame-&gt;add_box ( 
+		iround(s.x - 2), iround(s.y -2), 
+		iround(300 * space_zoom+5), iround(300 * space_zoom+5)
+		);
+	return;
+}
+void RainbowRift::squiggle() {
+  STACKTRACE;
+	int i;
+	int m = n*6+2;
+	for (i = 0; i &lt; m - 6; i += 1) {
+		p[i] = p[i+6];
+	}
+	p[m-6] = p[m-8] * 2 - p[m-10];
+	p[m-5] = p[m-7] * 2 - p[m-9];
+	p[m-4] = 75 + random(150.0);
+	p[m-3] = 75 + random(150.0);
+	p[m-2] = 75 + random(150.0);
+	p[m-1] = 75 + random(150.0);
+	for (i = 0; i &lt; n-1; i += 1) {
+		c[i] = c[i+1];
+	}
+	int r, g, b;
+	r = int(game-&gt;game_time * 0.5) % 360;
+	hsv_to_rgb( r, 1.0, 1.0, &amp;r, &amp;g, &amp;b );
+	c[n-1].r = r;
+	c[n-1].g = g;
+	c[n-1].b = b;
+	return;
+}
+void RainbowRift::calculate() {
+  STACKTRACE;
+	while (game-&gt;game_time &gt; next_time) {
+		next_time += 25;
+		squiggle();
+	}
+	while (game-&gt;game_time &gt; next_time2) {
+		next_time2 += random() % 10000;
+		Query q;
+		for (q.begin(this, bit(LAYER_SHIPS), 40); q.current; q.next()) {
+			GobPlayer *p = gobgame-&gt;get_player(q.currento);
+			if (q.currento == p-&gt;ship) {
+				int i = 0;
+				i = p-&gt;control-&gt;choose_ship(game-&gt;window, &quot;You found the Rainbow Rift!&quot;, reference_fleet);
+				game-&gt;log_int(p-&gt;channel, i);
+				if (i == -1) 
+				  i = random(reference_fleet-&gt;getSize());
+				game-&gt;redraw();
+				if (reference_fleet-&gt;getShipType(i) == p-&gt;ship-&gt;type) {
+					p-&gt;starbucks += random() % 80;
+					p-&gt;buckazoids += random() % 80;
+					game-&gt;add(new RainbowRift());
+				}
+				else {
+					p-&gt;starbucks += random() % (1+p-&gt;value_starbucks);
+					p-&gt;buckazoids += random() % (1+p-&gt;value_buckazoids);
+					p-&gt;new_ship(reference_fleet-&gt;getShipType(i));
+				}
+				die();
+			}
+		}
+	}
+	return;
+}
+
+
+REGISTER_GAME(GobGame, &quot;GOB&quot;)
+
+
+
+/* intended upgrades:
+
+faster marines       == faster Orz Marines, cost 4s
+upgrade battle armor == tougher Orz Marines, cost 4s/4b
+improve range        == long range Orz cannons, cost 3s
+regeneration         == crew regeneration for Orz, cost 10s/25b, only purchasable once
+sharper shurikens    == +1 damage for Kohr-Ah blades, cost 5s
+faster shurikens     == higher velocity for Kohr-Ah blades, cost 4s
+larger corona        == longer range for Kohr-Ah FRIED, cost 15s, only purchasable once
+hotter corona        == double damage for Kohr-Ah FRIED, cost 10s, only purchasable once
+divine favor         == pkunk respawn, only available from one base, cost 48s/0b, only purchasable once, kept when ship is sold
+sentinel system      == Chmmr ZapSats, only available from one base, cost 30s/30b
+
+long range scanners  == can zoom farther out, gives radar, only available from one base, cost 8s/20b
+
+*/

Added: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/games/ggob.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,171 @@
+/*
+This file is part of &quot;TW-Light&quot; 
+                    <A HREF="http://tw-light.berlios.de/">http://tw-light.berlios.de/</A>
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef TW_GOB_H_INCLUDES
+#define TW_GOB_H_INCLUDES
+
+#include &quot;melee.h&quot;
+#include &quot;melee/mframe.h&quot;
+#include &quot;melee/mgame.h&quot;
+#include &quot;melee/mitems.h&quot;
+
+class Upgrade;
+class GobStation;
+
+/// Player possession (ship, money, upgrades)
+class GobPlayer 
+{
+ public:
+  int channel;
+  ~GobPlayer();
+  Ship *ship;
+  Control *control;
+  ShipPanel *panel;
+  struct pair 
+  {
+    char *id;
+    int value;
+  };
+  pair *pair_list;
+  int num_pairs;
+  void _add_pair(const char *id, int value);
+  pair *_get_pair(const char *id);
+  void write_pair(const char *id, int value);
+  int read_pair(const char *id);
+  int total;         ///&lt;total upgrades purchased, used in calculating price of future upgrades
+  int starbucks;
+  int buckazoids;
+  int kills;
+  int value_starbucks;
+  int value_buckazoids;
+  TeamCode team;
+  void init(Control *c, TeamCode team);
+  void died(SpaceLocation *killer);
+  void new_ship(ShipType *type);
+  int charge (char *name, int price_starbucks, int price_buckazoids) ;
+  Upgrade **upgrade_list;
+} ;
+
+/// Enemy starship, reward for it
+class GobEnemy 
+{
+ public:
+  Ship *ship;
+  int starbucks;
+  int buckazoids;
+  void init(Ship *ship, int kill_starbucks, int kill_buckazoids);
+  void died (SpaceLocation *what);
+} ;
+
+/// Asteroid that add money to it's killer
+class GobAsteroid : public Asteroid 
+{
+ public:
+  virtual int handle_damage (SpaceLocation *source, double normal, double direct);
+  virtual void death();
+};
+
+/// Full future adventure game
+class GobGame : public Game 
+{
+ public:
+  virtual ~GobGame();
+
+  TeamCode enemy_team;
+
+  virtual void calculate();
+  virtual void ship_died(Ship *who, SpaceLocation *source);
+  virtual void preinit();
+  virtual void init (Log *log);
+
+  virtual void play_sound (SAMPLE *sample, SpaceLocation *source, int vol = 256, int freq = 1000);
+	
+  int gobplayers;
+  GobPlayer **gobplayer;
+  virtual void add_gobplayer(Control *control);
+  virtual GobPlayer *get_player(SpaceLocation *what);
+  int gobenemies, max_enemies;
+  GobEnemy **gobenemy;
+  virtual int get_enemy_index(SpaceLocation *what);
+  
+  //	protected:
+  virtual void fps ();
+  
+  void add_new_enemy();
+  
+  int next_add_new_enemy_time;
+  
+  SpaceSprite *stationSprite[3];
+  char *station_pic_name[3];
+  char *station_build_name[3];
+  SpaceSprite *defenderSprite;
+  
+ public:
+  int num_planets;
+  Planet *planet[16];
+  GobStation *station[16];
+  void add_planet_and_station ( SpaceSprite *planet_sprite, int planet_index, SpaceSprite *station_sprite, const char *builds, const char *background);
+};
+
+/// Station where player can buy upgrades and repair his ship
+class GobStation : public Orbiter {
+ public:
+  const char *build_type;
+  const char *background_pic;
+  GobStation ( SpaceSprite *pic, SpaceLocation *orbit_me, const char *ship, const char *background);
+  virtual void buy_new_ship_menu(GobPlayer *s) ;
+  virtual void inflict_damage(SpaceObject *other);
+  virtual void station_screen (GobPlayer *s);
+  virtual void upgrade_menu(GobStation *station, GobPlayer *gs) ;
+};
+
+/// Custom upgrade to ship
+class Upgrade 
+{
+ public:
+  enum {
+    active, inactive
+  };
+  char *name;
+  int starbucks;
+  int buckazoids;
+  int status;
+  int num;
+  int index;
+  virtual bool update(Ship *ship, GobStation *station, GobPlayer *gp) = 0;
+  //true if listed
+  virtual void execute(Ship *ship, GobStation *station, GobPlayer *gp) = 0;
+  virtual void charge(GobPlayer *gp);
+  virtual void clear(Ship *oship, Ship *nship, GobPlayer *gp);
+  virtual Upgrade *duplicate() = 0;
+};
+
+/// Strange space location
+class RainbowRift : public SpaceLocation 
+{
+ public:
+  enum { n = 2 };
+  float p[n * 6 + 2];
+  RGB c[n];
+  int next_time, next_time2;
+  RainbowRift ();
+  virtual void animate ( Frame *frame );
+  virtual void calculate () ;
+  void squiggle();
+};
+
+#endif // TW_GOB_H_INCLUDES
+

Added: trunk/source/libraries/lua/Makefile
===================================================================
--- trunk/source/libraries/lua/Makefile	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/Makefile	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,85 @@
+# makefile for Lua core library
+
+LUA= ..
+
+include $(LUA)/config
+
+OBJS=	\
+	lapi.o \
+	lcode.o \
+	ldebug.o \
+	ldo.o \
+	ldump.o \
+	lfunc.o \
+	lgc.o \
+	llex.o \
+	lmem.o \
+	lobject.o \
+	lopcodes.o \
+	lparser.o \
+	lstate.o \
+	lstring.o \
+	ltable.o \
+	ltests.o \
+	ltm.o \
+	lundump.o \
+	lvm.o \
+	lzio.o
+
+SRCS=	\
+	lapi.c \
+	lcode.c \
+	ldebug.c \
+	ldo.c \
+	ldump.c \
+	lfunc.c \
+	lgc.c \
+	llex.c \
+	lmem.c \
+	lobject.c \
+	lopcodes.c \
+	lparser.c \
+	lstate.c \
+	lstring.c \
+	ltable.c \
+	ltests.c \
+	ltm.c \
+	lundump.c \
+	lvm.c \
+	lzio.c \
+	lapi.h \
+	lcode.h \
+	ldebug.h \
+	ldo.h \
+	lfunc.h \
+	lgc.h \
+	llex.h \
+	llimits.h \
+	lmem.h \
+	lobject.h \
+	lopcodes.h \
+	lparser.h \
+	lstate.h \
+	lstring.h \
+	ltable.h \
+	ltm.h \
+	lundump.h \
+	lvm.h \
+	lzio.h
+
+T= $(LIB)/liblua.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/source/libraries/lua/README
===================================================================
--- trunk/source/libraries/lua/README	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/README	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,5 @@
+This is the Lua core.
+
+The standard Lua library are in lib/.
+A sample interpreter is in lua/.
+A standalone compiler is in luac/.

Added: trunk/source/libraries/lua/lapi.c
===================================================================
--- trunk/source/libraries/lua/lapi.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lapi.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,922 @@
+/*
+** $Id: lapi.c,v 1.235 2003/04/07 14:36:08 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#define lapi_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lapi.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lundump.h&quot;
+#include &quot;lvm.h&quot;
+
+
+const char lua_ident[] =
+  &quot;$Lua: &quot; LUA_VERSION &quot; &quot; LUA_COPYRIGHT &quot; $\n&quot;
+  &quot;$Authors: &quot; LUA_AUTHORS &quot; $\n&quot;
+  &quot;$URL: www.lua.org $\n&quot;;
+
+
+
+#ifndef api_check
+#define api_check(L, o)		/*{ assert(o); }*/
+#endif
+
+#define api_checknelems(L, n)	api_check(L, (n) &lt;= (L-&gt;top - L-&gt;base))
+
+#define api_incr_top(L)   {api_check(L, L-&gt;top &lt; L-&gt;ci-&gt;top); L-&gt;top++;}
+
+
+
+
+static TObject *negindex (lua_State *L, int idx) {
+  if (idx &gt; LUA_REGISTRYINDEX) {
+    api_check(L, idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - L-&gt;base);
+    return L-&gt;top+idx;
+  }
+  else switch (idx) {  /* pseudo-indices */
+    case LUA_REGISTRYINDEX: return registry(L);
+    case LUA_GLOBALSINDEX: return gt(L);
+    default: {
+      TObject *func = (L-&gt;base - 1);
+      idx = LUA_GLOBALSINDEX - idx;
+      lua_assert(iscfunction(func));
+      return (idx &lt;= clvalue(func)-&gt;c.nupvalues)
+                ? &amp;clvalue(func)-&gt;c.upvalue[idx-1]
+                : NULL;
+    }
+  }
+}
+
+
+static TObject *luaA_index (lua_State *L, int idx) {
+  if (idx &gt; 0) {
+    api_check(L, idx &lt;= L-&gt;top - L-&gt;base);
+    return L-&gt;base + idx - 1;
+  }
+  else {
+    TObject *o = negindex(L, idx);
+    api_check(L, o != NULL);
+    return o;
+  }
+}
+
+
+static TObject *luaA_indexAcceptable (lua_State *L, int idx) {
+  if (idx &gt; 0) {
+    TObject *o = L-&gt;base+(idx-1);
+    api_check(L, idx &lt;= L-&gt;stack_last - L-&gt;base);
+    if (o &gt;= L-&gt;top) return NULL;
+    else return o;
+  }
+  else
+    return negindex(L, idx);
+}
+
+
+void luaA_pushobject (lua_State *L, const TObject *o) {
+  setobj2s(L-&gt;top, o);
+  incr_top(L);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  lua_lock(L);
+  if ((L-&gt;top - L-&gt;base + size) &gt; LUA_MAXCSTACK)
+    res = 0;  /* stack overflow */
+  else {
+    luaD_checkstack(L, size);
+    if (L-&gt;ci-&gt;top &lt; L-&gt;top + size)
+      L-&gt;ci-&gt;top = L-&gt;top + size;
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  lua_lock(to);
+  api_checknelems(from, n);
+  from-&gt;top -= n;
+  for (i = 0; i &lt; n; i++) {
+    setobj2s(to-&gt;top, from-&gt;top + i);
+    api_incr_top(to);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)-&gt;panic;
+  G(L)-&gt;panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = luaE_newthread(L);
+  setthvalue(L-&gt;top, L1);
+  api_incr_top(L);
+  lua_unlock(L);
+  lua_userstateopen(L1);
+  return L1;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return (L-&gt;top - L-&gt;base);
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  lua_lock(L);
+  if (idx &gt;= 0) {
+    api_check(L, idx &lt;= L-&gt;stack_last - L-&gt;base);
+    while (L-&gt;top &lt; L-&gt;base + idx)
+      setnilvalue(L-&gt;top++);
+    L-&gt;top = L-&gt;base + idx;
+  }
+  else {
+    api_check(L, -(idx+1) &lt;= (L-&gt;top - L-&gt;base));
+    L-&gt;top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  while (++p &lt; L-&gt;top) setobjs2s(p-1, p);
+  L-&gt;top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = luaA_index(L, idx);
+  for (q = L-&gt;top; q&gt;p; q--) setobjs2s(q, q-1);
+  setobjs2s(p, L-&gt;top);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  setobj(luaA_index(L, idx), L-&gt;top - 1);  /* write barrier */
+  L-&gt;top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L-&gt;top, luaA_index(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -&gt; C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? LUA_TNONE : ttype(o);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return (t == LUA_TNONE) ? &quot;no value&quot; : luaT_typenames[t];
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL) ? 0 : iscfunction(o);
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL &amp;&amp; tonumber(o, &amp;n));
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL &amp;&amp; (ttisuserdata(o) || ttislightuserdata(o)));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = luaA_indexAcceptable(L, index1);
+  StkId o2 = luaA_indexAcceptable(L, index2);
+  return (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                    : luaO_rawequalObj(o1, o2);
+}
+
+
+LUA_API int lua_equal (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out of range */
+                                 : equalobj(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API int lua_lessthan (lua_State *L, int index1, int index2) {
+  StkId o1, o2;
+  int i;
+  lua_lock(L);  /* may call tag method */
+  o1 = luaA_indexAcceptable(L, index1);
+  o2 = luaA_indexAcceptable(L, index2);
+  i = (o1 == NULL || o2 == NULL) ? 0  /* index out-of-range */
+                                 : luaV_lessthan(L, o1, o2);
+  lua_unlock(L);
+  return i;
+}
+
+
+
+LUA_API lua_Number lua_tonumber (lua_State *L, int idx) {
+  TObject n;
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  if (o != NULL &amp;&amp; tonumber(o, &amp;n))
+    return nvalue(o);
+  else
+    return 0;
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TObject *o = luaA_indexAcceptable(L, idx);
+  return (o != NULL) &amp;&amp; !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tostring (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return NULL;
+  else if (ttisstring(o))
+    return svalue(o);
+  else {
+    const char *s;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    s = (luaV_tostring(L, o) ? svalue(o) : NULL);
+    luaC_checkGC(L);
+    lua_unlock(L);
+    return s;
+  }
+}
+
+
+LUA_API size_t lua_strlen (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL)
+    return 0;
+  else if (ttisstring(o))
+    return tsvalue(o)-&gt;tsv.len;
+  else {
+    size_t l;
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    l = (luaV_tostring(L, o) ? tsvalue(o)-&gt;tsv.len : 0);
+    lua_unlock(L);
+    return l;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !iscfunction(o)) ? NULL : clvalue(o)-&gt;c.f;
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  switch (ttype(o)) {
+    case LUA_TUSERDATA: return (uvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  return (o == NULL || !ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = luaA_indexAcceptable(L, idx);
+  if (o == NULL) return NULL;
+  else {
+    switch (ttype(o)) {
+      case LUA_TTABLE: return hvalue(o);
+      case LUA_TFUNCTION: return clvalue(o);
+      case LUA_TTHREAD: return thvalue(o);
+      case LUA_TUSERDATA:
+      case LUA_TLIGHTUSERDATA:
+        return lua_touserdata(L, idx);
+      default: return NULL;
+    }
+  }
+}
+
+
+
+/*
+** push functions (C -&gt; stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L-&gt;top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L-&gt;top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  setsvalue2s(L-&gt;top, luaS_newlstr(L, s, len));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL)
+    lua_pushnil(L);
+  else
+    lua_pushlstring(L, s, strlen(s));
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  Closure *cl;
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  cl = luaF_newCclosure(L, n);
+  cl-&gt;c.f = fn;
+  L-&gt;top -= n;
+  while (n--)
+    setobj2n(&amp;cl-&gt;c.upvalue[n], L-&gt;top+n);
+  setclvalue(L-&gt;top, cl);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L-&gt;top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L-&gt;top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** get functions (Lua -&gt; stack)
+*/
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  setobj2s(L-&gt;top - 1, luaV_gettable(L, t, L-&gt;top - 1, 0));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2s(L-&gt;top - 1, luaH_get(hvalue(t), L-&gt;top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2s(L-&gt;top, luaH_getnum(hvalue(o), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_newtable (lua_State *L) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  sethvalue(L-&gt;top, luaH_new(L, 0, 0));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TObject *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = luaA_indexAcceptable(L, objindex);
+  if (obj != NULL) {
+    switch (ttype(obj)) {
+      case LUA_TTABLE:
+        mt = hvalue(obj)-&gt;metatable;
+        break;
+      case LUA_TUSERDATA:
+        mt = uvalue(obj)-&gt;uv.metatable;
+        break;
+    }
+  }
+  if (mt == NULL || mt == hvalue(defaultmeta(L)))
+    res = 0;
+  else {
+    sethvalue(L-&gt;top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getfenv (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = luaA_index(L, idx);
+  setobj2s(L-&gt;top, isLfunction(o) ? &amp;clvalue(o)-&gt;l.g : gt(L));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -&gt; Lua)
+*/
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  luaV_settable(L, t, L-&gt;top - 2, L-&gt;top - 1);
+  L-&gt;top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  setobj2t(luaH_set(L, hvalue(t), L-&gt;top-2), L-&gt;top-1);  /* write barrier */
+  L-&gt;top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  api_check(L, ttistable(o));
+  setobj2t(luaH_setnum(L, hvalue(o), n), L-&gt;top-1);  /* write barrier */
+  L-&gt;top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TObject *obj, *mt;
+  int res = 1;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = luaA_index(L, objindex);
+  mt = (!ttisnil(L-&gt;top - 1)) ? L-&gt;top - 1 : defaultmeta(L);
+  api_check(L, ttistable(mt));
+  switch (ttype(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)-&gt;metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)-&gt;uv.metatable = hvalue(mt);  /* write barrier */
+      break;
+    }
+    default: {
+      res = 0;  /* cannot set */
+      break;
+    }
+  }
+  L-&gt;top--;
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API int lua_setfenv (lua_State *L, int idx) {
+  StkId o;
+  int res = 0;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = luaA_index(L, idx);
+  L-&gt;top--;
+  api_check(L, ttistable(L-&gt;top));
+  if (isLfunction(o)) {
+    res = 1;
+    clvalue(o)-&gt;l.g = *(L-&gt;top);
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+LUA_API void lua_call (lua_State *L, int nargs, int nresults) {
+  StkId func;
+  lua_lock(L);
+  api_checknelems(L, nargs+1);
+  func = L-&gt;top - (nargs+1);
+  luaD_call(L, func, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c-&gt;func, c-&gt;nresults);
+}
+
+
+
+LUA_API int lua_pcall (lua_State *L, int nargs, int nresults, int errfunc) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  func = (errfunc == 0) ? 0 : savestack(L, luaA_index(L, errfunc));
+  c.func = L-&gt;top - (nargs+1);  /* function to be called */
+  c.nresults = nresults;
+  status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Execute a protected C call.
+*/
+struct CCallS {  /* data to `f_Ccall' */
+  lua_CFunction func;
+  void *ud;
+};
+
+
+static void f_Ccall (lua_State *L, void *ud) {
+  struct CCallS *c = cast(struct CCallS *, ud);
+  Closure *cl;
+  cl = luaF_newCclosure(L, 0);
+  cl-&gt;c.f = c-&gt;func;
+  setclvalue(L-&gt;top, cl);  /* push function */
+  incr_top(L);
+  setpvalue(L-&gt;top, c-&gt;ud);  /* push only argument */
+  incr_top(L);
+  luaD_call(L, L-&gt;top - 2, 0);
+}
+
+
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud) {
+  struct CCallS c;
+  int status;
+  lua_lock(L);
+  c.func = func;
+  c.ud = ud;
+  status = luaD_pcall(L, f_Ccall, &amp;c, savestack(L, L-&gt;top), 0);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Chunkreader reader, void *data,
+                      const char *chunkname) {
+  ZIO z;
+  int status;
+  int c;
+  lua_lock(L);
+  if (!chunkname) chunkname = &quot;?&quot;;
+  luaZ_init(&amp;z, reader, data, chunkname);
+  c = luaZ_lookahead(&amp;z);
+  status = luaD_protectedparser(L, &amp;z, (c == LUA_SIGNATURE[0]));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data) {
+  int status;
+  TObject *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L-&gt;top - 1;
+  if (isLfunction(o) &amp;&amp; clvalue(o)-&gt;l.nupvalues == 0) {
+    luaU_dump(L, clvalue(o)-&gt;l.p, writer, data);
+    status = 1;
+  }
+  else
+    status = 0;
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** Garbage-collection functions
+*/
+
+/* GC values are expressed in Kbytes: #bytes/2^10 */
+#define GCscalel(x)		((x)&gt;&gt;10)
+#define GCscale(x)		(cast(int, GCscalel(x)))
+#define GCunscale(x)		(cast(lu_mem, x)&lt;&lt;10)
+
+LUA_API int lua_getgcthreshold (lua_State *L) {
+  int threshold;
+  lua_lock(L);
+  threshold = GCscale(G(L)-&gt;GCthreshold);
+  lua_unlock(L);
+  return threshold;
+}
+
+LUA_API int lua_getgccount (lua_State *L) {
+  int count;
+  lua_lock(L);
+  count = GCscale(G(L)-&gt;nblocks);
+  lua_unlock(L);
+  return count;
+}
+
+LUA_API void lua_setgcthreshold (lua_State *L, int newthreshold) {
+  lua_lock(L);
+  if (cast(lu_mem, newthreshold) &gt; GCscalel(MAX_LUMEM))
+    G(L)-&gt;GCthreshold = MAX_LUMEM;
+  else
+    G(L)-&gt;GCthreshold = GCunscale(newthreshold);
+  luaC_checkGC(L);
+  lua_unlock(L);
+}
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API const char *lua_version (void) {
+  return LUA_VERSION;
+}
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  lua_unlock(L);
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = luaA_index(L, idx);
+  api_check(L, ttistable(t));
+  more = luaH_next(L, hvalue(t), L-&gt;top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L-&gt;top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  luaC_checkGC(L);
+  api_checknelems(L, n);
+  if (n &gt;= 2) {
+    luaV_concat(L, n, L-&gt;top - L-&gt;base - 1);
+    L-&gt;top -= (n-1);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L-&gt;top, luaS_newlstr(L, NULL, 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size);
+  setuvalue(L-&gt;top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+LUA_API int lua_pushupvalues (lua_State *L) {
+  Closure *func;
+  int n, i;
+  lua_lock(L);
+  api_check(L, iscfunction(L-&gt;base - 1));
+  func = clvalue(L-&gt;base - 1);
+  n = func-&gt;c.nupvalues;
+  luaD_checkstack(L, n + LUA_MINSTACK);
+  for (i=0; i&lt;n; i++) {
+    setobj2s(L-&gt;top, &amp;func-&gt;c.upvalue[i]);
+    L-&gt;top++;
+  }
+  lua_unlock(L);
+  return n;
+}
+
+
+static const char *aux_upvalue (lua_State *L, int funcindex, int n,
+                                TObject **val) {
+  Closure *f;
+  StkId fi = luaA_index(L, funcindex);
+  if (!ttisfunction(fi)) return NULL;
+  f = clvalue(fi);
+  if (f-&gt;c.isC) {
+    if (n &gt; f-&gt;c.nupvalues) return NULL;
+    *val = &amp;f-&gt;c.upvalue[n-1];
+    return &quot;&quot;;
+  }
+  else {
+    Proto *p = f-&gt;l.p;
+    if (n &gt; p-&gt;sizeupvalues) return NULL;
+    *val = f-&gt;l.upvals[n-1]-&gt;v;
+    return getstr(p-&gt;upvalues[n-1]);
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  name = aux_upvalue(L, funcindex, n, &amp;val);
+  if (name) {
+    setobj2s(L-&gt;top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TObject *val;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  name = aux_upvalue(L, funcindex, n, &amp;val);
+  if (name) {
+    L-&gt;top--;
+    setobj(val, L-&gt;top);  /* write barrier */
+  }
+  lua_unlock(L);
+  return name;
+}
+

Added: trunk/source/libraries/lua/lapi.h
===================================================================
--- trunk/source/libraries/lua/lapi.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lapi.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,16 @@
+/*
+** $Id: lapi.h,v 1.21 2002/03/04 21:29:41 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include &quot;lobject.h&quot;
+
+
+void luaA_pushobject (lua_State *L, const TObject *o);
+
+#endif

Added: trunk/source/libraries/lua/lauxlib.h
===================================================================
--- trunk/source/libraries/lua/lauxlib.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lauxlib.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,145 @@
+/*
+** $Id: lauxlib.h,v 1.60 2003/04/03 13:35:34 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include &lt;stddef.h&gt;
+#include &lt;stdio.h&gt;
+
+#include &quot;lua.h&quot;
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+
+typedef struct luaL_reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_reg;
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_reg *l, int nup);
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *e);
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname);
+LUALIB_API int luaL_argerror (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *luaL_checklstring (lua_State *L, int numArg, size_t *l);
+LUALIB_API const char *luaL_optlstring (lua_State *L, int numArg,
+                                           const char *def, size_t *l);
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int numArg);
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API void luaL_checkstack (lua_State *L, int sz, const char *msg);
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t);
+LUALIB_API void luaL_checkany (lua_State *L, int narg);
+
+LUALIB_API int   luaL_newmetatable (lua_State *L, const char *tname);
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname);
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void luaL_where (lua_State *L, int lvl);
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int luaL_findstring (const char *st, const char *const lst[]);
+
+LUALIB_API int luaL_ref (lua_State *L, int t);
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref);
+
+LUALIB_API int luaL_getn (lua_State *L, int t);
+LUALIB_API void luaL_setn (lua_State *L, int t, int n);
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename);
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t sz,
+                                const char *name);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define luaL_argcheck(L, cond,numarg,extramsg) if (!(cond)) \
+                                               luaL_argerror(L, numarg,extramsg)
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checknumber(L, n))
+#define luaL_checklong(L,n)	((long)luaL_checknumber(L, n))
+#define luaL_optint(L,n,d)	((int)luaL_optnumber(L, n,(lua_Number)(d)))
+#define luaL_optlong(L,n,d)	((long)luaL_optnumber(L, n,(lua_Number)(d)))
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#ifndef LUAL_BUFFERSIZE
+#define LUAL_BUFFERSIZE	  BUFSIZ
+#endif
+
+
+typedef struct luaL_Buffer {
+  char *p;			/* current position in buffer */
+  int lvl;  /* number of strings in the stack (level) */
+  lua_State *L;
+  char buffer[LUAL_BUFFERSIZE];
+} luaL_Buffer;
+
+#define luaL_putchar(B,c) \
+  ((void)((B)-&gt;p &lt; ((B)-&gt;buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
+   (*(B)-&gt;p++ = (char)(c)))
+
+#define luaL_addsize(B,n)	((B)-&gt;p += (n))
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B);
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s);
+LUALIB_API void luaL_addvalue (luaL_Buffer *B);
+LUALIB_API void luaL_pushresult (luaL_Buffer *B);
+
+
+/* }====================================================== */
+
+
+
+/*
+** Compatibility macros and functions
+*/
+
+LUALIB_API int   lua_dofile (lua_State *L, const char *filename);
+LUALIB_API int   lua_dostring (lua_State *L, const char *str);
+LUALIB_API int   lua_dobuffer (lua_State *L, const char *buff, size_t sz,
+                               const char *n);
+
+
+#define luaL_check_lstr 	luaL_checklstring
+#define luaL_opt_lstr 	luaL_optlstring 
+#define luaL_check_number 	luaL_checknumber 
+#define luaL_opt_number	luaL_optnumber
+#define luaL_arg_check	luaL_argcheck
+#define luaL_check_string	luaL_checkstring
+#define luaL_opt_string	luaL_optstring
+#define luaL_check_int	luaL_checkint
+#define luaL_check_long	luaL_checklong
+#define luaL_opt_int	luaL_optint
+#define luaL_opt_long	luaL_optlong
+
+
+#endif
+
+

Added: trunk/source/libraries/lua/lcode.c
===================================================================
--- trunk/source/libraries/lua/lcode.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lcode.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,714 @@
+/*
+** $Id: lcode.c,v 1.117 2003/04/03 13:35:34 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lcode_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;ltable.h&quot;
+
+
+#define hasjumps(e)	((e)-&gt;t != (e)-&gt;f)
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  if (fs-&gt;pc &gt; fs-&gt;lasttarget &amp;&amp;  /* no jumps to current position? */
+      GET_OPCODE(*(previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-1])) == OP_LOADNIL) {
+    int pfrom = GETARG_A(*previous);
+    int pto = GETARG_B(*previous);
+    if (pfrom &lt;= from &amp;&amp; from &lt;= pto+1) {  /* can connect both? */
+      if (from+n-1 &gt; pto)
+        SETARG_B(*previous, from+n-1);
+      return;
+    }
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, from+n-1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs-&gt;jpc;  /* save list of jumps to here */
+  int j;
+  fs-&gt;jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &amp;j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+static int luaK_condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void luaK_fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &amp;fs-&gt;f-&gt;code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) &gt; MAXARG_sBx)
+    luaX_syntaxerror(fs-&gt;ls, &quot;control structure too long&quot;);
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs-&gt;lasttarget = fs-&gt;pc;
+  return fs-&gt;pc;
+}
+
+
+static int luaK_getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs-&gt;f-&gt;code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &amp;fs-&gt;f-&gt;code[pc];
+  if (pc &gt;= 1 &amp;&amp; testOpMode(GET_OPCODE(*(pi-1)), OpModeT))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list, int cond) {
+  for (; list != NO_JUMP; list = luaK_getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TEST || GETARG_C(i) != cond) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static void patchtestreg (Instruction *i, int reg) {
+  if (reg == NO_REG) reg = GETARG_B(*i);
+  SETARG_A(*i, reg);
+}
+
+
+static void luaK_patchlistaux (FuncState *fs, int list,
+          int ttarget, int treg, int ftarget, int freg, int dtarget) {
+  while (list != NO_JUMP) {
+    int next = luaK_getjump(fs, list);
+    Instruction *i = getjumpcontrol(fs, list);
+    if (GET_OPCODE(*i) != OP_TEST) {
+      lua_assert(dtarget != NO_JUMP);
+      luaK_fixjump(fs, list, dtarget);  /* jump to default target */
+    }
+    else {
+      if (GETARG_C(*i)) {
+        lua_assert(ttarget != NO_JUMP);
+        patchtestreg(i, treg);
+        luaK_fixjump(fs, list, ttarget);
+      }
+      else {
+        lua_assert(ftarget != NO_JUMP);
+        patchtestreg(i, freg);
+        luaK_fixjump(fs, list, ftarget);
+      }
+    }
+    list = next;
+  }
+}
+
+
+static void luaK_dischargejpc (FuncState *fs) {
+  luaK_patchlistaux(fs, fs-&gt;jpc, fs-&gt;pc, NO_REG, fs-&gt;pc, NO_REG, fs-&gt;pc);
+  fs-&gt;jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs-&gt;pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target &lt; fs-&gt;pc);
+    luaK_patchlistaux(fs, list, target, NO_REG, target, NO_REG, target);
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &amp;fs-&gt;jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = luaK_getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    luaK_fixjump(fs, list, l2);
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs-&gt;freereg + n;
+  if (newstack &gt; fs-&gt;f-&gt;maxstacksize) {
+    if (newstack &gt;= MAXSTACK)
+      luaX_syntaxerror(fs-&gt;ls, &quot;function or expression too complex&quot;);
+    fs-&gt;f-&gt;maxstacksize = cast(lu_byte, newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs-&gt;freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (reg &gt;= fs-&gt;nactvar &amp;&amp; reg &lt; MAXSTACK) {
+    fs-&gt;freereg--;
+    lua_assert(reg == fs-&gt;freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e-&gt;k == VNONRELOC)
+    freereg(fs, e-&gt;info);
+}
+
+
+static int addk (FuncState *fs, TObject *k, TObject *v) {
+  const TObject *idx = luaH_get(fs-&gt;h, k);
+  if (ttisnumber(idx)) {
+    lua_assert(luaO_rawequalObj(&amp;fs-&gt;f-&gt;k[cast(int, nvalue(idx))], v));
+    return cast(int, nvalue(idx));
+  }
+  else {  /* constant not found; create a new entry */
+    Proto *f = fs-&gt;f;
+    luaM_growvector(fs-&gt;L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TObject,
+                    MAXARG_Bx, &quot;constant table overflow&quot;);
+    setobj2n(&amp;f-&gt;k[fs-&gt;nk], v);
+    setnvalue(luaH_set(fs-&gt;L, fs-&gt;h, k), cast(lua_Number, fs-&gt;nk));
+    return fs-&gt;nk++;
+  }
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TObject o;
+  setsvalue(&amp;o, s);
+  return addk(fs, &amp;o, &amp;o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  TObject o;
+  setnvalue(&amp;o, r);
+  return addk(fs, &amp;o, &amp;o);
+}
+
+
+static int nil_constant (FuncState *fs) {
+  TObject k, v;
+  setnilvalue(&amp;v);
+  sethvalue(&amp;k, fs-&gt;h);  /* cannot use nil as key; instead use table itself */
+  return addk(fs, &amp;k, &amp;v);
+}
+
+
+void luaK_setcallreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e-&gt;k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+    if (nresults == 1) {  /* `regular' expression? */
+      e-&gt;k = VNONRELOC;
+      e-&gt;info = GETARG_A(getcode(fs, e));
+    }
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e-&gt;k) {
+    case VLOCAL: {
+      e-&gt;k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e-&gt;info = luaK_codeABC(fs, OP_GETUPVAL, 0, e-&gt;info, 0);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    case VGLOBAL: {
+      e-&gt;info = luaK_codeABx(fs, OP_GETGLOBAL, 0, e-&gt;info);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      freereg(fs, e-&gt;aux);
+      freereg(fs, e-&gt;info);
+      e-&gt;info = luaK_codeABC(fs, OP_GETTABLE, 0, e-&gt;info, e-&gt;aux);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    case VCALL: {
+      luaK_setcallreturns(fs, e, 1);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE:  case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e-&gt;k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codeABx(fs, OP_LOADK, reg, e-&gt;info);
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &amp;getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e-&gt;info)
+        luaK_codeABC(fs, OP_MOVE, reg, e-&gt;info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e-&gt;k == VVOID || e-&gt;k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e-&gt;info = reg;
+  e-&gt;k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e-&gt;k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs-&gt;freereg-1);
+  }
+}
+
+
+static void luaK_exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e-&gt;k == VJMP)
+    luaK_concat(fs, &amp;e-&gt;t, e-&gt;info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e-&gt;t, 1) || need_value(fs, e-&gt;f, 0)) {
+      int fj = NO_JUMP;  /* first jump (over LOAD ops.) */
+      if (e-&gt;k != VJMP)
+        fj = luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    luaK_patchlistaux(fs, e-&gt;f, p_f, NO_REG, final, reg, p_f);
+    luaK_patchlistaux(fs, e-&gt;t, final, reg, p_t, NO_REG, p_t);
+  }
+  e-&gt;f = e-&gt;t = NO_JUMP;
+  e-&gt;info = reg;
+  e-&gt;k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  luaK_exp2reg(fs, e, fs-&gt;freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e-&gt;k == VNONRELOC) {
+    if (!hasjumps(e)) return e-&gt;info;  /* exp is already in a register */ 
+    if (e-&gt;info &gt;= fs-&gt;nactvar) {  /* reg. is not a local? */
+      luaK_exp2reg(fs, e, e-&gt;info);  /* put value on it */
+      return e-&gt;info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e-&gt;info;
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: {
+      if (fs-&gt;nk + MAXSTACK &lt;= MAXARG_C) {  /* constant fit in argC? */
+        e-&gt;info = nil_constant(fs);
+        e-&gt;k = VK;
+        return e-&gt;info + MAXSTACK;
+      }
+      else break;
+    }
+    case VK: {
+      if (e-&gt;info + MAXSTACK &lt;= MAXARG_C)  /* constant fit in argC? */
+        return e-&gt;info + MAXSTACK;
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *exp) {
+  switch (var-&gt;k) {
+    case VLOCAL: {
+      freeexp(fs, exp);
+      luaK_exp2reg(fs, exp, var-&gt;info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var-&gt;info, 0);
+      break;
+    }
+    case VGLOBAL: {
+      int e = luaK_exp2anyreg(fs, exp);
+      luaK_codeABx(fs, OP_SETGLOBAL, e, var-&gt;info);
+      break;
+    }
+    case VINDEXED: {
+      int e = luaK_exp2RK(fs, exp);
+      luaK_codeABC(fs, OP_SETTABLE, var-&gt;info, var-&gt;aux, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, exp);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int func;
+  luaK_exp2anyreg(fs, e);
+  freeexp(fs, e);
+  func = fs-&gt;freereg;
+  luaK_reserveregs(fs, 2);
+  luaK_codeABC(fs, OP_SELF, func, e-&gt;info, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+  e-&gt;info = func;
+  e-&gt;k = VNONRELOC;
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e-&gt;info);
+  lua_assert(testOpMode(GET_OPCODE(*pc), OpModeT) &amp;&amp;
+             GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e-&gt;k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs-&gt;pc--;  /* remove previous OP_NOT */
+      return luaK_condjump(fs, OP_TEST, NO_REG, GETARG_B(ie), !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return luaK_condjump(fs, OP_TEST, NO_REG, e-&gt;info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VK: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    case VFALSE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e-&gt;info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &amp;e-&gt;f, pc);  /* insert last jump in `f' list */
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    case VTRUE: {
+      pc = luaK_jump(fs);  /* always jump */
+      break;
+    }
+    case VJMP: {
+      pc = e-&gt;info;
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &amp;e-&gt;t, pc);  /* insert last jump in `t' list */
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e-&gt;k) {
+    case VNIL: case VFALSE: {
+      e-&gt;k = VTRUE;
+      break;
+    }
+    case VK: case VTRUE: {
+      e-&gt;k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e-&gt;info = luaK_codeABC(fs, OP_NOT, 0, e-&gt;info, 0);
+      e-&gt;k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  t-&gt;aux = luaK_exp2RK(fs, k);
+  t-&gt;k = VINDEXED;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e) {
+  if (op == OPR_MINUS) {
+    luaK_exp2val(fs, e);
+    if (e-&gt;k == VK &amp;&amp; ttisnumber(&amp;fs-&gt;f-&gt;k[e-&gt;info]))
+      e-&gt;info = luaK_numberK(fs, -nvalue(&amp;fs-&gt;f-&gt;k[e-&gt;info]));
+    else {
+      luaK_exp2anyreg(fs, e);
+      freeexp(fs, e);
+      e-&gt;info = luaK_codeABC(fs, OP_UNM, 0, e-&gt;info, 0);
+      e-&gt;k = VRELOCABLE;
+    }
+  }
+  else  /* op == NOT */
+    codenot(fs, e);
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      luaK_patchtohere(fs, v-&gt;t);
+      v-&gt;t = NO_JUMP;
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      luaK_patchtohere(fs, v-&gt;f);
+      v-&gt;f = NO_JUMP;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+static void codebinop (FuncState *fs, expdesc *res, BinOpr op,
+                       int o1, int o2) {
+  if (op &lt;= OPR_POW) {  /* arithmetic operator? */
+    OpCode opc = cast(OpCode, (op - OPR_ADD) + OP_ADD);  /* ORDER OP */
+    res-&gt;info = luaK_codeABC(fs, opc, 0, o1, o2);
+    res-&gt;k = VRELOCABLE;
+  }
+  else {  /* test operator */
+    static const OpCode ops[] = {OP_EQ, OP_EQ, OP_LT, OP_LE, OP_LT, OP_LE};
+    int cond = 1;
+    if (op &gt;= OPR_GT) {  /* `&gt;' or `&gt;='? */
+      int temp;  /* exchange args and replace by `&lt;' or `&lt;=' */
+      temp = o1; o1 = o2; o2 = temp;  /* o1 &lt;==&gt; o2 */
+    }
+    else if (op == OPR_NE) cond = 0;
+    res-&gt;info = luaK_condjump(fs, ops[op - OPR_NE], cond, o1, o2);
+    res-&gt;k = VJMP;
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1-&gt;t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &amp;e1-&gt;f, e2-&gt;f);
+      e1-&gt;k = e2-&gt;k; e1-&gt;info = e2-&gt;info; e1-&gt;aux = e2-&gt;aux; e1-&gt;t = e2-&gt;t;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1-&gt;f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &amp;e1-&gt;t, e2-&gt;t);
+      e1-&gt;k = e2-&gt;k; e1-&gt;info = e2-&gt;info; e1-&gt;aux = e2-&gt;aux; e1-&gt;f = e2-&gt;f;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2-&gt;k == VRELOCABLE &amp;&amp; GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1-&gt;info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1-&gt;info);
+        e1-&gt;k = e2-&gt;k; e1-&gt;info = e2-&gt;info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);
+        freeexp(fs, e2);
+        freeexp(fs, e1);
+        e1-&gt;info = luaK_codeABC(fs, OP_CONCAT, 0, e1-&gt;info, e2-&gt;info);
+        e1-&gt;k = VRELOCABLE;
+      }
+      break;
+    }
+    default: {
+      int o1 = luaK_exp2RK(fs, e1);
+      int o2 = luaK_exp2RK(fs, e2);
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+      codebinop(fs, e1, op, o1, o2);
+    }
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs-&gt;f-&gt;lineinfo[fs-&gt;pc - 1] = line;
+}
+
+
+int luaK_code (FuncState *fs, Instruction i, int line) {
+  Proto *f = fs-&gt;f;
+  luaK_dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,
+                  MAX_INT, &quot;code size overflow&quot;);
+  f-&gt;code[fs-&gt;pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, int,
+                  MAX_INT, &quot;code size overflow&quot;);
+  f-&gt;lineinfo[fs-&gt;pc] = line;
+  return fs-&gt;pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c), fs-&gt;ls-&gt;lastline);
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc), fs-&gt;ls-&gt;lastline);
+}
+

Added: trunk/source/libraries/lua/lcode.h
===================================================================
--- trunk/source/libraries/lua/lcode.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lcode.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,74 @@
+/*
+** $Id: lcode.h,v 1.38 2002/12/11 12:34:22 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include &quot;llex.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep &quot;ORDER OPR&quot; if you change these enums
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MULT, OPR_DIV, OPR_POW,
+  OPR_CONCAT,
+  OPR_NE, OPR_EQ,
+  OPR_LT, OPR_LE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+#define binopistest(op)	((op) &gt;= OPR_NE)
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)-&gt;f-&gt;code[(e)-&gt;info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+int luaK_code (FuncState *fs, Instruction i, int line);
+int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+void luaK_fixline (FuncState *fs, int line);
+void luaK_nil (FuncState *fs, int from, int n);
+void luaK_reserveregs (FuncState *fs, int n);
+void luaK_checkstack (FuncState *fs, int n);
+int luaK_stringK (FuncState *fs, TString *s);
+int luaK_numberK (FuncState *fs, lua_Number r);
+void luaK_dischargevars (FuncState *fs, expdesc *e);
+int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+void luaK_exp2val (FuncState *fs, expdesc *e);
+int luaK_exp2RK (FuncState *fs, expdesc *e);
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+void luaK_goiftrue (FuncState *fs, expdesc *e);
+void luaK_goiffalse (FuncState *fs, expdesc *e);
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+void luaK_setcallreturns (FuncState *fs, expdesc *var, int nresults);
+int luaK_jump (FuncState *fs);
+void luaK_patchlist (FuncState *fs, int list, int target);
+void luaK_patchtohere (FuncState *fs, int list);
+void luaK_concat (FuncState *fs, int *l1, int l2);
+int luaK_getlabel (FuncState *fs);
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v);
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1, expdesc *v2);
+
+
+#endif

Added: trunk/source/libraries/lua/ldebug.c
===================================================================
--- trunk/source/libraries/lua/ldebug.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldebug.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,585 @@
+/*
+** $Id: ldebug.c,v 1.150 2003/03/19 21:24:04 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ldebug_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lapi.h&quot;
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lvm.h&quot;
+
+
+
+static const char *getfuncname (CallInfo *ci, const char **name);
+
+
+#define isLua(ci)	(!((ci)-&gt;state &amp; CI_C))
+
+
+static int currentpc (CallInfo *ci) {
+  if (!isLua(ci)) return -1;  /* function is not a Lua function? */
+  if (ci-&gt;state &amp; CI_HASFRAME)  /* function has a frame? */
+    ci-&gt;u.l.savedpc = *ci-&gt;u.l.pc;  /* use `pc' from there */
+  /* function's pc is saved */
+  return pcRel(ci-&gt;u.l.savedpc, ci_func(ci)-&gt;l.p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  int pc = currentpc(ci);
+  if (pc &lt; 0)
+    return -1;  /* only active lua functions have current-line information */
+  else
+    return getline(ci_func(ci)-&gt;l.p, pc);
+}
+
+
+void luaG_inithooks (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L-&gt;ci; ci != L-&gt;base_ci; ci--)  /* update all `savedpc's */
+    currentpc(ci);
+  L-&gt;hookinit = 1;
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  L-&gt;hook = func;
+  L-&gt;basehookcount = count;
+  resethookcount(L);
+  L-&gt;hookmask = cast(lu_byte, mask);
+  L-&gt;hookinit = 0;
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L-&gt;hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L-&gt;hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L-&gt;basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  lua_lock(L);
+  for (ci = L-&gt;ci; level &gt; 0 &amp;&amp; ci &gt; L-&gt;base_ci; ci--) {
+    level--;
+    if (!(ci-&gt;state &amp; CI_C))  /* Lua function? */
+      level -= ci-&gt;u.l.tailcalls;  /* skip lost tail calls */
+  }
+  if (level &gt; 0 || ci == L-&gt;base_ci) status = 0;  /* there is no such level */
+  else if (level &lt; 0) {  /* level is of a lost tail call */
+    status = 1;
+    ar-&gt;i_ci = 0;
+  }
+  else {
+    status = 1;
+    ar-&gt;i_ci = ci - L-&gt;base_ci;
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+static Proto *getluaproto (CallInfo *ci) {
+  return (isLua(ci) ? ci_func(ci)-&gt;l.p : NULL);
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L-&gt;base_ci + ar-&gt;i_ci;
+  fp = getluaproto(ci);
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (name)
+      luaA_pushobject(L, ci-&gt;base+(n-1));  /* push value */
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  CallInfo *ci;
+  Proto *fp;
+  lua_lock(L);
+  name = NULL;
+  ci = L-&gt;base_ci + ar-&gt;i_ci;
+  fp = getluaproto(ci);
+  L-&gt;top--;  /* pop new value */
+  if (fp) {  /* is a Lua function? */
+    name = luaF_getlocalname(fp, n, currentpc(ci));
+    if (!name || name[0] == '(')  /* `(' starts private locals */
+      name = NULL;
+    else
+      setobjs2s(ci-&gt;base+(n-1), L-&gt;top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, StkId func) {
+  Closure *cl = clvalue(func);
+  if (cl-&gt;c.isC) {
+    ar-&gt;source = &quot;=[C]&quot;;
+    ar-&gt;linedefined = -1;
+    ar-&gt;what = &quot;C&quot;;
+  }
+  else {
+    ar-&gt;source = getstr(cl-&gt;l.p-&gt;source);
+    ar-&gt;linedefined = cl-&gt;l.p-&gt;lineDefined;
+    ar-&gt;what = (ar-&gt;linedefined == 0) ? &quot;main&quot; : &quot;Lua&quot;;
+  }
+  luaO_chunkid(ar-&gt;short_src, ar-&gt;source, LUA_IDSIZE);
+}
+
+
+static const char *travglobals (lua_State *L, const TObject *o) {
+  Table *g = hvalue(gt(L));
+  int i = sizenode(g);
+  while (i--) {
+    Node *n = gnode(g, i);
+    if (luaO_rawequalObj(o, gval(n)) &amp;&amp; ttisstring(gkey(n)))
+      return getstr(tsvalue(gkey(n)));
+  }
+  return NULL;
+}
+
+
+static void info_tailcall (lua_State *L, lua_Debug *ar) {
+  ar-&gt;name = ar-&gt;namewhat = &quot;&quot;;
+  ar-&gt;what = &quot;tail&quot;;
+  ar-&gt;linedefined = ar-&gt;currentline = -1;
+  ar-&gt;source = &quot;=(tail call)&quot;;
+  luaO_chunkid(ar-&gt;short_src, ar-&gt;source, LUA_IDSIZE);
+  ar-&gt;nups = 0;
+  setnilvalue(L-&gt;top);
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                    StkId f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar-&gt;currentline = (ci) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar-&gt;nups = clvalue(f)-&gt;c.nupvalues;
+        break;
+      }
+      case 'n': {
+        ar-&gt;namewhat = (ci) ? getfuncname(ci, &amp;ar-&gt;name) : NULL;
+        if (ar-&gt;namewhat == NULL) {
+          /* try to find a global name */
+          if ((ar-&gt;name = travglobals(L, f)) != NULL)
+            ar-&gt;namewhat = &quot;global&quot;;
+          else ar-&gt;namewhat = &quot;&quot;;  /* not found */
+        }
+        break;
+      }
+      case 'f': {
+        setobj2s(L-&gt;top, f);
+        break;
+      }
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status = 1;
+  lua_lock(L);
+  if (*what == '&gt;') {
+    StkId f = L-&gt;top - 1;
+    if (!ttisfunction(f))
+      luaG_runerror(L, &quot;value for `lua_getinfo' is not a function&quot;);
+    status = auxgetinfo(L, what + 1, ar, f, NULL);
+    L-&gt;top--;  /* pop function */
+  }
+  else if (ar-&gt;i_ci != 0) {  /* no tail call? */
+    CallInfo *ci = L-&gt;base_ci + ar-&gt;i_ci;
+    lua_assert(ttisfunction(ci-&gt;base - 1));
+    status = auxgetinfo(L, what, ar, ci-&gt;base - 1, ci);
+  }
+  else
+    info_tailcall(L, ar);
+  if (strchr(what, 'f')) incr_top(L);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution and code checker
+** =======================================================
+*/
+
+#define check(x)		if (!(x)) return 0;
+
+#define checkjump(pt,pc)	check(0 &lt;= pc &amp;&amp; pc &lt; pt-&gt;sizecode)
+
+#define checkreg(pt,reg)	check((reg) &lt; (pt)-&gt;maxstacksize)
+
+
+
+static int precheck (const Proto *pt) {
+  check(pt-&gt;maxstacksize &lt;= MAXSTACK);
+  check(pt-&gt;sizelineinfo == pt-&gt;sizecode || pt-&gt;sizelineinfo == 0);
+  lua_assert(pt-&gt;numparams+pt-&gt;is_vararg &lt;= pt-&gt;maxstacksize);
+  check(GET_OPCODE(pt-&gt;code[pt-&gt;sizecode-1]) == OP_RETURN);
+  return 1;
+}
+
+
+static int checkopenop (const Proto *pt, int pc) {
+  Instruction i = pt-&gt;code[pc+1];
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:
+    case OP_RETURN: {
+      check(GETARG_B(i) == 0);
+      return 1;
+    }
+    case OP_SETLISTO: return 1;
+    default: return 0;  /* invalid instruction after an open call */
+  }
+}
+
+
+static int checkRK (const Proto *pt, int r) {
+  return (r &lt; pt-&gt;maxstacksize || (r &gt;= MAXSTACK &amp;&amp; r-MAXSTACK &lt; pt-&gt;sizek));
+}
+
+
+static Instruction luaG_symbexec (const Proto *pt, int lastpc, int reg) {
+  int pc;
+  int last;  /* stores position of last instruction that changed `reg' */
+  last = pt-&gt;sizecode-1;  /* points to final return (a `neutral' instruction) */
+  check(precheck(pt));
+  for (pc = 0; pc &lt; lastpc; pc++) {
+    const Instruction i = pt-&gt;code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    int b = 0;
+    int c = 0;
+    checkreg(pt, a);
+    switch (getOpMode(op)) {
+      case iABC: {
+        b = GETARG_B(i);
+        c = GETARG_C(i);
+        if (testOpMode(op, OpModeBreg)) {
+          checkreg(pt, b);
+        }
+        else if (testOpMode(op, OpModeBrk))
+          check(checkRK(pt, b));
+        if (testOpMode(op, OpModeCrk))
+          check(checkRK(pt, c));
+        break;
+      }
+      case iABx: {
+        b = GETARG_Bx(i);
+        if (testOpMode(op, OpModeK)) check(b &lt; pt-&gt;sizek);
+        break;
+      }
+      case iAsBx: {
+        b = GETARG_sBx(i);
+        break;
+      }
+    }
+    if (testOpMode(op, OpModesetA)) {
+      if (a == reg) last = pc;  /* change register `a' */
+    }
+    if (testOpMode(op, OpModeT)) {
+      check(pc+2 &lt; pt-&gt;sizecode);  /* check skip */
+      check(GET_OPCODE(pt-&gt;code[pc+1]) == OP_JMP);
+    }
+    switch (op) {
+      case OP_LOADBOOL: {
+        check(c == 0 || pc+2 &lt; pt-&gt;sizecode);  /* check its jump */
+        break;
+      }
+      case OP_LOADNIL: {
+        if (a &lt;= reg &amp;&amp; reg &lt;= b)
+          last = pc;  /* set registers from `a' to `b' */
+        break;
+      }
+      case OP_GETUPVAL:
+      case OP_SETUPVAL: {
+        check(b &lt; pt-&gt;nups);
+        break;
+      }
+      case OP_GETGLOBAL:
+      case OP_SETGLOBAL: {
+        check(ttisstring(&amp;pt-&gt;k[b]));
+        break;
+      }
+      case OP_SELF: {
+        checkreg(pt, a+1);
+        if (reg == a+1) last = pc;
+        break;
+      }
+      case OP_CONCAT: {
+        /* `c' is a register, and at least two operands */
+        check(c &lt; MAXSTACK &amp;&amp; b &lt; c);
+        break;
+      }
+      case OP_TFORLOOP:
+        checkreg(pt, a+c+5);
+        if (reg &gt;= a) last = pc;  /* affect all registers above base */
+        /* go through */
+      case OP_FORLOOP:
+        checkreg(pt, a+2);
+        /* go through */
+      case OP_JMP: {
+        int dest = pc+1+b;
+	check(0 &lt;= dest &amp;&amp; dest &lt; pt-&gt;sizecode);
+        /* not full check and jump is forward and do not skip `lastpc'? */
+        if (reg != NO_REG &amp;&amp; pc &lt; dest &amp;&amp; dest &lt;= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (b != 0) {
+          checkreg(pt, a+b-1);
+        }
+        c--;  /* c = num. returns */
+        if (c == LUA_MULTRET) {
+          check(checkopenop(pt, pc));
+        }
+        else if (c != 0)
+          checkreg(pt, a+c-1);
+        if (reg &gt;= a) last = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_RETURN: {
+        b--;  /* b = num. returns */
+        if (b &gt; 0) checkreg(pt, a+b-1);
+        break;
+      }
+      case OP_SETLIST: {
+        checkreg(pt, a + (b&amp;(LFIELDS_PER_FLUSH-1)) + 1);
+        break;
+      }
+      case OP_CLOSURE: {
+        int nup;
+        check(b &lt; pt-&gt;sizep);
+        nup = pt-&gt;p[b]-&gt;nups;
+        check(pc + nup &lt; pt-&gt;sizecode);
+        for (; nup&gt;0; nup--) {
+          OpCode op1 = GET_OPCODE(pt-&gt;code[pc+nup]);
+          check(op1 == OP_GETUPVAL || op1 == OP_MOVE);
+        }
+        break;
+      }
+      default: break;
+    }
+  }
+  return pt-&gt;code[last];
+}
+
+#undef check
+#undef checkjump
+#undef checkreg
+
+/* }====================================================== */
+
+
+int luaG_checkcode (const Proto *pt) {
+  return luaG_symbexec(pt, pt-&gt;sizecode, NO_REG);
+}
+
+
+static const char *kname (Proto *p, int c) {
+  c = c - MAXSTACK;
+  if (c &gt;= 0 &amp;&amp; ttisstring(&amp;p-&gt;k[c]))
+    return svalue(&amp;p-&gt;k[c]);
+  else
+    return &quot;?&quot;;
+}
+
+
+static const char *getobjname (CallInfo *ci, int stackpos, const char **name) {
+  if (isLua(ci)) {  /* a Lua function? */
+    Proto *p = ci_func(ci)-&gt;l.p;
+    int pc = currentpc(ci);
+    Instruction i;
+    *name = luaF_getlocalname(p, stackpos+1, pc);
+    if (*name)  /* is a local? */
+      return &quot;local&quot;;
+    i = luaG_symbexec(p, pc, stackpos);  /* try symbolic execution */
+    lua_assert(pc != -1);
+    switch (GET_OPCODE(i)) {
+      case OP_GETGLOBAL: {
+        int g = GETARG_Bx(i);  /* global index */
+        lua_assert(ttisstring(&amp;p-&gt;k[g]));
+        *name = svalue(&amp;p-&gt;k[g]);
+        return &quot;global&quot;;
+      }
+      case OP_MOVE: {
+        int a = GETARG_A(i);
+        int b = GETARG_B(i);  /* move from `b' to `a' */
+        if (b &lt; a)
+          return getobjname(ci, b, name);  /* get name for `b' */
+        break;
+      }
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return &quot;field&quot;;
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        *name = kname(p, k);
+        return &quot;method&quot;;
+      }
+      default: break;
+    }
+  }
+  return NULL;  /* no useful name found */
+}
+
+
+static const char *getfuncname (CallInfo *ci, const char **name) {
+  Instruction i;
+  if ((isLua(ci) &amp;&amp; ci-&gt;u.l.tailcalls &gt; 0) || !isLua(ci - 1))
+    return NULL;  /* calling function is not Lua (or is unknown) */
+  ci--;  /* calling function */
+  i = ci_func(ci)-&gt;l.p-&gt;code[currentpc(ci)];
+  if (GET_OPCODE(i) == OP_CALL || GET_OPCODE(i) == OP_TAILCALL)
+    return getobjname(ci, GETARG_A(i), name);
+  else
+    return NULL;  /* no useful name can be found */
+}
+
+
+/* only ANSI way to check whether a pointer points to an array */
+static int isinstack (CallInfo *ci, const TObject *o) {
+  StkId p;
+  for (p = ci-&gt;base; p &lt; ci-&gt;top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+void luaG_typeerror (lua_State *L, const TObject *o, const char *op) {
+  const char *name = NULL;
+  const char *t = luaT_typenames[ttype(o)];
+  const char *kind = (isinstack(L-&gt;ci, o)) ?
+                         getobjname(L-&gt;ci, o - L-&gt;base, &amp;name) : NULL;
+  if (kind)
+    luaG_runerror(L, &quot;attempt to %s %s `%s' (a %s value)&quot;,
+                op, kind, name, t);
+  else
+    luaG_runerror(L, &quot;attempt to %s a %s value&quot;, op, t);
+}
+
+
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1));
+  luaG_typeerror(L, p1, &quot;concatenate&quot;);
+}
+
+
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2) {
+  TObject temp;
+  if (luaV_tonumber(p1, &amp;temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, &quot;perform arithmetic on&quot;);
+}
+
+
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2) {
+  const char *t1 = luaT_typenames[ttype(p1)];
+  const char *t2 = luaT_typenames[ttype(p2)];
+  if (t1[2] == t2[2])
+    luaG_runerror(L, &quot;attempt to compare two %s values&quot;, t1);
+  else
+    luaG_runerror(L, &quot;attempt to compare %s with %s&quot;, t1, t2);
+  return 0;
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L-&gt;ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    luaO_chunkid(buff, getstr(getluaproto(ci)-&gt;source), LUA_IDSIZE);
+    luaO_pushfstring(L, &quot;%s:%d: %s&quot;, buff, line, msg);
+  }
+}
+
+
+void luaG_errormsg (lua_State *L) {
+  if (L-&gt;errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L-&gt;errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L-&gt;top, L-&gt;top - 1);  /* move argument */
+    setobjs2s(L-&gt;top - 1, errfunc);  /* push function */
+    incr_top(L);
+    luaD_call(L, L-&gt;top - 2, 1);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+void luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+

Added: trunk/source/libraries/lua/ldebug.h
===================================================================
--- trunk/source/libraries/lua/ldebug.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldebug.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,31 @@
+/*
+** $Id: ldebug.h,v 1.32 2002/11/18 11:01:55 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include &quot;lstate.h&quot;
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)-&gt;code) - 1)
+
+#define getline(f,pc)	(((f)-&gt;lineinfo) ? (f)-&gt;lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L-&gt;hookcount = L-&gt;basehookcount)
+
+
+void luaG_inithooks (lua_State *L);
+void luaG_typeerror (lua_State *L, const TObject *o, const char *opname);
+void luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+void luaG_aritherror (lua_State *L, const TObject *p1, const TObject *p2);
+int luaG_ordererror (lua_State *L, const TObject *p1, const TObject *p2);
+void luaG_runerror (lua_State *L, const char *fmt, ...);
+void luaG_errormsg (lua_State *L);
+int luaG_checkcode (const Proto *pt);
+
+
+#endif

Added: trunk/source/libraries/lua/ldo.c
===================================================================
--- trunk/source/libraries/lua/ldo.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldo.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,458 @@
+/*
+** $Id: ldo.c,v 1.217 2003/04/03 13:35:34 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;setjmp.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ldo_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lundump.h&quot;
+#include &quot;lvm.h&quot;
+#include &quot;lzio.h&quot;
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions (based on long jumps)
+** =======================================================
+*/
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  jmp_buf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {
+      setsvalue2s(oldtop, luaS_new(L, MEMERRMSG));
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(oldtop, luaS_new(L, &quot;error in error handling&quot;));
+      break;
+    }
+    case LUA_ERRSYNTAX:
+    case LUA_ERRRUN: {
+      setobjs2s(oldtop, L-&gt;top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L-&gt;top = oldtop + 1;
+}
+
+
+void luaD_throw (lua_State *L, int errcode) {
+  if (L-&gt;errorJmp) {
+    L-&gt;errorJmp-&gt;status = errcode;
+    longjmp(L-&gt;errorJmp-&gt;b, 1);
+  }
+  else {
+    G(L)-&gt;panic(L);
+    exit(EXIT_FAILURE);
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  struct lua_longjmp lj;
+  lj.status = 0;
+  lj.previous = L-&gt;errorJmp;  /* chain new error handler */
+  L-&gt;errorJmp = &lj;
+  if (setjmp(lj.b) == 0)
+    (*f)(L, ud);
+  L-&gt;errorJmp = lj.previous;  /* restore old error handler */
+  return lj.status;
+}
+
+
+static void restore_stack_limit (lua_State *L) {
+  L-&gt;stack_last = L-&gt;stack+L-&gt;stacksize-1;
+  if (L-&gt;size_ci &gt; LUA_MAXCALLS) {  /* there was an overflow? */
+    int inuse = (L-&gt;ci - L-&gt;base_ci);
+    if (inuse + 1 &lt; LUA_MAXCALLS)  /* can `undo' overflow? */
+      luaD_reallocCI(L, LUA_MAXCALLS);
+  }
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TObject *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L-&gt;top = (L-&gt;top - oldstack) + L-&gt;stack;
+  for (up = L-&gt;openupval; up != NULL; up = up-&gt;gch.next)
+    gcotouv(up)-&gt;v = (gcotouv(up)-&gt;v - oldstack) + L-&gt;stack;
+  for (ci = L-&gt;base_ci; ci &lt;= L-&gt;ci; ci++) {
+    ci-&gt;top = (ci-&gt;top - oldstack) + L-&gt;stack;
+    ci-&gt;base = (ci-&gt;base - oldstack) + L-&gt;stack;
+  }
+  L-&gt;base = L-&gt;ci-&gt;base;
+}
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TObject *oldstack = L-&gt;stack;
+  luaM_reallocvector(L, L-&gt;stack, L-&gt;stacksize, newsize, TObject);
+  L-&gt;stacksize = newsize;
+  L-&gt;stack_last = L-&gt;stack+newsize-1-EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_reallocCI (lua_State *L, int newsize) {
+  CallInfo *oldci = L-&gt;base_ci;
+  luaM_reallocvector(L, L-&gt;base_ci, L-&gt;size_ci, newsize, CallInfo);
+  L-&gt;size_ci = cast(unsigned short, newsize);
+  L-&gt;ci = (L-&gt;ci - oldci) + L-&gt;base_ci;
+  L-&gt;end_ci = L-&gt;base_ci + L-&gt;size_ci;
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  if (n &lt;= L-&gt;stacksize)  /* double size is enough? */
+    luaD_reallocstack(L, 2*L-&gt;stacksize);
+  else
+    luaD_reallocstack(L, L-&gt;stacksize + n + EXTRA_STACK);
+}
+
+
+static void luaD_growCI (lua_State *L) {
+  if (L-&gt;size_ci &gt; LUA_MAXCALLS)  /* overflow while handling overflow? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    luaD_reallocCI(L, 2*L-&gt;size_ci);
+    if (L-&gt;size_ci &gt; LUA_MAXCALLS)
+      luaG_runerror(L, &quot;stack overflow&quot;);
+  }
+}
+
+
+void luaD_callhook (lua_State *L, int event, int line) {
+  lua_Hook hook = L-&gt;hook;
+  if (hook &amp;&amp; L-&gt;allowhook) {
+    ptrdiff_t top = savestack(L, L-&gt;top);
+    ptrdiff_t ci_top = savestack(L, L-&gt;ci-&gt;top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    if (event == LUA_HOOKTAILRET)
+      ar.i_ci = 0;  /* tail call; no debug information about it */
+    else
+      ar.i_ci = L-&gt;ci - L-&gt;base_ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    L-&gt;ci-&gt;top = L-&gt;top + LUA_MINSTACK;
+    L-&gt;allowhook = 0;  /* cannot call hooks inside a hook */
+    lua_unlock(L);
+    (*hook)(L, &amp;ar);
+    lua_lock(L);
+    lua_assert(!L-&gt;allowhook);
+    L-&gt;allowhook = 1;
+    L-&gt;ci-&gt;top = restorestack(L, ci_top);
+    L-&gt;top = restorestack(L, top);
+  }
+}
+
+
+static void adjust_varargs (lua_State *L, int nfixargs, StkId base) {
+  int i;
+  Table *htab;
+  TObject nname;
+  int actual = L-&gt;top - base;  /* actual number of arguments */
+  if (actual &lt; nfixargs) {
+    luaD_checkstack(L, nfixargs - actual);
+    for (; actual &lt; nfixargs; ++actual)
+      setnilvalue(L-&gt;top++);
+  }
+  actual -= nfixargs;  /* number of extra arguments */
+  htab = luaH_new(L, actual, 1);  /* create `arg' table */
+  for (i=0; i&lt;actual; i++)  /* put extra arguments into `arg' table */
+    setobj2n(luaH_setnum(L, htab, i+1), L-&gt;top - actual + i);
+  /* store counter in field `n' */
+  setsvalue(&amp;nname, luaS_newliteral(L, &quot;n&quot;));
+  setnvalue(luaH_set(L, htab, &amp;nname), cast(lua_Number, actual));
+  L-&gt;top -= actual;  /* remove extra elements from the stack */
+  sethvalue(L-&gt;top, htab);
+  incr_top(L);
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TObject *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, &quot;call&quot;);
+  /* Open a hole inside the stack at `func' */
+  for (p = L-&gt;top; p &gt; func; p--) setobjs2s(p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+StkId luaD_precall (lua_State *L, StkId func) {
+  LClosure *cl;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(func)) /* `func' is not a function? */
+    func = tryfuncTM(L, func);  /* check the `function' tag method */
+  if (L-&gt;ci + 1 == L-&gt;end_ci) luaD_growCI(L);
+  else condhardstacktests(luaD_reallocCI(L, L-&gt;size_ci));
+  cl = &amp;clvalue(func)-&gt;l;
+  if (!cl-&gt;isC) {  /* Lua function? prepare its call */
+    CallInfo *ci;
+    Proto *p = cl-&gt;p;
+    if (p-&gt;is_vararg)  /* varargs? */
+      adjust_varargs(L, p-&gt;numparams, func+1);
+    luaD_checkstack(L, p-&gt;maxstacksize);
+    ci = ++L-&gt;ci;  /* now `enter' new function */
+    L-&gt;base = L-&gt;ci-&gt;base = restorestack(L, funcr) + 1;
+    ci-&gt;top = L-&gt;base + p-&gt;maxstacksize;
+    ci-&gt;u.l.savedpc = p-&gt;code;  /* starting point */
+    ci-&gt;u.l.tailcalls = 0;
+    ci-&gt;state = CI_SAVEDPC;
+    while (L-&gt;top &lt; ci-&gt;top)
+      setnilvalue(L-&gt;top++);
+    L-&gt;top = ci-&gt;top;
+    return NULL;
+  }
+  else {  /* if is a C function, call it */
+    CallInfo *ci;
+    int n;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci = ++L-&gt;ci;  /* now `enter' new function */
+    L-&gt;base = L-&gt;ci-&gt;base = restorestack(L, funcr) + 1;
+    ci-&gt;top = L-&gt;top + LUA_MINSTACK;
+    ci-&gt;state = CI_C;  /* a C function */
+    if (L-&gt;hookmask &amp; LUA_MASKCALL)
+      luaD_callhook(L, LUA_HOOKCALL, -1);
+    lua_unlock(L);
+#ifdef LUA_COMPATUPVALUES
+    lua_pushupvalues(L);
+#endif
+    n = (*clvalue(L-&gt;base - 1)-&gt;c.f)(L);  /* do the actual call */
+    lua_lock(L);
+    return L-&gt;top - n;
+  }
+}
+
+
+static StkId callrethooks (lua_State *L, StkId firstResult) {
+  ptrdiff_t fr = savestack(L, firstResult);  /* next call may change stack */
+  luaD_callhook(L, LUA_HOOKRET, -1);
+  if (!(L-&gt;ci-&gt;state &amp; CI_C)) {  /* Lua function? */
+    while (L-&gt;ci-&gt;u.l.tailcalls--)  /* call hook for eventual tail calls */
+      luaD_callhook(L, LUA_HOOKTAILRET, -1);
+  }
+  return restorestack(L, fr);
+}
+
+
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult) { 
+  StkId res;
+  if (L-&gt;hookmask &amp; LUA_MASKRET)
+    firstResult = callrethooks(L, firstResult);
+  res = L-&gt;base - 1;  /* res == final position of 1st result */
+  L-&gt;ci--;
+  L-&gt;base = L-&gt;ci-&gt;base;  /* restore base */
+  /* move results to correct place */
+  while (wanted != 0 &amp;&amp; firstResult &lt; L-&gt;top) {
+    setobjs2s(res++, firstResult++);
+    wanted--;
+  }
+  while (wanted-- &gt; 0)
+    setnilvalue(res++);
+  L-&gt;top = res;
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/ 
+void luaD_call (lua_State *L, StkId func, int nResults) {
+  StkId firstResult;
+  lua_assert(!(L-&gt;ci-&gt;state &amp; CI_CALLING));
+  if (++L-&gt;nCcalls &gt;= LUA_MAXCCALLS) {
+    if (L-&gt;nCcalls == LUA_MAXCCALLS)
+      luaG_runerror(L, &quot;C stack overflow&quot;);
+    else if (L-&gt;nCcalls &gt;= (LUA_MAXCCALLS + (LUA_MAXCCALLS&gt;&gt;3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  firstResult = luaD_precall(L, func);
+  if (firstResult == NULL)  /* is a Lua function? */
+    firstResult = luaV_execute(L);  /* call it */
+  luaD_poscall(L, nResults, firstResult);
+  L-&gt;nCcalls--;
+  luaC_checkGC(L);
+}
+
+
+static void resume (lua_State *L, void *ud) {
+  StkId firstResult;
+  int nargs = *cast(int *, ud);
+  CallInfo *ci = L-&gt;ci;
+  if (ci == L-&gt;base_ci) {  /* no activation record? */
+    if (nargs &gt;= L-&gt;top - L-&gt;base)
+      luaG_runerror(L, &quot;cannot resume dead coroutine&quot;);
+    luaD_precall(L, L-&gt;top - (nargs + 1));  /* start coroutine */
+  }
+  else if (ci-&gt;state &amp; CI_YIELD) {  /* inside a yield? */
+    if (ci-&gt;state &amp; CI_C) {  /* `common' yield? */
+      /* finish interrupted execution of `OP_CALL' */
+      int nresults;
+      lua_assert((ci-1)-&gt;state &amp; CI_SAVEDPC);
+      lua_assert(GET_OPCODE(*((ci-1)-&gt;u.l.savedpc - 1)) == OP_CALL ||
+                 GET_OPCODE(*((ci-1)-&gt;u.l.savedpc - 1)) == OP_TAILCALL);
+      nresults = GETARG_C(*((ci-1)-&gt;u.l.savedpc - 1)) - 1;
+      luaD_poscall(L, nresults, L-&gt;top - nargs);  /* complete it */
+      if (nresults &gt;= 0) L-&gt;top = L-&gt;ci-&gt;top;
+    }
+    else {  /* yielded inside a hook: just continue its execution */
+      ci-&gt;state &amp;= ~CI_YIELD;
+    }
+  }
+  else
+    luaG_runerror(L, &quot;cannot resume non-suspended coroutine&quot;);
+  firstResult = luaV_execute(L);
+  if (firstResult != NULL)   /* return? */
+    luaD_poscall(L, LUA_MULTRET, firstResult);  /* finalize this coroutine */
+}
+
+
+LUA_API int lua_resume (lua_State *L, int nargs) {
+  int status;
+  lu_byte old_allowhooks;
+  lua_lock(L);
+  old_allowhooks = L-&gt;allowhook;
+  lua_assert(L-&gt;errfunc == 0 &amp;&amp; L-&gt;nCcalls == 0);
+  status = luaD_rawrunprotected(L, resume, &amp;nargs);
+  if (status != 0) {  /* error? */
+    L-&gt;ci = L-&gt;base_ci;  /* go back to initial level */
+    L-&gt;base = L-&gt;ci-&gt;base;
+    L-&gt;nCcalls = 0;
+    luaF_close(L, L-&gt;base);  /* close eventual pending closures */
+    seterrorobj(L, status, L-&gt;base);
+    L-&gt;allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yield (lua_State *L, int nresults) {
+  CallInfo *ci;
+  lua_lock(L);
+  ci = L-&gt;ci;
+  if (L-&gt;nCcalls &gt; 0)
+    luaG_runerror(L, &quot;attempt to yield across metamethod/C-call boundary&quot;);
+  if (ci-&gt;state &amp; CI_C) {  /* usual yield */
+    if ((ci-1)-&gt;state &amp; CI_C)
+      luaG_runerror(L, &quot;cannot yield a C function&quot;);
+    if (L-&gt;top - nresults &gt; L-&gt;base) {  /* is there garbage in the stack? */
+      int i;
+      for (i=0; i&lt;nresults; i++)  /* move down results */
+        setobjs2s(L-&gt;base + i, L-&gt;top - nresults + i);
+      L-&gt;top = L-&gt;base + nresults;
+    }
+  } /* else it's an yield inside a hook: nothing to do */
+  ci-&gt;state |= CI_YIELD;
+  lua_unlock(L);
+  return -1;
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  unsigned short oldnCcalls = L-&gt;nCcalls;
+  ptrdiff_t old_ci = saveci(L, L-&gt;ci);
+  lu_byte old_allowhooks = L-&gt;allowhook;
+  ptrdiff_t old_errfunc = L-&gt;errfunc;
+  L-&gt;errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != 0) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close eventual pending closures */
+    seterrorobj(L, status, oldtop);
+    L-&gt;nCcalls = oldnCcalls;
+    L-&gt;ci = restoreci(L, old_ci);
+    L-&gt;base = L-&gt;ci-&gt;base;
+    L-&gt;allowhook = old_allowhooks;
+    restore_stack_limit(L);
+  }
+  L-&gt;errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* buffer to be used by the scanner */
+  int bin;
+};
+
+static void f_parser (lua_State *L, void *ud) {
+  struct SParser *p;
+  Proto *tf;
+  Closure *cl;
+  luaC_checkGC(L);
+  p = cast(struct SParser *, ud);
+  tf = p-&gt;bin ? luaU_undump(L, p-&gt;z, &amp;p-&gt;buff) : luaY_parser(L, p-&gt;z, &amp;p-&gt;buff);
+  cl = luaF_newLclosure(L, 0, gt(L));
+  cl-&gt;l.p = tf;
+  setclvalue(L-&gt;top, cl);
+  incr_top(L);
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin) {
+  struct SParser p;
+  int status;
+  ptrdiff_t oldtopr = savestack(L, L-&gt;top);  /* save current top */
+  p.z = z; p.bin = bin;
+  luaZ_initbuffer(L, &amp;p.buff);
+  status = luaD_rawrunprotected(L, f_parser, &amp;p);
+  luaZ_freebuffer(L, &amp;p.buff);
+  if (status != 0) {  /* error? */
+    StkId oldtop = restorestack(L, oldtopr);
+    seterrorobj(L, status, oldtop);
+  }
+  return status;
+}
+
+

Added: trunk/source/libraries/lua/ldo.h
===================================================================
--- trunk/source/libraries/lua/ldo.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldo.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,60 @@
+/*
+** $Id: ldo.h,v 1.56 2002/12/04 17:29:32 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lzio.h&quot;
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/ 
+#ifndef HARDSTACKTESTS
+#define condhardstacktests(x)	{ /* empty */ }
+#else
+#define condhardstacktests(x)	x
+#endif
+
+
+#define luaD_checkstack(L,n)	\
+  if ((char *)L-&gt;stack_last - (char *)L-&gt;top &lt;= (n)*(int)sizeof(TObject)) \
+    luaD_growstack(L, n); \
+  else condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize));
+
+
+#define incr_top(L) {luaD_checkstack(L,1); L-&gt;top++;}
+
+#define savestack(L,p)		((char *)(p) - (char *)L-&gt;stack)
+#define restorestack(L,n)	((TObject *)((char *)L-&gt;stack + (n)))
+
+#define saveci(L,p)		((char *)(p) - (char *)L-&gt;base_ci)
+#define restoreci(L,n)		((CallInfo *)((char *)L-&gt;base_ci + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+void luaD_resetprotection (lua_State *L);
+int luaD_protectedparser (lua_State *L, ZIO *z, int bin);
+void luaD_callhook (lua_State *L, int event, int line);
+StkId luaD_precall (lua_State *L, StkId func);
+void luaD_call (lua_State *L, StkId func, int nResults);
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t oldtop, ptrdiff_t ef);
+void luaD_poscall (lua_State *L, int wanted, StkId firstResult);
+void luaD_reallocCI (lua_State *L, int newsize);
+void luaD_reallocstack (lua_State *L, int newsize);
+void luaD_growstack (lua_State *L, int n);
+
+void luaD_throw (lua_State *L, int errcode);
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+
+#endif

Added: trunk/source/libraries/lua/ldump.c
===================================================================
--- trunk/source/libraries/lua/ldump.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ldump.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,170 @@
+/*
+** $Id: ldump.c,v 1.4 2003/02/11 23:52:12 lhf Exp $
+** save bytecodes
+** See Copyright Notice in lua.h
+*/
+
+#include &lt;stddef.h&gt;
+
+#define ldump_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lundump.h&quot;
+
+#define DumpVector(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpLiteral(s,D)	DumpBlock(&quot;&quot; s,(sizeof(s))-1,D)
+
+typedef struct {
+ lua_State* L;
+ lua_Chunkwriter write;
+ void* data;
+} DumpState;
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ lua_unlock(D-&gt;L);
+ (*D-&gt;write)(D-&gt;L,b,size,D-&gt;data);
+ lua_lock(D-&gt;L);
+}
+
+static void DumpByte(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpSize(size_t x, DumpState* D)
+{
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpBlock(&amp;x,sizeof(x),D);
+}
+
+static void DumpString(TString* s, DumpState* D)
+{
+ if (s==NULL || getstr(s)==NULL)
+  DumpSize(0,D);
+ else
+ {
+  size_t size=s-&gt;tsv.len+1;		/* include trailing '\0' */
+  DumpSize(size,D);
+  DumpBlock(getstr(s),size,D);
+ }
+}
+
+static void DumpCode(const Proto* f, DumpState* D)
+{
+ DumpInt(f-&gt;sizecode,D);
+ DumpVector(f-&gt;code,f-&gt;sizecode,sizeof(*f-&gt;code),D);
+}
+
+static void DumpLocals(const Proto* f, DumpState* D)
+{
+ int i,n=f-&gt;sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i&lt;n; i++)
+ {
+  DumpString(f-&gt;locvars[i].varname,D);
+  DumpInt(f-&gt;locvars[i].startpc,D);
+  DumpInt(f-&gt;locvars[i].endpc,D);
+ }
+}
+
+static void DumpLines(const Proto* f, DumpState* D)
+{
+ DumpInt(f-&gt;sizelineinfo,D);
+ DumpVector(f-&gt;lineinfo,f-&gt;sizelineinfo,sizeof(*f-&gt;lineinfo),D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f-&gt;sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i&lt;n; i++) DumpString(f-&gt;upvalues[i],D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpInt(n=f-&gt;sizek,D);
+ for (i=0; i&lt;n; i++)
+ {
+  const TObject* o=&amp;f-&gt;k[i];
+  DumpByte(ttype(o),D);
+  switch (ttype(o))
+  {
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(tsvalue(o),D);
+	break;
+   case LUA_TNIL:
+	break;
+   default:
+	lua_assert(0);			/* cannot happen */
+	break;
+  }
+ }
+ DumpInt(n=f-&gt;sizep,D);
+ for (i=0; i&lt;n; i++) DumpFunction(f-&gt;p[i],f-&gt;source,D);
+}
+
+static void DumpFunction(const Proto* f, const TString* p, DumpState* D)
+{
+ DumpString((f-&gt;source==p) ? NULL : f-&gt;source,D);
+ DumpInt(f-&gt;lineDefined,D);
+ DumpByte(f-&gt;nups,D);
+ DumpByte(f-&gt;numparams,D);
+ DumpByte(f-&gt;is_vararg,D);
+ DumpByte(f-&gt;maxstacksize,D);
+ DumpLines(f,D);
+ DumpLocals(f,D);
+ DumpUpvalues(f,D);
+ DumpConstants(f,D);
+ DumpCode(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ DumpLiteral(LUA_SIGNATURE,D);
+ DumpByte(VERSION,D);
+ DumpByte(luaU_endianness(),D);
+ DumpByte(sizeof(int),D);
+ DumpByte(sizeof(size_t),D);
+ DumpByte(sizeof(Instruction),D);
+ DumpByte(SIZE_OP,D);
+ DumpByte(SIZE_A,D);
+ DumpByte(SIZE_B,D);
+ DumpByte(SIZE_C,D);
+ DumpByte(sizeof(lua_Number),D);
+ DumpNumber(TEST_NUMBER,D);
+}
+
+/*
+** dump function as precompiled chunk
+*/
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data)
+{
+ DumpState D;
+ D.L=L;
+ D.write=w;
+ D.data=data;
+ DumpHeader(&amp;D);
+ DumpFunction(Main,NULL,&amp;D);
+}
+

Added: trunk/source/libraries/lua/lfunc.c
===================================================================
--- trunk/source/libraries/lua/lfunc.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lfunc.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,135 @@
+/*
+** $Id: lfunc.c,v 1.67 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lfunc_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TObject)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TObject *)*((n)-1)))
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int nelems) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c-&gt;c.isC = 1;
+  c-&gt;c.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e) {
+  Closure *c = cast(Closure *, luaM_malloc(L, sizeLclosure(nelems)));
+  luaC_link(L, valtogco(c), LUA_TFUNCTION);
+  c-&gt;l.isC = 0;
+  c-&gt;l.g = *e;
+  c-&gt;l.nupvalues = cast(lu_byte, nelems);
+  return c;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  GCObject **pp = &amp;L-&gt;openupval;
+  UpVal *p;
+  UpVal *v;
+  while ((p = ngcotouv(*pp)) != NULL &amp;&amp; p-&gt;v &gt;= level) {
+    if (p-&gt;v == level) return p;
+    pp = &amp;p-&gt;next;
+  }
+  v = luaM_new(L, UpVal);  /* not found: create a new one */
+  v-&gt;tt = LUA_TUPVAL;
+  v-&gt;marked = 1;  /* open upvalues should not be collected */
+  v-&gt;v = level;  /* current value lives in the stack */
+  v-&gt;next = *pp;  /* chain it in the proper position */
+  *pp = valtogco(v);
+  return v;
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *p;
+  while ((p = ngcotouv(L-&gt;openupval)) != NULL &amp;&amp; p-&gt;v &gt;= level) {
+    setobj(&amp;p-&gt;value, p-&gt;v);  /* save current value (write barrier) */
+    p-&gt;v = &amp;p-&gt;value;  /* now current value lives here */
+    L-&gt;openupval = p-&gt;next;  /* remove from `open' list */
+    luaC_link(L, valtogco(p), LUA_TUPVAL);
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = luaM_new(L, Proto);
+  luaC_link(L, valtogco(f), LUA_TPROTO);
+  f-&gt;k = NULL;
+  f-&gt;sizek = 0;
+  f-&gt;p = NULL;
+  f-&gt;sizep = 0;
+  f-&gt;code = NULL;
+  f-&gt;sizecode = 0;
+  f-&gt;sizelineinfo = 0;
+  f-&gt;sizeupvalues = 0;
+  f-&gt;nups = 0;
+  f-&gt;upvalues = NULL;
+  f-&gt;numparams = 0;
+  f-&gt;is_vararg = 0;
+  f-&gt;maxstacksize = 0;
+  f-&gt;lineinfo = NULL;
+  f-&gt;sizelocvars = 0;
+  f-&gt;locvars = NULL;
+  f-&gt;lineDefined = 0;
+  f-&gt;source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f-&gt;code, f-&gt;sizecode, Instruction);
+  luaM_freearray(L, f-&gt;p, f-&gt;sizep, Proto *);
+  luaM_freearray(L, f-&gt;k, f-&gt;sizek, TObject);
+  luaM_freearray(L, f-&gt;lineinfo, f-&gt;sizelineinfo, int);
+  luaM_freearray(L, f-&gt;locvars, f-&gt;sizelocvars, struct LocVar);
+  luaM_freearray(L, f-&gt;upvalues, f-&gt;sizeupvalues, TString *);
+  luaM_freelem(L, f);
+}
+
+
+void luaF_freeclosure (lua_State *L, Closure *c) {
+  int size = (c-&gt;c.isC) ? sizeCclosure(c-&gt;c.nupvalues) :
+                          sizeLclosure(c-&gt;l.nupvalues);
+  luaM_free(L, c, size);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i&lt;f-&gt;sizelocvars &amp;&amp; f-&gt;locvars[i].startpc &lt;= pc; i++) {
+    if (pc &lt; f-&gt;locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f-&gt;locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+

Added: trunk/source/libraries/lua/lfunc.h
===================================================================
--- trunk/source/libraries/lua/lfunc.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lfunc.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,25 @@
+/*
+** $Id: lfunc.h,v 1.21 2003/03/18 12:50:04 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include &quot;lobject.h&quot;
+
+
+Proto *luaF_newproto (lua_State *L);
+Closure *luaF_newCclosure (lua_State *L, int nelems);
+Closure *luaF_newLclosure (lua_State *L, int nelems, TObject *e);
+UpVal *luaF_findupval (lua_State *L, StkId level);
+void luaF_close (lua_State *L, StkId level);
+void luaF_freeproto (lua_State *L, Proto *f);
+void luaF_freeclosure (lua_State *L, Closure *c);
+
+const char *luaF_getlocalname (const Proto *func, int local_number, int pc);
+
+
+#endif

Added: trunk/source/libraries/lua/lgc.c
===================================================================
--- trunk/source/libraries/lua/lgc.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lgc.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,493 @@
+/*
+** $Id: lgc.c,v 1.171 2003/04/03 13:35:34 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include &lt;string.h&gt;
+
+#define lgc_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+
+
+typedef struct GCState {
+  GCObject *tmark;  /* list of marked objects to be traversed */
+  GCObject *wk;  /* list of traversed key-weak tables (to be cleared) */
+  GCObject *wv;  /* list of traversed value-weak tables */
+  GCObject *wkv;  /* list of traversed key-value weak tables */
+  global_State *g;
+} GCState;
+
+
+/*
+** some userful bit tricks
+*/
+#define setbit(x,b)	((x) |= (1&lt;&lt;(b)))
+#define resetbit(x,b)	((x) &amp;= cast(lu_byte, ~(1&lt;&lt;(b))))
+#define testbit(x,b)	((x) &amp; (1&lt;&lt;(b)))
+
+#define unmark(x)	resetbit((x)-&gt;gch.marked, 0)
+#define ismarked(x)	((x)-&gt;gch.marked &amp; ((1&lt;&lt;4)|1))
+
+#define stringmark(s)	setbit((s)-&gt;tsv.marked, 0)
+
+
+#define isfinalized(u)		(!testbit((u)-&gt;uv.marked, 1))
+#define markfinalized(u)	resetbit((u)-&gt;uv.marked, 1)
+
+
+#define KEYWEAKBIT    1
+#define VALUEWEAKBIT  2
+#define KEYWEAK         (1&lt;&lt;KEYWEAKBIT)
+#define VALUEWEAK       (1&lt;&lt;VALUEWEAKBIT)
+
+
+
+#define markobject(st,o) { checkconsistency(o); \
+  if (iscollectable(o) &amp;&amp; !ismarked(gcvalue(o))) reallymarkobject(st,gcvalue(o)); }
+
+#define condmarkobject(st,o,c) { checkconsistency(o); \
+  if (iscollectable(o) &amp;&amp; !ismarked(gcvalue(o)) &amp;&amp; (c)) \
+    reallymarkobject(st,gcvalue(o)); }
+
+#define markvalue(st,t) { if (!ismarked(valtogco(t))) \
+		reallymarkobject(st, valtogco(t)); }
+
+
+
+static void reallymarkobject (GCState *st, GCObject *o) {
+  lua_assert(!ismarked(o));
+  setbit(o-&gt;gch.marked, 0);  /* mark object */
+  switch (o-&gt;gch.tt) {
+    case LUA_TUSERDATA: {
+      markvalue(st, gcotou(o)-&gt;uv.metatable);
+      break;
+    }
+    case LUA_TFUNCTION: {
+      gcotocl(o)-&gt;c.gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    case LUA_TTABLE: {
+      gcotoh(o)-&gt;gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    case LUA_TTHREAD: {
+      gcototh(o)-&gt;gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    case LUA_TPROTO: {
+      gcotop(o)-&gt;gclist = st-&gt;tmark;
+      st-&gt;tmark = o;
+      break;
+    }
+    default: lua_assert(o-&gt;gch.tt == LUA_TSTRING);
+  }
+}
+
+
+static void marktmu (GCState *st) {
+  GCObject *u;
+  for (u = st-&gt;g-&gt;tmudata; u; u = u-&gt;gch.next) {
+    unmark(u);  /* may be marked, if left from previous GC */
+    reallymarkobject(st, u);
+  }
+}
+
+
+/* move `dead' udata that need finalization to list `tmudata' */
+void luaC_separateudata (lua_State *L) {
+  GCObject **p = &amp;G(L)-&gt;rootudata;
+  GCObject *curr;
+  GCObject *collected = NULL;  /* to collect udata with gc event */
+  GCObject **lastcollected = &collected;
+  while ((curr = *p) != NULL) {
+    lua_assert(curr-&gt;gch.tt == LUA_TUSERDATA);
+    if (ismarked(curr) || isfinalized(gcotou(curr)))
+      p = &amp;curr-&gt;gch.next;  /* don't bother with them */
+
+    else if (fasttm(L, gcotou(curr)-&gt;uv.metatable, TM_GC) == NULL) {
+      markfinalized(gcotou(curr));  /* don't need finalization */
+      p = &amp;curr-&gt;gch.next;
+    }
+    else {  /* must call its gc method */
+      *p = curr-&gt;gch.next;
+      curr-&gt;gch.next = NULL;  /* link `curr' at the end of `collected' list */
+      *lastcollected = curr;
+      lastcollected = &amp;curr-&gt;gch.next;
+    }
+  }
+  /* insert collected udata with gc event into `tmudata' list */
+  *lastcollected = G(L)-&gt;tmudata;
+  G(L)-&gt;tmudata = collected;
+}
+
+
+static void removekey (Node *n) {
+  setnilvalue(gval(n));  /* remove corresponding value ... */
+  if (iscollectable(gkey(n)))
+    setttype(gkey(n), LUA_TNONE);  /* dead key; remove it */
+}
+
+
+static void traversetable (GCState *st, Table *h) {
+  int i;
+  int weakkey = 0;
+  int weakvalue = 0;
+  const TObject *mode;
+  markvalue(st, h-&gt;metatable);
+  lua_assert(h-&gt;lsizenode || h-&gt;node == st-&gt;g-&gt;dummynode);
+  mode = gfasttm(st-&gt;g, h-&gt;metatable, TM_MODE);
+  if (mode &amp;&amp; ttisstring(mode)) {  /* is there a weak mode? */
+    weakkey = (strchr(svalue(mode), 'k') != NULL);
+    weakvalue = (strchr(svalue(mode), 'v') != NULL);
+    if (weakkey || weakvalue) {  /* is really weak? */
+      GCObject **weaklist;
+      h-&gt;marked &amp;= ~(KEYWEAK | VALUEWEAK);  /* clear bits */
+      h-&gt;marked |= cast(lu_byte, (weakkey &lt;&lt; KEYWEAKBIT) |
+                                 (weakvalue &lt;&lt; VALUEWEAKBIT));
+      weaklist = (weakkey &amp;&amp; weakvalue) ? &amp;st-&gt;wkv :
+                              (weakkey) ? &amp;st-&gt;wk :
+                                          &amp;st-&gt;wv;
+      h-&gt;gclist = *weaklist;  /* must be cleared after GC, ... */
+      *weaklist = valtogco(h);  /* ... so put in the appropriate list */
+    }
+  }
+  if (!weakvalue) {
+    i = h-&gt;sizearray;
+    while (i--)
+      markobject(st, &amp;h-&gt;array[i]);
+  }
+  i = sizenode(h);
+  while (i--) {
+    Node *n = gnode(h, i);
+    if (!ttisnil(gval(n))) {
+      lua_assert(!ttisnil(gkey(n)));
+      condmarkobject(st, gkey(n), !weakkey);
+      condmarkobject(st, gval(n), !weakvalue);
+    }
+  }
+}
+
+
+static void traverseproto (GCState *st, Proto *f) {
+  int i;
+  stringmark(f-&gt;source);
+  for (i=0; i&lt;f-&gt;sizek; i++) {  /* mark literal strings */
+    if (ttisstring(f-&gt;k+i))
+      stringmark(tsvalue(f-&gt;k+i));
+  }
+  for (i=0; i&lt;f-&gt;sizeupvalues; i++)  /* mark upvalue names */
+    stringmark(f-&gt;upvalues[i]);
+  for (i=0; i&lt;f-&gt;sizep; i++)  /* mark nested protos */
+    markvalue(st, f-&gt;p[i]);
+  for (i=0; i&lt;f-&gt;sizelocvars; i++)  /* mark local-variable names */
+    stringmark(f-&gt;locvars[i].varname);
+  lua_assert(luaG_checkcode(f));
+}
+
+
+
+static void traverseclosure (GCState *st, Closure *cl) {
+  if (cl-&gt;c.isC) {
+    int i;
+    for (i=0; i&lt;cl-&gt;c.nupvalues; i++)  /* mark its upvalues */
+      markobject(st, &amp;cl-&gt;c.upvalue[i]);
+  }
+  else {
+    int i;
+    lua_assert(cl-&gt;l.nupvalues == cl-&gt;l.p-&gt;nups);
+    markvalue(st, hvalue(&amp;cl-&gt;l.g));
+    markvalue(st, cl-&gt;l.p);
+    for (i=0; i&lt;cl-&gt;l.nupvalues; i++) {  /* mark its upvalues */
+      UpVal *u = cl-&gt;l.upvals[i];
+      if (!u-&gt;marked) {
+        markobject(st, &amp;u-&gt;value);
+        u-&gt;marked = 1;
+      }
+    }
+  }
+}
+
+
+static void checkstacksizes (lua_State *L, StkId max) {
+  int used = L-&gt;ci - L-&gt;base_ci;  /* number of `ci' in use */
+  if (4*used &lt; L-&gt;size_ci &amp;&amp; 2*BASIC_CI_SIZE &lt; L-&gt;size_ci)
+    luaD_reallocCI(L, L-&gt;size_ci/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocCI(L, L-&gt;size_ci));
+  used = max - L-&gt;stack;  /* part of stack in use */
+  if (4*used &lt; L-&gt;stacksize &amp;&amp; 2*(BASIC_STACK_SIZE+EXTRA_STACK) &lt; L-&gt;stacksize)
+    luaD_reallocstack(L, L-&gt;stacksize/2);  /* still big enough... */
+  else condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize));
+}
+
+
+static void traversestack (GCState *st, lua_State *L1) {
+  StkId o, lim;
+  CallInfo *ci;
+  markobject(st, gt(L1));
+  lim = L1-&gt;top;
+  for (ci = L1-&gt;base_ci; ci &lt;= L1-&gt;ci; ci++) {
+    lua_assert(ci-&gt;top &lt;= L1-&gt;stack_last);
+    lua_assert(ci-&gt;state &amp; (CI_C | CI_HASFRAME | CI_SAVEDPC));
+    if (!(ci-&gt;state &amp; CI_C) &amp;&amp; lim &lt; ci-&gt;top)
+      lim = ci-&gt;top;
+  }
+  for (o = L1-&gt;stack; o &lt; L1-&gt;top; o++)
+    markobject(st, o);
+  for (; o &lt;= lim; o++)
+    setnilvalue(o);
+  checkstacksizes(L1, lim);
+}
+
+
+static void propagatemarks (GCState *st) {
+  while (st-&gt;tmark) {  /* traverse marked objects */
+    switch (st-&gt;tmark-&gt;gch.tt) {
+      case LUA_TTABLE: {
+        Table *h = gcotoh(st-&gt;tmark);
+        st-&gt;tmark = h-&gt;gclist;
+        traversetable(st, h);
+        break;
+      }
+      case LUA_TFUNCTION: {
+        Closure *cl = gcotocl(st-&gt;tmark);
+        st-&gt;tmark = cl-&gt;c.gclist;
+        traverseclosure(st, cl);
+        break;
+      }
+      case LUA_TTHREAD: {
+        lua_State *th = gcototh(st-&gt;tmark);
+        st-&gt;tmark = th-&gt;gclist;
+        traversestack(st, th);
+        break;
+      }
+      case LUA_TPROTO: {
+        Proto *p = gcotop(st-&gt;tmark);
+        st-&gt;tmark = p-&gt;gclist;
+        traverseproto(st, p);
+        break;
+      }
+      default: lua_assert(0);
+    }
+  }
+}
+
+
+static int valismarked (const TObject *o) {
+  if (ttisstring(o))
+    stringmark(tsvalue(o));  /* strings are `values', so are never weak */
+  return !iscollectable(o) || testbit(o-&gt;value.gc-&gt;gch.marked, 0);
+}
+
+
+/*
+** clear collected keys from weaktables
+*/
+static void cleartablekeys (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = sizenode(h);
+    lua_assert(h-&gt;marked &amp; KEYWEAK);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gkey(n)))  /* key was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h-&gt;gclist;
+  }
+}
+
+
+/*
+** clear collected values from weaktables
+*/
+static void cleartablevalues (GCObject *l) {
+  while (l) {
+    Table *h = gcotoh(l);
+    int i = h-&gt;sizearray;
+    lua_assert(h-&gt;marked &amp; VALUEWEAK);
+    while (i--) {
+      TObject *o = &amp;h-&gt;array[i];
+      if (!valismarked(o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    i = sizenode(h);
+    while (i--) {
+      Node *n = gnode(h, i);
+      if (!valismarked(gval(n)))  /* value was collected? */
+        removekey(n);  /* remove entry from table */
+    }
+    l = h-&gt;gclist;
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (o-&gt;gch.tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gcotop(o)); break;
+    case LUA_TFUNCTION: luaF_freeclosure(L, gcotocl(o)); break;
+    case LUA_TUPVAL: luaM_freelem(L, gcotouv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gcotoh(o)); break;
+    case LUA_TTHREAD: {
+      lua_assert(gcototh(o) != L &amp;&amp; gcototh(o) != G(L)-&gt;mainthread);
+      luaE_freethread(L, gcototh(o));
+      break;
+    }
+    case LUA_TSTRING: {
+      luaM_free(L, o, sizestring(gcotots(o)-&gt;tsv.len));
+      break;
+    }
+    case LUA_TUSERDATA: {
+      luaM_free(L, o, sizeudata(gcotou(o)-&gt;uv.len));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+static int sweeplist (lua_State *L, GCObject **p, int limit) {
+  GCObject *curr;
+  int count = 0;  /* number of collected items */
+  while ((curr = *p) != NULL) {
+    if (curr-&gt;gch.marked &gt; limit) {
+      unmark(curr);
+      p = &amp;curr-&gt;gch.next;
+    }
+    else {
+      count++;
+      *p = curr-&gt;gch.next;
+      freeobj(L, curr);
+    }
+  }
+  return count;
+}
+
+
+static void sweepstrings (lua_State *L, int all) {
+  int i;
+  for (i=0; i&lt;G(L)-&gt;strt.size; i++) {  /* for each list */
+    G(L)-&gt;strt.nuse -= sweeplist(L, &amp;G(L)-&gt;strt.hash[i], all);
+  }
+}
+
+
+static void checkSizes (lua_State *L) {
+  /* check size of string hash */
+  if (G(L)-&gt;strt.nuse &lt; cast(ls_nstr, G(L)-&gt;strt.size/4) &amp;&amp;
+      G(L)-&gt;strt.size &gt; MINSTRTABSIZE*2)
+    luaS_resize(L, G(L)-&gt;strt.size/2);  /* table is too big */
+  /* check size of buffer */
+  if (luaZ_sizebuffer(&amp;G(L)-&gt;buff) &gt; LUA_MINBUFFER*2) {  /* buffer too big? */
+    size_t newsize = luaZ_sizebuffer(&amp;G(L)-&gt;buff) / 2;
+    luaZ_resizebuffer(L, &amp;G(L)-&gt;buff, newsize);
+  }
+  G(L)-&gt;GCthreshold = 2*G(L)-&gt;nblocks;  /* new threshold */
+}
+
+
+static void do1gcTM (lua_State *L, Udata *udata) {
+  const TObject *tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);
+  if (tm != NULL) {
+    setobj2s(L-&gt;top, tm);
+    setuvalue(L-&gt;top+1, udata);
+    L-&gt;top += 2;
+    luaD_call(L, L-&gt;top - 2, 0);
+  }
+}
+
+
+void luaC_callGCTM (lua_State *L) {
+  lu_byte oldah = L-&gt;allowhook;
+  L-&gt;allowhook = 0;  /* stop debug hooks during GC tag methods */
+  L-&gt;top++;  /* reserve space to keep udata while runs its gc method */
+  while (G(L)-&gt;tmudata != NULL) {
+    GCObject *o = G(L)-&gt;tmudata;
+    Udata *udata = gcotou(o);
+    G(L)-&gt;tmudata = udata-&gt;uv.next;  /* remove udata from `tmudata' */
+    udata-&gt;uv.next = G(L)-&gt;rootudata;  /* return it to `root' list */
+    G(L)-&gt;rootudata = o;
+    setuvalue(L-&gt;top - 1, udata);  /* keep a reference to it */
+    unmark(o);
+    markfinalized(udata);
+    do1gcTM(L, udata);
+  }
+  L-&gt;top--;
+  L-&gt;allowhook = oldah;  /* restore hooks */
+}
+
+
+void luaC_sweep (lua_State *L, int all) {
+  if (all) all = 256;  /* larger than any mark */
+  sweeplist(L, &amp;G(L)-&gt;rootudata, all);
+  sweepstrings(L, all);
+  sweeplist(L, &amp;G(L)-&gt;rootgc, all);
+}
+
+
+/* mark root set */
+static void markroot (GCState *st, lua_State *L) {
+  global_State *g = st-&gt;g;
+  markobject(st, defaultmeta(L));
+  markobject(st, registry(L));
+  traversestack(st, g-&gt;mainthread);
+  if (L != g-&gt;mainthread)  /* another thread is running? */
+    markvalue(st, L);  /* cannot collect it */
+}
+
+
+static void mark (lua_State *L) {
+  GCState st;
+  GCObject *wkv;
+  st.g = G(L);
+  st.tmark = NULL;
+  st.wkv = st.wk = st.wv = NULL;
+  markroot(&amp;st, L);
+  propagatemarks(&amp;st);  /* mark all reachable objects */
+  cleartablevalues(st.wkv);
+  cleartablevalues(st.wv);
+  wkv = st.wkv;  /* keys must be cleared after preserving udata */
+  st.wkv = NULL;
+  st.wv = NULL;
+  luaC_separateudata(L);  /* separate userdata to be preserved */
+  marktmu(&amp;st);  /* mark `preserved' userdata */
+  propagatemarks(&amp;st);  /* remark, to propagate `preserveness' */
+  cleartablekeys(wkv);
+  /* `propagatemarks' may resuscitate some weak tables; clear them too */
+  cleartablekeys(st.wk);
+  cleartablevalues(st.wv);
+  cleartablekeys(st.wkv);
+  cleartablevalues(st.wkv);
+}
+
+
+void luaC_collectgarbage (lua_State *L) {
+  mark(L);
+  luaC_sweep(L, 0);
+  checkSizes(L);
+  luaC_callGCTM(L);
+}
+
+
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
+  o-&gt;gch.next = G(L)-&gt;rootgc;
+  G(L)-&gt;rootgc = o;
+  o-&gt;gch.marked = 0;
+  o-&gt;gch.tt = tt;
+}
+

Added: trunk/source/libraries/lua/lgc.h
===================================================================
--- trunk/source/libraries/lua/lgc.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lgc.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,25 @@
+/*
+** $Id: lgc.h,v 1.19 2003/02/28 19:45:15 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include &quot;lobject.h&quot;
+
+
+#define luaC_checkGC(L) { lua_assert(!(L-&gt;ci-&gt;state &amp; CI_CALLING)); \
+	if (G(L)-&gt;nblocks &gt;= G(L)-&gt;GCthreshold) luaC_collectgarbage(L); }
+
+
+void luaC_separateudata (lua_State *L);
+void luaC_callGCTM (lua_State *L);
+void luaC_sweep (lua_State *L, int all);
+void luaC_collectgarbage (lua_State *L);
+void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
+
+
+#endif

Added: trunk/source/libraries/lua/lib/Makefile
===================================================================
--- trunk/source/libraries/lua/lib/Makefile	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/Makefile	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,27 @@
+# makefile for Lua standard library
+
+LUA= ../..
+
+include $(LUA)/config
+
+EXTRA_DEFS= $(POPEN) $(TMPNAM) $(DEGREES) $(LOADLIB)
+
+OBJS= lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o ltablib.o lstrlib.o loadlib.o
+SRCS= lauxlib.c lbaselib.c ldblib.c liolib.c lmathlib.c ltablib.c lstrlib.c loadlib.c
+
+T= $(LIB)/liblualib.a
+
+all:	$T
+
+$T:	$(OBJS)
+	$(AR) $@ $(OBJS)
+	$(RANLIB) $@
+
+clean:
+	rm -f $(OBJS) $T
+
+co:
+	co -q -f -M $(SRCS)
+
+klean:	clean
+	rm -f $(SRCS)

Added: trunk/source/libraries/lua/lib/README
===================================================================
--- trunk/source/libraries/lua/lib/README	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/README	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,8 @@
+This is the standard Lua library.
+
+The code of the standard library can be read as an example of how to export
+C functions to Lua. The easiest library to read is lmathlib.c.
+
+The library is implemented entirely on top of the official Lua API as declared
+in lua.h, using lauxlib.c, which contains several useful functions for writing
+libraries. We encourage developers to use lauxlib.c in their own libraries.

Added: trunk/source/libraries/lua/lib/lauxlib.c
===================================================================
--- trunk/source/libraries/lua/lib/lauxlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lauxlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,591 @@
+/*
+** $Id: lauxlib.c,v 1.100 2003/04/07 14:35:00 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+
+
+/* number of prereserved references (for internal use) */
+#define RESERVED_REFS	2
+
+/* reserved references */
+#define FREELIST_REF	1	/* free list of references */
+#define ARRAYSIZE_REF	2	/* array sizes */
+
+
+/* convert a stack index to positive */
+#define abs_index(L, i)		((i) &gt; 0 || (i) &lt;= LUA_REGISTRYINDEX ? (i) : \
+					lua_gettop(L) + (i) + 1)
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  lua_getstack(L, 0, &amp;ar);
+  lua_getinfo(L, &quot;n&quot;, &amp;ar);
+  if (strcmp(ar.namewhat, &quot;method&quot;) == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, &quot;calling `%s' on bad self (%s)&quot;, ar.name, extramsg);
+  }
+  if (ar.name == NULL)
+    ar.name = &quot;?&quot;;
+  return luaL_error(L, &quot;bad argument #%d to `%s' (%s)&quot;,
+                        narg, ar.name, extramsg);
+}
+
+
+LUALIB_API int luaL_typerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, &quot;%s expected, got %s&quot;,
+                                    tname, lua_typename(L, lua_type(L,narg)));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  luaL_typerror(L, narg, lua_typename(L, tag)); 
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &amp;ar)) {  /* check function at level */
+    lua_getinfo(L, &quot;Snl&quot;, &amp;ar);  /* get info about it */
+    if (ar.currentline &gt; 0) {  /* is there info? */
+      lua_pushfstring(L, &quot;%s:%d: &quot;, ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, &quot;&quot;);  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_findstring (const char *name, const char *const list[]) {
+  int i;
+  for (i=0; list[i]; i++)
+    if (strcmp(list[i], name) == 0)
+      return i;
+  return -1;  /* name not found */
+}
+
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry.name */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushstring(L, tname);
+  lua_pushvalue(L, -2);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry.name = metatable */
+  lua_pushvalue(L, -1);
+  lua_pushstring(L, tname);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* registry[metatable] = name */
+  return 1;
+}
+
+
+LUALIB_API void  luaL_getmetatable (lua_State *L, const char *tname) {
+  lua_pushstring(L, tname);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  const char *tn;
+  if (!lua_getmetatable(L, ud)) return NULL;  /* no metatable? */
+  lua_rawget(L, LUA_REGISTRYINDEX);  /* get registry[metatable] */
+  tn = lua_tostring(L, -1);
+  if (tn &amp;&amp; (strcmp(tn, tname) == 0)) {
+    lua_pop(L, 1);
+    return lua_touserdata(L, ud);
+  }
+  else {
+    lua_pop(L, 1);
+    return NULL;
+  }
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
+  if (!lua_checkstack(L, space))
+    luaL_error(L, &quot;stack overflow (%s)&quot;, mes);
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, &quot;value expected&quot;);
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tostring(L, narg);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  if (len) *len = lua_strlen(L, narg);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  lua_Number d = lua_tonumber(L, narg);
+  if (d == 0 &amp;&amp; !lua_isnumber(L, narg))  /* avoid extra test when d is not 0 */
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  if (lua_isnoneornil(L, narg)) return def;
+  else return luaL_checknumber(L, narg);
+}
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = abs_index(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                              const luaL_reg *l, int nup) {
+  if (libname) {
+    lua_pushstring(L, libname);
+    lua_gettable(L, LUA_GLOBALSINDEX);  /* check whether lib already exists */
+    if (lua_isnil(L, -1)) {  /* no? */
+      lua_pop(L, 1);
+      lua_newtable(L);  /* create it */
+      lua_pushstring(L, libname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, LUA_GLOBALSINDEX);  /* register it with given name */
+    }
+    lua_insert(L, -(nup+1));  /* move library table to below upvalues */
+  }
+  for (; l-&gt;name; l++) {
+    int i;
+    lua_pushstring(L, l-&gt;name);
+    for (i=0; i&lt;nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -(nup+1));
+    lua_pushcclosure(L, l-&gt;func, nup);
+    lua_settable(L, -(nup+3));
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+
+/*
+** {======================================================
+** getn-setn: size for arrays
+** =======================================================
+*/
+
+static int checkint (lua_State *L, int topop) {
+  int n = (int)lua_tonumber(L, -1);
+  if (n == 0 &amp;&amp; !lua_isnumber(L, -1)) n = -1;
+  lua_pop(L, topop);
+  return n;
+}
+
+
+static void getsizes (lua_State *L) {
+  lua_rawgeti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);
+  if (lua_isnil(L, -1)) {  /* no `size' table? */
+    lua_pop(L, 1);  /* remove nil */
+    lua_newtable(L);  /* create it */
+    lua_pushvalue(L, -1);  /* `size' will be its own metatable */
+    lua_setmetatable(L, -2);
+    lua_pushliteral(L, &quot;__mode&quot;);
+    lua_pushliteral(L, &quot;k&quot;);
+    lua_rawset(L, -3);  /* metatable(N).__mode = &quot;k&quot; */
+    lua_pushvalue(L, -1);
+    lua_rawseti(L, LUA_REGISTRYINDEX, ARRAYSIZE_REF);  /* store in register */
+  }
+}
+
+
+void luaL_setn (lua_State *L, int t, int n) {
+  t = abs_index(L, t);
+  lua_pushliteral(L, &quot;n&quot;);
+  lua_rawget(L, t);
+  if (checkint(L, 1) &gt;= 0) {  /* is there a numeric field `n'? */
+    lua_pushliteral(L, &quot;n&quot;);  /* use it */
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, t);
+  }
+  else {  /* use `sizes' */
+    getsizes(L);
+    lua_pushvalue(L, t);
+    lua_pushnumber(L, (lua_Number)n);
+    lua_rawset(L, -3);  /* sizes[t] = n */
+    lua_pop(L, 1);  /* remove `sizes' */
+  }
+}
+
+
+int luaL_getn (lua_State *L, int t) {
+  int n;
+  t = abs_index(L, t);
+  lua_pushliteral(L, &quot;n&quot;);  /* try t.n */
+  lua_rawget(L, t);
+  if ((n = checkint(L, 1)) &gt;= 0) return n;
+  getsizes(L);  /* else try sizes[t] */
+  lua_pushvalue(L, t);
+  lua_rawget(L, -2);
+  if ((n = checkint(L, 2)) &gt;= 0) return n;
+  for (n = 1; ; n++) {  /* else must count elements */
+    lua_rawgeti(L, t, n);
+    if (lua_isnil(L, -1)) break;
+    lua_pop(L, 1);
+  }
+  lua_pop(L, 1);
+  return n - 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+
+#define bufflen(B)	((B)-&gt;p - (B)-&gt;buffer)
+#define bufffree(B)	((size_t)(LUAL_BUFFERSIZE - bufflen(B)))
+
+#define LIMIT	(LUA_MINSTACK/2)
+
+
+static int emptybuffer (luaL_Buffer *B) {
+  size_t l = bufflen(B);
+  if (l == 0) return 0;  /* put nothing on stack */
+  else {
+    lua_pushlstring(B-&gt;L, B-&gt;buffer, l);
+    B-&gt;p = B-&gt;buffer;
+    B-&gt;lvl++;
+    return 1;
+  }
+}
+
+
+static void adjuststack (luaL_Buffer *B) {
+  if (B-&gt;lvl &gt; 1) {
+    lua_State *L = B-&gt;L;
+    int toget = 1;  /* number of levels to concat */
+    size_t toplen = lua_strlen(L, -1);
+    do {
+      size_t l = lua_strlen(L, -(toget+1));
+      if (B-&gt;lvl - toget + 1 &gt;= LIMIT || toplen &gt; l) {
+        toplen += l;
+        toget++;
+      }
+      else break;
+    } while (toget &lt; B-&gt;lvl);
+    lua_concat(L, toget);
+    B-&gt;lvl = B-&gt;lvl - toget + 1;
+  }
+}
+
+
+LUALIB_API char *luaL_prepbuffer (luaL_Buffer *B) {
+  if (emptybuffer(B))
+    adjuststack(B);
+  return B-&gt;buffer;
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  while (l--)
+    luaL_putchar(B, *s++);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  emptybuffer(B);
+  lua_concat(B-&gt;L, B-&gt;lvl);
+  B-&gt;lvl = 1;
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B-&gt;L;
+  size_t vl = lua_strlen(L, -1);
+  if (vl &lt;= bufffree(B)) {  /* fit into buffer? */
+    memcpy(B-&gt;p, lua_tostring(L, -1), vl);  /* put it there */
+    B-&gt;p += vl;
+    lua_pop(L, 1);  /* remove from stack */
+  }
+  else {
+    if (emptybuffer(B))
+      lua_insert(L, -2);  /* put buffer before new value */
+    B-&gt;lvl++;  /* add new value into B stack */
+    adjuststack(B);
+  }
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B-&gt;L = L;
+  B-&gt;p = B-&gt;buffer;
+  B-&gt;lvl = 0;
+}
+
+/* }====================================================== */
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  t = abs_index(L, t);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  lua_rawgeti(L, t, FREELIST_REF);  /* get first free element */
+  ref = (int)lua_tonumber(L, -1);  /* ref = t[FREELIST_REF] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, FREELIST_REF);  /* (t[FREELIST_REF] = t[ref]) */
+  }
+  else {  /* no free elements */
+    ref = luaL_getn(L, t);
+    if (ref &lt; RESERVED_REFS)
+      ref = RESERVED_REFS;  /* skip reserved references */
+    ref++;  /* create new reference */
+    luaL_setn(L, t, ref);
+  }
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref &gt;= 0) {
+    t = abs_index(L, t);
+    lua_rawgeti(L, t, FREELIST_REF);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[FREELIST_REF] */
+    lua_pushnumber(L, (lua_Number)ref);
+    lua_rawseti(L, t, FREELIST_REF);  /* t[FREELIST_REF] = ref */
+  }
+}
+
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  FILE *f;
+  char buff[LUAL_BUFFERSIZE];
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;
+  if (feof(lf-&gt;f)) return NULL;
+  *size = fread(lf-&gt;buff, 1, LUAL_BUFFERSIZE, lf-&gt;f);
+  return (*size &gt; 0) ? lf-&gt;buff : NULL;
+}
+
+
+static int errfile (lua_State *L, int fnameindex) {
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, &quot;cannot read %s: %s&quot;, filename, strerror(errno));
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+LUALIB_API int luaL_loadfile (lua_State *L, const char *filename) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, &quot;=stdin&quot;);
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, &quot;@%s&quot;, filename);
+    lf.f = fopen(filename, &quot;r&quot;);
+  }
+  if (lf.f == NULL) return errfile(L, fnameindex);  /* unable to open file */
+  c = ungetc(getc(lf.f), lf.f);
+  if (!(isspace(c) || isprint(c)) &amp;&amp; lf.f != stdin) {  /* binary file? */
+    fclose(lf.f);
+    lf.f = fopen(filename, &quot;rb&quot;);  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, fnameindex); /* unable to reopen file */
+  }
+  status = lua_load(L, getF, &amp;lf, lua_tostring(L, -1));
+  readstatus = ferror(lf.f);
+  if (lf.f != stdin) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;
+  if (ls-&gt;size == 0) return NULL;
+  *size = ls-&gt;size;
+  ls-&gt;size = 0;
+  return ls-&gt;s;
+}
+
+
+LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size,
+                                const char *name) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &amp;ls, name);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** compatibility code
+** =======================================================
+*/
+
+
+static void callalert (lua_State *L, int status) {
+  if (status != 0) {
+    lua_getglobal(L, &quot;_ALERT&quot;);
+    if (lua_isfunction(L, -1)) {
+      lua_insert(L, -2);
+      lua_call(L, 1, 0);
+    }
+    else {  /* no _ALERT function; print it on stderr */
+      fprintf(stderr, &quot;%s\n&quot;, lua_tostring(L, -2));
+      lua_pop(L, 2);  /* remove error message and _ALERT */
+    }
+  }
+}
+
+
+static int aux_do (lua_State *L, int status) {
+  if (status == 0) {  /* parse OK? */
+    status = lua_pcall(L, 0, LUA_MULTRET, 0);  /* call main */
+  }
+  callalert(L, status);
+  return status;
+}
+
+
+LUALIB_API int lua_dofile (lua_State *L, const char *filename) {
+  return aux_do(L, luaL_loadfile(L, filename));
+}
+
+
+LUALIB_API int lua_dobuffer (lua_State *L, const char *buff, size_t size,
+                          const char *name) {
+  return aux_do(L, luaL_loadbuffer(L, buff, size, name));
+}
+
+
+LUALIB_API int lua_dostring (lua_State *L, const char *str) {
+  return lua_dobuffer(L, str, strlen(str), str);
+}
+
+/* }====================================================== */

Added: trunk/source/libraries/lua/lib/lbaselib.c
===================================================================
--- trunk/source/libraries/lua/lib/lbaselib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lbaselib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,674 @@
+/*
+** $Id: lbaselib.c,v 1.130 2003/04/03 13:35:34 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include &lt;ctype.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define lbaselib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+
+/*
+** If your system does not support `stdout', you can just remove this function.
+** If you need, you can define your own `print' function, following this
+** model but changing `fputs' to put the strings at a proper place
+** (a console window or a log file, for instance).
+*/
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, &quot;tostring&quot;);
+  for (i=1; i&lt;=n; i++) {
+    const char *s;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tostring(L, -1);  /* get result */
+    if (s == NULL)
+      return luaL_error(L, &quot;`tostring' must return a string to `print'&quot;);
+    if (i&gt;1) fputs(&quot;\t&quot;, stdout);
+    fputs(s, stdout);
+    lua_pop(L, 1);  /* pop result */
+  }
+  fputs(&quot;\n&quot;, stdout);
+  return 0;
+}
+
+
+static int luaB_tonumber (lua_State *L) {
+  int base = luaL_optint(L, 2, 10);
+  if (base == 10) {  /* standard conversion */
+    luaL_checkany(L, 1);
+    if (lua_isnumber(L, 1)) {
+      lua_pushnumber(L, lua_tonumber(L, 1));
+      return 1;
+    }
+  }
+  else {
+    const char *s1 = luaL_checkstring(L, 1);
+    char *s2;
+    unsigned long n;
+    luaL_argcheck(L, 2 &lt;= base &amp;&amp; base &lt;= 36, 2, &quot;base out of range&quot;);
+    n = strtoul(s1, &amp;s2, base);
+    if (s1 != s2) {  /* at least one valid digit? */
+      while (isspace((unsigned char)(*s2))) s2++;  /* skip trailing spaces */
+      if (*s2 == '\0') {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (lua_Number)n);
+        return 1;
+      }
+    }
+  }
+  lua_pushnil(L);  /* else not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  if (!lua_isstring(L, 1) || level == 0)
+    lua_pushvalue(L, 1);  /* propagate error message without changes */
+  else {  /* add extra information */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, &quot;__metatable&quot;);
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    &quot;nil or table expected&quot;);
+  if (luaL_getmetafield(L, 1, &quot;__metatable&quot;))
+    luaL_error(L, &quot;cannot change a protected metatable&quot;);
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static void getfunc (lua_State *L) {
+  if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
+  else {
+    lua_Debug ar;
+    int level = luaL_optint(L, 1, 1);
+    luaL_argcheck(L, level &gt;= 0, 1, &quot;level must be non-negative&quot;);
+    if (lua_getstack(L, level, &amp;ar) == 0)
+      luaL_argerror(L, 1, &quot;invalid level&quot;);
+    lua_getinfo(L, &quot;f&quot;, &amp;ar);
+    if (lua_isnil(L, -1))
+      luaL_error(L, &quot;no function environment for tail call at level %d&quot;,
+                    level);
+  }
+}
+
+
+static int aux_getfenv (lua_State *L) {
+  lua_getfenv(L, -1);
+  lua_pushliteral(L, &quot;__fenv&quot;);
+  lua_rawget(L, -2);
+  return !lua_isnil(L, -1);
+}
+
+
+static int luaB_getfenv (lua_State *L) {
+  getfunc(L);
+  if (!aux_getfenv(L))  /* __fenv not defined? */
+    lua_pop(L, 1);  /* remove it, to return real environment */
+  return 1;
+}
+
+
+static int luaB_setfenv (lua_State *L) {
+  luaL_checktype(L, 2, LUA_TTABLE);
+  getfunc(L);
+  if (aux_getfenv(L))  /* __fenv defined? */
+    luaL_error(L, &quot;`setfenv' cannot change a protected environment&quot;);
+  else
+    lua_pop(L, 2);  /* remove __fenv and real environment table */
+  lua_pushvalue(L, 2);
+  if (lua_isnumber(L, 1) &amp;&amp; lua_tonumber(L, 1) == 0)
+    lua_replace(L, LUA_GLOBALSINDEX);
+  else if (lua_setfenv(L, -2) == 0)
+    luaL_error(L, &quot;`setfenv' cannot change environment of given function&quot;);
+  return 0;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_gcinfo (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)lua_getgccount(L));
+  lua_pushnumber(L, (lua_Number)lua_getgcthreshold(L));
+  return 2;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  lua_setgcthreshold(L, luaL_optint(L, 1, 0));
+  return 0;
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, lua_typename(L, lua_type(L, 1)));
+  return 1;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushliteral(L, &quot;next&quot;);
+  lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+  lua_pushvalue(L, 1);  /* state, */
+  lua_pushnil(L);  /* and initial value */
+  return 3;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  lua_Number i = lua_tonumber(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (i == 0 &amp;&amp; lua_isnone(L, 2)) {  /* `for' start? */
+    lua_pushliteral(L, &quot;ipairs&quot;);
+    lua_rawget(L, LUA_GLOBALSINDEX);  /* return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    lua_pushnumber(L, 0);  /* and initial value */
+    return 3;
+  }
+  else {  /* `for' step */
+    i++;  /* next value */
+    lua_pushnumber(L, i);
+    lua_rawgeti(L, 1, (int)i);
+    return (lua_isnil(L, -1)) ? 0 : 2;
+  }
+}
+
+
+static int load_aux (lua_State *L, int status) {
+  if (status == 0)  /* OK? */
+    return 1;
+  else {
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadstring (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  const char *chunkname = luaL_optstring(L, 2, s);
+  return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  return load_aux(L, luaL_loadfile(L, fname));
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  int status = luaL_loadfile(L, fname);
+  if (status != 0) lua_error(L);
+  lua_call(L, 0, LUA_MULTRET);
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_assert (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, &quot;%s&quot;, luaL_optstring(L, 2, &quot;assertion failed!&quot;));
+  lua_settop(L, 1);
+  return 1;
+}
+
+
+static int luaB_unpack (lua_State *L) {
+  int n, i;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  n = luaL_getn(L, 1);
+  luaL_checkstack(L, n, &quot;table too big to unpack&quot;);
+  for (i=1; i&lt;=n; i++)  /* push arg[1...n] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
+  lua_pushboolean(L, (status == 0));
+  lua_insert(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_insert(L, 1);  /* put error function under function to be called */
+  status = lua_pcall(L, 0, LUA_MULTRET, 1);
+  lua_pushboolean(L, (status == 0));
+  lua_replace(L, 1);
+  return lua_gettop(L);  /* return status + all results */
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  char buff[64];
+  luaL_checkany(L, 1);
+  if (luaL_callmeta(L, 1, &quot;__tostring&quot;))  /* is there a metafield? */
+    return 1;  /* use its value */
+  switch (lua_type(L, 1)) {
+    case LUA_TNUMBER:
+      lua_pushstring(L, lua_tostring(L, 1));
+      return 1;
+    case LUA_TSTRING:
+      lua_pushvalue(L, 1);
+      return 1;
+    case LUA_TBOOLEAN:
+      lua_pushstring(L, (lua_toboolean(L, 1) ? &quot;true&quot; : &quot;false&quot;));
+      return 1;
+    case LUA_TTABLE:
+      sprintf(buff, &quot;table: %p&quot;, lua_topointer(L, 1));
+      break;
+    case LUA_TFUNCTION:
+      sprintf(buff, &quot;function: %p&quot;, lua_topointer(L, 1));
+      break;
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      sprintf(buff, &quot;userdata: %p&quot;, lua_touserdata(L, 1));
+      break;
+    case LUA_TTHREAD:
+      sprintf(buff, &quot;thread: %p&quot;, (void *)lua_tothread(L, 1));
+      break;
+    case LUA_TNIL:
+      lua_pushliteral(L, &quot;nil&quot;);
+      return 1;
+  }
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int luaB_newproxy (lua_State *L) {
+  lua_settop(L, 1);
+  lua_newuserdata(L, 0);  /* create proxy */
+  if (lua_toboolean(L, 1) == 0)
+    return 1;  /* no metatable */
+  else if (lua_isboolean(L, 1)) {
+    lua_newtable(L);  /* create a new metatable `m' ... */
+    lua_pushvalue(L, -1);  /* ... and mark `m' as a valid metatable */
+    lua_pushboolean(L, 1);
+    lua_rawset(L, lua_upvalueindex(1));  /* weaktable[m] = true */
+  }
+  else {
+    int validproxy = 0;  /* to check if weaktable[metatable(u)] == true */
+    if (lua_getmetatable(L, 1)) {
+      lua_rawget(L, lua_upvalueindex(1));
+      validproxy = lua_toboolean(L, -1);
+      lua_pop(L, 1);  /* remove value */
+    }
+    luaL_argcheck(L, validproxy, 1, &quot;boolean or proxy expected&quot;);
+    lua_getmetatable(L, 1);  /* metatable is valid; get it */
+  }
+  lua_setmetatable(L, 2);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** `require' function
+** =======================================================
+*/
+
+
+/* name of global that holds table with loaded packages */
+#define REQTAB		&quot;_LOADED&quot;
+
+/* name of global that holds the search path for packages */
+#define LUA_PATH	&quot;LUA_PATH&quot;
+
+#ifndef LUA_PATH_SEP
+#define LUA_PATH_SEP	';'
+#endif
+
+#ifndef LUA_PATH_MARK
+#define LUA_PATH_MARK	'?'
+#endif
+
+#ifndef LUA_PATH_DEFAULT
+#define LUA_PATH_DEFAULT	&quot;?;?.lua&quot;
+#endif
+
+
+static const char *getpath (lua_State *L) {
+  const char *path;
+  lua_getglobal(L, LUA_PATH);  /* try global variable */
+  path = lua_tostring(L, -1);
+  lua_pop(L, 1);
+  if (path) return path;
+  path = getenv(LUA_PATH);  /* else try environment variable */
+  if (path) return path;
+  return LUA_PATH_DEFAULT;  /* else use default */
+}
+
+
+static const char *pushnextpath (lua_State *L, const char *path) {
+  const char *l;
+  if (*path == '\0') return NULL;  /* no more paths */
+  if (*path == LUA_PATH_SEP) path++;  /* skip separator */
+  l = strchr(path, LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path+strlen(path);
+  lua_pushlstring(L, path, l - path);  /* directory name */
+  return l;
+}
+
+
+static void pushcomposename (lua_State *L) {
+  const char *path = lua_tostring(L, -1);
+  const char *wild;
+  int n = 1;
+  while ((wild = strchr(path, LUA_PATH_MARK)) != NULL) {
+    /* is there stack space for prefix, name, and eventual last sufix? */
+    luaL_checkstack(L, 3, &quot;too many marks in a path component&quot;);
+    lua_pushlstring(L, path, wild - path);  /* push prefix */
+    lua_pushvalue(L, 1);  /* push package name (in place of MARK) */
+    path = wild + 1;  /* continue after MARK */
+    n += 2;
+  }
+  lua_pushstring(L, path);  /* push last sufix (`n' already includes this) */
+  lua_concat(L, n);
+}
+
+
+static int luaB_require (lua_State *L) {
+  const char *path;
+  int status = LUA_ERRFILE;  /* not found (yet) */
+  luaL_checkstring(L, 1);
+  lua_settop(L, 1);
+  lua_getglobal(L, REQTAB);
+  if (!lua_istable(L, 2)) return luaL_error(L, &quot;`&quot; REQTAB &quot;' is not a table&quot;);
+  path = getpath(L);
+  lua_pushvalue(L, 1);  /* check package's name in book-keeping table */
+  lua_rawget(L, 2);
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded; return its result */
+  else {  /* must load it */
+    while (status == LUA_ERRFILE) {
+      lua_settop(L, 3);  /* reset stack position */
+      if ((path = pushnextpath(L, path)) == NULL) break;
+      pushcomposename(L);
+      status = luaL_loadfile(L, lua_tostring(L, -1));  /* try to load it */
+    }
+  }
+  switch (status) {
+    case 0: {
+      lua_getglobal(L, &quot;_REQUIREDNAME&quot;);  /* save previous name */
+      lua_insert(L, -2);  /* put it below function */
+      lua_pushvalue(L, 1);
+      lua_setglobal(L, &quot;_REQUIREDNAME&quot;);  /* set new name */
+      lua_call(L, 0, 1);  /* run loaded module */
+      lua_insert(L, -2);  /* put result below previous name */
+      lua_setglobal(L, &quot;_REQUIREDNAME&quot;);  /* reset to previous name */
+      if (lua_isnil(L, -1)) {  /* no/nil return? */
+        lua_pushboolean(L, 1);
+        lua_replace(L, -2);  /* replace to true */
+      }
+      lua_pushvalue(L, 1);
+      lua_pushvalue(L, -2);
+      lua_rawset(L, 2);  /* mark it as loaded */
+      return 1;  /* return value */
+    }
+    case LUA_ERRFILE: {  /* file not found */
+      return luaL_error(L, &quot;could not load package `%s' from path `%s'&quot;,
+                            lua_tostring(L, 1), getpath(L));
+    }
+    default: {
+      return luaL_error(L, &quot;error loading package `%s' (%s)&quot;,
+                           lua_tostring(L, 1), lua_tostring(L, -1));
+    }
+  }
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg base_funcs[] = {
+  {&quot;error&quot;, luaB_error},
+  {&quot;getmetatable&quot;, luaB_getmetatable},
+  {&quot;setmetatable&quot;, luaB_setmetatable},
+  {&quot;getfenv&quot;, luaB_getfenv},
+  {&quot;setfenv&quot;, luaB_setfenv},
+  {&quot;next&quot;, luaB_next},
+  {&quot;ipairs&quot;, luaB_ipairs},
+  {&quot;pairs&quot;, luaB_pairs},
+  {&quot;print&quot;, luaB_print},
+  {&quot;tonumber&quot;, luaB_tonumber},
+  {&quot;tostring&quot;, luaB_tostring},
+  {&quot;type&quot;, luaB_type},
+  {&quot;assert&quot;, luaB_assert},
+  {&quot;unpack&quot;, luaB_unpack},
+  {&quot;rawequal&quot;, luaB_rawequal},
+  {&quot;rawget&quot;, luaB_rawget},
+  {&quot;rawset&quot;, luaB_rawset},
+  {&quot;pcall&quot;, luaB_pcall},
+  {&quot;xpcall&quot;, luaB_xpcall},
+  {&quot;collectgarbage&quot;, luaB_collectgarbage},
+  {&quot;gcinfo&quot;, luaB_gcinfo},
+  {&quot;loadfile&quot;, luaB_loadfile},
+  {&quot;dofile&quot;, luaB_dofile},
+  {&quot;loadstring&quot;, luaB_loadstring},
+  {&quot;require&quot;, luaB_require},
+  {NULL, NULL}
+};
+
+
+/*
+** {======================================================
+** Coroutine library
+** =======================================================
+*/
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg))
+    luaL_error(L, &quot;too many arguments to resume&quot;);
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, narg);
+  if (status == 0) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres))
+      luaL_error(L, &quot;too many results to resume&quot;);
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r &lt; 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r &lt; 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL = lua_newthread(L);
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1), 1,
+    &quot;Lua function expected&quot;);
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
+  if (L == co) lua_pushliteral(L, &quot;running&quot;);
+  else {
+    lua_Debug ar;
+    if (lua_getstack(co, 0, &amp;ar) == 0 &amp;&amp; lua_gettop(co) == 0)
+      lua_pushliteral(L, &quot;dead&quot;);
+    else
+      lua_pushliteral(L, &quot;suspended&quot;);
+  }
+  return 1;
+}
+
+
+static const luaL_reg co_funcs[] = {
+  {&quot;create&quot;, luaB_cocreate},
+  {&quot;wrap&quot;, luaB_cowrap},
+  {&quot;resume&quot;, luaB_coresume},
+  {&quot;yield&quot;, luaB_yield},
+  {&quot;status&quot;, luaB_costatus},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+static void base_open (lua_State *L) {
+  lua_pushliteral(L, &quot;_G&quot;);
+  lua_pushvalue(L, LUA_GLOBALSINDEX);
+  luaL_openlib(L, NULL, base_funcs, 0);  /* open lib into global table */
+  lua_pushliteral(L, &quot;_VERSION&quot;);
+  lua_pushliteral(L, LUA_VERSION);
+  lua_rawset(L, -3);  /* set global _VERSION */
+  /* `newproxy' needs a weaktable as upvalue */
+  lua_pushliteral(L, &quot;newproxy&quot;);
+  lua_newtable(L);  /* new table `w' */
+  lua_pushvalue(L, -1);  /* `w' will be its own metatable */
+  lua_setmetatable(L, -2);
+  lua_pushliteral(L, &quot;__mode&quot;);
+  lua_pushliteral(L, &quot;k&quot;);
+  lua_rawset(L, -3);  /* metatable(w).__mode = &quot;k&quot; */
+  lua_pushcclosure(L, luaB_newproxy, 1);
+  lua_rawset(L, -3);  /* set global `newproxy' */
+  lua_rawset(L, -1);  /* set global _G */
+}
+
+
+LUALIB_API int luaopen_base (lua_State *L) {
+  base_open(L);
+  luaL_openlib(L, LUA_COLIBNAME, co_funcs, 0);
+  lua_newtable(L);
+  lua_setglobal(L, REQTAB);
+  return 0;
+}
+

Added: trunk/source/libraries/lua/lib/ldblib.c
===================================================================
--- trunk/source/libraries/lua/lib/ldblib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/ldblib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,299 @@
+/*
+** $Id: ldblib.c,v 1.80 2003/04/03 13:35:34 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ldblib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, i);
+  lua_pushstring(L, v);
+  lua_rawset(L, -3);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushstring(L, i);
+  lua_pushnumber(L, (lua_Number)v);
+  lua_rawset(L, -3);
+}
+
+
+static int getinfo (lua_State *L) {
+  lua_Debug ar;
+  const char *options = luaL_optstring(L, 2, &quot;flnSu&quot;);
+  if (lua_isnumber(L, 1)) {
+    if (!lua_getstack(L, (int)(lua_tonumber(L, 1)), &amp;ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, 1)) {
+    lua_pushfstring(L, &quot;&gt;%s&quot;, options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, 1);
+  }
+  else
+    return luaL_argerror(L, 1, &quot;function or level expected&quot;);
+  if (!lua_getinfo(L, options, &amp;ar))
+    return luaL_argerror(L, 2, &quot;invalid option&quot;);
+  lua_newtable(L);
+  for (; *options; options++) {
+    switch (*options) {
+      case 'S':
+        settabss(L, &quot;source&quot;, ar.source);
+        settabss(L, &quot;short_src&quot;, ar.short_src);
+        settabsi(L, &quot;linedefined&quot;, ar.linedefined);
+        settabss(L, &quot;what&quot;, ar.what);
+        break;
+      case 'l':
+        settabsi(L, &quot;currentline&quot;, ar.currentline);
+        break;
+      case 'u':
+        settabsi(L, &quot;nups&quot;, ar.nups);
+        break;
+      case 'n':
+        settabss(L, &quot;name&quot;, ar.name);
+        settabss(L, &quot;namewhat&quot;, ar.namewhat);
+        break;
+      case 'f':
+        lua_pushliteral(L, &quot;func&quot;);
+        lua_pushvalue(L, -3);
+        lua_rawset(L, -3);
+        break;
+    }
+  }
+  return 1;  /* return table */
+}
+    
+
+static int getlocal (lua_State *L) {
+  lua_Debug ar;
+  const char *name;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &amp;ar))  /* level out of range? */
+    return luaL_argerror(L, 1, &quot;level out of range&quot;);
+  name = lua_getlocal(L, &amp;ar, luaL_checkint(L, 2));
+  if (name) {
+    lua_pushstring(L, name);
+    lua_pushvalue(L, -2);
+    return 2;
+  }
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int setlocal (lua_State *L) {
+  lua_Debug ar;
+  if (!lua_getstack(L, luaL_checkint(L, 1), &amp;ar))  /* level out of range? */
+    return luaL_argerror(L, 1, &quot;level out of range&quot;);
+  luaL_checkany(L, 3);
+  lua_pushstring(L, lua_setlocal(L, &amp;ar, luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_iscfunction(L, 1)) return 0;  /* cannot touch C upvalues from Lua */
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+
+static const char KEY_HOOK = 'h';
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {&quot;call&quot;, &quot;return&quot;, &quot;line&quot;, &quot;count&quot;, &quot;tail return&quot;};
+  lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar-&gt;event]);
+    if (ar-&gt;currentline &gt;= 0)
+      lua_pushnumber(L, (lua_Number)ar-&gt;currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, &quot;lS&quot;, ar));
+    lua_call(L, 2, 0);
+  }
+  else
+    lua_pop(L, 1);  /* pop result from gettable */
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count &gt; 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask &amp; LUA_MASKCALL) smask[i++] = 'c';
+  if (mask &amp; LUA_MASKRET) smask[i++] = 'r';
+  if (mask &amp; LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int sethook (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {
+    lua_settop(L, 1);
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, 2);
+    int count = luaL_optint(L, 3, 0);
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_sethook(L, hookf, makemask(smask, count), count);
+  }
+  lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
+  lua_pushvalue(L, 1);
+  lua_rawset(L, LUA_REGISTRYINDEX);  /* set new hook */
+  return 0;
+}
+
+
+static int gethook (lua_State *L) {
+  char buff[5];
+  int mask = lua_gethookmask(L);
+  lua_Hook hook = lua_gethook(L);
+  if (hook != NULL &amp;&amp; hook != hookf)  /* external hook? */
+    lua_pushliteral(L, &quot;external hook&quot;);
+  else {
+    lua_pushlightuserdata(L, (void *)&amp;KEY_HOOK);
+    lua_rawget(L, LUA_REGISTRYINDEX);   /* get hook */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushnumber(L, (lua_Number)lua_gethookcount(L));
+  return 3;
+}
+
+
+static int debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    fputs(&quot;lua_debug&gt; &quot;, stderr);
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, &quot;cont\n&quot;) == 0)
+      return 0;
+    lua_dostring(L, buffer);
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+static int errorfb (lua_State *L) {
+  int level = 1;  /* skip level 0 (it's this function) */
+  int firstpart = 1;  /* still before eventual `...' */
+  lua_Debug ar;
+  if (lua_gettop(L) == 0)
+    lua_pushliteral(L, &quot;&quot;);
+  else if (!lua_isstring(L, 1)) return 1;  /* no string message */
+  else lua_pushliteral(L, &quot;\n&quot;);
+  lua_pushliteral(L, &quot;stack traceback:&quot;);
+  while (lua_getstack(L, level++, &amp;ar)) {
+    if (level &gt; LEVELS1 &amp;&amp; firstpart) {
+      /* no more than `LEVELS2' more levels? */
+      if (!lua_getstack(L, level+LEVELS2, &amp;ar))
+        level--;  /* keep going */
+      else {
+        lua_pushliteral(L, &quot;\n\t...&quot;);  /* too many levels */
+        while (lua_getstack(L, level+LEVELS2, &amp;ar))  /* find last levels */
+          level++;
+      }
+      firstpart = 0;
+      continue;
+    }
+    lua_pushliteral(L, &quot;\n\t&quot;);
+    lua_getinfo(L, &quot;Snl&quot;, &amp;ar);
+    lua_pushfstring(L, &quot;%s:&quot;, ar.short_src);
+    if (ar.currentline &gt; 0)
+      lua_pushfstring(L, &quot;%d:&quot;, ar.currentline);
+    switch (*ar.namewhat) {
+      case 'g':  /* global */ 
+      case 'l':  /* local */
+      case 'f':  /* field */
+      case 'm':  /* method */
+        lua_pushfstring(L, &quot; in function `%s'&quot;, ar.name);
+        break;
+      default: {
+        if (*ar.what == 'm')  /* main? */
+          lua_pushfstring(L, &quot; in main chunk&quot;);
+        else if (*ar.what == 'C' || *ar.what == 't')
+          lua_pushliteral(L, &quot; ?&quot;);  /* C function or tail call */
+        else
+          lua_pushfstring(L, &quot; in function &lt;%s:%d&gt;&quot;,
+                             ar.short_src, ar.linedefined);
+      }
+    }
+    lua_concat(L, lua_gettop(L));
+  }
+  lua_concat(L, lua_gettop(L));
+  return 1;
+}
+
+
+static const luaL_reg dblib[] = {
+  {&quot;getlocal&quot;, getlocal},
+  {&quot;getinfo&quot;, getinfo},
+  {&quot;gethook&quot;, gethook},
+  {&quot;getupvalue&quot;, getupvalue},
+  {&quot;sethook&quot;, sethook},
+  {&quot;setlocal&quot;, setlocal},
+  {&quot;setupvalue&quot;, setupvalue},
+  {&quot;debug&quot;, debug},
+  {&quot;traceback&quot;, errorfb},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_debug (lua_State *L) {
+  luaL_openlib(L, LUA_DBLIBNAME, dblib, 0);
+  lua_pushliteral(L, &quot;_TRACEBACK&quot;);
+  lua_pushcfunction(L, errorfb);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/liolib.c
===================================================================
--- trunk/source/libraries/lua/lib/liolib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/liolib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,750 @@
+/*
+** $Id: liolib.c,v 2.39 2003/03/19 21:16:12 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;errno.h&gt;
+#include &lt;locale.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;time.h&gt;
+
+#define liolib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+/*
+** by default, gcc does not get `tmpname'
+*/
+#ifndef USE_TMPNAME
+#ifdef __GNUC__
+#define USE_TMPNAME	0
+#else
+#define USE_TMPNAME	1
+#endif
+#endif
+
+
+/*
+** by default, posix systems get `popen'
+*/
+#ifndef USE_POPEN
+#ifdef _POSIX_C_SOURCE
+#if _POSIX_C_SOURCE &gt;= 2
+#define USE_POPEN	1
+#endif
+#endif
+#endif
+
+#ifndef USE_POPEN
+#define USE_POPEN	0
+#endif
+
+
+
+
+/*
+** {======================================================
+** FILE Operations
+** =======================================================
+*/
+
+
+#if !USE_POPEN
+#define pclose(f)    (-1)
+#endif
+
+
+#define FILEHANDLE		&quot;FILE*&quot;
+
+#define IO_INPUT		&quot;_input&quot;
+#define IO_OUTPUT		&quot;_output&quot;
+
+
+static int pushresult (lua_State *L, int i, const char *filename) {
+  if (i) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (filename)
+      lua_pushfstring(L, &quot;%s: %s&quot;, filename, strerror(errno));
+    else
+      lua_pushfstring(L, &quot;%s&quot;, strerror(errno));
+    lua_pushnumber(L, errno);
+    return 3;
+  }
+}
+
+
+static FILE **topfile (lua_State *L, int findex) {
+  FILE **f = (FILE **)luaL_checkudata(L, findex, FILEHANDLE);
+  if (f == NULL) luaL_argerror(L, findex, &quot;bad file&quot;);
+  return f;
+}
+
+
+static int io_type (lua_State *L) {
+  FILE **f = (FILE **)luaL_checkudata(L, 1, FILEHANDLE);
+  if (f == NULL) lua_pushnil(L);
+  else if (*f == NULL)
+    lua_pushliteral(L, &quot;closed file&quot;);
+  else
+    lua_pushliteral(L, &quot;file&quot;);
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L, int findex) {
+  FILE **f = topfile(L, findex);
+  if (*f == NULL)
+    luaL_error(L, &quot;attempt to use a closed file&quot;);
+  return *f;
+}
+
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static FILE **newfile (lua_State *L) {
+  FILE **pf = (FILE **)lua_newuserdata(L, sizeof(FILE *));
+  *pf = NULL;  /* file handle is currently `closed' */
+  luaL_getmetatable(L, FILEHANDLE);
+  lua_setmetatable(L, -2);
+  return pf;
+}
+
+
+/*
+** assumes that top of the stack is the `io' library, and next is
+** the `io' metatable
+*/
+static void registerfile (lua_State *L, FILE *f, const char *name,
+                                                 const char *impname) {
+  lua_pushstring(L, name);
+  *newfile(L) = f;
+  if (impname) {
+    lua_pushstring(L, impname);
+    lua_pushvalue(L, -2);
+    lua_settable(L, -6);  /* metatable[impname] = file */
+  }
+  lua_settable(L, -3);  /* io[name] = file */
+}
+
+
+static int aux_close (lua_State *L) {
+  FILE *f = tofile(L, 1);
+  if (f == stdin || f == stdout || f == stderr)
+    return 0;  /* file cannot be closed */
+  else {
+    int ok = (pclose(f) != -1) || (fclose(f) == 0);
+    if (ok)
+      *(FILE **)lua_touserdata(L, 1) = NULL;  /* mark file as closed */
+    return ok;
+  }
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushstring(L, IO_OUTPUT);
+    lua_rawget(L, lua_upvalueindex(1));
+  }
+  return pushresult(L, aux_close(L), NULL);
+}
+
+
+static int io_gc (lua_State *L) {
+  FILE **f = topfile(L, 1);
+  if (*f != NULL)  /* ignore closed files */
+    aux_close(L);
+  return 0;
+}
+
+
+static int io_tostring (lua_State *L) {
+  char buff[32];
+  FILE **f = topfile(L, 1);
+  if (*f == NULL)
+    strcpy(buff, &quot;closed&quot;);
+  else
+    sprintf(buff, &quot;%p&quot;, lua_touserdata(L, 1));
+  lua_pushfstring(L, &quot;file (%s)&quot;, buff);
+  return 1;
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
+  FILE **pf = newfile(L);
+  *pf = fopen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+}
+
+
+static int io_popen (lua_State *L) {
+#if !USE_POPEN
+  luaL_error(L, &quot;`popen' not supported&quot;);
+  return 0;
+#else
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, &quot;r&quot;);
+  FILE **pf = newfile(L);
+  *pf = popen(filename, mode);
+  return (*pf == NULL) ? pushresult(L, 0, filename) : 1;
+#endif
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  FILE **pf = newfile(L);
+  *pf = tmpfile();
+  return (*pf == NULL) ? pushresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *name) {
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return tofile(L, -1);
+}
+
+
+static int g_iofile (lua_State *L, const char *name, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    lua_pushstring(L, name);
+    if (filename) {
+      FILE **pf = newfile(L);
+      *pf = fopen(filename, mode);
+      if (*pf == NULL) {
+        lua_pushfstring(L, &quot;%s: %s&quot;, filename, strerror(errno));
+        luaL_argerror(L, 1, lua_tostring(L, -1));
+      }
+    }
+    else {
+      tofile(L, 1);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_rawset(L, lua_upvalueindex(1));
+  }
+  /* return current value */
+  lua_pushstring(L, name);
+  lua_rawget(L, lua_upvalueindex(1));
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, &quot;r&quot;);
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, &quot;w&quot;);
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int idx, int close) {
+  lua_pushliteral(L, FILEHANDLE);
+  lua_rawget(L, LUA_REGISTRYINDEX);
+  lua_pushvalue(L, idx);
+  lua_pushboolean(L, close);  /* close/not close file when finished */
+  lua_pushcclosure(L, io_readline, 3);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L, 1);  /* check that it's a valid file handle */
+  aux_lines(L, 1, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {  /* no arguments? */
+    lua_pushstring(L, IO_INPUT);
+    lua_rawget(L, lua_upvalueindex(1));  /* will iterate over default input */
+    return f_lines(L);
+  }
+  else {
+    const char *filename = luaL_checkstring(L, 1);
+    FILE **pf = newfile(L);
+    *pf = fopen(filename, &quot;r&quot;);
+    luaL_argcheck(L, *pf, 1,  strerror(errno));
+    aux_lines(L, lua_gettop(L), 1);
+    return 1;
+  }
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &amp;d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else return 0;  /* read fails */
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&amp;b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&amp;b);  /* close buffer */
+      return (lua_strlen(L, -1) &gt; 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (p[l-1] != '\n')
+      luaL_addsize(&amp;b, l);
+    else {
+      luaL_addsize(&amp;b, l - 1);  /* do not include `eol' */
+      luaL_pushresult(&amp;b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t rlen;  /* how much to read */
+  size_t nr;  /* number of chars actually read */
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  rlen = LUAL_BUFFERSIZE;  /* try to read that much each time */
+  do {
+    char *p = luaL_prepbuffer(&amp;b);
+    if (rlen &gt; n) rlen = n;  /* cannot read more than asked */
+    nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&amp;b, nr);
+    n -= nr;  /* still have to read `n' chars */
+  } while (n &gt; 0 &amp;&amp; nr == rlen);  /* until end of count or eof */
+  luaL_pushresult(&amp;b);  /* close buffer */
+  return (n == 0 || lua_strlen(L, -1) &gt; 0);
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, &quot;too many arguments&quot;);
+    success = 1;
+    for (n = first; nargs-- &amp;&amp; success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tonumber(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p &amp;&amp; p[0] == '*', n, &quot;invalid option&quot;);
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f);
+            break;
+          case 'a':  /* file */
+            read_chars(L, f, ~((size_t)0));  /* read MAX_SIZE_T chars */
+            success = 1; /* always success */
+            break;
+          case 'w':  /* word */
+            return luaL_error(L, &quot;obsolete option `*w' to `read'&quot;);
+          default:
+            return luaL_argerror(L, n, &quot;invalid format&quot;);
+        }
+      }
+    }
+  }
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L, 1), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  FILE *f = *(FILE **)lua_touserdata(L, lua_upvalueindex(2));
+  if (f == NULL)  /* file is already closed? */
+    luaL_error(L, &quot;file is already closed&quot;);
+  if (read_line(L, f)) return 1;
+  else {  /* EOF */
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(2));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - 1;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &amp;&amp;
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) &gt; 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &amp;l);
+      status = status &amp;&amp; (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  return pushresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  return g_write(L, tofile(L, 1), 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {&quot;set&quot;, &quot;cur&quot;, &quot;end&quot;, NULL};
+  FILE *f = tofile(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, &quot;cur&quot;), modenames);
+  long offset = luaL_optlong(L, 3, 0);
+  luaL_argcheck(L, op != -1, 2, &quot;invalid mode&quot;);
+  op = fseek(f, offset, mode[op]);
+  if (op)
+    return pushresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, ftell(f));
+    return 1;
+  }
+}
+
+
+static int io_flush (lua_State *L) {
+  return pushresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return pushresult(L, fflush(tofile(L, 1)) == 0, NULL);
+}
+
+
+static const luaL_reg iolib[] = {
+  {&quot;input&quot;, io_input},
+  {&quot;output&quot;, io_output},
+  {&quot;lines&quot;, io_lines},
+  {&quot;close&quot;, io_close},
+  {&quot;flush&quot;, io_flush},
+  {&quot;open&quot;, io_open},
+  {&quot;popen&quot;, io_popen},
+  {&quot;read&quot;, io_read},
+  {&quot;tmpfile&quot;, io_tmpfile},
+  {&quot;type&quot;, io_type},
+  {&quot;write&quot;, io_write},
+  {NULL, NULL}
+};
+
+
+static const luaL_reg flib[] = {
+  {&quot;flush&quot;, f_flush},
+  {&quot;read&quot;, f_read},
+  {&quot;lines&quot;, f_lines},
+  {&quot;seek&quot;, f_seek},
+  {&quot;write&quot;, f_write},
+  {&quot;close&quot;, io_close},
+  {&quot;__gc&quot;, io_gc},
+  {&quot;__tostring&quot;, io_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, FILEHANDLE);  /* create new metatable for file handles */
+  /* file methods */
+  lua_pushliteral(L, &quot;__index&quot;);
+  lua_pushvalue(L, -2);  /* push metatable */
+  lua_rawset(L, -3);  /* metatable.__index = metatable */
+  luaL_openlib(L, NULL, flib, 0);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Other O.S. Operations
+** =======================================================
+*/
+
+static int io_execute (lua_State *L) {
+  lua_pushnumber(L, system(luaL_checkstring(L, 1)));
+  return 1;
+}
+
+
+static int io_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return pushresult(L, remove(filename) == 0, filename);
+}
+
+
+static int io_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return pushresult(L, rename(fromname, toname) == 0, fromname);
+}
+
+
+static int io_tmpname (lua_State *L) {
+#if !USE_TMPNAME
+  luaL_error(L, &quot;`tmpname' not supported&quot;);
+  return 0;
+#else
+  char buff[L_tmpnam];
+  if (tmpnam(buff) != buff)
+    return luaL_error(L, &quot;unable to generate a unique filename in `tmpname'&quot;);
+  lua_pushstring(L, buff);
+  return 1;
+#endif
+}
+
+
+static int io_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int io_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushnumber(L, value);
+  lua_rawset(L, -3);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  lua_pushstring(L, key);
+  lua_pushboolean(L, value);
+  lua_rawset(L, -3);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  res = lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res;
+  lua_pushstring(L, key);
+  lua_gettable(L, -2);
+  if (lua_isnumber(L, -1))
+    res = (int)(lua_tonumber(L, -1));
+  else {
+    if (d == -2)
+      return luaL_error(L, &quot;field `%s' missing in date table&quot;, key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int io_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, &quot;%c&quot;);
+  time_t t = (time_t)(luaL_optnumber(L, 2, -1));
+  struct tm *stm;
+  if (t == (time_t)(-1))  /* no time given? */
+    t = time(NULL);  /* use current time */
+  if (*s == '!') {  /* UTC? */
+    stm = gmtime(&amp;t);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = localtime(&amp;t);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, &quot;*t&quot;) == 0) {
+    lua_newtable(L);
+    setfield(L, &quot;sec&quot;, stm-&gt;tm_sec);
+    setfield(L, &quot;min&quot;, stm-&gt;tm_min);
+    setfield(L, &quot;hour&quot;, stm-&gt;tm_hour);
+    setfield(L, &quot;day&quot;, stm-&gt;tm_mday);
+    setfield(L, &quot;month&quot;, stm-&gt;tm_mon+1);
+    setfield(L, &quot;year&quot;, stm-&gt;tm_year+1900);
+    setfield(L, &quot;wday&quot;, stm-&gt;tm_wday+1);
+    setfield(L, &quot;yday&quot;, stm-&gt;tm_yday+1);
+    setboolfield(L, &quot;isdst&quot;, stm-&gt;tm_isdst);
+  }
+  else {
+    char b[256];
+    if (strftime(b, sizeof(b), s, stm))
+      lua_pushstring(L, b);
+    else
+      return luaL_error(L, &quot;`date' format too long&quot;);
+  }
+  return 1;
+}
+
+
+static int io_time (lua_State *L) {
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    lua_pushnumber(L, time(NULL));  /* return current time */
+  else {
+    time_t t;
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, &quot;sec&quot;, 0);
+    ts.tm_min = getfield(L, &quot;min&quot;, 0);
+    ts.tm_hour = getfield(L, &quot;hour&quot;, 12);
+    ts.tm_mday = getfield(L, &quot;day&quot;, -2);
+    ts.tm_mon = getfield(L, &quot;month&quot;, -2) - 1;
+    ts.tm_year = getfield(L, &quot;year&quot;, -2) - 1900;
+    ts.tm_isdst = getboolfield(L, &quot;isdst&quot;);
+    t = mktime(&amp;ts);
+    if (t == (time_t)(-1))
+      lua_pushnil(L);
+    else
+      lua_pushnumber(L, t);
+  }
+  return 1;
+}
+
+
+static int io_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int io_setloc (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {&quot;all&quot;, &quot;collate&quot;, &quot;ctype&quot;, &quot;monetary&quot;,
+     &quot;numeric&quot;, &quot;time&quot;, NULL};
+  const char *l = lua_tostring(L, 1);
+  int op = luaL_findstring(luaL_optstring(L, 2, &quot;all&quot;), catnames);
+  luaL_argcheck(L, l || lua_isnoneornil(L, 1), 1, &quot;string expected&quot;);
+  luaL_argcheck(L, op != -1, 2, &quot;invalid option&quot;);
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int io_exit (lua_State *L) {
+  exit(luaL_optint(L, 1, EXIT_SUCCESS));
+  return 0;  /* to avoid warnings */
+}
+
+static const luaL_reg syslib[] = {
+  {&quot;clock&quot;,     io_clock},
+  {&quot;date&quot;,      io_date},
+  {&quot;difftime&quot;,  io_difftime},
+  {&quot;execute&quot;,   io_execute},
+  {&quot;exit&quot;,      io_exit},
+  {&quot;getenv&quot;,    io_getenv},
+  {&quot;remove&quot;,    io_remove},
+  {&quot;rename&quot;,    io_rename},
+  {&quot;setlocale&quot;, io_setloc},
+  {&quot;time&quot;,      io_time},
+  {&quot;tmpname&quot;,   io_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaopen_io (lua_State *L) {
+  luaL_openlib(L, LUA_OSLIBNAME, syslib, 0);
+  createmeta(L);
+  lua_pushvalue(L, -1);
+  luaL_openlib(L, LUA_IOLIBNAME, iolib, 1);
+  /* put predefined file handles into `io' table */
+  registerfile(L, stdin, &quot;stdin&quot;, IO_INPUT);
+  registerfile(L, stdout, &quot;stdout&quot;, IO_OUTPUT);
+  registerfile(L, stderr, &quot;stderr&quot;, NULL);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/lmathlib.c
===================================================================
--- trunk/source/libraries/lua/lib/lmathlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lmathlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,246 @@
+/*
+** $Id: lmathlib.c,v 1.56 2003/03/11 12:30:37 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+#define lmathlib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+#undef PI
+#define PI (3.14159265358979323846)
+#define RADIANS_PER_DEGREE (PI/180.0)
+
+
+
+/*
+** If you want Lua to operate in degrees (instead of radians),
+** define USE_DEGREES
+*/
+#ifdef USE_DEGREES
+#define FROMRAD(a)	((a)/RADIANS_PER_DEGREE)
+#define TORAD(a)	((a)*RADIANS_PER_DEGREE)
+#else
+#define FROMRAD(a)	(a)
+#define TORAD(a)	(a)
+#endif
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, fabs(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, sin(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, cos(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, tan(TORAD(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(asin(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(acos(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan(luaL_checknumber(L, 1))));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, FROMRAD(atan2(luaL_checknumber(L, 1), luaL_checknumber(L, 2))));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, ceil(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, floor(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_mod (lua_State *L) {
+  lua_pushnumber(L, fmod(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, sqrt(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_pushnumber(L, pow(luaL_checknumber(L, 1), luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_pushnumber(L, log(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, log10(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, exp(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, frexp(luaL_checknumber(L, 1), &amp;e));
+  lua_pushnumber(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_pushnumber(L, ldexp(luaL_checknumber(L, 1), luaL_checkint(L, 2)));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i&lt;=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d &lt; dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i&lt;=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d &gt; dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      int u = luaL_checkint(L, 1);
+      luaL_argcheck(L, 1&lt;=u, 1, &quot;interval is empty&quot;);
+      lua_pushnumber(L, (int)floor(r*u)+1);  /* int between 1 and `u' */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      int l = luaL_checkint(L, 1);
+      int u = luaL_checkint(L, 2);
+      luaL_argcheck(L, l&lt;=u, 2, &quot;interval is empty&quot;);
+      lua_pushnumber(L, (int)floor(r*(u-l+1))+l);  /* int between `l' and `u' */
+      break;
+    }
+    default: return luaL_error(L, &quot;wrong number of arguments&quot;);
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkint(L, 1));
+  return 0;
+}
+
+
+static const luaL_reg mathlib[] = {
+  {&quot;abs&quot;,   math_abs},
+  {&quot;sin&quot;,   math_sin},
+  {&quot;cos&quot;,   math_cos},
+  {&quot;tan&quot;,   math_tan},
+  {&quot;asin&quot;,  math_asin},
+  {&quot;acos&quot;,  math_acos},
+  {&quot;atan&quot;,  math_atan},
+  {&quot;atan2&quot;, math_atan2},
+  {&quot;ceil&quot;,  math_ceil},
+  {&quot;floor&quot;, math_floor},
+  {&quot;mod&quot;,   math_mod},
+  {&quot;frexp&quot;, math_frexp},
+  {&quot;ldexp&quot;, math_ldexp},
+  {&quot;sqrt&quot;,  math_sqrt},
+  {&quot;min&quot;,   math_min},
+  {&quot;max&quot;,   math_max},
+  {&quot;log&quot;,   math_log},
+  {&quot;log10&quot;, math_log10},
+  {&quot;exp&quot;,   math_exp},
+  {&quot;deg&quot;,   math_deg},
+  {&quot;pow&quot;,   math_pow},
+  {&quot;rad&quot;,   math_rad},
+  {&quot;random&quot;,     math_random},
+  {&quot;randomseed&quot;, math_randomseed},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUALIB_API int luaopen_math (lua_State *L) {
+  luaL_openlib(L, LUA_MATHLIBNAME, mathlib, 0);
+  lua_pushliteral(L, &quot;pi&quot;);
+  lua_pushnumber(L, PI);
+  lua_settable(L, -3);
+  lua_pushliteral(L, &quot;__pow&quot;);
+  lua_pushcfunction(L, math_pow);
+  lua_settable(L, LUA_GLOBALSINDEX);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/loadlib.c
===================================================================
--- trunk/source/libraries/lua/lib/loadlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/loadlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,205 @@
+/*
+** $Id: loadlib.c,v 1.4 2003/04/07 20:11:53 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+*
+* This  Lua library  exports a  single function,  called loadlib,  which is
+* called from Lua  as loadlib(lib,init), where lib is the  full name of the
+* library to be  loaded (including the complete path) and  init is the name
+* of a function  to be called after the library  is loaded. Typically, this
+* function will register other functions,  thus making the complete library
+* available  to Lua.  The init  function is  *not* automatically  called by
+* loadlib. Instead,  loadlib returns  the init function  as a  Lua function
+* that the client  can call when it  thinks is appropriate. In  the case of
+* errors,  loadlib  returns  nil  and two  strings  describing  the  error.
+* The  first string  is  supplied by  the operating  system;  it should  be
+* informative and useful  for error messages. The second  string is &quot;open&quot;,
+* &quot;init&quot;, or  &quot;absent&quot; to identify  the error and is  meant to be  used for
+* making  decisions without  having to  look into  the first  string (whose
+* format is system-dependent).
+*
+* This module contains  an implementation of loadlib for  Unix systems that
+* have dlfcn, an implementation for Windows,  and a stub for other systems.
+* See  the list  at  the end  of  this  file for  some  links to  available
+* implementations of dlfcn  and interfaces to other  native dynamic loaders
+* on top of which loadlib could be implemented.
+*
+*/
+
+#include &quot;lua.h&quot;
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+#undef LOADLIB
+
+
+#ifdef USE_DLOPEN
+#define LOADLIB
+/*
+* This is an implementation of loadlib based on the dlfcn interface.
+* The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+* NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+* as an emulation layer on top of native functions.
+*/
+
+#include &lt;dlfcn.h&gt;
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ void *lib=dlopen(path,RTLD_NOW);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) dlsym(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ /* else return appropriate error messages */
+ lua_pushnil(L);
+ lua_pushstring(L,dlerror());
+ lua_pushstring(L,(lib!=NULL) ? &quot;init&quot; : &quot;open&quot;);
+ if (lib!=NULL) dlclose(lib);
+ return 3;
+}
+
+#endif
+
+
+
+/*
+** In Windows, default is to use dll; otherwise, default is not to use dll
+*/
+#ifndef USE_DLL
+#ifdef _WIN32
+#define USE_DLL	1
+#else
+#define USE_DLL	0
+#endif
+#endif
+
+
+#if USE_DLL
+#define LOADLIB
+/*
+* This is an implementation of loadlib for Windows using native functions.
+*/
+
+#include &lt;windows.h&gt;
+
+static void pusherror(lua_State *L)
+{
+ int error=GetLastError();
+ char buffer[128];
+ if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+	0, error, 0, buffer, sizeof(buffer), 0))
+  lua_pushstring(L,buffer);
+ else
+  lua_pushfstring(L,&quot;system error %d\n&quot;,error);
+}
+
+static int loadlib(lua_State *L)
+{
+ const char *path=luaL_checkstring(L,1);
+ const char *init=luaL_checkstring(L,2);
+ HINSTANCE lib=LoadLibrary(path);
+ if (lib!=NULL)
+ {
+  lua_CFunction f=(lua_CFunction) GetProcAddress(lib,init);
+  if (f!=NULL)
+  {
+   lua_pushlightuserdata(L,lib);
+   lua_pushcclosure(L,f,1);
+   return 1;
+  }
+ }
+ lua_pushnil(L);
+ pusherror(L);
+ lua_pushstring(L,(lib!=NULL) ? &quot;init&quot; : &quot;open&quot;);
+ if (lib!=NULL) FreeLibrary(lib);
+ return 3;
+}
+
+#endif
+
+
+
+#ifndef LOADLIB
+/* Fallback for other systems */
+
+/*
+** Those systems support dlopen, so they should have defined USE_DLOPEN.
+** The default (no)implementation gives them a special error message.
+*/
+#ifdef linux
+#define LOADLIB
+#endif
+
+#ifdef sun
+#define LOADLIB
+#endif
+
+#ifdef sgi
+#define LOADLIB
+#endif
+
+#ifdef BSD
+#define LOADLIB
+#endif
+
+#ifdef _WIN32
+#define LOADLIB
+#endif
+
+#ifdef LOADLIB
+#undef LOADLIB
+#define LOADLIB	&quot;`loadlib' not installed (check your Lua configuration)&quot;
+#else
+#define LOADLIB	&quot;`loadlib' not supported&quot;
+#endif
+
+static int loadlib(lua_State *L)
+{
+ lua_pushnil(L);
+ lua_pushliteral(L,LOADLIB);
+ lua_pushliteral(L,&quot;absent&quot;);
+ return 3;
+}
+#endif
+
+LUALIB_API int luaopen_loadlib (lua_State *L)
+{
+ lua_register(L,&quot;loadlib&quot;,loadlib);
+ return 0;
+}
+
+/*
+* Here are some links to available implementations of dlfcn and
+* interfaces to other native dynamic loaders on top of which loadlib
+* could be implemented. Please send contributions and corrections to us.
+*
+* AIX
+* Starting with AIX 4.2, dlfcn is included in the base OS.
+* There is also an emulation package available.
+* <A HREF="http://www.faqs.org/faqs/aix-faq/part4/section-21.html">http://www.faqs.org/faqs/aix-faq/part4/section-21.html</A>
+*
+* HPUX 
+* HPUX 11 has dlfcn. For HPUX 10 use shl_*.
+* <A HREF="http://www.geda.seul.org/mailinglist/geda-dev37/msg00094.html">http://www.geda.seul.org/mailinglist/geda-dev37/msg00094.html</A>
+* <A HREF="http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html">http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html</A>
+*
+* Macintosh, Windows
+* <A HREF="http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html">http://www.stat.umn.edu/~luke/xls/projects/dlbasics/dlbasics.html</A>
+*
+* Mac OS X/Darwin
+* <A HREF="http://www.opendarwin.org/projects/dlcompat/">http://www.opendarwin.org/projects/dlcompat/</A>
+*
+* GLIB has wrapper code for BeOS, OS2, Unix and Windows
+* <A HREF="http://cvs.gnome.org/lxr/source/glib/gmodule/">http://cvs.gnome.org/lxr/source/glib/gmodule/</A>
+*
+*/

Added: trunk/source/libraries/lua/lib/lstrlib.c
===================================================================
--- trunk/source/libraries/lua/lib/lstrlib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/lstrlib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,770 @@
+/*
+** $Id: lstrlib.c,v 1.98 2003/04/03 13:35:34 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;stddef.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define lstrlib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+/* macro to `unsign' a character */
+#ifndef uchar
+#define uchar(c)        ((unsigned char)(c))
+#endif
+
+
+typedef long sint32;	/* a signed version for size_t */
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &amp;l);
+  lua_pushnumber(L, (lua_Number)l);
+  return 1;
+}
+
+
+static sint32 posrelat (sint32 pos, size_t len) {
+  /* relative string position: negative means back from end */
+  return (pos&gt;=0) ? pos : (sint32)len+pos+1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  sint32 start = posrelat(luaL_checklong(L, 2), l);
+  sint32 end = posrelat(luaL_optlong(L, 3, -1), l);
+  if (start &lt; 1) start = 1;
+  if (end &gt; (sint32)l) end = (sint32)l;
+  if (start &lt;= end)
+    lua_pushlstring(L, s+start-1, end-start+1);
+  else lua_pushliteral(L, &quot;&quot;);
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  luaL_buffinit(L, &amp;b);
+  for (i=0; i&lt;l; i++)
+    luaL_putchar(&amp;b, tolower(uchar(s[i])));
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  luaL_buffinit(L, &amp;b);
+  for (i=0; i&lt;l; i++)
+    luaL_putchar(&amp;b, toupper(uchar(s[i])));
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+static int str_rep (lua_State *L) {
+  size_t l;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  int n = luaL_checkint(L, 2);
+  luaL_buffinit(L, &amp;b);
+  while (n-- &gt; 0)
+    luaL_addlstring(&amp;b, s, l);
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  sint32 pos = posrelat(luaL_optlong(L, 2, 1), l);
+  if (pos &lt;= 0 || (size_t)(pos) &gt; l)  /* index out of range? */
+    return 0;  /* no answer */
+  lua_pushnumber(L, uchar(s[pos-1]));
+  return 1;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  for (i=1; i&lt;=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, &quot;invalid value&quot;);
+    luaL_putchar(&amp;b, uchar(c));
+  }
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 1;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  luaL_buffinit(L,&amp;b);
+  if (!lua_dump(L, writer, &amp;b))
+    luaL_error(L, &quot;unable to dump given function&quot;);
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+#ifndef MAX_CAPTURES
+#define MAX_CAPTURES 32  /* arbitrary limit */
+#endif
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+typedef struct MatchState {
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end (`\0') of source string */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    sint32 len;
+  } capture[MAX_CAPTURES];
+} MatchState;
+
+
+#define ESC		'%'
+#define SPECIALS	&quot;^$*+?.([%-&quot;
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l &lt; 0 || l &gt;= ms-&gt;level || ms-&gt;capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms-&gt;level;
+  for (level--; level&gt;=0; level--)
+    if (ms-&gt;capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms-&gt;L, &quot;invalid pattern capture&quot;);
+}
+
+
+static const char *luaI_classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case ESC: {
+      if (*p == '\0')
+        luaL_error(ms-&gt;L, &quot;malformed pattern (ends with `%')&quot;);
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (*p == '\0')
+          luaL_error(ms-&gt;L, &quot;malformed pattern (missing `]')&quot;);
+        if (*(p++) == ESC &amp;&amp; *p != '\0')
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p &lt; ec) {
+    if (*p == ESC) {
+      p++;
+      if (match_class(c, *p))
+        return sig;
+    }
+    else if ((*(p+1) == '-') &amp;&amp; (p+2 &lt; ec)) {
+      p+=2;
+      if (uchar(*(p-2)) &lt;= c &amp;&amp; c &lt;= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int luaI_singlematch (int c, const char *p, const char *ep) {
+  switch (*p) {
+    case '.': return 1;  /* matches any char */
+    case ESC: return match_class(c, *(p+1));
+    case '[': return matchbracketclass(c, p, ep-1);
+    default:  return (uchar(*p) == c);
+  }
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (*p == 0 || *(p+1) == 0)
+    luaL_error(ms-&gt;L, &quot;unbalanced pattern&quot;);
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s &lt; ms-&gt;src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  sint32 i = 0;  /* counts maximum expand for item */
+  while ((s+i)&lt;ms-&gt;src_end &amp;&amp; luaI_singlematch(uchar(*(s+i)), p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i&gt;=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (s&lt;ms-&gt;src_end &amp;&amp; luaI_singlematch(uchar(*s), p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms-&gt;level;
+  if (level &gt;= MAX_CAPTURES) luaL_error(ms-&gt;L, &quot;too many captures&quot;);
+  ms-&gt;capture[level].init = s;
+  ms-&gt;capture[level].len = what;
+  ms-&gt;level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms-&gt;level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms-&gt;capture[l].len = s - ms-&gt;capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms-&gt;capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms-&gt;capture[l].len;
+  if ((size_t)(ms-&gt;src_end-s) &gt;= len &amp;&amp;
+      memcmp(ms-&gt;capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  init: /* using goto's to optimize tail recursion */
+  switch (*p) {
+    case '(': {  /* start capture */
+      if (*(p+1) == ')')  /* position capture? */
+        return start_capture(ms, s, p+2, CAP_POSITION);
+      else
+        return start_capture(ms, s, p+1, CAP_UNFINISHED);
+    }
+    case ')': {  /* end capture */
+      return end_capture(ms, s, p+1);
+    }
+    case ESC: {
+      switch (*(p+1)) {
+        case 'b': {  /* balanced string? */
+          s = matchbalance(ms, s, p+2);
+          if (s == NULL) return NULL;
+          p+=4; goto init;  /* else return match(ms, s, p+4); */
+        }
+        case 'f': {  /* frontier? */
+          const char *ep; char previous;
+          p += 2;
+          if (*p != '[')
+            luaL_error(ms-&gt;L, &quot;missing `[' after `%%f' in pattern&quot;);
+          ep = luaI_classend(ms, p);  /* points to what is next */
+          previous = (s == ms-&gt;src_init) ? '\0' : *(s-1);
+          if (matchbracketclass(uchar(previous), p, ep-1) ||
+             !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
+          p=ep; goto init;  /* else return match(ms, s, ep); */
+        }
+        default: {
+          if (isdigit(uchar(*(p+1)))) {  /* capture results (%0-%9)? */
+            s = match_capture(ms, s, *(p+1));
+            if (s == NULL) return NULL;
+            p+=2; goto init;  /* else return match(ms, s, p+2) */
+          }
+          goto dflt;  /* case default */
+        }
+      }
+    }
+    case '\0': {  /* end of pattern */
+      return s;  /* match succeeded */
+    }
+    case '$': {
+      if (*(p+1) == '\0')  /* is the `$' the last char in pattern? */
+        return (s == ms-&gt;src_end) ? s : NULL;  /* check end of string */
+      else goto dflt;
+    }
+    default: dflt: {  /* it is a pattern item */
+      const char *ep = luaI_classend(ms, p);  /* points to what is next */
+      int m = s&lt;ms-&gt;src_end &amp;&amp; luaI_singlematch(uchar(*s), p, ep);
+      switch (*ep) {
+        case '?': {  /* optional */
+          const char *res;
+          if (m &amp;&amp; ((res=match(ms, s+1, ep+1)) != NULL))
+            return res;
+          p=ep+1; goto init;  /* else return match(ms, s, ep+1); */
+        }
+        case '*': {  /* 0 or more repetitions */
+          return max_expand(ms, s, p, ep);
+        }
+        case '+': {  /* 1 or more repetitions */
+          return (m ? max_expand(ms, s+1, p, ep) : NULL);
+        }
+        case '-': {  /* 0 or more repetitions (minimum) */
+          return min_expand(ms, s, p, ep);
+        }
+        default: {
+          if (!m) return NULL;
+          s++; p=ep; goto init;  /* else return match(ms, s+1, ep); */
+        }
+      }
+    }
+  }
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 &gt; l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 &gt; 0 &amp;&amp; (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i) {
+  int l = ms-&gt;capture[i].len;
+  if (l == CAP_UNFINISHED) luaL_error(ms-&gt;L, &quot;unfinished capture&quot;);
+  if (l == CAP_POSITION)
+    lua_pushnumber(ms-&gt;L, (lua_Number)(ms-&gt;capture[i].init - ms-&gt;src_init + 1));
+  else
+    lua_pushlstring(ms-&gt;L, ms-&gt;capture[i].init, l);
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  luaL_checkstack(ms-&gt;L, ms-&gt;level, &quot;too many captures&quot;);
+  if (ms-&gt;level == 0 &amp;&amp; s) {  /* no explicit captures? */
+    lua_pushlstring(ms-&gt;L, s, e-s);  /* return whole match */
+    return 1;
+  }
+  else {  /* return all captures */
+    for (i=0; i&lt;ms-&gt;level; i++)
+      push_onecapture(ms, i);
+    return ms-&gt;level;  /* number of strings pushed */
+  }
+}
+
+
+static int str_find (lua_State *L) {
+  size_t l1, l2;
+  const char *s = luaL_checklstring(L, 1, &amp;l1);
+  const char *p = luaL_checklstring(L, 2, &amp;l2);
+  sint32 init = posrelat(luaL_optlong(L, 3, 1), l1) - 1;
+  if (init &lt; 0) init = 0;
+  else if ((size_t)(init) &gt; l1) init = (sint32)l1;
+  if (lua_toboolean(L, 4) ||  /* explicit request? */
+      strpbrk(p, SPECIALS) == NULL) {  /* or no special characters? */
+    /* do a plain search */
+    const char *s2 = lmemfind(s+init, l1-init, p, l2);
+    if (s2) {
+      lua_pushnumber(L, (lua_Number)(s2-s+1));
+      lua_pushnumber(L, (lua_Number)(s2-s+l2));
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    int anchor = (*p == '^') ? (p++, 1) : 0;
+    const char *s1=s+init;
+    ms.L = L;
+    ms.src_init = s;
+    ms.src_end = s+l1;
+    do {
+      const char *res;
+      ms.level = 0;
+      if ((res=match(&amp;ms, s1, p)) != NULL) {
+        lua_pushnumber(L, (lua_Number)(s1-s+1));  /* start */
+        lua_pushnumber(L, (lua_Number)(res-s));   /* end */
+        return push_captures(&amp;ms, NULL, 0) + 2;
+      }
+    } while (s1++&lt;ms.src_end &amp;&amp; !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int gfind_aux (lua_State *L) {
+  MatchState ms;
+  const char *s = lua_tostring(L, lua_upvalueindex(1));
+  size_t ls = lua_strlen(L, lua_upvalueindex(1));
+  const char *p = lua_tostring(L, lua_upvalueindex(2));
+  const char *src;
+  ms.L = L;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  for (src = s + (size_t)lua_tonumber(L, lua_upvalueindex(3));
+       src &lt;= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    if ((e = match(&amp;ms, src, p)) != NULL) {
+      int newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushnumber(L, (lua_Number)newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&amp;ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gfind (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushnumber(L, 0);
+  lua_pushcclosure(L, gfind_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b,
+                   const char *s, const char *e) {
+  lua_State *L = ms-&gt;L;
+  if (lua_isstring(L, 3)) {
+    const char *news = lua_tostring(L, 3);
+    size_t l = lua_strlen(L, 3);
+    size_t i;
+    for (i=0; i&lt;l; i++) {
+      if (news[i] != ESC)
+        luaL_putchar(b, news[i]);
+      else {
+        i++;  /* skip ESC */
+        if (!isdigit(uchar(news[i])))
+          luaL_putchar(b, news[i]);
+        else {
+          int level = check_capture(ms, news[i]);
+          push_onecapture(ms, level);
+          luaL_addvalue(b);  /* add capture to accumulated result */
+        }
+      }
+    }
+  }
+  else {  /* is a function */
+    int n;
+    lua_pushvalue(L, 3);
+    n = push_captures(ms, s, e);
+    lua_call(L, n, 1);
+    if (lua_isstring(L, -1))
+      luaL_addvalue(b);  /* add return to accumulated result */
+    else
+      lua_pop(L, 1);  /* function result is not a string: pop it */
+  }
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl;
+  const char *src = luaL_checklstring(L, 1, &amp;srcl);
+  const char *p = luaL_checkstring(L, 2);
+  int max_s = luaL_optint(L, 4, srcl+1);
+  int anchor = (*p == '^') ? (p++, 1) : 0;
+  int n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L,
+    lua_gettop(L) &gt;= 3 &amp;&amp; (lua_isstring(L, 3) || lua_isfunction(L, 3)),
+    3, &quot;string or function expected&quot;);
+  luaL_buffinit(L, &amp;b);
+  ms.L = L;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  while (n &lt; max_s) {
+    const char *e;
+    ms.level = 0;
+    e = match(&amp;ms, src, p);
+    if (e) {
+      n++;
+      add_s(&amp;ms, &amp;b, src, e);
+    }
+    if (e &amp;&amp; e&gt;src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src &lt; ms.src_end)
+      luaL_putchar(&amp;b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&amp;b, src, ms.src_end-src);
+  luaL_pushresult(&amp;b);
+  lua_pushnumber(L, (lua_Number)n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+/* maximum size of each formatted item (&gt; len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* maximum size of each format specification (such as '%-099.99d') */
+#define MAX_FORMAT	20
+
+
+static void luaI_addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &amp;l);
+  luaL_putchar(b, '&quot;');
+  while (l--) {
+    switch (*s) {
+      case '&quot;': case '\\': case '\n': {
+        luaL_putchar(b, '\\');
+        luaL_putchar(b, *s);
+        break;
+      }
+      case '\0': {
+        luaL_addlstring(b, &quot;\\000&quot;, 4);
+        break;
+      }
+      default: {
+        luaL_putchar(b, *s);
+        break;
+      }
+    }
+    s++;
+  }
+  luaL_putchar(b, '&quot;');
+}
+
+
+static const char *scanformat (lua_State *L, const char *strfrmt,
+                                 char *form, int *hasprecision) {
+  const char *p = strfrmt;
+  while (strchr(&quot;-+ #0&quot;, *p)) p++;  /* skip flags */
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    *hasprecision = 1;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, &quot;invalid format (width or precision too long)&quot;);
+  if (p-strfrmt+2 &gt; MAX_FORMAT)  /* +2 to include `%' and the specifier */
+    luaL_error(L, &quot;invalid format (too long)&quot;);
+  form[0] = '%';
+  strncpy(form+1, strfrmt, p-strfrmt+1);
+  form[p-strfrmt+2] = 0;
+  return p;
+}
+
+
+static int str_format (lua_State *L) {
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &amp;sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &amp;b);
+  while (strfrmt &lt; strfrmt_end) {
+    if (*strfrmt != '%')
+      luaL_putchar(&amp;b, *strfrmt++);
+    else if (*++strfrmt == '%')
+      luaL_putchar(&amp;b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char buff[MAX_ITEM];  /* to store the formatted item */
+      int hasprecision = 0;
+      if (isdigit(uchar(*strfrmt)) &amp;&amp; *(strfrmt+1) == '$')
+        return luaL_error(L, &quot;obsolete option (d$) to `format'&quot;);
+      arg++;
+      strfrmt = scanformat(L, strfrmt, form, &amp;hasprecision);
+      switch (*strfrmt++) {
+        case 'c':  case 'd':  case 'i': {
+          sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'o':  case 'u':  case 'x':  case 'X': {
+          sprintf(buff, form, (unsigned int)(luaL_checknumber(L, arg)));
+          break;
+        }
+        case 'e':  case 'E': case 'f':
+        case 'g': case 'G': {
+          sprintf(buff, form, luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          luaI_addquoted(L, &amp;b, arg);
+          continue;  /* skip the `addsize' at the end */
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_checklstring(L, arg, &amp;l);
+          if (!hasprecision &amp;&amp; l &gt;= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            lua_pushvalue(L, arg);
+            luaL_addvalue(&amp;b);
+            continue;  /* skip the `addsize' at the end */
+          }
+          else {
+            sprintf(buff, form, s);
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, &quot;invalid option to `format'&quot;);
+        }
+      }
+      luaL_addlstring(&amp;b, buff, strlen(buff));
+    }
+  }
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+static const luaL_reg strlib[] = {
+  {&quot;len&quot;, str_len},
+  {&quot;sub&quot;, str_sub},
+  {&quot;lower&quot;, str_lower},
+  {&quot;upper&quot;, str_upper},
+  {&quot;char&quot;, str_char},
+  {&quot;rep&quot;, str_rep},
+  {&quot;byte&quot;, str_byte},
+  {&quot;format&quot;, str_format},
+  {&quot;dump&quot;, str_dump},
+  {&quot;find&quot;, str_find},
+  {&quot;gfind&quot;, gfind},
+  {&quot;gsub&quot;, str_gsub},
+  {NULL, NULL}
+};
+
+
+/*
+** Open string library
+*/
+LUALIB_API int luaopen_string (lua_State *L) {
+  luaL_openlib(L, LUA_STRLIBNAME, strlib, 0);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/lib/ltablib.c
===================================================================
--- trunk/source/libraries/lua/lib/ltablib.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lib/ltablib.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,250 @@
+/*
+** $Id: ltablib.c,v 1.21 2003/04/03 13:35:34 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stddef.h&gt;
+
+#define ltablib_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lauxlib.h&quot;
+#include &quot;lualib.h&quot;
+
+
+#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_getn(L, n))
+
+
+static int luaB_foreachi (lua_State *L) {
+  int i;
+  int n = aux_getn(L, 1);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  for (i=1; i&lt;=n; i++) {
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushnumber(L, (lua_Number)i);  /* 1st argument */
+    lua_rawgeti(L, 1, i);  /* 2nd argument */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 1);  /* remove nil result */
+  }
+  return 0;
+}
+
+
+static int luaB_foreach (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_pushnil(L);  /* first key */
+  for (;;) {
+    if (lua_next(L, 1) == 0)
+      return 0;
+    lua_pushvalue(L, 2);  /* function */
+    lua_pushvalue(L, -3);  /* key */
+    lua_pushvalue(L, -3);  /* value */
+    lua_call(L, 2, 1);
+    if (!lua_isnil(L, -1))
+      return 1;
+    lua_pop(L, 2);  /* remove value and result */
+  }
+}
+
+
+static int luaB_getn (lua_State *L) {
+  lua_pushnumber(L, (lua_Number)aux_getn(L, 1));
+  return 1;
+}
+
+
+static int luaB_setn (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_setn(L, 1, luaL_checkint(L, 2));
+  return 0;
+}
+
+
+static int luaB_tinsert (lua_State *L) {
+  int v = lua_gettop(L);  /* number of arguments */
+  int n = aux_getn(L, 1) + 1;
+  int pos;  /* where to insert new element */
+  if (v == 2)  /* called with only 2 arguments */
+    pos = n;  /* insert new element at the end */
+  else {
+    pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+    if (pos &gt; n) n = pos;  /* `grow' array if necessary */
+    v = 3;  /* function may be called with more than 3 args */
+  }
+  luaL_setn(L, 1, n);  /* new size */
+  while (--n &gt;= pos) {  /* move up elements */
+    lua_rawgeti(L, 1, n);
+    lua_rawseti(L, 1, n+1);  /* t[n+1] = t[n] */
+  }
+  lua_pushvalue(L, v);
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int luaB_tremove (lua_State *L) {
+  int n = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, n);
+  if (n &lt;= 0) return 0;  /* table is `empty' */
+  luaL_setn(L, 1, n-1);  /* t.n = n-1 */
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ;pos&lt;n; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, n);  /* t[n] = nil */
+  return 1;
+}
+
+
+static int str_concat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  const char *sep = luaL_optlstring(L, 2, &quot;&quot;, &amp;lsep);
+  int i = luaL_optint(L, 3, 1);
+  int n = luaL_optint(L, 4, 0);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (n == 0) n = luaL_getn(L, 1);
+  luaL_buffinit(L, &amp;b);
+  for (; i &lt;= n; i++) {
+    lua_rawgeti(L, 1, i);
+    luaL_argcheck(L, lua_isstring(L, -1), 1, &quot;table contains non-strings&quot;);
+    luaL_addvalue(&amp;b);
+    if (i != n)
+      luaL_addlstring(&amp;b, sep, lsep);
+  }
+  luaL_pushresult(&amp;b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a &lt; b? */
+    return lua_lessthan(L, a, b);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l &lt; u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] &lt; a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]&lt;a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]&lt;a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] &lt;= P == a[u-1] &lt;= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] &lt;= P &lt;= a[j..u] */
+      /* repeat ++i until a[i] &gt;= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i&gt;u) luaL_error(L, &quot;invalid order function for sorting&quot;);
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] &lt;= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j&lt;l) luaL_error(L, &quot;invalid order function for sorting&quot;);
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j&lt;i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] &lt;= a[i] == P &lt;= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l &lt; u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int luaB_sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, &quot;&quot;);  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_reg tab_funcs[] = {
+  {&quot;concat&quot;, str_concat},
+  {&quot;foreach&quot;, luaB_foreach},
+  {&quot;foreachi&quot;, luaB_foreachi},
+  {&quot;getn&quot;, luaB_getn},
+  {&quot;setn&quot;, luaB_setn},
+  {&quot;sort&quot;, luaB_sort},
+  {&quot;insert&quot;, luaB_tinsert},
+  {&quot;remove&quot;, luaB_tremove},
+  {NULL, NULL}
+};
+
+
+LUALIB_API int luaopen_table (lua_State *L) {
+  luaL_openlib(L, LUA_TABLIBNAME, tab_funcs, 0);
+  return 1;
+}
+

Added: trunk/source/libraries/lua/llex.c
===================================================================
--- trunk/source/libraries/lua/llex.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/llex.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,417 @@
+/*
+** $Id: llex.c,v 1.119 2003/03/24 12:39:34 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;string.h&gt;
+
+#define llex_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldo.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;lzio.h&quot;
+
+
+
+#define next(LS) (LS-&gt;current = zgetc(LS-&gt;z))
+
+
+
+/* ORDER RESERVED */
+static const char *const token2string [] = {
+    &quot;and&quot;, &quot;break&quot;, &quot;do&quot;, &quot;else&quot;, &quot;elseif&quot;,
+    &quot;end&quot;, &quot;false&quot;, &quot;for&quot;, &quot;function&quot;, &quot;if&quot;,
+    &quot;in&quot;, &quot;local&quot;, &quot;nil&quot;, &quot;not&quot;, &quot;or&quot;, &quot;repeat&quot;,
+    &quot;return&quot;, &quot;then&quot;, &quot;true&quot;, &quot;until&quot;, &quot;while&quot;, &quot;*name&quot;,
+    &quot;..&quot;, &quot;...&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;~=&quot;,
+    &quot;*number&quot;, &quot;*string&quot;, &quot;&lt;eof&gt;&quot;
+};
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i&lt;NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, token2string[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    lua_assert(strlen(token2string[i])+1 &lt;= TOKEN_LEN);
+    ts-&gt;tsv.reserved = cast(lu_byte, i+1);  /* reserved word */
+  }
+}
+
+
+#define MAXSRC          80
+
+
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg) {
+  if (val &gt; limit) {
+    msg = luaO_pushfstring(ls-&gt;L, &quot;too many %s (limit=%d)&quot;, msg, limit);
+    luaX_syntaxerror(ls, msg);
+  }
+}
+
+
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line) {
+  lua_State *L = ls-&gt;L;
+  char buff[MAXSRC];
+  luaO_chunkid(buff, getstr(ls-&gt;source), MAXSRC);
+  luaO_pushfstring(L, &quot;%s:%d: %s near `%s'&quot;, buff, line, s, token); 
+  luaD_throw(L, LUA_ERRSYNTAX);
+}
+
+
+static void luaX_error (LexState *ls, const char *s, const char *token) {
+  luaX_errorline(ls, s, token, ls-&gt;linenumber);
+}
+
+
+void luaX_syntaxerror (LexState *ls, const char *msg) {
+  const char *lasttoken;
+  switch (ls-&gt;t.token) {
+    case TK_NAME:
+      lasttoken = getstr(ls-&gt;t.seminfo.ts);
+      break;
+    case TK_STRING:
+    case TK_NUMBER:
+      lasttoken = luaZ_buffer(ls-&gt;buff);
+      break;
+    default:
+      lasttoken = luaX_token2str(ls, ls-&gt;t.token);
+      break;
+  }
+  luaX_error(ls, msg, lasttoken);
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token &lt; FIRST_RESERVED) {
+    lua_assert(token == (unsigned char)token);
+    return luaO_pushfstring(ls-&gt;L, &quot;%c&quot;, token);
+  }
+  else
+    return token2string[token-FIRST_RESERVED];
+}
+
+
+static void luaX_lexerror (LexState *ls, const char *s, int token) {
+  if (token == TK_EOS)
+    luaX_error(ls, s, luaX_token2str(ls, token));
+  else
+    luaX_error(ls, s, luaZ_buffer(ls-&gt;buff));
+}
+
+
+static void inclinenumber (LexState *LS) {
+  next(LS);  /* skip `\n' */
+  ++LS-&gt;linenumber;
+  luaX_checklimit(LS, LS-&gt;linenumber, MAX_INT, &quot;lines in a chunk&quot;);
+}
+
+
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source) {
+  LS-&gt;L = L;
+  LS-&gt;lookahead.token = TK_EOS;  /* no look-ahead token */
+  LS-&gt;z = z;
+  LS-&gt;fs = NULL;
+  LS-&gt;linenumber = 1;
+  LS-&gt;lastline = 1;
+  LS-&gt;source = source;
+  next(LS);  /* read first char */
+  if (LS-&gt;current == '#') {
+    do {  /* skip first line */
+      next(LS);
+    } while (LS-&gt;current != '\n' &amp;&amp; LS-&gt;current != EOZ);
+  }
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+/* use buffer to store names, literal strings and numbers */
+
+/* extra space to allocate when growing buffer */
+#define EXTRABUFF	32
+
+/* maximum number of chars that can be read without checking buffer size */
+#define MAXNOCHECK	5
+
+#define checkbuffer(LS, len)	\
+    if (((len)+MAXNOCHECK)*sizeof(char) &gt; luaZ_sizebuffer((LS)-&gt;buff)) \
+      luaZ_openspace((LS)-&gt;L, (LS)-&gt;buff, (len)+EXTRABUFF)
+
+#define save(LS, c, l) \
+	(luaZ_buffer((LS)-&gt;buff)[l++] = cast(char, c))
+#define save_and_next(LS, l)  (save(LS, LS-&gt;current, l), next(LS))
+
+
+static size_t readname (LexState *LS) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  do {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  } while (isalnum(LS-&gt;current) || LS-&gt;current == '_');
+  save(LS, '\0', l);
+  return l-1;
+}
+
+
+/* LUA_NUMBER */
+static void read_numeral (LexState *LS, int comma, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  if (comma) save(LS, '.', l);
+  while (isdigit(LS-&gt;current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS-&gt;current == '.') {
+    save_and_next(LS, l);
+    if (LS-&gt;current == '.') {
+      save_and_next(LS, l);
+      save(LS, '\0', l);
+      luaX_lexerror(LS,
+                 &quot;ambiguous syntax (decimal point x string concatenation)&quot;,
+                 TK_NUMBER);
+    }
+  }
+  while (isdigit(LS-&gt;current)) {
+    checkbuffer(LS, l);
+    save_and_next(LS, l);
+  }
+  if (LS-&gt;current == 'e' || LS-&gt;current == 'E') {
+    save_and_next(LS, l);  /* read `E' */
+    if (LS-&gt;current == '+' || LS-&gt;current == '-')
+      save_and_next(LS, l);  /* optional exponent sign */
+    while (isdigit(LS-&gt;current)) {
+      checkbuffer(LS, l);
+      save_and_next(LS, l);
+    }
+  }
+  save(LS, '\0', l);
+  if (!luaO_str2d(luaZ_buffer(LS-&gt;buff), &amp;seminfo-&gt;r))
+    luaX_lexerror(LS, &quot;malformed number&quot;, TK_NUMBER);
+}
+
+
+static void read_long_string (LexState *LS, SemInfo *seminfo) {
+  int cont = 0;
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save(LS, '[', l);  /* save first `[' */
+  save_and_next(LS, l);  /* pass the second `[' */
+  if (LS-&gt;current == '\n')  /* string starts with a newline? */
+    inclinenumber(LS);  /* skip it */
+  for (;;) {
+    checkbuffer(LS, l);
+    switch (LS-&gt;current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, (seminfo) ? &quot;unfinished long string&quot; :
+                                   &quot;unfinished long comment&quot;, TK_EOS);
+        break;  /* to avoid warnings */
+      case '[':
+        save_and_next(LS, l);
+        if (LS-&gt;current == '[') {
+          cont++;
+          save_and_next(LS, l);
+        }
+        continue;
+      case ']':
+        save_and_next(LS, l);
+        if (LS-&gt;current == ']') {
+          if (cont == 0) goto endloop;
+          cont--;
+          save_and_next(LS, l);
+        }
+        continue;
+      case '\n':
+        save(LS, '\n', l);
+        inclinenumber(LS);
+        if (!seminfo) l = 0;  /* reset buffer to avoid wasting space */
+        continue;
+      default:
+        save_and_next(LS, l);
+    }
+  } endloop:
+  save_and_next(LS, l);  /* skip the second `]' */
+  save(LS, '\0', l);
+  if (seminfo)
+    seminfo-&gt;ts = luaS_newlstr(LS-&gt;L, luaZ_buffer(LS-&gt;buff) + 2, l - 5);
+}
+
+
+static void read_string (LexState *LS, int del, SemInfo *seminfo) {
+  size_t l = 0;
+  checkbuffer(LS, l);
+  save_and_next(LS, l);
+  while (LS-&gt;current != del) {
+    checkbuffer(LS, l);
+    switch (LS-&gt;current) {
+      case EOZ:
+        save(LS, '\0', l);
+        luaX_lexerror(LS, &quot;unfinished string&quot;, TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+        save(LS, '\0', l);
+        luaX_lexerror(LS, &quot;unfinished string&quot;, TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\':
+        next(LS);  /* do not save the `\' */
+        switch (LS-&gt;current) {
+          case 'a': save(LS, '\a', l); next(LS); break;
+          case 'b': save(LS, '\b', l); next(LS); break;
+          case 'f': save(LS, '\f', l); next(LS); break;
+          case 'n': save(LS, '\n', l); next(LS); break;
+          case 'r': save(LS, '\r', l); next(LS); break;
+          case 't': save(LS, '\t', l); next(LS); break;
+          case 'v': save(LS, '\v', l); next(LS); break;
+          case '\n': save(LS, '\n', l); inclinenumber(LS); break;
+          case EOZ: break;  /* will raise an error next loop */
+          default: {
+            if (!isdigit(LS-&gt;current))
+              save_and_next(LS, l);  /* handles \\, \&quot;, \', and \? */
+            else {  /* \xxx */
+              int c = 0;
+              int i = 0;
+              do {
+                c = 10*c + (LS-&gt;current-'0');
+                next(LS);
+              } while (++i&lt;3 &amp;&amp; isdigit(LS-&gt;current));
+              if (c &gt; UCHAR_MAX) {
+                save(LS, '\0', l);
+                luaX_lexerror(LS, &quot;escape sequence too large&quot;, TK_STRING);
+              }
+              save(LS, c, l);
+            }
+          }
+        }
+        break;
+      default:
+        save_and_next(LS, l);
+    }
+  }
+  save_and_next(LS, l);  /* skip delimiter */
+  save(LS, '\0', l);
+  seminfo-&gt;ts = luaS_newlstr(LS-&gt;L, luaZ_buffer(LS-&gt;buff) + 1, l - 3);
+}
+
+
+int luaX_lex (LexState *LS, SemInfo *seminfo) {
+  for (;;) {
+    switch (LS-&gt;current) {
+
+      case '\n': {
+        inclinenumber(LS);
+        continue;
+      }
+      case '-': {
+        next(LS);
+        if (LS-&gt;current != '-') return '-';
+        /* else is a comment */
+        next(LS);
+        if (LS-&gt;current == '[' &amp;&amp; (next(LS), LS-&gt;current == '['))
+          read_long_string(LS, NULL);  /* long comment */
+        else  /* short comment */
+          while (LS-&gt;current != '\n' &amp;&amp; LS-&gt;current != EOZ)
+            next(LS);
+        continue;
+      }
+      case '[': {
+        next(LS);
+        if (LS-&gt;current != '[') return '[';
+        else {
+          read_long_string(LS, seminfo);
+          return TK_STRING;
+        }
+      }
+      case '=': {
+        next(LS);
+        if (LS-&gt;current != '=') return '=';
+        else { next(LS); return TK_EQ; }
+      }
+      case '&lt;': {
+        next(LS);
+        if (LS-&gt;current != '=') return '&lt;';
+        else { next(LS); return TK_LE; }
+      }
+      case '&gt;': {
+        next(LS);
+        if (LS-&gt;current != '=') return '&gt;';
+        else { next(LS); return TK_GE; }
+      }
+      case '~': {
+        next(LS);
+        if (LS-&gt;current != '=') return '~';
+        else { next(LS); return TK_NE; }
+      }
+      case '&quot;':
+      case '\'': {
+        read_string(LS, LS-&gt;current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {
+        next(LS);
+        if (LS-&gt;current == '.') {
+          next(LS);
+          if (LS-&gt;current == '.') {
+            next(LS);
+            return TK_DOTS;   /* ... */
+          }
+          else return TK_CONCAT;   /* .. */
+        }
+        else if (!isdigit(LS-&gt;current)) return '.';
+        else {
+          read_numeral(LS, 1, seminfo);
+          return TK_NUMBER;
+        }
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (isspace(LS-&gt;current)) {
+          next(LS);
+          continue;
+        }
+        else if (isdigit(LS-&gt;current)) {
+          read_numeral(LS, 0, seminfo);
+          return TK_NUMBER;
+        }
+        else if (isalpha(LS-&gt;current) || LS-&gt;current == '_') {
+          /* identifier or reserved word */
+          size_t l = readname(LS);
+          TString *ts = luaS_newlstr(LS-&gt;L, luaZ_buffer(LS-&gt;buff), l);
+          if (ts-&gt;tsv.reserved &gt; 0)  /* reserved word? */
+            return ts-&gt;tsv.reserved - 1 + FIRST_RESERVED;
+          seminfo-&gt;ts = ts;
+          return TK_NAME;
+        }
+        else {
+          int c = LS-&gt;current;
+          if (iscntrl(c))
+            luaX_error(LS, &quot;invalid control char&quot;,
+                           luaO_pushfstring(LS-&gt;L, &quot;char(%d)&quot;, c));
+          next(LS);
+          return c;  /* single-char tokens (+ - / ...) */
+        }
+      }
+    }
+  }
+}
+
+#undef next

Added: trunk/source/libraries/lua/llex.h
===================================================================
--- trunk/source/libraries/lua/llex.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/llex.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,75 @@
+/*
+** $Id: llex.h,v 1.47 2003/02/28 17:19:47 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include &quot;lobject.h&quot;
+#include &quot;lzio.h&quot;
+
+
+#define FIRST_RESERVED	257
+
+/* maximum length of a reserved word */
+#define TOKEN_LEN	(sizeof(&quot;function&quot;)/sizeof(char))
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep &quot;ORDER RESERVED&quot;
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_NAME, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,
+  TK_STRING, TK_EOS
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* `FuncState' is private to the parser */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  TString *source;  /* current source name */
+  int nestlevel;  /* level of nested non-terminals */
+} LexState;
+
+
+void luaX_init (lua_State *L);
+void luaX_setinput (lua_State *L, LexState *LS, ZIO *z, TString *source);
+int luaX_lex (LexState *LS, SemInfo *seminfo);
+void luaX_checklimit (LexState *ls, int val, int limit, const char *msg);
+void luaX_syntaxerror (LexState *ls, const char *s);
+void luaX_errorline (LexState *ls, const char *s, const char *token, int line);
+const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif

Added: trunk/source/libraries/lua/llimits.h
===================================================================
--- trunk/source/libraries/lua/llimits.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/llimits.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,185 @@
+/*
+** $Id: llimits.h,v 1.52 2003/02/20 19:33:23 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include &lt;limits.h&gt;
+#include &lt;stddef.h&gt;
+
+
+#include &quot;lua.h&quot;
+
+
+/*
+** try to find number of bits in an integer
+*/
+#ifndef BITS_INT
+/* avoid overflows in comparison */
+#if INT_MAX-20 &lt; 32760
+#define	BITS_INT	16
+#else
+#if INT_MAX &gt; 2147483640L
+/* machine has at least 32 bits */
+#define BITS_INT	32
+#else
+#error &quot;you must define BITS_INT with number of bits in an integer&quot;
+#endif
+#endif
+#endif
+
+
+/*
+** the following types define integer types for values that may not
+** fit in a `small int' (16 bits), but may waste space in a
+** `large long' (64 bits). The current definitions should work in
+** any machine, but may not be optimal.
+*/
+
+/* an unsigned integer to hold hash values */
+typedef unsigned int lu_hash;
+/* its signed equivalent */
+typedef int ls_hash;
+
+/* an unsigned integer big enough to count the total memory used by Lua; */
+/* it should be at least as large as size_t */
+typedef unsigned long lu_mem;
+
+#define MAX_LUMEM	ULONG_MAX
+
+
+/* an integer big enough to count the number of strings in use */
+typedef long ls_nstr;
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((lu_hash)(p))
+
+
+
+/* type to ensure maximum alignment */
+#ifndef LUSER_ALIGNMENT_T
+typedef union { double u; void *s; long l; } L_Umaxalign;
+#else
+typedef LUSER_ALIGNMENT_T L_Umaxalign;
+#endif
+
+
+/* result of `usual argument conversion' over lua_Number */
+#ifndef LUA_UACNUMBER
+typedef double l_uacNumber;
+#else
+typedef LUA_UACNUMBER l_uacNumber;
+#endif
+
+
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+#ifndef check_exp
+#define check_exp(c,e)	(e)
+#endif
+
+
+#ifndef UNUSED
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#ifndef cast
+#define cast(t, exp)	((t)(exp))
+#endif
+
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef unsigned long Instruction;
+
+
+/* maximum depth for calls (unsigned short) */
+#ifndef LUA_MAXCALLS
+#define LUA_MAXCALLS        4096
+#endif
+
+
+/*
+** maximum depth for C calls (unsigned short): Not too big, or may
+** overflow the C stack...
+*/
+
+#ifndef LUA_MAXCCALLS
+#define LUA_MAXCCALLS        200
+#endif
+
+
+/* maximum size for the C stack */
+#ifndef LUA_MAXCSTACK
+#define LUA_MAXCSTACK        2048
+#endif
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+/* maximum number of variables declared in a function */
+#ifndef MAXVARS
+#define MAXVARS 200           /* arbitrary limit (&lt;MAXSTACK) */
+#endif
+
+
+/* maximum number of upvalues per function */
+#ifndef MAXUPVALUES
+#define MAXUPVALUES	32
+#endif
+
+
+/* maximum number of parameters in a function */
+#ifndef MAXPARAMS
+#define MAXPARAMS 100           /* arbitrary limit (&lt;MAXLOCALS) */
+#endif
+
+
+/* minimum size for the string table (must be power of 2) */
+#ifndef MINSTRTABSIZE
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#ifndef LUA_MINBUFFER
+#define LUA_MINBUFFER	32
+#endif
+
+
+/*
+** maximum number of syntactical nested non-terminals: Not too big,
+** or may overflow the C stack...
+*/
+#ifndef LUA_MAXPARSERLEVEL
+#define LUA_MAXPARSERLEVEL	200
+#endif
+
+
+#endif

Added: trunk/source/libraries/lua/lmem.c
===================================================================
--- trunk/source/libraries/lua/lmem.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lmem.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,91 @@
+/*
+** $Id: lmem.c,v 1.61 2002/12/04 17:38:31 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lmem_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+
+
+
+/*
+** definition for realloc function. It must assure that l_realloc(NULL,
+** 0, x) allocates a new block (ANSI C assures that). (`os' is the old
+** block size; some allocators may use that.)
+*/
+#ifndef l_realloc
+#define l_realloc(b,os,s)	realloc(b,s)
+#endif
+
+/*
+** definition for free function. (`os' is the old block size; some
+** allocators may use that.)
+*/
+#ifndef l_free
+#define l_free(b,os)	free(b)
+#endif
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elems,
+                    int limit, const char *errormsg) {
+  void *newblock;
+  int newsize = (*size)*2;
+  if (newsize &lt; MINSIZEARRAY)
+    newsize = MINSIZEARRAY;  /* minimum size */
+  else if (*size &gt;= limit/2) {  /* cannot double it? */
+    if (*size &lt; limit - MINSIZEARRAY)  /* try something smaller... */
+      newsize = limit;  /* still have at least MINSIZEARRAY free places */
+    else luaG_runerror(L, errormsg);
+  }
+  newblock = luaM_realloc(L, block,
+                          cast(lu_mem, *size)*cast(lu_mem, size_elems),
+                          cast(lu_mem, newsize)*cast(lu_mem, size_elems));
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc (lua_State *L, void *block, lu_mem oldsize, lu_mem size) {
+  lua_assert((oldsize == 0) == (block == NULL));
+  if (size == 0) {
+    if (block != NULL) {
+      l_free(block, oldsize);
+      block = NULL;
+    }
+    else return NULL;  /* avoid `nblocks' computations when oldsize==size==0 */
+  }
+  else if (size &gt;= MAX_SIZET)
+    luaG_runerror(L, &quot;memory allocation error: block too big&quot;);
+  else {
+    block = l_realloc(block, oldsize, size);
+    if (block == NULL) {
+      if (L)
+        luaD_throw(L, LUA_ERRMEM);
+      else return NULL;  /* error before creating state! */
+    }
+  }
+  if (L) {
+    lua_assert(G(L) != NULL &amp;&amp; G(L)-&gt;nblocks &gt; 0);
+    G(L)-&gt;nblocks -= oldsize;
+    G(L)-&gt;nblocks += size;
+  }
+  return block;
+}
+

Added: trunk/source/libraries/lua/lmem.h
===================================================================
--- trunk/source/libraries/lua/lmem.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lmem.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,44 @@
+/*
+** $Id: lmem.h,v 1.26 2002/05/01 20:40:42 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include &lt;stddef.h&gt;
+
+#include &quot;llimits.h&quot;
+#include &quot;lua.h&quot;
+
+#define MEMERRMSG	&quot;not enough memory&quot;
+
+
+void *luaM_realloc (lua_State *L, void *oldblock, lu_mem oldsize, lu_mem size);
+
+void *luaM_growaux (lua_State *L, void *block, int *size, int size_elem,
+                    int limit, const char *errormsg);
+
+#define luaM_free(L, b, s)	luaM_realloc(L, (b), (s), 0)
+#define luaM_freelem(L, b)	luaM_realloc(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n, t)	luaM_realloc(L, (b), \
+                                      cast(lu_mem, n)*cast(lu_mem, sizeof(t)), 0)
+
+#define luaM_malloc(L, t)	luaM_realloc(L, NULL, 0, (t))
+#define luaM_new(L, t)          cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L, n,t)  cast(t *, luaM_malloc(L, \
+                                         cast(lu_mem, n)*cast(lu_mem, sizeof(t))))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if (((nelems)+1) &gt; (size)) \
+            ((v)=cast(t *, luaM_growaux(L,v,&amp;(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_realloc(L, v,cast(lu_mem, oldn)*cast(lu_mem, sizeof(t)), \
+                                    cast(lu_mem, n)*cast(lu_mem, sizeof(t)))))
+
+
+#endif
+

Added: trunk/source/libraries/lua/lobject.c
===================================================================
--- trunk/source/libraries/lua/lobject.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lobject.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,195 @@
+/*
+** $Id: lobject.c,v 1.97 2003/04/03 13:35:34 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include &lt;ctype.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define lobject_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldo.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;lvm.h&quot;
+
+
+/* function to convert a string to a lua_Number */
+#ifndef lua_str2number
+#define lua_str2number(s,p)     strtod((s), (p))
+#endif
+
+
+const TObject luaO_nilobject = {LUA_TNIL, {NULL}};
+
+
+/*
+** converts an integer to a &quot;floating point byte&quot;, represented as
+** (mmmmmxxx), where the real value is (xxx) * 2^(mmmmm)
+*/
+int luaO_int2fb (unsigned int x) {
+  int m = 0;  /* mantissa */
+  while (x &gt;= (1&lt;&lt;3)) {
+    x = (x+1) &gt;&gt; 1;
+    m++;
+  }
+  return (m &lt;&lt; 3) | cast(int, x);
+}
+
+
+int luaO_log2 (unsigned int x) {
+  static const lu_byte log_8[255] = {
+    0,
+    1,1,
+    2,2,2,2,
+    3,3,3,3,3,3,3,3,
+    4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
+    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
+  };
+  if (x &gt;= 0x00010000) {
+    if (x &gt;= 0x01000000) return log_8[((x&gt;&gt;24) &amp; 0xff) - 1]+24;
+    else return log_8[((x&gt;&gt;16) &amp; 0xff) - 1]+16;
+  }
+  else {
+    if (x &gt;= 0x00000100) return log_8[((x&gt;&gt;8) &amp; 0xff) - 1]+8;
+    else if (x) return log_8[(x &amp; 0xff) - 1];
+    return -1;  /* special `log' for 0 */
+  }
+}
+
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2) {
+  if (ttype(t1) != ttype(t2)) return 0;
+  else switch (ttype(t1)) {
+    case LUA_TNIL:
+      return 1;
+    case LUA_TNUMBER:
+      return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN:
+      return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
+    case LUA_TLIGHTUSERDATA:
+      return pvalue(t1) == pvalue(t2);
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+}
+
+
+int luaO_str2d (const char *s, lua_Number *result) {
+  char *endptr;
+  lua_Number res = lua_str2number(s, &amp;endptr);
+  if (endptr == s) return 0;  /* no conversion */
+  while (isspace((unsigned char)(*endptr))) endptr++;
+  if (*endptr != '\0') return 0;  /* invalid trailing characters? */
+  *result = res;
+  return 1;
+}
+
+
+
+static void pushstr (lua_State *L, const char *str) {
+  setsvalue2s(L-&gt;top, luaS_new(L, str));
+  incr_top(L);
+}
+
+
+/* this function handles only `%d', `%c', %f, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 1;
+  pushstr(L, &quot;&quot;);
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    setsvalue2s(L-&gt;top, luaS_newlstr(L, fmt, e-fmt));
+    incr_top(L);
+    switch (*(e+1)) {
+      case 's':
+        pushstr(L, va_arg(argp, char *));
+        break;
+      case 'c': {
+        char buff[2];
+        buff[0] = cast(char, va_arg(argp, int));
+        buff[1] = '\0';
+        pushstr(L, buff);
+        break;
+      }
+      case 'd':
+        setnvalue(L-&gt;top, cast(lua_Number, va_arg(argp, int)));
+        incr_top(L);
+        break;
+      case 'f':
+        setnvalue(L-&gt;top, cast(lua_Number, va_arg(argp, l_uacNumber)));
+        incr_top(L);
+        break;
+      case '%':
+        pushstr(L, &quot;%&quot;);
+        break;
+      default: lua_assert(0);
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  pushstr(L, fmt);
+  luaV_concat(L, n+1, L-&gt;top - L-&gt;base - 1);
+  L-&gt;top -= n;
+  return svalue(L-&gt;top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+void luaO_chunkid (char *out, const char *source, int bufflen) {
+  if (*source == '=') {
+    strncpy(out, source+1, bufflen);  /* remove first char */
+    out[bufflen-1] = '\0';  /* ensures null termination */
+  }
+  else {  /* out = &quot;source&quot;, or &quot;...source&quot; */
+    if (*source == '@') {
+      int l;
+      source++;  /* skip the `@' */
+      bufflen -= sizeof(&quot; `...' &quot;);
+      l = strlen(source);
+      strcpy(out, &quot;&quot;);
+      if (l&gt;bufflen) {
+        source += (l-bufflen);  /* get last part of file name */
+        strcat(out, &quot;...&quot;);
+      }
+      strcat(out, source);
+    }
+    else {  /* out = [string &quot;string&quot;] */
+      int len = strcspn(source, &quot;\n&quot;);  /* stop at first newline */
+      bufflen -= sizeof(&quot; [string \&quot;...\&quot;] &quot;);
+      if (len &gt; bufflen) len = bufflen;
+      strcpy(out, &quot;[string \&quot;&quot;);
+      if (source[len] != '\0') {  /* must truncate? */
+        strncat(out, source, len);
+        strcat(out, &quot;...&quot;);
+      }
+      else
+        strcat(out, source);
+      strcat(out, &quot;\&quot;]&quot;);
+    }
+  }
+}

Added: trunk/source/libraries/lua/lobject.h
===================================================================
--- trunk/source/libraries/lua/lobject.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lobject.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,336 @@
+/*
+** $Id: lobject.h,v 1.159 2003/03/18 12:50:04 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include &quot;llimits.h&quot;
+#include &quot;lua.h&quot;
+
+
+/* tags for values visible from Lua */
+#define NUM_TAGS	LUA_TTHREAD
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	(NUM_TAGS+1)
+#define LUA_TUPVAL	(NUM_TAGS+2)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union {
+  GCObject *gc;
+  void *p;
+  lua_Number n;
+  int b;
+} Value;
+
+
+/*
+** Lua values (or `tagged objects')
+*/
+typedef struct lua_TObject {
+  int tt;
+  Value value;
+} TObject;
+
+
+/* Macros to test type */
+#define ttisnil(o)	(ttype(o) == LUA_TNIL)
+#define ttisnumber(o)	(ttype(o) == LUA_TNUMBER)
+#define ttisstring(o)	(ttype(o) == LUA_TSTRING)
+#define ttistable(o)	(ttype(o) == LUA_TTABLE)
+#define ttisfunction(o)	(ttype(o) == LUA_TFUNCTION)
+#define ttisboolean(o)	(ttype(o) == LUA_TBOOLEAN)
+#define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)
+#define ttisthread(o)	(ttype(o) == LUA_TTHREAD)
+#define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)
+
+/* Macros to access values */
+#define ttype(o)	((o)-&gt;tt)
+#define gcvalue(o)	check_exp(iscollectable(o), (o)-&gt;value.gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), (o)-&gt;value.p)
+#define nvalue(o)	check_exp(ttisnumber(o), (o)-&gt;value.n)
+#define tsvalue(o)	check_exp(ttisstring(o), &amp;(o)-&gt;value.gc-&gt;ts)
+#define uvalue(o)	check_exp(ttisuserdata(o), &amp;(o)-&gt;value.gc-&gt;u)
+#define clvalue(o)	check_exp(ttisfunction(o), &amp;(o)-&gt;value.gc-&gt;cl)
+#define hvalue(o)	check_exp(ttistable(o), &amp;(o)-&gt;value.gc-&gt;h)
+#define bvalue(o)	check_exp(ttisboolean(o), (o)-&gt;value.b)
+#define thvalue(o)	check_exp(ttisthread(o), &amp;(o)-&gt;value.gc-&gt;th)
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) &amp;&amp; bvalue(o) == 0))
+
+/* Macros to set values */
+#define setnvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TNUMBER; i_o-&gt;value.n=(x); }
+
+#define chgnvalue(obj,x) \
+	check_exp(ttype(obj)==LUA_TNUMBER, (obj)-&gt;value.n=(x))
+
+#define setpvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TLIGHTUSERDATA; i_o-&gt;value.p=(x); }
+
+#define setbvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TBOOLEAN; i_o-&gt;value.b=(x); }
+
+#define setsvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TSTRING; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TSTRING); }
+
+#define setuvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TUSERDATA; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TUSERDATA); }
+
+#define setthvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TTHREAD; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TTHREAD); }
+
+#define setclvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TFUNCTION; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TFUNCTION); }
+
+#define sethvalue(obj,x) \
+  { TObject *i_o=(obj); i_o-&gt;tt=LUA_TTABLE; \
+    i_o-&gt;value.gc=cast(GCObject *, (x)); \
+    lua_assert(i_o-&gt;value.gc-&gt;gch.tt == LUA_TTABLE); }
+
+#define setnilvalue(obj) ((obj)-&gt;tt=LUA_TNIL)
+
+
+
+/*
+** for internal debug only
+*/
+#define checkconsistency(obj) \
+  lua_assert(!iscollectable(obj) || (ttype(obj) == (obj)-&gt;value.gc-&gt;gch.tt))
+
+
+#define setobj(obj1,obj2) \
+  { const TObject *o2=(obj2); TObject *o1=(obj1); \
+    checkconsistency(o2); \
+    o1-&gt;tt=o2-&gt;tt; o1-&gt;value = o2-&gt;value; }
+
+
+/*
+** different types of sets, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+#define setttype(obj, tt) (ttype(obj) = (tt))
+
+
+#define iscollectable(o)	(ttype(o) &gt;= LUA_TSTRING)
+
+
+
+typedef TObject *StkId;  /* index to stack elements */
+
+
+/*
+** String headers for string table
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte reserved;
+    lu_hash hash;
+    size_t len;
+  } tsv;
+} TString;
+
+
+#define getstr(ts)	cast(const char *, (ts) + 1)
+#define svalue(o)       getstr(tsvalue(o))
+
+
+
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    size_t len;
+  } uv;
+} Udata;
+
+
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TObject *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines */
+  struct LocVar *locvars;  /* information about local variables */
+  TString **upvalues;  /* upvalue names */
+  TString  *source;
+  int sizeupvalues;
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int lineDefined;
+  GCObject *gclist;
+  lu_byte nups;  /* number of upvalues */
+  lu_byte numparams;
+  lu_byte is_vararg;
+  lu_byte maxstacksize;
+} Proto;
+
+
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+
+/*
+** Upvalues
+*/
+
+typedef struct UpVal {
+  CommonHeader;
+  TObject *v;  /* points to stack or to its own value */
+  TObject value;  /* the value (when closed) */
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte isC; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TObject upvalue[1];
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  TObject g;  /* global table for this closure */
+  UpVal *upvals[1];
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION &amp;&amp; clvalue(o)-&gt;c.isC)
+#define isLfunction(o)	(ttype(o) == LUA_TFUNCTION &amp;&amp; !clvalue(o)-&gt;c.isC)
+
+
+/*
+** Tables
+*/
+
+typedef struct Node {
+  TObject i_key;
+  TObject i_val;
+  struct Node *next;  /* for chaining */
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1&lt;&lt;p means tagmethod(p) is not present */ 
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TObject *array;  /* array part */
+  Node *node;
+  Node *firstfree;  /* this position is free; all positions after it are full */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	check_exp((size&amp;(size-1))==0, (cast(int, (s) &amp; ((size)-1))))
+
+
+#define twoto(x)	(1&lt;&lt;(x))
+#define sizenode(t)	(twoto((t)-&gt;lsizenode))
+
+
+
+extern const TObject luaO_nilobject;
+
+int luaO_log2 (unsigned int x);
+int luaO_int2fb (unsigned int x);
+#define fb2int(x)	(((x) &amp; 7) &lt;&lt; ((x) &gt;&gt; 3))
+
+int luaO_rawequalObj (const TObject *t1, const TObject *t2);
+int luaO_str2d (const char *s, lua_Number *result);
+
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp);
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+void luaO_chunkid (char *out, const char *source, int len);
+
+
+#endif

Added: trunk/source/libraries/lua/lopcodes.c
===================================================================
--- trunk/source/libraries/lua/lopcodes.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lopcodes.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,102 @@
+/*
+** $Id: lopcodes.c,v 1.22 2002/12/04 17:38:31 roberto Exp $
+** extracted automatically from lopcodes.h by mkprint.lua
+** DO NOT EDIT
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+
+
+#ifdef LUA_OPNAMES
+
+const char *const luaP_opnames[] = {
+  &quot;MOVE&quot;,
+  &quot;LOADK&quot;,
+  &quot;LOADBOOL&quot;,
+  &quot;LOADNIL&quot;,
+  &quot;GETUPVAL&quot;,
+  &quot;GETGLOBAL&quot;,
+  &quot;GETTABLE&quot;,
+  &quot;SETGLOBAL&quot;,
+  &quot;SETUPVAL&quot;,
+  &quot;SETTABLE&quot;,
+  &quot;NEWTABLE&quot;,
+  &quot;SELF&quot;,
+  &quot;ADD&quot;,
+  &quot;SUB&quot;,
+  &quot;MUL&quot;,
+  &quot;DIV&quot;,
+  &quot;POW&quot;,
+  &quot;UNM&quot;,
+  &quot;NOT&quot;,
+  &quot;CONCAT&quot;,
+  &quot;JMP&quot;,
+  &quot;EQ&quot;,
+  &quot;LT&quot;,
+  &quot;LE&quot;,
+  &quot;TEST&quot;,
+  &quot;CALL&quot;,
+  &quot;TAILCALL&quot;,
+  &quot;RETURN&quot;,
+  &quot;FORLOOP&quot;,
+  &quot;TFORLOOP&quot;,
+  &quot;TFORPREP&quot;,
+  &quot;SETLIST&quot;,
+  &quot;SETLISTO&quot;,
+  &quot;CLOSE&quot;,
+  &quot;CLOSURE&quot;
+};
+
+#endif
+
+#define opmode(t,b,bk,ck,sa,k,m) (((t)&lt;&lt;OpModeT) | \
+   ((b)&lt;&lt;OpModeBreg) | ((bk)&lt;&lt;OpModeBrk) | ((ck)&lt;&lt;OpModeCrk) | \
+   ((sa)&lt;&lt;OpModesetA) | ((k)&lt;&lt;OpModeK) | (m))
+
+
+const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  B Bk Ck sA  K  mode			   opcode    */
+  opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_MOVE */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_LOADK */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 0, 0, 0, 1, 1, iABx)		/* OP_GETGLOBAL */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, 0, 0, 0, 1, iABx)		/* OP_SETGLOBAL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, 1, 1, 0, 0, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_SELF */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_ADD */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_SUB */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_MUL */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_DIV */
+ ,opmode(0, 0, 1, 1, 1, 0, iABC)		/* OP_POW */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_UNM */
+ ,opmode(0, 1, 0, 0, 1, 0, iABC)		/* OP_NOT */
+ ,opmode(0, 1, 0, 1, 1, 0, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_EQ */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LT */
+ ,opmode(1, 0, 1, 1, 0, 0, iABC)		/* OP_LE */
+ ,opmode(1, 1, 0, 0, 1, 0, iABC)		/* OP_TEST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_RETURN */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_FORLOOP */
+ ,opmode(1, 0, 0, 0, 0, 0, iABC)		/* OP_TFORLOOP */
+ ,opmode(0, 0, 0, 0, 0, 0, iAsBx)		/* OP_TFORPREP */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLIST */
+ ,opmode(0, 0, 0, 0, 0, 0, iABx)		/* OP_SETLISTO */
+ ,opmode(0, 0, 0, 0, 0, 0, iABC)		/* OP_CLOSE */
+ ,opmode(0, 0, 0, 0, 1, 0, iABx)		/* OP_CLOSURE */
+};
+

Added: trunk/source/libraries/lua/lopcodes.h
===================================================================
--- trunk/source/libraries/lua/lopcodes.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lopcodes.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,238 @@
+/*
+** $Id: lopcodes.h,v 1.102 2002/08/21 18:56:09 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include &quot;llimits.h&quot;
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+
+#define SIZE_OP		6
+
+#define POS_C		SIZE_OP
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_A		(POS_B + SIZE_B)
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in BITS_INT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx &lt; BITS_INT-1
+#define MAXARG_Bx        ((1&lt;&lt;SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx&gt;&gt;1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1&lt;&lt;SIZE_A)-1)
+#define MAXARG_B        ((1&lt;&lt;SIZE_B)-1)
+#define MAXARG_C        ((1&lt;&lt;SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)&lt;&lt;n))&lt;&lt;p)
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, (i)&amp;MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&amp;MASK0(SIZE_OP,0)) | cast(Instruction, o)))
+
+#define GETARG_A(i)	(cast(int, (i)&gt;&gt;POS_A))
+#define SETARG_A(i,u)	((i) = (((i)&amp;MASK0(SIZE_A,POS_A)) | \
+		((cast(Instruction, u)&lt;&lt;POS_A)&amp;MASK1(SIZE_A,POS_A))))
+
+#define GETARG_B(i)	(cast(int, ((i)&gt;&gt;POS_B) &amp; MASK1(SIZE_B,0)))
+#define SETARG_B(i,b)	((i) = (((i)&amp;MASK0(SIZE_B,POS_B)) | \
+		((cast(Instruction, b)&lt;&lt;POS_B)&amp;MASK1(SIZE_B,POS_B))))
+
+#define GETARG_C(i)	(cast(int, ((i)&gt;&gt;POS_C) &amp; MASK1(SIZE_C,0)))
+#define SETARG_C(i,b)	((i) = (((i)&amp;MASK0(SIZE_C,POS_C)) | \
+		((cast(Instruction, b)&lt;&lt;POS_C)&amp;MASK1(SIZE_C,POS_C))))
+
+#define GETARG_Bx(i)	(cast(int, ((i)&gt;&gt;POS_Bx) &amp; MASK1(SIZE_Bx,0)))
+#define SETARG_Bx(i,b)	((i) = (((i)&amp;MASK0(SIZE_Bx,POS_Bx)) | \
+		((cast(Instruction, b)&lt;&lt;POS_Bx)&amp;MASK1(SIZE_Bx,POS_Bx))))
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	(cast(Instruction, o) \
+			| (cast(Instruction, a)&lt;&lt;POS_A) \
+			| (cast(Instruction, b)&lt;&lt;POS_B) \
+			| (cast(Instruction, c)&lt;&lt;POS_C))
+
+#define CREATE_ABx(o,a,bc)	(cast(Instruction, o) \
+			| (cast(Instruction, a)&lt;&lt;POS_A) \
+			| (cast(Instruction, bc)&lt;&lt;POS_Bx))
+
+
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if x &lt; MAXSTACK then R(x) else Kst(x-MAXSTACK)
+*/
+
+
+/*
+** grep &quot;ORDER OP&quot; if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) PC++			*/
+OP_LOADNIL,/*	A B	R(A) := ... := R(B) := nil			*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETGLOBAL,/*	A Bx	R(A) := Gbl[Kst(Bx)]				*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETGLOBAL,/*	A Bx	Gbl[Kst(Bx)] := R(A)				*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	sBx	PC += sBx					*/
+
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) &lt;  RK(C)) ~= A) then pc++  		*/
+OP_LE,/*	A B C	if ((RK(B) &lt;= RK(C)) ~= A) then pc++  		*/
+
+OP_TEST,/*	A B C	if (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++	*/ 
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2); if R(A) &lt;?= R(A+1) then PC+= sBx	*/
+
+OP_TFORLOOP,/*	A C	R(A+2), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); 
+                        if R(A+2) ~= nil then pc++			*/
+OP_TFORPREP,/*	A sBx	if type(R(A)) == table then R(A+1):=R(A), R(A):=next;
+			PC += sBx					*/
+
+OP_SETLIST,/*	A Bx	R(A)[Bx-Bx%FPF+i] := R(A+i), 1 &lt;= i &lt;= Bx%FPF+1	*/
+OP_SETLISTO,/*	A Bx							*/
+
+OP_CLOSE,/*	A 	close all variables in the stack up to (&gt;=) R(A)*/
+OP_CLOSURE/*	A Bx	R(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_CLOSURE+1))
+
+
+
+/*===========================================================================
+  Notes:
+  (1) In OP_CALL, if (B == 0) then B = top. C is the number of returns - 1,
+      and can be 0: OP_CALL then sets `top' to last_result+1, so
+      next open instruction (OP_CALL, OP_RETURN, OP_SETLIST) may use `top'.
+
+  (2) In OP_RETURN, if (B == 0) then return up to `top'
+
+  (3) For comparisons, B specifies what conditions the test should accept.
+
+  (4) All `skips' (pc++) assume that next instruction is a jump
+===========================================================================*/
+
+
+/*
+** masks for instruction properties
+*/  
+enum OpModeMask {
+  OpModeBreg = 2,       /* B is a register */
+  OpModeBrk,		/* B is a register/constant */
+  OpModeCrk,           /* C is a register/constant */
+  OpModesetA,           /* instruction set register A */
+  OpModeK,              /* Bx is a constant */
+  OpModeT		/* operator is a test */
+  
+};
+
+
+extern const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)            (cast(enum OpMode, luaP_opmodes[m] &amp; 3))
+#define testOpMode(m, b)        (luaP_opmodes[m] &amp; (1 &lt;&lt; (b)))
+
+
+#ifdef LUA_OPNAMES
+extern const char *const luaP_opnames[];  /* opcode names */
+#endif
+
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+/* (must be a power of 2) */
+#define LFIELDS_PER_FLUSH	32
+
+
+#endif

Added: trunk/source/libraries/lua/lparser.c
===================================================================
--- trunk/source/libraries/lua/lparser.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lparser.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,1329 @@
+/*
+** $Id: lparser.c,v 1.208 2003/04/03 13:35:34 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define lparser_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lparser.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+
+
+
+
+#define getlocvar(fs, i)	((fs)-&gt;f-&gt;locvars[(fs)-&gt;actvar[i]])
+
+
+#define enterlevel(ls)	if (++(ls)-&gt;nestlevel &gt; LUA_MAXPARSERLEVEL) \
+		luaX_syntaxerror(ls, &quot;too many syntax levels&quot;);
+#define leavelevel(ls)	((ls)-&gt;nestlevel--)
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  int breaklist;  /* list of jumps out of this loop */
+  int nactvar;  /* # active local variables outside the breakable structure */
+  int upval;  /* true if some variable in the block is an upvalue */
+  int isbreakable;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void chunk (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+
+static void next (LexState *ls) {
+  ls-&gt;lastline = ls-&gt;linenumber;
+  if (ls-&gt;lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls-&gt;t = ls-&gt;lookahead;  /* use this one */
+    ls-&gt;lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls-&gt;t.token = luaX_lex(ls, &amp;ls-&gt;t.seminfo);  /* read next token */
+}
+
+
+static void lookahead (LexState *ls) {
+  lua_assert(ls-&gt;lookahead.token == TK_EOS);
+  ls-&gt;lookahead.token = luaX_lex(ls, &amp;ls-&gt;lookahead.seminfo);
+}
+
+
+static void error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+         luaO_pushfstring(ls-&gt;L, &quot;`%s' expected&quot;, luaX_token2str(ls, token)));
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls-&gt;t.token == c) {
+    next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (!testnext(ls, c))
+    error_expected(ls, c);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls-&gt;linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls-&gt;L,
+             &quot;`%s' expected (to close `%s' at line %d)&quot;,
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check_condition(ls, (ls-&gt;t.token == TK_NAME), &quot;&lt;name&gt; expected&quot;);
+  ts = ls-&gt;t.seminfo.ts;
+  next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e-&gt;f = e-&gt;t = NO_JUMP;
+  e-&gt;k = k;
+  e-&gt;info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls-&gt;fs, s));
+}
+
+
+static void checkname(LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int luaI_registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls-&gt;fs;
+  Proto *f = fs-&gt;f;
+  luaM_growvector(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,
+                  LocVar, MAX_INT, &quot;&quot;);
+  f-&gt;locvars[fs-&gt;nlocvars].varname = varname;
+  return fs-&gt;nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name, int n) {
+  FuncState *fs = ls-&gt;fs;
+  luaX_checklimit(ls, fs-&gt;nactvar+n+1, MAXVARS, &quot;local variables&quot;);
+  fs-&gt;actvar[fs-&gt;nactvar+n] = luaI_registerlocalvar(ls, name);
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls-&gt;fs;
+  fs-&gt;nactvar += nvars;
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs-&gt;nactvar - nvars).startpc = fs-&gt;pc;
+  }
+}
+
+
+static void removevars (LexState *ls, int tolevel) {
+  FuncState *fs = ls-&gt;fs;
+  while (fs-&gt;nactvar &gt; tolevel)
+    getlocvar(fs, --fs-&gt;nactvar).endpc = fs-&gt;pc;
+}
+
+
+static void new_localvarstr (LexState *ls, const char *name, int n) {
+  new_localvar(ls, luaS_new(ls-&gt;L, name), n);
+}
+
+
+static void create_local (LexState *ls, const char *name) {
+  new_localvarstr(ls, name, 0);
+  adjustlocalvars(ls, 1);
+}
+
+
+static int indexupvalue (FuncState *fs, TString *name, expdesc *v) {
+  int i;
+  Proto *f = fs-&gt;f;
+  for (i=0; i&lt;f-&gt;nups; i++) {
+    if (fs-&gt;upvalues[i].k == v-&gt;k &amp;&amp; fs-&gt;upvalues[i].info == v-&gt;info) {
+      lua_assert(fs-&gt;f-&gt;upvalues[i] == name);
+      return i;
+    }
+  }
+  /* new one */
+  luaX_checklimit(fs-&gt;ls, f-&gt;nups + 1, MAXUPVALUES, &quot;upvalues&quot;);
+  luaM_growvector(fs-&gt;L, fs-&gt;f-&gt;upvalues, f-&gt;nups, fs-&gt;f-&gt;sizeupvalues,
+                  TString *, MAX_INT, &quot;&quot;);
+  fs-&gt;f-&gt;upvalues[f-&gt;nups] = name;
+  fs-&gt;upvalues[f-&gt;nups] = *v;
+  return f-&gt;nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i=fs-&gt;nactvar-1; i &gt;= 0; i--) {
+    if (n == getlocvar(fs, i).varname)
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs-&gt;bl;
+  while (bl &amp;&amp; bl-&gt;nactvar &gt; level) bl = bl-&gt;previous;
+  if (bl) bl-&gt;upval = 1;
+}
+
+
+static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    init_exp(var, VGLOBAL, NO_REG);  /* default is global variable */
+  else {
+    int v = searchvar(fs, n);  /* look up at current level */
+    if (v &gt;= 0) {
+      init_exp(var, VLOCAL, v);
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+    }
+    else {  /* not found at current level; try upper one */
+      singlevaraux(fs-&gt;prev, n, var, 0);
+      if (var-&gt;k == VGLOBAL) {
+        if (base)
+          var-&gt;info = luaK_stringK(fs, n);  /* info points to global name */
+      }
+      else {  /* LOCAL or UPVAL */
+        var-&gt;info = indexupvalue(fs, n, var);
+        var-&gt;k = VUPVAL;  /* upvalue in this level */
+      }
+    }
+  }
+}
+
+
+static TString *singlevar (LexState *ls, expdesc *var, int base) {
+  TString *varname = str_checkname(ls);
+  singlevaraux(ls-&gt;fs, varname, var, base);
+  return varname;
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls-&gt;fs;
+  int extra = nvars - nexps;
+  if (e-&gt;k == VCALL) {
+    extra++;  /* includes call itself */
+    if (extra &lt;= 0) extra = 0;
+    else luaK_reserveregs(fs, extra-1);
+    luaK_setcallreturns(fs, e, extra);  /* call provides the difference */
+  }
+  else {
+    if (e-&gt;k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra &gt; 0) {
+      int reg = fs-&gt;freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void code_params (LexState *ls, int nparams, int dots) {
+  FuncState *fs = ls-&gt;fs;
+  adjustlocalvars(ls, nparams);
+  luaX_checklimit(ls, fs-&gt;nactvar, MAXPARAMS, &quot;parameters&quot;);
+  fs-&gt;f-&gt;numparams = cast(lu_byte, fs-&gt;nactvar);
+  fs-&gt;f-&gt;is_vararg = cast(lu_byte, dots);
+  if (dots)
+    create_local(ls, &quot;arg&quot;);
+  luaK_reserveregs(fs, fs-&gt;nactvar);  /* reserve register for parameters */
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, int isbreakable) {
+  bl-&gt;breaklist = NO_JUMP;
+  bl-&gt;isbreakable = isbreakable;
+  bl-&gt;nactvar = fs-&gt;nactvar;
+  bl-&gt;upval = 0;
+  bl-&gt;previous = fs-&gt;bl;
+  fs-&gt;bl = bl;
+  lua_assert(fs-&gt;freereg == fs-&gt;nactvar);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs-&gt;bl;
+  fs-&gt;bl = bl-&gt;previous;
+  removevars(fs-&gt;ls, bl-&gt;nactvar);
+  if (bl-&gt;upval)
+    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
+  lua_assert(bl-&gt;nactvar == fs-&gt;nactvar);
+  fs-&gt;freereg = fs-&gt;nactvar;  /* free registers */
+  luaK_patchtohere(fs, bl-&gt;breaklist);
+}
+
+
+static void pushclosure (LexState *ls, FuncState *func, expdesc *v) {
+  FuncState *fs = ls-&gt;fs;
+  Proto *f = fs-&gt;f;
+  int i;
+  luaM_growvector(ls-&gt;L, f-&gt;p, fs-&gt;np, f-&gt;sizep, Proto *,
+                  MAXARG_Bx, &quot;constant table overflow&quot;);
+  f-&gt;p[fs-&gt;np++] = func-&gt;f;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs-&gt;np-1));
+  for (i=0; i&lt;func-&gt;f-&gt;nups; i++) {
+    OpCode o = (func-&gt;upvalues[i].k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, o, 0, func-&gt;upvalues[i].info, 0);
+  }
+}
+
+
+static void open_func (LexState *ls, FuncState *fs) {
+  Proto *f = luaF_newproto(ls-&gt;L);
+  fs-&gt;f = f;
+  fs-&gt;prev = ls-&gt;fs;  /* linked list of funcstates */
+  fs-&gt;ls = ls;
+  fs-&gt;L = ls-&gt;L;
+  ls-&gt;fs = fs;
+  fs-&gt;pc = 0;
+  fs-&gt;lasttarget = 0;
+  fs-&gt;jpc = NO_JUMP;
+  fs-&gt;freereg = 0;
+  fs-&gt;nk = 0;
+  fs-&gt;h = luaH_new(ls-&gt;L, 0, 0);
+  fs-&gt;np = 0;
+  fs-&gt;nlocvars = 0;
+  fs-&gt;nactvar = 0;
+  fs-&gt;bl = NULL;
+  f-&gt;source = ls-&gt;source;
+  f-&gt;maxstacksize = 2;  /* registers 0/1 are always valid */
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls-&gt;L;
+  FuncState *fs = ls-&gt;fs;
+  Proto *f = fs-&gt;f;
+  removevars(ls, 0);
+  luaK_codeABC(fs, OP_RETURN, 0, 1, 0);  /* final return */
+  luaM_reallocvector(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, Instruction);
+  f-&gt;sizecode = fs-&gt;pc;
+  luaM_reallocvector(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, int);
+  f-&gt;sizelineinfo = fs-&gt;pc;
+  luaM_reallocvector(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, TObject);
+  f-&gt;sizek = fs-&gt;nk;
+  luaM_reallocvector(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, Proto *);
+  f-&gt;sizep = fs-&gt;np;
+  luaM_reallocvector(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, LocVar);
+  f-&gt;sizelocvars = fs-&gt;nlocvars;
+  luaM_reallocvector(L, f-&gt;upvalues, f-&gt;sizeupvalues, f-&gt;nups, TString *);
+  f-&gt;sizeupvalues = f-&gt;nups;
+  lua_assert(luaG_checkcode(f));
+  lua_assert(fs-&gt;bl == NULL);
+  ls-&gt;fs = fs-&gt;prev;
+}
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff) {
+  struct LexState lexstate;
+  struct FuncState funcstate;
+  lexstate.buff = buff;
+  lexstate.nestlevel = 0;
+  luaX_setinput(L, &amp;lexstate, z, luaS_new(L, zname(z)));
+  open_func(&amp;lexstate, &amp;funcstate);
+  next(&amp;lexstate);  /* read first token */
+  chunk(&amp;lexstate);
+  check_condition(&amp;lexstate, (lexstate.t.token == TK_EOS), &quot;&lt;eof&gt; expected&quot;);
+  close_func(&amp;lexstate);
+  lua_assert(funcstate.prev == NULL);
+  lua_assert(funcstate.f-&gt;nups == 0);
+  lua_assert(lexstate.nestlevel == 0);
+  return funcstate.f;
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+static void luaY_field (LexState *ls, expdesc *v) {
+  /* field -&gt; ['.' | ':'] NAME */
+  FuncState *fs = ls-&gt;fs;
+  expdesc key;
+  luaK_exp2anyreg(fs, v);
+  next(ls);  /* skip the dot or colon */
+  checkname(ls, &amp;key);
+  luaK_indexed(fs, v, &amp;key);
+}
+
+
+static void luaY_index (LexState *ls, expdesc *v) {
+  /* index -&gt; '[' expr ']' */
+  next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls-&gt;fs, v);
+  check(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -&gt; (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls-&gt;fs;
+  int reg = ls-&gt;fs-&gt;freereg;
+  expdesc key, val;
+  if (ls-&gt;t.token == TK_NAME) {
+    luaX_checklimit(ls, cc-&gt;nh, MAX_INT, &quot;items in a constructor&quot;);
+    cc-&gt;nh++;
+    checkname(ls, &amp;key);
+  }
+  else  /* ls-&gt;t.token == '[' */
+    luaY_index(ls, &amp;key);
+  check(ls, '=');
+  luaK_exp2RK(fs, &amp;key);
+  expr(ls, &amp;val);
+  luaK_codeABC(fs, OP_SETTABLE, cc-&gt;t-&gt;info, luaK_exp2RK(fs, &amp;key),
+                                             luaK_exp2RK(fs, &amp;val));
+  fs-&gt;freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc-&gt;v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &amp;cc-&gt;v);
+  cc-&gt;v.k = VVOID;
+  if (cc-&gt;tostore == LFIELDS_PER_FLUSH) {
+    luaK_codeABx(fs, OP_SETLIST, cc-&gt;t-&gt;info, cc-&gt;na-1);  /* flush */
+    cc-&gt;tostore = 0;  /* no more items pending */
+    fs-&gt;freereg = cc-&gt;t-&gt;info + 1;  /* free registers */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc-&gt;tostore == 0) return;
+  if (cc-&gt;v.k == VCALL) {
+    luaK_setcallreturns(fs, &amp;cc-&gt;v, LUA_MULTRET);
+    luaK_codeABx(fs, OP_SETLISTO, cc-&gt;t-&gt;info, cc-&gt;na-1);
+  }
+  else {
+    if (cc-&gt;v.k != VVOID)
+      luaK_exp2nextreg(fs, &amp;cc-&gt;v);
+    luaK_codeABx(fs, OP_SETLIST, cc-&gt;t-&gt;info, cc-&gt;na-1);
+  }
+  fs-&gt;freereg = cc-&gt;t-&gt;info + 1;  /* free registers */
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  expr(ls, &amp;cc-&gt;v);
+  luaX_checklimit(ls, cc-&gt;na, MAXARG_Bx, &quot;items in a constructor&quot;);
+  cc-&gt;na++;
+  cc-&gt;tostore++;
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -&gt; ?? */
+  FuncState *fs = ls-&gt;fs;
+  int line = ls-&gt;linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&amp;cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls-&gt;fs, t);  /* fix it at stack top (for gc) */
+  check(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0);
+    testnext(ls, ';');  /* compatibility only */
+    if (ls-&gt;t.token == '}') break;
+    closelistfield(fs, &amp;cc);
+    switch(ls-&gt;t.token) {
+      case TK_NAME: {  /* may be listfields or recfields */
+        lookahead(ls);
+        if (ls-&gt;lookahead.token != '=')  /* expression? */
+          listfield(ls, &amp;cc);
+        else
+          recfield(ls, &amp;cc);
+        break;
+      }
+      case '[': {  /* constructor_item -&gt; recfield */
+        recfield(ls, &amp;cc);
+        break;
+      }
+      default: {  /* constructor_part -&gt; listfield */
+        listfield(ls, &amp;cc);
+        break;
+      }
+    }
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &amp;cc);
+  SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs-&gt;f-&gt;code[pc], luaO_log2(cc.nh)+1);  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -&gt; [ param { `,' param } ] */
+  int nparams = 0;
+  int dots = 0;
+  if (ls-&gt;t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls-&gt;t.token) {
+        case TK_DOTS: dots = 1; next(ls); break;
+        case TK_NAME: new_localvar(ls, str_checkname(ls), nparams++); break;
+        default: luaX_syntaxerror(ls, &quot;&lt;name&gt; or `...' expected&quot;);
+      }
+    } while (!dots &amp;&amp; testnext(ls, ','));
+  }
+  code_params(ls, nparams, dots);
+}
+
+
+static void body (LexState *ls, expdesc *e, int needself, int line) {
+  /* body -&gt;  `(' parlist `)' chunk END */
+  FuncState new_fs;
+  open_func(ls, &amp;new_fs);
+  new_fs.f-&gt;lineDefined = line;
+  check(ls, '(');
+  if (needself)
+    create_local(ls, &quot;self&quot;);
+  parlist(ls);
+  check(ls, ')');
+  chunk(ls);
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  close_func(ls);
+  pushclosure(ls, &amp;new_fs, e);
+}
+
+
+static int explist1 (LexState *ls, expdesc *v) {
+  /* explist1 -&gt; expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls-&gt;fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f) {
+  FuncState *fs = ls-&gt;fs;
+  expdesc args;
+  int base, nparams;
+  int line = ls-&gt;linenumber;
+  switch (ls-&gt;t.token) {
+    case '(': {  /* funcargs -&gt; `(' [ explist1 ] `)' */
+      if (line != ls-&gt;lastline)
+        luaX_syntaxerror(ls,&quot;ambiguous syntax (function call x new statement)&quot;);
+      next(ls);
+      if (ls-&gt;t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist1(ls, &amp;args);
+        luaK_setcallreturns(fs, &amp;args, LUA_MULTRET);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -&gt; constructor */
+      constructor(ls, &amp;args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -&gt; STRING */
+      codestring(ls, &amp;args, ls-&gt;t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, &quot;function arguments expected&quot;);
+      return;
+    }
+  }
+  lua_assert(f-&gt;k == VNONRELOC);
+  base = f-&gt;info;  /* base register for call */
+  if (args.k == VCALL)
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &amp;args);  /* close last argument */
+    nparams = fs-&gt;freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs-&gt;freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void prefixexp (LexState *ls, expdesc *v) {
+  /* prefixexp -&gt; NAME | '(' expr ')' */
+  switch (ls-&gt;t.token) {
+    case '(': {
+      int line = ls-&gt;linenumber;
+      next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls-&gt;fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v, 1);
+      return;
+    }
+#ifdef LUA_COMPATUPSYNTAX
+    case '%': {  /* for compatibility only */
+      TString *varname;
+      int line = ls-&gt;linenumber;
+      next(ls);  /* skip `%' */
+      varname = singlevar(ls, v, 1);
+      if (v-&gt;k != VUPVAL)
+        luaX_errorline(ls, &quot;global upvalues are obsolete&quot;,
+                           getstr(varname), line);
+      return;
+    }
+#endif
+    default: {
+      luaX_syntaxerror(ls, &quot;unexpected symbol&quot;);
+      return;
+    }
+  }
+}
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp -&gt;
+        prefixexp { `.' NAME | `[' exp `]' | `:' NAME funcargs | funcargs } */
+  FuncState *fs = ls-&gt;fs;
+  prefixexp(ls, v);
+  for (;;) {
+    switch (ls-&gt;t.token) {
+      case '.': {  /* field */
+        luaY_field(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyreg(fs, v);
+        luaY_index(ls, &amp;key);
+        luaK_indexed(fs, v, &amp;key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        next(ls);
+        checkname(ls, &amp;key);
+        luaK_self(fs, v, &amp;key);
+        funcargs(ls, v);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -&gt; NUMBER | STRING | NIL | constructor | FUNCTION body
+               | primaryexp */
+  switch (ls-&gt;t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VK, luaK_numberK(ls-&gt;fs, ls-&gt;t.seminfo.r));
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls-&gt;t.seminfo.ts);
+      next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      next(ls);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      next(ls);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      next(ls);
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      break;
+    }
+    case TK_FUNCTION: {
+      next(ls);
+      body(ls, v, 0, ls-&gt;linenumber);
+      break;
+    }
+    default: {
+      primaryexp(ls, v);
+      break;
+    }
+  }
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MULT;
+    case '/': return OPR_DIV;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '&lt;': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '&gt;': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7},  /* arithmetic */
+   {10, 9}, {5, 4},                 /* power and concat (right associative) */
+   {3, 3}, {3, 3},                  /* equality */
+   {3, 3}, {3, 3}, {3, 3}, {3, 3},  /* order */
+   {2, 2}, {1, 1}                   /* logical (and/or) */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -&gt; (simplexep | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls-&gt;t.token);
+  if (uop != OPR_NOUNOPR) {
+    next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls-&gt;fs, uop, v);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls-&gt;t.token);
+  while (op != OPR_NOBINOPR &amp;&amp; cast(int, priority[op].left) &gt; limit) {
+    expdesc v2;
+    BinOpr nextop;
+    next(ls);
+    luaK_infix(ls-&gt;fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &amp;v2, cast(int, priority[op].right));
+    luaK_posfix(ls-&gt;fs, op, v, &amp;v2);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, -1);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static int block_follow (int token) {
+  switch (token) {
+    case TK_ELSE: case TK_ELSEIF: case TK_END:
+    case TK_UNTIL: case TK_EOS:
+      return 1;
+    default: return 0;
+  }
+}
+
+
+static void block (LexState *ls) {
+  /* block -&gt; chunk */
+  FuncState *fs = ls-&gt;fs;
+  BlockCnt bl;
+  enterblock(fs, &amp;bl, 0);
+  chunk(ls);
+  lua_assert(bl.breaklist == NO_JUMP);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to a local variable, the local variable
+** is needed in a previous assignment (to a table). If so, save original
+** local value in a safe place and use this safe copy in the previous
+** assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls-&gt;fs;
+  int extra = fs-&gt;freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh-&gt;prev) {
+    if (lh-&gt;v.k == VINDEXED) {
+      if (lh-&gt;v.info == v-&gt;info) {  /* conflict? */
+        conflict = 1;
+        lh-&gt;v.info = extra;  /* previous assignment will use safe copy */
+      }
+      if (lh-&gt;v.aux == v-&gt;info) {  /* conflict? */
+        conflict = 1;
+        lh-&gt;v.aux = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    luaK_codeABC(fs, OP_MOVE, fs-&gt;freereg, v-&gt;info, 0);  /* make copy */
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, VLOCAL &lt;= lh-&gt;v.k &amp;&amp; lh-&gt;v.k &lt;= VINDEXED,
+                      &quot;syntax error&quot;);
+  if (testnext(ls, ',')) {  /* assignment -&gt; `,' primaryexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    primaryexp(ls, &amp;nv.v);
+    if (nv.v.k == VLOCAL)
+      check_conflict(ls, lh, &amp;nv.v);
+    assignment(ls, &amp;nv, nvars+1);
+  }
+  else {  /* assignment -&gt; `=' explist1 */
+    int nexps;
+    check(ls, '=');
+    nexps = explist1(ls, &amp;e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &amp;e);
+      if (nexps &gt; nvars)
+        ls-&gt;fs-&gt;freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setcallreturns(ls-&gt;fs, &amp;e, 1);  /* close last expression */
+      luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&amp;e, VNONRELOC, ls-&gt;fs-&gt;freereg-1);  /* default assignment */
+  luaK_storevar(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);
+}
+
+
+static void cond (LexState *ls, expdesc *v) {
+  /* cond -&gt; exp */
+  expr(ls, v);  /* read condition */
+  if (v-&gt;k == VNIL) v-&gt;k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls-&gt;fs, v);
+  luaK_patchtohere(ls-&gt;fs, v-&gt;t);
+}
+
+
+/*
+** The while statement optimizes its code by coding the condition
+** after its body (and thus avoiding one jump in the loop).
+*/
+
+/*
+** maximum size of expressions for optimizing `while' code
+*/
+#ifndef MAXEXPWHILE
+#define MAXEXPWHILE	100
+#endif
+
+/*
+** the call `luaK_goiffalse' may grow the size of an expression by
+** at most this:
+*/
+#define EXTRAEXP	5
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -&gt; WHILE cond DO block END */
+  Instruction codeexp[MAXEXPWHILE + EXTRAEXP];
+  int lineexp;
+  int i;
+  int sizeexp;
+  FuncState *fs = ls-&gt;fs;
+  int whileinit, blockinit, expinit;
+  expdesc v;
+  BlockCnt bl;
+  next(ls);  /* skip WHILE */
+  whileinit = luaK_jump(fs);  /* jump to condition (which will be moved) */
+  expinit = luaK_getlabel(fs);
+  expr(ls, &amp;v);  /* parse condition */
+  if (v.k == VK) v.k = VTRUE;  /* `trues' are all equal here */
+  lineexp = ls-&gt;linenumber;
+  luaK_goiffalse(fs, &amp;v);
+  luaK_concat(fs, &amp;v.f, fs-&gt;jpc);
+  fs-&gt;jpc = NO_JUMP;
+  sizeexp = fs-&gt;pc - expinit;  /* size of expression code */
+  if (sizeexp &gt; MAXEXPWHILE) 
+    luaX_syntaxerror(ls, &quot;`while' condition too complex&quot;);
+  for (i = 0; i &lt; sizeexp; i++)  /* save `exp' code */
+    codeexp[i] = fs-&gt;f-&gt;code[expinit + i];
+  fs-&gt;pc = expinit;  /* remove `exp' code */
+  enterblock(fs, &amp;bl, 1);
+  check(ls, TK_DO);
+  blockinit = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, whileinit);  /* initial jump jumps to here */
+  /* move `exp' back to code */
+  if (v.t != NO_JUMP) v.t += fs-&gt;pc - expinit;
+  if (v.f != NO_JUMP) v.f += fs-&gt;pc - expinit;
+  for (i=0; i&lt;sizeexp; i++)
+    luaK_code(fs, codeexp[i], lineexp);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchlist(fs, v.t, blockinit);  /* true conditions go back to loop */
+  luaK_patchtohere(fs, v.f);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -&gt; REPEAT block UNTIL cond */
+  FuncState *fs = ls-&gt;fs;
+  int repeat_init = luaK_getlabel(fs);
+  expdesc v;
+  BlockCnt bl;
+  enterblock(fs, &amp;bl, 1);
+  next(ls);
+  block(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  cond(ls, &amp;v);
+  luaK_patchlist(fs, v.f, repeat_init);
+  leaveblock(fs);
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int k;
+  expr(ls, &amp;e);
+  k = e.k;
+  luaK_exp2nextreg(ls-&gt;fs, &amp;e);
+  return k;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  BlockCnt bl;
+  FuncState *fs = ls-&gt;fs;
+  int prep, endfor;
+  adjustlocalvars(ls, nvars);  /* scope for all variables */
+  check(ls, TK_DO);
+  enterblock(fs, &amp;bl, 1);  /* loop block */
+  prep = luaK_getlabel(fs);
+  block(ls);
+  luaK_patchtohere(fs, prep-1);
+  endfor = (isnum) ? luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP) :
+                     luaK_codeABC(fs, OP_TFORLOOP, base, 0, nvars - 3);
+  luaK_fixline(fs, line);  /* pretend that `OP_FOR' starts the loop */
+  luaK_patchlist(fs, (isnum) ? endfor : luaK_jump(fs), prep);
+  leaveblock(fs);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -&gt; NAME = exp1,exp1[,exp1] DO body */
+  FuncState *fs = ls-&gt;fs;
+  int base = fs-&gt;freereg;
+  new_localvar(ls, varname, 0);
+  new_localvarstr(ls, &quot;(for limit)&quot;, 1);
+  new_localvarstr(ls, &quot;(for step)&quot;, 2);
+  check(ls, '=');
+  exp1(ls);  /* initial value */
+  check(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codeABx(fs, OP_LOADK, fs-&gt;freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  luaK_codeABC(fs, OP_SUB, fs-&gt;freereg - 3, fs-&gt;freereg - 3, fs-&gt;freereg - 1);
+  luaK_jump(fs);
+  forbody(ls, base, line, 3, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -&gt; NAME {,NAME} IN explist1 DO body */
+  FuncState *fs = ls-&gt;fs;
+  expdesc e;
+  int nvars = 0;
+  int line;
+  int base = fs-&gt;freereg;
+  new_localvarstr(ls, &quot;(for generator)&quot;, nvars++);
+  new_localvarstr(ls, &quot;(for state)&quot;, nvars++);
+  new_localvar(ls, indexname, nvars++);
+  while (testnext(ls, ','))
+    new_localvar(ls, str_checkname(ls), nvars++);
+  check(ls, TK_IN);
+  line = ls-&gt;linenumber;
+  adjust_assign(ls, nvars, explist1(ls, &amp;e), &amp;e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  luaK_codeAsBx(fs, OP_TFORPREP, base, NO_JUMP);
+  forbody(ls, base, line, nvars, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -&gt; fornum | forlist */
+  FuncState *fs = ls-&gt;fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &amp;bl, 0);  /* block to control variable scope */
+  next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls-&gt;t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, &quot;`=' or `in' expected&quot;);
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);
+}
+
+
+static void test_then_block (LexState *ls, expdesc *v) {
+  /* test_then_block -&gt; [IF | ELSEIF] cond THEN block */
+  next(ls);  /* skip IF or ELSEIF */
+  cond(ls, v);
+  check(ls, TK_THEN);
+  block(ls);  /* `then' part */
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls-&gt;fs;
+  expdesc v;
+  int escapelist = NO_JUMP;
+  test_then_block(ls, &amp;v);  /* IF cond THEN block */
+  while (ls-&gt;t.token == TK_ELSEIF) {
+    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    test_then_block(ls, &amp;v);  /* ELSEIF cond THEN block */
+  }
+  if (ls-&gt;t.token == TK_ELSE) {
+    luaK_concat(fs, &amp;escapelist, luaK_jump(fs));
+    luaK_patchtohere(fs, v.f);
+    next(ls);  /* skip ELSE (after patch, for correct line info) */
+    block(ls);  /* `else' part */
+  }
+  else
+    luaK_concat(fs, &amp;escapelist, v.f);
+  luaK_patchtohere(fs, escapelist);
+  check_match(ls, TK_END, TK_IF, line);
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc v, b;
+  new_localvar(ls, str_checkname(ls), 0);
+  init_exp(&amp;v, VLOCAL, ls-&gt;fs-&gt;freereg++);
+  adjustlocalvars(ls, 1);
+  body(ls, &amp;b, 0, ls-&gt;linenumber);
+  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -&gt; LOCAL NAME {`,' NAME} [`=' explist1] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls), nvars++);
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist1(ls, &amp;e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &amp;e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -&gt; NAME {field} [`:' NAME] */
+  int needself = 0;
+  singlevar(ls, v, 1);
+  while (ls-&gt;t.token == '.')
+    luaY_field(ls, v);
+  if (ls-&gt;t.token == ':') {
+    needself = 1;
+    luaY_field(ls, v);
+  }
+  return needself;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -&gt; FUNCTION funcname body */
+  int needself;
+  expdesc v, b;
+  next(ls);  /* skip FUNCTION */
+  needself = funcname(ls, &amp;v);
+  body(ls, &amp;b, needself, line);
+  luaK_storevar(ls-&gt;fs, &amp;v, &amp;b);
+  luaK_fixline(ls-&gt;fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -&gt; func | assignment */
+  FuncState *fs = ls-&gt;fs;
+  struct LHS_assign v;
+  primaryexp(ls, &amp;v.v);
+  if (v.v.k == VCALL) {  /* stat -&gt; func */
+    luaK_setcallreturns(fs, &amp;v.v, 0);  /* call statement uses no results */
+  }
+  else {  /* stat -&gt; assignment */
+    v.prev = NULL;
+    assignment(ls, &amp;v, 1);
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -&gt; RETURN explist */
+  FuncState *fs = ls-&gt;fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  next(ls);  /* skip RETURN */
+  if (block_follow(ls-&gt;t.token) || ls-&gt;t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist1(ls, &amp;e);  /* optional return values */
+    if (e.k == VCALL) {
+      luaK_setcallreturns(fs, &amp;e, LUA_MULTRET);
+      if (nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&amp;e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&amp;e)) == fs-&gt;nactvar);
+      }
+      first = fs-&gt;nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &amp;e);
+      else {
+        luaK_exp2nextreg(fs, &amp;e);  /* values must go to the `stack' */
+        first = fs-&gt;nactvar;  /* return all `active' values */
+        lua_assert(nret == fs-&gt;freereg - first);
+      }
+    }
+  }
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static void breakstat (LexState *ls) {
+  /* stat -&gt; BREAK [NAME] */
+  FuncState *fs = ls-&gt;fs;
+  BlockCnt *bl = fs-&gt;bl;
+  int upval = 0;
+  next(ls);  /* skip BREAK */
+  while (bl &amp;&amp; !bl-&gt;isbreakable) {
+    upval |= bl-&gt;upval;
+    bl = bl-&gt;previous;
+  }
+  if (!bl)
+    luaX_syntaxerror(ls, &quot;no loop to break&quot;);
+  if (upval)
+    luaK_codeABC(fs, OP_CLOSE, bl-&gt;nactvar, 0, 0);
+  luaK_concat(fs, &amp;bl-&gt;breaklist, luaK_jump(fs));
+}
+
+
+static int statement (LexState *ls) {
+  int line = ls-&gt;linenumber;  /* may be needed for error messages */
+  switch (ls-&gt;t.token) {
+    case TK_IF: {  /* stat -&gt; ifstat */
+      ifstat(ls, line);
+      return 0;
+    }
+    case TK_WHILE: {  /* stat -&gt; whilestat */
+      whilestat(ls, line);
+      return 0;
+    }
+    case TK_DO: {  /* stat -&gt; DO block END */
+      next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      return 0;
+    }
+    case TK_FOR: {  /* stat -&gt; forstat */
+      forstat(ls, line);
+      return 0;
+    }
+    case TK_REPEAT: {  /* stat -&gt; repeatstat */
+      repeatstat(ls, line);
+      return 0;
+    }
+    case TK_FUNCTION: {
+      funcstat(ls, line);  /* stat -&gt; funcstat */
+      return 0;
+    }
+    case TK_LOCAL: {  /* stat -&gt; localstat */
+      next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      return 0;
+    }
+    case TK_RETURN: {  /* stat -&gt; retstat */
+      retstat(ls);
+      return 1;  /* must be last statement */
+    }
+    case TK_BREAK: {  /* stat -&gt; breakstat */
+      breakstat(ls);
+      return 1;  /* must be last statement */
+    }
+    default: {
+      exprstat(ls);
+      return 0;  /* to avoid warnings */
+    }
+  }
+}
+
+
+static void chunk (LexState *ls) {
+  /* chunk -&gt; { stat [`;'] } */
+  int islast = 0;
+  enterlevel(ls);
+  while (!islast &amp;&amp; !block_follow(ls-&gt;t.token)) {
+    islast = statement(ls);
+    testnext(ls, ';');
+    lua_assert(ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);
+    ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar;  /* free registers */
+  }
+  leavelevel(ls);
+}
+
+/* }====================================================================== */

Added: trunk/source/libraries/lua/lparser.h
===================================================================
--- trunk/source/libraries/lua/lparser.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lparser.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,71 @@
+/*
+** $Id: lparser.h,v 1.47 2003/02/11 10:46:24 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include &quot;llimits.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;lzio.h&quot;
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in `upvalues' */
+  VGLOBAL,	/* info = index of table; aux = index of global name in `k' */
+  VINDEXED,	/* info = table register; aux = index register (or `k') */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VNONRELOC,	/* info = result register */
+  VCALL		/* info = result register */
+} expkind;
+
+typedef struct expdesc {
+  expkind k;
+  int info, aux;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct lua_State *L;  /* copy of the Lua state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* `pc' of last `jump target' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int freereg;  /* first free register */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int nlocvars;  /* number of elements in `locvars' */
+  int nactvar;  /* number of active local variables */
+  expdesc upvalues[MAXUPVALUES];  /* upvalues */
+  int actvar[MAXVARS];  /* declared-variable stack */
+} FuncState;
+
+
+Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff);
+
+
+#endif

Added: trunk/source/libraries/lua/lstate.c
===================================================================
--- trunk/source/libraries/lua/lstate.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstate.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,220 @@
+/*
+** $Id: lstate.c,v 1.123 2003/04/03 13:35:34 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdlib.h&gt;
+
+#define lstate_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;llex.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+
+
+/*
+** macro to allow the inclusion of user information in Lua state
+*/
+#ifndef LUA_USERSTATE
+#define EXTRASPACE	0
+#else
+union UEXTRASPACE {L_Umaxalign a; LUA_USERSTATE b;};
+#define EXTRASPACE (sizeof(union UEXTRASPACE))
+#endif
+
+
+
+/*
+** you can change this function through the official API:
+** call `lua_setpanicf'
+*/
+static int default_panic (lua_State *L) {
+  UNUSED(L);
+  return 0;
+}
+
+
+static lua_State *mallocstate (lua_State *L) {
+  lu_byte *block = (lu_byte *)luaM_malloc(L, sizeof(lua_State) + EXTRASPACE);
+  if (block == NULL) return NULL;
+  else {
+    block += EXTRASPACE;
+    return cast(lua_State *, block);
+  }
+}
+
+
+static void freestate (lua_State *L, lua_State *L1) {
+  luaM_free(L, cast(lu_byte *, L1) - EXTRASPACE,
+               sizeof(lua_State) + EXTRASPACE);
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, TObject);
+  L1-&gt;stacksize = BASIC_STACK_SIZE + EXTRA_STACK;
+  L1-&gt;top = L1-&gt;stack;
+  L1-&gt;stack_last = L1-&gt;stack+(L1-&gt;stacksize - EXTRA_STACK)-1;
+  L1-&gt;base_ci = luaM_newvector(L, BASIC_CI_SIZE, CallInfo);
+  L1-&gt;ci = L1-&gt;base_ci;
+  L1-&gt;ci-&gt;state = CI_C;  /*  not a Lua function */
+  setnilvalue(L1-&gt;top++);  /* `function' entry for this `ci' */
+  L1-&gt;base = L1-&gt;ci-&gt;base = L1-&gt;top;
+  L1-&gt;ci-&gt;top = L1-&gt;top + LUA_MINSTACK;
+  L1-&gt;size_ci = BASIC_CI_SIZE;
+  L1-&gt;end_ci = L1-&gt;base_ci + L1-&gt;size_ci;
+}
+
+
+static void freestack (lua_State *L, lua_State *L1) {
+  luaM_freearray(L, L1-&gt;base_ci, L1-&gt;size_ci, CallInfo);
+  luaM_freearray(L, L1-&gt;stack, L1-&gt;stacksize, TObject);
+}
+
+
+/*
+** open parts that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  /* create a new global state */
+  global_State *g = luaM_new(NULL, global_State);
+  UNUSED(ud);
+  if (g == NULL) luaD_throw(L, LUA_ERRMEM);
+  L-&gt;l_G = g;
+  g-&gt;mainthread = L;
+  g-&gt;GCthreshold = 0;  /* mark it as unfinished state */
+  g-&gt;strt.size = 0;
+  g-&gt;strt.nuse = 0;
+  g-&gt;strt.hash = NULL;
+  setnilvalue(defaultmeta(L));
+  setnilvalue(registry(L));
+  luaZ_initbuffer(L, &amp;g-&gt;buff);
+  g-&gt;panic = default_panic;
+  g-&gt;rootgc = NULL;
+  g-&gt;rootudata = NULL;
+  g-&gt;tmudata = NULL;
+  setnilvalue(gkey(g-&gt;dummynode));
+  setnilvalue(gval(g-&gt;dummynode));
+  g-&gt;dummynode-&gt;next = NULL;
+  g-&gt;nblocks = sizeof(lua_State) + sizeof(global_State);
+  stack_init(L, L);  /* init stack */
+  /* create default meta table with a dummy table, and then close the loop */
+  defaultmeta(L)-&gt;tt = LUA_TTABLE;
+  sethvalue(defaultmeta(L), luaH_new(L, 0, 0));
+  hvalue(defaultmeta(L))-&gt;metatable = hvalue(defaultmeta(L));
+  sethvalue(gt(L), luaH_new(L, 0, 4));  /* table of globals */
+  sethvalue(registry(L), luaH_new(L, 4, 4));  /* registry */
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  luaS_fix(luaS_newliteral(L, MEMERRMSG));
+  g-&gt;GCthreshold = 4*G(L)-&gt;nblocks;
+}
+
+
+static void preinit_state (lua_State *L) {
+  L-&gt;stack = NULL;
+  L-&gt;stacksize = 0;
+  L-&gt;errorJmp = NULL;
+  L-&gt;hook = NULL;
+  L-&gt;hookmask = L-&gt;hookinit = 0;
+  L-&gt;basehookcount = 0;
+  L-&gt;allowhook = 1;
+  resethookcount(L);
+  L-&gt;openupval = NULL;
+  L-&gt;size_ci = 0;
+  L-&gt;nCcalls = 0;
+  L-&gt;base_ci = L-&gt;ci = NULL;
+  L-&gt;errfunc = 0;
+  setnilvalue(gt(L));
+}
+
+
+static void close_state (lua_State *L) {
+  luaF_close(L, L-&gt;stack);  /* close all upvalues for this thread */
+  if (G(L)) {  /* close global state */
+    luaC_sweep(L, 1);  /* collect all elements */
+    lua_assert(G(L)-&gt;rootgc == NULL);
+    lua_assert(G(L)-&gt;rootudata == NULL);
+    luaS_freeall(L);
+    luaZ_freebuffer(L, &amp;G(L)-&gt;buff);
+  }
+  freestack(L, L);
+  if (G(L)) {
+    lua_assert(G(L)-&gt;nblocks == sizeof(lua_State) + sizeof(global_State));
+    luaM_freelem(NULL, G(L));
+  }
+  freestate(NULL, L);
+}
+
+
+lua_State *luaE_newthread (lua_State *L) {
+  lua_State *L1 = mallocstate(L);
+  luaC_link(L, valtogco(L1), LUA_TTHREAD);
+  preinit_state(L1);
+  L1-&gt;l_G = L-&gt;l_G;
+  stack_init(L1, L);  /* init stack */
+  setobj2n(gt(L1), gt(L));  /* share table of globals */
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  luaF_close(L1, L1-&gt;stack);  /* close all upvalues for this thread */
+  lua_assert(L1-&gt;openupval == NULL);
+  freestack(L, L1);
+  freestate(L, L1);
+}
+
+
+LUA_API lua_State *lua_open (void) {
+  lua_State *L = mallocstate(NULL);
+  if (L) {  /* allocation OK? */
+    L-&gt;tt = LUA_TTHREAD;
+    L-&gt;marked = 0;
+    L-&gt;next = L-&gt;gclist = NULL;
+    preinit_state(L);
+    L-&gt;l_G = NULL;
+    if (luaD_rawrunprotected(L, f_luaopen, NULL) != 0) {
+      /* memory allocation error: free partial state */
+      close_state(L);
+      L = NULL;
+    }
+  }
+  lua_userstateopen(L);
+  return L;
+}
+
+
+static void callallgcTM (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaC_callGCTM(L);  /* call GC metamethods for all udata */
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  lua_lock(L);
+  L = G(L)-&gt;mainthread;  /* only the main thread can be closed */
+  luaF_close(L, L-&gt;stack);  /* close all upvalues for this thread */
+  luaC_separateudata(L);  /* separate udata that have GC metamethods */
+  L-&gt;errfunc = 0;  /* no error function during GC metamethods */
+  do {  /* repeat until no more errors */
+    L-&gt;ci = L-&gt;base_ci;
+    L-&gt;base = L-&gt;top = L-&gt;ci-&gt;base;
+    L-&gt;nCcalls = 0;
+  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);
+  lua_assert(G(L)-&gt;tmudata == NULL);
+  close_state(L);
+}
+

Added: trunk/source/libraries/lua/lstate.h
===================================================================
--- trunk/source/libraries/lua/lstate.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstate.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,195 @@
+/*
+** $Id: lstate.h,v 1.109 2003/02/27 11:52:30 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lzio.h&quot;
+
+
+/*
+** macros for thread synchronization inside Lua core machine:
+** all accesses to the global state and to global objects are synchronized.
+** Because threads can read the stack of other threads
+** (when running garbage collection),
+** a thread must also synchronize any write-access to its own stack.
+** Unsynchronized accesses are allowed only when reading its own stack,
+** or when reading immutable fields from global objects
+** (such as string values and udata values). 
+*/
+#ifndef lua_lock
+#define lua_lock(L)	((void) 0)
+#endif
+
+#ifndef lua_unlock
+#define lua_unlock(L)	((void) 0)
+#endif
+
+
+#ifndef lua_userstateopen
+#define lua_userstateopen(l)
+#endif
+
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+/* default meta table (both for tables and udata) */
+#define defaultmeta(L)	(&amp;G(L)-&gt;_defaultmeta)
+
+/* table of globals */
+#define gt(L)	(&amp;L-&gt;_gt)
+
+/* registry */
+#define registry(L)	(&amp;G(L)-&gt;_registry)
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_CI_SIZE           8
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  ls_nstr nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** informations about a call
+*/
+typedef struct CallInfo {
+  StkId base;  /* base for called function */
+  StkId	top;  /* top for this function */
+  int state;  /* bit fields; see below */
+  union {
+    struct {  /* for Lua functions */
+      const Instruction *savedpc;
+      const Instruction **pc;  /* points to `pc' variable in `luaV_execute' */
+      int tailcalls;  /* number of tail calls lost under this entry */
+    } l;
+    struct {  /* for C functions */
+      int dummy;  /* just to avoid an empty struct */
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** bit fields for `CallInfo.state'
+*/
+#define CI_C		(1&lt;&lt;0)  /* 1 if function is a C function */
+/* 1 if (Lua) function has an active `luaV_execute' running it */
+#define CI_HASFRAME	(1&lt;&lt;1)
+/* 1 if Lua function is calling another Lua function (and therefore its
+   `pc' is being used by the other, and therefore CI_SAVEDPC is 1 too) */
+#define CI_CALLING	(1&lt;&lt;2)
+#define CI_SAVEDPC	(1&lt;&lt;3)  /* 1 if `savedpc' is updated */
+#define CI_YIELD	(1&lt;&lt;4)  /* 1 if thread is suspended */
+
+
+#define ci_func(ci)	(clvalue((ci)-&gt;base - 1))
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  stringtable strt;  /* hash table for strings */
+  GCObject *rootgc;  /* list of (almost) all collectable objects */
+  GCObject *rootudata;   /* (separated) list of all userdata */
+  GCObject *tmudata;  /* list of userdata to be GC */
+  Mbuffer buff;  /* temporary buffer for string concatentation */
+  lu_mem GCthreshold;
+  lu_mem nblocks;  /* number of `bytes' currently allocated */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  TObject _registry;
+  TObject _defaultmeta;
+  struct lua_State *mainthread;
+  Node dummynode[1];  /* common node array for all empty tables */
+  TString *tmname[TM_N];  /* array with tag-method names */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  StkId top;  /* first free slot in the stack */
+  StkId base;  /* base of current function */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  CallInfo *end_ci;  /* points after end of ci array*/
+  CallInfo *base_ci;  /* array of CallInfo's */
+  unsigned short size_ci;  /* size of array `base_ci' */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  lu_byte hookinit;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  TObject _gt;  /* table of globals */
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+};
+
+
+#define G(L)	(L-&gt;l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+/* macros to convert a GCObject into a specific value */
+#define gcotots(o)	check_exp((o)-&gt;gch.tt == LUA_TSTRING, &amp;((o)-&gt;ts))
+#define gcotou(o)	check_exp((o)-&gt;gch.tt == LUA_TUSERDATA, &amp;((o)-&gt;u))
+#define gcotocl(o)	check_exp((o)-&gt;gch.tt == LUA_TFUNCTION, &amp;((o)-&gt;cl))
+#define gcotoh(o)	check_exp((o)-&gt;gch.tt == LUA_TTABLE, &amp;((o)-&gt;h))
+#define gcotop(o)	check_exp((o)-&gt;gch.tt == LUA_TPROTO, &amp;((o)-&gt;p))
+#define gcotouv(o)	check_exp((o)-&gt;gch.tt == LUA_TUPVAL, &amp;((o)-&gt;uv))
+#define ngcotouv(o) \
+	check_exp((o) == NULL || (o)-&gt;gch.tt == LUA_TUPVAL, &amp;((o)-&gt;uv))
+#define gcototh(o)	check_exp((o)-&gt;gch.tt == LUA_TTHREAD, &amp;((o)-&gt;th))
+
+/* macro to convert any value into a GCObject */
+#define valtogco(v)	(cast(GCObject *, (v)))
+
+
+lua_State *luaE_newthread (lua_State *L);
+void luaE_freethread (lua_State *L, lua_State *L1);
+
+#endif
+

Added: trunk/source/libraries/lua/lstring.c
===================================================================
--- trunk/source/libraries/lua/lstring.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstring.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,102 @@
+/*
+** $Id: lstring.c,v 1.78 2002/12/04 17:38:31 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define lstring_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+
+
+
+void luaS_freeall (lua_State *L) {
+  lua_assert(G(L)-&gt;strt.nuse==0);
+  luaM_freearray(L, G(L)-&gt;strt.hash, G(L)-&gt;strt.size, TString *);
+}
+
+
+void luaS_resize (lua_State *L, int newsize) {
+  GCObject **newhash = luaM_newvector(L, newsize, GCObject *);
+  stringtable *tb = &amp;G(L)-&gt;strt;
+  int i;
+  for (i=0; i&lt;newsize; i++) newhash[i] = NULL;
+  /* rehash */
+  for (i=0; i&lt;tb-&gt;size; i++) {
+    GCObject *p = tb-&gt;hash[i];
+    while (p) {  /* for each node in the list */
+      GCObject *next = p-&gt;gch.next;  /* save next */
+      lu_hash h = gcotots(p)-&gt;tsv.hash;
+      int h1 = lmod(h, newsize);  /* new position */
+      lua_assert(cast(int, h%newsize) == lmod(h, newsize));
+      p-&gt;gch.next = newhash[h1];  /* chain it */
+      newhash[h1] = p;
+      p = next;
+    }
+  }
+  luaM_freearray(L, tb-&gt;hash, tb-&gt;size, TString *);
+  tb-&gt;size = newsize;
+  tb-&gt;hash = newhash;
+}
+
+
+static TString *newlstr (lua_State *L, const char *str, size_t l, lu_hash h) {
+  TString *ts = cast(TString *, luaM_malloc(L, sizestring(l)));
+  stringtable *tb;
+  ts-&gt;tsv.len = l;
+  ts-&gt;tsv.hash = h;
+  ts-&gt;tsv.marked = 0;
+  ts-&gt;tsv.tt = LUA_TSTRING;
+  ts-&gt;tsv.reserved = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  tb = &amp;G(L)-&gt;strt;
+  h = lmod(h, tb-&gt;size);
+  ts-&gt;tsv.next = tb-&gt;hash[h];  /* chain new entry */
+  tb-&gt;hash[h] = valtogco(ts);
+  tb-&gt;nuse++;
+  if (tb-&gt;nuse &gt; cast(ls_nstr, tb-&gt;size) &amp;&amp; tb-&gt;size &lt;= MAX_INT/2)
+    luaS_resize(L, tb-&gt;size*2);  /* too crowded */
+  return ts;
+}
+
+
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  lu_hash h = (lu_hash)l;  /* seed */
+  size_t step = (l&gt;&gt;5)+1;  /* if string is too long, don't hash all its chars */
+  size_t l1;
+  for (l1=l; l1&gt;=step; l1-=step)  /* compute hash */
+    h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+(unsigned char)(str[l1-1]));
+  for (o = G(L)-&gt;strt.hash[lmod(h, G(L)-&gt;strt.size)];
+       o != NULL;
+       o = o-&gt;gch.next) {
+    TString *ts = gcotots(o);
+    if (ts-&gt;tsv.len == l &amp;&amp; (memcmp(str, getstr(ts), l) == 0))
+      return ts;
+  }
+  return newlstr(L, str, l, h);  /* not found */
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s) {
+  Udata *u;
+  u = cast(Udata *, luaM_malloc(L, sizeudata(s)));
+  u-&gt;uv.marked = (1&lt;&lt;1);  /* is not finalized */
+  u-&gt;uv.tt = LUA_TUSERDATA;
+  u-&gt;uv.len = s;
+  u-&gt;uv.metatable = hvalue(defaultmeta(L));
+  /* chain it on udata list */
+  u-&gt;uv.next = G(L)-&gt;rootudata;
+  G(L)-&gt;rootudata = valtogco(u);
+  return u;
+}
+

Added: trunk/source/libraries/lua/lstring.h
===================================================================
--- trunk/source/libraries/lua/lstring.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lstring.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,33 @@
+/*
+** $Id: lstring.h,v 1.37 2002/08/16 14:45:55 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+
+
+
+#define sizestring(l)	(cast(lu_mem, sizeof(union TString))+ \
+                         (cast(lu_mem, l)+1)*sizeof(char))
+
+#define sizeudata(l)	(cast(lu_mem, sizeof(union Udata))+(l))
+
+#define luaS_new(L, s)	(luaS_newlstr(L, s, strlen(s)))
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, &quot;&quot; s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	((s)-&gt;tsv.marked |= (1&lt;&lt;4))
+
+void luaS_resize (lua_State *L, int newsize);
+Udata *luaS_newudata (lua_State *L, size_t s);
+void luaS_freeall (lua_State *L);
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+
+
+#endif

Added: trunk/source/libraries/lua/ltable.c
===================================================================
--- trunk/source/libraries/lua/ltable.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltable.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,509 @@
+/*
+** $Id: ltable.c,v 1.132 2003/04/03 13:35:34 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** In other words, there are collisions only when two elements have the
+** same main position (i.e. the same hash values for that table size).
+** Because of that, the load factor of these tables can be 100% without
+** performance penalties.
+*/
+
+#include &lt;string.h&gt;
+
+#define ltable_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;ltable.h&quot;
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if BITS_INT &gt; 26
+#define MAXBITS		24
+#else
+#define MAXBITS		(BITS_INT-2)
+#endif
+
+/* check whether `x' &lt; 2^MAXBITS */
+#define toobig(x)	((((x)-1) &gt;&gt; MAXBITS) != 0)
+
+
+/* function to convert a lua_Number to int (with any rounding method) */
+#ifndef lua_number2int
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+
+#define hashpow2(t,n)      (gnode(t, lmod((n), sizenode(t))))
+  
+#define hashstr(t,str)  hashpow2(t, (str)-&gt;tsv.hash)
+#define hashboolean(t,p)        hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+/*
+** number of ints inside a lua_Number
+*/
+#define numints		cast(int, sizeof(lua_Number)/sizeof(int))
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  unsigned int a[numints];
+  int i;
+  n += 1;  /* normalize number (avoid -0) */
+  lua_assert(sizeof(a) &lt;= sizeof(n));
+  memcpy(a, &amp;n, sizeof(a));
+  for (i = 1; i &lt; numints; i++) a[0] += a[i];
+  return hashmod(t, cast(lu_hash, a[0]));
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+Node *luaH_mainposition (const Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TSTRING:
+      return hashstr(t, tsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TObject *key) {
+  if (ttisnumber(key)) {
+    int k;
+    lua_number2int(k, (nvalue(key)));
+    if (cast(lua_Number, k) == nvalue(key) &amp;&amp; k &gt;= 1 &amp;&amp; !toobig(k))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning and end of a traversal are signalled by -1.
+*/
+static int luaH_index (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 &lt;= i &amp;&amp; i &lt;= t-&gt;sizearray) {  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  }
+  else {
+    const TObject *v = luaH_get(t, key);
+    if (v == &amp;luaO_nilobject)
+      luaG_runerror(L, &quot;invalid key for `next'&quot;);
+    i = cast(int, (cast(const lu_byte *, v) -
+                   cast(const lu_byte *, gval(gnode(t, 0)))) / sizeof(Node));
+    return i + t-&gt;sizearray;  /* hash elements are numbered after array ones */
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = luaH_index(L, t, key);  /* find original element */
+  for (i++; i &lt; t-&gt;sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&amp;t-&gt;array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast(lua_Number, i+1));
+      setobj2s(key+1, &amp;t-&gt;array[i]);
+      return 1;
+    }
+  }
+  for (i -= t-&gt;sizearray; i &lt; sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(key, gkey(gnode(t, i)));
+      setobj2s(key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static void computesizes  (int nums[], int ntotal, int *narray, int *nhash) {
+  int i;
+  int a = nums[0];  /* number of elements smaller than 2^i */
+  int na = a;  /* number of elements to go to array part */
+  int n = (na == 0) ? -1 : 0;  /* (log of) optimal size for array part */
+  for (i = 1; a &lt; *narray &amp;&amp; *narray &gt;= twoto(i-1); i++) {
+    if (nums[i] &gt; 0) {
+      a += nums[i];
+      if (a &gt;= twoto(i-1)) {  /* more than half elements in use? */
+        n = i;
+        na = a;
+      }
+    }
+  }
+  lua_assert(na &lt;= *narray &amp;&amp; *narray &lt;= ntotal);
+  *nhash = ntotal - na;
+  *narray = (n == -1) ? 0 : twoto(n);
+  lua_assert(na &lt;= *narray &amp;&amp; na &gt;= *narray/2);
+}
+
+
+static void numuse (const Table *t, int *narray, int *nhash) {
+  int nums[MAXBITS+1];
+  int i, lg;
+  int totaluse = 0;
+  /* count elements in array part */
+  for (i=0, lg=0; lg&lt;=MAXBITS; lg++) {  /* for each slice [2^(lg-1) to 2^lg) */
+    int ttlg = twoto(lg);  /* 2^lg */
+    if (ttlg &gt; t-&gt;sizearray) {
+      ttlg = t-&gt;sizearray;
+      if (i &gt;= ttlg) break;
+    }
+    nums[lg] = 0;
+    for (; i&lt;ttlg; i++) {
+      if (!ttisnil(&amp;t-&gt;array[i])) {
+        nums[lg]++;
+        totaluse++;
+      }
+    }
+  }
+  for (; lg&lt;=MAXBITS; lg++) nums[lg] = 0;  /* reset other counts */
+  *narray = totaluse;  /* all previous uses were in array part */
+  /* count elements in hash part */
+  i = sizenode(t);
+  while (i--) {
+    Node *n = &amp;t-&gt;node[i];
+    if (!ttisnil(gval(n))) {
+      int k = arrayindex(gkey(n));
+      if (k &gt;= 0) {  /* is `key' an appropriate array index? */
+        nums[luaO_log2(k-1)+1]++;  /* count as such */
+        (*narray)++;
+      }
+      totaluse++;
+    }
+  }
+  computesizes(nums, totaluse, narray, nhash);
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t-&gt;array, t-&gt;sizearray, size, TObject);
+  for (i=t-&gt;sizearray; i&lt;size; i++)
+     setnilvalue(&amp;t-&gt;array[i]);
+  t-&gt;sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int lsize) {
+  int i;
+  int size = twoto(lsize);
+  if (lsize &gt; MAXBITS)
+    luaG_runerror(L, &quot;table overflow&quot;);
+  if (lsize == 0) {  /* no elements to hash part? */
+    t-&gt;node = G(L)-&gt;dummynode;  /* use common `dummynode' */
+    lua_assert(ttisnil(gkey(t-&gt;node)));  /* assert invariants: */
+    lua_assert(ttisnil(gval(t-&gt;node)));
+    lua_assert(t-&gt;node-&gt;next == NULL);  /* (`dummynode' must be empty) */
+  }
+  else {
+    t-&gt;node = luaM_newvector(L, size, Node);
+    for (i=0; i&lt;size; i++) {
+      t-&gt;node[i].next = NULL;
+      setnilvalue(gkey(gnode(t, i)));
+      setnilvalue(gval(gnode(t, i)));
+    }
+  }
+  t-&gt;lsizenode = cast(lu_byte, lsize);
+  t-&gt;firstfree = gnode(t, size-1);  /* first free position to be used */
+}
+
+
+static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t-&gt;sizearray;
+  int oldhsize = t-&gt;lsizenode;
+  Node *nold;
+  Node temp[1];
+  if (oldhsize)
+    nold = t-&gt;node;  /* save old hash ... */
+  else {  /* old hash is `dummynode' */
+    lua_assert(t-&gt;node == G(L)-&gt;dummynode);
+    temp[0] = t-&gt;node[0];  /* copy it to `temp' */
+    nold = temp;
+    setnilvalue(gkey(G(L)-&gt;dummynode));  /* restate invariant */
+    setnilvalue(gval(G(L)-&gt;dummynode));
+    lua_assert(G(L)-&gt;dummynode-&gt;next == NULL);
+  }
+  if (nasize &gt; oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);  
+  /* re-insert elements */
+  if (nasize &lt; oldasize) {  /* array part must shrink? */
+    t-&gt;sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i&lt;oldasize; i++) {
+      if (!ttisnil(&amp;t-&gt;array[i]))
+        setobjt2t(luaH_setnum(L, t, i+1), &amp;t-&gt;array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t-&gt;array, oldasize, nasize, TObject);
+  }
+  /* re-insert elements in hash part */
+  for (i = twoto(oldhsize) - 1; i &gt;= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old)))
+      setobjt2t(luaH_set(L, t, gkey(old)), gval(old));
+  }
+  if (oldhsize)
+    luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
+}
+
+
+static void rehash (lua_State *L, Table *t) {
+  int nasize, nhsize;
+  numuse(t, &amp;nasize, &amp;nhsize);  /* compute new sizes for array and hash parts */
+  resize(L, t, nasize, luaO_log2(nhsize)+1);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L, int narray, int lnhash) {
+  Table *t = luaM_new(L, Table);
+  luaC_link(L, valtogco(t), LUA_TTABLE);
+  t-&gt;metatable = hvalue(defaultmeta(L));
+  t-&gt;flags = cast(lu_byte, ~0);
+  /* temporary values (kept only if some malloc fails) */
+  t-&gt;array = NULL;
+  t-&gt;sizearray = 0;
+  t-&gt;lsizenode = 0;
+  t-&gt;node = NULL;
+  setarrayvector(L, t, narray);
+  setnodevector(L, t, lnhash);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (t-&gt;lsizenode)
+    luaM_freearray(L, t-&gt;node, sizenode(t), Node);
+  luaM_freearray(L, t-&gt;array, t-&gt;sizearray, TObject);
+  luaM_freelem(L, t);
+}
+
+
+#if 0
+/*
+** try to remove an element from a hash table; cannot move any element
+** (because gc can call `remove' during a table traversal)
+*/
+void luaH_remove (Table *t, Node *e) {
+  Node *mp = luaH_mainposition(t, gkey(e));
+  if (e != mp) {  /* element not in its main position? */
+    while (mp-&gt;next != e) mp = mp-&gt;next;  /* find previous */
+    mp-&gt;next = e-&gt;next;  /* remove `e' from its list */
+  }
+  else {
+    if (e-&gt;next != NULL) ??
+  }
+  lua_assert(ttisnil(gval(node)));
+  setnilvalue(gkey(e));  /* clear node `e' */
+  e-&gt;next = NULL;
+}
+#endif
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main 
+** position is free. If not, check whether colliding node is in its main 
+** position or not: if it is not, move colliding node to an empty place and 
+** put new key in its main position; otherwise (colliding node is in its main 
+** position), new key goes to an empty position. 
+*/
+static TObject *newkey (lua_State *L, Table *t, const TObject *key) {
+  TObject *val;
+  Node *mp = luaH_mainposition(t, key);
+  if (!ttisnil(gval(mp))) {  /* main position is not free? */
+    Node *othern = luaH_mainposition(t, gkey(mp));  /* `mp' of colliding node */
+    Node *n = t-&gt;firstfree;  /* get a free place */
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (othern-&gt;next != mp) othern = othern-&gt;next;  /* find previous */
+      othern-&gt;next = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp-&gt;next also goes) */
+      mp-&gt;next = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      n-&gt;next = mp-&gt;next;  /* chain new position */
+      mp-&gt;next = n;
+      mp = n;
+    }
+  }
+  setobj2t(gkey(mp), key);  /* write barrier */
+  lua_assert(ttisnil(gval(mp)));
+  for (;;) {  /* correct `firstfree' */
+    if (ttisnil(gkey(t-&gt;firstfree)))
+      return gval(mp);  /* OK; table still has a free place */
+    else if (t-&gt;firstfree == t-&gt;node) break;  /* cannot decrement from here */
+    else (t-&gt;firstfree)--;
+  }
+  /* no more free places; must create one */
+  setbvalue(gval(mp), 0);  /* avoid new key being removed */
+  rehash(L, t);  /* grow table */
+  val = cast(TObject *, luaH_get(t, key));  /* get new position */
+  lua_assert(ttisboolean(val));
+  setnilvalue(val);
+  return val;
+}
+
+
+/*
+** generic search function
+*/
+static const TObject *luaH_getany (Table *t, const TObject *key) {
+  if (ttisnil(key)) return &amp;luaO_nilobject;
+  else {
+    Node *n = luaH_mainposition(t, key);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (luaO_rawequalObj(gkey(n), key)) return gval(n);  /* that's it */
+      else n = n-&gt;next;
+    } while (n);
+    return &amp;luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for integers
+*/
+const TObject *luaH_getnum (Table *t, int key) {
+  if (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray)
+    return &amp;t-&gt;array[key-1];
+  else {
+    lua_Number nk = cast(lua_Number, key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) &amp;&amp; nvalue(gkey(n)) == nk)
+        return gval(n);  /* that's it */
+      else n = n-&gt;next;
+    } while (n);
+    return &amp;luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for strings
+*/
+const TObject *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisstring(gkey(n)) &amp;&amp; tsvalue(gkey(n)) == key)
+      return gval(n);  /* that's it */
+    else n = n-&gt;next;
+  } while (n);
+  return &amp;luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TObject *luaH_get (Table *t, const TObject *key) {
+  switch (ttype(key)) {
+    case LUA_TSTRING: return luaH_getstr(t, tsvalue(key));
+    case LUA_TNUMBER: {
+      int k;
+      lua_number2int(k, (nvalue(key)));
+      if (cast(lua_Number, k) == nvalue(key))  /* is an integer index? */
+        return luaH_getnum(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: return luaH_getany(t, key);
+  }
+}
+
+
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key) {
+  const TObject *p = luaH_get(t, key);
+  t-&gt;flags = 0;
+  if (p != &amp;luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    if (ttisnil(key)) luaG_runerror(L, &quot;table index is nil&quot;);
+    else if (ttisnumber(key) &amp;&amp; nvalue(key) != nvalue(key))
+      luaG_runerror(L, &quot;table index is NaN&quot;);
+    return newkey(L, t, key);
+  }
+}
+
+
+TObject *luaH_setnum (lua_State *L, Table *t, int key) {
+  const TObject *p = luaH_getnum(t, key);
+  if (p != &amp;luaO_nilobject)
+    return cast(TObject *, p);
+  else {
+    TObject k;
+    setnvalue(&amp;k, cast(lua_Number, key));
+    return newkey(L, t, &amp;k);
+  }
+}
+

Added: trunk/source/libraries/lua/ltable.h
===================================================================
--- trunk/source/libraries/lua/ltable.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltable.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,31 @@
+/*
+** $Id: ltable.h,v 1.44 2003/03/18 12:50:04 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include &quot;lobject.h&quot;
+
+
+#define gnode(t,i)	(&amp;(t)-&gt;node[i])
+#define gkey(n)		(&amp;(n)-&gt;i_key)
+#define gval(n)		(&amp;(n)-&gt;i_val)
+
+
+const TObject *luaH_getnum (Table *t, int key);
+TObject *luaH_setnum (lua_State *L, Table *t, int key);
+const TObject *luaH_getstr (Table *t, TString *key);
+const TObject *luaH_get (Table *t, const TObject *key);
+TObject *luaH_set (lua_State *L, Table *t, const TObject *key);
+Table *luaH_new (lua_State *L, int narray, int lnhash);
+void luaH_free (lua_State *L, Table *t);
+int luaH_next (lua_State *L, Table *t, StkId key);
+
+/* exported only for debugging */
+Node *luaH_mainposition (const Table *t, const TObject *key);
+
+
+#endif

Added: trunk/source/libraries/lua/ltests.c
===================================================================
--- trunk/source/libraries/lua/ltests.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltests.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,852 @@
+/*
+** $Id: ltests.c,v 1.158 2003/04/07 14:35:00 roberto Exp $
+** Internal Module for Debugging of the Lua Implementation
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;ctype.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#define ltests_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lapi.h&quot;
+#include &quot;lauxlib.h&quot;
+#include &quot;lcode.h&quot;
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;lualib.h&quot;
+
+
+
+/*
+** The whole module only makes sense with LUA_DEBUG on
+*/
+#ifdef LUA_DEBUG
+
+
+#define lua_pushintegral(L,i)	lua_pushnumber(L, cast(lua_Number, (i)))
+
+
+static lua_State *lua_state = NULL;
+
+int islocked = 0;
+
+
+#define func_at(L,k)	(L-&gt;ci-&gt;base+(k) - 1)
+
+
+static void setnameval (lua_State *L, const char *name, int val) {
+  lua_pushstring(L, name);
+  lua_pushintegral(L, val);
+  lua_settable(L, -3);
+}
+
+
+/*
+** {======================================================================
+** Controlled version for realloc.
+** =======================================================================
+*/
+
+#define MARK		0x55  /* 01010101 (a nice pattern) */
+
+#ifndef EXTERNMEMCHECK
+/* full memory check */
+#define HEADER	(sizeof(L_Umaxalign)) /* ensures maximum alignment for HEADER */
+#define MARKSIZE	16  /* size of marks after each block */
+#define blockhead(b)	(cast(char *, b) - HEADER)
+#define setsize(newblock, size)	(*cast(size_t *, newblock) = size)
+#define checkblocksize(b, size) (size == (*cast(size_t *, blockhead(b))))
+#define fillmem(mem,size)	memset(mem, -MARK, size)
+#else
+/* external memory check: don't do it twice */
+#define HEADER		0
+#define MARKSIZE	0
+#define blockhead(b)	(b)
+#define setsize(newblock, size)	/* empty */
+#define checkblocksize(b,size)	(1)
+#define fillmem(mem,size)	/* empty */
+#endif
+
+unsigned long memdebug_numblocks = 0;
+unsigned long memdebug_total = 0;
+unsigned long memdebug_maxmem = 0;
+unsigned long memdebug_memlimit = ULONG_MAX;
+
+
+static void *checkblock (void *block, size_t size) {
+  void *b = blockhead(block);
+  int i;
+  for (i=0;i&lt;MARKSIZE;i++)
+    lua_assert(*(cast(char *, b)+HEADER+size+i) == MARK+i); /* corrupted block? */
+  return b;
+}
+
+
+static void freeblock (void *block, size_t size) {
+  if (block) {
+    lua_assert(checkblocksize(block, size));
+    block = checkblock(block, size);
+    fillmem(block, size+HEADER+MARKSIZE);  /* erase block */
+    free(block);  /* free original block */
+    memdebug_numblocks--;
+    memdebug_total -= size;
+  }
+}
+
+
+void *debug_realloc (void *block, size_t oldsize, size_t size) {
+  lua_assert(oldsize == 0 || checkblocksize(block, oldsize));
+  /* ISO does not specify what realloc(NULL, 0) does */
+  lua_assert(block != NULL || size &gt; 0);
+  if (size == 0) {
+    freeblock(block, oldsize);
+    return NULL;
+  }
+  else if (size &gt; oldsize &amp;&amp; memdebug_total+size-oldsize &gt; memdebug_memlimit)
+    return NULL;  /* to test memory allocation errors */
+  else {
+    void *newblock;
+    int i;
+    size_t realsize = HEADER+size+MARKSIZE;
+    size_t commonsize = (oldsize &lt; size) ? oldsize : size;
+    if (realsize &lt; size) return NULL;  /* overflow! */
+    newblock = malloc(realsize);  /* alloc a new block */
+    if (newblock == NULL) return NULL;
+    if (block) {
+      memcpy(cast(char *, newblock)+HEADER, block, commonsize);
+      freeblock(block, oldsize);  /* erase (and check) old copy */
+    }
+    /* initialize new part of the block with something `weird' */
+    fillmem(cast(char *, newblock)+HEADER+commonsize, size-commonsize);
+    memdebug_total += size;
+    if (memdebug_total &gt; memdebug_maxmem)
+      memdebug_maxmem = memdebug_total;
+    memdebug_numblocks++;
+    setsize(newblock, size);
+    for (i=0;i&lt;MARKSIZE;i++)
+      *(cast(char *, newblock)+HEADER+size+i) = cast(char, MARK+i);
+    return cast(char *, newblock)+HEADER;
+  }
+}
+
+
+/* }====================================================================== */
+
+
+
+/*
+** {======================================================
+** Disassembler
+** =======================================================
+*/
+
+
+static char *buildop (Proto *p, int pc, char *buff) {
+  Instruction i = p-&gt;code[pc];
+  OpCode o = GET_OPCODE(i);
+  const char *name = luaP_opnames[o];
+  int line = getline(p, pc);
+  sprintf(buff, &quot;(%4d) %4d - &quot;, line, pc);
+  switch (getOpMode(o)) {  
+    case iABC:
+      sprintf(buff+strlen(buff), &quot;%-12s%4d %4d %4d&quot;, name,
+              GETARG_A(i), GETARG_B(i), GETARG_C(i));
+      break;
+    case iABx:
+      sprintf(buff+strlen(buff), &quot;%-12s%4d %4d&quot;, name, GETARG_A(i), GETARG_Bx(i));
+      break;
+    case iAsBx:
+      sprintf(buff+strlen(buff), &quot;%-12s%4d %4d&quot;, name, GETARG_A(i), GETARG_sBx(i));
+      break;
+  }
+  return buff;
+}
+
+
+#if 0
+void luaI_printcode (Proto *pt, int size) {
+  int pc;
+  for (pc=0; pc&lt;size; pc++) {
+    char buff[100];
+    printf(&quot;%s\n&quot;, buildop(pt, pc, buff));
+  }
+  printf(&quot;-------\n&quot;);
+}
+#endif
+
+
+static int listcode (lua_State *L) {
+  int pc;
+  Proto *p;
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1),
+                 1, &quot;Lua function expected&quot;);
+  p = clvalue(func_at(L, 1))-&gt;l.p;
+  lua_newtable(L);
+  setnameval(L, &quot;maxstack&quot;, p-&gt;maxstacksize);
+  setnameval(L, &quot;numparams&quot;, p-&gt;numparams);
+  for (pc=0; pc&lt;p-&gt;sizecode; pc++) {
+    char buff[100];
+    lua_pushintegral(L, pc+1);
+    lua_pushstring(L, buildop(p, pc, buff));
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listk (lua_State *L) {
+  Proto *p;
+  int i;
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1),
+                 1, &quot;Lua function expected&quot;);
+  p = clvalue(func_at(L, 1))-&gt;l.p;
+  lua_newtable(L);
+  for (i=0; i&lt;p-&gt;sizek; i++) {
+    lua_pushintegral(L, i+1);
+    luaA_pushobject(L, p-&gt;k+i);
+    lua_settable(L, -3);
+  }
+  return 1;
+}
+
+
+static int listlocals (lua_State *L) {
+  Proto *p;
+  int pc = luaL_checkint(L, 2) - 1;
+  int i = 0;
+  const char *name;
+  luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1),
+                 1, &quot;Lua function expected&quot;);
+  p = clvalue(func_at(L, 1))-&gt;l.p;
+  while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)
+    lua_pushstring(L, name);
+  return i-1;
+}
+
+/* }====================================================== */
+
+
+
+
+static int get_limits (lua_State *L) {
+  lua_newtable(L);
+  setnameval(L, &quot;BITS_INT&quot;, BITS_INT);
+  setnameval(L, &quot;LFPF&quot;, LFIELDS_PER_FLUSH);
+  setnameval(L, &quot;MAXVARS&quot;, MAXVARS);
+  setnameval(L, &quot;MAXPARAMS&quot;, MAXPARAMS);
+  setnameval(L, &quot;MAXSTACK&quot;, MAXSTACK);
+  setnameval(L, &quot;MAXUPVALUES&quot;, MAXUPVALUES);
+  return 1;
+}
+
+
+static int mem_query (lua_State *L) {
+  if (lua_isnone(L, 1)) {
+    lua_pushintegral(L, memdebug_total);
+    lua_pushintegral(L, memdebug_numblocks);
+    lua_pushintegral(L, memdebug_maxmem);
+    return 3;
+  }
+  else {
+    memdebug_memlimit = luaL_checkint(L, 1);
+    return 0;
+  }
+}
+
+
+static int hash_query (lua_State *L) {
+  if (lua_isnone(L, 2)) {
+    luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, &quot;string expected&quot;);
+    lua_pushintegral(L, tsvalue(func_at(L, 1))-&gt;tsv.hash);
+  }
+  else {
+    TObject *o = func_at(L, 1);
+    Table *t;
+    luaL_checktype(L, 2, LUA_TTABLE);
+    t = hvalue(func_at(L, 2));
+    lua_pushintegral(L, luaH_mainposition(t, o) - t-&gt;node);
+  }
+  return 1;
+}
+
+
+static int stacklevel (lua_State *L) {
+  unsigned long a = 0;
+  lua_pushintegral(L, (int)(L-&gt;top - L-&gt;stack));
+  lua_pushintegral(L, (int)(L-&gt;stack_last - L-&gt;stack));
+  lua_pushintegral(L, (int)(L-&gt;ci - L-&gt;base_ci));
+  lua_pushintegral(L, (int)(L-&gt;end_ci - L-&gt;base_ci));
+  lua_pushintegral(L, (unsigned long)&amp;a);
+  return 5;
+}
+
+
+static int table_query (lua_State *L) {
+  const Table *t;
+  int i = luaL_optint(L, 2, -1);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  t = hvalue(func_at(L, 1));
+  if (i == -1) {
+    lua_pushintegral(L, t-&gt;sizearray);
+    lua_pushintegral(L, sizenode(t));
+    lua_pushintegral(L, t-&gt;firstfree - t-&gt;node);
+  }
+  else if (i &lt; t-&gt;sizearray) {
+    lua_pushintegral(L, i);
+    luaA_pushobject(L, &amp;t-&gt;array[i]);
+    lua_pushnil(L); 
+  }
+  else if ((i -= t-&gt;sizearray) &lt; sizenode(t)) {
+    if (!ttisnil(gval(gnode(t, i))) ||
+        ttisnil(gkey(gnode(t, i))) ||
+        ttisnumber(gkey(gnode(t, i)))) {
+      luaA_pushobject(L, gkey(gnode(t, i)));
+    }
+    else
+      lua_pushstring(L, &quot;&lt;undef&gt;&quot;);
+    luaA_pushobject(L, gval(gnode(t, i)));
+    if (t-&gt;node[i].next)
+      lua_pushintegral(L, t-&gt;node[i].next - t-&gt;node);
+    else
+      lua_pushnil(L);
+  }
+  return 3;
+}
+
+
+static int string_query (lua_State *L) {
+  stringtable *tb = &amp;G(L)-&gt;strt;
+  int s = luaL_optint(L, 2, 0) - 1;
+  if (s==-1) {
+    lua_pushintegral(L ,tb-&gt;nuse);
+    lua_pushintegral(L ,tb-&gt;size);
+    return 2;
+  }
+  else if (s &lt; tb-&gt;size) {
+    GCObject *ts;
+    int n = 0;
+    for (ts = tb-&gt;hash[s]; ts; ts = ts-&gt;gch.next) {
+      setsvalue2s(L-&gt;top, gcotots(ts));
+      incr_top(L);
+      n++;
+    }
+    return n;
+  }
+  return 0;
+}
+
+
+static int tref (lua_State *L) {
+  int level = lua_gettop(L);
+  int lock = luaL_optint(L, 2, 1);
+  luaL_checkany(L, 1);
+  lua_pushvalue(L, 1);
+  lua_pushintegral(L, lua_ref(L, lock));
+  assert(lua_gettop(L) == level+1);  /* +1 for result */
+  return 1;
+}
+
+static int getref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_getref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level+1);
+  return 1;
+}
+
+static int unref (lua_State *L) {
+  int level = lua_gettop(L);
+  lua_unref(L, luaL_checkint(L, 1));
+  assert(lua_gettop(L) == level);
+  return 0;
+}
+
+static int metatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (lua_isnone(L, 2)) {
+    if (lua_getmetatable(L, 1) == 0)
+      lua_pushnil(L);
+  }
+  else {
+    lua_settop(L, 2);
+    luaL_checktype(L, 2, LUA_TTABLE);
+    lua_setmetatable(L, 1);
+  }
+  return 1;
+}
+
+
+static int upvalue (lua_State *L) {
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  if (lua_isnone(L, 3)) {
+    const char *name = lua_getupvalue(L, 1, n);
+    if (name == NULL) return 0;
+    lua_pushstring(L, name);
+    return 2;
+  }
+  else {
+    const char *name = lua_setupvalue(L, 1, n);
+    lua_pushstring(L, name);
+    return 1;
+  }
+}
+
+
+static int newuserdata (lua_State *L) {
+  size_t size = luaL_checkint(L, 1);
+  char *p = cast(char *, lua_newuserdata(L, size));
+  while (size--) *p++ = '\0';
+  return 1;
+}
+
+
+static int pushuserdata (lua_State *L) {
+  lua_pushlightuserdata(L, cast(void *, luaL_checkint(L, 1)));
+  return 1;
+}
+
+
+static int udataval (lua_State *L) {
+  lua_pushintegral(L, cast(int, lua_touserdata(L, 1)));
+  return 1;
+}
+
+
+static int doonnewstack (lua_State *L) {
+  lua_State *L1 = lua_newthread(L);
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &amp;l);
+  int status = luaL_loadbuffer(L1, s, l, s);
+  if (status == 0)
+    status = lua_pcall(L1, 0, 0, 0);
+  lua_pushintegral(L, status);
+  return 1;
+}
+
+
+static int s2d (lua_State *L) {
+  lua_pushnumber(L, *cast(const double *, luaL_checkstring(L, 1)));
+  return 1;
+}
+
+static int d2s (lua_State *L) {
+  double d = luaL_checknumber(L, 1);
+  lua_pushlstring(L, cast(char *, &amp;d), sizeof(d));
+  return 1;
+}
+
+
+static int newstate (lua_State *L) {
+  lua_State *L1 = lua_open();
+  if (L1) {
+    lua_userstateopen(L1);  /* init lock */
+    lua_pushintegral(L, (unsigned long)L1);
+  }
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+
+static int loadlib (lua_State *L) {
+  static const luaL_reg libs[] = {
+    {&quot;mathlibopen&quot;, luaopen_math},
+    {&quot;strlibopen&quot;, luaopen_string},
+    {&quot;iolibopen&quot;, luaopen_io},
+    {&quot;tablibopen&quot;, luaopen_table},
+    {&quot;dblibopen&quot;, luaopen_debug},
+    {&quot;baselibopen&quot;, luaopen_base},
+    {NULL, NULL}
+  };
+  lua_State *L1 = cast(lua_State *,
+                       cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_pushvalue(L1, LUA_GLOBALSINDEX);
+  luaL_openlib(L1, NULL, libs, 0);
+  return 0;
+}
+
+static int closestate (lua_State *L) {
+  lua_State *L1 = cast(lua_State *, cast(unsigned long, luaL_checknumber(L, 1)));
+  lua_close(L1);
+  lua_unlock(L);  /* close cannot unlock that */
+  return 0;
+}
+
+static int doremote (lua_State *L) {
+  lua_State *L1 = cast(lua_State *,cast(unsigned long,luaL_checknumber(L, 1)));
+  size_t lcode;
+  const char *code = luaL_checklstring(L, 2, &amp;lcode);
+  int status;
+  lua_settop(L1, 0);
+  status = luaL_loadbuffer(L1, code, lcode, code);
+  if (status == 0)
+    status = lua_pcall(L1, 0, LUA_MULTRET, 0);
+  if (status != 0) {
+    lua_pushnil(L);
+    lua_pushintegral(L, status);
+    lua_pushstring(L, lua_tostring(L1, -1));
+    return 3;
+  }
+  else {
+    int i = 0;
+    while (!lua_isnone(L1, ++i))
+      lua_pushstring(L, lua_tostring(L1, i));
+    lua_pop(L1, i-1);
+    return i-1;
+  }
+}
+
+
+static int log2_aux (lua_State *L) {
+  lua_pushintegral(L, luaO_log2(luaL_checkint(L, 1)));
+  return 1;
+}
+
+static int int2fb_aux (lua_State *L) {
+  int b = luaO_int2fb(luaL_checkint(L, 1));
+  lua_pushintegral(L, b);
+  lua_pushintegral(L, fb2int(b));
+  return 2;
+}
+
+
+static int test_do (lua_State *L) {
+  const char *p = luaL_checkstring(L, 1);
+  if (*p == '@')
+    lua_dofile(L, p+1);
+  else
+    lua_dostring(L, p);
+  return lua_gettop(L);
+}
+
+
+
+/*
+** {======================================================
+** function to test the API with C. It interprets a kind of assembler
+** language with calls to the API, so the test can be driven by Lua code
+** =======================================================
+*/
+
+static const char *const delimits = &quot; \t\n,;&quot;;
+
+static void skip (const char **pc) {
+  while (**pc != '\0' &amp;&amp; strchr(delimits, **pc)) (*pc)++;
+}
+
+static int getnum_aux (lua_State *L, const char **pc) {
+  int res = 0;
+  int sig = 1;
+  skip(pc);
+  if (**pc == '.') {
+    res = cast(int, lua_tonumber(L, -1));
+    lua_pop(L, 1);
+    (*pc)++;
+    return res;
+  }
+  else if (**pc == '-') {
+    sig = -1;
+    (*pc)++;
+  }
+  while (isdigit(cast(int, **pc))) res = res*10 + (*(*pc)++) - '0';
+  return sig*res;
+}
+  
+static const char *getname_aux (char *buff, const char **pc) {
+  int i = 0;
+  skip(pc);
+  while (**pc != '\0' &amp;&amp; !strchr(delimits, **pc))
+    buff[i++] = *(*pc)++;
+  buff[i] = '\0';
+  return buff;
+}
+
+
+#define EQ(s1)	(strcmp(s1, inst) == 0)
+
+#define getnum	(getnum_aux(L, &amp;pc))
+#define getname	(getname_aux(buff, &amp;pc))
+
+
+static int testC (lua_State *L) {
+  char buff[30];
+  const char *pc = luaL_checkstring(L, 1);
+  for (;;) {
+    const char *inst = getname;
+    if EQ(&quot;&quot;) return 0;
+    else if EQ(&quot;isnumber&quot;) {
+      lua_pushintegral(L, lua_isnumber(L, getnum));
+    }
+    else if EQ(&quot;isstring&quot;) {
+      lua_pushintegral(L, lua_isstring(L, getnum));
+    }
+    else if EQ(&quot;istable&quot;) {
+      lua_pushintegral(L, lua_istable(L, getnum));
+    }
+    else if EQ(&quot;iscfunction&quot;) {
+      lua_pushintegral(L, lua_iscfunction(L, getnum));
+    }
+    else if EQ(&quot;isfunction&quot;) {
+      lua_pushintegral(L, lua_isfunction(L, getnum));
+    }
+    else if EQ(&quot;isuserdata&quot;) {
+      lua_pushintegral(L, lua_isuserdata(L, getnum));
+    }
+    else if EQ(&quot;isudataval&quot;) {
+      lua_pushintegral(L, lua_islightuserdata(L, getnum));
+    }
+    else if EQ(&quot;isnil&quot;) {
+      lua_pushintegral(L, lua_isnil(L, getnum));
+    }
+    else if EQ(&quot;isnull&quot;) {
+      lua_pushintegral(L, lua_isnone(L, getnum));
+    }
+    else if EQ(&quot;tonumber&quot;) {
+      lua_pushnumber(L, lua_tonumber(L, getnum));
+    }
+    else if EQ(&quot;tostring&quot;) {
+      const char *s = lua_tostring(L, getnum);
+      lua_pushstring(L, s);
+    }
+    else if EQ(&quot;strlen&quot;) {
+      lua_pushintegral(L, lua_strlen(L, getnum));
+    }
+    else if EQ(&quot;tocfunction&quot;) {
+      lua_pushcfunction(L, lua_tocfunction(L, getnum));
+    }
+    else if EQ(&quot;return&quot;) {
+      return getnum;
+    }
+    else if EQ(&quot;gettop&quot;) {
+      lua_pushintegral(L, lua_gettop(L));
+    }
+    else if EQ(&quot;settop&quot;) {
+      lua_settop(L, getnum);
+    }
+    else if EQ(&quot;pop&quot;) {
+      lua_pop(L, getnum);
+    }
+    else if EQ(&quot;pushnum&quot;) {
+      lua_pushintegral(L, getnum);
+    }
+    else if EQ(&quot;pushnil&quot;) {
+      lua_pushnil(L);
+    }
+    else if EQ(&quot;pushbool&quot;) {
+      lua_pushboolean(L, getnum);
+    }
+    else if EQ(&quot;tobool&quot;) {
+      lua_pushintegral(L, lua_toboolean(L, getnum));
+    }
+    else if EQ(&quot;pushvalue&quot;) {
+      lua_pushvalue(L, getnum);
+    }
+    else if EQ(&quot;pushcclosure&quot;) {
+      lua_pushcclosure(L, testC, getnum);
+    }
+    else if EQ(&quot;pushupvalues&quot;) {
+      lua_pushupvalues(L);
+    }
+    else if EQ(&quot;remove&quot;) {
+      lua_remove(L, getnum);
+    }
+    else if EQ(&quot;insert&quot;) {
+      lua_insert(L, getnum);
+    }
+    else if EQ(&quot;replace&quot;) {
+      lua_replace(L, getnum);
+    }
+    else if EQ(&quot;gettable&quot;) {
+      lua_gettable(L, getnum);
+    }
+    else if EQ(&quot;settable&quot;) {
+      lua_settable(L, getnum);
+    }
+    else if EQ(&quot;next&quot;) {
+      lua_next(L, -2);
+    }
+    else if EQ(&quot;concat&quot;) {
+      lua_concat(L, getnum);
+    }
+    else if EQ(&quot;lessthan&quot;) {
+      int a = getnum;
+      lua_pushboolean(L, lua_lessthan(L, a, getnum));
+    }
+    else if EQ(&quot;equal&quot;) {
+      int a = getnum;
+      lua_pushboolean(L, lua_equal(L, a, getnum));
+    }
+    else if EQ(&quot;rawcall&quot;) {
+      int narg = getnum;
+      int nres = getnum;
+      lua_call(L, narg, nres);
+    }
+    else if EQ(&quot;call&quot;) {
+      int narg = getnum;
+      int nres = getnum;
+      lua_pcall(L, narg, nres, 0);
+    }
+    else if EQ(&quot;loadstring&quot;) {
+      size_t sl;
+      const char *s = luaL_checklstring(L, getnum, &amp;sl);
+      luaL_loadbuffer(L, s, sl, s);
+    }
+    else if EQ(&quot;loadfile&quot;) {
+      luaL_loadfile(L, luaL_checkstring(L, getnum));
+    }
+    else if EQ(&quot;setmetatable&quot;) {
+      lua_setmetatable(L, getnum);
+    }
+    else if EQ(&quot;getmetatable&quot;) {
+      if (lua_getmetatable(L, getnum) == 0)
+        lua_pushnil(L);
+    }
+    else if EQ(&quot;type&quot;) {
+      lua_pushstring(L, lua_typename(L, lua_type(L, getnum)));
+    }
+    else if EQ(&quot;getn&quot;) {
+      int i = getnum;
+      lua_pushintegral(L, luaL_getn(L, i));
+    }
+    else if EQ(&quot;setn&quot;) {
+      int i = getnum;
+      int n = cast(int, lua_tonumber(L, -1));
+      luaL_setn(L, i, n);
+      lua_pop(L, 1);
+    }
+    else luaL_error(L, &quot;unknown instruction %s&quot;, buff);
+  }
+  return 0;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** tests for yield inside hooks
+** =======================================================
+*/
+
+static void yieldf (lua_State *L, lua_Debug *ar) {
+  lua_yield(L, 0);
+}
+
+static int setyhook (lua_State *L) {
+  if (lua_isnoneornil(L, 1))
+    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */
+  else {
+    const char *smask = luaL_checkstring(L, 1);
+    int count = luaL_optint(L, 2, 0);
+    int mask = 0;
+    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+    if (count &gt; 0) mask |= LUA_MASKCOUNT;
+    lua_sethook(L, yieldf, mask, count);
+  }
+  return 0;
+}
+
+
+static int coresume (lua_State *L) {
+  int status;
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
+  status = lua_resume(co, 0);
+  if (status != 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+}
+
+/* }====================================================== */
+
+
+
+static const struct luaL_reg tests_funcs[] = {
+  {&quot;hash&quot;, hash_query},
+  {&quot;limits&quot;, get_limits},
+  {&quot;listcode&quot;, listcode},
+  {&quot;listk&quot;, listk},
+  {&quot;listlocals&quot;, listlocals},
+  {&quot;loadlib&quot;, loadlib},
+  {&quot;stacklevel&quot;, stacklevel},
+  {&quot;querystr&quot;, string_query},
+  {&quot;querytab&quot;, table_query},
+  {&quot;doit&quot;, test_do},
+  {&quot;testC&quot;, testC},
+  {&quot;ref&quot;, tref},
+  {&quot;getref&quot;, getref},
+  {&quot;unref&quot;, unref},
+  {&quot;d2s&quot;, d2s},
+  {&quot;s2d&quot;, s2d},
+  {&quot;metatable&quot;, metatable},
+  {&quot;upvalue&quot;, upvalue},
+  {&quot;newuserdata&quot;, newuserdata},
+  {&quot;pushuserdata&quot;, pushuserdata},
+  {&quot;udataval&quot;, udataval},
+  {&quot;doonnewstack&quot;, doonnewstack},
+  {&quot;newstate&quot;, newstate},
+  {&quot;closestate&quot;, closestate},
+  {&quot;doremote&quot;, doremote},
+  {&quot;log2&quot;, log2_aux},
+  {&quot;int2fb&quot;, int2fb_aux},
+  {&quot;totalmem&quot;, mem_query},
+  {&quot;resume&quot;, coresume},
+  {&quot;setyhook&quot;, setyhook},
+  {NULL, NULL}
+};
+
+
+static void fim (void) {
+  if (!islocked)
+    lua_close(lua_state);
+  lua_assert(memdebug_numblocks == 0);
+  lua_assert(memdebug_total == 0);
+}
+
+
+static int l_panic (lua_State *L) {
+  UNUSED(L);
+  fprintf(stderr, &quot;unable to recover; exiting\n&quot;);
+  return 0;
+}
+
+
+int luaB_opentests (lua_State *L) {
+  lua_atpanic(L, l_panic);
+  lua_userstateopen(L);  /* init lock */
+  lua_state = L;  /* keep first state to be opened */
+  luaL_openlib(L, &quot;T&quot;, tests_funcs, 0);
+  atexit(fim);
+  return 0;
+}
+
+
+#undef main
+int main (int argc, char *argv[]) {
+  char *limit = getenv(&quot;MEMLIMIT&quot;);
+  if (limit)
+    memdebug_memlimit = strtoul(limit, NULL, 10);
+  l_main(argc, argv);
+  return 0;
+}
+
+#endif

Added: trunk/source/libraries/lua/ltm.c
===================================================================
--- trunk/source/libraries/lua/ltm.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltm.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,70 @@
+/*
+** $Id: ltm.c,v 1.106 2003/04/03 13:35:34 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define ltm_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;lobject.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+
+
+
+const char *const luaT_typenames[] = {
+  &quot;nil&quot;, &quot;boolean&quot;, &quot;userdata&quot;, &quot;number&quot;,
+  &quot;string&quot;, &quot;table&quot;, &quot;function&quot;, &quot;userdata&quot;, &quot;thread&quot;
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    &quot;__index&quot;, &quot;__newindex&quot;,
+    &quot;__gc&quot;, &quot;__mode&quot;, &quot;__eq&quot;,
+    &quot;__add&quot;, &quot;__sub&quot;, &quot;__mul&quot;, &quot;__div&quot;,
+    &quot;__pow&quot;, &quot;__unm&quot;, &quot;__lt&quot;, &quot;__le&quot;,
+    &quot;__concat&quot;, &quot;__call&quot;
+  };
+  int i;
+  for (i=0; i&lt;TM_N; i++) {
+    G(L)-&gt;tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)-&gt;tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro &quot;fasttm&quot;: optimized for absence of
+** tag methods
+*/
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TObject *tm = luaH_getstr(events, ename);
+  lua_assert(event &lt;= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events-&gt;flags |= cast(lu_byte, 1u&lt;&lt;event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event) {
+  TString *ename = G(L)-&gt;tmname[event];
+  switch (ttype(o)) {
+    case LUA_TTABLE:
+      return luaH_getstr(hvalue(o)-&gt;metatable, ename);
+    case LUA_TUSERDATA:
+      return luaH_getstr(uvalue(o)-&gt;uv.metatable, ename);
+    default:
+      return &amp;luaO_nilobject;
+  }
+}
+

Added: trunk/source/libraries/lua/ltm.h
===================================================================
--- trunk/source/libraries/lua/ltm.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/ltm.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,51 @@
+/*
+** $Id: ltm.h,v 1.41 2002/11/14 11:51:50 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include &quot;lobject.h&quot;
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep &quot;ORDER TM&quot;
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) \
+  (((et)-&gt;flags &amp; (1u&lt;&lt;(e))) ? NULL : luaT_gettm(et, e, (g)-&gt;tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+
+const TObject *luaT_gettm (Table *events, TMS event, TString *ename);
+const TObject *luaT_gettmbyobj (lua_State *L, const TObject *o, TMS event);
+void luaT_init (lua_State *L);
+
+extern const char *const luaT_typenames[];
+
+#endif

Added: trunk/source/libraries/lua/lua.h
===================================================================
--- trunk/source/libraries/lua/lua.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lua.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,391 @@
+/*
+** $Id: lua.h,v 1.175 2003/03/18 12:31:39 roberto Exp $
+** Lua - An Extensible Extension Language
+** Tecgraf: Computer Graphics Technology Group, PUC-Rio, Brazil
+** <A HREF="http://www.lua.org">http://www.lua.org</A>	mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">info at lua.org</A>
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include &lt;stdarg.h&gt;
+#include &lt;stddef.h&gt;
+
+
+#define LUA_VERSION	&quot;Lua 5.0&quot;
+#define LUA_COPYRIGHT	&quot;Copyright (C) 1994-2003 Tecgraf, PUC-Rio&quot;
+#define LUA_AUTHORS 	&quot;R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes&quot;
+
+
+
+/* option for multiple returns in `lua_pcall' and `lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	(-10000)
+#define LUA_GLOBALSINDEX	(-10001)
+#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))
+
+
+/* error codes for `lua_load' and `lua_pcall' */
+#define LUA_ERRRUN	1
+#define LUA_ERRFILE	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRERR	5
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Chunkreader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Chunkwriter) (lua_State *L, const void* p,
+                                size_t sz, void* ud);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE	(-1)
+
+#define LUA_TNIL	0
+#define LUA_TBOOLEAN	1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER	3
+#define LUA_TSTRING	4
+#define LUA_TTABLE	5
+#define LUA_TFUNCTION	6
+#define LUA_TUSERDATA	7
+#define LUA_TTHREAD	8
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/*
+** generic extra include file
+*/
+#ifdef LUA_USER_H
+#include LUA_USER_H
+#endif
+
+
+/* type of numbers in Lua */
+#ifndef LUA_NUMBER
+typedef double lua_Number;
+#else
+typedef LUA_NUMBER lua_Number;
+#endif
+
+
+/* mark for all API functions */
+#ifndef LUA_API
+#define LUA_API		extern
+#endif
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *lua_open (void);
+LUA_API void       lua_close (lua_State *L);
+LUA_API lua_State *lua_newthread (lua_State *L);
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   lua_gettop (lua_State *L);
+LUA_API void  lua_settop (lua_State *L, int idx);
+LUA_API void  lua_pushvalue (lua_State *L, int idx);
+LUA_API void  lua_remove (lua_State *L, int idx);
+LUA_API void  lua_insert (lua_State *L, int idx);
+LUA_API void  lua_replace (lua_State *L, int idx);
+LUA_API int   lua_checkstack (lua_State *L, int sz);
+
+LUA_API void  lua_xmove (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -&gt; C)
+*/
+
+LUA_API int             lua_isnumber (lua_State *L, int idx);
+LUA_API int             lua_isstring (lua_State *L, int idx);
+LUA_API int             lua_iscfunction (lua_State *L, int idx);
+LUA_API int             lua_isuserdata (lua_State *L, int idx);
+LUA_API int             lua_type (lua_State *L, int idx);
+LUA_API const char     *lua_typename (lua_State *L, int tp);
+
+LUA_API int            lua_equal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_rawequal (lua_State *L, int idx1, int idx2);
+LUA_API int            lua_lessthan (lua_State *L, int idx1, int idx2);
+
+LUA_API lua_Number      lua_tonumber (lua_State *L, int idx);
+LUA_API int             lua_toboolean (lua_State *L, int idx);
+LUA_API const char     *lua_tostring (lua_State *L, int idx);
+LUA_API size_t          lua_strlen (lua_State *L, int idx);
+LUA_API lua_CFunction   lua_tocfunction (lua_State *L, int idx);
+LUA_API void	       *lua_touserdata (lua_State *L, int idx);
+LUA_API lua_State      *lua_tothread (lua_State *L, int idx);
+LUA_API const void     *lua_topointer (lua_State *L, int idx);
+
+
+/*
+** push functions (C -&gt; stack)
+*/
+LUA_API void  lua_pushnil (lua_State *L);
+LUA_API void  lua_pushnumber (lua_State *L, lua_Number n);
+LUA_API void  lua_pushlstring (lua_State *L, const char *s, size_t l);
+LUA_API void  lua_pushstring (lua_State *L, const char *s);
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                                    va_list argp);
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...);
+LUA_API void  lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  lua_pushboolean (lua_State *L, int b);
+LUA_API void  lua_pushlightuserdata (lua_State *L, void *p);
+
+
+/*
+** get functions (Lua -&gt; stack)
+*/
+LUA_API void  lua_gettable (lua_State *L, int idx);
+LUA_API void  lua_rawget (lua_State *L, int idx);
+LUA_API void  lua_rawgeti (lua_State *L, int idx, int n);
+LUA_API void  lua_newtable (lua_State *L);
+LUA_API void *lua_newuserdata (lua_State *L, size_t sz);
+LUA_API int   lua_getmetatable (lua_State *L, int objindex);
+LUA_API void  lua_getfenv (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -&gt; Lua)
+*/
+LUA_API void  lua_settable (lua_State *L, int idx);
+LUA_API void  lua_rawset (lua_State *L, int idx);
+LUA_API void  lua_rawseti (lua_State *L, int idx, int n);
+LUA_API int   lua_setmetatable (lua_State *L, int objindex);
+LUA_API int   lua_setfenv (lua_State *L, int idx);
+
+
+/*
+** `load' and `call' functions (load and run Lua code)
+*/
+LUA_API void  lua_call (lua_State *L, int nargs, int nresults);
+LUA_API int   lua_pcall (lua_State *L, int nargs, int nresults, int errfunc);
+LUA_API int lua_cpcall (lua_State *L, lua_CFunction func, void *ud);
+LUA_API int   lua_load (lua_State *L, lua_Chunkreader reader, void *dt,
+                        const char *chunkname);
+
+LUA_API int lua_dump (lua_State *L, lua_Chunkwriter writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  lua_yield (lua_State *L, int nresults);
+LUA_API int  lua_resume (lua_State *L, int narg);
+
+/*
+** garbage-collection functions
+*/
+LUA_API int   lua_getgcthreshold (lua_State *L);
+LUA_API int   lua_getgccount (lua_State *L);
+LUA_API void  lua_setgcthreshold (lua_State *L, int newthreshold);
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API const char *lua_version (void);
+
+LUA_API int   lua_error (lua_State *L);
+
+LUA_API int   lua_next (lua_State *L, int idx);
+
+LUA_API void  lua_concat (lua_State *L, int n);
+
+
+
+/* 
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_boxpointer(L,u) \
+	(*(void **)(lua_newuserdata(L, sizeof(void *))) = (u))
+
+#define lua_unboxpointer(L,i)	(*(void **)(lua_touserdata(L, i)))
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_register(L,n,f) \
+	(lua_pushstring(L, n), \
+	 lua_pushcfunction(L, f), \
+	 lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, f, 0)
+
+#define lua_isfunction(L,n)	(lua_type(L,n) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L,n) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L,n) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L,n) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L,n) == LUA_TBOOLEAN)
+#define lua_isnone(L,n)		(lua_type(L,n) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L,n) &lt;= 0)
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, &quot;&quot; s, (sizeof(s)/sizeof(char))-1)
+
+
+
+/*
+** compatibility macros and functions
+*/
+
+
+LUA_API int lua_pushupvalues (lua_State *L);
+
+#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)
+#define lua_setglobal(L,s)	\
+   (lua_pushstring(L, s), lua_insert(L, -2), lua_settable(L, LUA_GLOBALSINDEX))
+
+#define lua_getglobal(L,s)	\
+		(lua_pushstring(L, s), lua_gettable(L, LUA_GLOBALSINDEX))
+
+
+/* compatibility with ref system */
+
+/* pre-defined references */
+#define LUA_NOREF	(-2)
+#define LUA_REFNIL	(-1)
+
+#define lua_ref(L,lock)	((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
+      (lua_pushstring(L, &quot;unlocked references are obsolete&quot;), lua_error(L), 0))
+
+#define lua_unref(L,ref)	luaL_unref(L, LUA_REGISTRYINDEX, (ref))
+
+#define lua_getref(L,ref)	lua_rawgeti(L, LUA_REGISTRYINDEX, ref)
+
+
+
+/*
+** {======================================================================
+** useful definitions for Lua kernel and libraries
+** =======================================================================
+*/
+
+/* formats for Lua numbers */
+#ifndef LUA_NUMBER_SCAN
+#define LUA_NUMBER_SCAN		&quot;%lf&quot;
+#endif
+
+#ifndef LUA_NUMBER_FMT
+#define LUA_NUMBER_FMT		&quot;%.14g&quot;
+#endif
+
+/* }====================================================================== */
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILRET 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 &lt;&lt; LUA_HOOKCALL)
+#define LUA_MASKRET	(1 &lt;&lt; LUA_HOOKRET)
+#define LUA_MASKLINE	(1 &lt;&lt; LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 &lt;&lt; LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);
+
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook lua_gethook (lua_State *L);
+LUA_API int lua_gethookmask (lua_State *L);
+LUA_API int lua_gethookcount (lua_State *L);
+
+
+#define LUA_IDSIZE	60
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) `global', `local', `field', `method' */
+  const char *what;	/* (S) `Lua', `C', `main', `tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int nups;		/* (u) number of upvalues */
+  int linedefined;	/* (S) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  int i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2003 Tecgraf, PUC-Rio.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* &quot;Software&quot;), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif

Added: trunk/source/libraries/lua/lualib.h
===================================================================
--- trunk/source/libraries/lua/lualib.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lualib.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,56 @@
+/*
+** $Id: lualib.h,v 1.28 2003/03/18 12:24:26 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include &quot;lua.h&quot;
+
+
+#ifndef LUALIB_API
+#define LUALIB_API	LUA_API
+#endif
+
+
+#define LUA_COLIBNAME	&quot;coroutine&quot;
+LUALIB_API int luaopen_base (lua_State *L);
+
+#define LUA_TABLIBNAME	&quot;table&quot;
+LUALIB_API int luaopen_table (lua_State *L);
+
+#define LUA_IOLIBNAME	&quot;io&quot;
+#define LUA_OSLIBNAME	&quot;os&quot;
+LUALIB_API int luaopen_io (lua_State *L);
+
+#define LUA_STRLIBNAME	&quot;string&quot;
+LUALIB_API int luaopen_string (lua_State *L);
+
+#define LUA_MATHLIBNAME	&quot;math&quot;
+LUALIB_API int luaopen_math (lua_State *L);
+
+#define LUA_DBLIBNAME	&quot;debug&quot;
+LUALIB_API int luaopen_debug (lua_State *L);
+
+
+LUALIB_API int luaopen_loadlib (lua_State *L);
+
+
+/* to help testing the libraries */
+#ifndef lua_assert
+#define lua_assert(c)		/* empty */
+#endif
+
+
+/* compatibility code */
+#define lua_baselibopen	luaopen_base
+#define lua_tablibopen	luaopen_table
+#define lua_iolibopen	luaopen_io
+#define lua_strlibopen	luaopen_string
+#define lua_mathlibopen	luaopen_math
+#define lua_dblibopen	luaopen_debug
+
+#endif

Added: trunk/source/libraries/lua/lundump.c
===================================================================
--- trunk/source/libraries/lua/lundump.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lundump.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,286 @@
+/*
+** $Id: lundump.c,v 1.49 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#define lundump_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;lundump.h&quot;
+#include &quot;lzio.h&quot;
+
+#define	LoadByte	(lu_byte) ezgetc
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ int swap;
+ const char* name;
+} LoadState;
+
+static void unexpectedEOZ (LoadState* S)
+{
+ luaG_runerror(S-&gt;L,&quot;unexpected end of file in %s&quot;,S-&gt;name);
+}
+
+static int ezgetc (LoadState* S)
+{
+ int c=zgetc(S-&gt;Z);
+ if (c==EOZ) unexpectedEOZ(S);
+ return c;
+}
+
+static void ezread (LoadState* S, void* b, int n)
+{
+ int r=luaZ_read(S-&gt;Z,b,n);
+ if (r!=0) unexpectedEOZ(S);
+}
+
+static void LoadBlock (LoadState* S, void* b, size_t size)
+{
+ if (S-&gt;swap)
+ {
+  char* p=(char*) b+size-1;
+  int n=size;
+  while (n--) *p--=(char)ezgetc(S);
+ }
+ else
+  ezread(S,b,size);
+}
+
+static void LoadVector (LoadState* S, void* b, int m, size_t size)
+{
+ if (S-&gt;swap)
+ {
+  char* q=(char*) b;
+  while (m--)
+  {
+   char* p=q+size-1;
+   int n=size;
+   while (n--) *p--=(char)ezgetc(S);
+   q+=size;
+  }
+ }
+ else
+  ezread(S,b,m*size);
+}
+
+static int LoadInt (LoadState* S)
+{
+ int x;
+ LoadBlock(S,&amp;x,sizeof(x));
+ if (x&lt;0) luaG_runerror(S-&gt;L,&quot;bad integer in %s&quot;,S-&gt;name);
+ return x;
+}
+
+static size_t LoadSize (LoadState* S)
+{
+ size_t x;
+ LoadBlock(S,&amp;x,sizeof(x));
+ return x;
+}
+
+static lua_Number LoadNumber (LoadState* S)
+{
+ lua_Number x;
+ LoadBlock(S,&amp;x,sizeof(x));
+ return x;
+}
+
+static TString* LoadString (LoadState* S)
+{
+ size_t size=LoadSize(S);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S-&gt;L,S-&gt;b,size);
+  ezread(S,s,size);
+  return luaS_newlstr(S-&gt;L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f-&gt;code=luaM_newvector(S-&gt;L,size,Instruction);
+ f-&gt;sizecode=size;
+ LoadVector(S,f-&gt;code,size,sizeof(*f-&gt;code));
+}
+
+static void LoadLocals (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f-&gt;locvars=luaM_newvector(S-&gt;L,n,LocVar);
+ f-&gt;sizelocvars=n;
+ for (i=0; i&lt;n; i++)
+ {
+  f-&gt;locvars[i].varname=LoadString(S);
+  f-&gt;locvars[i].startpc=LoadInt(S);
+  f-&gt;locvars[i].endpc=LoadInt(S);
+ }
+}
+
+static void LoadLines (LoadState* S, Proto* f)
+{
+ int size=LoadInt(S);
+ f-&gt;lineinfo=luaM_newvector(S-&gt;L,size,int);
+ f-&gt;sizelineinfo=size;
+ LoadVector(S,f-&gt;lineinfo,size,sizeof(*f-&gt;lineinfo));
+}
+
+static void LoadUpvalues (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ if (n!=0 &amp;&amp; n!=f-&gt;nups) 
+  luaG_runerror(S-&gt;L,&quot;bad nupvalues in %s: read %d; expected %d&quot;,
+		S-&gt;name,n,f-&gt;nups);
+ f-&gt;upvalues=luaM_newvector(S-&gt;L,n,TString*);
+ f-&gt;sizeupvalues=n;
+ for (i=0; i&lt;n; i++) f-&gt;upvalues[i]=LoadString(S);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p);
+
+static void LoadConstants (LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f-&gt;k=luaM_newvector(S-&gt;L,n,TObject);
+ f-&gt;sizek=n;
+ for (i=0; i&lt;n; i++)
+ {
+  TObject* o=&amp;f-&gt;k[i];
+  int t=LoadByte(S);
+  switch (t)
+  {
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(o,LoadString(S));
+	break;
+   case LUA_TNIL:
+   	setnilvalue(o);
+	break;
+   default:
+	luaG_runerror(S-&gt;L,&quot;bad constant type (%d) in %s&quot;,t,S-&gt;name);
+	break;
+  }
+ }
+ n=LoadInt(S);
+ f-&gt;p=luaM_newvector(S-&gt;L,n,Proto*);
+ f-&gt;sizep=n;
+ for (i=0; i&lt;n; i++) f-&gt;p[i]=LoadFunction(S,f-&gt;source);
+}
+
+static Proto* LoadFunction (LoadState* S, TString* p)
+{
+ Proto* f=luaF_newproto(S-&gt;L);
+ f-&gt;source=LoadString(S); if (f-&gt;source==NULL) f-&gt;source=p;
+ f-&gt;lineDefined=LoadInt(S);
+ f-&gt;nups=LoadByte(S);
+ f-&gt;numparams=LoadByte(S);
+ f-&gt;is_vararg=LoadByte(S);
+ f-&gt;maxstacksize=LoadByte(S);
+ LoadLines(S,f);
+ LoadLocals(S,f);
+ LoadUpvalues(S,f);
+ LoadConstants(S,f);
+ LoadCode(S,f);
+#ifndef TRUST_BINARIES
+ if (!luaG_checkcode(f)) luaG_runerror(S-&gt;L,&quot;bad code in %s&quot;,S-&gt;name);
+#endif
+ return f;
+}
+
+static void LoadSignature (LoadState* S)
+{
+ const char* s=LUA_SIGNATURE;
+ while (*s!=0 &amp;&amp; ezgetc(S)==*s)
+  ++s;
+ if (*s!=0) luaG_runerror(S-&gt;L,&quot;bad signature in %s&quot;,S-&gt;name);
+}
+
+static void TestSize (LoadState* S, int s, const char* what)
+{
+ int r=LoadByte(S);
+ if (r!=s)
+  luaG_runerror(S-&gt;L,&quot;virtual machine mismatch in %s: &quot;
+	&quot;size of %s is %d but read %d&quot;,S-&gt;name,what,s,r);
+}
+
+#define TESTSIZE(s,w)	TestSize(S,s,w)
+#define V(v)		v/16,v%16
+
+static void LoadHeader (LoadState* S)
+{
+ int version;
+ lua_Number x,tx=TEST_NUMBER;
+ LoadSignature(S);
+ version=LoadByte(S);
+ if (version&gt;VERSION)
+  luaG_runerror(S-&gt;L,&quot;%s too new: &quot;
+	&quot;read version %d.%d; expected at most %d.%d&quot;,
+	S-&gt;name,V(version),V(VERSION));
+ if (version&lt;VERSION0)				/* check last major change */
+  luaG_runerror(S-&gt;L,&quot;%s too old: &quot;
+	&quot;read version %d.%d; expected at least %d.%d&quot;,
+	S-&gt;name,V(version),V(VERSION0));
+ S-&gt;swap=(luaU_endianness()!=LoadByte(S));	/* need to swap bytes? */
+ TESTSIZE(sizeof(int),&quot;int&quot;);
+ TESTSIZE(sizeof(size_t), &quot;size_t&quot;);
+ TESTSIZE(sizeof(Instruction), &quot;Instruction&quot;);
+ TESTSIZE(SIZE_OP, &quot;OP&quot;);
+ TESTSIZE(SIZE_A, &quot;A&quot;);
+ TESTSIZE(SIZE_B, &quot;B&quot;);
+ TESTSIZE(SIZE_C, &quot;C&quot;);
+ TESTSIZE(sizeof(lua_Number), &quot;number&quot;);
+ x=LoadNumber(S);
+ if ((long)x!=(long)tx)		/* disregard errors in last bits of fraction */
+  luaG_runerror(S-&gt;L,&quot;unknown number format in %s&quot;,S-&gt;name);
+}
+
+static Proto* LoadChunk (LoadState* S)
+{
+ LoadHeader(S);
+ return LoadFunction(S,NULL);
+}
+
+/*
+** load precompiled chunk
+*/
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff)
+{
+ LoadState S;
+ const char* s=zname(Z);
+ if (*s=='@' || *s=='=')
+  S.name=s+1;
+ else if (*s==LUA_SIGNATURE[0])
+  S.name=&quot;binary string&quot;;
+ else
+  S.name=s;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ return LoadChunk(&amp;S);
+}
+
+/*
+** find byte order
+*/
+int luaU_endianness (void)
+{
+ int x=1;
+ return *(char*)&x;
+}

Added: trunk/source/libraries/lua/lundump.h
===================================================================
--- trunk/source/libraries/lua/lundump.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lundump.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,34 @@
+/*
+** $Id: lundump.h,v 1.30 2003/04/07 20:34:20 lhf Exp $
+** load pre-compiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include &quot;lobject.h&quot;
+#include &quot;lzio.h&quot;
+
+/* load one chunk; from lundump.c */
+Proto* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff);
+
+/* find byte order; from lundump.c */
+int luaU_endianness (void);
+
+/* dump one chunk; from ldump.c */
+void luaU_dump (lua_State* L, const Proto* Main, lua_Chunkwriter w, void* data);
+
+/* print one chunk; from print.c */
+void luaU_print (const Proto* Main);
+
+/* definitions for headers of binary files */
+#define	LUA_SIGNATURE	&quot;\033Lua&quot;	/* binary files start with &quot;&lt;esc&gt;Lua&quot; */
+#define	VERSION		0x50		/* last format change was in 5.0 */
+#define	VERSION0	0x50		/* last major  change was in 5.0 */
+
+/* a multiple of PI for testing native format */
+/* multiplying by 1E7 gives non-trivial integer values */
+#define	TEST_NUMBER	((lua_Number)3.14159265358979323846E7)
+
+#endif

Added: trunk/source/libraries/lua/lvm.c
===================================================================
--- trunk/source/libraries/lua/lvm.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lvm.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,780 @@
+/*
+** $Id: lvm.c,v 1.284 2003/04/03 13:35:34 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;stdarg.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+/* needed only when `lua_number2str' uses `sprintf' */
+#include &lt;stdio.h&gt;
+
+#define lvm_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;ldebug.h&quot;
+#include &quot;ldo.h&quot;
+#include &quot;lfunc.h&quot;
+#include &quot;lgc.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;lopcodes.h&quot;
+#include &quot;lstate.h&quot;
+#include &quot;lstring.h&quot;
+#include &quot;ltable.h&quot;
+#include &quot;ltm.h&quot;
+#include &quot;lvm.h&quot;
+
+
+
+/* function to convert a lua_Number to a string */
+#ifndef lua_number2str
+#define lua_number2str(s,n)     sprintf((s), LUA_NUMBER_FMT, (n))
+#endif
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TObject *luaV_tonumber (const TObject *obj, TObject *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) &amp;&amp; luaO_str2d(svalue(obj), &amp;num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[32];  /* 16 digits, sign, point and \0  (+ some extra...) */
+    lua_number2str(s, nvalue(obj));
+    setsvalue2s(obj, luaS_new(L, s));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  lu_byte mask = L-&gt;hookmask;
+  if (mask &gt; LUA_MASKLINE) {  /* instruction-hook set? */
+    if (L-&gt;hookcount == 0) {
+      resethookcount(L);
+      luaD_callhook(L, LUA_HOOKCOUNT, -1);
+      return;
+    }
+  }
+  if (mask &amp; LUA_MASKLINE) {
+    CallInfo *ci = L-&gt;ci;
+    Proto *p = ci_func(ci)-&gt;l.p;
+    int newline = getline(p, pcRel(*ci-&gt;u.l.pc, p));
+    if (!L-&gt;hookinit) {
+      luaG_inithooks(L);
+      return;
+    }
+    lua_assert(ci-&gt;state &amp; CI_HASFRAME);
+    if (pcRel(*ci-&gt;u.l.pc, p) == 0)  /* tracing may be starting now? */
+      ci-&gt;u.l.savedpc = *ci-&gt;u.l.pc;  /* initialize `savedpc' */
+    /* calls linehook when enters a new line or jumps back (loop) */
+    if (*ci-&gt;u.l.pc &lt;= ci-&gt;u.l.savedpc ||
+        newline != getline(p, pcRel(ci-&gt;u.l.savedpc, p))) {
+      luaD_callhook(L, LUA_HOOKLINE, newline);
+      ci = L-&gt;ci;  /* previous call may reallocate `ci' */
+    }
+    ci-&gt;u.l.savedpc = *ci-&gt;u.l.pc;
+  }
+}
+
+
+static void callTMres (lua_State *L, const TObject *f,
+                       const TObject *p1, const TObject *p2) {
+  setobj2s(L-&gt;top, f);  /* push function */
+  setobj2s(L-&gt;top+1, p1);  /* 1st argument */
+  setobj2s(L-&gt;top+2, p2);  /* 2nd argument */
+  luaD_checkstack(L, 3);  /* cannot check before (could invalidate p1, p2) */
+  L-&gt;top += 3;
+  luaD_call(L, L-&gt;top - 3, 1);
+  L-&gt;top--;  /* result will be in L-&gt;top */
+}
+
+
+
+static void callTM (lua_State *L, const TObject *f,
+                    const TObject *p1, const TObject *p2, const TObject *p3) {
+  setobj2s(L-&gt;top, f);  /* push function */
+  setobj2s(L-&gt;top+1, p1);  /* 1st argument */
+  setobj2s(L-&gt;top+2, p2);  /* 2nd argument */
+  setobj2s(L-&gt;top+3, p3);  /* 3th argument */
+  luaD_checkstack(L, 4);  /* cannot check before (could invalidate p1...p3) */
+  L-&gt;top += 4;
+  luaD_call(L, L-&gt;top - 4, 0);
+}
+
+
+static const TObject *luaV_index (lua_State *L, const TObject *t,
+                                  TObject *key, int loop) {
+  const TObject *tm = fasttm(L, hvalue(t)-&gt;metatable, TM_INDEX);
+  if (tm == NULL) return &amp;luaO_nilobject;  /* no TM */
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L-&gt;top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+static const TObject *luaV_getnotable (lua_State *L, const TObject *t,
+                                       TObject *key, int loop) {
+  const TObject *tm = luaT_gettmbyobj(L, t, TM_INDEX);
+  if (ttisnil(tm))
+    luaG_typeerror(L, t, &quot;index&quot;);
+  if (ttisfunction(tm)) {
+    callTMres(L, tm, t, key);
+    return L-&gt;top;
+  }
+  else return luaV_gettable(L, tm, key, loop);
+}
+
+
+/*
+** Function to index a table.
+** Receives the table at `t' and the key at `key'.
+** leaves the result at `res'.
+*/
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop) {
+  if (loop &gt; MAXTAGLOOP)
+    luaG_runerror(L, &quot;loop in gettable&quot;);
+  if (ttistable(t)) {  /* `t' is a table? */
+    Table *h = hvalue(t);
+    const TObject *v = luaH_get(h, key);  /* do a primitive get */
+    if (!ttisnil(v)) return v;
+    else return luaV_index(L, t, key, loop+1);
+  }
+  else return luaV_getnotable(L, t, key, loop+1);
+}
+
+
+/*
+** Receives table at `t', key at `key' and value at `val'.
+*/
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val) {
+  const TObject *tm;
+  int loop = 0;
+  do {
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TObject *oldval = luaH_set(L, h, key); /* do a primitive set */
+      if (!ttisnil(oldval) ||  /* result is no nil? */
+          (tm = fasttm(L, h-&gt;metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */
+        setobj2t(oldval, val);  /* write barrier */
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+      luaG_typeerror(L, t, &quot;index&quot;);
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val);
+      return;
+    }
+    t = tm;  /* else repeat with `tm' */ 
+  } while (++loop &lt;= MAXTAGLOOP);
+  luaG_runerror(L, &quot;loop in settable&quot;);
+}
+
+
+static int call_binTM (lua_State *L, const TObject *p1, const TObject *p2,
+                       StkId res, TMS event) {
+  ptrdiff_t result = savestack(L, res);
+  const TObject *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (!ttisfunction(tm)) return 0;
+  callTMres(L, tm, p1, p2);
+  res = restorestack(L, result);  /* previous call may change stack */
+  setobjs2s(res, L-&gt;top);
+  return 1;
+}
+
+
+static const TObject *get_compTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TObject *tm1 = fasttm(L, mt1, event);
+  const TObject *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables =&gt; same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaO_rawequalObj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TObject *p1, const TObject *p2,
+                         TMS event) {
+  const TObject *tm1 = luaT_gettmbyobj(L, p1, event);
+  const TObject *tm2;
+  if (ttisnil(tm1)) return -1;  /* no metamethod? */
+  tm2 = luaT_gettmbyobj(L, p2, event);
+  if (!luaO_rawequalObj(tm1, tm2))  /* different metamethods? */
+    return -1;
+  callTMres(L, tm1, p1, p2);
+  return !l_isfalse(L-&gt;top);
+}
+
+
+static int luaV_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls-&gt;tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs-&gt;tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) &lt; nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) &lt; 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) != -1)
+    return res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+static int luaV_lessequal (lua_State *L, const TObject *l, const TObject *r) {
+  int res;
+  if (ttype(l) != ttype(r))
+    return luaG_ordererror(L, l, r);
+  else if (ttisnumber(l))
+    return nvalue(l) &lt;= nvalue(r);
+  else if (ttisstring(l))
+    return luaV_strcmp(tsvalue(l), tsvalue(r)) &lt;= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) != -1)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) != -1)  /* else try `lt' */
+    return !res;
+  return luaG_ordererror(L, l, r);
+}
+
+
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2) {
+  const TObject *tm;
+  lua_assert(ttype(t1) == ttype(t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return nvalue(t1) == nvalue(t2);
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      tm = get_compTM(L, uvalue(t1)-&gt;uv.metatable, uvalue(t2)-&gt;uv.metatable,
+                         TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      tm = get_compTM(L, hvalue(t1)-&gt;metatable, hvalue(t2)-&gt;metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default: return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTMres(L, tm, t1, t2);  /* call TM */
+  return !l_isfalse(L-&gt;top);
+}
+
+
+void luaV_concat (lua_State *L, int total, int last) {
+  do {
+    StkId top = L-&gt;base + last + 1;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!tostring(L, top-2) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    } else if (tsvalue(top-1)-&gt;tsv.len &gt; 0) {  /* if len=0, do nothing */
+      /* at least two string values; get as many as possible */
+      lu_mem tl = cast(lu_mem, tsvalue(top-1)-&gt;tsv.len) +
+                  cast(lu_mem, tsvalue(top-2)-&gt;tsv.len);
+      char *buffer;
+      int i;
+      while (n &lt; total &amp;&amp; tostring(L, top-n-1)) {  /* collect total length */
+        tl += tsvalue(top-n-1)-&gt;tsv.len;
+        n++;
+      }
+      if (tl &gt; MAX_SIZET) luaG_runerror(L, &quot;string size overflow&quot;);
+      buffer = luaZ_openspace(L, &amp;G(L)-&gt;buff, tl);
+      tl = 0;
+      for (i=n; i&gt;0; i--) {  /* concat all strings */
+        size_t l = tsvalue(top-i)-&gt;tsv.len;
+        memcpy(buffer+tl, svalue(top-i), l);
+        tl += l;
+      }
+      setsvalue2s(top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got `n' strings to create 1 new */
+    last -= n-1;
+  } while (total &gt; 1);  /* repeat until only 1 result left */
+}
+
+
+static void Arith (lua_State *L, StkId ra,
+                   const TObject *rb, const TObject *rc, TMS op) {
+  TObject tempb, tempc;
+  const TObject *b, *c;
+  if ((b = luaV_tonumber(rb, &amp;tempb)) != NULL &amp;&amp;
+      (c = luaV_tonumber(rc, &amp;tempc)) != NULL) {
+    switch (op) {
+      case TM_ADD: setnvalue(ra, nvalue(b) + nvalue(c)); break;
+      case TM_SUB: setnvalue(ra, nvalue(b) - nvalue(c)); break;
+      case TM_MUL: setnvalue(ra, nvalue(b) * nvalue(c)); break;
+      case TM_DIV: setnvalue(ra, nvalue(b) / nvalue(c)); break;
+      case TM_POW: {
+        const TObject *f = luaH_getstr(hvalue(gt(L)), G(L)-&gt;tmname[TM_POW]);
+        ptrdiff_t res = savestack(L, ra);
+        if (!ttisfunction(f))
+          luaG_runerror(L, &quot;`__pow' (`^' operator) is not a function&quot;);
+        callTMres(L, f, b, c);
+        ra = restorestack(L, res);  /* previous call may change stack */
+        setobjs2s(ra, L-&gt;top);
+        break;
+      }
+      default: lua_assert(0); break;
+    }
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#define runtime_check(L, c)	{ if (!(c)) return 0; }
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define XRA(i)	(L-&gt;base+GETARG_A(i))
+#define RB(i)	(base+GETARG_B(i))
+#define RKB(i)	((GETARG_B(i) &lt; MAXSTACK) ? RB(i) : k+GETARG_B(i)-MAXSTACK)
+#define RC(i)	(base+GETARG_C(i))
+#define RKC(i)	((GETARG_C(i) &lt; MAXSTACK) ? RC(i) : k+GETARG_C(i)-MAXSTACK)
+#define KBx(i)	(k+GETARG_Bx(i))
+
+
+#define dojump(pc, i)	((pc) += (i))
+
+
+StkId luaV_execute (lua_State *L) {
+  LClosure *cl;
+  TObject *k;
+  const Instruction *pc;
+ callentry:  /* entry point when calling new functions */
+  L-&gt;ci-&gt;u.l.pc = &pc;
+  if (L-&gt;hookmask &amp; LUA_MASKCALL)
+    luaD_callhook(L, LUA_HOOKCALL, -1);
+ retentry:  /* entry point when returning to old functions */
+  lua_assert(L-&gt;ci-&gt;state == CI_SAVEDPC ||
+             L-&gt;ci-&gt;state == (CI_SAVEDPC | CI_CALLING));
+  L-&gt;ci-&gt;state = CI_HASFRAME;  /* activate frame */
+  pc = L-&gt;ci-&gt;u.l.savedpc;
+  cl = &amp;clvalue(L-&gt;base - 1)-&gt;l;
+  k = cl-&gt;p-&gt;k;
+  /* main loop of interpreter */
+  for (;;) {
+    const Instruction i = *pc++;
+    StkId base, ra;
+    if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;
+        (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {
+      traceexec(L);
+      if (L-&gt;ci-&gt;state &amp; CI_YIELD) {  /* did hook yield? */
+        L-&gt;ci-&gt;u.l.savedpc = pc - 1;
+        L-&gt;ci-&gt;state = CI_YIELD | CI_SAVEDPC;
+        return NULL;
+      }
+    }
+    /* warning!! several calls may realloc the stack and invalidate `ra' */
+    base = L-&gt;base;
+    ra = RA(i);
+    lua_assert(L-&gt;ci-&gt;state &amp; CI_HASFRAME);
+    lua_assert(base == L-&gt;ci-&gt;base);
+    lua_assert(L-&gt;top &lt;= L-&gt;stack + L-&gt;stacksize &amp;&amp; L-&gt;top &gt;= base);
+    lua_assert(L-&gt;top == L-&gt;ci-&gt;top ||
+         GET_OPCODE(i) == OP_CALL ||   GET_OPCODE(i) == OP_TAILCALL ||
+         GET_OPCODE(i) == OP_RETURN || GET_OPCODE(i) == OP_SETLISTO);
+    switch (GET_OPCODE(i)) {
+      case OP_MOVE: {
+        setobjs2s(ra, RB(i));
+        break;
+      }
+      case OP_LOADK: {
+        setobj2s(ra, KBx(i));
+        break;
+      }
+      case OP_LOADBOOL: {
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) pc++;  /* skip next instruction (if C) */
+        break;
+      }
+      case OP_LOADNIL: {
+        TObject *rb = RB(i);
+        do {
+          setnilvalue(rb--);
+        } while (rb &gt;= ra);
+        break;
+      }
+      case OP_GETUPVAL: {
+        int b = GETARG_B(i);
+        setobj2s(ra, cl-&gt;upvals[b]-&gt;v);
+        break;
+      }
+      case OP_GETGLOBAL: {
+        TObject *rb = KBx(i);
+        const TObject *v;
+        lua_assert(ttisstring(rb) &amp;&amp; ttistable(&amp;cl-&gt;g));
+        v = luaH_getstr(hvalue(&amp;cl-&gt;g), tsvalue(rb));
+        if (!ttisnil(v)) { setobj2s(ra, v); }
+        else
+          setobj2s(XRA(i), luaV_index(L, &amp;cl-&gt;g, rb, 0));
+        break;
+      }
+      case OP_GETTABLE: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_get(hvalue(rb), rc);
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_SETGLOBAL: {
+        lua_assert(ttisstring(KBx(i)) &amp;&amp; ttistable(&amp;cl-&gt;g));
+        luaV_settable(L, &amp;cl-&gt;g, KBx(i), ra);
+        break;
+      }
+      case OP_SETUPVAL: {
+        int b = GETARG_B(i);
+        setobj(cl-&gt;upvals[b]-&gt;v, ra);  /* write barrier */
+        break;
+      }
+      case OP_SETTABLE: {
+        luaV_settable(L, ra, RKB(i), RKC(i));
+        break;
+      }
+      case OP_NEWTABLE: {
+        int b = GETARG_B(i);
+        b = fb2int(b);
+        sethvalue(ra, luaH_new(L, b, GETARG_C(i)));
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_SELF: {
+        StkId rb = RB(i);
+        TObject *rc = RKC(i);
+        runtime_check(L, ttisstring(rc));
+        setobjs2s(ra+1, rb);
+        if (ttistable(rb)) {
+          const TObject *v = luaH_getstr(hvalue(rb), tsvalue(rc));
+          if (!ttisnil(v)) { setobj2s(ra, v); }
+          else
+            setobj2s(XRA(i), luaV_index(L, rb, rc, 0));
+        }
+        else
+          setobj2s(XRA(i), luaV_getnotable(L, rb, rc, 0));
+        break;
+      }
+      case OP_ADD: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) + nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_ADD);
+        break;
+      }
+      case OP_SUB: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) - nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_SUB);
+        break;
+      }
+      case OP_MUL: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) * nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_MUL);
+        break;
+      }
+      case OP_DIV: {
+        TObject *rb = RKB(i);
+        TObject *rc = RKC(i);
+        if (ttisnumber(rb) &amp;&amp; ttisnumber(rc)) {
+          setnvalue(ra, nvalue(rb) / nvalue(rc));
+        }
+        else
+          Arith(L, ra, rb, rc, TM_DIV);
+        break;
+      }
+      case OP_POW: {
+        Arith(L, ra, RKB(i), RKC(i), TM_POW);
+        break;
+      }
+      case OP_UNM: {
+        const TObject *rb = RB(i);
+        TObject temp;
+        if (tonumber(rb, &amp;temp)) {
+          setnvalue(ra, -nvalue(rb));
+        }
+        else {
+          setnilvalue(&amp;temp);
+          if (!call_binTM(L, RB(i), &amp;temp, ra, TM_UNM))
+            luaG_aritherror(L, RB(i), &amp;temp);
+        }
+        break;
+      }
+      case OP_NOT: {
+        int res = l_isfalse(RB(i));  /* next assignment may change this value */
+        setbvalue(ra, res);
+        break;
+      }
+      case OP_CONCAT: {
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        luaV_concat(L, c-b+1, c);  /* may change `base' (and `ra') */
+        base = L-&gt;base;
+        setobjs2s(RA(i), base+b);
+        luaC_checkGC(L);
+        break;
+      }
+      case OP_JMP: {
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_EQ: {
+        if (equalobj(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LT: {
+        if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_LE: {
+        if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i)) pc++;
+        else dojump(pc, GETARG_sBx(*pc) + 1);
+        break;
+      }
+      case OP_TEST: {
+        TObject *rb = RB(i);
+        if (l_isfalse(rb) == GETARG_C(i)) pc++;
+        else {
+          setobjs2s(ra, rb);
+          dojump(pc, GETARG_sBx(*pc) + 1);
+        }
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        StkId firstResult;
+        int b = GETARG_B(i);
+        int nresults;
+        if (b != 0) L-&gt;top = ra+b;  /* else previous instruction set top */
+        nresults = GETARG_C(i) - 1;
+        firstResult = luaD_precall(L, ra);
+        if (firstResult) {
+          if (firstResult &gt; L-&gt;top) {  /* yield? */
+            lua_assert(L-&gt;ci-&gt;state == (CI_C | CI_YIELD));
+            (L-&gt;ci - 1)-&gt;u.l.savedpc = pc;
+            (L-&gt;ci - 1)-&gt;state = CI_SAVEDPC;
+            return NULL;
+          }
+          /* it was a C function (`precall' called it); adjust results */
+          luaD_poscall(L, nresults, firstResult);
+          if (nresults &gt;= 0) L-&gt;top = L-&gt;ci-&gt;top;
+        }
+        else {  /* it is a Lua function */
+          if (GET_OPCODE(i) == OP_CALL) {  /* regular call? */
+            (L-&gt;ci-1)-&gt;u.l.savedpc = pc;  /* save `pc' to return later */
+            (L-&gt;ci-1)-&gt;state = (CI_SAVEDPC | CI_CALLING);
+          }
+          else {  /* tail call: put new frame in place of previous one */
+            int aux;
+            base = (L-&gt;ci - 1)-&gt;base;  /* `luaD_precall' may change the stack */
+            ra = RA(i);
+            if (L-&gt;openupval) luaF_close(L, base);
+            for (aux = 0; ra+aux &lt; L-&gt;top; aux++)  /* move frame down */
+              setobjs2s(base+aux-1, ra+aux);
+            (L-&gt;ci - 1)-&gt;top = L-&gt;top = base+aux;  /* correct top */
+            lua_assert(L-&gt;ci-&gt;state &amp; CI_SAVEDPC);
+            (L-&gt;ci - 1)-&gt;u.l.savedpc = L-&gt;ci-&gt;u.l.savedpc;
+            (L-&gt;ci - 1)-&gt;u.l.tailcalls++;  /* one more call lost */
+            (L-&gt;ci - 1)-&gt;state = CI_SAVEDPC;
+            L-&gt;ci--;  /* remove new frame */
+            L-&gt;base = L-&gt;ci-&gt;base;
+          }
+          goto callentry;
+        }
+        break;
+      }
+      case OP_RETURN: {
+        CallInfo *ci = L-&gt;ci - 1;  /* previous function frame */
+        int b = GETARG_B(i);
+        if (b != 0) L-&gt;top = ra+b-1;
+        lua_assert(L-&gt;ci-&gt;state &amp; CI_HASFRAME);
+        if (L-&gt;openupval) luaF_close(L, base);
+        L-&gt;ci-&gt;state = CI_SAVEDPC;  /* deactivate current function */
+        L-&gt;ci-&gt;u.l.savedpc = pc;
+        /* previous function was running `here'? */
+        if (!(ci-&gt;state &amp; CI_CALLING)) {
+          lua_assert((ci-&gt;state &amp; CI_C) || ci-&gt;u.l.pc != &amp;pc);
+          return ra;  /* no: return */
+        }
+        else {  /* yes: continue its execution */
+          int nresults;
+          lua_assert(ci-&gt;u.l.pc == &amp;pc &amp;&amp;
+                     ttisfunction(ci-&gt;base - 1) &amp;&amp;
+                     (ci-&gt;state &amp; CI_SAVEDPC));
+          lua_assert(GET_OPCODE(*(ci-&gt;u.l.savedpc - 1)) == OP_CALL);
+          nresults = GETARG_C(*(ci-&gt;u.l.savedpc - 1)) - 1;
+          luaD_poscall(L, nresults, ra);
+          if (nresults &gt;= 0) L-&gt;top = L-&gt;ci-&gt;top;
+          goto retentry;
+        }
+      }
+      case OP_FORLOOP: {
+        lua_Number step, idx, limit;
+        const TObject *plimit = ra+1;
+        const TObject *pstep = ra+2;
+        if (!ttisnumber(ra))
+          luaG_runerror(L, &quot;`for' initial value must be a number&quot;);
+        if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, &quot;`for' limit must be a number&quot;);
+        if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, &quot;`for' step must be a number&quot;);
+        step = nvalue(pstep);
+        idx = nvalue(ra) + step;  /* increment index */
+        limit = nvalue(plimit);
+        if (step &gt; 0 ? idx &lt;= limit : idx &gt;= limit) {
+          dojump(pc, GETARG_sBx(i));  /* jump back */
+          chgnvalue(ra, idx);  /* update index */
+        }
+        break;
+      }
+      case OP_TFORLOOP: {
+        int nvar = GETARG_C(i) + 1;
+        StkId cb = ra + nvar + 2;  /* call base */
+        setobjs2s(cb, ra);
+        setobjs2s(cb+1, ra+1);
+        setobjs2s(cb+2, ra+2);
+        L-&gt;top = cb+3;  /* func. + 2 args (state and index) */
+        luaD_call(L, cb, nvar);
+        L-&gt;top = L-&gt;ci-&gt;top;
+        ra = XRA(i) + 2;  /* final position of first result */
+        cb = ra + nvar;
+        do {  /* move results to proper positions */
+          nvar--;
+          setobjs2s(ra+nvar, cb+nvar);
+        } while (nvar &gt; 0);
+        if (ttisnil(ra))  /* break loop? */
+          pc++;  /* skip jump (break loop) */
+        else
+          dojump(pc, GETARG_sBx(*pc) + 1);  /* jump back */
+        break;
+      }
+      case OP_TFORPREP: {  /* for compatibility only */
+        if (ttistable(ra)) {
+          setobjs2s(ra+1, ra);
+          setobj2s(ra, luaH_getstr(hvalue(gt(L)), luaS_new(L, &quot;next&quot;)));
+        }
+        dojump(pc, GETARG_sBx(i));
+        break;
+      }
+      case OP_SETLIST:
+      case OP_SETLISTO: {
+        int bc;
+        int n;
+        Table *h;
+        runtime_check(L, ttistable(ra));
+        h = hvalue(ra);
+        bc = GETARG_Bx(i);
+        if (GET_OPCODE(i) == OP_SETLIST)
+          n = (bc&amp;(LFIELDS_PER_FLUSH-1)) + 1;
+        else {
+          n = L-&gt;top - ra - 1;
+          L-&gt;top = L-&gt;ci-&gt;top;
+        }
+        bc &amp;= ~(LFIELDS_PER_FLUSH-1);  /* bc = bc - bc%FPF */
+        for (; n &gt; 0; n--)
+          setobj2t(luaH_setnum(L, h, bc+n), ra+n);  /* write barrier */
+        break;
+      }
+      case OP_CLOSE: {
+        luaF_close(L, ra);
+        break;
+      }
+      case OP_CLOSURE: {
+        Proto *p;
+        Closure *ncl;
+        int nup, j;
+        p = cl-&gt;p-&gt;p[GETARG_Bx(i)];
+        nup = p-&gt;nups;
+        ncl = luaF_newLclosure(L, nup, &amp;cl-&gt;g);
+        ncl-&gt;l.p = p;
+        for (j=0; j&lt;nup; j++, pc++) {
+          if (GET_OPCODE(*pc) == OP_GETUPVAL)
+            ncl-&gt;l.upvals[j] = cl-&gt;upvals[GETARG_B(*pc)];
+          else {
+            lua_assert(GET_OPCODE(*pc) == OP_MOVE);
+            ncl-&gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
+          }
+        }
+        setclvalue(ra, ncl);
+        luaC_checkGC(L);
+        break;
+      }
+    }
+  }
+}
+

Added: trunk/source/libraries/lua/lvm.h
===================================================================
--- trunk/source/libraries/lua/lvm.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lvm.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,35 @@
+/*
+** $Id: lvm.h,v 1.47 2002/11/14 16:16:21 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include &quot;ldo.h&quot;
+#include &quot;lobject.h&quot;
+#include &quot;ltm.h&quot;
+
+
+#define tostring(L,o) ((ttype(o) == LUA_TSTRING) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttype(o) == LUA_TNUMBER || \
+                         (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2) \
+	(ttype(o1) == ttype(o2) &amp;&amp; luaV_equalval(L, o1, o2))
+
+
+int luaV_lessthan (lua_State *L, const TObject *l, const TObject *r);
+int luaV_equalval (lua_State *L, const TObject *t1, const TObject *t2);
+const TObject *luaV_tonumber (const TObject *obj, TObject *n);
+int luaV_tostring (lua_State *L, StkId obj);
+const TObject *luaV_gettable (lua_State *L, const TObject *t, TObject *key,
+                              int loop);
+void luaV_settable (lua_State *L, const TObject *t, TObject *key, StkId val);
+StkId luaV_execute (lua_State *L);
+void luaV_concat (lua_State *L, int total, int last);
+
+#endif

Added: trunk/source/libraries/lua/lzio.c
===================================================================
--- trunk/source/libraries/lua/lzio.c	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lzio.c	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,81 @@
+/*
+** $Id: lzio.c,v 1.24 2003/03/20 16:00:56 roberto Exp $
+** a generic input stream interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include &lt;string.h&gt;
+
+#define lzio_c
+
+#include &quot;lua.h&quot;
+
+#include &quot;llimits.h&quot;
+#include &quot;lmem.h&quot;
+#include &quot;lzio.h&quot;
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  const char *buff = z-&gt;reader(NULL, z-&gt;data, &amp;size);
+  if (buff == NULL || size == 0) return EOZ;
+  z-&gt;n = size - 1;
+  z-&gt;p = buff;
+  return char2int(*(z-&gt;p++));
+}
+
+
+int luaZ_lookahead (ZIO *z) {
+  if (z-&gt;n == 0) {
+    int c = luaZ_fill(z);
+    if (c == EOZ) return c;
+    z-&gt;n++;
+    z-&gt;p--;
+  }
+  return char2int(*z-&gt;p);
+}
+
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name) {
+  z-&gt;reader = reader;
+  z-&gt;data = data;
+  z-&gt;name = name;
+  z-&gt;n = 0;
+  z-&gt;p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z-&gt;n == 0) {
+      if (luaZ_fill(z) == EOZ)
+        return n;  /* return number of missing bytes */
+      else {
+        ++z-&gt;n;  /* filbuf removed first byte; put back it */
+        --z-&gt;p;
+      }
+    }
+    m = (n &lt;= z-&gt;n) ? n : z-&gt;n;  /* min. between n and z-&gt;n */
+    memcpy(b, z-&gt;p, m);
+    z-&gt;n -= m;
+    z-&gt;p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n &gt; buff-&gt;buffsize) {
+    if (n &lt; LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaM_reallocvector(L, buff-&gt;buffer, buff-&gt;buffsize, n, char);
+    buff-&gt;buffsize = n;
+  }
+  return buff-&gt;buffer;
+}
+
+

Added: trunk/source/libraries/lua/lzio.h
===================================================================
--- trunk/source/libraries/lua/lzio.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/libraries/lua/lzio.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,64 @@
+/*
+** $Id: lzio.h,v 1.15 2003/03/20 16:00:56 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include &quot;lua.h&quot;
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+
+#define char2int(c)	cast(int, cast(unsigned char, (c)))
+
+#define zgetc(z)  (((z)-&gt;n--)&gt;0 ?  char2int(*(z)-&gt;p++) : luaZ_fill(z))
+
+#define zname(z)	((z)-&gt;name)
+
+void luaZ_init (ZIO *z, lua_Chunkreader reader, void *data, const char *name);
+size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+int luaZ_lookahead (ZIO *z);
+
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t buffsize;
+} Mbuffer;
+
+
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+
+#define luaZ_initbuffer(L, buff) ((buff)-&gt;buffer = NULL, (buff)-&gt;buffsize = 0)
+
+#define luaZ_sizebuffer(buff)	((buff)-&gt;buffsize)
+#define luaZ_buffer(buff)	((buff)-&gt;buffer)
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)-&gt;buffer, (buff)-&gt;buffsize, size, char), \
+	(buff)-&gt;buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Chunkreader reader;
+  void* data;			/* additional data */
+  const char *name;
+};
+
+
+int luaZ_fill (ZIO *z);
+
+#endif

Added: trunk/source/other/gup.cpp
===================================================================
--- trunk/source/other/gup.cpp	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/other/gup.cpp	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,713 @@
+#include &lt;string.h&gt;
+#include &lt;allegro.h&gt;
+#include &quot;melee.h&quot;
+
+#include &quot;melee/mframe.h&quot;
+#include &quot;melee/mship.h&quot;
+#include &quot;melee/mcbodies.h&quot;
+#include &quot;melee/mview.h&quot;
+#include &quot;frame.h&quot;
+#include &quot;sc1ships.h&quot;
+#include &quot;sc2ships.h&quot;
+#include &quot;games/ggob.h&quot;
+#include &quot;gup.h&quot;
+
+/* this file contains the ship upgrades used by Gob */
+
+/*
+Generic Upgrades
+*/
+
+/*
+NOTE that execute() is called BEFORE charge(), so 
+num is not yet incremented when execute() is running
+*/
+void Upgrade::clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+  STACKTRACE;
+	if (oship) gs-&gt;total -= num;
+	num = 0;
+	return;
+	}
+void Upgrade::charge(GobPlayer *gs) {
+  STACKTRACE; //called AFTER execute
+	gs-&gt;total += 1;
+	num += 1;
+	gs-&gt;value_starbucks += this-&gt;starbucks;
+	gs-&gt;value_buckazoids += this-&gt;buckazoids;
+	return;
+	}
+
+#define UPGRADE(a) virtual Upgrade *duplicate() {return new a();}
+class UpCrewpod : public Upgrade {
+	UPGRADE(UpCrewpod)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Add Crewpod&quot;;
+		if (ship-&gt;crew_max &gt;= 42) return false;
+		starbucks = 2;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship-&gt;crew_max += 4;
+		if (ship-&gt;crew_max &gt; 42) ship-&gt;crew_max = 42;
+		ship-&gt;crew += 4;
+		if (ship-&gt;crew &gt; 42) ship-&gt;crew = 42;
+		}
+	} crewpod;
+
+class UpBattery : public Upgrade {
+	UPGRADE(UpBattery)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Add Battery&quot;;
+		if (ship-&gt;batt_max &gt;= 42) return false;
+		starbucks = 1;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship-&gt;batt_max += 8;
+		if (ship-&gt;batt_max &gt; 42) ship-&gt;batt_max = 42;
+		ship-&gt;batt += 8;
+		if (ship-&gt;batt &gt; 42) ship-&gt;batt = 42;
+		}
+	} battery;
+
+class UpThrusters : public Upgrade {
+	UPGRADE(UpThrusters)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Thrusters&quot;;
+		starbucks = 3 + num * 3;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship-&gt;speed_max *=  1 + .3  / (.25*num + 1);
+		ship-&gt;accel_rate *= 1 + .18 / (.12*num + 1);
+		}
+	} thrusters;
+
+class UpControlJets : public Upgrade {
+	UPGRADE(UpControlJets)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Control Jets&quot;;
+		starbucks = 2 + num * 2;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship-&gt;turn_rate  *=  1 + .3  / (num + 1);
+		ship-&gt;accel_rate *=  1 + .1  / (.0*num + 1);
+		}
+	} controljets;
+
+class UpDynamo : public Upgrade {
+	UPGRADE(UpDynamo)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Dynamo&quot;;
+		starbucks = 16 / (1 + ship-&gt;recharge_amount-num) + num;
+		if (ship-&gt;recharge_amount == 0) starbucks *= 6;
+		if (ship-&gt;weapon_rate &lt; 100) starbucks /= 2;
+		if (ship-&gt;special_drain &gt; 16) starbucks *= 2;
+		if (!strcmp(&quot;supbl&quot;, ship-&gt;type-&gt;id)) starbucks /= 2;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship-&gt;recharge_amount += 1;
+	}
+} dynamo;
+
+/*
+Supox Upgrades
+*/
+
+class UpSupoxRange : public Upgrade {
+	UPGRADE(UpSupoxRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Glob Hurler (Supox)&quot;;
+		if (strcmp(&quot;supbl&quot;, ship-&gt;type-&gt;id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)-&gt;weaponRange *= 1 + .25 / (1 + num*.1);
+		((SupoxBlade*)ship)-&gt;weaponVelocity *= 1.15;
+		}
+	} supoxrange;
+
+class UpSupoxDamage : public Upgrade {
+	UPGRADE(UpSupoxDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Glob Former (Supox)&quot;;
+		if (strcmp(&quot;supbl&quot;, ship-&gt;type-&gt;id)) return false;
+		if (gs-&gt;ship-&gt;recharge_amount &lt; (1&lt;&lt;num)) return false;
+		if (num &gt; 7) return false;
+		starbucks = 5;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)-&gt;weaponDamage += 1;
+		((SupoxBlade*)ship)-&gt;weaponArmour += 1;
+		((SupoxBlade*)ship)-&gt;weapon_drain += num + 1;
+		if (num &gt; 1) ((SupoxBlade*)ship)-&gt;recharge_amount += 1;
+		}
+	} supoxdamage;
+
+class UpSupoxBLADE : public Upgrade {
+	UPGRADE(UpSupoxBLADE)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Add B.L.A.D.E. (Supox)&quot;;
+		if (strcmp(&quot;supbl&quot;, ship-&gt;type-&gt;id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((SupoxBlade*)ship)-&gt;damage_factor += 3;
+		}
+	} supoxblade;
+
+/*
+Orz Upgrades
+*/
+
+class UpOrzMissile : public Upgrade {
+	UPGRADE(UpOrzMissile)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Missiles (ORZ)&quot;;
+		if (strcmp(&quot;orzne&quot;, ship-&gt;type-&gt;id)) return false;
+		starbucks = 6;
+		buckazoids = gs-&gt;total / 2 + 2;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)-&gt;weaponDamage += 1;
+		((OrzNemesis*)ship)-&gt;weaponArmour += 1;
+		((OrzNemesis*)ship)-&gt;weaponRange *= 1.15;
+		((OrzNemesis*)ship)-&gt;weapon_drain += 1;
+		}
+	} orzmissile;
+
+class UpOrzMarineSpeed : public Upgrade {
+	UPGRADE(UpOrzMarineSpeed)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Marine Suits (ORZ)&quot;;
+		if (strcmp(&quot;orzne&quot;, ship-&gt;type-&gt;id)) return false;
+		starbucks = 3 + num * 2;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)-&gt;specialArmour += 1;
+		((OrzNemesis*)ship)-&gt;specialSpeedMax *= 1 + .2 / (.2*num+1);
+		((OrzNemesis*)ship)-&gt;specialAccelRate *= 1.15;
+		}
+	} orzmarinespeed;
+
+class UpOrzAbsorbtion : public Upgrade {
+	UPGRADE(UpOrzAbsorbtion)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Absorbtion (ORZ)&quot;;
+		if (strcmp(&quot;orzne&quot;, ship-&gt;type-&gt;id)) return false;
+		if (num) return false;
+		starbucks = 15;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((OrzNemesis*)ship)-&gt;absorption = 256 / 3;
+	}
+	void charge(GobPlayer *gs) {
+		Upgrade::charge(gs);
+		gs-&gt;total += 2;
+	}
+} orzabsorption;
+
+/*
+Kohr-Ah Upgrades
+*/
+
+class UpKohrAhBladeDamage : public Upgrade {
+	UPGRADE(UpKohrAhBladeDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Increase Shuriken Sharpness (Kohr-Ah)&quot;;
+		if (strcmp(&quot;kohma&quot;, ship-&gt;type-&gt;id)) return false;
+		starbucks = 2 + num;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)-&gt;weaponDamage += 1;
+		((KohrAhMarauder*)ship)-&gt;weaponArmour += 1;
+		((KohrAhMarauder*)ship)-&gt;weapon_drain += 1;
+		}
+	} kohrahbladedamage;
+
+class UpKohrAhBladeSpeed : public Upgrade {
+	UPGRADE(UpKohrAhBladeSpeed)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		if (strcmp(&quot;kohma&quot;, ship-&gt;type-&gt;id)) return false;
+		name = &quot;Increase Shuriken Velocity (Kohr-Ah)&quot;;
+		starbucks = 2 + num * 2;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)-&gt;weaponVelocity *= 1.2;
+	}
+} kohrahbladespeed;
+
+class UpKohrAhFireRange : public Upgrade {
+	UPGRADE(UpKohrAhFireRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;double F.R.I.E.D. range (Kohr-Ah)&quot;;
+		if (strcmp(&quot;kohma&quot;, ship-&gt;type-&gt;id)) return false;
+		if (num) return false;
+		starbucks = 30;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)-&gt;specialRange *= 2;
+		((KohrAhMarauder*)ship)-&gt;specialVelocity *= 1.4;
+		((KohrAhMarauder*)ship)-&gt;special_drain += 12;
+		}
+	} kohrahfirerange;
+
+class UpKohrAhFireDamage : public Upgrade {
+	UPGRADE(UpKohrAhFireDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;double F.R.I.E.D. damage (Kohr-Ah)&quot;;
+		if (strcmp(&quot;kohma&quot;, ship-&gt;type-&gt;id)) return false;
+		if (num) return false;
+		starbucks = 13;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((KohrAhMarauder*)ship)-&gt;specialDamage *= 2;
+		((KohrAhMarauder*)ship)-&gt;special_drain += 6;
+	}
+} kohrahfiredamage;
+
+/*
+Utwig Upgrades
+*/
+
+class UpUtwigJuggerRange : public Upgrade {
+	UPGRADE(UpUtwigJuggerRange)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Bolt Regulator (Utwig)&quot;;
+		if (strcmp(&quot;utwju&quot;, ship-&gt;type-&gt;id)) return false;
+		starbucks = 3;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)-&gt;weaponRange += 100;
+	}
+} utwigrange;
+class UpUtwigJuggerDamage : public Upgrade {
+	UPGRADE(UpUtwigJuggerDamage)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Bolt Charger (Utwig)&quot;;
+		if (strcmp(&quot;utwju&quot;, ship-&gt;type-&gt;id)) return false;
+		starbucks = (num + 3) * 5;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)-&gt;weaponDamage += 1;
+		ship-&gt;weapon_rate += 250;
+	}
+} utwigdamage;
+class UpUtwigJuggerROF : public Upgrade {
+	UPGRADE(UpUtwigJuggerROF)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Upgrade Bolt Generator (Utwig)&quot;;
+		if (strcmp(&quot;utwju&quot;, ship-&gt;type-&gt;id)) return false;
+		if (ship-&gt;weapon_rate &lt; 425) return false;
+		starbucks = num / 2 + 2;
+		buckazoids = gs-&gt;total / 3;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship-&gt;weapon_rate -= 50;
+	}
+} utwigrof;
+class UpUtwigJuggerMaskOfHonestDemeanor : public Upgrade {
+	UPGRADE(UpUtwigJuggerMaskOfHonestDemeanor)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Mask of Honest Demeanor (max 1 mask)&quot;;
+		if (strcmp(&quot;utwju&quot;, ship-&gt;type-&gt;id)) return false;
+		if ((num + gs-&gt;upgrade_list[UpgradeIndex::utwigmask2]-&gt;num) == 1) return false;
+		starbucks = 99;
+		buckazoids = 0;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		gs-&gt;value_starbucks += 251;
+		gs-&gt;value_buckazoids += 250;
+	}
+} utwigmask1;
+class UpUtwigJuggerMaskOfElephantineFortitude : public Upgrade {
+	UPGRADE(UpUtwigJuggerMaskOfElephantineFortitude)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Mask of Elephantine Fortitude (max 1 mask)&quot;;
+		if (strcmp(&quot;utwju&quot;, ship-&gt;type-&gt;id)) return false;
+		if ((num + gs-&gt;upgrade_list[UpgradeIndex::utwigmask1]-&gt;num) == 1) return false;
+		starbucks = 99;
+		buckazoids = 0;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		((UtwigJugger*)ship)-&gt;fortitude = 1;
+	}
+} utwigmask2;
+
+/*
+Special Upgrades
+*/
+
+class UpDivineFavor : public Upgrade {
+	UPGRADE(UpDivineFavor)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Divine Favor (unique)&quot;;
+		if (strcmp(station-&gt;build_type, &quot;orzne&quot;)) return false;
+		if (num) return false;
+		starbucks = 150;
+		buckazoids = 0;
+		return true;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		return;
+		}
+	void charge(GobPlayer *gs) {
+		num += 1;
+		}
+	} divinefavor;
+
+class UpUnholyAura : public Upgrade {
+	UPGRADE(UpUnholyAura)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;the Devil protects his own...&quot;;
+		starbucks = 6;
+		buckazoids = 66;
+		//if (strcmp(station-&gt;build_type, &quot;orzne&quot;)) return false;
+		if (num) return false;
+		if (((game-&gt;game_time / 1000) % 1000) == 666) return true;
+		if (((game-&gt;game_time / 1000) % 666) == 0) return true;
+		//666, 1332, 1666, 1998, etc.
+		return false;
+		}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		game-&gt;add ( new UnholyAura ( ship ) );
+		}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		else if (num) {
+			game-&gt;add ( new UnholyAura ( nship ) );
+		}
+		return;
+		}
+	void charge(GobPlayer *gs) {
+		num += 1;
+		}
+	} unholyaura;
+
+
+class UpDefender : public Upgrade {
+	UPGRADE(UpDefender)
+	GobDefender *def[6];
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;External Defense System&quot;;
+		if (strcmp(station-&gt;build_type, &quot;kohma&quot;)) return false;
+		if (num &gt;= 6) return false;
+		starbucks = 5 + 5 * (num+1) * num;
+		buckazoids = 12;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		def[num] = new GobDefender(ship);
+		int i;
+		for (i = 0; i &lt;= num; i += 1) def[i]-&gt;base_phase = i * PI2 / (num+1);
+		gobgame-&gt;add (def[num]);
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		if (oship) {
+			for (int i = 0; i &lt; num; i += 1) {
+				def[i]-&gt;die();
+				def[i] = new GobDefender(nship);
+				def[i]-&gt;base_phase = i * PI2 / num;
+				game-&gt;add(def[i]);
+			}
+		}
+		//Upgrade::clear(oship, nship, gs);
+		return;
+	}
+	void charge(GobPlayer *gs) {
+		gs-&gt;total += 1;
+		num += 1;
+	}
+} defender;
+
+class UpPlanetLocater : public Upgrade {
+	UPGRADE(UpPlanetLocater)
+	Presence **locater;
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Planet Locater&quot;;
+		if (strcmp(station-&gt;build_type, &quot;supbl&quot;)) return false;
+		if (num) return false;
+		starbucks = 4;
+		buckazoids = 5;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		locater = new Presence *[gobgame-&gt;num_planets];
+		for (int i = 0; i &lt; gobgame-&gt;num_planets; i += 1) {
+			locater[i] = new WedgeIndicator ( gobgame-&gt;planet[i], 80, 2 );
+			gobgame-&gt;add (locater[i] );
+		}
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		Upgrade::clear(oship, nship, gs);
+		if (oship &amp;&amp; locater) for (int i = 0; i &lt; gobgame-&gt;num_planets; i += 1) {
+			locater[i]-&gt;die();
+		}
+		locater = NULL;
+		return;
+	}
+} planetlocater;
+
+class UpHyperDynamo : public Upgrade {
+	UPGRADE(UpHyperDynamo)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Hyper Dynamo (ancient artifact)&quot;;
+		if (game-&gt;game_time / 1000 &lt; 21 * 60) return false;
+		starbucks = 720 / (game-&gt;game_time / (1000*60*10) - 1);
+		//unavailable before 20 minutes
+		//720 starbucks at 20 minutes
+		//360 starbucks at 30 minutes
+		//240 starbucks at 40 minutes
+		//180 starbucks at 50 minutes
+		//144 starbucks at 60 minutes
+		//120 starbucks at 70 minutes
+		//102 starbucks at 80 minutes
+		//90 starbucks at 90 minutes
+		buckazoids = starbucks/2 + gs-&gt;total / 3;
+		if (gs-&gt;starbucks &lt; starbucks / 4) return false;
+		if (ship-&gt;recharge_amount == 0) return false;
+		if (num) return false;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		ship-&gt;recharge_rate /= 2;
+	}
+} hyperdynamo;
+
+/*class UpRoswellDevice : public Upgrade {
+	UPGRADE(UpUnholyAura)
+	bool update(Ship *ship, GobStation *station, GobPlayer *gs) {
+		name = &quot;Roswell Device&quot;;
+		if (((game-&gt;game_time / 1000) % 1000) &lt; 700) return false;
+		starbucks = 99;
+		buckazoids = 9;
+		if (strcmp(station-&gt;build_type, &quot;utwju&quot;)) return false;
+		if (num) return false;
+		return true;
+	}
+	void execute(Ship *ship, GobStation *station, GobPlayer *gs) {
+		game-&gt;add ( new RoswellDevice ( ship ) );
+	}
+	void clear(Ship *oship, Ship *nship, GobPlayer *gs) {
+		if (!oship) num = 0;
+		else if (num) {
+			game-&gt;add ( new RoswellDevice ( nship ) );
+		}
+		return;
+	}
+	void charge(GobPlayer *gs) {
+		num += 1;
+	}
+} roswelldevice;*/
+
+/*
+note to future coders:
+in order for an upgrade to show up, it must be added to this list
+anything added to this list MUST be added, in the same order, to 
+the enum in gup.h
+*/
+static Upgrade *_upgrade_list[] = {
+	&amp;crewpod,
+	&amp;battery,
+	&amp;thrusters,
+	&amp;controljets,
+	&amp;dynamo,
+	&amp;supoxrange,
+	&amp;supoxdamage,
+	&amp;supoxblade,
+	&amp;orzmissile,
+	&amp;orzmarinespeed,
+	&amp;orzabsorption,
+	&amp;kohrahbladedamage,
+	&amp;kohrahbladespeed,
+	&amp;kohrahfirerange,
+	&amp;kohrahfiredamage,
+	&amp;utwigrange,
+	&amp;utwigdamage,
+	&amp;utwigrof,
+	&amp;utwigmask1,
+	&amp;utwigmask2,
+	&amp;divinefavor,
+	&amp;unholyaura,
+	&amp;defender,
+	&amp;planetlocater,
+	&amp;hyperdynamo,
+//	&amp;roswelldevice,
+	NULL
+	};
+
+Upgrade **upgrade_list = _upgrade_list;
+
+UnholyAura::UnholyAura ( SpaceLocation * ship ) {
+	focus = ship;
+	angle = 0;
+}
+void UnholyAura::animate (Frame *frame) {
+	Vector2 p = corner(focus-&gt;normal_pos());
+	const int speed = 1500;
+	int color = game-&gt;game_time % speed;
+	if (color &gt; speed/2) color = speed - color;
+	color = tw_color ( color * 255 * 2 / speed, 0, 0);
+	Vector2 r;
+	r.y = space_zoom * 240;
+	r.x = r.y * 1.5;
+	double a = angle;
+	line (frame-&gt;surface, 
+		p + r *(unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame-&gt;surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame-&gt;surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame-&gt;surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	a += 72 * ANGLE_RATIO;
+	line (frame-&gt;surface, 
+		p + r * (unit_vector(a +   0 * ANGLE_RATIO)), 
+		p + r * (unit_vector(a + 144 * ANGLE_RATIO)), 
+		color);
+	frame-&gt;add_box(iround(p.x - r.x-1), iround(p.y - r.y-1), iround(r.x*2+3), iround(r.y*2+3));
+}
+void UnholyAura::calculate () {
+	if (!focus-&gt;exists()) die();
+	angle -= frame_time / 10.0;
+	if (angle &lt; 0) angle += 360;
+	if (random(1700) &lt; frame_time) {
+		Query q;
+		q.begin(focus, OBJECT_LAYERS, 666);
+		for (;q.current; q.next() ) {
+			if (!(focus-&gt;sameTeam(q.current))) q.current-&gt;handle_damage(focus, 0, random() % 6);
+		}
+	}
+}
+/*
+void GobRadar::animate_item ( SpaceLocation *item ) {
+	int type = 0;
+	int color = 0;
+	double angle = 0;
+	double radius = 0;
+	double x, y;
+	x = normalize(item-&gt;normal_x() - gx + X_MAX/2, X_MAX) - X_MAX/200+gx/2;
+	x *= window-&gt;w / gw;
+	y = normalize(item-&gt;normal_y() - gy + Y_MAX/2, Y_MAX) - Y_MAX/200+gy/2;
+	y *= window-&gt;h / gh;
+	TeamCode t = item-&gt;get_team();
+	if (t == 0) color = palette_color[6];
+	else if (t == team) color = palette_color[7];
+	else color = palette_color[4];
+	color = palette_color[7];
+	if (item-&gt;isObject()) {
+		SpaceSprite *sprite = ((SpaceObject*)item)-&gt;get_sprite();
+		if (sprite) radius = 
+			sqrt(sprite-&gt;width() * sprite-&gt;width() + sprite-&gt;height() * sprite-&gt;height()) / 2 / gw;
+		else return;
+		if (radius &lt; 5) radius = sqrt(radius * 5);
+	}
+	else if (item-&gt;isLine()) {
+		type = 1;
+		radius = (((SpaceLine*)item)-&gt;get_length()) / gw;
+		angle = (((SpaceLine*)item)-&gt;get_angle());
+	}
+
+
+	if (type == 0) {
+		circlefill ( window-&gt;surface, 
+			window-&gt;x + x, 
+			window-&gt;y + y, 
+			radius,
+			color
+		);
+	}
+	else if (type == 1) {
+		line (  window-&gt;surface,
+			window-&gt;x + x, 
+			window-&gt;y + y,
+			window-&gt;x + x + cos(angle) * radius,
+			window-&gt;y + y + sin(angle) * radius,
+			color
+		);
+	}
+}
+
+void GobRadar::animate ( Frame * frame ) {
+	Query q;
+	if (!window-&gt;surface) return;
+
+	window-&gt;lock();
+
+	rectfill(window-&gt;surface, 
+		window-&gt;x, window-&gt;y, 
+		window-&gt;x + window-&gt;w,
+		window-&gt;y + window-&gt;h,
+		0
+		);
+	for (q.begin(0, 0, ALL_LAYERS, 999999999999);q.current;q.next()) {
+		if (!q.current-&gt;exists()) continue;
+		if (q.current-&gt;isInvisible())
+			continue;
+		animate_item(q.current);
+	}
+	q.end();
+
+	window-&gt;unlock();
+}
+
+GobRadar::GobRadar() {
+  STACKTRACE;
+	attributes &amp;= ~ATTRIB_SYNCHED;
+	team = 0;
+	gx = 0;
+	gy = 0;
+	gw = X_MAX;
+	gh = Y_MAX;
+	window = new VideoWindow();
+	window-&gt;preinit();
+}
+*/

Added: trunk/source/other/gup.h
===================================================================
--- trunk/source/other/gup.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/other/gup.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -0,0 +1,74 @@
+class Upgrade;
+extern Upgrade **upgrade_list;
+
+class UpgradeIndex {
+public:
+	enum {
+		crewpod,
+		battery,
+		thrusters,
+		controljets,
+		dynamo,
+		supoxrange,
+		supoxdamage,
+		supoxblade,
+		orzmissile,
+		orzmarinespeed,
+		orzabsorption,
+		kohrahbladedamage,
+		kohrahbladespeed,
+		kohrahfirerange,
+		kohrahfiredamage,
+		utwigrange,
+		utwigdamage,
+		utwigrof,
+		utwigmask1,
+		utwigmask2,
+		divinefavor,
+		unholyaura,
+		defender,
+		planetlocater,
+		hyperdynamo,
+		//gobradar,
+		//roswelldevice,
+		NULL_UPGRADE
+	};
+};
+
+class GobDefender : public SpaceObject {
+	public:
+	GobDefender ( Ship *ship);
+	double base_phase;
+	virtual void calculate();
+	int next_shoot_time;
+};
+
+/*class RoswellDevice : public Presence {
+	public:
+	RoswellDevice ( Ship *ship, double angle );
+	virtual void calculate();
+	int next_shoot_time;
+	double phase;
+};*/
+
+class UnholyAura : public Presence {
+public:
+	SpaceLocation *focus;
+	double angle;
+	virtual void calculate ();
+	virtual void animate ( Frame * frame);
+	UnholyAura ( SpaceLocation *ship );
+};
+
+/*
+class GobRadar : public Presence {
+public:
+	TeamCode team;
+	double gx, gy, gw, gh;
+	VideoWindow *window;
+	//virtual void calculate ();
+	virtual void animate ( Frame * frame );
+	virtual void animate_item ( SpaceLocation *item);
+	GobRadar();
+};*/
+

Modified: trunk/source/scp.h
===================================================================
--- trunk/source/scp.h	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/source/scp.h	2004-09-26 08:30:59 UTC (rev 64)
@@ -18,12 +18,13 @@
 #ifndef __SCP_H__
 #define __SCP_H__
 
-class VideoWindow;
+
 #include &quot;allegro.h&quot;
 
 //class SAMPLE;
 
 #include &lt;string&gt;
+class VideoWindow;
 
 /// \brief run tests
 bool RunTests();

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2004-09-25 19:22:38 UTC (rev 63)
+++ trunk/sources.lst	2004-09-26 08:30:59 UTC (rev 64)
@@ -17,6 +17,7 @@
 source/util/endian.cpp
 source/util/pmask.c
 source/util/base.cpp
+source/games/ggob.cpp
 source/games/gflmelee.cpp
 source/melee/mlog.cpp
 source/melee/mitems.cpp
@@ -45,6 +46,7 @@
 source/other/vtarget.cpp
 source/other/twconfig.cpp
 source/other/vbodies.cpp
+source/other/gup.cpp
 source/other/objanim.cpp
 source/other/nullphas.cpp
 source/other/planet3d.cpp
@@ -85,6 +87,34 @@
 source/twgui/twpopup.cpp
 source/twgui/twwindow.cpp
 source/twgui/utils.cpp
+source/libraries/lua/lib/ldblib.c
+source/libraries/lua/lib/lauxlib.c
+source/libraries/lua/lib/lbaselib.c
+source/libraries/lua/lib/loadlib.c
+source/libraries/lua/lib/ltablib.c
+source/libraries/lua/lib/lmathlib.c
+source/libraries/lua/lib/lstrlib.c
+source/libraries/lua/lib/liolib.c
+source/libraries/lua/lundump.c
+source/libraries/lua/ldebug.c
+source/libraries/lua/ldo.c
+source/libraries/lua/lgc.c
+source/libraries/lua/ltm.c
+source/libraries/lua/lvm.c
+source/libraries/lua/lcode.c
+source/libraries/lua/ldump.c
+source/libraries/lua/lfunc.c
+source/libraries/lua/lparser.c
+source/libraries/lua/ltable.c
+source/libraries/lua/ltests.c
+source/libraries/lua/lstate.c
+source/libraries/lua/lapi.c
+source/libraries/lua/llex.c
+source/libraries/lua/lmem.c
+source/libraries/lua/lzio.c
+source/libraries/lua/lopcodes.c
+source/libraries/lua/lobject.c
+source/libraries/lua/lstring.c
 source/libraries/agup/aphoton.c
 source/libraries/agup/ans.c
 source/libraries/agup/awin95.c


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000011.html">[Tw-light-svn] r63 - in trunk/source: . melee other sc1ships sc2ships ships util
</A></li>
	<LI>Next message: <A HREF="000013.html">[Tw-light-svn] r65 - in trunk: . doc gamedata source source/games
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12">[ date ]</a>
              <a href="thread.html#12">[ thread ]</a>
              <a href="subject.html#12">[ subject ]</a>
              <a href="author.html#12">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
