<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r60 - in trunk: . Util gamedata/images source source/ais source/games source/melee source/other source/sc1ships source/sc2ships source/ships source/twgui source/util web
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2004-September/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r60%20-%20in%20trunk%3A%20.%20Util%20gamedata/images%20source%20source/ais%20source/games%20source/melee%20source/other%20source/sc1ships%20source/sc2ships%20source/ships%20source/twgui%20source/util%20web&In-Reply-To=%3C200409202105.i8KL50rm023543%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000007.html">
   <LINK REL="Next"  HREF="000009.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r60 - in trunk: . Util gamedata/images source source/ais source/games source/melee source/other source/sc1ships source/sc2ships source/ships source/twgui source/util web</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r60%20-%20in%20trunk%3A%20.%20Util%20gamedata/images%20source%20source/ais%20source/games%20source/melee%20source/other%20source/sc1ships%20source/sc2ships%20source/ships%20source/twgui%20source/util%20web&In-Reply-To=%3C200409202105.i8KL50rm023543%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r60 - in trunk: . Util gamedata/images source source/ais source/games source/melee source/other source/sc1ships source/sc2ships source/ships source/twgui source/util web">yurand at sheep.berlios.de
       </A><BR>
    <I>Mon Sep 20 23:05:00 CEST 2004</I>
    <P><UL>
        <LI>Previous message: <A HREF="000007.html">[Tw-light-svn] r59 - in trunk/source: . melee
</A></li>
        <LI>Next message: <A HREF="000009.html">[Tw-light-svn] r61 - in trunk: gamedata/default_ini/ships gamedata/ships source source/ais source/melee
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2004-09-20 23:04:58 +0200 (Mon, 20 Sep 2004)
New Revision: 60

Added:
   trunk/Util/addStackTrace.pl
   trunk/gamedata/images/bspab.jpg
   trunk/gamedata/images/stangrop.jpg
Removed:
   trunk/gamedata/images/logo.bmp
Modified:
   trunk/makefile
   trunk/source/ais/c_input.cpp
   trunk/source/ais/c_other.cpp
   trunk/source/frame.cpp
   trunk/source/games/gflmelee.cpp
   trunk/source/gui.cpp
   trunk/source/melee/manim.cpp
   trunk/source/melee/mcbodies.cpp
   trunk/source/melee/mcontrol.cpp
   trunk/source/melee/mfleet.cpp
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mhelpers.cpp
   trunk/source/melee/mitems.cpp
   trunk/source/melee/mlog.cpp
   trunk/source/melee/mmain.cpp
   trunk/source/melee/mnet1.cpp
   trunk/source/melee/mship.cpp
   trunk/source/melee/mshot.cpp
   trunk/source/melee/mshpdata.cpp
   trunk/source/melee/mshppan.cpp
   trunk/source/melee/msprite.cpp
   trunk/source/melee/mtarget.cpp
   trunk/source/melee/mview.cpp
   trunk/source/other/nullphas.cpp
   trunk/source/other/objanim.cpp
   trunk/source/other/orbit.cpp
   trunk/source/other/planet3d.cpp
   trunk/source/other/radar.cpp
   trunk/source/other/shippart.cpp
   trunk/source/other/vbodies.cpp
   trunk/source/other/vtarget.cpp
   trunk/source/sc1ships/shpandgu.cpp
   trunk/source/sc1ships/shparisk.cpp
   trunk/source/sc1ships/shpchebr.cpp
   trunk/source/sc1ships/shpearcr.cpp
   trunk/source/sc1ships/shpilwav.cpp
   trunk/source/sc1ships/shpkzedr.cpp
   trunk/source/sc1ships/shpmmrxf.cpp
   trunk/source/sc1ships/shpmycpo.cpp
   trunk/source/sc1ships/shpshosc.cpp
   trunk/source/sc1ships/shpspael.cpp
   trunk/source/sc1ships/shpsyrpe.cpp
   trunk/source/sc1ships/shpumgdr.cpp
   trunk/source/sc1ships/shpvuxin.cpp
   trunk/source/sc1ships/shpyehte.cpp
   trunk/source/sc2ships/shpchmav.cpp
   trunk/source/sc2ships/shpdruma.cpp
   trunk/source/sc2ships/shpkohma.cpp
   trunk/source/sc2ships/shpmeltr.cpp
   trunk/source/sc2ships/shporzne.cpp
   trunk/source/sc2ships/shppkufu.cpp
   trunk/source/sc2ships/shpslypr.cpp
   trunk/source/sc2ships/shpsupbl.cpp
   trunk/source/sc2ships/shpthrto.cpp
   trunk/source/sc2ships/shputwju.cpp
   trunk/source/sc2ships/shpzfpst.cpp
   trunk/source/scp.cpp
   trunk/source/ships/shpaktgu.cpp
   trunk/source/ships/shpalabc.cpp
   trunk/source/ships/shpbahbu.cpp
   trunk/source/ships/shpbipka.cpp
   trunk/source/ships/shpbogce.cpp
   trunk/source/ships/shpchoex.cpp
   trunk/source/ships/shpconca.cpp
   trunk/source/ships/shpconho.cpp
   trunk/source/ships/shpdragr.cpp
   trunk/source/ships/shpearc3.cpp
   trunk/source/ships/shpforsh.cpp
   trunk/source/ships/shpgarty.cpp
   trunk/source/ships/shpilwsp.cpp
   trunk/source/ships/shpkahbo.cpp
   trunk/source/ships/shprogsq.cpp
   trunk/source/ships/shpstaba.cpp
   trunk/source/ships/shptauar.cpp
   trunk/source/ships/shptauda.cpp
   trunk/source/ships/shptaume.cpp
   trunk/source/ships/shptausl.cpp
   trunk/source/ships/shptaust.cpp
   trunk/source/ships/shptauto.cpp
   trunk/source/ships/shpwolmi.cpp
   trunk/source/ships/shpyusra.cpp
   trunk/source/ships/shpzeksh.cpp
   trunk/source/twgui/twbutton.cpp
   trunk/source/twgui/twbuttontypes.cpp
   trunk/source/twgui/twgui.cpp
   trunk/source/twgui/twhelpers.cpp
   trunk/source/twgui/twmenuexamples.cpp
   trunk/source/twgui/twpopup.cpp
   trunk/source/twgui/twwindow.cpp
   trunk/source/twgui/utils.cpp
   trunk/source/util/base.cpp
   trunk/source/util/errors.cpp
   trunk/source/util/errors.h
   trunk/source/util/history.cpp
   trunk/source/util/random.cpp
   trunk/source/util/sound.cpp
   trunk/source/util/vector2.cpp
   trunk/web/index.html
   trunk/web/style.css
Log:
Added Jhon stacktrace script
Sources was patched using this script
Added 2 loading screen



Added: trunk/Util/addStackTrace.pl
===================================================================
--- trunk/Util/addStackTrace.pl	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/Util/addStackTrace.pl	2004-09-20 21:04:58 UTC (rev 60)
@@ -0,0 +1,107 @@
+#!/usr/bin/perl -w
+
+# $Id$
+# Original Author: John Cataldo aka jodiamonds at imap dot cc
+# Modified by Yura Semashko aka Yurand
+
+# Put the text 'STACKTRACE;' at the beginning of each C++ function.
+# This only recognizes functions which look like: text :: text (
+# not_close_paren ) { So non-class functions will never be recognized.
+# This is really a two line script, turned into a much larger
+# program. =)
+
+# All affected files are backed up to name~~ (similar to emacs backup file names).
+# You can set BACKUP='' to turn this behavior off.
+
+# This script will first delete all existing STACKTRACE mentions and
+# replace them.  Ones with are on the same line are likely to be
+# placed onto the next line.
+
+use strict;
+{#create a lexical scope, so these variables are accessible to the subroutines (but not global per se)
+
+  ########################################
+  ### CONFIGURATION VARIABLES ###
+  my( $BACKUP ) = ''; #SET THIS TO '' STOP THIS SCRIPT FROM BACKING UP FILES
+
+  ########################################
+  ### CHECK THE ARGUMENTS ###
+  #each and every argument should be a filename to do the replacements on, readable and writable
+  my( @args ) = @ARGV;
+  my( $filename );
+  my( $test );
+  my( $invalidArguments ) = 0;
+  my( $fExists, $fReadable, $fWritable );
+  foreach $filename ( @args )
+    {
+      $fExists = -f $filename;
+      $fReadable = -r _;        #using _ means to use the stat() from the previous file stat(), which is better than checking it again
+      $fWritable = -w _;
+
+      warn &quot;$filename doesn't exist!&quot; unless $fExists;
+      warn &quot;$filename isn't readable by $0!&quot; unless $fReadable;
+      warn &quot;$filename isn't writable by $0!&quot; unless $fWritable;
+
+      $invalidArguments = 1 unless ( $fExists &amp;&amp; $fReadable &amp;&amp; $fWritable );
+    }
+  die &quot;\n\nAborting $0: One or more filenames aren't valid.  Usage: $0 filename filename ...&quot; if $invalidArguments;
+
+
+  foreach $filename( @args ) #process each file
+    {
+      print &quot;Processing $filename\n&quot;;
+
+      ########################################
+      ### GET ENTIRE FILE AS ONE STRING ###
+      #necessary for doing regex on the whole thing
+      open( INPUT, &quot;&lt;&quot;, $filename ) or die &quot;can't open $filename for input&quot;;
+      my( @file ) = &lt;INPUT&gt;;	#the raw input
+      my( $line );
+      my( $blob ) = &quot;&quot;;		#wholefile
+      foreach $line (@file) {
+	$blob .= $line;
+      }
+      close( INPUT );
+      @file = (); #just frees up some memory
+
+      my( $originalFile ) = $blob; #we save a copy of the file just to
+                                   #see if it changed.  this isn't
+                                   #particularly memory efficient, but
+                                   #is the simplest way to see if
+                                   #anything actually changed
+
+      ### THE MEAT OF THE FILE: TWO REGEXs ###
+      # Pretty much all of the actual changes happen on these two lines: 
+
+      # There's a couple weird things going on, like the \s* before
+      # STACKTRACE, which are just done to improve readability
+      # (i.e. try to put the new STACKTRACE in a place where it's most
+      # legible, which I define as on a line by itself at the same
+      # indentation as the NEXT line that's already in the function)
+
+      #the ';' after STACKTRACE appears to be optional, but this script will put it in afterwards.
+      #using /x at the end allows for commenting and whitespace!
+
+      ##### Delete all existing &quot;STACKTRACE&quot; instances (but only in the exact places where we will put it back in!) #####
+      $blob =~ s/(\s*\w+\s*::\s*\w+[(][^)]*[)]\s*(?:[:][^{]*)?\s*[{])\s*STACKTRACE;?/$1/xg;
+
+      ##### FIND THE PLACES STACKTRACE SHOULD SHOW UP, AND SHOVE IT IN THERE. #####
+      $blob =~ s/(\s*\w+\s*::\s*\w+[(][^)]*[)]\s*(?:[:][^{]*)?\s*[{])(\s*)/${1}\n  STACKTRACE;${2}/mg;
+      #/mg: multiline, since we have the whole file here, and global, meaning replace not just the first instance
+
+      #if the file changed, back it up and spit it out to disk
+      if ( $blob ne $originalFile )
+	{
+	  if ( $BACKUP )
+	    {
+	      rename $filename, &quot;${filename}~~&quot; or warn &quot;couldn't backup $filename to ${filename}~~\n&quot;;
+	      print &quot;\tBacked up $filename to ${filename}~~\n&quot;;
+	    }
+
+	  open( OUTPUT, &quot;&gt;&quot;, $filename ) or die &quot;couldn't open $filename for output&quot;;
+	  print OUTPUT $blob;
+	  close OUTPUT;
+	  print &quot;\tWrote out new $filename.\n&quot;;
+	}
+    }
+}


Property changes on: trunk/Util/addStackTrace.pl
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/gamedata/images/bspab.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/bspab.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: trunk/gamedata/images/logo.bmp
===================================================================
(Binary files differ)

Added: trunk/gamedata/images/stangrop.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stangrop.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/makefile	2004-09-20 21:04:58 UTC (rev 60)
@@ -195,6 +195,10 @@
 
 update_source_list:
 	find source -type f &quot;(&quot; -name &quot;*.c&quot; -o -name &quot;*.cpp&quot; &quot;)&quot; &gt;sources.lst
+
+add_stacktrace:
+	find source -name '*.cpp'|grep -v 'libraries'|grep -v 'errors.cpp'|grep -v 'utils.cpp'|xargs ./Util/addStackTrace.pl 
+
 install:
 	./install-sh $(NAME) $(EXECPATH)/$(NAME)
 	./install-sh gamedata $(DATAPATH)

Modified: trunk/source/ais/c_input.cpp
===================================================================
--- trunk/source/ais/c_input.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ais/c_input.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -215,12 +215,14 @@
 /*! \brief Get control name */
 const char *ControlHuman::getTypeName() 
 {
+  STACKTRACE;
   return &quot;Keyboard/Joystick&quot;;
 }
 
 /*! \brief Process get input from player */
 int ControlHuman::think() 
 {
+  STACKTRACE;
   int r = 0;
   if (key_pressed(thrust))  r |= keyflag::thrust;
   if (key_pressed(back))    r |= keyflag::back;
@@ -243,10 +245,11 @@
 
 ControlHuman::ControlHuman(const char *name, int channel) : Control(name, channel, ai_index_human) 
 {
+  STACKTRACE;
 };
 
 int ControlHuman::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) {
-	STACKTRACE;
+  STACKTRACE;
 	int ret = -1, slot = 0;
 	if (fleet-&gt;getSize() == 0) {tw_error (&quot;Empty fleet! (prompt:%s)&quot;, prompt);}
 	selectDialog[SELECT_DIALOG_LIST].dp3 = fleet;
@@ -277,6 +280,7 @@
 
 /*! returns help text for this controller ie keys to use this controller*/
 void ControlHuman::getHelpText(char * text) {
+  STACKTRACE;
 	char line[80] = &quot;&quot;;
 	char desc[80] = &quot;&quot;;
 
@@ -297,6 +301,7 @@
 /*! \brief setap players keys */
 void ControlHuman::setup() 
 {
+  STACKTRACE;
   int i, t = 0;
   int last = 0;
   while (true) 

Modified: trunk/source/ais/c_other.cpp
===================================================================
--- trunk/source/ais/c_other.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ais/c_other.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,11 +24,13 @@
 /*! \brief Get control name */
 const char *ControlVegetable::getTypeName() 
 {
+  STACKTRACE;
   return &quot;VegetableBot&quot;;
 }
 /*! \brief This AI do nothing */
 int ControlVegetable::think() 
 {
+  STACKTRACE;
   return 0;
 }
 /*! \brief This function do nothing
@@ -36,6 +38,7 @@
 */
 int ControlVegetable::choose_ship(VideoWindow *window, char * prompt, class Fleet *fleet ) 
 {
+  STACKTRACE;
   return -1;
 }
 
@@ -45,6 +48,7 @@
 
 const char *ControlMoron::getTypeName() 
 {
+  STACKTRACE;
   return &quot;MoronBot&quot;;
 }
 
@@ -90,6 +94,7 @@
 /*! \brief Summon stupid_bot() */
 int ControlMoron::think()
 {
+  STACKTRACE;
   if (ship)
     return stupid_bot(ship);
   else
@@ -98,6 +103,7 @@
 
 ControlMoron::ControlMoron(const char *name, int channel) : Control(name, channel, ai_index_moron) 
 {
+  STACKTRACE;
 }
 
 

Modified: trunk/source/frame.cpp
===================================================================
--- trunk/source/frame.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/frame.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -125,6 +125,7 @@
 
 Frame::Frame(int max_items) 
 {
+  STACKTRACE;
   window = new VideoWindow();
   window-&gt;preinit();
   surface = NULL;
@@ -165,6 +166,7 @@
 /*! \brief weild code to enlarge amount of items */
 void Frame::enlarge_list(int increment) 
 {
+  STACKTRACE;
   DirtyItem *temp;
   
   temp = item;
@@ -222,42 +224,49 @@
 /*! \brief Add pixel item to item list */
 void Frame::add_pixel(int x, int y)
 {
+  STACKTRACE;
   add_to_list(x, y, 0, 0, erase_pixel, draw_pixel);
 }
 
 /*! \brief Add box item to item list */
 void Frame::add_box(double x, double y, double w, double h)
 {
+  STACKTRACE;
   add_to_list((int)x, (int)y, (int)w, (int)h, erase_box, draw_box);
 }
 
 /*! \brief Add circle item to item list */
 void Frame::add_circle(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_list(x, y, a, b, erase_circle, draw_circle);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_circle(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(x, y, a, b, erase_circle, draw_circle);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_line(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_list(x, y, a, b, erase_line, draw_line);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_pixel(int x, int y)
 {
+  STACKTRACE;
   add_to_old_list(x, y, 0, 0, erase_pixel, draw_pixel);
 }
 
 /*! \brief to be deleted? */
 void Frame::add_old_box(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(
 		  x, 
 		  y, 
@@ -270,6 +279,7 @@
 /*! \brief to be deleted? */
 void Frame::add_old_line(int x, int y, int a, int b)
 {
+  STACKTRACE;
   add_to_old_list(x, y, a, b, erase_line, draw_line);
 }
 

Modified: trunk/source/games/gflmelee.cpp
===================================================================
--- trunk/source/games/gflmelee.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/games/gflmelee.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -180,6 +180,7 @@
 
 StatsManager::StatsManager()
 {
+  STACKTRACE;
   Nships = 0;
   // no stats yet :)
 
@@ -465,6 +466,7 @@
 
 YRadar::YRadar(Control *ocontroller, double Size, TeamCode hteam, char *datafilename, bool rel, int shape)
 {
+  STACKTRACE;
   relative_angle = rel;
   display_shape = shape;
   
@@ -532,11 +534,13 @@
 
 void YRadar::toggleActive()
 {
+  STACKTRACE;
   active^=1;
 }
 
 void YRadar::setSize(double Size)
 {
+  STACKTRACE;
   size=Size;
 }
 
@@ -684,6 +688,7 @@
 
 ImIndicator::ImIndicator(SpaceLocation *o)
 {
+  STACKTRACE;
   showme = o;
   
   bmp = create_bitmap_ex( bitmap_color_depth(screen), ImIndicatorSize, ImIndicatorSize);

Modified: trunk/source/gui.cpp
===================================================================
--- trunk/source/gui.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/gui.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -90,6 +90,7 @@
 
 void TW_Dialog_Player::redraw() 
 {
+  STACKTRACE;
   int i;
   if (!player) return;
   for (i = 0; player-&gt;dialog[i].proc; i++) player-&gt;dialog[i].flags |= D_DIRTY;
@@ -99,6 +100,7 @@
 
 void TW_Dialog_Player::_event( Event * e) 
 {
+  STACKTRACE;
   switch (e-&gt;type) 
     {
     case Event::VIDEO: {
@@ -110,6 +112,7 @@
 
 void TW_Dialog_Player::init(VideoWindow *w, DIALOG *d, int focus) 
 {
+  STACKTRACE;
   dialog = d;
   window = w;
   ifocus = focus;
@@ -162,6 +165,7 @@
 }
 void TW_Dialog_Player::deinit() 
 {
+  STACKTRACE;
   int i;
   window-&gt;remove_callback(this);
   dialog[length].d2 -= 1;
@@ -188,6 +192,7 @@
 }
 int TW_Dialog_Player::update() 
 {
+  STACKTRACE;
   videosystem.poll_redraw();
   BITMAP *old = screen;
   screen = subscreen;

Modified: trunk/source/melee/manim.cpp
===================================================================
--- trunk/source/melee/manim.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/manim.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -53,7 +53,7 @@
 }
 
 void Animation::calculate() 
-{ 
+{
   STACKTRACE;
   frame_step -= frame_time;
   while (frame_step &lt; 0) 
@@ -101,6 +101,7 @@
 
 void FixedAnimation::calculate() 
 {
+  STACKTRACE;
   if (follow-&gt;exists()) 
     {
       pos = follow-&gt;normal_pos();
@@ -120,6 +121,7 @@
   FixedAnimation(creator, opos, osprite, first_frame, num_frames, frame_length, depth),
   relative_pos(rel_pos)
 {
+  STACKTRACE;
   if (!follow || !follow-&gt;exists()) 
     {
       state = 0;
@@ -130,6 +132,7 @@
 
 void PositionedAnimation::calculate() 
 {
+  STACKTRACE;
   FixedAnimation::calculate();
   if (!exists()) 
     return;

Modified: trunk/source/melee/mcbodies.cpp
===================================================================
--- trunk/source/melee/mcbodies.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mcbodies.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 Asteroid::Asteroid() 
 :	SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite), explosion(meleedata.asteroidExplosionSprite)
 {
+  STACKTRACE;
   collide_flag_sameteam = ALL_LAYERS;
   collide_flag_sameship = ALL_LAYERS;
   layer = LAYER_CBODIES;
@@ -51,6 +52,7 @@
 
 void Asteroid::calculate()
 {
+  STACKTRACE;
   step-= frame_time;
   while(step &lt;= 0) 
     {
@@ -64,6 +66,7 @@
 
 int Asteroid::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   if (!exists()) 
     return 0;
   if (!normal &amp;&amp; !direct) 
@@ -77,7 +80,8 @@
 }
 
 void Asteroid::death() 
-{		  
+{
+  STACKTRACE;		  
   Animation *a = new Animation(this, pos,
 			       explosion, 0, explosion-&gt;frames(), time_ratio, get_depth());
   a-&gt;match_velocity(this);
@@ -91,6 +95,7 @@
   :
   SpaceObject(NULL, loc, 0.0, sprite) 
 {
+  STACKTRACE;
   collide_flag_sameship = ALL_LAYERS;
   layer = LAYER_CBODIES;
   set_depth(DEPTH_PLANETS);
@@ -110,6 +115,7 @@
 
 void Planet::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   int i = 1;
   if (other-&gt;isShip()) 
     {
@@ -147,6 +153,7 @@
 
 void Planet::calculate() 
 {
+  STACKTRACE;
   SpaceObject::calculate();
   SpaceObject *o;
   Query a;
@@ -329,10 +336,12 @@
 
 void Stars::select_view( View **view) 
 {
+  STACKTRACE;
   v = view;
 }
 
 void Stars::_event( Event *e) {
+  STACKTRACE;
   if (e-&gt;type == Event::TW_CONFIG) 
     {
       ConfigEvent *ce = (ConfigEvent *) e;
@@ -358,6 +367,7 @@
 
 Stars::Stars()
 {
+  STACKTRACE;
   int i;
   v = NULL;
   set_depth(DEPTH_STARS);
@@ -404,6 +414,7 @@
 
 void Stars::animate(Frame *space) 
 {
+  STACKTRACE;
   if (v &amp;&amp; (space_view != *v)) return;
 
   double d = space_zoom;

Modified: trunk/source/melee/mcontrol.cpp
===================================================================
--- trunk/source/melee/mcontrol.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mcontrol.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -85,14 +85,17 @@
 
 int Control::rand() 
 {
+  STACKTRACE;
   if (channel == Game::channel_none) 
     return random();
   return (::rand() ^ ((::rand() &lt;&lt; 12) + (::rand() &lt;&lt;24))) &amp; 0x7fffffff;
 }
 
-void Control::setup() {}
+void Control::setup() {
+  STACKTRACE;}
 void Control::select_ship(Ship* ship_pointer, const char* ship_name) 
 {
+  STACKTRACE;
   ship = ship_pointer;
   if (ship) 
     {
@@ -108,14 +111,17 @@
 
 void Control::load(const char* inifile, const char* inisection) 
 {
+  STACKTRACE;
   return;
 }
 void Control::save(const char* inifile, const char* inisection) 
 {
+  STACKTRACE;
   return;
 }
 SpaceLocation *Control::get_focus() 
 {
+  STACKTRACE;
   if (ship) 
     return ship-&gt;get_focus();
   else return NULL;
@@ -124,6 +130,7 @@
 
 int Control::choose_ship(VideoWindow *window, char * prompt, Fleet *fleet) 
 {
+  STACKTRACE;
 	//automatically select a random ship, without interrupting the user.
 	// HumanControl is where a user can select a ship herself.
 		
@@ -135,6 +142,7 @@
 }
 void Control::set_target(int i) 
 {
+  STACKTRACE;
   if (i &gt;= targets-&gt;N) {tw_error(&quot;oscar hamburger!!!!!!!!!&quot;);}
   if (i == -1) 
     {
@@ -150,6 +158,7 @@
 
 void Control::target_stuff() 
 {
+  STACKTRACE;
   if (index == -1) 
     {
       if (targets-&gt;N) 
@@ -214,7 +223,8 @@
 }
 
 void Control::calculate() 
-{ 
+{
+  STACKTRACE; 
   if (!exists()) 
     return;
 
@@ -276,14 +286,17 @@
 
 int Control::think()
 {
+  STACKTRACE;
   return 0;
 }
 char *Control::getDescription() 
 {
+  STACKTRACE;
    return iname;
 }
 void Control::_event(Event *e) 
 {
+  STACKTRACE;
    //add code for lag increase / decrease here
   return;
 }
@@ -292,6 +305,7 @@
 						   target(NULL), index(-1), always_random(0), _prediction_keys(NULL),
 						   _controlType(controlType)
 {
+  STACKTRACE;
   id |= ID_CONTROL;
   attributes |= ATTRIB_SYNCHED;
   if (channel != Game::channel_none) 
@@ -312,6 +326,7 @@
 }
 bool Control::die() 
 {
+  STACKTRACE;
   if (channel == Game::channel_none) 
     return Presence::die();
   // controls CANNOT arbitrarily be killed off, because the deal with networking directly
@@ -324,6 +339,7 @@
 
 bool Control::valid_target(SpaceObject *t) 
 {
+  STACKTRACE;
   // GEO: this error sometimes occur, unknown why.
   // speculation: it happened with a wasx clone; perhaps its mother died before
   // and since it shared control, and didn't check for a dead mother before the

Modified: trunk/source/melee/mfleet.cpp
===================================================================
--- trunk/source/melee/mfleet.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mfleet.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -76,14 +76,15 @@
 	reference_fleet-&gt;Sort();
 }
 
-    Fleet::Fleet() {STACKTRACE
+    Fleet::Fleet() {
+  STACKTRACE;
         cost = 0;
         maxFleetCost = (FleetCost)FLEET_COST_DEFAULT;
         memset(title, '\0', MAX_TITLE_LENGTH);
     };
 
     void Fleet::reset() {
-		STACKTRACE;
+  STACKTRACE;
         ships.clear();
         this-&gt;cost = 0;
         memset(title, '\0', MAX_TITLE_LENGTH);
@@ -120,7 +121,8 @@
 #define READ(a) if (int(s+sizeof(a))&gt;psize) {delete k;tw_error (&quot;deserialize_fleet - bad!&quot;);}memcpy(&amp;a, &amp;buffy[s], sizeof(a)); s += sizeof(a);
 #define READ2(a,b) if (b+s&gt;psize) {delete k;tw_error (&quot;deserialize_fleet - bad!&quot;);}memcpy(&amp;a, &amp;buffy[s], b); s += b;
 
-void Fleet::deserialize(void *data, int psize) {        
+void Fleet::deserialize(void *data, int psize) {
+  STACKTRACE;        
   unsigned char *buffy = (unsigned char *) data;
   int s = 0;
   int j;
@@ -176,6 +178,7 @@
        
 
     int Fleet::addShipType(ShipType * type) {
+  STACKTRACE;
         if ( (getSize() &gt;= MAX_FLEET_SIZE) || (type == NULL))
             return -1;
 
@@ -186,6 +189,7 @@
     }
 
     void Fleet::addFleet(Fleet * fleetToAdd) {
+  STACKTRACE;
         for (int i=0; i&lt;fleetToAdd-&gt;getSize(); i++)
             addShipType(fleetToAdd-&gt;getShipType(i));
     }
@@ -198,14 +202,16 @@
     
     }
 
-    ShipType * Fleet::getShipType(int slot) {STACKTRACE
+    ShipType * Fleet::getShipType(int slot) {
+  STACKTRACE;
         if ( (slot&lt;0) || (slot&gt;=(int)ships.size()))
             return NULL;
 
         return ships[slot];
     }
 
-    void Fleet::save(const char *filename, const char *section) {STACKTRACE
+    void Fleet::save(const char *filename, const char *section) {
+  STACKTRACE;
         int count = 0;
         char slot_str[8];
     
@@ -227,7 +233,8 @@
         set_config_int(section, &quot;MaxFleetCost&quot;, getMaxCost());
     }
 
-    void Fleet::load(const char *filename, const char *section) {STACKTRACE
+    void Fleet::load(const char *filename, const char *section) {
+  STACKTRACE;
         int i, count;
         ShipType *type;
         char slot_str[8];
@@ -385,6 +392,7 @@
 };
 
 void Fleet::Sort(SortingMethod sortMethod, bool ascending, int startIndex, int endIndex) {
+  STACKTRACE;
   MyFleetListType::iterator _begin, _end;
   int _size = ships.size();
   
@@ -464,6 +472,7 @@
 }
 
 int Fleet::getNextFleetEntryByCharacter(unsigned int currentShip, char c) {
+  STACKTRACE;
         
         ASSERT(ships.at(currentShip) != NULL);
         ASSERT(currentShip &lt; ships.size());

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mframe.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -174,7 +174,8 @@
 	return;
 	}
 
-void Query::end() {STACKTRACE
+void Query::end() {
+  STACKTRACE;
 	}
 
 
@@ -294,11 +295,13 @@
 	return;
 	}
 
-void Query2::end() {STACKTRACE
+void Query2::end() {
+  STACKTRACE;
 	}
 
 
-Presence::Presence() {STACKTRACE
+Presence::Presence() {
+  STACKTRACE;
 	total_presences += 1;
 	attributes = 0;
 	state = 1;
@@ -365,10 +368,12 @@
 	return ((attributes &amp; ATTRIB_SYNCHED) != 0);
 	}
 
-SpaceLocation *Presence::get_focus() {STACKTRACE
+SpaceLocation *Presence::get_focus() {
+  STACKTRACE;
 	return NULL;
 	}
-SpaceLocation *SpaceLocation::get_focus() {STACKTRACE
+SpaceLocation *SpaceLocation::get_focus() {
+  STACKTRACE;
 	return this;
 	}
 
@@ -383,7 +388,8 @@
 	collide_flag_sameteam(0),
 	collide_flag_sameship(0)
 
-{STACKTRACE
+{
+  STACKTRACE;
 	id |= SPACE_LOCATION;
 	attributes |= ATTRIB_SYNCHED;
 	attributes |= ATTRIB_LOCATION;
@@ -408,7 +414,8 @@
 
 	}
 
-bool SpaceLocation::change_owner(SpaceLocation *new_owner) {STACKTRACE
+bool SpaceLocation::change_owner(SpaceLocation *new_owner) {
+  STACKTRACE;
 	if (new_owner) {
 		ally_flag = new_owner-&gt;ally_flag;
 		ship = new_owner-&gt;ship;
@@ -422,7 +429,8 @@
 	return true;
 	}
 
-void SpaceLocation::death() {STACKTRACE
+void SpaceLocation::death() {
+  STACKTRACE;
 }
 
 double SpaceLocation::get_angle_ex() const
@@ -456,7 +464,8 @@
 }
 
 double SpaceLocation::distance(SpaceLocation *l)
-{STACKTRACE
+{
+  STACKTRACE;
   return(distance_from(normal_pos(), l-&gt;normal_pos()));
 }
 
@@ -474,6 +483,7 @@
 
 void SpaceLocation::change_vel(Vector2 dvel)
 {
+  STACKTRACE;
 	vel += dvel;
 }
 
@@ -481,6 +491,7 @@
 */
 void SpaceLocation::change_pos(Vector2 dpos)
 {
+  STACKTRACE;
 	pos = normalize(pos + dpos);
 }
 
@@ -488,23 +499,28 @@
 */
 void SpaceLocation::change_pos(double scale)
 {
+  STACKTRACE;
 	pos *= scale;
 }
 
-void SpaceLocation::ship_died() {STACKTRACE
+void SpaceLocation::ship_died() {
+  STACKTRACE;
 	ship = NULL;
 }
 void SpaceLocation::target_died() {
+  STACKTRACE;
 	target = NULL;
 }
 
-double SpaceLocation::trajectory_angle(SpaceLocation *l) {STACKTRACE
+double SpaceLocation::trajectory_angle(SpaceLocation *l) {
+  STACKTRACE;
 	return ::trajectory_angle(pos, l-&gt;normal_pos());
 }
 
 
 bool inline SpaceLocation::detectable()
 {
+  STACKTRACE;
 	int i;
 	i = attributes &amp; ATTRIB_UNDETECTABLE;
 
@@ -515,6 +531,7 @@
 
 
 int SpaceLocation::canCollide(SpaceLocation *other) {
+  STACKTRACE;
 	if (!detectable()) return 0;
 	if (sameShip(other)) return ((1 &lt;&lt; other-&gt;layer) &amp; collide_flag_sameship);
 	else if (sameTeam(other)) return ((1 &lt;&lt; other-&gt;layer) &amp; collide_flag_sameteam);
@@ -528,6 +545,7 @@
 
 void SpaceLocation::set_team(TeamCode k)
 {
+  STACKTRACE;
 	ally_flag &amp;= ~team_mask;
 	ally_flag |= k &lt;&lt; team_shift;
 }
@@ -545,14 +563,17 @@
 }
 
 void Presence::set_depth(double d) {
+  STACKTRACE;
 	_depth = int(floor(ldexp(d, 8)));
 }
 
 double Presence::get_depth() {
+  STACKTRACE;
 	return ldexp((double)_depth, -8);
 }
 
-Planet *SpaceLocation::nearest_planet() {STACKTRACE
+Planet *SpaceLocation::nearest_planet() {
+  STACKTRACE;
 	Planet *p = NULL;
 	double r = 99999999;
 	Query q;
@@ -572,22 +593,26 @@
 
 int SpaceLocation::translate( Vector2 delta) 
 {
+  STACKTRACE;
   pos = normalize ( pos + delta, map_size );
   return true;
 }
 
 int SpaceLocation::accelerate(SpaceLocation *source, double angle, double velocity, double max_speed) 
 {
+  STACKTRACE;
   _accelerate(angle, velocity, max_speed);
   return true;
 }
 int SpaceLocation::accelerate(SpaceLocation *source, Vector2 delta_v, double max_speed) 
 {
+  STACKTRACE;
   _accelerate(delta_v, max_speed);
   return true;
 }
 void SpaceLocation::_accelerate(double angle, double velocity, double max_speed) 
 {
+  STACKTRACE;
   double ovm, nvm;
   Vector2 nv;
 
@@ -609,6 +634,7 @@
 
 void SpaceLocation::_accelerate(Vector2 delta_v, double max_speed) 
 {
+  STACKTRACE;
   double ovm, nvm;
   Vector2 nv;
 
@@ -637,6 +663,7 @@
 				       double velocity, 
 				       double max_speed) 
 {
+  STACKTRACE;
 	Planet *p = nearest_planet();
 	if (!p) return SpaceLocation::accelerate(source, angle, velocity, max_speed);
 	double tmp;
@@ -650,10 +677,12 @@
 
 void SpaceLocation::animate(Frame* f) 
 {
+  STACKTRACE;
 }
 
 void SpaceLocation::calculate() 
 {
+  STACKTRACE;
   if (target &amp;&amp; !target-&gt;exists()) 
     {
       target_died();
@@ -667,12 +696,14 @@
 
 void SpaceObject::set_sprite(SpaceSprite *new_sprite) 
 {
+  STACKTRACE;
   sprite = new_sprite;
   size = new_sprite-&gt;size();
 }
 
 void SpaceObject::calculate() 
 {
+  STACKTRACE;
   SpaceLocation::calculate();
   if ((attributes &amp; ATTRIB_STANDARD_INDEX) &amp;&amp; sprite) 
     {
@@ -690,6 +721,7 @@
   sprite(osprite),
   sprite_index(0)
 {
+  STACKTRACE;
   attributes |= ATTRIB_OBJECT;
   if (game &amp;&amp; game-&gt;friendly_fire) collide_flag_sameteam = ALL_LAYERS;
   collide_flag_sameship = 0;
@@ -701,12 +733,14 @@
 
 void SpaceObject::animate(Frame *space) 
 {
+  STACKTRACE;
   sprite-&gt;animate(pos, sprite_index, space);
   return;
 }
 
 void SpaceObject::collide(SpaceObject *other) 
 {
+  STACKTRACE;
   double tmp;
   
   if (this == other) {tw_error(&quot;SpaceObject::collide - self!&quot;);}
@@ -778,6 +812,7 @@
 
 double SpaceObject::collide_ray(Vector2 lp1, Vector2 lp2, double llength)
 {
+  STACKTRACE;
 	int collide_x = (int)(lp2.x);
 	int collide_y = (int)(lp2.y);
 	Vector2 d;
@@ -796,6 +831,7 @@
 
 void SpaceObject::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   int i;
   if (damage_factor &gt; 0) 
     {
@@ -831,6 +867,7 @@
 }
 
 void SpaceObject::death() {
+  STACKTRACE;
 	if (attributes &amp; ATTRIB_NOTIFY_ON_DEATH) {
 		physics-&gt;object_died(this, NULL);
 		attributes &amp;= ~ ATTRIB_NOTIFY_ON_DEATH;
@@ -843,7 +880,8 @@
 	SpaceLocation(creator, lpos, langle),
 	length(llength),
 	color(lcolor)
-	{STACKTRACE
+	{
+  STACKTRACE;
 	id = SPACE_LINE;
 	attributes |= ATTRIB_LINE;// | ATTRIB_COLLIDE_STATIC;
 	layer = LAYER_LINES;
@@ -908,6 +946,7 @@
 
 void SpaceLine::animate(Frame *space) 
 {
+  STACKTRACE;
   
   Vector2 p1 = corner( pos );
   Vector2 p2 = p1 + edge() * space_zoom;
@@ -962,10 +1001,12 @@
 }
 
 unsigned int Physics::new_ship() {
+  STACKTRACE;
 	last_ship += 1;
 	return last_ship;
 	}
 TeamCode Physics::new_team() {
+  STACKTRACE;
 	last_team += 1;
 	return last_team;
 	}
@@ -1012,7 +1053,7 @@
 
 
 void Physics::add(SpaceLocation *o) {
-	STACKTRACE;
+  STACKTRACE;
 	if (o-&gt;attributes &amp; ATTRIB_INGAME) {tw_error(&quot;addItem - already added&quot;);}
 	if (!o-&gt;isLocation()) {tw_error(&quot;addItem - catastrophic&quot;);}
 	//if (!o-&gt;_serial) _list(o);
@@ -1102,8 +1143,9 @@
     return false;
 }
 
-void Physics::calculate() {
-  _STACKTRACE(&quot;Physics::calculate()&quot;);
+void Physics::calculate() 
+{
+  STACKTRACE;
   int i;
   
   //adjust time
@@ -1242,8 +1284,9 @@
 }
 
 
-void Physics::collide() {
-  _STACKTRACE(&quot;Physics::collide()&quot;);
+void Physics::collide() 
+{
+  STACKTRACE;
   PMASKDATA_FLOAT *tmp;
   int l = 0;
   tmp = new PMASKDATA_FLOAT[item.size()];
@@ -1297,7 +1340,8 @@
   return;
 }
 
-void Physics::prepare() {STACKTRACE
+void Physics::prepare() {
+  STACKTRACE;
 	::physics_time = this-&gt;game_time;
 	::render_time = this-&gt;game_time;
 	::frame_time = this-&gt;frame_time;
@@ -1306,7 +1350,7 @@
 	return;
 }
 int Physics::checksum() {
-  _STACKTRACE(&quot;Physics::checksum&quot;);
+  STACKTRACE;
   Uint32 g = 0;
   for(std::list&lt;SpaceLocation*&gt;::iterator i=item.begin();i!=item.end();i++)
     {
@@ -1332,12 +1376,14 @@
 
 void Physics::ship_died(Ship *who, SpaceLocation *source)
 {
+  STACKTRACE;
 	// nothing ...
 }
 
 
 void Physics::object_died(SpaceObject *who, SpaceLocation *source)
 {
+  STACKTRACE;
   if (who &amp;&amp; who-&gt;isShip())
     {
       ship_died((Ship*)who, source);

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mgame.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -56,6 +56,7 @@
 
 MeleeData::MeleeData()
 {
+  STACKTRACE;
 	panelSprite             = NULL;
 	kaboomSprite            = NULL;
 	hotspotSprite           = NULL;
@@ -72,6 +73,7 @@
 
 void MeleeData::init()
 {
+  STACKTRACE;
   melee = load_datafile(data_full_path(&quot;melee.dat&quot;).c_str());
   if (!melee) tw_error(&quot;Error loading melee data\n&quot;);
 
@@ -101,6 +103,7 @@
 
 void MeleeData::deinit()
 {
+  STACKTRACE;
 	panelSprite             = NULL;
 	kaboomSprite            = NULL;
 	hotspotSprite           = NULL;
@@ -152,6 +155,7 @@
 
 Game *GameType::new_game() 
 {
+  STACKTRACE;
   Game *tmp = _new_game();
   tmp-&gt;preinit();
   tmp-&gt;type = this;
@@ -183,6 +187,7 @@
 
 void Game::_event(Event *e) 
 {
+  STACKTRACE;
   switch (e-&gt;type) 
     {
     case Event::VIDEO: 
@@ -223,6 +228,7 @@
 
 void Game::add_focus(Presence *new_focus, int channel) 
 {
+  STACKTRACE;
   if ((channel != -1) &amp;&amp; !log-&gt;playback &amp;&amp; !(log-&gt;get_direction(channel) &amp; Log::direction_write))
     return;
   num_focuses += 1;
@@ -235,6 +241,7 @@
 
 
 void Game::prepare() {
+  STACKTRACE;
 #ifdef _MSC_VER
   _asm { finit }
 #elif defined(__GCC__) &amp;&amp; defined(__i386__)
@@ -248,6 +255,7 @@
 
 void Game::set_resolution(int screen_x, int screen_y) 
 {
+  STACKTRACE;
   int view_x, view_y;
   view_x = screen_x;
   view_y = screen_y;
@@ -257,6 +265,7 @@
 
 void Game::redraw() 
 {
+  STACKTRACE;
   if (!window-&gt;surface) return;
   scare_mouse();
   window-&gt;lock();
@@ -272,6 +281,7 @@
 
 Ship *Game::create_ship(const char *id, Control *c, Vector2 pos, double angle, int team) 
 {
+  STACKTRACE;
   ShipType *type = shiptype(id);
   if (!type)
     {tw_error(&quot;Game::create_ship - bad ship id (%s)&quot;, id);}
@@ -287,6 +297,7 @@
 
 Ship *Game::create_ship(int channel, const char *id, const char *control, Vector2 pos, double angle, int team) 
 {
+  STACKTRACE;
   Control *c = create_control(channel, control);
   if (!c)
     {tw_error(&quot;bad Control type!&quot;);}
@@ -297,6 +308,7 @@
 
 void Game::increase_latency() 
 {
+  STACKTRACE;
   if (CHECKSUM_CHANNEL) {
     log-&gt;buffer(channel_server + Game::_channel_buffered, NULL, 2);
     log-&gt;buffer(channel_client + Game::_channel_buffered, NULL, 2);
@@ -309,6 +321,7 @@
 
 void Game::decrease_latency() 
 {
+  STACKTRACE;
   if (lag_frames &lt;= 1) {tw_error(&quot;latency decreased too far&quot;);}
   if (CHECKSUM_CHANNEL) {
     log-&gt;unbuffer(channel_server + Game::_channel_buffered, NULL, 2);
@@ -330,6 +343,7 @@
 
 void Game::log_fleet(int channel, Fleet *fleet) 
 {
+  STACKTRACE;
   int fl;
   void *tmpdata = fleet-&gt;serialize(&amp;fl);
   char buffer[16384];
@@ -361,12 +375,14 @@
 }
 
 void Game::log_char(int channel, char &amp;data) {
+  STACKTRACE;
 	if (!log) return;
 	log-&gt;log  (channel, &amp;data, 1);
 	return;
 }
 
 void Game::log_short(int channel, short &amp;data) {
+  STACKTRACE;
 	if (!log) return;
 	data = intel_ordering_short(data);	
 	log-&gt;log  (channel, &amp;data, sizeof(short));
@@ -375,6 +391,7 @@
 }
 
 void Game::log_int(int channel, int &amp;data) {
+  STACKTRACE;
 	if (!log) return;
 	data = intel_ordering(data);
 	log-&gt;log  (channel, &amp;data, sizeof(int));
@@ -382,13 +399,15 @@
 	return;
 }
 
-void Game::log_data(int channel, void *data, int size) {STACKTRACE
+void Game::log_data(int channel, void *data, int size) {
+  STACKTRACE;
 	if (!log) return;
 	log-&gt;log  (channel, data, size);
 	return;
 }
 
-void Game::idle(int time) {STACKTRACE
+void Game::idle(int time) {
+  STACKTRACE;
 	if (log-&gt;listen()) return;
 	::idle(time);
 	return;
@@ -396,11 +415,13 @@
 
 void Game::animate(Frame *frame) 
 {
+  STACKTRACE;
   Physics::animate(frame);
 }
 
 void Game::animate() 
 {
+  STACKTRACE;
   double t = get_time();
   paused_time = 0;
   view-&gt;animate(this);
@@ -409,7 +430,8 @@
   return;
 }
 
-bool Game::game_ready() {STACKTRACE
+bool Game::game_ready() {
+  STACKTRACE;
 	if (CHECKSUM_CHANNEL == 0) return 1;
 	if (log-&gt;playback) {
 		return (log-&gt;ready(channel_server + Game::_channel_buffered) != 0);
@@ -456,6 +478,7 @@
 
 void Game::compare_checksums() 
 {
+  STACKTRACE;
   unsigned char local_checksum = checksum() &amp; 255;
   unsigned char client_checksum = local_checksum;
   unsigned char server_checksum = local_checksum;
@@ -483,115 +506,126 @@
     }
 }
 
-void Game::do_game_events() {_STACKTRACE(&quot;Game::do_game_events()&quot;)
-	int i;
+void Game::do_game_events() 
+{
+  STACKTRACE;
+  int i;
 
-	//transmit from server
-	if (log-&gt;get_direction(channel_server) &amp; Log::direction_write) {
-		COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
-		log-&gt;buffer( channel_server + _channel_buffered, &amp;events_waiting, sizeof(events_waiting) );
-		for (i = 0; i &lt; events_waiting; i += 1) {
-			log-&gt;buffer ( channel_server + _channel_buffered, waiting_events[i], waiting_events[i]-&gt;size );
-		}
-		//deallocate transmitted events
-		for (i = 0; i &lt; events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//transmit from client
-	if (log-&gt;get_direction(channel_client) &amp; Log::direction_write) {
-		COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
-		log-&gt;buffer( channel_client + _channel_buffered, &amp;events_waiting, sizeof(events_waiting) );
-		for (i = 0; i &lt; events_waiting; i += 1) {
-			log-&gt;buffer ( channel_client + _channel_buffered, waiting_events[i], waiting_events[i]-&gt;size );
-		}
-		//deallocate transmitted events
-		for (i = 0; i &lt; events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//double-check transmission
-	if (events_waiting) {
-		tw_error(&quot;Game::do_game_events - events weren't sent properly&quot;);
-		for (i = 0; i &lt; events_waiting; i += 1) free(waiting_events[i]);
-		events_waiting = 0;
-	}
-
-	//recieve
-	char ne;
-	COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(ne));
-	char buffy[1024];
-
-	//recieve from server
-	log-&gt;unbuffer(channel_server + _channel_buffered, &amp;ne, sizeof(ne));
-	for (i = 0; i &lt; ne; i += 1) {
-		char *tmp = buffy;
-		log-&gt;unbuffer(channel_server + _channel_buffered, &amp;buffy, sizeof(GameEvent));
-		int s = ((GameEvent*)tmp)-&gt;size;
-		if (s &gt; 1024) {
-			tmp = (char *)malloc(s);
-			memcpy(tmp, buffy, sizeof(GameEvent));
-		}
+  //transmit from server
+  if (log-&gt;get_direction(channel_server) &amp; Log::direction_write) {
+    COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
+    log-&gt;buffer( channel_server + _channel_buffered, &amp;events_waiting, sizeof(events_waiting) );
+    for (i = 0; i &lt; events_waiting; i += 1) {
+      log-&gt;buffer ( channel_server + _channel_buffered, waiting_events[i], waiting_events[i]-&gt;size );
+    }
+    //deallocate transmitted events
+    for (i = 0; i &lt; events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //transmit from client
+  if (log-&gt;get_direction(channel_client) &amp; Log::direction_write) {
+    COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(char));
+    log-&gt;buffer( channel_client + _channel_buffered, &amp;events_waiting, sizeof(events_waiting) );
+    for (i = 0; i &lt; events_waiting; i += 1) {
+      log-&gt;buffer ( channel_client + _channel_buffered, waiting_events[i], waiting_events[i]-&gt;size );
+    }
+    //deallocate transmitted events
+    for (i = 0; i &lt; events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //double-check transmission
+  if (events_waiting) {
+    tw_error(&quot;Game::do_game_events - events weren't sent properly&quot;);
+    for (i = 0; i &lt; events_waiting; i += 1) free(waiting_events[i]);
+    events_waiting = 0;
+  }
+  
+  //recieve
+  char ne;
+  COMPILE_TIME_ASSERT(sizeof(events_waiting) == sizeof(ne));
+  char buffy[1024];
+  
+  //recieve from server
+  log-&gt;unbuffer(channel_server + _channel_buffered, &amp;ne, sizeof(ne));
+  for (i = 0; i &lt; ne; i += 1) {
+    char *tmp = buffy;
+    log-&gt;unbuffer(channel_server + _channel_buffered, &amp;buffy, sizeof(GameEvent));
+    int s = ((GameEvent*)tmp)-&gt;size;
+    if (s &gt; 1024) {
+      tmp = (char *)malloc(s);
+      memcpy(tmp, buffy, sizeof(GameEvent));
+    }
 		log-&gt;unbuffer(channel_server + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
 		handle_game_event ( channel_server, ((GameEvent*)tmp));
 		if (tmp != buffy) free(tmp);
-	}
-
-
-	//recieve from client
-	log-&gt;unbuffer(channel_client + _channel_buffered, &amp;ne, sizeof(ne));
-	for (i = 0; i &lt; ne; i += 1) {
-		char *tmp = buffy;
-		log-&gt;unbuffer(channel_client + _channel_buffered, &amp;buffy, sizeof(GameEvent));
-		int s = ((GameEvent*)tmp)-&gt;size;
-		if (s &gt; 1024) {
-			tmp = (char *)malloc(s);
-			memcpy(tmp, buffy, sizeof(GameEvent));
+  }
+  
+  
+  //recieve from client
+  log-&gt;unbuffer(channel_client + _channel_buffered, &amp;ne, sizeof(ne));
+  for (i = 0; i &lt; ne; i += 1) {
+    char *tmp = buffy;
+    log-&gt;unbuffer(channel_client + _channel_buffered, &amp;buffy, sizeof(GameEvent));
+    int s = ((GameEvent*)tmp)-&gt;size;
+    if (s &gt; 1024) {
+      tmp = (char *)malloc(s);
+      memcpy(tmp, buffy, sizeof(GameEvent));
 		}
-		log-&gt;unbuffer(channel_client + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
-		handle_game_event ( channel_client, ((GameEvent*)tmp));
-		if (tmp != buffy) free(tmp);
-	}
+    log-&gt;unbuffer(channel_client + _channel_buffered, tmp + sizeof(GameEvent), s - sizeof(GameEvent));
+    handle_game_event ( channel_client, ((GameEvent*)tmp));
+    if (tmp != buffy) free(tmp);
+  }
 }
 
-void Game::handle_game_event ( int source, class GameEvent *event ) {STACKTRACE
-	if ((event-&gt;type &lt;= event_invalid) || (event-&gt;type &gt;= event_last)) {
-		tw_error(&quot;Game::handle_game_event - Bad event type: %d&quot;, event-&gt;type);
-	}
-	switch (event-&gt;type) {
-		case event_change_lag: ((GameEventChangeLag*)event)-&gt;execute(source);
-		break;
-		case event_message: ((GameEventMessage*)event)-&gt;execute(source);
-		break;
-	}
+void Game::handle_game_event ( int source, class GameEvent *event ) 
+{
+  STACKTRACE;
+  if ((event-&gt;type &lt;= event_invalid) || (event-&gt;type &gt;= event_last)) 
+    {
+      tw_error(&quot;Game::handle_game_event - Bad event type: %d&quot;, event-&gt;type);
+    }
+  switch (event-&gt;type) 
+    {
+    case event_change_lag: ((GameEventChangeLag*)event)-&gt;execute(source);
+      break;
+    case event_message: ((GameEventMessage*)event)-&gt;execute(source);
+      break;
+    }
 }
 
-void Game::send_game_event ( class GameEvent *event ) {STACKTRACE
-	if (events_waiting == maximum_events_waiting) {
-		tw_error(&quot;too many GameEvents&quot;);
-		return;
-	}
-	if (!waiting_events) waiting_events = new GameEvent*[maximum_events_waiting];
-	waiting_events[events_waiting] = event;
-	events_waiting += 1;
+void Game::send_game_event ( class GameEvent *event ) 
+{
+  STACKTRACE;
+  if (events_waiting == maximum_events_waiting) 
+    {
+      tw_error(&quot;too many GameEvents&quot;);
+      return;
+    }
+  if (!waiting_events) waiting_events = new GameEvent*[maximum_events_waiting];
+  waiting_events[events_waiting] = event;
+  events_waiting += 1;
 }
 
 
-void Game::calculate() {_STACKTRACE(&quot;Game::calculate&quot;)
-	int i;
-	double t = get_time();
-	int active_focus_destroyed = false;
-
-
-	paused_time = 0;
-	compare_checksums();
-	do_game_events();
-
-	for (i = 0; i &lt; num_focuses; i += 1) {
-		if (!focus[i]-&gt;exists()) {
-			num_focuses -= 1;
-			if (focus_index == i) {
-				focus[i]-&gt;attributes &amp;= ~ATTRIB_ACTIVE_FOCUS;
+void Game::calculate() 
+{
+  STACKTRACE;
+  int i;
+  double t = get_time();
+  int active_focus_destroyed = false;
+  
+  
+  paused_time = 0;
+  compare_checksums();
+  do_game_events();
+  
+  for (i = 0; i &lt; num_focuses; i += 1) {
+    if (!focus[i]-&gt;exists()) {
+      num_focuses -= 1;
+      if (focus_index == i) {
+	focus[i]-&gt;attributes &amp;= ~ATTRIB_ACTIVE_FOCUS;
 				active_focus_destroyed = 1;
 				focus_index -= 1;
 				if (num_focuses &amp;&amp; (focus_index &lt; 0))
@@ -622,6 +656,7 @@
 
 void Game::play() 
 {
+  STACKTRACE;
   set_resolution(window-&gt;w, window-&gt;h);
   prepare();
   if (is_paused()) 
@@ -700,6 +735,7 @@
 
 void Game::ship_died(Ship *who, SpaceLocation *source)
 {
+  STACKTRACE;
   if (source &amp;&amp; source-&gt;data) 
     {
       std::string tmp = &quot;&quot;;
@@ -721,13 +757,15 @@
 
 void Game::object_died(SpaceObject *who, SpaceLocation *source)
 {
+  STACKTRACE;
 	if (who &amp;&amp; who-&gt;isShip())
 	{
 		ship_died((Ship*)who, source);
 	}
 }
 
-void Game::fps() {STACKTRACE
+void Game::fps() {
+  STACKTRACE;
 	if ((!log-&gt;playback) &amp;&amp; ((log-&gt;type == Log::log_net1server) || (log-&gt;type == Log::log_net1client))) {
 		int ping = ((NetLog*)log)-&gt;ping;
 		char *tt = &quot;good&quot;;
@@ -782,6 +820,7 @@
 
 void Game::preinit() 
 {
+  STACKTRACE;
   Physics::preinit();
   //	meleedata.planetSprite = meleedata.asteroidSprite = meleedata.asteroidExplosionSprite = meleedata.hotspotSprite = meleedata.kaboomSprite = meleedata.panelSprite = meleedata.sparkSprite = meleedata.xpl1Sprite = NULL;
   // you should reset it here (again), cause there can be subgames of this type.
@@ -804,75 +843,77 @@
   music = &quot;&quot;;
 }
 
-void Game::init(Log *_log) {_STACKTRACE(&quot;Game::init&quot;)
-	int i;
+void Game::init(Log *_log) 
+{
+  STACKTRACE;
+  int i;
 
-	game_done = false;
-	log = _log;
-	if (!log) {
-		log = new Log();
-		log-&gt;init();
-	}
-
-	lag_frames = 0;
-	show_fps = 0;
-	game_time = 0;
-	frame_time = 1;
-	frame_number = 0;
-	hiccup_margin = 100;
-	next_tic_time = get_time();
-	next_render_time = game_time;
-	next_fps_time = game_time;
-	view_locked = false;
-	physics_locked = false;
-	if (log-&gt;type != Log::log_normal || log-&gt;playback) physics_locked = true;
-	local_checksum = client_checksum = server_checksum = 0;
-
-	Physics::init();
-	prepare();
-
-	if (!window) {
-		window = new VideoWindow();
-		window-&gt;preinit();
-	}
-
-	tw_set_config_file(&quot;client.ini&quot;);
-	change_view(get_config_string(&quot;View&quot;, &quot;View&quot;, &quot;Hero&quot;)); 
-
-	window-&gt;add_callback(this);
-
-	if (!log-&gt;playback) {
-		switch (log-&gt;type) {
-			case Log::log_normal: {
-			}
+  game_done = false;
+  log = _log;
+  if (!log) {
+    log = new Log();
+    log-&gt;init();
+  }
+  
+  lag_frames = 0;
+  show_fps = 0;
+  game_time = 0;
+  frame_time = 1;
+  frame_number = 0;
+  hiccup_margin = 100;
+  next_tic_time = get_time();
+  next_render_time = game_time;
+  next_fps_time = game_time;
+  view_locked = false;
+  physics_locked = false;
+  if (log-&gt;type != Log::log_normal || log-&gt;playback) physics_locked = true;
+  local_checksum = client_checksum = server_checksum = 0;
+  
+  Physics::init();
+  prepare();
+  
+  if (!window) {
+    window = new VideoWindow();
+    window-&gt;preinit();
+  }
+  
+  tw_set_config_file(&quot;client.ini&quot;);
+  change_view(get_config_string(&quot;View&quot;, &quot;View&quot;, &quot;Hero&quot;)); 
+  
+  window-&gt;add_callback(this);
+  
+  if (!log-&gt;playback) {
+    switch (log-&gt;type) {
+    case Log::log_normal: {
+    }
+      break;
+    case Log::log_net1server: {
+    }
+      break;
+    case Log::log_net1client: {
+    }
 			break;
-			case Log::log_net1server: {
-			}
-			break;
-			case Log::log_net1client: {
-			}
-			break;
-			default: {
-				tw_error(&quot;Knee!&quot;);
-			}
-			break;
-		}
-	}
-
-/* CONTENTS OF CHANNEL channel_init :
-
-offset	size	format		data
-0		4		int			log type number
+    default: {
+      tw_error(&quot;Knee!&quot;);
+    }
+      break;
+    }
+  }
+  
+  /* CONTENTS OF CHANNEL channel_init :
+     
+  offset	size	format		data
+  0		4		int			log type number
 4		4		int			size of game type name
 8		?		char[]		game type name
 ?		4		int			lag frames
 
-*/
-	int tmp = log-&gt;type;
-	log_int(channel_init, tmp);
-	if (log-&gt;playback) log-&gt;type = tmp;
+  */
+  int tmp = log-&gt;type;
+  log_int(channel_init, tmp);
+  if (log-&gt;playback) log-&gt;type = tmp;
 
-	char buffy[128];
+  char buffy[128];
 	i = strlen(type-&gt;name);
 	memcpy(buffy, type-&gt;name, i);
 	if (i &gt; 127) {tw_error(&quot;long gamename1&quot;);}
@@ -928,7 +969,8 @@
 	return;
 }
 
-void Game::init_lag() {STACKTRACE
+void Game::init_lag() {
+  STACKTRACE;
 	if ((log-&gt;type == Log::log_net1server) || (log-&gt;type == Log::log_net1client)) {
 		int lag_time = 0;//get_config_int(&quot;Network&quot;, &quot;Lag&quot;, 200);
 		char blah = 0;
@@ -960,7 +1002,8 @@
 	}
 }
 
-void Game::change_view(View *new_view) {STACKTRACE//this function looks wrong to me
+void Game::change_view(View *new_view) {
+  STACKTRACE;//this function looks wrong to me
 	View *v = new_view;
 	v-&gt;preinit();
 	v-&gt;init(view);
@@ -979,7 +1022,8 @@
 	return;
 }
 
-void Game::change_view(const char * name) {STACKTRACE
+void Game::change_view(const char * name) {
+  STACKTRACE;
 	View *v = get_view(name, view);
 	if (!v)	{tw_error(&quot;Game::change_view - invalid view name&quot;);}
 	if (view)
@@ -1023,6 +1067,7 @@
 
 bool Game::is_paused() 
 {
+  STACKTRACE;
   if (time_paused != -1) 
     return true;
   return false;
@@ -1030,6 +1075,7 @@
 
 void Game::pause() 
 {
+  STACKTRACE;
   if (time_paused != -1) 
     tw_error (&quot;can't pause -- already paused&quot;);
   time_paused = get_time();
@@ -1037,6 +1083,7 @@
 
 void Game::unpause() 
 {
+  STACKTRACE;
   if (time_paused == -1) 
     tw_error (&quot;can't unpause -- not paused&quot;);
   redraw();
@@ -1047,6 +1094,7 @@
 
 void Game::save_screenshot() 
 {
+  STACKTRACE;
   static int shot_index = 0;
   char path[80];
 
@@ -1076,6 +1124,7 @@
 
 bool Game::handle_key(int k) 
 {
+  STACKTRACE;
   switch (k &gt;&gt; 8) 
     {
 #if !defined _DEBUG
@@ -1207,6 +1256,7 @@
 }
 
 int Game::set_frame_time(int t) {
+  STACKTRACE;
 	this-&gt;frame_time = t;
 	prepare();
 	return 1;
@@ -1214,6 +1264,7 @@
 
 int Game::set_turbo(double t) 
 {
+  STACKTRACE;
   this-&gt;normal_turbo = t;
   prepare();
   return 1;
@@ -1221,17 +1272,20 @@
 
 double Game::get_turbo() 
 {
+  STACKTRACE;
   return this-&gt;normal_turbo;
 }
 
 void Game::play_music() 
 {
+  STACKTRACE;
   tw_sound.play_music(data_full_path(&quot;music/Robeter-battle-music-remix.ogg&quot;));
   return;
 }
 
 void Game::quit(const char *message) 
-{ 
+{
+  STACKTRACE; 
   game_done = true;
 }
 

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mhelpers.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -160,6 +160,7 @@
 
 int VideoSystem::poll_redraw() 
 {
+  STACKTRACE;
   last_poll = get_time();
   if (screen_corrupted) 
     {
@@ -172,6 +173,7 @@
 
 void VideoSystem::preinit() 
 {
+  STACKTRACE;
   int i;
   surface = NULL;
   width = -1;
@@ -206,6 +208,7 @@
 
 FONT *VideoSystem::get_font(int s) 
 {
+  STACKTRACE;
   if (!font_data) 
     {
       if (basic_font) 
@@ -223,6 +226,7 @@
 
 void VideoSystem::set_palette(RGB *new_palette) 
 {
+  STACKTRACE;
   memcpy(palette, new_palette, sizeof(RGB) * 256);
   update_colors();
   return;
@@ -230,6 +234,7 @@
 
 void VideoSystem::update_colors() 
 {
+  STACKTRACE;
   RGB tmp[256];
   if (!palette) return;
   memcpy(tmp, palette, sizeof(RGB) * 256);
@@ -249,6 +254,7 @@
 
 void VideoSystem::redraw() 
 {
+  STACKTRACE;
   VideoEvent ve;
   ve.type = Event::VIDEO;
   ve.subtype = VideoEvent::REDRAW;
@@ -416,12 +422,14 @@
 
 void VideoWindow::hide() 
 {
+  STACKTRACE;
   locate(0,0,0,0,0,0,0,0);
   return;
 }
 
 void VideoWindow::add_callback( BaseClass *callee ) 
 {
+  STACKTRACE;
   std::list&lt;BaseClass*&gt;::iterator cb = std::find(callback_list.begin(),callback_list.end(), callee);
   if(cb != callback_list.end())
     {
@@ -433,12 +441,14 @@
 
 void VideoWindow::remove_callback( BaseClass *callee ) 
 {
+  STACKTRACE;
   callback_list.remove(callee);
   return;
 }
 
 void VideoWindow::event(int subtype) 
 {
+  STACKTRACE;
   if (lock_level) 
     {tw_error(&quot;VideoWindow - illegal while locked&quot;);}
   VideoEvent ve;
@@ -451,6 +461,7 @@
 
 void VideoWindow::update_pos() 
 {
+  STACKTRACE;
   if (lock_level) 
     {tw_error(&quot;VideoWindow - illegal while locked&quot;);}
   int nx = 0, ny = 0, nw = 0, nh = 0;
@@ -488,6 +499,7 @@
 
 void VideoWindow::_event( Event *e ) 
 {
+  STACKTRACE;
   if (e-&gt;type == Event::VIDEO) 
     {
       const VideoEvent *ve = (const VideoEvent *) e;
@@ -577,6 +589,7 @@
 
 void VideoWindow::deinit() 
 {
+  STACKTRACE;
   if (lock_level) {tw_error(&quot;VideoWindow - illegal while locked&quot;);}
   if (parent) {
     parent-&gt;remove_callback( this );

Modified: trunk/source/melee/mitems.cpp
===================================================================
--- trunk/source/melee/mitems.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mitems.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 
 HealthBar::HealthBar(Ship *creator, int *toggle)
 {
+  STACKTRACE;
 	scale = 2.0;
 	bartoggle = toggle;
 	mother = creator;
@@ -37,7 +38,7 @@
 
 void HealthBar::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(mother &amp;&amp; mother-&gt;exists()) )
 	{
@@ -50,7 +51,7 @@
 
 void HealthBar::draw_bar(Ship *s, double yoffs, int len, double H, double fraction, int col1, int col2, Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Vector2 center;
 	int d;
@@ -86,7 +87,7 @@
 
 void HealthBar::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if (!*bartoggle)
 		return;
@@ -111,10 +112,12 @@
 
 
 
-Indicator::Indicator() : Presence() {STACKTRACE
+Indicator::Indicator() : Presence() {
+  STACKTRACE;
 	}
 
-bool Indicator::coords(Frame *space, SpaceLocation *l, Vector2 *pos, Vector2 *a_pos) {STACKTRACE
+bool Indicator::coords(Frame *space, SpaceLocation *l, Vector2 *pos, Vector2 *a_pos) {
+  STACKTRACE;
 	Vector2 p = corner(l-&gt;normal_pos());
 	Vector2 op = p;
 
@@ -145,12 +148,14 @@
 	return true;
 	}
 
-BlinkyIndicator::BlinkyIndicator(SpaceObject *target, int color) : Indicator() {STACKTRACE
+BlinkyIndicator::BlinkyIndicator(SpaceObject *target, int color) : Indicator() {
+  STACKTRACE;
 	this-&gt;target = target;
 	this-&gt;color = color;
 	}
 
 void BlinkyIndicator::animate(Frame *space) {
+  STACKTRACE;
 	if ((game-&gt;game_time &gt;&gt; 8) &amp; 1) return;
 	Vector2 p;
 	int a = coords(space, target, &amp;p);
@@ -175,17 +180,20 @@
 	}
 	return;
 	}
-void BlinkyIndicator::calculate() {STACKTRACE
+void BlinkyIndicator::calculate() {
+  STACKTRACE;
 	if (!target-&gt;exists()) die();
 	}
 
-WedgeIndicator::WedgeIndicator(SpaceLocation *target, int length, int color) : Indicator() {STACKTRACE
+WedgeIndicator::WedgeIndicator(SpaceLocation *target, int length, int color) : Indicator() {
+  STACKTRACE;
 	this-&gt;target = target;
 	this-&gt;length = length;
 	this-&gt;color = color;
 	}
 
 void WedgeIndicator::animate(Frame *space) {
+  STACKTRACE;
 	double a, a2;
 	Vector2 p, p2, tmp;
 	if (target-&gt;isInvisible() &gt; 0.5) return;
@@ -207,6 +215,7 @@
 	return;
 	}
 void WedgeIndicator::calculate() {
+  STACKTRACE;
 	if (!target-&gt;exists()) die();
 	}
 
@@ -223,7 +232,8 @@
 	accelerate(this, angle + PI/2 + PI*(random()&amp;1), 0.15, MAX_SPEED);
 	}
 
-void Orbiter::calculate() {STACKTRACE
+void Orbiter::calculate() {
+  STACKTRACE;
 	angle = trajectory_angle(center) + PI;
 	sprite_index = get_index(angle);
 	double r = distance(center) / radius;

Modified: trunk/source/melee/mlog.cpp
===================================================================
--- trunk/source/melee/mlog.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mlog.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,7 +30,8 @@
 //				Logging stuff
 ////////////////////////////////////////////////////////////////////////
 
-void Log::init() {STACKTRACE
+void Log::init() {
+  STACKTRACE;
 	log_len  = NULL;
 	log_size = NULL;
 	log_pos  = NULL;
@@ -93,7 +94,8 @@
 	if (log_dir[channel] &amp; direction_read) _unlog ( channel, data, size);
 	return;
 }
-void Log::_log(int channel, const void *data, int size) {STACKTRACE
+void Log::_log(int channel, const void *data, int size) {
+  STACKTRACE;
 	log_len[channel] += size;
 	while (log_len[channel] &gt; log_size[channel]) {
 		if (log_size[channel]) log_size[channel] = log_size[channel] * 2;
@@ -104,7 +106,7 @@
 	return;
 }
 void Log::_unlog(int channel, void *data, int size) {
-	STACKTRACE;
+  STACKTRACE;
 	if (log_len[channel] &lt; log_pos[channel] + size) {tw_error (&quot;Game::_unlog - went past end (%d+%d/%d on %d)&quot;, log_pos[channel], size, log_len[channel], channel);}
 	memcpy(data, log_data[channel]+log_pos[channel], size);
 	log_pos[channel] += size;
@@ -158,7 +160,7 @@
 	return;
 }
 void Log::expand_logs(int num_channels) {
-	STACKTRACE;
+  STACKTRACE;
 	int old_log_num = log_num;
 	if (num_channels &lt;= log_num) { tw_error (&quot;Log::expand_logs - shrinking logs?&quot;); }
 	log_num = num_channels;
@@ -177,12 +179,13 @@
 	return;
 }
 int Log::ready(int channel) {
+  STACKTRACE;
 	if (channel &lt; 0) { tw_error (&quot;log_ready - negative channel!&quot;); }
 	if (channel &gt;= log_num) return 0;
 	return log_len[channel] - log_pos[channel];
 }
 int Log::file_ready(const char *fname, void **location) {
-	STACKTRACE;
+  STACKTRACE;
 	if (log_num &lt;= channel_file_data) return -1;
 	int i = 0, j = 0;
 	while (i &lt; log_len[channel_file_names]) {
@@ -208,6 +211,7 @@
 	return -1;
 }
 void Log::log_file(const char *fname) {
+  STACKTRACE;
 	void *loc;
 	if (!(log_dir[channel_file_data] &amp; direction_read)) {
 		set_config_file(home_ini_full_path(fname).c_str());
@@ -250,7 +254,8 @@
 	return;
 }
 
-void Log::deinit() {STACKTRACE
+void Log::deinit() {
+  STACKTRACE;
 	return;
 }
 
@@ -296,14 +301,17 @@
 }
 
 void Log::flush() {
+  STACKTRACE;
 	return;
 }
 
 bool Log::listen() {
+  STACKTRACE;
 	return false;
 }
 
 void Log::reset() {
+  STACKTRACE;
 	int i;
 	for (i = 0 ; i &lt; this-&gt;log_num; i += 1) {
 		log_pos[i] = 0;
@@ -313,7 +321,8 @@
 
 
 
-void PlaybackLog::init() {STACKTRACE
+void PlaybackLog::init() {
+  STACKTRACE;
 	Log::init();
 	playback = true;
 	default_direction = Log::direction_read;
@@ -329,7 +338,7 @@
 }
 
 void PlaybackLog::set_all_directions( char direction ) {
-	STACKTRACE;
+  STACKTRACE;
 	tw_error(&quot;set_all_directions - your not supposed to do that in a demo playback!&quot;);
 	return;
 }

Modified: trunk/source/melee/mmain.cpp
===================================================================
--- trunk/source/melee/mmain.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mmain.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -95,7 +95,8 @@
 	return i;
 	}
 
-void NormalGame::init_objects() {STACKTRACE
+void NormalGame::init_objects() {
+  STACKTRACE;
 	int i;
 	add(new Stars());
 	Planet *planet = create_planet();
@@ -106,7 +107,8 @@
 	for (i = 0; i &lt; num_asteroids; i += 1) add(new Asteroid());
 	}
 
-void NormalGame::init_players() {STACKTRACE
+void NormalGame::init_players() {
+  STACKTRACE;
 	switch (log-&gt;type) {
 		case Log::log_normal: {
 			for (int i = 0; true; i += 1) {
@@ -195,6 +197,7 @@
 }
 
 void NormalGame::set_resolution(int screen_x, int screen_y) {
+  STACKTRACE;
 	int view_x, view_y;
 	view_x = screen_x;
 	view_y = screen_y;
@@ -208,6 +211,7 @@
 	}
 
 void NormalGame::preinit() {
+  STACKTRACE;
 	Game::preinit();
 	player_control = NULL;
 	player_name = NULL;
@@ -223,7 +227,8 @@
 	gameEnding = false;
 	gameEndingTime = DefaultEndingTime;
 	}
-void NormalGame::init(Log *_log) {STACKTRACE
+void NormalGame::init(Log *_log) {
+  STACKTRACE;
 	Game::init(_log);
 
 	team_table_size = 0;
@@ -281,7 +286,8 @@
 	}
 
 static int kill_all_delay_counter = 0;
-void NormalGame::calculate() {STACKTRACE
+void NormalGame::calculate() {
+  STACKTRACE;
 	Game::calculate();
 	if (next_choose_new_ships_time &lt;= game_time) {
 		choose_new_ships();
@@ -317,7 +323,8 @@
 	return;
 	}
 
-void NormalGame::ship_died(Ship *who, SpaceLocation *source) {STACKTRACE
+void NormalGame::ship_died(Ship *who, SpaceLocation *source) {
+  STACKTRACE;
 	char victimName[80] = &quot;&quot;;
 	char killerName[80] = &quot;&quot;;
 	int victimID = -1;
@@ -379,7 +386,8 @@
 	return;
 	}
 
-void NormalGame::display_stats() {STACKTRACE
+void NormalGame::display_stats() {
+  STACKTRACE;
 	pause();
 	int i;
 	for (i = 0; i &lt; num_players; i += 1) {
@@ -404,7 +412,7 @@
 }
 bool NormalGame::handle_key(int k)
 {
-	STACKTRACE;
+  STACKTRACE;
 	switch (k &gt;&gt; 8) {
 		default: {
 			return Game::handle_key(k);
@@ -456,6 +464,7 @@
 
 void NormalGame::choose_new_ships() 
 {
+  STACKTRACE;
   char tmp[40];
   int i;
   pause();
@@ -557,6 +566,7 @@
 
 bool NormalGame::isGameDone() 
 {
+  STACKTRACE;
   /*! we'll only check this every now and again, to avoid bogging down the engine.  */  
   enum { IterationsToSkip = 30 };
   static long iterationsToSkip = IterationsToSkip;
@@ -628,12 +638,14 @@
 // this should be places elsewhere I think ...
 TeamIndicator::TeamIndicator(Ship *s, int *atoggle)
 {
+  STACKTRACE;
 	indtoggle = atoggle;
 	mother = s;
 }
 
 void TeamIndicator::calculate()
 {
+  STACKTRACE;
 	if ( !(mother &amp;&amp; mother-&gt;exists()) )
 	{
 		mother = 0;
@@ -643,6 +655,7 @@
 }
 
 void TeamIndicator::animate(Frame *space) {
+  STACKTRACE;
   if (!*indtoggle)
     return;
   
@@ -667,6 +680,7 @@
   
 }
 void NormalGame::showHelpText() {
+  STACKTRACE;
 	const char * file = data_full_path(&quot;ingame.txt&quot;).c_str();
 	char text[10000] = &quot;&quot;;
 	char controlHelp[3000] = &quot;&quot;;

Modified: trunk/source/melee/mnet1.cpp
===================================================================
--- trunk/source/melee/mnet1.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mnet1.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -33,7 +33,8 @@
 	size = sizeof(GameEvent) + l;
 	type = Game::event_message;
 }
-void GameEventMessage::execute( int source ) {STACKTRACE
+void GameEventMessage::execute( int source ) {
+  STACKTRACE;
 	char buffy[64+max_message_length];
 	char *tmp = buffy;
 	int c = 15;
@@ -47,7 +48,8 @@
 	::message.out(buffy, 6000, c);
 }
 
-void GameEventChangeLag::execute( int source ) {STACKTRACE
+void GameEventChangeLag::execute( int source ) {
+  STACKTRACE;
 	if (source != Game::channel_server) return;
 	if (old_lag != game-&gt;lag_frames) return;
 	int i;
@@ -111,39 +113,50 @@
 		}
 	}
 
-void NetLog::init() {STACKTRACE
+void NetLog::init() {
+  STACKTRACE;
 	}
-void NetLog::deinit() {STACKTRACE
+void NetLog::deinit() {
+  STACKTRACE;
 	}
 
 NetLog::~NetLog() {STACKTRACE
 	}
 
 void NetLog::send_packet() {
+  STACKTRACE;
 	}
 void NetLog::recv_packet() {
+  STACKTRACE;
 	}
 
 void NetLog::expand_logs(int num_channels) {
+  STACKTRACE;
 	return;
 	}
 
 void NetLog::_log(int channel, const void *data, int size) {
+  STACKTRACE;
 }
 void NetLog::_unlog(int channel, void *data, int size) {
+  STACKTRACE;
 	return;
 	}
 
 void NetLog::log_file(const char *fname) {
+  STACKTRACE;
 }
 
 void NetLog::flush() {
+  STACKTRACE;
 }
 
 bool NetLog::listen() {
+  STACKTRACE;
 return false;
 }
 
 int NetLog::ready(int channel) {
+  STACKTRACE;
 return 0;
 }

Modified: trunk/source/melee/mship.cpp
===================================================================
--- trunk/source/melee/mship.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mship.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -59,6 +59,7 @@
 }
 
 Ship *ShipClass::get_ship(Vector2 pos, double angle, ShipData *dat, unsigned int team) {
+  STACKTRACE;
 	dat-&gt;lock();
 	Ship *s = _get_ship(pos, angle, dat, team);
 	dat-&gt;unlock();
@@ -86,6 +87,7 @@
 
 
 Ship *ShipType::get_ship(Vector2 pos, double angle, unsigned int team) {
+  STACKTRACE;
 	game-&gt;log_file(file);
 	Ship *s = code-&gt;get_ship(pos, angle, data, team);
 	s-&gt;type = this;
@@ -244,6 +246,7 @@
 	target_pressed(false),
 	control(NULL)
 {
+  STACKTRACE;
   attributes |= ATTRIB_SHIP;
   layer = LAYER_SHIPS;
   set_depth(DEPTH_SHIPS);
@@ -284,6 +287,7 @@
   target_pressed(false),
   control(NULL)
 {
+  STACKTRACE;
   shipData-&gt;lock();
   attributes |= ATTRIB_SHIP;
   layer = LAYER_SHIPS;
@@ -376,6 +380,7 @@
 
 void Ship::death() 
 {
+  STACKTRACE;
   if (attributes &amp; ATTRIB_NOTIFY_ON_DEATH) 
     {
       game-&gt;ship_died(this, NULL);
@@ -391,28 +396,33 @@
 
 double Ship::getCrew()
 {
+  STACKTRACE;
   return(crew);
 }
 
 double Ship::getBatt()
 {
+  STACKTRACE;
   return(batt);
 }
 
 RGB Ship::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {0,225,0};
 	return c;
 }
 
 RGB Ship::battPanelColor(int k)
 {
+  STACKTRACE;
   RGB c = {225,0,0};
   return c;
 }
 
 void Ship::locate() 
 {
+  STACKTRACE;
   int tries = 0;
   double mindist = 1000;
   while (tries &lt; 15) {
@@ -430,6 +440,7 @@
 
 void Ship::calculate()
 {
+  STACKTRACE;
   
   //added by Tau - start
   if (exists() &amp;&amp; death_counter &gt;= 0) 
@@ -668,6 +679,7 @@
 
 int Ship::handle_fuel_sap(SpaceLocation *source, double normal) 
 {
+  STACKTRACE;
   if (death_counter &gt;= 0) 
     return 0; //added by Tau
 
@@ -690,6 +702,7 @@
 
 double Ship::handle_speed_loss(SpaceLocation *source, double normal) 
 {
+  STACKTRACE;
   double speed_loss = normal;
   if(speed_loss &gt; 0.0) 
     {
@@ -708,6 +721,7 @@
 
 int Ship::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   if (death_counter &gt;= 0) 
     return 0; //added by Tau
 
@@ -748,34 +762,40 @@
 }
 
 void Ship::materialize() {
+  STACKTRACE;
 }
 
 
 void Ship::assigntarget(SpaceObject *otarget)
 {
+  STACKTRACE;
 	target = otarget;
 }
 
 
-void Ship::calculate_thrust() {STACKTRACE
+void Ship::calculate_thrust() {
+  STACKTRACE;
 	if (thrust)
 		accelerate_gravwhip(this, angle, accel_rate * frame_time, speed_max);
 	return;
 }
 
 void Ship::calculate_turn_left()
-{STACKTRACE
+{
+  STACKTRACE;
   if(turn_left)
 		turn_step -= turn_rate * frame_time;
 }
 
 void Ship::calculate_turn_right()
-{STACKTRACE
+{
+  STACKTRACE;
   if(turn_right)
 		turn_step += turn_rate * frame_time;
 }
 
-void Ship::calculate_fire_weapon() {STACKTRACE
+void Ship::calculate_fire_weapon() {
+  STACKTRACE;
 	weapon_low = FALSE;
 
 	if (fire_weapon) {
@@ -806,6 +826,7 @@
 
 void Ship::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = FALSE;
 
   if(fire_special) {
@@ -833,6 +854,7 @@
 
 void Ship::calculate_hotspots() 
 {
+  STACKTRACE;
   if((thrust) &amp;&amp; (hotspot_frame &lt;= 0)) 
     {
       game-&gt;add(new Animation(this,
@@ -847,15 +869,18 @@
 
 int Ship::activate_weapon()
 {
+  STACKTRACE;
   return(TRUE);
 }
 
 int Ship::activate_special()
 {
+  STACKTRACE;
   return(TRUE);
 }
 
 void Ship::animate(Frame *frame) {
+  STACKTRACE;
 	SpaceObject::animate(frame);
 }
 
@@ -866,6 +891,7 @@
 
 ShipType *Ship::get_shiptype()
 {
+  STACKTRACE;
 	return type;
 }
 
@@ -886,7 +912,8 @@
 	phaser_step_position(0),
 	phaser_steps(steps),
 	phaser_step_size(step_size)
-{STACKTRACE
+{
+  STACKTRACE;
 	layer = LAYER_HOTSPOTS;
 	set_depth(DEPTH_HOTSPOTS);
 	collide_flag_anyone = 0;
@@ -903,12 +930,14 @@
 }
 
 void Phaser::animate(Frame *space) {
+  STACKTRACE;
 	sprite-&gt;animate_character(pos, 
 		sprite_index, pallete_color[colors[color_index]], space);
 	return;
 }
 
-void Phaser::calculate() {STACKTRACE
+void Phaser::calculate() {
+  STACKTRACE;
 	if (!exists())
 		return;
 	frame_step -= frame_time;
@@ -939,7 +968,8 @@
 	SpaceObject::calculate();
 }
 
-SpaceLocation *Ship::get_ship_phaser() {STACKTRACE
+SpaceLocation *Ship::get_ship_phaser() {
+  STACKTRACE;
 	return new Phaser(this,
 		pos - unit_vector(angle ) * PHASE_MAX * size.x,
 		unit_vector(angle ) * PHASE_MAX * size.x,

Modified: trunk/source/melee/mshot.cpp
===================================================================
--- trunk/source/melee/mshot.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mshot.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -42,6 +42,7 @@
   explosionFrameCount(SPARK_FRAMES),
   explosionFrameSize(scale_frames(0))
 {
+  STACKTRACE;
 	layer = LAYER_SHOTS;
 	set_depth(DEPTH_SHOTS);
 	attributes |= ATTRIB_SHOT;
@@ -62,6 +63,7 @@
 }
 
 void Shot::calculate() {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	if (!(ship &amp;&amp; ship-&gt;exists()))
@@ -76,11 +78,13 @@
 }
 
 void Shot::animate(Frame *space) {
+  STACKTRACE;
   SpaceObject::animate(space);
   return;
 }
 
 int Shot::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (!exists()) return 0;
 	if ((normal &gt; 0) || (direct &gt; 0)) {
 		armour -= normal;
@@ -97,6 +101,7 @@
 }
 
 void Shot::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other-&gt;exists()) return;
 	damage(other, damage_factor);
 	//if (!other-&gt;isShot()) state = 0;
@@ -109,9 +114,11 @@
 }
 
 void Shot::death() {
+  STACKTRACE;
 }
 
 void Shot::animateExplosion() {
+  STACKTRACE;
 	game-&gt;add(new Animation(this, normal_pos(),
 			explosionSprite, 0, explosionFrameCount,
 			explosionFrameSize, DEPTH_EXPLOSIONS));
@@ -120,6 +127,7 @@
 
 void Shot::soundExplosion() 
 {
+  STACKTRACE;
   if(!explosionSample.empty()) 
     {
       tw_sound.play_sound(data_full_path(explosionSample));
@@ -155,11 +163,13 @@
 }
 
 void Shot::stop() {
+  STACKTRACE;
 	vel = Vector2(0,0);
 	return;
 }
 
 void Shot::destroy() {
+  STACKTRACE;
 	state = 0;
 	return;
 }
@@ -174,6 +184,7 @@
 }
 
 int Shot::isHomingMissile() {
+  STACKTRACE;
 	return ((id &amp; BASE_MASK3) == SPACE_HOMING_MISSILE);
 }
 
@@ -186,9 +197,11 @@
 	frame_size(ofsize),
 	frame_step(ofsize)
 {
+  STACKTRACE;
 }
 
 void AnimatedShot::calculate() {
+  STACKTRACE;
 	Shot::calculate();
 	frame_step -= frame_time;
 	while (frame_step &lt; 0) {
@@ -205,6 +218,7 @@
 :
 	Shot(creator, rpos, oangle, ov, odamage, orange, oarmour, opos, osprite, relativity)
 {
+  STACKTRACE;
 	sprite_index = get_index(angle);
 }
 
@@ -222,11 +236,13 @@
 	turn_rate(otrate),
 	turn_step(0.0)
 {
+  STACKTRACE;
 	target = otarget;
 	id = SPACE_HOMING_MISSILE;
 }
 
 void HomingMissile::calculate() {
+  STACKTRACE;
 	Missile::calculate();
 	if (target &amp;&amp; !target-&gt;isInvisible()) {
 		double d_a = normalize(trajectory_angle(target) - (angle + turn_step), PI2);
@@ -256,6 +272,7 @@
 }
 
 void HomingMissile::animate(Frame *space) {
+  STACKTRACE;
 	int old_sprite_index = sprite_index;
 	Vector2 old_vel = vel;
 
@@ -292,6 +309,7 @@
   rel_pos(rpos),
   sinc_angle(osinc_angle)
 {
+  STACKTRACE;
 
 // angle conventions fucked up??
 	rel_pos.x *= -1;
@@ -319,6 +337,7 @@
 
 
 void Laser::calculate() {
+  STACKTRACE;
 	if((frame &lt; frame_count) &amp;&amp; (lpos-&gt;exists())) {
 		pos = lpos-&gt;normal_pos() + rotate(rel_pos, lpos-&gt;get_angle() - PI/2);
 		vel = lpos-&gt;get_vel();
@@ -335,6 +354,7 @@
   Laser(creator, lsource-&gt;trajectory_angle(ltarget), lcolor, lsource-&gt;distance(ltarget), ldamage, lfcount, lsource, rel_pos),
   target(ltarget)
 {
+  STACKTRACE;
 	collide_flag_anyone = bit(target-&gt;layer);
 	collide_flag_sameteam = bit(target-&gt;layer);
 	collide_flag_sameship = bit(target-&gt;layer);
@@ -346,11 +366,13 @@
 }
 
 int PointLaser::canCollide(SpaceObject *other) {
+  STACKTRACE;
 	if (other != target) return false;
 	return Laser::canCollide(other);
 }
 
 void PointLaser::calculate() {
+  STACKTRACE;
 	double alpha;
 	alpha = (lpos-&gt;get_angle());
 	Laser::calculate();

Modified: trunk/source/melee/mshpdata.cpp
===================================================================
--- trunk/source/melee/mshpdata.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mshpdata.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -122,6 +122,7 @@
 
 void ShipData::lock() 
 {
+  STACKTRACE;
   if (references == 0) 
     {
       push_config_state();//can screw up badly if an error occurs while loading...
@@ -133,6 +134,7 @@
 
 void ShipData::unlock() 
 {
+  STACKTRACE;
   references -= 1;
   if ((references == 0) &amp;&amp; auto_unload) 
     {
@@ -142,6 +144,7 @@
 
 void ShipData::unload() 
 {
+  STACKTRACE;
   if (status != LOADED_FULL) 
     return;
 
@@ -205,6 +208,7 @@
   spriteExtra(NULL),
   spriteExtraExplosion(NULL)
 {
+  STACKTRACE;
   file = filename;
   ini  = inifile;
   references = 0;
@@ -250,6 +254,7 @@
 
 void ShipData::load() 
 {
+  STACKTRACE;
   int i, index = 0, count;
   
   if (status != LOADED_NONE) 

Modified: trunk/source/melee/mshppan.cpp
===================================================================
--- trunk/source/melee/mshppan.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mshppan.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -37,7 +37,8 @@
 int batt_y = 53;
 
 
-ShipPanel::ShipPanel(Ship *_ship) {STACKTRACE
+ShipPanel::ShipPanel(Ship *_ship) {
+  STACKTRACE;
 	id |= ID_SHIP_PANEL;
 
 	panel   = create_bitmap(64, 100);
@@ -80,13 +81,15 @@
   delete window;
 }
 
-void ShipPanel::refresh() {STACKTRACE
+void ShipPanel::refresh() {
+  STACKTRACE;
 	panel_needs_update = 1;
 	captain_needs_update = 1;
 	return;
 	}
 
-void ShipPanel::calculate() {STACKTRACE
+void ShipPanel::calculate() {
+  STACKTRACE;
 	if (!ship) {
 		deathframe -= frame_time;
 		if (deathframe &lt;= 0) this-&gt;die();
@@ -115,7 +118,7 @@
 	}
 
 void ShipPanel::animate(Frame *space) {
-	STACKTRACE;
+  STACKTRACE;
 
 	BITMAP *screen = window-&gt;surface;
 	if (!screen) return;

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/msprite.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -607,6 +607,7 @@
 
 SpaceSprite::SpaceSprite(SpaceSprite &amp;old) 
 {
+  STACKTRACE;
   int i, l;
   BITMAP *bmp;
   count = old.count;
@@ -804,12 +805,14 @@
 
 void SpaceSprite::lock() 
 {
+  STACKTRACE;
   highest_mip = 0;
   return;
 }
 
 void SpaceSprite::unlock() 
 {
+  STACKTRACE;
   int i, j;
   for (i = 0; i &lt; MAX_MIP_LEVELS; i += 1) 
     {
@@ -849,6 +852,7 @@
 
 BITMAP *SpaceSprite::get_bitmap(int index, int miplevel)
 {
+  STACKTRACE;
   if (general_attributes &amp; MIPMAPED) 
     if (miplevel &gt; highest_mip) 
       {tw_error (&quot;get_bitmap on undefined mipmap level&quot;);}
@@ -859,6 +863,7 @@
 
 BITMAP *SpaceSprite::get_bitmap_readonly(int index)
 {
+  STACKTRACE;
   if (index &gt;= count) 
     {
       tw_error(&quot;SpaceSprite::get_bitmap_readonly - index %d &gt;= count %d&quot;, index, count); index = 0;
@@ -872,6 +877,7 @@
 
 void SpaceSprite::animate_character(Vector2 pos, int index, int color, Frame *space, double scale) 
 {
+  STACKTRACE;
   if (index &gt;= count) 
     {
       tw_error(&quot;SpaceSprite::animate_character - index %d &gt;= count %d&quot;, index, count);
@@ -959,6 +965,7 @@
 
 void SpaceSprite::draw(Vector2 pos, Vector2 size, int index, BITMAP *surface) 
 {
+  STACKTRACE;
   if (index &gt;= count) 
     {
       tw_error(&quot;SpaceSprite::draw - index %d &gt; count %d&quot;, index, count); index = 0;
@@ -989,6 +996,7 @@
 
 void SpaceSprite::draw(Vector2 pos, Vector2 size, int index, Frame *frame) 
 {
+  STACKTRACE;
   if (index &gt;= count) 
     {
       tw_error(&quot;SpaceSprite::draw - index %d &gt; count %d&quot;, index, count); index = 0;
@@ -1034,12 +1042,14 @@
 
 void SpaceSprite::draw(int x, int y, int index, BITMAP *surface) 
 {
+  STACKTRACE;
   draw(Vector2(x,y), Vector2(b[0][index]-&gt;w, b[0][index]-&gt;h), index, surface);
   return;
 }
 
 void SpaceSprite::animate(Vector2 pos, int index, Frame *space, double scale) 
 {
+  STACKTRACE;
   if (index &gt;= count) 
     {
       tw_error(&quot;SpaceSprite::animate - index %d &gt;= count %d&quot;, index, count);
@@ -1057,6 +1067,7 @@
 
 void SpaceSprite::draw_character(int x, int y, int index, int color, BITMAP *bmp) 
 {
+  STACKTRACE;
   if (index &gt;= count) 
     {
       tw_error(&quot;SpaceSprite::draw_character - index %d &gt;= count %d&quot;, index, count); index = 0;
@@ -1071,18 +1082,21 @@
 
 void SpaceSprite::draw_character(int x, int y, int index, int color, Frame *space) 
 {
+  STACKTRACE;
   draw_character(x, y, index, color, space-&gt;surface);
   space-&gt;add_box(x, y, w, h);
 }
 
 void SpaceSprite::draw_character(int x, int y, int w, int h, int index, int color, Frame *space) 
 {
+  STACKTRACE;
   draw_character(x, y, w, h, index, color, space-&gt;surface);
   space-&gt;add_box(x, y, w, h);
 }
 
 void SpaceSprite::draw_character(int x, int y, int w, int h, int index, int color, BITMAP *bmp) 
 {
+  STACKTRACE;
   if (index &gt;= count) 
     {
       tw_error(&quot;SpaceSprite::draw_character_stretch - index %d &gt;= count %d&quot;, index, count); index = 0;
@@ -1098,6 +1112,7 @@
 int SpaceSprite::collide(int x, int y, int i, int ox, int oy, int oi,
 			 SpaceSprite *other)
 {
+  STACKTRACE;
   if (i &gt;= count) 
     { 
       tw_error(&quot;SpaceSprite::collide - index1 %d &gt;= count1 %d&quot;, i, count); 
@@ -1152,6 +1167,7 @@
 int SpaceSprite::collide_ray(int lx1, int ly1, int *lx2, int *ly2,
   int sx, int sy, int sindex)
 {
+  STACKTRACE;
   line_collide = FALSE;
   rect_x = sx - (w / 2);
   rect_y = sy - (h / 2);

Modified: trunk/source/melee/mtarget.cpp
===================================================================
--- trunk/source/melee/mtarget.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mtarget.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,6 +24,7 @@
 
 Targets::Targets()
 {
+  STACKTRACE;
 	N = 0;
 	item = 0;
 }
@@ -36,6 +37,7 @@
 
 void Targets::reset()
 {
+  STACKTRACE;
 	if (item)
 		free(item);
 	item = 0;
@@ -43,7 +45,8 @@
 }
 
 
-void Targets::add(SpaceObject *a) {STACKTRACE
+void Targets::add(SpaceObject *a) {
+  STACKTRACE;
 	N += 1;
 	item = (SpaceObject **) realloc(item, sizeof(SpaceObject *) * N);
 	item[N - 1] = a;
@@ -53,6 +56,7 @@
 
 void Targets::rem(int i)
 {
+  STACKTRACE;
 	-- N;
 	item[i]-&gt;attributes &amp;= ~ATTRIB_TARGET;
 	item[i] = item[N];
@@ -61,6 +65,7 @@
 
 void Targets::rem(SpaceObject *r)
 {
+  STACKTRACE;
 	int i;
 	for ( i = 0; i &lt; N; ++i )
 		if (item[i] == r)
@@ -76,6 +81,7 @@
 
 void Targets::calculate()
 {
+  STACKTRACE;
 	int i;
 	
 	for (i = 0; i &lt; N; i += 1)
@@ -93,6 +99,7 @@
 
 int Targets::findindex(SpaceObject *o)
 {
+  STACKTRACE;
 	int i;
 
 	for (i = 0; i &lt; N; i += 1)
@@ -109,5 +116,6 @@
 
 bool Targets::isintargetlist(SpaceObject *o)
 {
+  STACKTRACE;
 	return findindex(o) &gt;= 0;
 }

Modified: trunk/source/melee/mview.cpp
===================================================================
--- trunk/source/melee/mview.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/melee/mview.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -58,7 +58,8 @@
 
 
 
-View * ViewType::create( View * old ) {STACKTRACE
+View * ViewType::create( View * old ) {
+  STACKTRACE;
 	View * r = _create();
 	r-&gt;preinit();
 	r-&gt;type = this;
@@ -111,7 +112,8 @@
 
 
 
-void View::preinit() {STACKTRACE
+void View::preinit() {
+  STACKTRACE;
 	frame = NULL;
 	window = NULL;
 	type = NULL;
@@ -152,7 +154,8 @@
 }
 
 
-void View::animate(Game *game) {STACKTRACE
+void View::animate(Game *game) {
+  STACKTRACE;
 	if (FULL_REDRAW) frame-&gt;full_redraw = true;
 	frame-&gt;erase();
 	prepare(frame, 0);
@@ -168,11 +171,12 @@
 	return;
 	}
 
-void View::config() {STACKTRACE
+void View::config() {
+  STACKTRACE;
 	return;
 	}
 bool View::screen2game(Vector2 *_pos) {
-	STACKTRACE
+  STACKTRACE;
 	Vector2 pos = *_pos;
 	Vector2 opos = pos;
 
@@ -192,7 +196,7 @@
 	return true;
 	}
 double View::in_view(Vector2 pos, Vector2 size) {
-	STACKTRACE
+  STACKTRACE;
 	pos = corner(pos, size);
 	size = size * space_zoom;
 
@@ -211,7 +215,7 @@
 	return a * b / (size.x * size.y);
 }
 int View::focus(CameraPosition *pos, SpaceLocation *la, SpaceLocation *lb) {
-	STACKTRACE
+  STACKTRACE;
 	if (!la &amp;&amp; !lb) return 0;
 	if (!la) la = lb;
 	if (!lb) lb = la;
@@ -241,6 +245,7 @@
 }
 
 /*void View::see_also(SpaceLocation *o) {
+  STACKTRACE;
 	if (!o) return;
 	double x2, y2;
 	x2 = b-&gt;normal_x();
@@ -316,7 +321,8 @@
 	return;
 }
 
-void View::init(View *old) {STACKTRACE
+void View::init(View *old) {
+  STACKTRACE;
 	if (window || frame) {
 		tw_error(&quot;View::init - hmm...&quot;);
 	}
@@ -372,9 +378,11 @@
 		delete frame;
 	}
 }
-void View::calculate(Game *game) {}
+void View::calculate(Game *game) {
+  STACKTRACE;}
 
-void message_type::out(char *string, int dur, int c) {STACKTRACE
+void message_type::out(char *string, int dur, int c) {
+  STACKTRACE;
 	ASSERT (c &lt; 256);
 	if (num_messages == max_messages - 1) {
 		messages[0].end_time = -1;
@@ -390,7 +398,8 @@
 	clean();
 	return;
 	}
-void message_type::print(int dur, int c, const char *format, ...) {STACKTRACE
+void message_type::print(int dur, int c, const char *format, ...) {
+  STACKTRACE;
 	char buf[1024];
 	va_list those_dots;
 	va_start (those_dots, format);
@@ -407,7 +416,8 @@
 	out(buf, dur, c);
 	return;
 	}
-void message_type::clean() {STACKTRACE
+void message_type::clean() {
+  STACKTRACE;
 	int kill_time;
 	if (game) kill_time = game-&gt;game_time;
 	else kill_time = 0;
@@ -421,7 +431,8 @@
 		}
 	return;
 	}
-void message_type::flush() {STACKTRACE
+void message_type::flush() {
+  STACKTRACE;
 	for (int i = 0; i &lt; num_messages; i += 1) {
 		if (messages[i].string)
 			free (messages[i].string);
@@ -430,7 +441,8 @@
 	return;
 	}
 
-void message_type::animate(Frame *frame) {STACKTRACE
+void message_type::animate(Frame *frame) {
+  STACKTRACE;
 
 	if (num_messages &lt;= 0)
 		return;
@@ -462,7 +474,8 @@
 	}
 message_type message;
 
-void View::_event( Event *e ) {STACKTRACE
+void View::_event( Event *e ) {
+  STACKTRACE;
 	if ( e-&gt;type == Event::VIDEO ) {
 		const VideoEvent *ve = (const VideoEvent*) e;
 		const VideoWindow *w = ve-&gt;window;
@@ -502,7 +515,8 @@
 	virtual void init(View *old);
 	//virtual void set_window (BITMAP *dest, int x, int y, int w, int h);
 	};
-void View_Hero::init(View *old) {STACKTRACE
+void View_Hero::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 	f = 0;
 	min = 30;//480;
@@ -609,7 +623,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split2a();
 	};
-void View_Split2a::init(View *old) {STACKTRACE
+void View_Split2a::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -707,7 +722,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split2b();
 	};
-void View_Split2b::init(View *old) {STACKTRACE
+void View_Split2b::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -807,7 +823,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split3();
 	};
-void View_Split3::init(View *old) {STACKTRACE
+void View_Split3::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -828,7 +845,8 @@
 		delete frames[i];
 	}
 }
-void View_Split3::animate(Game *game) {STACKTRACE
+void View_Split3::animate(Game *game) {
+  STACKTRACE;
 	VideoWindow *tmpw;
 	Frame *tmpf;
 	CameraPosition tmpc;
@@ -906,7 +924,8 @@
 	virtual void animate(Game *game);
 	virtual ~View_Split4();
 	};
-void View_Split4::init(View *old) {STACKTRACE
+void View_Split4::init(View *old) {
+  STACKTRACE;
 	View::init(old);
 
 	min = 480;
@@ -928,7 +947,8 @@
 		delete frames[i];
 	}
 }
-void View_Split4::animate(Game *game) {STACKTRACE
+void View_Split4::animate(Game *game) {
+  STACKTRACE;
 	VideoWindow *tmpw;
 	Frame *tmpf;
 	CameraPosition tmpc;

Modified: trunk/source/other/nullphas.cpp
===================================================================
--- trunk/source/other/nullphas.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/nullphas.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,11 +24,13 @@
   oship-&gt;size, unit_vector( oship-&gt;get_angle()) * PHASE_MAX * oship-&gt;size,
   oship, oship-&gt;get_sprite(), oship-&gt;get_sprite_index(), hot_color, HOT_COLORS,
   PHASE_DELAY, PHASE_MAX, PHASE_DELAY ){
+  STACKTRACE;
 }
 
-void NullPhaser::animate( Frame* space ){}
+void NullPhaser::animate( Frame* space ){
+  STACKTRACE;}
 void NullPhaser::calculate(){
-	STACKTRACE
+  STACKTRACE;
 
   if( state &gt; 0 ){
     game-&gt;add( ship );

Modified: trunk/source/other/objanim.cpp
===================================================================
--- trunk/source/other/objanim.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/objanim.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 Animation( creator, opos, osprite, first_frame, num_frames, frame_size, depth ),
   angle(oangle)
 {
+  STACKTRACE;
   vel = ovel;
 
   sprite_index = get_index(angle);
@@ -32,7 +33,7 @@
 }
 
 void ObjectAnimation::calculate(){
-	STACKTRACE
+  STACKTRACE;
 
   sprite_index &gt;&gt;= 6;
   Animation::calculate();

Modified: trunk/source/other/orbit.cpp
===================================================================
--- trunk/source/other/orbit.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/orbit.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -45,7 +45,7 @@
 
 int SpaceStation::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Crew-=(int)(normal+direct);
 	if(Crew&lt;=0) state=0;
@@ -54,7 +54,7 @@
 
 void SpaceStation::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	//Healing beam code
 
@@ -74,6 +74,7 @@
 SpaceStation::SpaceStation(SpaceLocation *creator, Vector2 opos,
 	SpaceSprite *oSprite):SpaceObject(creator,opos,0.,oSprite)
 {
+  STACKTRACE;
 //	layer=LAYER_SPECIAL;
 	mass=10.;
 	Crew=2000;
@@ -86,6 +87,7 @@
 	double lrad, double lspeed, int iLock):SpaceLocation(creator,
 	lpos, 0.)
 {
+  STACKTRACE;
 	id=ORBIT_ID;
 	ipos=lpos;
 	Lock=iLock;
@@ -103,7 +105,7 @@
 
 void OrbitHandler::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if((sun==NULL)||(plan==NULL))
 		return;
@@ -142,6 +144,7 @@
 
 int OrbitHandler::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
 	return FALSE;
 }
 
@@ -149,6 +152,7 @@
 	:
 	SpaceObject(NULL, opos, 0.0, sprite)
 	{
+  STACKTRACE;
 
 	layer = LAYER_SHOTS;
 	set_depth(LAYER_EXPLOSIONS);
@@ -175,7 +179,7 @@
 
 int Sun::canCollide(SpaceLocation *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if(other-&gt;id==COMET_ID) return FALSE;
 	return(!other-&gt;isPlanet());
@@ -183,7 +187,7 @@
 
 void Sun::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	double d = distance(other);
 	if (d &gt;= Range) return;
@@ -195,7 +199,7 @@
 }
 
 void Sun::calculate() {
-	STACKTRACE
+  STACKTRACE;
 
 	SpaceObject::calculate();
 	SpaceObject *o;

Modified: trunk/source/other/planet3d.cpp
===================================================================
--- trunk/source/other/planet3d.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/planet3d.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 
 SpaceSprite::SpaceSprite(BITMAP *image, int _attributes)
 {
+  STACKTRACE;
   if (_attributes == -1) 
     _attributes = string_to_sprite_attributes(NULL);
   general_attributes = _attributes;

Modified: trunk/source/other/radar.cpp
===================================================================
--- trunk/source/other/radar.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/radar.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -32,16 +32,19 @@
 
 void ZRadar::toggleActive()
 {
+  STACKTRACE;
 	active^=1;
 }
 
 void ZRadar::setSize(double Size)
 {
+  STACKTRACE;
 	size=Size;
 }
 
 void ZRadar::setTarget(SpaceLocation *target)
 {
+  STACKTRACE;
 	t=target;
 }
 
@@ -52,6 +55,7 @@
 
 ZRadar::ZRadar(BITMAP *BlankSlate, Presence *target, double Size)
 {
+  STACKTRACE;
 	Blank=BlankSlate;
 	Painted = create_bitmap_ex(bitmap_color_depth(screen),Blank-&gt;w,Blank-&gt;h);
 	t=target;
@@ -62,13 +66,14 @@
 
 double ZRadar::shiftscale(double r_center, double v_center, double scale, double n)
 {
+  STACKTRACE;
 	//Used to scale game coordinates onto RADAR screen coordinates
 	return(((n - r_center)*scale)+v_center);
 }
 
 void ZRadar::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	//If the radar is disabled, don't do anything.
 	if(active==FALSE) return;

Modified: trunk/source/other/shippart.cpp
===================================================================
--- trunk/source/other/shippart.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/shippart.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -33,6 +33,7 @@
 :
 Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	// remove this from the physics interaction
 	//mass = 0;
 	collide_flag_anyone = 0;
@@ -45,7 +46,7 @@
 
 void BigShip::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// make sure the &quot;ship&quot; is not a real target
 	if (targets-&gt;isintargetlist(this))
@@ -70,7 +71,7 @@
 // change velocities of the ship and all its parts
 void BigShip::change_vel(Vector2 dvel)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	int i;
 
@@ -88,7 +89,7 @@
 // change positions of the ship and all its parts
 void BigShip::change_pos(Vector2 dpos)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	int i;
 
@@ -106,6 +107,7 @@
 
 void BigShip::animate(Frame *space)
 {
+  STACKTRACE;
 	return;
 }
 
@@ -120,6 +122,7 @@
 :
 Ship(aowner, 0, 0, spr)
 {
+  STACKTRACE;
 	owner = aowner;
 	relpos = orelpos;
 	relangle = orelangle;
@@ -164,7 +167,7 @@
 
 void BigShipPart::syncpos()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// maintain (relative) position wrt the ship
 	angle = owner-&gt;angle + relangle;	// this is the discrete angle (64 values).
@@ -186,7 +189,7 @@
 
 void BigShipPart::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(owner &amp;&amp; owner-&gt;exists()) )
 	{
@@ -232,7 +235,7 @@
 
 int BigShipPart::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	// by default, transmit damage to the ship owner ...
 	return owner-&gt;handle_damage(source, normal, direct);
@@ -242,7 +245,7 @@
 
 void BigShipPart::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	Ship::inflict_damage(other);
 
@@ -254,6 +257,7 @@
 
 bool BigShipPart::isdisabled()
 {
+  STACKTRACE;
 	return false;
 }
 
@@ -262,7 +266,7 @@
 // change velocities of the ship and all its parts
 void BigShipPart::change_vel(Vector2 dvel)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	owner-&gt;change_vel(dvel);
 }
@@ -270,7 +274,7 @@
 // change positions of the ship and all its parts
 void BigShipPart::change_pos(Vector2 dpos)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	owner-&gt;change_pos(dpos);
 }
@@ -282,6 +286,7 @@
 :
 SpaceObject(aownerpart, aownerpart-&gt;pos, aownerpart-&gt;angle, ospr)
 {
+  STACKTRACE;
 	ownerpart = aownerpart;
 
 	layer = LAYER_SHIPS;
@@ -300,7 +305,7 @@
 
 void BigShipPartDevice::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if ( !(ownerpart &amp;&amp; ownerpart-&gt;exists()) )
 	{
@@ -322,7 +327,7 @@
 
 void BigShipPartDevice::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	if (ownerpart-&gt;isdisabled())
 		return;
@@ -334,7 +339,7 @@
 
 int BigShipPart::handle_fuel_sap(SpaceLocation *source, double normal)
 {
-	STACKTRACE
+  STACKTRACE;
 
 	return owner-&gt;handle_fuel_sap(source, normal);
 }
@@ -343,6 +348,7 @@
 
 ShipType *BigShipPart::get_shiptype()
 {
+  STACKTRACE;
 	// this is necessary, otherwise the Kat Poly ship crashes.
 	// also, &quot;type&quot; cannot be redirected inside the constructor, cause the
 	// parents' type is declared outside of its constructor (bad?).

Modified: trunk/source/other/vbodies.cpp
===================================================================
--- trunk/source/other/vbodies.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/vbodies.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -208,15 +208,18 @@
 
 VSpaceInstallation::VSpaceInstallation():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
 	collide_flag_sameteam = ALL_LAYERS;
 	collide_flag_sameship = ALL_LAYERS;
 	layer = LAYER_CBODIES;
 	set_depth(DEPTH_ASTEROIDS);
 }
 
-void VSpaceInstallation::Initialize(void) {;}
+void VSpaceInstallation::Initialize(void) {
+  STACKTRACE;;}
 
 void VSpaceInstallation::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game-&gt;log_file (&quot;vobject.ini&quot;);
   this-&gt;armour = get_config_float(nameInIni, &quot;Armour&quot;, 0);
   this-&gt;mass = get_config_float(nameInIni, &quot;Mass&quot;, 0);
@@ -224,6 +227,7 @@
 }
 
 bool VSpaceInstallation::AddInstallation(VGroundInstallation* oGI) {
+  STACKTRACE;
   int i;
   for(i=0;i&lt;12;i++) {
     if(this-&gt;Installation[i]==NULL) {
@@ -237,10 +241,12 @@
 }
 
 void VSpaceInstallation::calculate(void) {
+  STACKTRACE;
 	this-&gt;vel *= (1 - this-&gt;friction * game-&gt;frame_time);
 }
 
 void VSpaceInstallation::death() {
+  STACKTRACE;
   int i;
   for(i=0;i&lt;12;i++)
     if(this-&gt;Installation[i]!=NULL)
@@ -248,6 +254,7 @@
 }
 
 int VSpaceInstallation::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   message.print(500,5,&quot;Installation armour=%d&quot;, (long int)armour);
   if(source-&gt;isAsteroid()) return(0);
   armour -= (normal + direct);
@@ -257,45 +264,54 @@
 
 
 VDefSat::VDefSat() {
+  STACKTRACE;
   this-&gt;set_sprite(VDefSat::mySprite);
   this-&gt;Initialize();
 }
 
 void VDefSat::Initialize(void) {
+  STACKTRACE;
   VSpaceInstallation::Initialize(&quot;DefSat&quot;);
 }
 
 VDeepSpaceOutpost::VDeepSpaceOutpost() {
+  STACKTRACE;
   this-&gt;set_sprite(VDeepSpaceOutpost::mySprite);
   this-&gt;Initialize();
 }
 
 void VDeepSpaceOutpost::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize(&quot;DeepSpaceOutpost&quot;);
 
 }
 
 VDeepSpaceColony::VDeepSpaceColony() {
+  STACKTRACE;
   this-&gt;set_sprite(VDeepSpaceColony::mySprite);
   this-&gt;Initialize();
 }
 
 void VDeepSpaceColony::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize(&quot;DeepSpaceColony&quot;);
 }
 
 VDeepSpaceStation::VDeepSpaceStation() {
+  STACKTRACE;
   this-&gt;set_sprite(VDeepSpaceStation::mySprite);
   this-&gt;Initialize();
 }
 
 void VDeepSpaceStation::Initialize() {
+  STACKTRACE;
   VSpaceInstallation::Initialize(&quot;DeepSpaceStation&quot;);
 }
 
 
 VGroundInstallation::VGroundInstallation(SpaceLocation* olocation):Presence()
 {
+  STACKTRACE;
   this-&gt;totalDamageTaken = 0;
   this-&gt;location = olocation;
   actionCounter = 0;
@@ -308,11 +324,13 @@
 
 void VGroundInstallation::Initialize(void)
 {
+  STACKTRACE;
   ;
 }
 
 void VGroundInstallation::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
 	game-&gt;log_file (&quot;vobject.ini&quot;);
   this-&gt;damageToDisable = get_config_float(nameInIni, &quot;DamageToDisable&quot;, 0);
   this-&gt;damageToDestroy = get_config_float(nameInIni, &quot;DamageToDestroy&quot;, 0);
@@ -322,6 +340,7 @@
 
 int VGroundInstallation::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if(source-&gt;isPlanet()||source-&gt;isAsteroid()) return(0);
   this-&gt;totalDamageTaken += (normal + direct);
   message.print(350,5,&quot;DamageTaken=%d&quot;, (long int)this-&gt;totalDamageTaken);
@@ -342,6 +361,7 @@
 
 void VGroundInstallation::calculate(void)
 {
+  STACKTRACE;
   if(!this-&gt;isFunctioning)return;
   Presence::calculate();
   actionCounter += ((double)frame_time / 1000.0) * this-&gt;actionsPerSecond;
@@ -355,47 +375,57 @@
 
 bool VGroundInstallation::BattleAction(void)
 {
+  STACKTRACE;
   return(false);
 }
 
 VWilderness::VWilderness(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this-&gt;Initialize();
 }
 
 void VWilderness::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;Wilderness&quot;);
 }
 
 
 VColony::VColony(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this-&gt;Initialize();
 }
 
 void VColony::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;Colony&quot;);
 }
 
 VMine::VMine(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this-&gt;Initialize();
 }
 
 void VMine::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;Mine&quot;);
 }
 
 VFortification::VFortification(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this-&gt;Initialize();
 }
 
 void VFortification::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;Fortification&quot;);
 }
 
 VPlanetaryShield::VPlanetaryShield(SpaceLocation* olocation):VGroundInstallation(olocation) {
+  STACKTRACE;
   this-&gt;Initialize();
   this-&gt;isFunctioning = true;
   this-&gt;isDestroyed = false;
@@ -405,6 +435,7 @@
 
 void VPlanetaryShield::Initialize(void)
 {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;PlanetaryShield&quot;);
   this-&gt;maxShield = get_config_float(&quot;PlanetaryShield&quot;, &quot;Shield&quot;, 0);
   this-&gt;currentShield = maxShield;
@@ -412,6 +443,7 @@
 }
 
 int VPlanetaryShield::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(this-&gt;currentShield&gt;0) {
     this-&gt;currentShield -= (normal + direct);
     message.print(500,5,&quot;Shield level=%d&quot;, (long int)this-&gt;currentShield);
@@ -422,6 +454,7 @@
 }
 
 void VPlanetaryShield::calculate(void) {
+  STACKTRACE;
   this-&gt;currentShield += ((double)frame_time / 1000) * this-&gt;shieldRegenerationPerSecond;
   if(this-&gt;currentShield&gt;this-&gt;maxShield) this-&gt;currentShield=this-&gt;maxShield;
   if(this-&gt;currentShield&lt;0) this-&gt;isShield = false;
@@ -430,6 +463,7 @@
 
 VGroundDefenseLaser::VGroundDefenseLaser(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this-&gt;Initialize();
   this-&gt;isFunctioning = true;
   this-&gt;isDestroyed = false;
@@ -438,6 +472,7 @@
 }
 
 void VGroundDefenseLaser::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;PlanetaryDefenseLaser&quot;);
   weaponRange = scale_range(get_config_float(&quot;PlanetaryDefenseLaser&quot;, &quot;LaserRange&quot;, 0));
   weaponColor = get_config_int(&quot;PlanetaryDefenseLaser&quot;, &quot;LaserColor&quot;, 0);
@@ -446,6 +481,7 @@
 }
 
 bool VGroundDefenseLaser::BattleAction() {
+  STACKTRACE;
   Vector2 RelLoc;
   double ta;
 	SpaceObject *o = NULL;
@@ -483,6 +519,7 @@
 
 VGroundIonCannon::VGroundIonCannon(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this-&gt;Initialize();
   this-&gt;isFunctioning = true;
   this-&gt;isDestroyed = false;
@@ -492,6 +529,7 @@
 }
 
 void VGroundIonCannon::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;PlanetaryIonCannon&quot;);
   weaponRange = scale_range(get_config_float(&quot;PlanetaryIonCannon&quot;, &quot;CannonRange&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;PlanetaryIonCannon&quot;, &quot;CannonSpeed&quot;, 0));
@@ -500,6 +538,7 @@
 }
 
 bool VGroundIonCannon::BattleAction(void) {
+  STACKTRACE;
   //double rAnticipated;
   Vector2 RelLoc;
 
@@ -529,6 +568,7 @@
 
 VGroundMissileLauncher::VGroundMissileLauncher(SpaceLocation* olocation):VGroundInstallation(olocation)
 {
+  STACKTRACE;
   this-&gt;Initialize();
   this-&gt;isFunctioning = true;
   this-&gt;isDestroyed = false;
@@ -538,6 +578,7 @@
 }
 
 void VGroundMissileLauncher::Initialize() {
+  STACKTRACE;
   VGroundInstallation::Initialize(&quot;PlanetaryMissileLauncher&quot;);
   weaponRange = scale_range(get_config_float(&quot;PlanetaryMissileLauncher&quot;, &quot;MissileRange&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;PlanetaryMissileLauncher&quot;, &quot;MissileSpeed&quot;, 0));
@@ -547,6 +588,7 @@
 }
 
 bool VGroundMissileLauncher::BattleAction(void) {
+  STACKTRACE;
   Vector2 RelLoc;
 
 	SpaceObject *o = NULL;
@@ -572,6 +614,7 @@
 
 VSpaceMine::VSpaceMine():SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
   this-&gt;set_sprite(VSpaceMine::mySprite);
   this-&gt;explosionSprite = VSpaceMine::explosionSprite;
   Initialize();
@@ -585,12 +628,14 @@
 }
 
 void VSpaceMine::death(void) {
+  STACKTRACE;
   this-&gt;animateExplosion();
   SpaceObject::death();
   if(this-&gt;willRespawn) game-&gt;add(new VSpaceMine());
 }
 
 void VSpaceMine::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Vector2 V;
   if(!other-&gt;isShip()) return; //only damages ships!!!
   this-&gt;damage_factor = this-&gt;damage;
@@ -602,6 +647,7 @@
 
 int VSpaceMine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if(source-&gt;isLine()||source-&gt;isShot()) {
     armour -= normal + direct;
     if(armour&lt;0) state = 0;
@@ -612,6 +658,7 @@
 }
 
 void VSpaceMine::Initialize() {
+  STACKTRACE;
 	game-&gt;log_file (&quot;vobject.ini&quot;);
   this-&gt;sprite_index = 0;
   this-&gt;armour = get_config_float(&quot;SpaceMine&quot;, &quot;Armour&quot;, 0);
@@ -620,6 +667,7 @@
 }
 
 void VSpaceMine::animateExplosion(void) {
+  STACKTRACE;
 //	Animation(SpaceLocation *creator, Vector2 opos, SpaceSprite *osprite, 
 //			int first_frame, int num_frames, int frame_size, double depth, double scale = 1.0) ;
 	game-&gt;add(new Animation(this, normal_pos(),
@@ -630,6 +678,7 @@
 
 void VSpaceMine::soundExplosion(void) 
 {
+  STACKTRACE;
   if(damage_factor &gt; 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -661,6 +710,7 @@
 
 VNebula::VNebula():Presence()
 {
+  STACKTRACE;
 //  game-&gt;all_damage_direct = true;
 //  game-&gt;is_nebula = true;
   friction = 0.0004;
@@ -670,6 +720,7 @@
 
 VNebula::VNebula(double ofriction):Presence()
 {
+  STACKTRACE;
 //  game-&gt;all_damage_direct = true;
   friction = ofriction;
 	videosystem.color_effects = VNebulaColorEffects;
@@ -679,6 +730,7 @@
 
 VNebula::VNebula(double ofriction, int oionStorms):Presence()
 {
+  STACKTRACE;
 //  game-&gt;all_damage_direct = true;
   friction = ofriction; 
   ionStorms = oionStorms;
@@ -687,6 +739,7 @@
 }
 
 void VNebula::calculate(void) {
+  STACKTRACE;
   Presence::calculate();
   
   for(std::list&lt;SpaceLocation*&gt;::iterator i=game-&gt;item.begin();i!=game-&gt;item.end();i++)
@@ -710,6 +763,7 @@
 }
 
 VIonStorm::VIonStorm(void):SpaceObject(NULL, Vector2(0,0), 0, NULL) {
+  STACKTRACE;
 //	SpaceObject(SpaceLocation *creator, Vector2 opos, double oangle, 
 //			SpaceSprite *osprite);
 
@@ -721,6 +775,7 @@
 :
 SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
   double speed, angle;
   this-&gt;velocityRestoreFactor = 0.00;
   this-&gt;mass = 0;
@@ -739,6 +794,7 @@
 }
 
 void VDustCloud::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game-&gt;log_file (&quot;vobject.ini&quot;);
   this-&gt;sprite_index = 0;
 	mass = get_config_int(nameInIni, &quot;Mass&quot;, 0);
@@ -752,10 +808,12 @@
 }
 
 void VDustCloud::Initialize(void) {
+  STACKTRACE;
   Initialize(&quot;DustCloud&quot;);
 }
 
 int VDustCloud::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(source-&gt;isAsteroid()) return(0);
   if(source-&gt;isLine()||source-&gt;isShot()) {
     armour -= (normal + direct);
@@ -766,6 +824,7 @@
 }
 
 void VDustCloud::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Vector2 relV;
   double excessSpeed;
   double d;
@@ -789,11 +848,13 @@
 }
 
 void VDustCloud::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this-&gt;willRespawn) game-&gt;add(new VDustCloud());
 }
 
 void VDustCloud::calculate(void) {
+  STACKTRACE;
   double x;
   x = (double)frame_time * this-&gt;velocityRestoreFactor;
   if(x&gt;1)x=1;
@@ -806,6 +867,7 @@
 :
 SpaceObject(NULL, random(map_size), random(PI2), meleedata.asteroidSprite)
 {
+  STACKTRACE;
   double speed, angle;
   this-&gt;velocityRestoreFactor = 0.00;
   this-&gt;mass = 0;
@@ -825,6 +887,7 @@
 }
 
 void VGasCloud::Initialize(const char* nameInIni) {
+  STACKTRACE;
 	game-&gt;log_file (&quot;vobject.ini&quot;);
   this-&gt;sprite_index = 0;
 	mass = get_config_int(nameInIni, &quot;Mass&quot;, 0);
@@ -843,10 +906,12 @@
 }
 
 void VGasCloud::Initialize(void) {
+  STACKTRACE;
   Initialize(&quot;GasCloud&quot;);
 }
 
 int VGasCloud::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   if(isEnergized = false) {
     this-&gt;damageFactor=0;
     this-&gt;damage_factor=0;
@@ -868,6 +933,7 @@
 }
 
 void VGasCloud::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   if(this-&gt;damageFactor&gt;0.001) {
     //message.print(500,5,&quot;energizing damage&quot;);
     damage(other, this-&gt;energizingDamageFactor * this-&gt;damageFactor / 2, this-&gt;energizingDamageFactor * this-&gt;damageFactor / 2);
@@ -884,6 +950,7 @@
 }
 
 void VGasCloud::calculate(void) {
+  STACKTRACE;
   double x;
   if(this-&gt;isEnergized) {
     this-&gt;isEnergized = false;
@@ -901,6 +968,7 @@
 }
 
 void VGasCloud::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this-&gt;willRespawn) game-&gt;add(new VGasCloud());
 }
@@ -910,6 +978,7 @@
 :
 Planet(Vector2(0,0), VMoon::mySprite, 0) // a sprite is needed to avoid a crash...WTF?
 {
+  STACKTRACE;
   int i;
   for(i=0; i&lt;12; i++) this-&gt;Installation[i]=NULL;
   this-&gt;id = ID_PLANET;
@@ -917,16 +986,19 @@
 }
 
 double VPlanet::getRadius(void) {
+  STACKTRACE;
   return(((this-&gt;size.x + this-&gt;size.y) / 4) / 1000);
 }
 
 
 void VPlanet::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   Planet::inflict_damage(other);
 }
 
 int VPlanet::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int i,j;
   for(i=0;i&lt;12;i++) {
     if(this-&gt;Installation[i]!=NULL)
@@ -966,6 +1038,7 @@
 
 void VPlanet::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
 	game-&gt;log_file (&quot;vobject.ini&quot;);
   this-&gt;sprite_index = 0;
 	gravity_mindist = scale_range(get_config_float(nameInIni, &quot;GravityMinDist&quot;, 0));
@@ -978,6 +1051,7 @@
 }
 
 bool VPlanet::AddInstallation(VGroundInstallation* oGI) {
+  STACKTRACE;
   int i;
   for(i=0;i&lt;12;i++) {
     if(this-&gt;Installation[i]==NULL) {
@@ -990,6 +1064,7 @@
 }
 
 void VPlanet::death() {
+  STACKTRACE;
   int i;
   for(i=0;i&lt;12;i++)
     if(this-&gt;Installation[i]!=NULL)
@@ -997,6 +1072,7 @@
 }
 
 void VStar::AttractShots(int warping_power, double intensity) {
+  STACKTRACE;
   //sort of like gravity, but no minimum distance
   //and only changes direction, not speed.
   //only affects massless objects.
@@ -1057,6 +1133,7 @@
 :
 Planet(Vector2(0,0), VBrownDwarf::mySprite, 0) //sprite problem?
 {
+  STACKTRACE;
   this-&gt;id = ID_PLANET; // done for grav-whip purposes!!!!
   this-&gt;starEnergy = 0.0;
   this-&gt;angle = 0;
@@ -1074,11 +1151,13 @@
 }
 
 double VStar::getRadius(void) {
+  STACKTRACE;
   return((this-&gt;size.x + this-&gt;size.y) / 4);
 }
 
 
 void VStar::calculate() {
+  STACKTRACE;
   double r;
   double maxFlares;
   double flareFactor;
@@ -1114,6 +1193,7 @@
 }
 
 void VStar::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   ;// this SHOULD be overridden as needed by individual stars...?
   VRedFlare* VRF;
   VRF = new VRedFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
@@ -1124,12 +1204,14 @@
 
 int VStar::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
   return(TRUE);
 	if(other-&gt;id==COMET_ID) return FALSE;
 	return(!other-&gt;isPlanet());
 }
 
 void VStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   double percentCoreDamage;
 
   double totalDamage;
@@ -1145,6 +1227,7 @@
 }
 
 int VStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
   /*int x;
   x = VStar::handle_damage(source, normal, direct);
@@ -1157,6 +1240,7 @@
 
 void VStar::Initialize(const char* nameInIni)
 {
+  STACKTRACE;
   starEnergy = 0.0;
 	game-&gt;log_file (&quot;vobject.ini&quot;);
   this-&gt;sprite_index = 0;
@@ -1187,6 +1271,7 @@
 }
 
 bool VStar::isPlanet(void) {
+  STACKTRACE;
   return(true); // a kludge, should help grav-whip???
 }
 
@@ -1195,6 +1280,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this-&gt;set_sprite(mySprite);
   armour = VMetalShard::myArmour;
   damage_factor = VMetalShard::myDamage;
@@ -1208,6 +1294,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   if(VMetalShard::mySprite==NULL) {
     ;
   }
@@ -1223,6 +1310,7 @@
 
 
 int VMetalShard::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (!exists()) return 0;
 	if ((normal &gt; 0) || (direct &gt; 0)) {
 		armour -= normal;
@@ -1239,6 +1327,7 @@
 }
 
 void VMetalShard::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other-&gt;exists()) return;
 	damage(other, 0, damage_factor);
   if(other-&gt;isShip()) ((Ship*)other)-&gt;update_panel=1;
@@ -1249,6 +1338,7 @@
 }
 
 void VMetalShard::animateExplosion(void) {
+  STACKTRACE;
 	game-&gt;add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1256,6 +1346,7 @@
 }
 
 void VMetalShard::soundExplosion(void) {
+  STACKTRACE;
   if(damage_factor &gt; 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -1285,11 +1376,13 @@
 }
 
 void VMetalShard::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this-&gt;willRespawn) game-&gt;add(new VMetalShard());
 }
 
 void VMetalShard::compareSprites(void) {
+  STACKTRACE;
   if(this-&gt;sprite==this-&gt;mySprite) {
     tw_error(&quot;Identical sprites&quot;);
   }
@@ -1302,6 +1395,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this-&gt;set_sprite(mySprite);
   armour = VMetalAsteroid::myArmour;
   damage_factor = VMetalAsteroid::myDamage;
@@ -1310,7 +1404,8 @@
   this-&gt;willRespawn = TRUE;
 }
 
-int VMetalAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {STACKTRACE
+int VMetalAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   Vector2 V;
   //tw_error(&quot;about to handle damage&quot;);
 	if (!exists()) return 0;
@@ -1335,7 +1430,8 @@
 	return 1;
 }
 
-void VMetalAsteroid::inflict_damage(SpaceObject *other) {STACKTRACE
+void VMetalAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
   //tw_error(&quot;about to inflict damage&quot;);
 	if (!other-&gt;exists()) return;
 	damage(other, 0, damage_factor);
@@ -1347,6 +1443,7 @@
 }
 
 void VMetalAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game-&gt;add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1356,6 +1453,7 @@
 
 void VMetalAsteroid::soundExplosion(void) 
 {
+  STACKTRACE;
   if(damage_factor &gt; 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -1384,6 +1482,7 @@
 }
 
 void VMetalAsteroid::death(void) {
+  STACKTRACE;
   VMetalShard* VS;
   Vector2 Loc, UV;
   int i;
@@ -1413,6 +1512,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this-&gt;set_sprite(mySprite);
   armour = VSmallAsteroid::myArmour;
   damage_factor = VSmallAsteroid::damage_factor;
@@ -1425,6 +1525,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this-&gt;set_sprite(mySprite);
   armour = 10;
   damage_factor = 0;
@@ -1437,6 +1538,7 @@
 
 
 int VSmallAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	Vector2 V;
   if (!exists()) return 0;
 	if ((normal &gt; 0) || (direct &gt; 0)) {
@@ -1461,6 +1563,7 @@
 }
 
 void VSmallAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other-&gt;exists()) return;
 	damage(other, 0, damage_factor);
   if(other-&gt;isShip()) ((Ship*)other)-&gt;update_panel=1;
@@ -1471,6 +1574,7 @@
 }
 
 void VSmallAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game-&gt;add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1479,6 +1583,7 @@
 }
 
 void VSmallAsteroid::soundExplosion(void) {
+  STACKTRACE;
   if(damage_factor &gt; 0) 
     {
       int i = iround_down(damage_factor / 2);
@@ -1507,6 +1612,7 @@
 }
 
 void VSmallAsteroid::death(void) {
+  STACKTRACE;
   SpaceObject::death();
   if(this-&gt;willRespawn) game-&gt;add(new VSmallAsteroid());
 
@@ -1516,6 +1622,7 @@
 :
 Asteroid()
 {
+  STACKTRACE;
   this-&gt;set_sprite(mySprite);
   armour = VLargeAsteroid::myArmour;
   damage_factor = VLargeAsteroid::myDamage;
@@ -1525,6 +1632,7 @@
 }
 
 int VLargeAsteroid::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   Vector2 V;
 	if (!exists()) return 0;
 	if ((normal &gt; 0) || (direct &gt; 0)) {
@@ -1551,6 +1659,7 @@
 }
 
 void VLargeAsteroid::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (!other-&gt;exists()) return;
 	damage(other, 0, damage_factor);
   if(other-&gt;isShip()) ((Ship*)other)-&gt;update_panel=1;
@@ -1561,6 +1670,7 @@
 }
 
 void VLargeAsteroid::animateExplosion(void) {
+  STACKTRACE;
 	game-&gt;add(new Animation(this, normal_pos(),
     explosionSprite, 0, 10,
     scale_frames(0), DEPTH_EXPLOSIONS));
@@ -1570,6 +1680,7 @@
 
 void VLargeAsteroid::soundExplosion(void) 
 {
+  STACKTRACE;
   if(damage_factor &gt; 0) {
     int i = iround_down(damage_factor / 2);
     if(i &gt;= BOOM_SAMPLES) i = BOOM_SAMPLES - 1;
@@ -1597,6 +1708,7 @@
 }
 
 void VLargeAsteroid::death(void) {
+  STACKTRACE;
   VSmallAsteroid* VS;
   Vector2 Loc, UV;
   int i;
@@ -1616,11 +1728,13 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VMoon::mySprite);
   this-&gt;Initialize(&quot;Moon&quot;);
 }
 
 void VMoon::calculate() {
+  STACKTRACE;
   VPlanet::calculate();
 }
 
@@ -1629,6 +1743,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VRockballPlanet::mySprite);
   this-&gt;Initialize(&quot;RockballPlanet&quot;);
 }
@@ -1639,6 +1754,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VInhospitablePlanet::mySprite);
   this-&gt;Initialize(&quot;InhospitablePlanet&quot;);
 }
@@ -1647,6 +1763,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VHabitablePlanet::mySprite);
   this-&gt;Initialize(&quot;HabitablePlanet&quot;);
 }
@@ -1655,6 +1772,7 @@
 :
 VPlanet()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VGasGiant::mySprite);
   this-&gt;Initialize(&quot;GasGiant&quot;);
 
@@ -1664,15 +1782,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VBrownDwarf::mySprite);
   this-&gt;Initialize(&quot;BrownDwarf&quot;);
 }
 
 void VBrownDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VBrownDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1681,15 +1802,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VRedDwarf::mySprite);
   this-&gt;Initialize(&quot;RedDwarf&quot;);
 }
 
 void VRedDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1697,15 +1821,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VWhiteDwarf::mySprite);
   this-&gt;Initialize(&quot;WhiteDwarf&quot;);
 }
 
 void VWhiteDwarf::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 void VWhiteDwarf::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game-&gt;add(VRF);
@@ -1714,6 +1841,7 @@
 
 
 int VWhiteDwarf::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1722,15 +1850,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VRedStar::mySprite);
   this-&gt;Initialize(&quot;RedStar&quot;);
 }
 
 void VRedStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1738,20 +1869,24 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VOrangeStar::mySprite);
   this-&gt;Initialize(&quot;OrangeStar&quot;);
 
 }
 
 void VOrangeStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VOrangeStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VOrangeStar::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VOrangeFlare* VRF;
   VRF = new VOrangeFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game-&gt;add(VRF);
@@ -1763,20 +1898,24 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VYellowStar::mySprite);
   this-&gt;Initialize(&quot;YellowStar&quot;);
 }
 
 
 void VYellowStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VYellowStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VYellowStar::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VYellowFlare* VRF;
   VRF = new VYellowFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game-&gt;add(VRF);
@@ -1788,19 +1927,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VWhiteStar::mySprite);
   this-&gt;Initialize(&quot;WhiteStar&quot;);
 }
 
 void VWhiteStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VWhiteStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VWhiteStar::LaunchFlare(VStar* osource, double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game-&gt;add(VRF);
@@ -1811,15 +1954,18 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VRedGiant::mySprite);
   this-&gt;Initialize(&quot;RedGiant&quot;);
 }
 
 void VRedGiant::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VRedGiant::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
@@ -1828,19 +1974,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VBlueGiant::mySprite);
   this-&gt;Initialize(&quot;BlueGiant&quot;);
 }
 
 void VBlueGiant::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VBlueGiant::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return VStar::handle_damage(source, normal, direct);
 }
 
 void VBlueGiant::LaunchFlare(double oangle, double oinitialVelocity, double orange, double odamage, double ofinalVelocity) {
+  STACKTRACE;
   VWhiteFlare* VRF;
   VRF = new VWhiteFlare(this, oangle, oinitialVelocity, orange, odamage, ofinalVelocity);
   game-&gt;add(VRF);
@@ -1852,6 +2002,7 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VNeutronStar::mySprite);
   this-&gt;Initialize(&quot;NeutronStar&quot;);
 	/*game-&gt;log_file (&quot;vobject.ini&quot;);
@@ -1864,13 +2015,16 @@
 }
 
 void VNeutronStar::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VNeutronStar::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
 }
 void VNeutronStar::calculate(void) {
+  STACKTRACE;
   this-&gt;sprite_index += 1;
   while(this-&gt;sprite_index&gt;63) this-&gt;sprite_index -=64;
   while(this-&gt;sprite_index&lt;0) this-&gt;sprite_index +=64;
@@ -1883,19 +2037,23 @@
 :
 VStar()
 {
+  STACKTRACE;
   this-&gt;set_sprite(VHypermass::mySprite);
   this-&gt;Initialize(&quot;Hypermass&quot;);
 }
 
 void VHypermass::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   VStar::inflict_damage(other);
 }
 
 int VHypermass::handle_damage(SpaceLocation* source, double normal, double direct) {
+  STACKTRACE;
   return(0);
 }
 
 void VHypermass::calculate(void) {
+  STACKTRACE;
   this-&gt;sprite_index += 1;
   while(this-&gt;sprite_index&gt;63) this-&gt;sprite_index -=64;
   while(this-&gt;sprite_index&lt;0) this-&gt;sprite_index +=64;
@@ -1908,6 +2066,7 @@
 Missile(source, source-&gt;pos, angle, initialVelocity, 
         odamage, range, odamage, source, VRedFlare::mySprite, 0)
 {
+  STACKTRACE;
   creator = (SpaceLocation*)source;
   pos = source-&gt;pos;
   originalVelocity = initialVelocity;
@@ -1919,6 +2078,7 @@
 }
 
 void VFlare::calculate() {
+  STACKTRACE;
   double amountFlown, amountToFly, currentAngle, calcVelocity;
   amountToFly = ((double)this-&gt;range - (double)this-&gt;d) / (double)this-&gt;range;
   amountToFly = amountToFly * amountToFly * amountToFly;
@@ -1931,11 +2091,13 @@
 }
 
 void VFlare::inflict_damage(SpaceObject* other) {
+  STACKTRACE;
   if((SpaceLocation*)other == (SpaceLocation*)creator) return;
   Missile::inflict_damage(other);
 }
 
 int VFlare::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
   if((SpaceLocation*)source == (SpaceLocation*)creator) return(0);
   return(Missile::handle_damage(source, normal, direct));
 }
@@ -1944,6 +2106,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this-&gt;set_sprite(VRedFlare::mySprite);
 }
 
@@ -1951,6 +2114,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this-&gt;set_sprite(VOrangeFlare::mySprite);
 }
 
@@ -1958,6 +2122,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this-&gt;set_sprite(VYellowFlare::mySprite);
 }
 
@@ -1965,6 +2130,7 @@
 :
 VFlare(source, angle, initialVelocity, range, odamage, ofinalVelocity)
 {
+  STACKTRACE;
   this-&gt;set_sprite(VWhiteFlare::mySprite);
 }
 

Modified: trunk/source/other/vtarget.cpp
===================================================================
--- trunk/source/other/vtarget.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/other/vtarget.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -40,6 +40,7 @@
 			   double WeaponOffsetY, double WeaponAngle,
 			   double MaxRange,
 			   double DegTolerance, int LagSetting) {
+  STACKTRACE;
 	AimSys::SetupDefaults();
 	source = sourceP; target = targetP;
 	relativity = Relativity;
@@ -60,6 +61,7 @@
 
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP, double WeaponSpeed, double Relativity) {
+  STACKTRACE;
 	//not anti-aliased here
 	AimSys::SetupDefaults();
 	source = sourceP; target = targetP;
@@ -75,6 +77,7 @@
 }
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP, double WeaponSpeed) {
+  STACKTRACE;
 	//not anti-aliased here
 	AimSys::SetupDefaults();
     source = sourceP; target = targetP;
@@ -88,6 +91,7 @@
 }
 
 AimSys::AimSys(SpaceLocation* sourceP, SpaceLocation* targetP) {
+  STACKTRACE;
 	//not anti-aliased here
 	//use with caution -- weapon speed is taken to be the
 	//current ship speed.  Would work for the Tau Bomber.
@@ -102,7 +106,8 @@
   AimSys::CalcWeaponOffset();
 }
 
-void AimSys::SetupDefaults(void) { //sets up defaults
+void AimSys::SetupDefaults(void) {
+  STACKTRACE; //sets up defaults
 	relativity = 0.5;
 	source = NULL; target = NULL;
   nx1center = 0; ny1center = 0;
@@ -116,6 +121,7 @@
 }
 
 void AimSys::CalcWeaponOffset(void) {
+  STACKTRACE;
   
   double dx, dy;
 	gamma = CalcVectorAngle(0,0,-weaponOffsetY, weaponOffsetX);
@@ -130,12 +136,14 @@
 }
 
 void AimSys::CalcWeaponOffset(double xOff, double yOff) {
+  STACKTRACE;
   weaponOffsetX = xOff;
   weaponOffsetY = yOff;
   AimSys::CalcWeaponOffset();
 }
 
 void AimSys::SetSpaceLine(SpaceLine* SL) {
+  STACKTRACE;
   SL-&gt;pos.x = nx1;
   SL-&gt;pos.y = ny1;
   SL-&gt;angle = gamma+source-&gt;angle;
@@ -146,16 +154,19 @@
 
 
 double AimSys::RawDistance(double x1, double y1, double x2, double y2) {
+  STACKTRACE;
 	return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2 - y1));
 	//not anti-aliased here
 }
 
 double AimSys:: CalcVectorAngle(void) {
+  STACKTRACE;
 	return AimSys::CalcVectorAngle(nx1, ny1, nx2, ny2);
 }
 
 
 double AimSys:: CalcVectorAngle(double x1, double y1, double x2, double y2) {
+  STACKTRACE;
 	//angle of the line from source to target, in normal cartesian coordinates
 	//zero degrees is going straight up.
 	//the computer uses X+ across, Y+ down.
@@ -182,6 +193,7 @@
 }
 
 int AimSys::CalcTrialValues(void) {
+  STACKTRACE;
 	//HERE is where the anti-ailasing happens!
 	//all 8 wrap-around positions are tested, along with the non
 	//wrapped one.
@@ -229,26 +241,32 @@
 }
 
 double AimSys::getPursuitAngle() {
+  STACKTRACE;
 	return pursuitAngle;
 }
 
 double AimSys::getBestTrialAlpha() {
+  STACKTRACE;
 	return bestTrialAlpha;
 }
 
 double AimSys::getBestTrialTheta() {
+  STACKTRACE;
 	return bestTrialTheta;
 }
 
 double AimSys::getAngleOfShortestDistance() {
+  STACKTRACE;
   return bestTrialEpsilon;
 }
 
 void AimSys::setNewTarget(SpaceObject* newTarget) {
+  STACKTRACE;
 	target = newTarget;
 }
 
 void AimSys::Update(void) {
+  STACKTRACE;
 	if(source==NULL||target==NULL) return;
 	nx1center = source-&gt;pos.x; ny1center = source-&gt;pos.y; 
 	nx2 = target-&gt;pos.x; ny2 = target-&gt;pos.y;
@@ -265,6 +283,7 @@
 }
 
 double AimSys::absAngleDifference(double A1, double A2) {
+  STACKTRACE;
 	double x;
 	x = fabs(A2 - A1);
 	if(x&gt;180)
@@ -275,6 +294,7 @@
 
 
 int AimSys::shouldFireNow(void) {
+  STACKTRACE;
 	// at the moment, just checks for current angle
 	//within tolerance
 	//the quick and dirty answer
@@ -292,6 +312,7 @@
 }
 
 int AimSys::shouldTurnLeft(void) {
+  STACKTRACE;
 	int x1, x2;
 	x1 = iround(source-&gt;angle-weaponAngle);
 	x2 = iround(pursuitAngle);
@@ -304,6 +325,7 @@
 }
 
 int AimSys::shouldTurnRight(void) {
+  STACKTRACE;
 	int x1, x2;
 	x1 = iround(source-&gt;angle-weaponAngle);
 	x2 = iround(pursuitAngle);

Modified: trunk/source/sc1ships/shpandgu.cpp
===================================================================
--- trunk/source/sc1ships/shpandgu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpandgu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 AndrosynthGuardian::AndrosynthGuardian(Vector2 opos, double angle, ShipData *data, unsigned int code) :
   Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	weaponDamage       = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 1);
 	weaponArmour       = get_config_int(&quot;Weapon&quot;, &quot;Armour&quot;, 1);
 	weaponRange        = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 10));
@@ -59,6 +60,7 @@
 
 void AndrosynthGuardian::calculate()
 {
+  STACKTRACE;
 	Ship::calculate();
 	if(specialActive &amp;&amp; (batt == -1)) {
 		set_sprite(shipSprite);
@@ -74,6 +76,7 @@
 	}
 
 void AndrosynthGuardian::calculate_thrust() {
+  STACKTRACE;
 	if(specialActive) {
 		double dv;
 		if (bounce_status &gt; 0) {
@@ -94,6 +97,7 @@
 
 void AndrosynthGuardian::calculate_hotspots()
 {
+  STACKTRACE;
   if(specialActive)
     return;
   Ship::calculate_hotspots();
@@ -101,6 +105,7 @@
 
 void AndrosynthGuardian::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if (damage_factor &gt; 0) 
     {
       if (other-&gt;mass) 
@@ -139,6 +144,7 @@
 }
 
 int AndrosynthGuardian::activate_weapon() {
+  STACKTRACE;
   
   if(specialActive)
 	  return FALSE;
@@ -151,6 +157,7 @@
 
 int AndrosynthGuardian::activate_special() 
 {
+  STACKTRACE;
   if(specialActive)
     return(FALSE);
   
@@ -181,6 +188,7 @@
     osprite, ofcount, ofsize),
   courseFrames(0)
 {
+  STACKTRACE;
   explosionSprite     = data-&gt;spriteWeaponExplosion;
   explosionFrameCount = 6;
   explosionFrameSize  = 50;
@@ -188,6 +196,7 @@
 
 void AndrosynthBubble::calculate()
 {
+  STACKTRACE;
 	if (!(ship &amp;&amp; ship-&gt;exists()))
 	{
 		state = 0;

Modified: trunk/source/sc1ships/shparisk.cpp
===================================================================
--- trunk/source/sc1ships/shparisk.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shparisk.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -23,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 	specialSprite = data-&gt;spriteSpecial;
 
 	weaponColor  = get_config_int(&quot;Weapon&quot;, &quot;Color&quot;, 0);
@@ -36,6 +37,7 @@
 	}
 
 void ArilouSkiff::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (just_teleported &amp;&amp; other-&gt;mass) {
 		damage(this, 0, 999);
 		}
@@ -44,6 +46,7 @@
 	}
 
 int ArilouSkiff::activate_weapon() {
+  STACKTRACE;
 	SpaceObject *o = NULL;
 
 	double r = 99999;  
@@ -63,6 +66,7 @@
 	}
 
 int ArilouSkiff::activate_special() {
+  STACKTRACE;
 
 	game-&gt;add(new Animation(this, pos,
 			specialSprite, 0, 40, iround(specialFrames/40), DEPTH_HOTSPOTS-0.1));
@@ -80,6 +84,7 @@
 	}
 
 void ArilouSkiff::calculate() {
+  STACKTRACE;
 	just_teleported = 0;
 	Ship::calculate();
 
@@ -88,10 +93,12 @@
 		}
 	}
 
-void ArilouSkiff::calculate_gravity() {}
+void ArilouSkiff::calculate_gravity() {
+  STACKTRACE;}
 
 int ArilouSkiff::accelerate(SpaceLocation *source, double angle, double velocity, 
 		double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;
@@ -99,6 +106,7 @@
 
 int ArilouSkiff::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
 		double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;

Modified: trunk/source/sc1ships/shpchebr.cpp
===================================================================
--- trunk/source/sc1ships/shpchebr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpchebr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -53,6 +53,7 @@
 ChenjesuBroodhome::ChenjesuBroodhome(Vector2 opos, double angle, ShipData *data, unsigned int code) :
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	weaponDamage		= get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
 	shardRange			= scale_range(get_config_int(&quot;Weapon&quot;, &quot;ShardRange&quot;, 0));
 	shardDamage			= get_config_int(&quot;Weapon&quot;, &quot;ShardDamage&quot;, 0);
@@ -76,6 +77,7 @@
 
 int ChenjesuBroodhome::activate_weapon()
 {
+  STACKTRACE;
 	if(weaponFired)
 		return(FALSE);
 	weaponObject = new ChenjesuShot(Vector2(0.0, (size.y / 2.0)), angle,
@@ -87,6 +89,7 @@
 
 int ChenjesuBroodhome::activate_special()
 {
+  STACKTRACE;
 	if(specialNumDOGIs &gt;= MAX_DOGIS)
 		return(FALSE);
 	ChenjesuDOGI* DOGI; //added by Varith
@@ -102,6 +105,7 @@
 
 void ChenjesuBroodhome::calculate()
 {
+  STACKTRACE;
 	int i;
 
 	Ship::calculate();
@@ -130,6 +134,7 @@
 	int odamage, int oarmour, SpaceLocation *creator, SpaceSprite *osprite) :
 	Missile(creator, opos, oangle, ov, odamage, -1.0, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SPECIAL);
 	explosionSprite     = data-&gt;spriteWeaponExplosion;
 	explosionFrameCount = 20;
@@ -138,6 +143,7 @@
 
 void ChenjesuShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	Shot::inflict_damage(other);
 	if ((other-&gt;mass &gt; 0) &amp;&amp; !exists())
 		if (other-exists())
@@ -152,6 +158,7 @@
 
 void ChenjesuShot::animateExplosion()
 {
+  STACKTRACE;
 	return;
 }
 
@@ -161,6 +168,7 @@
 	AnimatedShot(oship, opos, ov, oangle, 0, -1.0, oarmour, oship, osprite, 64, 50),
 	sap_factor(fuel_sap), accel_rate(accel), num_dogis(onum_dogis)
 {
+  STACKTRACE;
 	layer = LAYER_SPECIAL;
 	set_depth(DEPTH_SPECIAL);
 	mass = omass;
@@ -170,6 +178,7 @@
 
 void ChenjesuDOGI::calculate()
 {
+  STACKTRACE;
 	AnimatedShot::calculate();
 
 	if (ship &amp;&amp; ship-&gt;exists()) {
@@ -195,6 +204,7 @@
 
 void ChenjesuDOGI::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   tw_sound.play_sound(data_full_path(data-&gt;sampleExtra[1]));
 
   if(sameTeam(other)) 
@@ -210,11 +220,13 @@
 
 void ChenjesuDOGI::death()
 {
+  STACKTRACE;
 	if (num_dogis) (*num_dogis)--;
 }
 
 void ChenjesuDOGI::ship_died()
 {
+  STACKTRACE;
 	num_dogis = NULL;
 	SpaceObject::ship_died();
 	state = 0;
@@ -223,12 +235,14 @@
 
 void ChenjesuDOGI::animateExplosion()
 {
+  STACKTRACE;
 	game-&gt;add(new Animation(this, pos,
 		data-&gt;spriteSpecialExplosion, 0, 20, 25, DEPTH_EXPLOSIONS));
 }
 
 void ChenjesuDOGI::soundExplosion()
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(data-&gt;sampleExtra[2]));
   tw_sound.play_sound(data_full_path(data-&gt;sampleExtra[2]));
   return;

Modified: trunk/source/sc1ships/shpearcr.cpp
===================================================================
--- trunk/source/sc1ships/shpearcr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpearcr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -32,6 +32,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -48,6 +49,7 @@
 }
 
 int EarthlingCruiser::activate_weapon() {
+  STACKTRACE;
 	game-&gt;add(new EarthlingMissile(
 		Vector2(0.0, (size.y * 1.0)), angle, weaponVelocity, weaponDamage, weaponRange,
 		weaponArmour, weaponTurnRate, this, data-&gt;spriteWeapon));
@@ -56,6 +58,7 @@
 
 int EarthlingCruiser::activate_special() 
 {
+  STACKTRACE;
   int fire = FALSE;
   SpaceObject *o;
   
@@ -90,6 +93,7 @@
   HomingMissile(oship, opos, oangle, ov, odamage, orange, oarmour, otrate, 
 		oship, osprite, oship-&gt;target)
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);
   explosionSprite     = data-&gt;spriteWeaponExplosion;
   explosionFrameCount = 10;

Modified: trunk/source/sc1ships/shpilwav.cpp
===================================================================
--- trunk/source/sc1ships/shpilwav.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpilwav.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
   weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -41,6 +42,7 @@
 	}
 
 int IlwrathAvenger::activate_weapon() {
+  STACKTRACE;
 	// note that target=0 is only set after this routine is called in ship::calculate
 	// so we need to check if it exists ...
 	if (cloak &amp;&amp; target &amp;&amp; target-&gt;exists()) {
@@ -60,6 +62,7 @@
 
 void IlwrathAvenger::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = FALSE;
 
   if(fire_special) {
@@ -89,12 +92,14 @@
 
 void IlwrathAvenger::calculate_hotspots()
 {
+  STACKTRACE;
   if(!cloak)
     Ship::calculate_hotspots();
 }
 
 void IlwrathAvenger::calculate()
 {
+  STACKTRACE;
   if((cloak) &amp;&amp; (cloak_frame &lt; 300))
     cloak_frame += frame_time;
   if((!cloak) &amp;&amp; (cloak_frame &gt; 0))
@@ -104,6 +109,7 @@
 }
 
 void IlwrathAvenger::animate(Frame *space) {
+  STACKTRACE;
 	if((cloak_frame &gt; 0) &amp;&amp; (cloak_frame &lt; 300))
 		sprite-&gt;animate_character( pos, sprite_index, 
 				pallete_color[cloak_color[cloak_frame / 100]], space);

Modified: trunk/source/sc1ships/shpkzedr.cpp
===================================================================
--- trunk/source/sc1ships/shpkzedr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpkzedr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -51,6 +51,7 @@
 	:
 	Ship(opos, angle, data, code) 
 	{
+  STACKTRACE;
 	weaponRange         = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponVelocity      = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
 	weaponDamage        = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -68,6 +69,7 @@
 	}
 
 int KzerZaDreadnought::activate_weapon() {
+  STACKTRACE;
 	game-&gt;add( new KzerZaMissile(
 			Vector2(0.0, (size.y / 2.0)), angle, weaponVelocity, weaponDamage, weaponRange,
 			weaponArmour, this, data-&gt;spriteWeapon) );
@@ -75,6 +77,7 @@
 	}
 
 int KzerZaDreadnought::activate_special() {
+  STACKTRACE;
 	if(crew &gt; 1) {
 		game-&gt;add( new KzerZaFighter(Vector2(-25.0, -50.0),
 				angle - PI*7.0/8 , specialVelocity, specialRange, specialArmour,
@@ -101,6 +104,7 @@
 	:
 	Missile(oship, opos, oangle, ov, odamage, orange, oarmour, oship,osprite) 
 	{
+  STACKTRACE;
 	explosionSprite     = data-&gt;spriteWeaponExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 50;
@@ -127,6 +131,7 @@
 
 void KzerZaFighter::calculate() 
 {
+  STACKTRACE;
   Missile::calculate();
 
   if (!(ship &amp;&amp; ship-&gt;exists()))
@@ -199,6 +204,7 @@
 
 int KzerZaFighter::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if (source-&gt;isPlanet()) 
     {
       state = 1;
@@ -210,6 +216,7 @@
 
 void KzerZaFighter::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if (other == ship) 
     {
       tw_sound.stop_sound(data_full_path(data-&gt;sampleExtra[1]));

Modified: trunk/source/sc1ships/shpmmrxf.cpp
===================================================================
--- trunk/source/sc1ships/shpmmrxf.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpmmrxf.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 	laser2(NULL),
 	laserSpark(0)
 	{
+  STACKTRACE;
 	form_data[T_FORM].speed_max       = speed_max;
 	form_data[T_FORM].accel_rate      = accel_rate;
 	form_data[T_FORM].turn_rate       = turn_rate;
@@ -78,6 +79,7 @@
 
 void MmrnmhrmXForm::calculate()
 {
+  STACKTRACE;
   if(laserSpark &gt; 0) {
     laserSpark-= frame_time;
     if((laserSpark &lt;= 0) &amp;&amp; (laserSpark &gt; -frame_time)) {
@@ -95,6 +97,7 @@
 
 int MmrnmhrmXForm::activate_weapon()
 {
+  STACKTRACE;
   if(form == T_FORM) {
     add(laser1 = new Laser(this, angle + laserAngle,
       pallete_color[laserColor], laserRange, laserDamage, weapon_rate, this,
@@ -117,6 +120,7 @@
 
 int MmrnmhrmXForm::activate_special()
 {
+  STACKTRACE;
 	form_data[form].speed_max       = speed_max;
 	form_data[form].accel_rate      = accel_rate;
 	form_data[form].turn_rate       = turn_rate;
@@ -141,6 +145,7 @@
 }
 
 double MmrnmhrmXForm::handle_speed_loss(SpaceLocation *source, double normal) {
+  STACKTRACE;
 	Ship::handle_speed_loss(source, normal);
 	if (normal) {
 		activate_special();

Modified: trunk/source/sc1ships/shpmycpo.cpp
===================================================================
--- trunk/source/sc1ships/shpmycpo.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpmycpo.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -41,6 +41,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
   weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -50,6 +51,7 @@
 
 int MyconPodship::activate_weapon()
 {
+  STACKTRACE;
   add(new MyconPlasma(Vector2(0.0, size.y),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponHome, this,
     data-&gt;spriteWeapon, 64));
@@ -58,6 +60,7 @@
 
 int MyconPodship::activate_special()
 {
+  STACKTRACE;
   if(crew &gt;= crew_max)
     return(FALSE);
   damage(this, 0, -4);
@@ -74,6 +77,7 @@
   frame_count(ofcount),
   max_damage(odamage)
 {
+  STACKTRACE;
 	spriteWeaponExplosion = data-&gt;spriteWeaponExplosion;
 	collide_flag_sameship |= bit(LAYER_SHIPS);
 	collide_flag_sameteam |= bit(LAYER_SHIPS);
@@ -81,6 +85,7 @@
 
 void MyconPlasma::calculate()
 {
+  STACKTRACE;
   HomingMissile::calculate();
 
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
@@ -89,6 +94,7 @@
 
 void MyconPlasma::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   SpaceObject::inflict_damage(other);
   //if (!other-&gt;isShot()) {
   if (other-&gt;isblockingweapons)
@@ -106,6 +112,7 @@
 }
 
 int MyconPlasma::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	double total = normal + direct;
 
 	if (total) {

Modified: trunk/source/sc1ships/shpshosc.cpp
===================================================================
--- trunk/source/sc1ships/shpshosc.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpshosc.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -23,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
   weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -39,6 +40,7 @@
 
 int ShofixtiScout::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, size.y / 2.0),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data-&gt;spriteWeapon));
@@ -47,6 +49,7 @@
 
 void ShofixtiScout::calculate_fire_special() 
 {
+  STACKTRACE;
   int gloryDamage;
   
   if(fire_special) 

Modified: trunk/source/sc1ships/shpspael.cpp
===================================================================
--- trunk/source/sc1ships/shpspael.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpspael.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -23,6 +23,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
 	weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -38,6 +39,7 @@
 
 int SpathiEluder::activate_weapon()
 {
+  STACKTRACE;
 	add(new Missile( this, Vector2(0.0, size.y / 2.0),
 		angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
 		this, data-&gt;spriteWeapon));
@@ -46,6 +48,7 @@
 
 int SpathiEluder::activate_special()
 {
+  STACKTRACE;
 	SpaceLocation *tmp = new HomingMissile( this, 
 		Vector2(0.0, -size.y / 1.5), angle + PI, specialVelocity, specialDamage, specialRange, 
 		specialArmour, specialTurnRate, this, data-&gt;spriteSpecial, target);

Modified: trunk/source/sc1ships/shpsyrpe.cpp
===================================================================
--- trunk/source/sc1ships/shpsyrpe.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpsyrpe.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -43,6 +43,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
 	weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -57,6 +58,7 @@
 
 int SyreenPenetrator::activate_weapon()
 {
+  STACKTRACE;
 	Missile *m;
 	m = new Missile(this, Vector2(0.0, size.y / 2.0 + 10),
 			angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
@@ -68,6 +70,7 @@
 }
 
 int SyreenPenetrator::activate_special() {
+  STACKTRACE;
 	double minDist;
 	minDist = specialRange + (size.x / 2.0);
 	int j;
@@ -112,6 +115,7 @@
   life(0),
   lifetime(oLifeTime)
 {
+  STACKTRACE;
 	collide_flag_sameship = ALL_LAYERS;
 	collide_flag_sameteam = ALL_LAYERS;
 	layer = LAYER_SPECIAL;
@@ -121,10 +125,12 @@
 }
 
 int CrewPod::sameTeam(SpaceLocation *other) {
+  STACKTRACE;
 	return true;
 	}
 
 void CrewPod::calculate() {
+  STACKTRACE;
 	frame_step += frame_time;
 	while (frame_step &gt;= frame_size) {
 		frame_step -= frame_size;
@@ -148,6 +154,7 @@
 
 void CrewPod::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if (other-&gt;isShip() &amp;&amp; other-&gt;damage_factor == 0) 
     {
       tw_sound.stop_sound(data_full_path(data-&gt;sampleExtra[0]));
@@ -159,6 +166,7 @@
 
 int CrewPod::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
 	state = 0;
 	return 0;
 }

Modified: trunk/source/sc1ships/shpumgdr.cpp
===================================================================
--- trunk/source/sc1ships/shpumgdr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpumgdr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -43,6 +43,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
   weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
   specialRate    = special_rate;
@@ -53,12 +54,14 @@
 }
 
 int UmgahDrone::activate_weapon() {
+  STACKTRACE;
   firing = true;
   return(TRUE);
 }
 
 int UmgahDrone::activate_special()
 {
+  STACKTRACE;
   special_rate = specialRate;
   vel = 0;
   pos -= (unit_vector(angle) * size.x * 2.0);
@@ -68,12 +71,14 @@
 
 void UmgahDrone::calculate_thrust()
 {
+  STACKTRACE;
   if(special_recharge &lt;= 0)
     Ship::calculate_thrust();
 }
 
 void UmgahDrone::calculate()
 {
+  STACKTRACE;
   if (fire_weapon)
     recharge_step = recharge_rate;
   else
@@ -87,6 +92,7 @@
   SpaceObject(oship, oship-&gt;normal_pos(), 0.0, osprite),
   dist(odist)
 {
+  STACKTRACE;
 	layer = LAYER_SHOTS;
 	set_depth(DEPTH_SHIPS - 0.1);
 
@@ -109,11 +115,13 @@
 }
 
 bool UmgahCone::change_owner(SpaceLocation *new_owner) {
+  STACKTRACE;
 	return false;
 	}
 
 void UmgahCone::calculate()
 {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	if(!(ship &amp;&amp; ship-&gt;exists()))
@@ -140,6 +148,7 @@
 
 void UmgahCone::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   switch (damage_type) {
     case 0: {
             residual_damage = damage * frame_time / 2.0;
@@ -168,6 +177,7 @@
 }
 
 int UmgahCone::canCollide(SpaceLocation* other) {
+  STACKTRACE;
 //  calc_base();
   if (umgahship &amp;&amp; umgahship-&gt;exists())
 	return (umgahship-&gt;firing &amp; !other-&gt;isPlanet());
@@ -176,6 +186,7 @@
 }
 
 void UmgahCone::animate(Frame* space) {
+  STACKTRACE;
 //  calc_base();
   if (!umgahship || !umgahship-&gt;exists() || !umgahship-&gt;firing) return;
   int si = sprite_index;

Modified: trunk/source/sc1ships/shpvuxin.cpp
===================================================================
--- trunk/source/sc1ships/shpvuxin.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpvuxin.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 	Ship(opos, angle, data, code)
 
 {
+  STACKTRACE;
   weaponColor  = get_config_int(&quot;Weapon&quot;, &quot;Color&quot;, 0);
   weaponRange  = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponDamage = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -47,6 +48,7 @@
 
 int VuxIntruder::activate_weapon()
 {
+  STACKTRACE;
   add(new Laser(this, angle,
     pallete_color[weaponColor], weaponRange, weaponDamage, weapon_rate,
     this, Vector2(size.x/11, (size.y / 2.07)), true));
@@ -55,6 +57,7 @@
 
 int VuxIntruder::activate_special()
 {
+  STACKTRACE;
   add(new VuxLimpet(Vector2(0, -size.y / 2.8),
     specialVelocity, specialSlowdown, specialRange, specialArmour, this,
     data-&gt;spriteSpecial, 100, 5));
@@ -68,6 +71,7 @@
     ofcount, ofsize),
   slowdown_factor(slowdown)
 {
+  STACKTRACE;
   if((ship-&gt;target) &amp;&amp; (!ship-&gt;target-&gt;isInvisible()))
     angle = trajectory_angle(ship-&gt;target);
   else
@@ -84,6 +88,7 @@
 
 void VuxLimpet::calculate()
 {
+  STACKTRACE;
 	if(!(ship &amp;&amp; ship-&gt;exists())) {
 		state = 0;
 		return;
@@ -98,6 +103,7 @@
 
 void VuxLimpet::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if(!other-&gt;isShip()) 
     {
       if (other-&gt;damage_factor || other-&gt;mass) state = 0;
@@ -142,6 +148,7 @@
 
 void VuxIntruder::relocate() 
 {
+  STACKTRACE;
   if ( control ) target = control-&gt;target; 
   if (target &amp;&amp; (distance(target) &gt; 500)) {
     pos = target-&gt;normal_pos() + (unit_vector(angle) * 125.0);
@@ -157,6 +164,7 @@
 
 void VuxIntruder::animate(Frame *space)
 {
+  STACKTRACE;
   
   double back_x=size.x/3.60, back_y=-size.y/2.33,
     frnt_x=size.x/5.55, frnt_y=+size.y/17.01,
@@ -215,10 +223,12 @@
 :
 Phaser(ship, opos, _n, ship, sprite, osprite_index, ocolors, onum_colors, ofsize, steps, step_size)
 {
+  STACKTRACE;
 	vuxship = ship;
 }
 
 void VuxPhaser::calculate() {
+  STACKTRACE;
 	Phaser::calculate();
 	if (!ship) return;
 	if( !(ship-&gt;attributes &amp; ATTRIB_INGAME )) vuxship-&gt;relocate();//((VuxIntruder*)ship)-&gt;relocate();
@@ -230,6 +240,7 @@
 	}
 
 SpaceLocation *VuxIntruder::get_ship_phaser() {
+  STACKTRACE;
 	return new VuxPhaser(
 			pos - unit_vector(angle) * PHASE_MAX * size.x,
 			unit_vector(angle) * PHASE_MAX * size.x,

Modified: trunk/source/sc1ships/shpyehte.cpp
===================================================================
--- trunk/source/sc1ships/shpyehte.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc1ships/shpyehte.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 	:
 	Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -37,6 +38,7 @@
 
 int YehatTerminator::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(-24.0, 14),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data-&gt;spriteWeapon));
@@ -48,12 +50,14 @@
 
 int YehatTerminator::activate_special()
 {
+  STACKTRACE;
   shieldFrames = (shieldFrames % frame_time) + specialFrames;
   return(TRUE);
 }
 
 void YehatTerminator::calculate()
 {
+  STACKTRACE;
    if(shieldFrames &gt; 0)
      shieldFrames-= frame_time;
    Ship::calculate();
@@ -61,6 +65,7 @@
 
 void YehatTerminator::animate(Frame *space)
 {
+  STACKTRACE;
   if(shieldFrames &gt; 0)
     data-&gt;spriteSpecial-&gt;animate( pos, sprite_index, space);
   else
@@ -68,6 +73,7 @@
 }
 
 int YehatTerminator::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	if (shieldFrames &gt; 0) normal = 0;
 	return Ship::handle_damage(source, normal, direct);
 	}

Modified: trunk/source/sc2ships/shpchmav.cpp
===================================================================
--- trunk/source/sc2ships/shpchmav.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpchmav.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -66,6 +66,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code) 
 	{
+  STACKTRACE;
 
 	weaponRange  = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponDamage = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -86,6 +87,7 @@
 
 void ChmmrAvatar::calculate()
 {
+  STACKTRACE;
 	Ship::calculate();
 	
 	if ((uninterrupted_fire) &amp;&amp; ((!fire_weapon) || weapon_low))
@@ -101,6 +103,7 @@
 
 int ChmmrAvatar::activate_weapon()
 {
+  STACKTRACE;
 	add(new ChmmrLaser(angle, weaponRange, weaponDamage, weapon_rate, this, Vector2(0.0, 25.0) ));
 	if (tw_random(150) &lt; frame_time) {
 		add(new Animation(this, 
@@ -122,6 +125,7 @@
 
 int ChmmrAvatar::activate_special()
 {
+  STACKTRACE;
 	if (target &amp;&amp; target-&gt;exists() &amp;&amp; (!target-&gt;isInvisible()) &amp;&amp; (target-&gt;mass &gt; 0) &amp;&amp; (distance(target) &lt; specialRange)) {
 		add(new ChmmrBeam(this, special_rate));
 		target-&gt;accelerate(this, target-&gt;trajectory_angle(this), specialForce / target-&gt;mass, MAX_SPEED);
@@ -132,6 +136,7 @@
 
 void ChmmrAvatar::materialize()
 {
+  STACKTRACE;
 	Ship::materialize();
 	add(new ChmmrZapSat(0.0, extraRange,
 		extraDamage, extraFrames, extraRechargeRate, extraColor, extraArmour, this,
@@ -150,6 +155,7 @@
 	Laser(opos, langle, pallete_color[hot_color[random() % HOT_COLORS]], lrange,
 	ldamage, lfcount, opos, rel_pos, true)
 {
+  STACKTRACE;
 }
 
 ChmmrBeam::ChmmrBeam(Ship *oship, int oframes) :
@@ -160,6 +166,7 @@
 	ship(oship),
 	target(oship-&gt;target)
 {
+  STACKTRACE;
 	set_depth(DEPTH_HOTSPOTS);
 	collide_flag_anyone = 0;
 	if(!(ship &amp;&amp; ship-&gt;exists())) {
@@ -176,6 +183,7 @@
 
 void ChmmrBeam::calculate()
 {
+  STACKTRACE;
 
 	SpaceLocation::calculate();
 
@@ -201,6 +209,7 @@
 
 void ChmmrBeam::animate(Frame *space)
 {
+  STACKTRACE;
 	const int beam_color[5] = { 80, 81, 82, 83, 84 };
 	int i;//, old_trans;
 	double length = target-&gt;get_vel().length() + (target-&gt;get_size().x / 4.0);
@@ -235,6 +244,7 @@
   lColor(ocolor),
   armour(oarmour)
 {
+  STACKTRACE;
 	layer = LAYER_SPECIAL;
 	set_depth(DEPTH_SPECIAL);
 	collide_flag_anyone = ALL_LAYERS &amp;~ bit(LAYER_CBODIES);
@@ -254,6 +264,7 @@
 }
 
 void ChmmrZapSat::calculate() {
+  STACKTRACE;
 
 	SpaceObject::calculate();
 
@@ -298,11 +309,13 @@
 	return;
 	}
 int ChmmrZapSat::canCollide(SpaceLocation *other) {
+  STACKTRACE;
 	if (!other-&gt;damage_factor) return false;
 	return SpaceObject::canCollide(other);
 	}
 
 int ChmmrZapSat::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	int total = iround(normal + direct);
 	if (total) {
 		armour -= total;

Modified: trunk/source/sc2ships/shpdruma.cpp
===================================================================
--- trunk/source/sc2ships/shpdruma.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpdruma.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -36,6 +36,7 @@
 	ShipData *shipData, unsigned int code)
 	:
 	Ship(opos, shipAngle, shipData, code) {
+  STACKTRACE;
 
   weaponRange         = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity      = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -46,6 +47,7 @@
 
 
 int DruugeMauler::activate_weapon() {
+  STACKTRACE;
 	accelerate (this, angle + PI, weaponDriftVelocity / mass, MAX_SPEED);
 	add(new DruugeMissile(
 			Vector2(0.0, (get_size().y /*height()*/ / 2.0)), angle, weaponVelocity, weaponDamage,
@@ -56,6 +58,7 @@
 
 
 void DruugeMauler::calculate_fire_special() {
+  STACKTRACE;
   if((fire_special) &amp;&amp; (crew &gt; 1) &amp;&amp; (batt &lt; batt_max) &amp;&amp;
     (special_recharge &lt;= 0)) {
 
@@ -77,6 +80,7 @@
   Missile(oship, opos, oangle, ov, odamage, orange, oarmour, oship, osprite),
   kick(weaponDriftVelocity)
 {
+  STACKTRACE;
   explosionSprite     = data-&gt;spriteWeaponExplosion;
   explosionFrameCount = 5;
   explosionFrameSize  = 50;

Modified: trunk/source/sc2ships/shpkohma.cpp
===================================================================
--- trunk/source/sc2ships/shpkohma.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpkohma.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -55,6 +55,7 @@
 };
 
 void KohrAhFRIED::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if ((other-&gt;getID() &amp;~ SPACE_MASK) == CHMMR_SPEC) other-&gt;state = 0;
 	Shot::inflict_damage(other);
 	return;
@@ -64,6 +65,7 @@
 	ShipData *shipData, unsigned int code)
 	:
 	Ship(opos, shipAngle, shipData, code) {
+  STACKTRACE;
 	weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
 	weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -85,6 +87,7 @@
 	}
 
 int KohrAhMarauder::activate_weapon() {
+  STACKTRACE;
 	if (weaponFired) return(FALSE);
 	if (numblades == maxblades) {
 		weaponObject[0]-&gt;state = 0;
@@ -104,6 +107,7 @@
 	}
 
 int KohrAhMarauder::activate_special() {
+  STACKTRACE;
 	int i;
 	for(i = 0; i &lt; 16; i++) {
 		add(new KohrAhFRIED(
@@ -114,6 +118,7 @@
 	}
 
 void KohrAhMarauder::calculate() {
+  STACKTRACE;
 	Ship::calculate();
 	
 	if (!fire_weapon) {
@@ -145,12 +150,14 @@
   passive(FALSE),
   passiveRange(orange)
 {
+  STACKTRACE;
   explosionSprite     = data-&gt;spriteWeaponExplosion;
   explosionFrameCount = 20;
   explosionFrameSize  = 40;
 }
 
 void KohrAhBlade::calculate() {
+  STACKTRACE;
 	SpaceObject *o, *t = NULL;
 	double oldrange = 999999;
 
@@ -185,12 +192,14 @@
 
 void KohrAhBlade::animateExplosion()
 {
+  STACKTRACE;
   add(new KohrAhBladeDecay(this, pos,
     vel, explosionSprite, explosionFrameCount, explosionFrameSize));
 }
 
 void KohrAhBlade::disengage()
 {
+  STACKTRACE;
   passive = TRUE;
 }
 
@@ -198,6 +207,7 @@
   SpaceSprite *osprite, int ofcount, int ofsize) :
   Animation(creator, opos, osprite, 0, ofcount, ofsize, DEPTH_EXPLOSIONS)
 {
+  STACKTRACE;
 //  vx = ovx / 2;
 //  vy = ovy / 2;
   vel = 0.5 * ovel;
@@ -209,12 +219,14 @@
   Shot(oship, Vector2(0.0, 0.0), oangle, ov, odamage, orange, oarmour, oship, osprite, 1.0),
   frame_count(ofcount)
 {
+  STACKTRACE;
 //  x += cos(angle) * 50.0;
 //  y += sin(angle) * 50.0;
   pos += 50.0 * unit_vector(angle);
 }
 
 void KohrAhFRIED::calculate() {
+  STACKTRACE;
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
   Shot::calculate();
 }

Modified: trunk/source/sc2ships/shpmeltr.cpp
===================================================================
--- trunk/source/sc2ships/shpmeltr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpmeltr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -75,6 +75,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponRangeUp  = scale_range(get_config_float(&quot;Weapon&quot;, &quot;RangeUp&quot;, 0));
@@ -91,6 +92,7 @@
 
 void MelnormeTrader::calculate()
 {
+  STACKTRACE;
   Ship::calculate();
   if (weaponObject) {
     if (!weaponObject-&gt;exists()) weaponObject = NULL;
@@ -100,6 +102,7 @@
 
 int MelnormeTrader::activate_weapon()
 {
+  STACKTRACE;
   if(weaponObject)
     return(FALSE);
   add(weaponObject = new MelnormeShot(
@@ -109,6 +112,7 @@
 }
 
 int MelnormeTrader::activate_special() {
+  STACKTRACE;
   add( new MelnormeSpecial(
     Vector2(0.0, get_size().y /*(height()*/ / 2.0), angle, specialVelocity, specialFrames,
     specialRange, specialArmour, this, data-&gt;spriteSpecial, 20, 50));
@@ -128,7 +132,8 @@
   charge_phase(0),
   released(FALSE),
 	RangeUp(rangeup)
-{  
+{
+  STACKTRACE;  
 //  vx = ship-&gt;get_vx();
 //  vy = ship-&gt;get_vy();
   vel = ship-&gt;get_vel();
@@ -137,6 +142,7 @@
 
 void MelnormeShot::calculate() 
 {
+  STACKTRACE;
   if(released) 
     {
       Shot::calculate();
@@ -191,6 +197,7 @@
 
 void MelnormeShot::animateExplosion()
 {
+  STACKTRACE;
   add( new Animation(this, pos,
     data-&gt;spriteWeaponExplosion, (charge_phase * 20), 20, 25, 
     DEPTH_EXPLOSIONS));
@@ -198,6 +205,7 @@
 
 int MelnormeShot::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int old = iround(armour);
   Shot::handle_damage(source, normal, direct);
   if (!released &amp;&amp; (armour &gt; 0)) armour = old;
@@ -206,6 +214,7 @@
 
 void MelnormeShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	if (!other-&gt;exists()) return;
 	damage(other, damage_factor);
 
@@ -230,11 +239,13 @@
   frame_size(ofsize),
   frame_count(ofcount)
 {
+  STACKTRACE;
 	collide_flag_anyone = 0;
 	set_depth(DEPTH_EXPLOSIONS);
 }
 
 void MelnormeDisable::calculate() {
+  STACKTRACE;
 	frame_step+= frame_time;
 	while (frame_step &gt;= frame_size) {
 		frame_step -= frame_size;
@@ -266,12 +277,15 @@
   disableFrames(oframes),
   disableSprite(data-&gt;spriteExtra)
 {
+  STACKTRACE;
 	collide_flag_anyone = bit(LAYER_SHIPS);
 }
 
-void MelnormeSpecial::animateExplosion() {}
+void MelnormeSpecial::animateExplosion() {
+  STACKTRACE;}
 
 void MelnormeSpecial::inflict_damage(SpaceObject *other) {
+  STACKTRACE;
 	if (other-&gt;isShip()) add(new MelnormeDisable( ship, 
 			(Ship *)(other), disableSprite, 20, 50, disableFrames));
 	state = 0;

Modified: trunk/source/sc2ships/shporzne.cpp
===================================================================
--- trunk/source/sc2ships/shporzne.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shporzne.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -58,6 +58,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   int i;
 
 	absorption = 0;
@@ -91,18 +92,21 @@
 
 void OrzNemesis::calculate_turn_left()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_left();
 }
 
 void OrzNemesis::calculate_turn_right()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_right();
 }
 
 int OrzNemesis::activate_weapon()
 {
+  STACKTRACE;
   if(fire_special)
     return(FALSE);
   add(new OrzMissile(
@@ -116,6 +120,7 @@
 
 int OrzNemesis::activate_special()
 {
+  STACKTRACE;
   if(turn_left &amp;&amp; (recoil&lt;=0))
     turret_turn_step -= frame_time * turret_turn_rate;
   if(turn_right &amp;&amp; (recoil&lt;=0))
@@ -151,6 +156,7 @@
 
 void OrzNemesis::calculate()
 {
+  STACKTRACE;
   int i;
 
   for(i = 0; i &lt; MAX_MARINES; i++)
@@ -164,6 +170,7 @@
 
 void OrzNemesis::animate(Frame *space)
 {
+  STACKTRACE;
 	double rec;
 	int turret_index;
 	/*
@@ -193,6 +200,7 @@
   Missile(oship, Vector2(0.0, 0.0), oangle, ov, odamage, orange, oarmour, oship,
     osprite)
 {
+  STACKTRACE;
 //  x += cos(angle) * 30.0;
 //  y += sin(angle) * 30.0;
   pos += 30.0 * unit_vector(angle);
@@ -219,6 +227,7 @@
   slot(oSlot),
   damage_frame(-1)
 {
+  STACKTRACE;
 		layer = LAYER_SPECIAL;
 		set_depth(DEPTH_SPECIAL);
         mass = 0.001;
@@ -230,6 +239,7 @@
 
 void OrzMarine::calculate() 
 {
+  STACKTRACE;
   int    chance;
 
   if (!(orzship &amp;&amp; orzship-&gt;exists()))
@@ -365,11 +375,13 @@
 
 void OrzMarine::animate(Frame *space)
 {
+  STACKTRACE;
   if (!invading) SpaceObject::animate(space);
 }
 
 void OrzMarine::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   if (other-&gt;isShip() &amp;&amp; (!returning) &amp;&amp; (!other-&gt;sameTeam(this)) &amp;&amp; (!other-&gt;isProtected()))
     {
       invading = (Ship *) other;
@@ -396,6 +408,7 @@
 
 int OrzMarine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int total = iround(normal + direct);
   armour -= total;
   if(armour &lt;= 0)

Modified: trunk/source/sc2ships/shppkufu.cpp
===================================================================
--- trunk/source/sc2ships/shppkufu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shppkufu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -30,6 +30,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -42,6 +43,7 @@
 
 int PkunkFury::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   int r = iround(normal + direct);
   crew -= r;
   if (crew &gt; 0) 
@@ -146,6 +148,7 @@
 
 int PkunkFury::activate_weapon()
 {
+  STACKTRACE;
   add(new AnimatedShot(this, 
     Vector2(0.0, (get_size().y / 2.0)), angle, weaponVelocity, weaponDamage, weaponRange,
     weaponArmour, this, data-&gt;spriteWeapon, 10, 1, 1.0));
@@ -161,6 +164,7 @@
 
 void PkunkFury::calculate_fire_special()
 {
+  STACKTRACE;
   if(fire_special) 
     {
       if((special_recharge &gt; 0) || (batt &gt;= batt_max))

Modified: trunk/source/sc2ships/shpslypr.cpp
===================================================================
--- trunk/source/sc2ships/shpslypr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpslypr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -25,6 +25,7 @@
 
 int SlylandroProbe::accelerate_gravwhip(SpaceLocation *source, double angle, double velocity, 
 										 double max_speed) {
+  STACKTRACE;
 	if (source == this) 
 		return Ship::accelerate(source, angle, velocity, max_speed);
 	return false;
@@ -67,6 +68,7 @@
 thrustActive(FALSE),
 thrustForward(TRUE)
 {
+  STACKTRACE;
 	sprite_index2 = random() &amp; 63;
 	segment_length = get_config_int(&quot;Weapon&quot;, &quot;SegmentLength&quot;,0);
 	segment_dispersion = get_config_int(&quot;Weapon&quot;, &quot;SegmentLengthDispersion&quot;,0);
@@ -86,12 +88,14 @@
 
 RGB SlylandroProbe::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {64,64,64};
 	return c;
 }
 
 void SlylandroProbe::calculate_turn_left()
 {
+  STACKTRACE;
 	if ( turn_left )
 	{
 		if (!last_turn_left)
@@ -110,6 +114,7 @@
 
 void SlylandroProbe::calculate_turn_right()
 {
+  STACKTRACE;
 	if ( turn_right )
 	{
 	if (!last_turn_right)
@@ -129,6 +134,7 @@
 
 void SlylandroProbe::calculate()
 {
+  STACKTRACE;
   if (!(SlyLaser &amp;&amp; SlyLaser-&gt;exists()) )
     SlyLaser = 0;
 
@@ -177,11 +183,14 @@
 }
 
 void SlylandroProbe::calculate_hotspots() {
+  STACKTRACE;
 }
 void SlylandroProbe::calculate_fire_special() {
+  STACKTRACE;
 	return;
 }
 void SlylandroProbe::calculate_thrust() {
+  STACKTRACE;
 	if (thrust &amp;&amp; !thrustActive) {
 		angle = angle + PI;
 		if (angle &gt; PI2) angle -= PI2;
@@ -194,7 +203,8 @@
 }
 
 int SlylandroProbe::activate_weapon()
-{	
+{
+  STACKTRACE;	
 	SpaceLocation *t = NULL;
 	double r = 99999;
 	int i;
@@ -220,6 +230,7 @@
 
 SlylandroLaserNew::SlylandroLaserNew(SpaceLocation *lroot, SpaceLocation *ltarget)
 {
+  STACKTRACE;
 	
 	max_length = 400.0;
 	existtime = 1200.0;		// in milliseconds ?
@@ -245,6 +256,7 @@
 
 void SlylandroLaserNew::calculate()
 {
+  STACKTRACE;
 	lifetime += frame_time;
 
 	if ( lifetime &gt; existtime || !(mother &amp;&amp; mother-&gt;exists()) )
@@ -452,6 +464,7 @@
 
 void SlylandroLaserNew::animate(Frame *frame)
 {
+  STACKTRACE;
 	int i, iline;
 	
 	if ( !(mother &amp;&amp; mother-&gt;exists()) )

Modified: trunk/source/sc2ships/shpsupbl.cpp
===================================================================
--- trunk/source/sc2ships/shpsupbl.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpsupbl.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,6 +24,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -33,6 +34,7 @@
 
 void SupoxBlade::calculate_thrust()
 {
+  STACKTRACE;
 
   if(thrust || ((fire_special) &amp;&amp; (turn_left || turn_right || thrust))) {
     if((fire_special) &amp;&amp; (turn_left)) {
@@ -53,31 +55,36 @@
 
 void SupoxBlade::calculate_turn_left()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_left();
 }
 
 void SupoxBlade::calculate_turn_right()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_turn_right();
 }
 
 void SupoxBlade::calculate_hotspots()
 {
+  STACKTRACE;
   if(!fire_special)
     Ship::calculate_hotspots();
 }
 
 int SupoxBlade::activate_weapon()
 {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, 0.5*get_size().y / 2.0),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data-&gt;spriteWeapon));
   return(TRUE);
 }
 
-void SupoxBlade::calculate_fire_special() {}
+void SupoxBlade::calculate_fire_special() {
+  STACKTRACE;}
 
 
 

Modified: trunk/source/sc2ships/shpthrto.cpp
===================================================================
--- trunk/source/sc2ships/shpthrto.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpthrto.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -35,6 +35,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -47,6 +48,7 @@
 }
 
 int ThraddashTorch::activate_weapon() {
+  STACKTRACE;
   add(new Missile(this, Vector2(0.0, 0.5*get_size().y),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data-&gt;spriteWeapon));
@@ -54,6 +56,7 @@
 }
 
 int ThraddashTorch::activate_special() {
+  STACKTRACE;
 	accelerate(this, angle, specialThrust, MAX_SPEED);
   add(new ThraddashFlame(
 //    x ,//- cos(angle) * (width() / 2.0),
@@ -65,6 +68,7 @@
 
 void ThraddashTorch::calculate_thrust()
 {
+  STACKTRACE;
 	if(special_recharge &lt;= 0) Ship::calculate_thrust();
 }
 
@@ -73,6 +77,7 @@
   Animation(oship, opos, osprite, 0, ofcount, ofsize, DEPTH_SHOTS),
   armour(oarmour)
 {
+  STACKTRACE;
 	  layer = LAYER_SHOTS;
 	collide_flag_anyone = ALL_LAYERS;
 	collide_flag_sameteam = ALL_LAYERS;
@@ -89,10 +94,12 @@
 
 void ThraddashFlame::calculate()
 {
+  STACKTRACE;
 	Animation::calculate();
 }
 
 int ThraddashFlame::handle_damage(SpaceLocation *source, double normal, double direct) {
+  STACKTRACE;
 	int total = iround(normal + direct);
 	armour -= total;
 

Modified: trunk/source/sc2ships/shputwju.cpp
===================================================================
--- trunk/source/sc2ships/shputwju.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shputwju.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -26,6 +26,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -36,6 +37,7 @@
 
 void UtwigJugger::calculate()
 {
+  STACKTRACE;
         Ship::calculate();
         if (!fire_special)
                 special_recharge = 0;
@@ -43,6 +45,7 @@
 
 void UtwigJugger::calculate_fire_weapon()
 {
+  STACKTRACE;
   weapon_low = FALSE;
 
   if(fire_weapon) {
@@ -78,6 +81,7 @@
 
 void UtwigJugger::animate(Frame *space) 
 {
+  STACKTRACE;
   if (special_recharge &gt; 0) 
     {
       sprite-&gt;animate_character(pos, sprite_index, 
@@ -90,6 +94,7 @@
 
 int UtwigJugger::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
   if (special_recharge &gt; 0) 
     {
       batt += normal;

Modified: trunk/source/sc2ships/shpzfpst.cpp
===================================================================
--- trunk/source/sc2ships/shpzfpst.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/sc2ships/shpzfpst.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -55,6 +55,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -65,6 +66,7 @@
 }
 
 int ZoqFotPikStinger::activate_weapon() {
+  STACKTRACE;
   add(new ZoqFotPikShot(
     Vector2(0.0, 0.5*get_size().y), angle + ANGLE_RATIO * random(-10.0, 10.0),
     weaponVelocity, weaponDamage, weaponRange, weaponArmour, this,
@@ -74,6 +76,7 @@
 
 int ZoqFotPikStinger::activate_special()
 {
+  STACKTRACE;
   add(new ZoqFotPikTongue(
     39, specialDamage, this, data-&gt;spriteSpecial, 6, 50));
   return(TRUE);
@@ -85,10 +88,12 @@
   Shot(oship, opos, oangle, ov, odamage, orange, oarmour, oship, osprite),
   frame_count(num_frames)
 {
+  STACKTRACE;
 }
 
 void ZoqFotPikShot::calculate()
 {
+  STACKTRACE;
   Shot::calculate();
   sprite_index = (int)((d / range) * (double)(frame_count - 1));
 }
@@ -105,6 +110,7 @@
   frame_count(ofcount),
   frame_step(0)
 {
+  STACKTRACE;
   layer = LAYER_SHOTS;
   set_depth(DEPTH_SHOTS);
   damage_factor = abs(lick_factor);
@@ -121,6 +127,7 @@
 
 void ZoqFotPikTongue::calculate()
 {
+  STACKTRACE;
   int current_frame = frame;
 
   if (!(ship &amp;&amp; ship-&gt;exists()))
@@ -153,6 +160,7 @@
 
 void ZoqFotPikTongue::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   SpaceObject::inflict_damage(other); 
   damage_factor = 0;
 

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/scp.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -60,6 +60,7 @@
 
 std::string tw_version() 
 {
+  STACKTRACE;
   std::string tw_version_string;
 	
   tw_version_string += std::string(APPLICATION_NAME) + &quot; &quot;  + std::string(TW_MAJOR_VERSION) 
@@ -121,6 +122,7 @@
 
 Log *new_log (int logtype) 
 {
+  STACKTRACE;
   union 
   { 
     Log *log; 
@@ -153,6 +155,7 @@
 
 char *detect_gametype( Log *_log ) 
 {
+  STACKTRACE;
   int ltype;
   _log-&gt;unbuffer(Game::channel_init, &amp;ltype, sizeof(int));
   ltype = intel_ordering(ltype);
@@ -186,6 +189,7 @@
 */
 void prepareTitleScreenAssets() 
 {
+  STACKTRACE;
   titleMusic = data_full_path(&quot;music/Robeter-Space-Gods-Loop.ogg&quot;);
   tw_sound.play_music(titleMusic);
 
@@ -197,60 +201,36 @@
   titlePic = load_bitmap(data_full_path(&quot;images/scptitle.jpg&quot;).c_str(), NULL);
 }
 
-/*! \brief clears the screen, and displays a loading message to the user.
-*/
-void showLoadingScreen() {
+/// clears the screen, and displays a loading message to the user.
+void showLoadingScreen() 
+{
   STACKTRACE;
-
-  static BITMAP * logo = NULL;
-  static int depth = bitmap_color_depth(screen);
   
+  std::vector&lt;std::string&gt; waitpics;
+  waitpics.push_back(data_full_path(&quot;images/bspab.jpg&quot;));
+  waitpics.push_back(data_full_path(&quot;images/stangrop.jpg&quot;));
+  
   acquire_screen(); 
   clear_to_color(screen, 0);
-  
-  if (NULL == logo || bitmap_color_depth(screen) != depth) 
-    {
-      depth = bitmap_color_depth(screen);
-      
-      BITMAP * temp = load_bitmap(data_full_path(&quot;images/logo.bmp&quot;).c_str(),NULL);
-      logo = create_bitmap(temp-&gt;w, temp-&gt;h);
-      blit(temp, logo, 0,0, 0,0, temp-&gt;w, temp-&gt;h);
-      destroy_bitmap(temp);
-    }
-  
-  if (logo != NULL ) {
-    if (screen-&gt;w/2 &gt;= logo-&gt;w) {
-      draw_sprite(screen, logo, screen-&gt;w/2 - logo-&gt;w/2, screen-&gt;h/2 - logo-&gt;h/2);
-    }
-    else {
-      float ratio = logo-&gt;w / logo-&gt;h;
-      
-      int h = screen-&gt;h/4;
-      int w = iround(ratio * h);                
-      
-      stretch_blit(logo, screen, 
-		   0,0, 
-		   logo-&gt;w, logo-&gt;h,
-		   screen-&gt;w/2 - w/2, screen-&gt;h/2 - h/2,
-		   w, h);
-    }
-  }
+ 
+  int pic = rand()%waitpics.size();
 
-  const char * loadString = &quot;Loading...&quot;;
-  textout_right(screen, font, loadString, 
-		screen-&gt;w - 1*text_length(font, loadString), screen-&gt;h - 4*text_height(font), 
-		palette_color[15]);
+  BITMAP * temp = load_bitmap(waitpics[pic].c_str(), NULL);
+  stretch_blit(temp, screen, 0, 0, temp-&gt;w, temp-&gt;h, 0, 0, screen-&gt;w, screen-&gt;h);
+  destroy_bitmap(temp);
   release_screen();
 }
 
 int is_escape_pressed() 
 {
+  STACKTRACE;
   poll_keyboard();
   return key[KEY_ESC];
 }
 
 void play_game(const char *_gametype_name, Log *_log) 
 {
+  STACKTRACE;
   char gametype_name[1024];
   char *c;
   Game *new_game = NULL;
@@ -357,7 +337,9 @@
 int *player_config = NULL;
 int *player_team = NULL;
 
-Control *load_player(int i) {STACKTRACE
+Control *load_player(int i) 
+{
+  STACKTRACE;
 	char tmp[32];
 	Control *r = NULL;
 
@@ -371,7 +353,8 @@
 }
 
 
-class MainMenu : public BaseClass {
+class MainMenu : public BaseClass 
+{
 	public:
 	virtual void _event(Event * e);
 	virtual void preinit();
@@ -384,99 +367,117 @@
 	VideoWindow *window;
 } mainmenu;
 
-void MainMenu::_event(Event *e) {
+void MainMenu::_event(Event *e) 
+{
   STACKTRACE;
+		   
 	if (e-&gt;type == Event::VIDEO) {
 		if (e-&gt;subtype == VideoEvent::REDRAW) if (state &amp; 1) showTitle();
 	}
 }
 
-void MainMenu::enable() {STACKTRACE
+void MainMenu::enable() 
+{
+  STACKTRACE;
+		   
 	if (!(state &amp; 2)) window-&gt;add_callback(this);
 	state |= 3;
 }
 
-void MainMenu::disable() {STACKTRACE
-	state &amp;=~ 1;
+void MainMenu::disable() 
+{
+  STACKTRACE;
+		   
+  state &amp;=~ 1;
 }
 
-void MainMenu::preinit() {
-	window = NULL;
-	state = 0;
+void MainMenu::preinit() 
+{
+  STACKTRACE; 
+  window = NULL;
+  state = 0;
 }
 
-void MainMenu::init(VideoWindow *parent) {
-	if (window) window-&gt;init(parent);
-	else {
+void MainMenu::init(VideoWindow *parent) 
+{
+  STACKTRACE; 
+  if (window) window-&gt;init(parent);
+  else {
 		window = new VideoWindow();
 		window-&gt;preinit();
 		window-&gt;init(parent);
 	}
 }
 
-void MainMenu::deinit() {
-	STACKTRACE
-	if (state &amp; 2) {
-		window-&gt;remove_callback(this);
-		window-&gt;deinit();
-		delete window;
-		window = NULL;
-	}
+void MainMenu::deinit() 
+{
+  STACKTRACE;   
+		   
+  if (state &amp; 2) 
+    {
+      window-&gt;remove_callback(this);
+      window-&gt;deinit();
+      delete window;
+      window = NULL;
+    }
 }
 
-void MainMenu::doit() {STACKTRACE
-	int i;
-	char tmp[32];
-
-	tw_set_config_file(&quot;scp.ini&quot;);
-	if (!player_type) {		
-		MAX_PLAYERS        = get_config_int(&quot;Limits&quot;, &quot;MaxPlayers&quot;, 12);
-		MAX_CONFIGURATIONS = get_config_int(&quot;Limits&quot;, &quot;MaxConfigurations&quot;, 4);
-		MAX_TEAMS          = get_config_int(&quot;Limits&quot;, &quot;MaxTeams&quot;, 6);
-		player_type = new char*[MAX_PLAYERS];
-		player_config = new int[MAX_PLAYERS];
-		player_team   = new int[MAX_PLAYERS];
-	}
-	for (i = 0; i &lt; MAX_PLAYERS; i += 1) {
-		sprintf(tmp, &quot;Player%d&quot;, i+1);
-		player_type[i] = strdup(get_config_string(tmp, &quot;Type&quot;, &quot;Human&quot;));
-		player_config[i] = get_config_int (tmp, &quot;Config&quot;, i % MAX_CONFIGURATIONS);
-		player_team[i] = get_config_int (tmp, &quot;Team&quot;, 0);
-	}
-
-    prepareTitleScreenAssets();
-	showTitle();
-	enable();
-
-	int mainRet;
-	do {
-		//mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
-		mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
-		switch (mainRet) {
-			case MAIN_DIALOG_MELEE:
-				disable();
-				play_game(&quot;Melee&quot;);
-				enable();
-				break;
-			case MAIN_DIALOG_MELEE_EXTENDED:
-				disable();
-				extended_menu();
-				enable();
-				break;
-			case MAIN_DIALOG_OPTIONS:
-				showTitle();
-				options_menu(NULL);
-				break;
-			case MAIN_DIALOG_HELP:
-				show_file(data_full_path(&quot;ingame.txt&quot;).c_str());
-				break;
-			case MAIN_DIALOG_TEAMS:
-				change_teams();
-				showTitle();
-				break;
-		}
-	} while((mainRet != MAIN_DIALOG_EXIT) &amp;&amp; (mainRet != -1));
-
+void MainMenu::doit() 
+{
+  STACKTRACE;
+		   
+  int i;
+  char tmp[32];
+  
+  tw_set_config_file(&quot;scp.ini&quot;);
+  if (!player_type) {		
+    MAX_PLAYERS        = get_config_int(&quot;Limits&quot;, &quot;MaxPlayers&quot;, 12);
+    MAX_CONFIGURATIONS = get_config_int(&quot;Limits&quot;, &quot;MaxConfigurations&quot;, 4);
+    MAX_TEAMS          = get_config_int(&quot;Limits&quot;, &quot;MaxTeams&quot;, 6);
+    player_type = new char*[MAX_PLAYERS];
+    player_config = new int[MAX_PLAYERS];
+    player_team   = new int[MAX_PLAYERS];
+  }
+  for (i = 0; i &lt; MAX_PLAYERS; i += 1) {
+    sprintf(tmp, &quot;Player%d&quot;, i+1);
+    player_type[i] = strdup(get_config_string(tmp, &quot;Type&quot;, &quot;Human&quot;));
+    player_config[i] = get_config_int (tmp, &quot;Config&quot;, i % MAX_CONFIGURATIONS);
+    player_team[i] = get_config_int (tmp, &quot;Team&quot;, 0);
+  }
+  
+  prepareTitleScreenAssets();
+  showTitle();
+  enable();
+  
+  int mainRet;
+  do {
+    //mainRet = popup_dialog(mainDialog, MAIN_DIALOG_MELEE);
+    mainRet = tw_do_dialog(window, mainDialog, MAIN_DIALOG_MELEE);
+    switch (mainRet) {
+    case MAIN_DIALOG_MELEE:
+      disable();
+      play_game(&quot;Melee&quot;);
+      enable();
+      break;
+    case MAIN_DIALOG_MELEE_EXTENDED:
+      disable();
+      extended_menu();
+      enable();
+      break;
+    case MAIN_DIALOG_OPTIONS:
+      showTitle();
+      options_menu(NULL);
+      break;
+    case MAIN_DIALOG_HELP:
+      show_file(data_full_path(&quot;ingame.txt&quot;).c_str());
+      break;
+    case MAIN_DIALOG_TEAMS:
+      change_teams();
+      showTitle();
+      break;
+    }
+  } while((mainRet != MAIN_DIALOG_EXIT) &amp;&amp; (mainRet != -1));
+  
 }
 
 int tw_main(int argc, char *argv[]);
@@ -511,7 +512,7 @@
   strncpy(datapath, argv[0], i);
   chdir(datapath);
 #endif
-  
+
   log_debug(NULL);
   time_t start_time = time(NULL);
   log_debug(&quot;Log started at %s\n&quot;, asctime(localtime(&amp;start_time)));

Modified: trunk/source/ships/shpaktgu.cpp
===================================================================
--- trunk/source/ships/shpaktgu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpaktgu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -89,6 +89,7 @@
 Ship(opos, shipAngle, shipData, shipCollideFlag)
 
 {
+  STACKTRACE;
 	weaponColor  = get_config_int(&quot;Weapon&quot;, &quot;Color&quot;, 0);
 	weaponRange1  = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range1&quot;, 0));
 	weaponDamage = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -119,6 +120,7 @@
 
 int AktunGunner::activate_weapon()
 {
+  STACKTRACE;
 	if(fire_special)
 		return(FALSE);
 
@@ -141,6 +143,7 @@
 
 int AktunGunner::activate_special()
 {
+  STACKTRACE;
 //	if ((fire_weapon) &amp;&amp; (batt &gt;= extraDrain))
 //	{
 		if (num_ComSats == max_ComSats) {
@@ -174,10 +177,12 @@
 	  ldamage, lfcount, opos, relpos, true),
 	  owner(lowner)
 {
+  STACKTRACE;
 }
 
 void AktunLaser::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(owner-&gt;data-&gt;sampleWeapon[0]));
   Laser::inflict_damage(other);
   tw_sound.play_sound(data_full_path(owner-&gt;data-&gt;sampleWeapon[1]));
@@ -197,6 +202,7 @@
   lColor(ocolor),
   armour(oarmour)
 {
+  STACKTRACE;
   layer = LAYER_SPECIAL;
   collide_flag_anyone = ALL_LAYERS - bit(LAYER_CBODIES);
   angle = oangle;
@@ -205,6 +211,7 @@
 }
 
 void AktunComSat::calculate() {
+  STACKTRACE;
   
   if(!(ship &amp;&amp; ship-&gt;exists())) 
     {
@@ -254,11 +261,13 @@
 
 int AktunComSat::canCollide(SpaceLocation *other) 
 {
+  STACKTRACE;
   return SpaceObject::canCollide(other);
 }
 
 int AktunComSat::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
   double tot;
   tot = normal+direct;
   if ( tot &gt; 0 ) 
@@ -280,6 +289,7 @@
 
 void AktunComSat::death() 
 {
+  STACKTRACE;
   for (int i = 0; i &lt; ((AktunGunner*)ship)-&gt;num_ComSats; i++ ) 
     {
       if (((AktunGunner*)ship)-&gt;ComSat[i] == this) 

Modified: trunk/source/ships/shpalabc.cpp
===================================================================
--- trunk/source/ships/shpalabc.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpalabc.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -218,6 +218,7 @@
 
 void AlaryBC::calculate()
 {
+  STACKTRACE;
   update_panel = true;
 
   if (crew &lt;= 0) 
@@ -323,6 +324,7 @@
 
 int AlaryBC::activate_weapon()
 {
+  STACKTRACE;
   if (crew &lt;= 0) return false;
   
   game-&gt;add(new AlaryBCTorpedo(this, 30*side, 0, angle, 
@@ -338,6 +340,7 @@
 
 void AlaryBC::calculate_fire_special()
 {
+  STACKTRACE;
   if (crew &lt;= 0) return;
   
   if (fire_special &amp;&amp; can_switch) 
@@ -350,6 +353,7 @@
 
 void AlaryBC::calculate_thrust()
 {
+  STACKTRACE;
   if (crew &lt;= 0) 
     return;
   Ship::calculate_thrust();
@@ -357,6 +361,7 @@
 
 void AlaryBC::calculate_turn_left()
 {
+  STACKTRACE;
   if (crew &lt;= 0) 
     return;
   if ((turn_left)&amp;&amp;(!turn_right))
@@ -365,6 +370,7 @@
 
 void AlaryBC::calculate_turn_right()
 {
+  STACKTRACE;
   if (crew &lt;= 0) 
     return;
   if ((turn_right)&amp;&amp;(!turn_left))
@@ -373,6 +379,7 @@
 
 void AlaryBC::calculate_hotspots()
 {
+  STACKTRACE;
   if (crew &lt;= 0) 
     return;
   if (engines_armour &gt; 0) 
@@ -391,6 +398,7 @@
 
 void AlaryBC::animate(Frame *space)
 {
+  STACKTRACE;
   if (state == 0) 
     return;
   
@@ -462,6 +470,7 @@
 
 int AlaryBC::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
   double total = 0;
   
   //	check for &quot;repair&quot;
@@ -598,12 +607,14 @@
 
 int AlaryBC::handle_fuel_sap(SpaceLocation *source, double normal)
 {
+  STACKTRACE;
   normal = (normal / extraFuelSapReduction);
   return Ship::handle_fuel_sap(source, normal);
 }
 
 double AlaryBC::handle_speed_loss(SpaceLocation *source, double normal)
 {
+  STACKTRACE;
   normal = normal / extraSpeedLossReduction;
   return Ship::handle_speed_loss(source, normal);
 }
@@ -623,6 +634,7 @@
   wh_damage(iround(wdamage)), wh_armour(iround(warmour)), wh_v(wv),
   wh_turn_rate(wtr), wh_range(wrange)
 {
+  STACKTRACE;
   target = otarget;
   layer = LAYER_SHOTS;
   set_depth(DEPTH_SHOTS);
@@ -641,6 +653,7 @@
 
 void AlaryBCTorpedo::calculate()
 {
+  STACKTRACE;
   SpaceObject::calculate();
   lifetime -= frame_time;
   if (lifetime &lt; 0) 
@@ -711,6 +724,7 @@
 
 void AlaryBCTorpedo::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if (other-&gt;isblockingweapons)
     {
       game-&gt;add(new Animation(this, pos, data-&gt;spriteWeaponExplosion, 0, 10, 50, DEPTH_EXPLOSIONS));
@@ -721,6 +735,7 @@
 
 int AlaryBCTorpedo::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   if (direct+normal &gt; 0) 
     armour -= iround(direct+normal);
   if (armour &lt;= 0) 
@@ -739,6 +754,7 @@
   HomingMissile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
 		otrate, creator, osprite, otarget)
 {
+  STACKTRACE;
   explosionSprite     = data-&gt;spriteExtraExplosion;
   explosionFrameCount = 10;
   explosionFrameSize  = 50;
@@ -750,6 +766,7 @@
 
 void AlaryBCWarhead::calculate()
 {
+  STACKTRACE;
   HomingMissile::calculate();
   
   while (smoke_frame &lt;= 0) 
@@ -765,6 +782,7 @@
 
 void AlaryBCTurret::sinc_it()
 {
+  STACKTRACE;
   pos = normalize(ship-&gt;normal_pos() + rotate(Vector2(-rel_x, rel_y), -PI/2+ship-&gt;get_angle()));
   vel = ship-&gt;get_vel();
 }
@@ -801,6 +819,7 @@
 
 double AlaryBCTurret::get_aim(SpaceObject *tgt)
 {
+  STACKTRACE;
   if (tgt == NULL)
     return (-1);
   
@@ -853,6 +872,7 @@
 
 SpaceObject *AlaryBCTurret::get_target(SpaceObject *tgt)
 {
+  STACKTRACE;
   double d_a, prix=-1, prix_c, aim; //!!!
   Query q;
   SpaceObject *tgt0=tgt;
@@ -904,6 +924,7 @@
 
 void AlaryBCTurret::calculate()
 {
+  STACKTRACE;
   if (!(ship &amp;&amp; ship-&gt;exists()))
     {
       ship = 0;
@@ -1030,6 +1051,7 @@
   Missile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, 
 	  creator, osprite, relativity)
 {
+  STACKTRACE;
   set_depth(DEPTH_SHIPS+0.25);
   collide_flag_sameship = 0;
   collide_flag_sameteam = 0;

Modified: trunk/source/ships/shpbahbu.cpp
===================================================================
--- trunk/source/ships/shpbahbu.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpbahbu.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -78,6 +78,7 @@
 BahaoidBuzzsaw::BahaoidBuzzsaw(Vector2 opos, double shipAngle, ShipData *shipData, int shipCollideFlag) :
 	Ship(opos, shipAngle, shipData, shipCollideFlag)
 {
+  STACKTRACE;
 
 	weaponRange		= scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponSpeed		= get_config_float(&quot;Weapon&quot;, &quot;Speed&quot;, 1) * ANGLE_RATIO;
@@ -94,6 +95,7 @@
 
 void BahaoidBuzzsaw::calculate_turn_left()
 {
+  STACKTRACE;
 	if(can_turn)
 	{
 		Ship::calculate_turn_left();
@@ -102,6 +104,7 @@
 
 void BahaoidBuzzsaw::calculate_turn_right()
 {
+  STACKTRACE;
 	if(can_turn)
 	{
 		Ship::calculate_turn_right();
@@ -110,6 +113,7 @@
 
 int BahaoidBuzzsaw::activate_weapon()
 {
+  STACKTRACE;
 	double xone = 0.8660254038;
 	double yone = 0.5;
 
@@ -144,6 +148,7 @@
 
 int BahaoidBuzzsaw::activate_special()
 {
+  STACKTRACE;
 	if(nummines&gt;=specialNumber) return(FALSE);
 
 	game-&gt;add(new BahaoidBabyBuzzsaw(0, 0, angle, 0, specialArmour, this,
@@ -155,6 +160,7 @@
 
 void BahaoidBuzzsaw::calculate()
 {
+  STACKTRACE;
 
 	if(fire_weapon)
 	{
@@ -176,6 +182,7 @@
     AnimatedShot(oship, opos, oangle, ov, odamage, -1.0, oarmour, oship,
       osprite, ofcount, ofsize)
 {
+  STACKTRACE;
 	weaponRange		= rangey;
 	weaponSpeed		= speedy;
 	weaponDamage	= damagey;
@@ -191,6 +198,7 @@
 
 int BahaoidBabyBuzzsaw::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
 	armour -= normal + direct;
 	
 	if(armour &lt;= 0)
@@ -203,6 +211,7 @@
 
 void BahaoidBabyBuzzsaw::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 	if((ship) &amp;&amp; (other == ship))
 	{
 		state = 0;
@@ -216,6 +225,7 @@
 
 void BahaoidBabyBuzzsaw::calculate()
 {
+  STACKTRACE;
 	SpaceObject *o, *t = NULL;
 	double oldrange = 999999;
 

Modified: trunk/source/ships/shpbipka.cpp
===================================================================
--- trunk/source/ships/shpbipka.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpbipka.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -106,6 +106,7 @@
 };
 
 SpaceLocation* BipoleKatamaran::get_ship_phaser() {
+  STACKTRACE;
   return new NullPhaser( this );
 }
 
@@ -113,6 +114,7 @@
   ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   collide_flag_anyone = 0;
   collide_flag_sameteam = 0;
   collide_flag_sameship = 0;
@@ -157,7 +159,7 @@
 }
 
 int BipoleKatamaran::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return FALSE;
   weapon_sample = random(11);
   int left_w = left-&gt;activate_weapon();
@@ -166,7 +168,7 @@
 }
 
 int BipoleKatamaran::activate_special(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return FALSE;
   if( range &gt;= specialMaxRange ){
     range = specialMaxRange;
@@ -177,12 +179,13 @@
 }
 
 void BipoleKatamaran::animate(Frame* space){
+  STACKTRACE;
   /* we do not show */
   return;
 }
 
 void BipoleKatamaran::calculate(){
-	STACKTRACE
+  STACKTRACE;
   if( left ) if( !left-&gt;exists() ){
     left = NULL;
     if( right ){
@@ -320,7 +323,7 @@
 }
 
 void BipoleKatamaran::calculate_thrust(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left-&gt;thrust &amp;&amp; !left-&gt;turn_left &amp;&amp; !left-&gt;turn_right ){
     left-&gt;accelerate(this, angle, accel_rate * frame_time, speed_max);
@@ -330,7 +333,7 @@
   }
 }
 void BipoleKatamaran::calculate_turn_left(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left-&gt;turn_left ){
     left-&gt;nextkeys &amp;= ~keyflag::thrust;
@@ -342,7 +345,7 @@
   }
 }
 void BipoleKatamaran::calculate_turn_right(){
-	STACKTRACE
+  STACKTRACE;
   if( !left || !right ) return;
   if( left-&gt;turn_right ){
     left-&gt;nextkeys |= keyflag::thrust;
@@ -355,11 +358,12 @@
 }
 
 void BipoleKatamaran::calculate_hotspots(){
+  STACKTRACE;
   return;
 }
 
 void BipoleKatamaran::materialize(){
-	STACKTRACE;
+  STACKTRACE;
 	
 //  int i;
 //  for( i = 0; game-&gt;target[i] != this; i++ );
@@ -373,7 +377,7 @@
 }
 
 void BipoleKatamaran::death(){
-	STACKTRACE
+  STACKTRACE;
 	// bug fix Geo.
 	// added exists(), because I *think* that the &quot;invisible&quot; ships can be destroyed
 	// by some field weapon ? At the same time, this field weapon can destroy the
@@ -387,6 +391,7 @@
   ShipData *shipData, unsigned int code, Ship* oparent, SpaceSprite* osprite) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   parent = oparent;
   sprite = osprite;
 
@@ -402,7 +407,7 @@
 }
 
 int BipoleShip::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   shooting = !shooting;
   if( !shooting ) return FALSE;  // if we would return TRUE single ship would fire slower
 
@@ -414,7 +419,7 @@
 }
 
 int BipoleShip::activate_special(){
-	STACKTRACE
+  STACKTRACE;
 
 	if ( vel != 0 )
 	{
@@ -429,27 +434,28 @@
 }
 
 void BipoleShip::calculate_fire_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_fire_weapon();
 }
 void BipoleShip::calculate_fire_special(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_fire_special();
 }
 void BipoleShip::calculate_thrust(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_thrust();
 }
 void BipoleShip::calculate_turn_left(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_turn_left();
 }
 void BipoleShip::calculate_turn_right(){
-	STACKTRACE
+  STACKTRACE;
   if( !sibling ) Ship::calculate_turn_right();
 }
 
 /*void BipoleShip::calculate_hotspots() {
+  STACKTRACE;
   if( thrust &amp;&amp;( hotspot_frame &lt;= 0 )){
     game-&gt;addItem(new Animation( this, 
       normal_x() - (cos(angle ) * w / 2.5),
@@ -461,7 +467,7 @@
 }*/
 
 int BipoleShip::handle_damage(SpaceLocation *source, double normal, double direct) {
-	STACKTRACE
+  STACKTRACE;
 	int s = exists();
 	int i = Ship::handle_damage(source, normal, direct);
 	if (s &amp;&amp; !exists()) destroyed( source );
@@ -470,6 +476,7 @@
 
 void BipoleShip::destroyed( SpaceLocation* source )
 {
+  STACKTRACE;
   tw_sound.play_sound(data_full_path(MELEE_BOOMSHIP_SOUND));
   game-&gt;add(new Animation(this, pos,
 			  meleedata.kaboomSprite, 0, KABOOM_FRAMES, time_ratio, LAYER_EXPLOSIONS));
@@ -478,6 +485,7 @@
 
 ShipType *BipoleShip::get_shiptype()
 {
+  STACKTRACE;
   // this is necessary, otherwise the Kat Poly ship crashes.
   // also, &quot;type&quot; cannot be redirected inside the constructor, cause the
   // parents' type is declared outside of its constructor (bad?).

Modified: trunk/source/ships/shpbogce.cpp
===================================================================
--- trunk/source/ships/shpbogce.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpbogce.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -179,6 +179,7 @@
 
 int BoggCenturion::activate_weapon()
 {
+  STACKTRACE;
   if ((gun_phase &gt;= old_gun_phase) || (!gun_full_speed) || (delay_count &lt; startup_delay))
     return false;
   
@@ -198,6 +199,7 @@
 
 void BoggCenturion::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = FALSE;
   
   if(fire_special) 
@@ -239,6 +241,7 @@
 
 void BoggCenturion::calculate()
 {
+  STACKTRACE;
   Ship::calculate();
   
   if ((fire_weapon) &amp;&amp; !( (batt &lt; weapon_drain) || slowing_down)  ) {
@@ -280,6 +283,7 @@
 
 void BoggCenturion::animate(Frame* space)
 {
+  STACKTRACE;
   BITMAP *bmp;
   bmp = sprite-&gt;get_bitmap(64, 0);
   clear_to_color( bmp, makecol(255,0,255));
@@ -330,6 +334,7 @@
 
 void BoggCenturion::calculate_hotspots()
 {
+  STACKTRACE;
   if (draw_hotspots)
     Ship::calculate_hotspots();
   
@@ -356,6 +361,7 @@
 int BoggCenturion::handle_damage(SpaceLocation *source, double normal, double direct)
 //void BoggCenturion::handle_damage(SpaceLocation *source)
 {
+  STACKTRACE;
   if (source == this) {
     return Ship::handle_damage(source, normal, direct);
   }
@@ -425,6 +431,7 @@
 
 void BoggCenturionMissile::calculate()
 {
+  STACKTRACE;
   SpaceObject::calculate();
   if (lifetime &gt; 0) 
     lifetime -= frame_time;
@@ -449,6 +456,7 @@
 
 void  BoggCenturionMissile::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if ((!other-&gt;isPlanet()) &amp;&amp; (other-&gt;mass))
     other-&gt;accelerate(this, normalize(trajectory_angle(other), 360), blast_accel/other-&gt;mass, blast_maxspeed);
   Missile::inflict_damage(other);
@@ -472,6 +480,7 @@
 
 void BoggCenturionExhaust::calculate()
 {
+  STACKTRACE;
   Animation::calculate();
   double gamma = exp( - slowdown * frame_time);
   vel *= gamma;
@@ -489,6 +498,7 @@
 
 void BoggCenturionExhaustShot::calculate()
 {
+  STACKTRACE;
   Shot::calculate();
   if (!amt-&gt;exists()) 
     state = 0;
@@ -499,10 +509,12 @@
 
 void BoggCenturionExhaustShot::animate(Frame *space)
 {
+  STACKTRACE;
 }
 
 void BoggCenturionExhaustShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   other-&gt;handle_damage(this, 1);
   if (!s.empty())  
     {
@@ -522,10 +534,12 @@
 
 void BoggCenturionShot::animate(Frame *space)
 {
+  STACKTRACE;
 }
 
 void BoggCenturionShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   pos += edge();
   tw_sound.play_sound(data_full_path(ex_sample)); // was vol 240
   game-&gt;add(new Animation(this, pos, ex_sprite, 0, 10, 50, LAYER_EXPLOSIONS));
@@ -535,6 +549,7 @@
 
 void BoggCenturionShot::calculate()
 {
+  STACKTRACE;
   if (frame &gt; 0) 
     {
       state = 0;

Modified: trunk/source/ships/shpchoex.cpp
===================================================================
--- trunk/source/ships/shpchoex.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpchoex.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -50,6 +50,7 @@
 AsteroidDebris::AsteroidDebris(Ship *creator1, Vector2 new_pos, int tforce)
 : Asteroid()
 {
+  STACKTRACE;
   creator=creator1;
   translate(new_pos - pos);
   frame_born=(int)(game-&gt;frame_number);
@@ -60,7 +61,7 @@
 }
 void AsteroidDebris::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   step-= frame_time;
   while(step &lt;= 0) {
     step += speed * time_ratio;
@@ -82,7 +83,7 @@
 }
 int AsteroidDebris::canCollide(SpaceLocation *other) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (collide_flag)
     { return SpaceObject::canCollide(other);
     }
@@ -106,13 +107,14 @@
 AsteroidCenter::AsteroidCenter(Ship *creator1, Vector2 new_pos) 
 : AsteroidDebris(creator1, new_pos, 0)
 {
+  STACKTRACE;
   layer = LAYER_SHOTS;
   collide_flag_anyone = ALL_LAYERS &amp;~ bit(LAYER_CBODIES);
   creator=creator1;
 }
 void AsteroidCenter::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   if (creator == NULL)
     {
       this-&gt;~AsteroidCenter();
@@ -126,16 +128,18 @@
 }
 int AsteroidCenter::canCollide(SpaceLocation *other) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (!other-&gt;damage_factor) return false;
   return SpaceObject::canCollide(other);
 }
 int AsteroidCenter::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
+  STACKTRACE;
 	return iround(normal + direct);
 }
 int AsteroidCenter::isAsteroid()
 {
+  STACKTRACE;
   return 0;
 }
 
@@ -161,6 +165,7 @@
 Laser(creator1, langle, lcolor, lrange, 
        ldamage, lfcount, opos, Vector2(rel_x,rel_y), osinc_angle)
 {
+  STACKTRACE;
   tractorForce = tForce;
   tractorPushForce = tPushForce;
   creator=creator1;
@@ -168,7 +173,7 @@
 
 void ChoraliTractorBeam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   // SpaceObject::inflict_damage(other);
  if(other != NULL)
   {
@@ -258,6 +263,7 @@
 		oship, osprite, oship-&gt;target), 
   explosion(meleedata.asteroidExplosionSprite), frame_count(oframe_count) 
 {
+  STACKTRACE;
 	collide_flag_sameship = bit(LAYER_SHIPS) | bit(LAYER_SHOTS);
 	//	explosionSprite     = game-&gt;asteroidExplosionSprite;
 	
@@ -282,7 +288,7 @@
 
 void AsteroidMissile::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
   HomingMissile::calculate();
   if(sprite_index_count&lt;63)
@@ -305,7 +311,7 @@
 
 void AsteroidMissile::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
   SpaceObject::inflict_damage(other);
   add(new Animation(this, pos, explosion, 0, explosion-&gt;frames(), time_ratio, LAYER_CBODIES));
   state=0;
@@ -313,7 +319,7 @@
 
 int AsteroidMissile::handle_damage(SpaceLocation *source, double normal, double direct) 
 {
-	STACKTRACE
+  STACKTRACE;
   if (!exists()) return 0;
   if (!normal &amp;&amp; !direct) return 0;
   
@@ -325,7 +331,7 @@
 }
 void AsteroidMissile::death()
 {
-	STACKTRACE
+  STACKTRACE;
   HomingMissile::death();
   add(new Animation(this, pos, explosion, 0, explosion-&gt;frames(), time_ratio, LAYER_CBODIES));
 }
@@ -415,6 +421,7 @@
 	Ship(opos, shipAngle, shipData, code)
 
 {
+  STACKTRACE;
   weaponFrames = get_config_int(&quot;Weapon&quot;, &quot;Frames&quot;, 0);
   drillFrames  = 0;
   weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -455,7 +462,7 @@
 
 void ChoraliExtractor::death()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::death();
 
   // dangerous, this is a memory leak:
@@ -464,26 +471,26 @@
 }
 void ChoraliExtractor::materialize()
 {
-	STACKTRACE
+  STACKTRACE;
 	Ship::materialize();
 	add(asteroid_center = new AsteroidCenter(this, this-&gt;normal_pos()));
 }
 
 void ChoraliExtractor::calculate_turn_left()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::calculate_turn_left();
 }
 
 void ChoraliExtractor::calculate_turn_right()
 {
-	STACKTRACE
+  STACKTRACE;
   Ship::calculate_turn_right();
 }
 
 int ChoraliExtractor::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   if (drillFrames &gt; 0)
     {
       count=0;      
@@ -515,7 +522,7 @@
 
 int ChoraliExtractor::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 
   if(this-&gt;nearest_planet() != NULL)
     {
@@ -540,6 +547,7 @@
 
 void ChoraliExtractor::calculate()
 {
+  STACKTRACE;
   if(drillFrames &gt; 0) 
     {
       if(grabbed == NULL)
@@ -651,6 +659,7 @@
 
 int ChoraliExtractor::canCollide(SpaceObject *other)
 {
+  STACKTRACE;
   if ((latched) &amp;&amp; (grabbed!=NULL) &amp;&amp; (grabbed-&gt;exists()))
     {
       if (grabbed == other)
@@ -661,12 +670,14 @@
  
 void ChoraliExtractor::animate(Frame *space)
 {
+  STACKTRACE;
   sprite-&gt;animate( pos, sprite_index, space);
 }
 
 
 void ChoraliExtractor::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   if (drillFrames &gt; 0)
     {
       if (!latched)

Modified: trunk/source/ships/shpconca.cpp
===================================================================
--- trunk/source/ships/shpconca.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpconca.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -71,6 +71,7 @@
 	SpaceObject *Next_Object):SpaceObject(creator,
 	opos,oangle,osprite)
 {
+  STACKTRACE;
 	Prev_Link=(Link *)Prev_Object;
 	Next_Link=(Link *)Next_Object;
 }
@@ -119,7 +120,7 @@
 
 void CargoLink::do_area_damage()
 {
-	STACKTRACE
+  STACKTRACE;
 	Query q;
 	for (q.begin(this, OBJECT_LAYERS, explosionRange); q.currento; q.next())
 	{
@@ -135,6 +136,7 @@
 
 int CargoLink::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   int  totalDamage = int( normal+direct + 0.5);
 
   if (totalDamage == 0) 
@@ -177,7 +179,7 @@
 
 void CargoLink::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	Link::calculate();
 	sprite_index = get_index(angle);
 	if (Prev_Link &amp;&amp; !Prev_Link-&gt;exists()) Prev_Link = NULL;
@@ -190,6 +192,7 @@
 :
 Link(creator,opos,oangle,osprite,Prev_Object,Next_Object)
 {
+  STACKTRACE;
 	mass=omass;
 	layer = LAYER_SPECIAL;
 
@@ -206,7 +209,7 @@
 
 void Chain::Pull_Last_Link()
 {
-	STACKTRACE
+  STACKTRACE;
 	Link *l=this;
 
 	//Seek to the end of the list
@@ -218,13 +221,13 @@
 
 int Chain::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 	return damage(Prev_Link, 0, normal+direct);
 }
 
 void Chain::Uncouple()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	for(Link *l=this-&gt;Next_Link ; l!=NULL; l=l-&gt;Next_Link)
 	{
@@ -269,6 +272,7 @@
 :
 Link(creator,opos, oangle,osprite,NULL,NULL)
 {
+  STACKTRACE;
 		
 	Prev_Link=(Link *)creator;	//Attach the first link to the ship
 	
@@ -307,7 +311,7 @@
 
 void Chain::addlink(SpaceLocation *creator, double oangle, SpaceSprite *osprite, double ospacing, double omass)
 {
-	STACKTRACE
+  STACKTRACE;
 	// first, find the last link in the list:
 	
 	Link *Cur_Link = this;					// Chain is also of type Link.
@@ -352,7 +356,7 @@
 //backwards.
 void Chain::ChainRecur(Link *other,int num)
 {
-	STACKTRACE
+  STACKTRACE;
 	//Call ChainRecur for the next link UNLESS you're at the last link
 	if(other-&gt;Next_Link!=NULL) ChainRecur(other-&gt;Next_Link,num+1);
 
@@ -363,7 +367,7 @@
 
 void Chain::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if( !(ship &amp;&amp; ship-&gt;exists()) )
 	{	//If the mothership is killed, the chain dies.
 		Uncouple();		//Shatters chain, links become independent
@@ -382,7 +386,7 @@
 
 void Chain::ChainPhysics(SpaceObject *first, SpaceObject *second)
 {
-	STACKTRACE
+  STACKTRACE;
 
 
 	// first = towards the head, second = towards the tail
@@ -502,6 +506,7 @@
 	Ship(opos, angle, data, code)
 
 {
+  STACKTRACE;
 	weaponColor   =  get_config_int(&quot;Weapon&quot;, &quot;Color&quot;, 0);
 	weaponRange   =  scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponDamage  =  get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -515,7 +520,7 @@
 
 int ConfedCargotran::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	if(fire_special) return(FALSE);
 
 	//Add weapon code here
@@ -528,7 +533,7 @@
 
 int ConfedCargotran::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 	//Cuts loose all links and remembers that it did so.
 	if(Head==NULL)
 		return(FALSE);
@@ -550,7 +555,7 @@
 
 void ConfedCargotran::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	double back_x=size.x/3.60, back_y=-size.y/2.33,
 	       frnt_x=size.x/5.55, frnt_y=+size.y/17.01,
 	       back_y_1=-size.y/2.06;
@@ -587,7 +592,7 @@
 
 void ConfedCargotran::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	Ship::calculate();
 
 }
@@ -595,7 +600,7 @@
 
 void ConfedCargotran::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE;
+  STACKTRACE;
 	if (!(other &amp;&amp; other-&gt;exists()))
 		return;
 

Modified: trunk/source/ships/shpconho.cpp
===================================================================
--- trunk/source/ships/shpconho.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpconho.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -77,6 +77,7 @@
 		ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   regenrateFrames = get_config_int(&quot;Extra&quot;, &quot;Frames&quot;, 0);
   regenrating     = FALSE;
   regenrateAmount = get_config_int(&quot;Extra&quot;, &quot;RechargeAmount&quot;, 0);
@@ -113,7 +114,7 @@
 }
 
 int ConfederationHornet::activate_weapon() {
-	STACKTRACE
+  STACKTRACE;
   add(new Missile(this, Vector2(7,35),
     angle, weaponVelocity, weaponDamage, weaponRange, weaponArmour,
     this, data-&gt;spriteWeapon));
@@ -125,7 +126,7 @@
 
 int ConfederationHornet::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
   add(new TorpedoMissile(0.0, (size.y / 2.0),
     angle, specialVelocity, specialDamage, specialDDamage, specialRange, specialArmour, specialTurnRate, this, this, data-&gt;spriteSpecial, target));
   return(TRUE);
@@ -133,7 +134,7 @@
 
 void ConfederationHornet::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 //   int shield_color = 9; // Blue
 //   int i, bar_x, bar_y, shield_panel;
@@ -182,7 +183,7 @@
 }
 
 int ConfederationHornet::handle_damage(SpaceLocation *source, double normal, double direct) {
-	STACKTRACE
+  STACKTRACE;
    if ((normal - shield) &lt;= 0) {
      shield -= iround(normal);
 	 normal = 0;
@@ -196,6 +197,7 @@
 
 RGB ConfederationHornet::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c1 = {0,255,0};
 	RGB c2 = {0,0,255};		// blue
 
@@ -208,6 +210,7 @@
 // returns the &quot;real&quot; live crew (this can fool the Syreen).
 double ConfederationHornet::getCrew()
 {
+  STACKTRACE;
 	if (crew)
 		return 1;
 	else
@@ -224,10 +227,11 @@
   HomingMissile(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, otrate, opos, osprite, otarget),
   Direct_Damage(oddamage)
 {
+  STACKTRACE;
 }
 
 void TorpedoMissile::inflict_damage(SpaceObject *other) {
-	STACKTRACE
+  STACKTRACE;
 	damage(other, 0, Direct_Damage);
   HomingMissile::inflict_damage(other);
 }

Modified: trunk/source/ships/shpdragr.cpp
===================================================================
--- trunk/source/ships/shpdragr.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpdragr.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -75,6 +75,7 @@
 						 ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -101,7 +102,7 @@
 
 int DraxGryphon::activate_weapon()
 {
-	STACKTRACE;
+  STACKTRACE;
   weaponoffset++;
 
   if (weaponoffset &gt; 3)
@@ -118,9 +119,8 @@
 
 int DraxGryphon::activate_special()
 {
+  STACKTRACE;
 
-	STACKTRACE;
-
 	if (numMines == maxMines) {
 	  weaponObject[0]-&gt;state = 0;
 	  numMines -= 1;
@@ -139,7 +139,7 @@
 
 void DraxGryphon::calculate()
 {
-STACKTRACE;
+  STACKTRACE;
 
    int j = 0;
    for (int i = 0; i &lt; numMines; i += 1) {
@@ -160,6 +160,7 @@
     AnimatedShot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0, oarmour, oship,
       osprite, ofcount, ofsize)
 {
+  STACKTRACE;
   MineMoving = TRUE;
   MineRange = miner;
   MineTimer = minet;
@@ -171,9 +172,8 @@
 }
 
 void DraxMine::calculate() {
+  STACKTRACE;
 
-	STACKTRACE;
-
 	AnimatedShot::calculate();
 
 	if (!exists()) return;
@@ -240,8 +240,7 @@
 }
 
 void DraxMine::inflict_damage(SpaceObject *other) {
-
-	STACKTRACE;
+  STACKTRACE;
   if (other-&gt;isShip())
      damage_factor = 0;
 

Modified: trunk/source/ships/shpearc3.cpp
===================================================================
--- trunk/source/ships/shpearc3.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpearc3.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -79,6 +79,7 @@
 		ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange			= scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponVelocity		= scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
 	weaponDamage		= get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -101,7 +102,7 @@
 
 void EarthlingCruiserMk3::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	Ship::calculate();
 
 	double track_angle = 0;
@@ -148,7 +149,7 @@
 
 int EarthlingCruiserMk3::activate_weapon()
 {
-	STACKTRACE;
+  STACKTRACE;
 	add(new EarthlingCruiserMk3Shot(this, Vector2(0.0, 28.0),
 		normalize(angle + launch_angle + turn_step + tw_random(-weaponSpread, +weaponSpread), PI2),
 		weaponVelocity,	weaponDamage, weaponRange, weaponArmour, data-&gt;spriteWeapon));
@@ -157,6 +158,7 @@
 
 int EarthlingCruiserMk3::activate_special()
 {
+  STACKTRACE;
   bool fire = false;;
   SpaceObject *o;
   double rng = 1e40;
@@ -193,6 +195,7 @@
 		double ov, double odamage, double orange, double oarmour, SpaceSprite *osprite) :
 	Shot(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	explosionSprite     = data-&gt;spriteWeaponExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 25;
@@ -206,12 +209,14 @@
 
 void EarthlingCruiserMk3Shot::animate(Frame *space)
 {
+  STACKTRACE;
   if (exists())
     sprite-&gt;animate(pos, sprite_index = (int)(31.99 * d / range), space);
 }
 
 void EarthlingCruiserMk3Shot::soundExplosion()
 {
+  STACKTRACE;
   tw_sound.play_sound(data_full_path(explosionSample));
   return;
 }
@@ -224,6 +229,7 @@
 	frame(0), frame_count(lfcount), lpos(creator), rel_pos(rpos), damage_shots(sdamage)
 
 {
+  STACKTRACE;
 	set_depth(DEPTH_EXPLOSIONS);
 	target = tgt;
 	base_length = length;
@@ -248,7 +254,7 @@
 
 void EarthlingCruiserMk3Beam::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	if(!(lpos &amp;&amp; lpos-&gt;exists()))
 	{
 		lpos = 0;
@@ -303,7 +309,7 @@
 
 void EarthlingCruiserMk3Beam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE;
+  STACKTRACE;
 	if (other-&gt;isShot())
 		damage(other, damage_shots*frame_time/frame_count);
 	else
@@ -321,7 +327,7 @@
 
 void EarthlingCruiserMk3Beam::animate(Frame *space)
 {
-	STACKTRACE;
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
 	if ((aa &amp; AA_BLEND) &amp;&amp; (aa &amp; AA_ALPHA) &amp;&amp; !(aa &amp; AA_NO_AA) &amp;&amp; (length &lt; base_length*0.9999) &amp;&amp; (target)) {

Modified: trunk/source/ships/shpforsh.cpp
===================================================================
--- trunk/source/ships/shpforsh.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpforsh.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -58,6 +58,7 @@
 ForevianShocker::ForevianShocker(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange		= scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0)); 
 	weaponVelocity	= scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
 	weaponDamage	= get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0); 
@@ -90,6 +91,7 @@
 
 int ForevianShocker::activate_weapon()
 {
+  STACKTRACE;
   SpaceSprite *tmp_s = data-&gt;spriteWeapon;
   if (weapon_type==2)	
     tmp_s = data-&gt;spriteExtra;
@@ -119,6 +121,7 @@
 
 int ForevianShocker::activate_special()
 {
+  STACKTRACE;
   if(shockingFrames == 0) 
     {
       tw_sound.stop_sound(data_full_path(data-&gt;sampleSpecial[0]));
@@ -132,6 +135,7 @@
 
 void ForevianShocker::calculate()
 {
+  STACKTRACE;
   if(shockVar == 1)
     {
       if(shockingFrames &gt; 0)
@@ -193,7 +197,8 @@
 				     int ofsize, int ol) :
   AnimatedShot(oship, Vector2(ox,oy), oangle, ov, odamage, orange, 
 	       oarmour, oship, osprite, ofcount, ofsize)
-{ 
+{
+  STACKTRACE; 
   collide_flag_anyone = OBJECT_LAYERS&amp;~bit(LAYER_SHOTS);
   collide_flag_sameship = collide_flag_anyone;
   last_hit = oship;
@@ -201,7 +206,8 @@
 }
 
 void ForevianShockwave::inflict_damage(SpaceObject *other)
-{	
+{
+  STACKTRACE;	
   if (other==last_hit)
     return;
   

Modified: trunk/source/ships/shpgarty.cpp
===================================================================
--- trunk/source/ships/shpgarty.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpgarty.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -116,6 +116,7 @@
 	:
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
 	weaponDamage					 = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 8);
 	weaponArmour					 = get_config_int(&quot;Weapon&quot;, &quot;Armour&quot;, 8);
@@ -145,7 +146,7 @@
 
 void GarashTyrant::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 
 if (!fire_weapon  &amp;&amp;
 		!fire_special &amp;&amp;
@@ -225,7 +226,7 @@
 }
 
 void GarashTyrant::stun_ship(SpaceObject *other){
-	STACKTRACE
+  STACKTRACE;
   GarashRepulsarStun* GRS;
   if (other-&gt;state==0) return;
 	if (other-&gt;isShip()) {
@@ -242,7 +243,7 @@
 
 void GarashTyrant::calculate_fire_weapon()
 	{
-	STACKTRACE
+  STACKTRACE;
 	weapon_low = FALSE;
 
 	if (fire_weapon) {
@@ -268,7 +269,7 @@
 
 int GarashTyrant::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   if(weaponObject)
     return(FALSE);
 
@@ -281,6 +282,7 @@
 }
 
 int GarashTyrant::activate_special() {
+  STACKTRACE;
 
 	repulse = true;
 
@@ -294,6 +296,7 @@
   ship(oship), stunframe(0), stunframe_count(stunFrames),
   frame_step(0), frame_size(ofsize), frame_count(ofcount)
 {
+  STACKTRACE;
   targetIsDead = FALSE;
 	collide_flag_anyone = 0;
 	layer = LAYER_EXPLOSIONS;
@@ -301,7 +304,7 @@
 }
 
 void GarashRepulsarStun::calculate() {
-	STACKTRACE
+  STACKTRACE;
   if(!ship) targetIsDead = TRUE;
   else {
     if(!ship-&gt;exists()) targetIsDead = TRUE;
@@ -360,6 +363,7 @@
 	CD(oChargingDistance),
 	CDD(oChargingDistanceDamage)
 {
+  STACKTRACE;
 	  vel = ship-&gt;get_vel();
 
 	Timer  = 0;
@@ -378,6 +382,7 @@
 
 void GarashShot::calculate() 
 {
+  STACKTRACE;
   if(released) 
     Shot::calculate();
   else SpaceObject::calculate();
@@ -464,11 +469,13 @@
 
 void GarashShot::animateExplosion()
 {
+  STACKTRACE;
   return;
 }
 
 void GarashShot::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   int Distance_Travelled = iround(distance_from(StartC, other-&gt;normal_pos()));
   int AddDamage = iround((Distance_Travelled / CD) * CDD);
   
@@ -513,6 +520,7 @@
 
 int GarashShot::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   armour += damage_factor + direct ; // nullify damage
   if (((!ship_hit &amp;&amp; !source-&gt;isShip()) ||
        (ship_hit &amp;&amp; source-&gt;isShip())) &amp;&amp; !released)
@@ -523,6 +531,7 @@
 
 int GarashShot::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
   return(TRUE);
 }
 REGISTER_SHIP(GarashTyrant)

Modified: trunk/source/ships/shpilwsp.cpp
===================================================================
--- trunk/source/ships/shpilwsp.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpilwsp.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -82,6 +82,7 @@
 		ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
   weaponRange       = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity    = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -98,7 +99,7 @@
 
 int IlwrathSpider::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   game-&gt;add( new AnimatedShot( this, Vector2(size.x*0.12, size.y*0.35),
     angle + weaponAngle, weaponVelocity, weaponDamage, weaponRange, weaponArmour, this,
     data-&gt;spriteWeapon, data-&gt;spriteWeapon-&gt;frames(), ILWRATH_FIRE_ANIM_RATE, 1 ));
@@ -111,7 +112,7 @@
 
 int IlwrathSpider::activate_special()
 {
-	STACKTRACE;
+  STACKTRACE;
     double alpha = specialSpread / specialNumber;
     double beta = normalize( angle + PI - 0.5 * specialSpread + random(alpha), PI2 );
     double tx = cos( angle );
@@ -130,13 +131,13 @@
 
 void IlwrathSpider::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
     Ship::calculate();
 }
 
 void IlwrathSpiderMine::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   double alpha = (-10 + random(21)) * ANGLE_RATIO;
   alpha *= randomness;
   angle += alpha * frame_time;
@@ -169,6 +170,7 @@
 
 void IlwrathSpiderMine::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   state = 0;
   
   int freq;
@@ -202,6 +204,7 @@
   step( 0 ), life( olife ), inc( 1 ),
   randomness( orandomness ), stoptime( ostoptime )
 {
+  STACKTRACE;
   layer = LAYER_SPECIAL;
   vel = unit_vector(angle) * v;
 }
@@ -210,6 +213,7 @@
   SpaceLocation( creator, 0, 0 ),
   victim( ovictim ), life( olife )
 {
+  STACKTRACE;
   if( victim )
     {
       if( !victim-&gt;exists() )
@@ -234,6 +238,7 @@
 
 void IlwrathStop::calculate()
 {
+  STACKTRACE;
   SpaceLocation::calculate();
   if( !(victim &amp;&amp; victim-&gt;exists()) )
     {

Modified: trunk/source/ships/shpkahbo.cpp
===================================================================
--- trunk/source/ships/shpkahbo.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpkahbo.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -141,6 +141,7 @@
 	:
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   weapon1Range    = scale_range(get_config_float(&quot;WeaponS&quot;, &quot;Range&quot;, 0));
   weapon1Turn     = scale_turning(get_config_float(&quot;WeaponS&quot;,&quot;Turn&quot;, 0));
   weapon1Velocity = scale_velocity(get_config_float(&quot;WeaponS&quot;, &quot;Velocity&quot;, 0));
@@ -174,7 +175,7 @@
 
 int KahrBoomerang::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
   int chance;
   int answer = FALSE;
   if (weaponChoice == SMALL_BOOMERANG) {
@@ -209,7 +210,7 @@
 
 int KahrBoomerang::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
   int answer;
   if (weaponChoice == SMALL_BOOMERANG) {
     weapon_drain = weapon2Drain;
@@ -232,7 +233,7 @@
 
 void KahrBoomerang::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
   if ((boomerangL != NULL) &amp;&amp; (!boomerangL-&gt;exists()))
     boomerangL=NULL;
   Ship::calculate();
@@ -248,7 +249,7 @@
 
 void KahrBoomerang::calculate_fire_special()
 {
-	STACKTRACE
+  STACKTRACE;
   if (weaponChoice == SMALL_BOOMERANG) {
     blit(this-&gt;spritePanel-&gt;get_bitmap(7), this-&gt;spritePanel-&gt;get_bitmap(1), 36, 0, 36, 0, 19, 30);
     blit(this-&gt;spritePanel-&gt;get_bitmap(7), this-&gt;spritePanel-&gt;get_bitmap(2), 36, 0, 36, 0, 19, 30);
@@ -279,6 +280,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass = 0.25;
   frame = 0;
   frame_step = 0;
@@ -293,7 +295,7 @@
 
 void KahrSmall::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship &amp;&amp; ship-&gt;exists()))
 	{
 		state = 0;
@@ -334,7 +336,7 @@
 
 void KahrSmall::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -353,6 +355,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass = 3.0;
   frame = 0;
   frame_step = 0;
@@ -368,13 +371,13 @@
 }
 
 void KahrMedium::death() {
-	STACKTRACE;
+  STACKTRACE;
 	if (kahrship) (kahrship)-&gt;num_medium_boomerangs -= 1;
 	Shot::death();
 	}
 
 void KahrMedium::calculate() {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship &amp;&amp; ship-&gt;exists()))
 	{
 		state = 0;
@@ -418,7 +421,7 @@
 
 void KahrMedium::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -437,6 +440,7 @@
 	Shot(oship, Vector2(ox,oy), oangle, ov, odamage, -1.0 , oarmour, oship, osprite)
 
 {
+  STACKTRACE;
   mass =5.0;
   frame = 0;
   frame_step = 0;
@@ -451,7 +455,7 @@
 
 void KahrLarge::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!(ship &amp;&amp; ship-&gt;exists()))
 	{
 		state = 0;
@@ -490,7 +494,7 @@
 
 void KahrLarge::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (other == ship) {
 		state = 0;
 		mass = 0;
@@ -505,7 +509,7 @@
 
 int KahrLarge::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
   return Shot::handle_damage(source, 0, 0);
 }
 

Modified: trunk/source/ships/shprogsq.cpp
===================================================================
--- trunk/source/ships/shprogsq.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shprogsq.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -144,6 +144,7 @@
 :
 Ship(opos, angle, data, code)
 {
+  STACKTRACE;
 	
 	weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -215,7 +216,7 @@
 // This is called just before the first calculate(), after the ship phases into battle
 void RogueSquadron::materialize()
 {
-	STACKTRACE
+  STACKTRACE;
 	int i;
 
 	formation = 0;
@@ -266,6 +267,7 @@
 
 int RogueSquadron::activate_weapon()
 {
+  STACKTRACE;
 	// all ships fire a pulse laser:
 	fire_main = 1;
 	return TRUE;
@@ -274,8 +276,7 @@
 
 int RogueSquadron::activate_special()
 {
-
-	STACKTRACE
+  STACKTRACE;
 	int	i;
 
 	// first of all, clean up the old formation.
@@ -324,8 +325,8 @@
 
 
 void RogueSquadron::calculate()
-{	
-	STACKTRACE
+{
+  STACKTRACE;
 	fire_main = 0;	// reset this first.
 
 	int i;
@@ -440,7 +441,7 @@
 
 void RogueSquadron::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	int a;
 	a = aa_get_trans();
 	aa_set_trans(100);
@@ -452,6 +453,7 @@
 
 int RogueSquadron::handle_damage(SpaceLocation* source, double normal, double direct)
 {
+  STACKTRACE;
 	// the Syreen, and maybe other area-effect weapons, can do damage to
 	// the virtual ship, which I don't want. So, I'll disable all damage
 	// taking by this ship
@@ -463,6 +465,7 @@
 
 void RogueSquadron::calculate_hotspots()
 {
+  STACKTRACE;
 	// do nothing: no hotspots for this virtual thing
 }
 
@@ -472,6 +475,7 @@
 :
 Ship(creator, creator-&gt;pos, creator-&gt;angle, osprite)
 {
+  STACKTRACE;
 	mother = creator;
 	pos = mother-&gt;pos;
 
@@ -502,7 +506,7 @@
 
 SpaceObject* RogueFighter::nearest_location()
 {
-	STACKTRACE
+  STACKTRACE;
 	SpaceObject *p = NULL;
 	double r = 99999999;
 	Query q;
@@ -526,7 +530,7 @@
 // should be added to SpaceLocation I think !
 void RogueFighter::avoid_location(SpaceObject *o)
 {
-	STACKTRACE
+  STACKTRACE;
 	double t_a = trajectory_angle(o);
 	double d_a = normalize(t_a - angle, PI2);
 	
@@ -548,7 +552,7 @@
 
 void RogueFighter::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if ( !(mother &amp;&amp; mother-&gt;exists()) )
 	{
 		state = 0;
@@ -639,7 +643,7 @@
 
 int RogueFighter::handle_damage(SpaceLocation* source, double normal, double direct)
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!state)
 		return 0;	// to avoid an infinite feedback with enemy rogue.
 
@@ -690,6 +694,7 @@
   lpos(opos),
   rel_pos(rpos)
 {
+  STACKTRACE;
 
 // angle conventions fucked up??
 	rel_pos.x *= -1;
@@ -709,7 +714,7 @@
 
 
 void PulseLaser::calculate() {
-	STACKTRACE
+  STACKTRACE;
 	if((frame &lt; frame_count) &amp;&amp; (lpos-&gt;exists())) {
 //		pos = lpos-&gt;normal_pos() + rotate(rel_pos, lpos-&gt;get_angle() - PI/2);
 //		vel = lpos-&gt;get_vel();
@@ -723,6 +728,7 @@
 
 void PulseLaser::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
   // copied from space_line:
   int i;
   i = iround_down(damage_factor / 2);

Modified: trunk/source/ships/shpstaba.cpp
===================================================================
--- trunk/source/ships/shpstaba.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpstaba.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -48,6 +48,7 @@
 	:
 	Ship(opos, angle, data, code)
 	{
+  STACKTRACE;
 
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -67,7 +68,7 @@
 }
 
 int StarBase::activate_weapon() {
-	STACKTRACE
+  STACKTRACE;
    
 	double a;
 	if (target) {
@@ -96,7 +97,7 @@
 }
 
 int StarBase::activate_special() {
-	STACKTRACE
+  STACKTRACE;
   int fire = FALSE;
   SpaceObject *o;
 
@@ -123,6 +124,7 @@
 
 void StarBase::calculate() 
 {
+  STACKTRACE;
   int fire = FALSE;
   Ship *o;
 
@@ -154,6 +156,7 @@
 
 int StarBase::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
   batt -= normal;
   if (batt &lt; 0) 
     {
@@ -164,6 +167,7 @@
   return Ship::handle_damage(source, normal, direct);
 }
 
-void StarBase::calculate_gravity() {}
+void StarBase::calculate_gravity() {
+  STACKTRACE;}
 
 REGISTER_SHIP ( StarBase )

Modified: trunk/source/ships/shptauar.cpp
===================================================================
--- trunk/source/ships/shptauar.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptauar.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -120,6 +120,7 @@
 TauArchon::TauArchon(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponChargeTime	= (int)(get_config_float(&quot;Weapon&quot;, &quot;ChargeTime&quot;, 0) * 1000);
 	weapon_charge_counter	= 0;
 	weaponVelocity		= scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -167,6 +168,7 @@
 
 bool TauArchon::ShotTakeBatt()
 {
+  STACKTRACE;
 	if(numDamage_steps &gt; 0)
 	{
 		bool bWhat2Do;
@@ -216,7 +218,7 @@
 
 void TauArchon::calculate_fire_weapon()
 {
-STACKTRACE
+  STACKTRACE;
   weapon_low = FALSE;
 
  if ((fire_weapon || fire_special) &amp;&amp; (weapon_charge_counter &gt;= weaponChargeTime))
@@ -269,7 +271,7 @@
 
 void TauArchon::calculate_fire_special()
 {
-STACKTRACE
+  STACKTRACE;
 	special_low = false;
 	return;
 }
@@ -277,7 +279,7 @@
 
 void TauArchon::animate(Frame *space)
 {
-STACKTRACE
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	if ((weapon_charge_counter &gt; 0) &amp;&amp; (aa &amp; AA_BLEND) &amp;&amp; !(aa &amp; AA_NO_AA)) 
 	{
@@ -302,6 +304,7 @@
 /*	Removed by Jad
 RGB TauArchon::crewPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {255, 255, 255};
 	return c;
 }
@@ -309,6 +312,7 @@
 
 RGB TauArchon::battPanelColor(int k)
 {
+  STACKTRACE;
 	RGB c = {85, 85, 255};
 	return c;
 }
@@ -316,7 +320,7 @@
 
 void TauArchon::calculate_hotspots()
 {
-STACKTRACE
+  STACKTRACE;
 	if((thrust) &amp;&amp; (hotspot_frame &lt;= 0)) {
 		game-&gt;add(new Animation( this, 
 				normal_pos() - unit_vector(angle) * 15,
@@ -335,6 +339,7 @@
 	Shot(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite),
 	min_damage(omindamage), fuel_sap(ofsap)
 {
+  STACKTRACE;
 	do_reactive_damage = oreactive;
 	explosionSprite     = data-&gt;spriteWeaponExplosion;
 	explosionFrameCount = 10;
@@ -379,7 +384,7 @@
 
 void TauArchonShot::calculate()
 {
-STACKTRACE
+  STACKTRACE;
 	Shot::calculate();
 
 	if (rotation_base) {
@@ -402,14 +407,14 @@
 
 void TauArchonShot::animate(Frame *space)
 {
-STACKTRACE
+  STACKTRACE;
 	if (exists())
 		sprite-&gt;animate(pos, index_base + (int)(19.89 * d / range), space);
 }
 
 void TauArchonShot::inflict_damage(SpaceObject *other)
 {
-STACKTRACE
+  STACKTRACE;
 	double d_f = damage_factor;
 
 	if (other-&gt;isShip()) 
@@ -496,6 +501,7 @@
 TauArchonFrozen::TauArchonFrozen(SpaceLocation *creator, SpaceObject *source, SpaceSprite *osprite) :
 	Shot(creator, 0, source-&gt;get_angle(), 0, 0, 999, source-&gt;mass, source, osprite, 1.0)
 {
+  STACKTRACE;
 	collide_flag_anyone = collide_flag_sameteam = collide_flag_sameship = ALL_LAYERS;
 	ally_flag = 0;
 	mass = source-&gt;mass;
@@ -528,11 +534,12 @@
 
 void TauArchonFrozen::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
 }
 
 void TauArchonFrozen::calculate()
 {
-STACKTRACE
+  STACKTRACE;
 
 	Shot::calculate();
 	if (length(vel-old_vel) &gt; scale_velocity(15+tw_random()%20))
@@ -545,7 +552,7 @@
 
 void TauArchonFrozen::animateExplosion()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!exploded_already) {
 		exploded_already = true;	
 		game-&gt;add(new Animation(this, normal_pos(),

Modified: trunk/source/ships/shptauda.cpp
===================================================================
--- trunk/source/ships/shptauda.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptauda.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -71,6 +71,7 @@
 TauDagger::TauDagger(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 
 	weaponRange			= scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponDamage		= get_config_float(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -86,14 +87,14 @@
 
 int TauDagger::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	game-&gt;add(new TauDaggerBeam(this, Vector2(0,30), weaponRange, weaponDamage, iround(weaponFrameCount), angle));
 	return true;
 }
 
 int TauDagger::activate_special()
 {
-	STACKTRACE
+  STACKTRACE;
 
 	game-&gt;add(new TauDaggerShot(this, Vector2(0,55), angle, specialVelocity,
 			specialDamage, specialRange, specialArmour, data-&gt;spriteSpecial));
@@ -110,6 +111,7 @@
 	frame(0), frame_count(lfcount), lpos(creator), rel_pos(rpos)
 
 {
+  STACKTRACE;
 	if (ldamage &lt;= 0) collide_flag_anyone = 0;
 	set_depth(DEPTH_SHOTS);
 	base_length = length;
@@ -129,7 +131,7 @@
 
 void TauDaggerBeam::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	if((frame &lt; frame_count) &amp;&amp; (lpos-&gt;exists())) {
 		length = base_length;
 		pos = lpos-&gt;normal_pos() + rotate(rel_pos, lpos-&gt;get_angle() - PI/2);
@@ -148,7 +150,7 @@
 
 void TauDaggerBeam::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	damage(other, damage_factor*frame_time/frame_count);
 
 	int aa = get_tw_aa_mode();
@@ -163,7 +165,7 @@
 
 void TauDaggerBeam::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	int aa = get_tw_aa_mode();
 	SpaceLine::animate(space);
 	if ((aa &amp; AA_BLEND) &amp;&amp; (aa &amp; AA_ALPHA) &amp;&amp; !(aa &amp; AA_NO_AA) &amp;&amp; (length &lt; base_length*0.9999) &amp;&amp; (target)) {
@@ -180,6 +182,7 @@
 		double ov, double odamage, double orange, double oarmour, SpaceSprite *osprite) :
 	Missile(creator, opos, oangle, ov, odamage, orange, oarmour, creator, osprite)
 {
+  STACKTRACE;
 	explosionSprite     = data-&gt;spriteSpecialExplosion;
 	explosionFrameCount = 20;
 	explosionFrameSize  = 25;
@@ -192,7 +195,7 @@
 
 void TauDaggerShot::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	sprite-&gt;animate(pos, sprite_index + 64 * s_ind, space);
 	s_ind = (s_ind + 1) % 2;
 }

Modified: trunk/source/ships/shptaume.cpp
===================================================================
--- trunk/source/ships/shptaume.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptaume.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -75,6 +75,7 @@
 TauMercury::TauMercury(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
 	Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
 	weaponRange		= scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponVelocity	= scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
     weaponDamage	= get_config_float(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -106,7 +107,7 @@
 
 int TauMercury::activate_weapon()
 {
-	STACKTRACE
+  STACKTRACE;
 	double da = (1-0.002*(random()%1001));
 	if (da &gt;= 0)
 		da *= da;
@@ -121,7 +122,7 @@
 
 void TauMercury::calculate_turn_right()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (turn_right) {
 		bank_position += bank_max * frame_time / bank_time;
 		if (!turn_lag)
@@ -130,7 +131,7 @@
 
 void TauMercury::calculate_turn_left()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (turn_left) {
 		bank_position -= bank_max * frame_time / bank_time;
 		if (!turn_lag)
@@ -139,7 +140,7 @@
 
 void TauMercury::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	double vl;
 	bool locked_rail = false;
 
@@ -214,7 +215,7 @@
 
 int TauMercury::accelerate(SpaceLocation *source, double angle, double velocity, double max_speed)
 {
-	STACKTRACE
+  STACKTRACE;
 	double ov;
 	double nvs, nvl;
 
@@ -240,7 +241,7 @@
 
 void TauMercury::calculate_hotspots()
 {
-	STACKTRACE
+  STACKTRACE;
 	if((thrust) &amp;&amp; (hotspot_frame &lt;= 0)) {
 		game-&gt;add(new Animation( this, 
 				normal_pos() - unit_vector(angle) * 14,
@@ -252,11 +253,12 @@
 
 void TauMercury::calculate_thrust()
 {
+  STACKTRACE;
 }
 
 void TauMercury::calculate_fire_special()
 {
-	STACKTRACE
+  STACKTRACE;
 	special_low = FALSE;
 	if (!fire_special)
 		return;
@@ -301,6 +303,7 @@
 	AnimatedShot(creator, Vector2(ox,oy), oangle, ov, odamage, orange, oarmour, creator, osprite, 10, 50, relativity),
 	sparks(osparks), frags(ofrags)
 {
+  STACKTRACE;
 		if (frags)
 		  {
 		    //			explosionSample = data-&gt;sampleWeapon[1];
@@ -310,7 +313,7 @@
 
 void TauMercuryShot::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	int si = sprite_index;
 	AnimatedShot::calculate();
 	
@@ -343,7 +346,7 @@
 
 void TauMercuryShot::animateExplosion()
 {
-	STACKTRACE
+  STACKTRACE;
 	if (!frags) {
 		Shot::animateExplosion();
 		return; }
@@ -389,7 +392,7 @@
 
 void TauMercurySpark::calculate()
 {
-	STACKTRACE
+  STACKTRACE;
 	lifetime -= frame_time;
 	if (lifetime &lt;= 0)
 		state = 0;
@@ -399,14 +402,14 @@
 
 void TauMercurySpark::inflict_damage(SpaceObject *other)
 {
-	STACKTRACE
+  STACKTRACE;
 	SpaceLine::inflict_damage(other);
 	state =0;
 }
 
 void TauMercurySpark::animate(Frame *space)
 {
-	STACKTRACE
+  STACKTRACE;
 	drawing_mode(DRAW_MODE_TRANS, NULL, 0, 0);
 
 	double c = lifetime/(double)lifetime_max;

Modified: trunk/source/ships/shptausl.cpp
===================================================================
--- trunk/source/ships/shptausl.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptausl.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -125,6 +125,7 @@
 
 int TauSlider::activate_weapon()
 {
+  STACKTRACE;
         if (in_jump) return false;
         add(new TauSliderLaser(+21, 15, angle - 15*ANGLE_RATIO,
                           weaponVelocity, weaponRange, weaponLength, this));
@@ -140,6 +141,7 @@
 
 void TauSlider::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = false;
 
   if (fire_special) 
@@ -181,6 +183,7 @@
 
 int TauSlider::activate_special()
 {
+  STACKTRACE;
   if (special_charge &gt;= critical_charge) 
     {
       in_jump = true;
@@ -207,6 +210,7 @@
 
 void TauSlider::calculate()
 {
+  STACKTRACE;
         just_exited = false;
         Ship::calculate();
         if (in_jump) {
@@ -228,6 +232,7 @@
 }
 
 int TauSlider::handle_damage(SpaceLocation *source, int normal, int direct) {
+  STACKTRACE;
         if (in_jump) {
                 return 0; }
         if (just_exited &amp;&amp; source-&gt;isPlanet())
@@ -237,23 +242,27 @@
 
 int TauSlider::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
         return ((!in_jump)&amp;&amp;Ship::canCollide(other));
 }
 
 int TauSlider::translate(double dx, double dy)
 {
+  STACKTRACE;
         if (!in_jump) return Ship::translate(dx, dy);
 				return false;
 }
 
 int TauSlider::accelerate(SpaceLocation *source, double oangle, double vel, double omax_speed)
 {
+  STACKTRACE;
         if (!in_jump) return Ship::accelerate(source, oangle, vel, omax_speed);
 				return false;
 }
 
 void TauSlider::animate(Frame* space)
 {
+  STACKTRACE;
         int i,j,r,g,b;
         double a;
         for (i=max_trace_number; i&gt;=0; i--) {
@@ -280,11 +289,13 @@
 
 int TauSlider::isProtected()
 {
+  STACKTRACE;
         return (in_jump);
 }
 
 void TauSlider::calculate_hotspots()
 {
+  STACKTRACE;
         if (!in_jump) Ship::calculate_hotspots();
 }
 
@@ -308,6 +319,7 @@
 
 void TauSliderLaser::calculate()
 {
+  STACKTRACE;
         double a = (d) / range;
         int r = (int)floor(255 - a*400);
         if (r &lt; 0) r = 0;
@@ -323,6 +335,7 @@
 
 void TauSliderLaser::inflict_damage(SpaceObject *other)
 {
+  STACKTRACE;
         SpaceLine::inflict_damage(other);
         state = 0;
 }
@@ -331,6 +344,7 @@
 TauSliderTrace::TauSliderTrace(Ship* oship) :
         SpaceLocation(oship, oship-&gt;normal_pos(), oship-&gt;get_angle())
 {
+  STACKTRACE;
         collide_flag_anyone = 0;
         lifetime = 0;
         //vx = oship-&gt;get_vx();
@@ -341,6 +355,7 @@
 
 void TauSliderTrace::calculate()
 {
+  STACKTRACE;
         if ((lifetime += frame_time) &gt;= trace_lifetime)
                 state = 0;
 }

Modified: trunk/source/ships/shptaust.cpp
===================================================================
--- trunk/source/ships/shptaust.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptaust.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -70,6 +70,7 @@
 TauStorm::TauStorm(Vector2 opos, double shipAngle, ShipData *shipData, unsigned int code) :
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   
   weaponMass = get_config_float(&quot;Weapon&quot;, &quot;Mass&quot;, 0.01);
   
@@ -105,6 +106,7 @@
 
 int TauStorm::activate_weapon()
 {
+  STACKTRACE;
   int rx;
   if (slot&lt;2)	
     rx = 9;
@@ -123,6 +125,7 @@
 
 int TauStorm::activate_special()
 {
+  STACKTRACE;
   int rx;
   if (slot&lt;2)	rx = 9;
   else rx = 13;
@@ -141,6 +144,7 @@
 
 void TauStorm::animate(Frame *space)
 {
+  STACKTRACE;
   if (thrust)
     sprite-&gt;animate(pos, sprite_index + 64, space);
   else
@@ -177,6 +181,7 @@
 
 void TauStormMissile::calculate()
 {
+  STACKTRACE;
   if (latched) 
     {
       if (!latched-&gt;exists())
@@ -247,6 +252,7 @@
 
 int TauStormMissile::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
   if (other == latched) return false;
   return Shot::canCollide(other);
 }

Modified: trunk/source/ships/shptauto.cpp
===================================================================
--- trunk/source/ships/shptauto.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shptauto.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -77,6 +77,7 @@
         Ship(opos, shipAngle, shipData, code)
 
 {
+  STACKTRACE;
         weaponRange     = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
         weaponVelocity  = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
         weaponDamage    = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -106,6 +107,7 @@
 
 int TauTor::activate_weapon()
 {
+  STACKTRACE;
         if (transition_count &gt; 0) return false;
 
         if (TauTor_state) {
@@ -125,6 +127,7 @@
 
 void TauTor::calculate_fire_special()
 {
+  STACKTRACE;
   special_low = false;
   if (fire_special &amp;&amp; can_switch &amp;&amp; (transition_count &lt;=0)) 
     {
@@ -155,6 +158,7 @@
 
 void TauTor::calculate()
 {
+  STACKTRACE;
   if (transition_count &gt; 0) 
     {
       if ((transition_count -= frame_time) &lt;= 0) 
@@ -188,6 +192,7 @@
 
 void TauTor::calculate_thrust()
 {
+  STACKTRACE;
   if (thrust &amp;&amp; (transition_count &lt;=0)) 
     {
       if (TauTor_state &amp;&amp; (batt &gt; 0)) 
@@ -226,6 +231,7 @@
   AnimatedShot(creator, opos, oangle, ov, odamage, orange, oarmour,
 	       lpos, osprite, ofcount, ofsize, relativity)
 {
+  STACKTRACE;
   explosionSprite     = data-&gt;spriteWeaponExplosion;
   explosionFrameCount = 12;
   explosionFrameSize  = 50;
@@ -238,6 +244,7 @@
         AnimatedShot(creator, opos, oangle, ov, odamage, orange, oarmour,
 		     lpos, osprite, ofcount, ofsize, relativity)
 {
+  STACKTRACE;
   explosionSprite     = data-&gt;spriteSpecialExplosion;
   explosionFrameCount = 12;
   explosionFrameSize  = 50;

Modified: trunk/source/ships/shpwolmi.cpp
===================================================================
--- trunk/source/ships/shpwolmi.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpwolmi.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -74,6 +74,7 @@
 :
 Ship(opos,  shipAngle, shipData, code)
 {
+  STACKTRACE;
 	
 	weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
 	weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
@@ -87,8 +88,8 @@
 
 
 int Wolly::activate_weapon()
-{	
-	STACKTRACE;
+{
+  STACKTRACE;
 	
 
 	Vector2 rpos;
@@ -105,7 +106,7 @@
 
 int Wolly::activate_special()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	WollyMine *o;
 	Vector2 rpos;
@@ -129,6 +130,7 @@
 :
 Shot(creator, rpos, oangle, ov, odamage, orange, oarmour, opos, osprite, relativity)
 {
+  STACKTRACE;
 	default_range = orange;
 
 	collide_flag_anyone = ALL_LAYERS;
@@ -140,7 +142,7 @@
 
 int WollyPlasma::handle_damage(SpaceLocation *source, double normal, double direct)
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	armour += normal + direct;
 
@@ -164,7 +166,7 @@
 
 void WollyPlasma::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 	
 	Shot::calculate();
 
@@ -191,6 +193,7 @@
 
 int WollyPlasma::canCollide(SpaceLocation *other)
 {
+  STACKTRACE;
 	if (other-&gt;id == ID_WOLLYPLASMA)
 		return FALSE;
 		
@@ -206,6 +209,7 @@
 :
 SpaceObject(creator, opos, oangle, osprite)
 {
+  STACKTRACE;
 	lifetime = olifetime;
 	existtime = 0;
 
@@ -225,6 +229,7 @@
 
 void WollyMine::calculate()
 {
+  STACKTRACE;
 	SpaceObject::calculate();
 
 	existtime += frame_time * 1E-3;
@@ -239,6 +244,7 @@
 
 int WollyMine::handle_damage(SpaceLocation *source, double normal, double direct)
 {
+  STACKTRACE;
 	state = 0;
 	return true;
 }

Modified: trunk/source/ships/shpyusra.cpp
===================================================================
--- trunk/source/ships/shpyusra.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpyusra.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -68,6 +68,7 @@
   ShipData *shipData, unsigned int code ):
   Ship( opos, shipAngle, shipData, code )
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
   weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -77,7 +78,7 @@
 }
 
 int YushRanger::activate_weapon(){
-	STACKTRACE
+  STACKTRACE;
   if( weaponObject ) return FALSE;
   game-&gt;add( weaponObject = new YushSpear( this, Vector2(0, 0.5*get_size().y), angle, weaponVelocity,
     weaponDamage, weaponRange, weaponArmour, weaponControl, this, data-&gt;spriteWeapon ));
@@ -85,7 +86,7 @@
 }
 
 int YushRanger::activate_special(){
-	STACKTRACE;
+  STACKTRACE;
 	double alpha = atan3(vel.y, vel.x);
 	alpha = normalize(alpha, PI2);
 	double v = vel.length();		//sqrt( vx*vx + vy*vy );
@@ -106,17 +107,17 @@
 }
 
 void YushRanger::calculate_turn_left(){
-	STACKTRACE;
+  STACKTRACE;
 	if( !fire_weapon ) Ship::calculate_turn_left();
 }
 
 void YushRanger::calculate_turn_right(){
-	STACKTRACE;
+  STACKTRACE;
   if( !fire_weapon ) Ship::calculate_turn_right();
 }
 
 void YushRanger::calculate(){
-	STACKTRACE;
+  STACKTRACE;
   Ship::calculate();
   if( weaponObject ){
     if( !weaponObject-&gt;exists() || weaponObject-&gt;released ){
@@ -136,11 +137,12 @@
 control( ocontrol ), 
 released( false )
 {
+  STACKTRACE;
 }
 
 void YushSpear::calculate()
 {
-	STACKTRACE;
+  STACKTRACE;
 
 	if (latched)
 	{
@@ -190,11 +192,13 @@
 }
 
 void YushSpear::release(){
+  STACKTRACE;
 	released = true;
 }
 
 void YushSpear::inflict_damage( SpaceObject* other )
 {
+  STACKTRACE;
   if( latched || other-&gt;isShot() ) return;
   if( !other-&gt;isAsteroid() ) Shot::inflict_damage( other );
   state = 1;                   // don't want to die on contact
@@ -212,6 +216,7 @@
 
 int YushSpear::handle_damage( SpaceLocation* other, double normal, double direct )
 {
+  STACKTRACE;
   if( latched )
     {
       latched-&gt;handle_damage( other, normal, direct );

Modified: trunk/source/ships/shpzeksh.cpp
===================================================================
--- trunk/source/ships/shpzeksh.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/ships/shpzeksh.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -60,6 +60,7 @@
 	:
   Ship(opos, shipAngle, shipData, code)
 {
+  STACKTRACE;
   weaponRange    = scale_range(get_config_float(&quot;Weapon&quot;, &quot;Range&quot;, 0));
   weaponVelocity = scale_velocity(get_config_float(&quot;Weapon&quot;, &quot;Velocity&quot;, 0));
   weaponDamage   = get_config_int(&quot;Weapon&quot;, &quot;Damage&quot;, 0);
@@ -76,6 +77,7 @@
 
 int ZekfahanShocker::activate_weapon()
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(data-&gt;sampleWeapon[0]));
   tw_sound.play_sound(data_full_path(data-&gt;sampleWeapon[0]));
   
@@ -88,6 +90,7 @@
 
 int ZekfahanShocker::activate_special() 
 {
+  STACKTRACE;
   if(shockingFrames == 0)
     {
       tw_sound.stop_sound(data_full_path(data-&gt;sampleSpecial[0]));
@@ -101,7 +104,8 @@
 }
 
 void ZekfahanShocker::calculate()
-{ 
+{
+  STACKTRACE; 
   if(shockVar == 1)
   {
     if(shockingFrames &gt; 0) 
@@ -133,11 +137,13 @@
   SpaceSprite *osprite, int ofcount, int ofsize) :
   AnimatedShot(oship, oposvec, oangle, ov, odamage, orange, oarmour, oship, osprite, ofcount, ofsize)
 {
+  STACKTRACE;
   collide_flag_anyone = (ALL_LAYERS);
 }
 
 void Shockwave::inflict_damage(SpaceObject *other) 
 {
+  STACKTRACE;
   tw_sound.stop_sound(data_full_path(data-&gt;sampleSpecial[2]));
   tw_sound.play_sound(data_full_path(data-&gt;sampleSpecial[2]));
  

Modified: trunk/source/twgui/twbutton.cpp
===================================================================
--- trunk/source/twgui/twbutton.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twbutton.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -31,6 +31,7 @@
 
 EmptyButton::EmptyButton(TWindow *menu, char *identbranch, int asciicode, bool akeepkey)
 {
+  STACKTRACE;
   prev = 0;
   next = 0;
   selected = false;
@@ -78,6 +79,7 @@
 
 bool EmptyButton::hasmouse()
 {
+  STACKTRACE;
   return (mainwindow-&gt;mpos.x &gt;= pos.x &amp;&amp;
 	  mainwindow-&gt;mpos.y &gt;= pos.y &amp;&amp;
 	  mainwindow-&gt;mpos.x &lt; (pos+size).x &amp;&amp;
@@ -88,11 +90,13 @@
 
 bool EmptyButton::haskey()
 {
+  STACKTRACE;
   return flag.haskey;
 }
 
 bool EmptyButton::haskeypress()
 {
+  STACKTRACE;
   return flag.haskeypress;
 }
 
@@ -102,6 +106,7 @@
 // made for the detection flag
 void EmptyButton::check_key()
 {
+  STACKTRACE;
   // this is usually the case.
   flag.haskey = false;
   flag.haskeypress = false;
@@ -157,7 +162,8 @@
 
 
 void EmptyButton::handle_focus()
-{	
+{
+  STACKTRACE;	
   //mainwindow-&gt;setfocus(this);
   
   //focus = 1;
@@ -169,7 +175,8 @@
 
 
 void EmptyButton::handle_defocus()
-{	
+{
+  STACKTRACE;	
   flag.focus = false;
   
   //	if (button_event)
@@ -179,6 +186,7 @@
 
 void EmptyButton::check_focus()
 {
+  STACKTRACE;
   flag.lastfocus = flag.focus;
   
   if (haskey())
@@ -215,6 +223,7 @@
 // calls to calculate aren't made...
 void EmptyButton::handle_menu_focus_loss()
 {
+  STACKTRACE;
   selected = 0;
   //update_key();
   flag.reset();
@@ -222,6 +231,7 @@
 
 void EmptyButton::calculate()
 {
+  STACKTRACE;
   
   // copy information from the TWindow manager
   //	update_mouse();
@@ -297,12 +307,14 @@
 
 void EmptyButton::animate()
 {
+  STACKTRACE;
 }
 	
 
 
 EmptyButton::flag_struct::flag_struct()
 {
+  STACKTRACE;
 	// these flags are updated by the area's calculate function.
 //	focus = 0;
 //	left_mouse_press = left_mouse_release = left_mouse_hold = 0;
@@ -313,6 +325,7 @@
 
 void EmptyButton::flag_struct::reset()
 {
+  STACKTRACE;
   // these flags are updated by the area's calculate function.
   focus = 0;
   left_mouse_press = left_mouse_release = left_mouse_hold = 0;
@@ -323,6 +336,7 @@
 
 bool EmptyButton::isvalid()
 {
+  STACKTRACE;
   return true;
 }
 
@@ -338,11 +352,13 @@
 :
 EmptyButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 //	mainwindow-&gt;scalepos(&amp;x, &amp;y);
 }
 
 void GraphicButton::locate(int ax, int ay)
 {
+  STACKTRACE;
   pos.x = ax;
   pos.y = ay;
   mainwindow-&gt;scalepos(&amp;pos);
@@ -355,6 +371,7 @@
 
 void GraphicButton::animate()
 {
+  STACKTRACE;
   // check if button 1 (left) releases -&gt; clicks for this item
   // unconditional drawing:
   if (flag.focus)
@@ -372,14 +389,17 @@
 
 void GraphicButton::draw_default()
 {
+  STACKTRACE;
 }
 
 void GraphicButton::draw_focus()
 {
+  STACKTRACE;
 }
 
 void GraphicButton::draw_selected()
 {
+  STACKTRACE;
 }
 
 
@@ -404,6 +424,7 @@
 // check a square area to see if it has the mouse on it.
 bool GraphicButton::hasmouse(BITMAP *bmpref)
 {
+  STACKTRACE;
   // first, check the square bitmap area
   if (EmptyButton::hasmouse())
     {
@@ -420,6 +441,7 @@
 
 void GraphicButton::draw_rect()
 {
+  STACKTRACE;
   BITMAP *b = mainwindow-&gt;drawarea;
   int x1, y1, x2, y2;
   
@@ -458,6 +480,7 @@
 
 void GraphicButton::draw_rect_fancy()
 {
+  STACKTRACE;
   BITMAP *b = mainwindow-&gt;drawarea;
   int x1, y1, x2, y2;
   
@@ -528,6 +551,7 @@
 
 void GraphicButton::draw_boundaries(BITMAP *bmpref)
 {
+  STACKTRACE;
   BITMAP *b = mainwindow-&gt;drawarea;
   
   int i, j;
@@ -574,6 +598,7 @@
 */
 void GraphicButton::locate_by_backgr(char *strid)
 {
+  STACKTRACE;
   char stron[128];
   strcpy(stron,  ident);
   strcat(stron,  strid);
@@ -629,6 +654,7 @@
 // obtain a bitmap, specific to this &quot;object&quot; :
 BITMAP *GraphicButton::getbmp(char *name)
 {
+  STACKTRACE;
   char streditbox[128];
   strcpy(streditbox,  ident);
   strcat(streditbox,  name);
@@ -641,6 +667,7 @@
 // obtain a bitmap using &quot;absolute&quot; path, so that it can come from anywhere...
 BITMAP *GraphicButton::getbmp_nobutton(char *name)
 {
+  STACKTRACE;
   // a background image is needed of course.
   return mainwindow-&gt;bmp(name);
 }
@@ -650,6 +677,7 @@
 
 void GraphicButton::init_pos_size(BITMAP **bmp_default, char *idstr)
 {
+  STACKTRACE;
   *bmp_default = getbmp(idstr);
   
   if (*bmp_default)
@@ -675,6 +703,7 @@
 
 bool GraphicButton::draw(BITMAP *b)
 {
+  STACKTRACE;
   if (b)
     {
       masked_blit(b, mainwindow-&gt;drawarea, 0, 0, pos.x, pos.y, b-&gt;w, b-&gt;h);

Modified: trunk/source/twgui/twbuttontypes.cpp
===================================================================
--- trunk/source/twgui/twbuttontypes.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twbuttontypes.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -36,6 +36,7 @@
 :
 GraphicButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	init_pos_size(&amp;bmp_default, &quot;default&quot;);
 
 	bmp_focus = getbmp(&quot;focus&quot;);
@@ -54,11 +55,13 @@
 // this is the default drawing (at rest):
 void Button::draw_default()
 {
+  STACKTRACE;
 	draw(bmp_default);
 }
 
 void Button::draw_focus()
 {
+  STACKTRACE;
 	if (!draw(bmp_focus))
 	{
 		draw_default();
@@ -68,6 +71,7 @@
 
 void Button::draw_selected()
 {
+  STACKTRACE;
 	if (!draw(bmp_selected))
 		draw_default();
 }
@@ -75,12 +79,14 @@
 
 bool Button::hasmouse()
 {
+  STACKTRACE;
 	return GraphicButton::hasmouse(bmp_default);
 }
 
 
 bool Button::isvalid()
 {
+  STACKTRACE;
 	return bmp_default != 0;
 };
 
@@ -91,6 +97,7 @@
 :
 GraphicButton(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	init_pos_size(&amp;backgr, &quot;backgr&quot;);
 
 	markfordeletion = true;
@@ -105,6 +112,7 @@
 
 void Area::changebackgr(char *fname)
 {
+  STACKTRACE;
 	BITMAP *newb;
 	//newb = getbmp(fname);
 	newb = getbmp_nobutton(fname);
@@ -122,6 +130,7 @@
 
 void Area::changebackgr(BITMAP *newb)
 {
+  STACKTRACE;
 	if (newb)
 	{
 		if (markfordeletion)
@@ -134,6 +143,7 @@
 
 void Area::overwritebackgr(BITMAP *newb, double scale, int col)
 {
+  STACKTRACE;
 	if (newb &amp;&amp; backgr)
 	{
 		clear_to_color(backgr, col);
@@ -146,12 +156,14 @@
 
 void Area::animate()
 {
+  STACKTRACE;
 	draw(backgr);
 }
 
 
 bool Area::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(backgr);
 }
@@ -159,6 +171,7 @@
 
 bool Area::isvalid()
 {
+  STACKTRACE;
 	return backgr != 0;
 };
 
@@ -175,6 +188,7 @@
 :
 Area(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 
 	//init_pos_size(&amp;backgr, &quot;backgr&quot;);
 
@@ -196,6 +210,7 @@
 
 void AreaTablet::animate()
 {
+  STACKTRACE;
 	blit(backgr, drawarea, 0, 0, 0, 0, iround(size.x), iround(size.y));
 
 	subanimate();
@@ -207,6 +222,7 @@
 
 void AreaTablet::subanimate()
 {
+  STACKTRACE;
 	// nothing; you can put extra drawing commands here, stuff that's drawn onto
 	// the background before being blitted onto the reserved area.
 }
@@ -214,6 +230,7 @@
 
 bool AreaTablet::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(backgr);
 }
@@ -221,6 +238,7 @@
 
 bool AreaTablet::isvalid()
 {
+  STACKTRACE;
 	return backgr != 0;
 };
 
@@ -237,6 +255,7 @@
 :
 GraphicButton(menu, identbranch, asciicode)
 {
+  STACKTRACE;
 	init_pos_size(&amp;bmp_on, &quot;on&quot;);
 	bmp_off = getbmp(&quot;off&quot;);
 
@@ -251,6 +270,7 @@
 
 void SwitchButton::draw_default()
 {
+  STACKTRACE;
 	if (state)
 		draw(bmp_on);
 	else
@@ -259,6 +279,7 @@
 
 void SwitchButton::draw_focus()
 {
+  STACKTRACE;
 	draw_default();
 	draw_rect_fancy();
 }
@@ -266,12 +287,14 @@
 // is the same as focus, cause a switch cannot be selected all the time !!
 void SwitchButton::draw_selected()
 {
+  STACKTRACE;
 	draw_focus();
 }
 
 
 void SwitchButton::calculate()
 {
+  STACKTRACE;
 	GraphicButton::calculate();
 
 	// determine if the state of the button is being changed by (some) interaction:
@@ -282,6 +305,7 @@
 
 bool SwitchButton::hasmouse()
 {
+  STACKTRACE;
 	// the first rough check whether it's in the boxed bitmap area
 	return GraphicButton::hasmouse(bmp_on);
 }
@@ -289,6 +313,7 @@
 
 bool SwitchButton::isvalid()
 {
+  STACKTRACE;
 	return bmp_on != 0;
 };
 
@@ -301,6 +326,7 @@
 :
 EmptyButton(menu)
 {
+  STACKTRACE;
 	passive = true;
 }
 GhostButton::~GhostButton()
@@ -315,6 +341,7 @@
 :
 AreaTablet(menu, identbranch, 255)
 {
+  STACKTRACE;
 	relpos = 0.0;	// between 0 and 1
 
 	button = getbmp(&quot;button&quot;);
@@ -354,6 +381,7 @@
 
 void ScrollBar::handle_lhold()
 {
+  STACKTRACE;
 	if (direction == ver)
 		pbutton = iround(mainwindow-&gt;mpos.y - pos.y);		// mouse pos relative in the little bar area
 	else
@@ -371,6 +399,7 @@
 
 void ScrollBar::subanimate()
 {
+  STACKTRACE;
 	AreaTablet::subanimate();
 
 	if (direction == ver)
@@ -382,6 +411,7 @@
 
 void ScrollBar::setrelpos(double arelpos)
 {
+  STACKTRACE;
 	if (relpos == arelpos)
 		return;
 
@@ -394,6 +424,7 @@
 
 void ScrollBar::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 }
 

Modified: trunk/source/twgui/twgui.cpp
===================================================================
--- trunk/source/twgui/twgui.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twgui.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -38,18 +38,21 @@
 :
 AreaTablet(menu, identbranch, asciicode, akeepkey)
 {
+  STACKTRACE;
 	scroll.setup(mainwindow, identbranch);//, &amp;scroll);
 }
 
 
 int AreaTabletScrolled::gety()
 {
+  STACKTRACE;
 	return scroll.yselect;
 }
 
 
 void AreaTabletScrolled::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 
 	scroll.calculate();
@@ -67,6 +70,7 @@
 :
 AreaTablet(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 	text = 0;
 
@@ -81,6 +85,7 @@
 
 void TextButton::set_text(char *newtext, int color)
 {
+  STACKTRACE;
 	if (newtext)
 	{
 		if (text &amp;&amp; strlen(text) &lt; strlen(newtext))
@@ -100,6 +105,7 @@
 
 void TextButton::subanimate()
 {
+  STACKTRACE;
 	int xcentre, ycentre;
 
 	xcentre = iround(size.x / 2);
@@ -125,6 +131,7 @@
 :
 AreaTabletScrolled(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 	Htxt = text_height(usefont);
 	text_color = makecol(0,0,0);
@@ -154,6 +161,7 @@
 
 void TextList::calculate()
 {
+  STACKTRACE;
 	AreaTablet::calculate();
 
 	scroll.calculate();
@@ -170,6 +178,7 @@
 
 void TextList::set_selected(int iy)
 {
+  STACKTRACE;
 //	yselected = iy;
 	if ( iy &gt;= 0 &amp;&amp; iy &lt; N )
 		scroll.yselect = iy;
@@ -179,6 +188,7 @@
 
 void TextList::clear_optionlist()
 {
+  STACKTRACE;
 	int i;
 
 	if (optionlist)			// delete an existing set of strings first.
@@ -200,6 +210,7 @@
 
 void TextList::set_optionlist(char **aoptionlist, int color)
 {
+  STACKTRACE;
 	int aN;
 
 	// in this case, where the number of elements in the list isn't explicitly
@@ -216,6 +227,7 @@
 
 void TextList::set_optionlist(char **aoptionlist, int aN, int color)
 {
+  STACKTRACE;
 	int i;
 
 	clear_optionlist();		// note that this resets N .
@@ -249,6 +261,7 @@
 
 void TextList::add_optionlist(char *newstr)
 {
+  STACKTRACE;
 	if (!optionlist)
 	{
 		Nreserved = 128;
@@ -277,6 +290,7 @@
 // if the mouse is clicked within the window:
 void TextList::handle_lpress()
 {
+  STACKTRACE;
 
 	int iy;
 	
@@ -304,12 +318,14 @@
 
 int TextList::getk()
 {
+  STACKTRACE;
 	return scroll.yselect;
 }
 
 // select and center the list on &quot;that&quot; item
 void TextList::handle_rpress()
 {
+  STACKTRACE;
 	
 	int iy;
 	
@@ -329,6 +345,7 @@
 
 void TextList::subanimate()
 {
+  STACKTRACE;
 
 	if (!optionlist || N == 0)
 		return;				// if it's an empty list
@@ -392,6 +409,7 @@
 :
 AreaTabletScrolled(menu, identbranch, 255)
 {
+  STACKTRACE;
 	usefont = afont;
 //	Htxt = text_height(usefont);
 	text_color = makecol(0,0,0);
@@ -425,6 +443,7 @@
 // the following could be used for editing text that's stored elsewhere
 void TextInfoArea::set_textinfo_unbuffered(char *newtext, int Nchars)
 {
+  STACKTRACE;
 	if (textinfo)
 		delete textinfo;
 
@@ -439,6 +458,7 @@
 // other external factors.
 void TextInfoArea::set_textinfo(char *newtext, int Nchars)
 {
+  STACKTRACE;
 
 	if (localcopy)
 		delete localcopy;
@@ -457,6 +477,7 @@
 
 void TextInfoArea::set_textinfo(char *atextinfo)
 {
+  STACKTRACE;
 	set_textinfo(atextinfo, strlen(atextinfo));
 }
 
@@ -464,6 +485,7 @@
 
 void TextInfoArea::subanimate()
 {
+  STACKTRACE;
 
 	text_mode(-1);
 
@@ -528,6 +550,7 @@
 :
 TextInfoArea(menu, identbranch, afont, atext, amaxtext)
 {
+  STACKTRACE;
 	//usefont = afont;
 	text = atext;
 	maxchars = amaxtext;	// a short line?
@@ -574,6 +597,7 @@
 
 void TextEditBox::set_textcolor(int c)
 {
+  STACKTRACE;
 	text_color = c;
 }
 
@@ -583,6 +607,7 @@
 // if the mouse button was pressed .. update text pos to current mouse cursor pos.
 void TextEditBox::handle_lpress()
 {
+  STACKTRACE;
 	// but only if the enter-key wasn't pressed (that can also intiate this?)
 	if (keyhandler.keyhit[KEY_ENTER])
 		return;
@@ -615,6 +640,7 @@
 
 void TextEditBox::text_reset(char *newtext, int N)
 {
+  STACKTRACE;
 	textinfo-&gt;textinfo = newtext;
 	text = newtext;
 	textinfo-&gt;Nchars = N;
@@ -624,6 +650,7 @@
 
 void TextEditBox::text_reset()
 {
+  STACKTRACE;
 
 	textinfo-&gt;reset(&amp;scroll);
 
@@ -643,6 +670,7 @@
 // this is, where text is detected and entered ... I think ....
 void TextEditBox::calculate()
 {
+  STACKTRACE;
 	if (textinfo-&gt;textinfo != text) {tw_error(&quot;text mismatch&quot;);}
 
 	TextInfoArea::calculate();
@@ -813,6 +841,7 @@
 
 void TextEditBox::subanimate()
 {
+  STACKTRACE;
 
 //	TextInfoArea::subanimate();
 
@@ -879,6 +908,7 @@
 
 char *TextEditBox::get_text()
 {
+  STACKTRACE;
 	return text;
 }
 
@@ -906,6 +936,7 @@
 :
 AreaTabletScrolled(menu, identbranch, akey)
 {
+  STACKTRACE;
 
 	scroll.set(0, 0, 1, 1, 1, 1);
 
@@ -945,6 +976,7 @@
 
 void MatrixIcons::set_iconinfo(BITMAP **alistIcon, double ascale)
 {
+  STACKTRACE;
 	listIcon = alistIcon;
 
 	// do nothing, if there are no data (doh)
@@ -990,6 +1022,7 @@
 // this is done just after mouse/key update, but before the handle* routines.
 void MatrixIcons::subcalculate()
 {
+  STACKTRACE;
 
 	// additionally, if there's mouse movement within this region, you should
 	// override settings of the scroll menu, namely, which particular icon is
@@ -1005,6 +1038,7 @@
 
 void MatrixIcons::subanimate()
 {
+  STACKTRACE;
 
 	int i, j;
 	int ix, iy;
@@ -1065,6 +1099,7 @@
 // this action is used to scroll left/right/up/down
 void MatrixIcons::handle_rpress()
 {
+  STACKTRACE;
 	int mx, my;
 	
 	// mouse position relative to the center of the item window:
@@ -1079,12 +1114,14 @@
 // select some icon :
 void MatrixIcons::handle_lpress()
 {
+  STACKTRACE;
 	selected = true;
 }
 
 
 int MatrixIcons::getk()
 {
+  STACKTRACE;
 	int k;
 	k = scroll.xselect + scroll.yselect * Nx;
 

Modified: trunk/source/twgui/twhelpers.cpp
===================================================================
--- trunk/source/twgui/twhelpers.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twhelpers.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -32,6 +32,7 @@
 
 ScrollControl::ScrollControl()
 {
+  STACKTRACE;
 	x = 0;
 	y = 0;
 
@@ -47,6 +48,7 @@
 void ScrollControl::set(int xscroll, int yscroll, int Nxscroll, int Nyscroll,
 						int Nx_show, int Ny_show)
 {
+  STACKTRACE;
 	x = xscroll;	// this is top-left corner item of the visible screen
 	y = yscroll;
 
@@ -74,6 +76,7 @@
 
 void ScrollControl::check_pos()
 {
+  STACKTRACE;
 	// check the scroll position
 	if (x &gt; Nx-1)
 		x = Nx-1;
@@ -106,6 +109,7 @@
 
 void ScrollControl::add(int dx, int dy)
 {
+  STACKTRACE;
 	x += dx;
 	y += dy;
 
@@ -116,6 +120,7 @@
 
 void ScrollControl::check_sel()
 {
+  STACKTRACE;
 	if (xselect &lt; x)
 		x = xselect;
 
@@ -133,6 +138,7 @@
 
 void ScrollControl::set_sel(int xsel, int ysel)
 {
+  STACKTRACE;
 	xselect = xsel;
 	yselect = ysel;
 
@@ -145,18 +151,21 @@
 // alpha is a value between 0 and 1
 void ScrollControl::set_percent_pos_x(double alpha)
 {
+  STACKTRACE;
 	x = iround( (Nx-1) * alpha );
 	check_pos();
 }
 
 void ScrollControl::set_percent_pos_y(double alpha)
 {
+  STACKTRACE;
 	y = iround( (Ny-1) * alpha );
 	check_pos();
 }
 
 void ScrollControl::set_pos(int xnew, int ynew)
 {
+  STACKTRACE;
 	if ( xnew &gt;= 0 &amp;&amp; xnew &lt; Nx &amp;&amp; ynew &gt;= 0 &amp;&amp; ynew &lt; Ny )
 	{
 		x = xnew;
@@ -175,6 +184,7 @@
 // vertical, or a default value.
 double ScrollControl::get_relpos()
 {
+  STACKTRACE;
 	if (scrollhor)
 		return scrollhor-&gt;relpos;
 	if (scrollvert)
@@ -186,6 +196,7 @@
 
 void ScrollControl::calculate()
 {
+  STACKTRACE;
 	int xold, yold;
 
 	xold = x;
@@ -247,6 +258,7 @@
 								EmptyButton *aup, EmptyButton *adown,
 								ScrollBar *ascrollhor, ScrollBar *ascrollvert)
 {
+  STACKTRACE;
 	left = aleft;
 	right = aright;
 	up = aup;
@@ -355,6 +367,7 @@
 
 TextInfo::TextInfo(FONT *afont, BITMAP *abmp, char *atextinfo, int aNchars)
 {
+  STACKTRACE;
 	bmp = abmp;
 	usefont = afont;
 	textinfo = atextinfo;
@@ -374,6 +387,7 @@
 
 void TextInfo::reset(ScrollControl *scroll)
 {
+  STACKTRACE;
 
 	// &quot;initialize&quot; the text:
 	int n, len;
@@ -458,6 +472,7 @@
 // go from line-coordinate to bitmap coordinate
 void TextInfo::getxy(int charpos, int *x, int *y)
 {
+  STACKTRACE;
 	int iline;
 
 	iline = 0;
@@ -493,6 +508,7 @@
 // map (x) coordinate to character number
 int TextInfo::getcharpos(char *scantxt, int x, int max)
 {
+  STACKTRACE;
 	int i;
 	i = 0;
 
@@ -523,6 +539,7 @@
 // map (x,y) coordinate to character number
 int TextInfo::getcharpos(int x, int y)
 {
+  STACKTRACE;
 	int iline;
 
 	iline = y / Htxt;
@@ -563,6 +580,7 @@
 
 void TextInfo::changeline(int *charpos, int line1, int line2)
 {
+  STACKTRACE;
 
 	if (line2 &gt; Nlines-1)
 		line2 = Nlines-1;

Modified: trunk/source/twgui/twmenuexamples.cpp
===================================================================
--- trunk/source/twgui/twmenuexamples.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twmenuexamples.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -40,6 +40,7 @@
 :
 PopupT(creator, ident, axshift, ayshift)
 {
+  STACKTRACE;
 	// add a text list box
 	tia = new TextInfoArea(this, id2, afont, atext, aNchar);//, &amp;scroll);
 	//tia-&gt;set_textinfo(atext, aNchar);
@@ -62,6 +63,7 @@
 
 void PopupTextInfo::check_end()
 {
+  STACKTRACE;
 	if (closebutton-&gt;flag.left_mouse_press)
 		close(-1);
 }
@@ -75,12 +77,14 @@
 :
 PopupTextInfo(creator, ident, id2, axshift, ayshift, afont, atext, aNchar)
 {
+  STACKTRACE;
 };
 
 
 
 void PopupTextInfo_toggle::calculate()
 {
+  STACKTRACE;
 	PopupTextInfo::calculate();
 }
 
@@ -104,6 +108,7 @@
 :
 PopupT(ident, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 	tbl = new TextList(this, id2, afont);
 	tbl-&gt;set_optionlist(aoptionslist, makecol(0,0,0));
 
@@ -116,6 +121,7 @@
 :
 PopupT(atrigger, ident, axshift, ayshift)
 {
+  STACKTRACE;
 	//optionslist = aoptionslist;
 
 	// add a text list box
@@ -140,6 +146,7 @@
 // this calls close with return value
 void PopupList::check_end()
 {
+  STACKTRACE;
 	PopupT::check_end();		// this is also a way to end (without choosing anything)
 
 	if (tbl-&gt;selected)
@@ -164,6 +171,7 @@
 :
 Popup(ident, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 
 	icons = new MatrixIcons(this, &quot;icon_&quot;, KEY_ENTER);
 
@@ -198,6 +206,7 @@
 // (the general close is ok, it closes and hides the menu).
 void PopupFleetSelection::check_end()
 {
+  STACKTRACE;
 	if (icons-&gt;selected)
 		close(icons-&gt;getk());
 }
@@ -206,6 +215,7 @@
 
 void PopupFleetSelection::newscan(BITMAP **alistIcon, double ascale, char *txt)
 {
+  STACKTRACE;
 	Popup::newscan();
 	icons-&gt;set_iconinfo(alistIcon, ascale);
 	info-&gt;set_text(txt, makecol(255,255,0));
@@ -218,6 +228,7 @@
 // let the &quot;main&quot; routine determine whether to stop or not ;)
 void PopupFleetSelection::check_end()
 {
+  STACKTRACE;
 	if (icons-&gt;selected)
 		close(icons-&gt;getk());
 }
@@ -238,6 +249,7 @@
 			xcenter, ycenter,
 			outputscreen)
 {
+  STACKTRACE;
 	yes = new Button(this, &quot;yes_&quot;,KEY_Y);
 
 	no = new Button(this, &quot;no_&quot;, KEY_N);
@@ -251,6 +263,7 @@
 
 void PopupYN::check_end()
 {
+  STACKTRACE;
 	if (yes-&gt;flag.left_mouse_press)
 		close(1);
 	if (no-&gt;flag.left_mouse_press)
@@ -272,6 +285,7 @@
 			xcenter, ycenter,
 			outputscreen)
 {
+  STACKTRACE;
 	ok = new Button(this, &quot;ok_&quot;, KEY_ENTER);
 
 	exclusive = true;
@@ -283,6 +297,7 @@
 
 void PopupOk::check_end()
 {
+  STACKTRACE;
 	if (ok-&gt;flag.left_mouse_press)
 		close(1);
 }
@@ -300,6 +315,7 @@
 :
 PopupList(creator, ident, &quot;list_&quot;, axshift, ayshift, afont, 0)
 {
+  STACKTRACE;
 	strcpy(dir, &quot;.&quot;);	// you can't get below this (which is the game directory)
 	strcpy(fname, &quot;none&quot;);
 
@@ -321,6 +337,7 @@
 
 void FileBrowser::set_dir(char *newdir)
 {
+  STACKTRACE;
 	strcpy(dir, newdir);
 	reset_dirlist();
 }
@@ -329,6 +346,7 @@
 
 void FileBrowser::set_ext(char *ext)
 {
+  STACKTRACE;
 	strcpy(required_ext, &quot;.&quot;);
 	strcat(required_ext, ext);
 }
@@ -336,6 +354,7 @@
 
 void FileBrowser::reset_dirlist()
 {
+  STACKTRACE;
 	int err;
 	al_ffblk info;
 	
@@ -388,6 +407,7 @@
 
 void FileBrowser::calculate()
 {
+  STACKTRACE;
 	PopupList::calculate();
 
 	if (disabled)
@@ -438,6 +458,7 @@
 // this calls close with return value
 void FileBrowser::check_end()
 {
+  STACKTRACE;
 	if (selection)
 	{
 		selection = false;
@@ -465,6 +486,7 @@
 
 void ValueStr::set(valuetypes atype, char *adescr, double amin, double amax)
 {
+  STACKTRACE;
 	type = atype;
 	strncpy(descr, adescr, sizeof(descr)-1);
 	min = amin;
@@ -480,6 +502,7 @@
 
 double ValueStr::getval()
 {
+  STACKTRACE;
 	if (type == vtype_float)
 		return value;
 	else
@@ -493,6 +516,7 @@
 :
 EmptyButton(menu, identbranch)
 {
+  STACKTRACE;
 	Nmax = aNmax;
 	values = new ValueStr* [Nmax];
 
@@ -538,12 +562,14 @@
 
 void ValueEdit::edit_update()
 {
+  STACKTRACE;
 	sprintf(edit-&gt;text, values[isel]-&gt;format, values[isel]-&gt;value);
 }
 
 
 void ValueEdit::calculate()
 {
+  STACKTRACE;
 	EmptyButton::calculate();
 
 	// the scrollbar:

Modified: trunk/source/twgui/twpopup.cpp
===================================================================
--- trunk/source/twgui/twpopup.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twpopup.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -37,6 +37,7 @@
 :
 TWindow(ident, xcenter, ycenter, outputscreen)
 {
+  STACKTRACE;
 	movingthereserve = false;
 
 	center(xcenter, ycenter);		// center around this position, in relative coordinates
@@ -51,6 +52,7 @@
 
 void Popup::doneinit()
 {
+  STACKTRACE;
 	TWindow::doneinit();
 
 	hide();
@@ -61,12 +63,14 @@
 // (the general close is ok, it closes and hides the menu).
 void Popup::check_end()
 {
+  STACKTRACE;
 	// nothing
 }
 
 
 void Popup::calculate()
 {
+  STACKTRACE;
 	// must be called before the &quot;return&quot;, otherwise focus-loss isn't called
 	TWindow::calculate();
 
@@ -119,6 +123,7 @@
 
 void Popup::close(int areturnstatus)
 {
+  STACKTRACE;
 	hide();
 
 	returnstatus = areturnstatus;
@@ -130,6 +135,7 @@
 // resets its &quot;ready&quot; status as well.
 bool Popup::ready()
 {
+  STACKTRACE;
 	if (returnvalueready)
 	{
 		returnvalueready = false;
@@ -141,6 +147,7 @@
 // call this to get a int-value from some selection mechanism (eg a list)
 int Popup::getvalue()
 {
+  STACKTRACE;
 //	if (!returnvalueready)
 //		return -1;				// otherwise it's undefined
 
@@ -152,6 +159,7 @@
 // restore the ability to do calculations and actions
 void Popup::enable()
 {
+  STACKTRACE;
 	TWindow::enable();
 	returnvalueready = false;
 }
@@ -160,6 +168,7 @@
 
 void Popup::newscan()
 {
+  STACKTRACE;
 	show();	// (more general than enable)
 	ready();
 }
@@ -192,6 +201,7 @@
 :
 Popup(identbranch, axshift, ayshift, outputscreen)
 {
+  STACKTRACE;
 	trigger = 0;
 
 	init_components(identbranch);
@@ -206,6 +216,7 @@
 			axshift, ayshift,
 			atrigger-&gt;mainwindow-&gt;screen)
 {
+  STACKTRACE;
 	trigger = atrigger;
 
 	init_components(identbranch);
@@ -218,6 +229,7 @@
 
 void PopupT::init_components(char *id)
 {
+  STACKTRACE;
 	returnvalueready = false;
 
 	// and default option settings:
@@ -254,6 +266,7 @@
 
 void PopupT::calculate()
 {
+  STACKTRACE;
 	// must be called before the &quot;return&quot;, otherwise focus-loss isn't called
 	Popup::calculate();
 
@@ -319,6 +332,7 @@
 
 void PopupT::handle_focus_loss()
 {
+  STACKTRACE;
 	/*
 	if (!close_on_defocus)
 		return;
@@ -335,6 +349,7 @@
 
 void PopupT::close(int areturnstatus)
 {
+  STACKTRACE;
 	if (trigger)
 	{
 		// give back focus/control to the window that called this window.
@@ -353,6 +368,7 @@
 // you can (and should) replace this routine with one suited for your own purposes
 void PopupT::check_end()
 {
+  STACKTRACE;
 //	if (!hidden &amp;&amp; !hasfocus &amp;&amp; close_on_defocus)	// to prevent this from being called twice, due to recursive call to handle_focus() in hide()
 //	{
 		//tw_error(&quot;PopupList : Losing focus !!&quot;);

Modified: trunk/source/twgui/twwindow.cpp
===================================================================
--- trunk/source/twgui/twwindow.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/twwindow.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -47,6 +47,7 @@
 // this is used to scale them to other screen resolutions.
 TWindow::TWindow(char *identbase, int dx, int dy, BITMAP *outputscreen, bool vidwin)
 {
+  STACKTRACE;
 	prev = 0;
 	next = 0;
 
@@ -224,6 +225,7 @@
 
 TWindow *TWindow::tree_root()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current-&gt;prev)
@@ -235,6 +237,7 @@
 
 TWindow *TWindow::tree_last()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current-&gt;next)
@@ -247,6 +250,7 @@
 
 void TWindow::tree_calculate()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -273,6 +277,7 @@
 
 void TWindow::tree_animate()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_last();
 
@@ -292,6 +297,7 @@
 
 void TWindow::focus()
 {
+  STACKTRACE;
 	// no need if this already is the root ... cause then it already has the focus.
 	if (!prev)
 		return;
@@ -323,6 +329,7 @@
 
 void TWindow::tree_setscreen(BITMAP *scr)
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -338,6 +345,7 @@
 // add a window at the end of the window list
 void TWindow::add(TWindow *newwindow)
 {
+  STACKTRACE;
 	TWindow *current;
 	current = this;
 	while (current-&gt;next)
@@ -351,6 +359,7 @@
 // call all the clean up routines for all the menus
 void TWindow::tree_doneinit()
 {
+  STACKTRACE;
 	TWindow *current;
 	current = tree_root();
 
@@ -365,6 +374,7 @@
 
 bool TWindow::hasfocus()
 {
+  STACKTRACE;
 	// only the root has primary focus...
 	return (prev != 0);
 }
@@ -387,6 +397,7 @@
 
 BITMAP* TWindow::bmp(char *bmpname, bool vidmem)
 {
+  STACKTRACE;
 	BITMAP *bmp, *tmpbmp;
 	int bpp;
 
@@ -417,12 +428,14 @@
 
 void TWindow::doneinit()
 {
+  STACKTRACE;
 	del_bitmap(&amp;backgr_forsearch);
 	//if (datafile)			unload_datafile(datafile);
 }
 
 void TWindow::setscreen(BITMAP *scr)
 {
+  STACKTRACE;
 	screen = scr;
 }
 
@@ -430,6 +443,7 @@
 
 void TWindow::center(int xcenter, int ycenter)
 {
+  STACKTRACE;
 	// put back the background
 	//blit(originalscreen, screen, 0, 0, x, y, W, H);
 
@@ -446,6 +460,7 @@
 
 void TWindow::center_abs(int xcenter, int ycenter)
 {
+  STACKTRACE;
 	// put back the background
 	//blit(originalscreen, screen, 0, 0, x, y, W, H);
 
@@ -459,6 +474,7 @@
 
 void TWindow::center()
 {
+  STACKTRACE;
 	ASSERT(screen)
 	center(screen-&gt;w/2, screen-&gt;h/2);
 }
@@ -467,12 +483,14 @@
 // changes the &quot;disabled&quot; flag, and possibly does other stuff as well?
 void TWindow::enable()
 {
+  STACKTRACE;
 	disabled = false;
 //	mouse.reset();		// reset the mouse to the newest values.
 }
 
 void TWindow::disable()
 {
+  STACKTRACE;
 	if (!disabled)				// to prevent possible recursive call (disable can be called within focus loss in some cases...)
 	{
 		disabled = true;
@@ -484,6 +502,7 @@
 
 void TWindow::show()
 {
+  STACKTRACE;
 	hidden = false;	// allow animation
 	enable();		// allow calculation
 	focus();		// bring this window to the front of the list, so that it draws on top of the rest
@@ -491,6 +510,7 @@
 
 void TWindow::hide()
 {
+  STACKTRACE;
 	hidden = true;
 	disable();
 	//blit(originalscreen, screen, 0, 0, 0, 0, W, H);
@@ -500,6 +520,7 @@
 
 void TWindow::add(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (!button_first)
 	{
 		button_first = newbutton;
@@ -515,6 +536,7 @@
 
 void TWindow::rem(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (! newbutton)
 		return;
 
@@ -542,6 +564,7 @@
 
 bool TWindow::checkmouse()
 {
+  STACKTRACE;
 	if (!(prev &amp;&amp; prev-&gt;grabbedmouse))
 	{
 		// If the mouse hasn't been &quot;grabbed&quot; by a window above this window
@@ -569,6 +592,7 @@
 
 void TWindow::setfocus(EmptyButton *newbutton)
 {
+  STACKTRACE;
 	if (button_focus)
 		button_focus-&gt;handle_defocus();
 
@@ -582,6 +606,7 @@
 
 void TWindow::calculate()
 {
+  STACKTRACE;
 
 	if (disabled)
 	{
@@ -712,6 +737,7 @@
 
 void TWindow::animate()
 {
+  STACKTRACE;
 
 	if (hidden)
 		return;
@@ -761,6 +787,7 @@
 
 void TWindow::handle_focus()
 {
+  STACKTRACE;
 	// bring it first in the list ...
 	focus();
 }
@@ -768,6 +795,7 @@
 
 void TWindow::handle_focus_loss()
 {
+  STACKTRACE;
 	//for (int i = 0; i &lt; Nareas; ++i )
 	//	area[i]-&gt;handle_menu_focus_loss();
 	EmptyButton *button;
@@ -783,12 +811,14 @@
 
 void TWindow::scalepos(int *ax, int *ay)
 {
+  STACKTRACE;
 	(*ax) = iround( (*ax) * scale );
 	(*ay) = iround( (*ay) * scale );
 }
 
 void TWindow::scalepos(Vector2 *apos)
 {
+  STACKTRACE;
 	(apos-&gt;x) = iround( (apos-&gt;x) * scale );
 	(apos-&gt;y) = iround( (apos-&gt;y) * scale );
 }
@@ -838,6 +868,7 @@
 
 bool TWindow::search_bmp_location(BITMAP *bmp_default, Vector2 *apos)
 {
+  STACKTRACE;
 	ASSERT(bmp_default);
 	ASSERT(apos);
 	
@@ -908,6 +939,7 @@
 /*
 void TWindow::focus2other(TWindow *other)
 {
+  STACKTRACE;
 	disable();			// this menu won't generate signals now, but it'll be drawn still
 	other-&gt;show();
 	other-&gt;prev = this;
@@ -915,6 +947,7 @@
 
 void TWindow::back2other()
 {
+  STACKTRACE;
 	prev-&gt;enable();			// switch control back to the meleemenu
 	hide();					// this menu is disabled, and won't be drawn
 	prev = 0;
@@ -924,17 +957,20 @@
 
 void TWindow::update_time()
 {
+  STACKTRACE;
 	menu_time = get_time() - menu_starttime;
 }
 
 /*
 void TWindow::clear_keys()
 {
+  STACKTRACE;
 	keybuff_count = 0;
 }
 
 void TWindow::add_key(int akey)
 {
+  STACKTRACE;
 	if (disabled)
 		return;
 
@@ -948,6 +984,7 @@
 
 void TWindow::add_keys()
 {
+  STACKTRACE;
 	if (keyboard_needs_poll())
 		poll_keyboard();
 

Modified: trunk/source/twgui/utils.cpp
===================================================================
--- trunk/source/twgui/utils.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/twgui/utils.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -42,138 +42,128 @@
 // note, separated are the &quot;key&quot; and the extra &quot;control&quot; key (ctrl, alt)
 int mapkey(int scancode_key, int scancode_ctrl)
 {
-	int k;
+  int k;
 
-	k = scancode_key;
+  k = scancode_key;
 
-	k |= scancode_ctrl &lt;&lt; 8;
-	
-	// thus we have 2 scan codes, no more needed.
-	return k;
+  k |= scancode_ctrl &lt;&lt; 8;
+  
+  // thus we have 2 scan codes, no more needed.
+  return k;
 }
 
 int unmapkey1(int k)
 {
-	// return the 1st scancode
-	return k &amp; 0x0FF;
+  // return the 1st scancode
+  return k &amp; 0x0FF;
 }
 
 int unmapkey2(int k)
 {
-	// return the 1st scancode
-	return (k &gt;&gt; 8) &amp; 0x0FF;
+  // return the 1st scancode
+  return (k &gt;&gt; 8) &amp; 0x0FF;
 }
 
 
 BITMAP *find_datafile_bmp(DATAFILE *datafile, char *identif)
 {
-	char objname[128];
+  char objname[128];
+  
+  if (strlen(identif) &gt; 120)
+    {
+      tw_error(&quot;string exceeds max length&quot;);
+    }
+  
+  strcpy(objname, identif);
+  strcat(objname, &quot;_BMP&quot;);	// default extension for .bmp files.
 
-	if (strlen(identif) &gt; 120)
-	{
-		tw_error(&quot;string exceeds max length&quot;);
-	}
+  DATAFILE *dat = find_datafile_object(datafile, objname);
 
-	strcpy(objname, identif);
-	strcat(objname, &quot;_BMP&quot;);	// default extension for .bmp files.
-
-	DATAFILE *dat = find_datafile_object(datafile, objname);
-
-	if (!dat)
-	{
-		//char txt[512];
-		//sprintf(txt, &quot;Could not find %s&quot;, objname);
-		//tw_error(txt);
-		return 0;
-	}
-
-	if (dat-&gt;type == DAT_BITMAP)
-		return (BITMAP*) dat-&gt;dat;
-	else
-		return 0;
+  if (!dat)
+    {
+      //char txt[512];
+      //sprintf(txt, &quot;Could not find %s&quot;, objname);
+      //tw_error(txt);
+      return 0;
+    }
+  
+  if (dat-&gt;type == DAT_BITMAP)
+    return (BITMAP*) dat-&gt;dat;
+  else
+    return 0;
 }
 
 
 BITMAP *clone_bitmap(int bpp, BITMAP *src, double scale, bool vidmem)
 {
-	BITMAP *dest, *convert;
+  BITMAP *dest, *convert;
+  
+  if ( !src )
+    return 0;
 
-	if ( !src )
-		return 0;
+  int W, H;
+  
+  W = iround( src-&gt;w * scale );
+  H = iround( src-&gt;h * scale );
+  
+  dest = create_bitmap_ex(bpp, W, H);
+  
+  convert = create_bitmap_ex(bpp, src-&gt;w, src-&gt;h);
+  blit(src, convert, 0, 0, 0, 0, src-&gt;w, src-&gt;h);		// use this to convert color depth
+  
+  if (W != src-&gt;w || H != src-&gt;h )
+    stretch_blit(convert, dest, 0, 0, convert-&gt;w, convert-&gt;h, 0, 0, dest-&gt;w, dest-&gt;h);
+  else
+    blit(convert, dest, 0, 0, 0, 0, W, H);
+  
+  del_bitmap(&amp;convert);
 
-	int W, H;
 
-	W = iround( src-&gt;w * scale );
-	H = iround( src-&gt;h * scale );
-
-	dest = create_bitmap_ex(bpp, W, H);
-
-	convert = create_bitmap_ex(bpp, src-&gt;w, src-&gt;h);
-	blit(src, convert, 0, 0, 0, 0, src-&gt;w, src-&gt;h);		// use this to convert color depth
-
-	if (W != src-&gt;w || H != src-&gt;h )
-		stretch_blit(convert, dest, 0, 0, convert-&gt;w, convert-&gt;h, 0, 0, dest-&gt;w, dest-&gt;h);
-	else
-		blit(convert, dest, 0, 0, 0, 0, W, H);
-
-	del_bitmap(&amp;convert);
-
-
 	
-	// try to store this in memory, if there's enough room for it
-	// cause the menu-bitmaps are pretty large, and take lotsa time to draw ...
-	if (vidmem)
+  // try to store this in memory, if there's enough room for it
+  // cause the menu-bitmaps are pretty large, and take lotsa time to draw ...
+  if (vidmem)
+    {
+      convert = create_video_bitmap(W, H);
+      if (convert)
 	{
-		convert = create_video_bitmap(W, H);
-		if (convert)
-		{
-			blit(dest, convert, 0, 0, 0, 0, W, H);
-			del_bitmap(&amp;dest);
-			dest = convert;
-		}
+	  blit(dest, convert, 0, 0, 0, 0, W, H);
+	  del_bitmap(&amp;dest);
+	  dest = convert;
 	}
+    }
 	
-
-	return dest;
+  
+  return dest;
 }
 
-
-
-
-
-
-
-
-
-
-
 normalmouse::normalmouse()
 {
-	bmp.original_mouse_sprite = mouse_sprite;
-	bmp.newmousebmp = 0;
+  bmp.original_mouse_sprite = mouse_sprite;
+  bmp.newmousebmp = 0;
 
-	reset();
+  reset();
 }
 
 
 void normalmouse::reset()
 {
-	update();		// initialize with current mouse values.
-	pos2 = pos;
-	oldpos = pos;
+  update();		// initialize with current mouse values.
+  pos2 = pos;
+  oldpos = pos;
 }
 
 
 void normalmouse::copyinfo(normalmouse *othermouse)
 {
-	pos    = othermouse-&gt;pos;
-	oldpos = othermouse-&gt;oldpos;
-	pos2 = othermouse-&gt;pos2;
-	left   = othermouse-&gt;left;
-	mid    = othermouse-&gt;mid;
-	right  = othermouse-&gt;right;
-	bmp.newmousebmp = othermouse-&gt;bmp.newmousebmp;
-	bmp.original_mouse_sprite = othermouse-&gt;bmp.original_mouse_sprite;
+  pos    = othermouse-&gt;pos;
+  oldpos = othermouse-&gt;oldpos;
+  pos2 = othermouse-&gt;pos2;
+  left   = othermouse-&gt;left;
+  mid    = othermouse-&gt;mid;
+  right  = othermouse-&gt;right;
+  bmp.newmousebmp = othermouse-&gt;bmp.newmousebmp;
+  bmp.original_mouse_sprite = othermouse-&gt;bmp.original_mouse_sprite;
 }
 
 
@@ -182,134 +172,133 @@
 // (unmoved) position every iteration.
 void normalmouse::move(int dx, int dy)
 {
-	pos.x += dx;
-	pos.y += dy;
-
-	oldpos.x += dx;
-	oldpos.y += dy;
+  pos.x += dx;
+  pos.y += dy;
+	
+  oldpos.x += dx;
+  oldpos.y += dy;
 }
 
 int normalmouse::vx()
 {
-	return pos.x - oldpos.x;
+  return pos.x - oldpos.x;
 }
 
 int normalmouse::vy()
 {
-	return pos.y - oldpos.y;
+  return pos.y - oldpos.y;
 }
 
 
 void normalmouse::update()
 {
-	if (mouse_needs_poll())
-		poll_mouse();
+  if (mouse_needs_poll())
+    poll_mouse();
 	
-	oldpos = pos2;	// this is exactly the &quot;old&quot; position, unmoved
-	pos.set(mouse_x, mouse_y, mouse_z);
-	pos2 = pos;
-
-	int b = mouse_b;
-
-	left.update(bool(b &amp; 1));		// make distinction here; individual buttons shouldn't know of each other
-	mid.update(bool(b &amp; 4));
-	right.update(bool(b &amp; 2));
+  oldpos = pos2;	// this is exactly the &quot;old&quot; position, unmoved
+  pos.set(mouse_x, mouse_y, mouse_z);
+  pos2 = pos;
+  
+  int b = mouse_b;
+  
+  left.update(bool(b &amp; 1));		// make distinction here; individual buttons shouldn't know of each other
+  mid.update(bool(b &amp; 4));
+  right.update(bool(b &amp; 2));
 }
 
 
 void normalmouse::mousebutton::update(bool newstatus)
 {
-	// we are mainly interested in changes in the button status.
-	if (newstatus != button.status)
-	{
-		oldbutton = button;
-	
-		button.status = newstatus;	// on or of ;)
+  // we are mainly interested in changes in the button status.
+  if (newstatus != button.status)
+    {
+      oldbutton = button;
+      
+      button.status = newstatus;	// on or of ;)
 
-		if (button.status != oldbutton.status)
-			button.time = get_time() * 1E-3;				// detect timing of a change in button status
-
-		button.change = true;
-
-	} else
-		button.change = false;
+      if (button.status != oldbutton.status)
+	button.time = get_time() * 1E-3;				// detect timing of a change in button status
+      
+      button.change = true;
+      
+    } else
+      button.change = false;
 }
 
 
 
 bool normalmouse::mousebutton::press()
 {
-	if (!button.change)
-		return false;
-
-	if (button.status &amp;&amp; (!oldbutton.status))
-		return true;
-	else 
-		return false;
-
+  if (!button.change)
+    return false;
+  
+  if (button.status &amp;&amp; (!oldbutton.status))
+    return true;
+  else 
+    return false;
 }
 
 bool normalmouse::mousebutton::release()
 {
-	if (!button.change)
-		return false;
-
-	if ((!button.status) &amp;&amp; oldbutton.status)
-		return true;
-	else 
-		return false;
+  if (!button.change)
+    return false;
+  
+  if ((!button.status) &amp;&amp; oldbutton.status)
+    return true;
+  else 
+    return false;
 }
 
 bool normalmouse::mousebutton::dclick()
 {
-	if (!button.change)		// check if the mouse is clicked
-		return false;
+  if (!button.change)		// check if the mouse is clicked
+    return false;
+  
+  if (!button.status)		// check if the mouse button is pressed
+    return false;
+  
+  if (button.time - oldbutton.time &lt; 0.2)	// check time between release and press
+    return true;
+  
 
-	if (!button.status)		// check if the mouse button is pressed
-		return false;
-
-	if (button.time - oldbutton.time &lt; 0.2)	// check time between release and press
-		return true;
-	
-
-	return false;
+  return false;
 }
 
 bool normalmouse::mousebutton::hold()
 {
-	return button.status;
+  return button.status;
 }
 
 
 void normalmouse::bmpstr::init(BITMAP *newbmp)
 {
-	newmousebmp = newbmp;
+  newmousebmp = newbmp;
 }
 
 void normalmouse::bmpstr::set()
 {
-	if (newmousebmp)
-	{
-		set_mouse_sprite(newmousebmp);
-	}
+  if (newmousebmp)
+    {
+      set_mouse_sprite(newmousebmp);
+    }
 }
 
 void normalmouse::bmpstr::restore()
 {
-	set_mouse_sprite(original_mouse_sprite);
+  set_mouse_sprite(original_mouse_sprite);
 }
 
 void normalmouse::posstr::set(int xnew, int ynew, int znew)
 {
-	x = xnew;
-	y = ynew;
-	wheel = znew;
+  x = xnew;
+  y = ynew;
+  wheel = znew;
 }
 
 void normalmouse::posstr::move(int dx, int dy)
 {
-	x += dx;
-	y += dy;
+  x += dx;
+  y += dy;
 }
 
 
@@ -332,42 +321,42 @@
 // just make a copy of the input.
 static int my_callback(int key)
 {
-	keyhandler.add(key);
-	return key;
+  keyhandler.add(key);
+  return key;
 }
 
 
 
 TKeyHandler::TKeyHandler()
 {
-	keyboard_callback = my_callback;
-
-	clear();
+  keyboard_callback = my_callback;
+  
+  clear();
 }
 
 
 void TKeyHandler::clear()
 {
-	Nbuf = 0;
-	Nbackbuf = 0;
-
-	int i;
-	for ( i = 0; i &lt; KEY_MAX; ++i )
-	{
-		keynew[i] = key[i];
-		keyold[i] = key[i];
-	}
+  Nbuf = 0;
+  Nbackbuf = 0;
+  
+  int i;
+  for ( i = 0; i &lt; KEY_MAX; ++i )
+    {
+      keynew[i] = key[i];
+      keyold[i] = key[i];
+    }
 }
 
 
 void TKeyHandler::add(int key)
 {
-	if (Nbackbuf &gt;= buffmax)
-		return;
-
-	keybackbuf[Nbackbuf] = key;
-
-	++Nbackbuf;
+  if (Nbackbuf &gt;= buffmax)
+    return;
+  
+  keybackbuf[Nbackbuf] = key;
+  
+  ++Nbackbuf;
 }
 
 void TKeyHandler::clearbuf()
@@ -378,64 +367,64 @@
 
 void TKeyHandler::update()
 {
-	if (keyboard_needs_poll())
-		poll_keyboard();
-
-	// detect key changes ...
-	// (note that changes in-between updates are not seen by this so it's not 100% accurate)
-	int i;
-	for ( i = 0; i &lt; KEY_MAX; ++i )
+  if (keyboard_needs_poll())
+    poll_keyboard();
+  
+  // detect key changes ...
+  // (note that changes in-between updates are not seen by this so it's not 100% accurate)
+  int i;
+  for ( i = 0; i &lt; KEY_MAX; ++i )
+    {
+      // keep record of prev and new states
+      keyold[i] = keynew[i];
+      keynew[i] = key[i];
+      
+      // detect changes
+      keyhit[i] = 0;
+      keyreleased[i] = 0;
+      
+      if (keynew[i] != keyold[i])
 	{
-		// keep record of prev and new states
-		keyold[i] = keynew[i];
-		keynew[i] = key[i];
-
-		// detect changes
-		keyhit[i] = 0;
-		keyreleased[i] = 0;
-
-		if (keynew[i] != keyold[i])
-		{
-			if (keynew[i])
-				keyhit[i] = 1;
-			else
-				keyreleased[i] = 1;
-		}
-
+	  if (keynew[i])
+	    keyhit[i] = 1;
+	  else
+	    keyreleased[i] = 1;
 	}
-
-
-	Nbuf = Nbackbuf;
-	for ( i = 0; i &lt; Nbuf; ++i )
-	{
-		keybuf[i] = keybackbuf[i];
-	}
-	// reset the back-buffer for reading new stuf.
-	Nbackbuf = 0;
-
+      
+    }
+  
+  
+  Nbuf = Nbackbuf;
+  for ( i = 0; i &lt; Nbuf; ++i )
+    {
+      keybuf[i] = keybackbuf[i];
+    }
+  // reset the back-buffer for reading new stuf.
+  Nbackbuf = 0;
+  
 }
 
 
 bool TKeyHandler::pressed(char key)
 {
-	// only compare if the key != 0, otherwise you can get matches with
-	// wierd key combos or something. So, key==0 has the meaning of, don't compare me!
-	if (key == 0)
-		return false;
-
-	//char teststring[128];
-	int i;
-	for (i = 0; i &lt; Nbuf; ++i)
-	{
-		//teststring[i] = keybuf[i] &amp; 0x0FF;
-
-		if ( (keybuf[i] &amp; 0x0FF) == key )	// only compare by ascii code...
-			return true;
-	}
-
-	//teststring[i] = 0;
-	//message.out(teststring);
-
-	return false;
+  // only compare if the key != 0, otherwise you can get matches with
+  // wierd key combos or something. So, key==0 has the meaning of, don't compare me!
+  if (key == 0)
+    return false;
+  
+  //char teststring[128];
+  int i;
+  for (i = 0; i &lt; Nbuf; ++i)
+    {
+      //teststring[i] = keybuf[i] &amp; 0x0FF;
+      
+      if ( (keybuf[i] &amp; 0x0FF) == key )	// only compare by ascii code...
+	return true;
+    }
+  
+  //teststring[i] = 0;
+  //message.out(teststring);
+  
+  return false;
 }
 

Modified: trunk/source/util/base.cpp
===================================================================
--- trunk/source/util/base.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/base.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -44,6 +44,7 @@
 ------------------------------*/
 
 void BaseClass::preinit() {
+  STACKTRACE;
 	return;
 }
 BaseClass::~BaseClass() {
@@ -55,12 +56,14 @@
 	return ((void**)this);
 }
 int BaseClass::serialize(void *stream) {
+  STACKTRACE;
 	return 0;
 }
 int BaseClass::_get_size() const {
 	return 0;
 }
 void BaseClass::_event( Event *e) {
+  STACKTRACE;
 	return;
 }
 void BaseClass::issue_event ( std::list&lt;BaseClass*&gt;&amp; recipients, Event *e) {

Modified: trunk/source/util/errors.cpp
===================================================================
--- trunk/source/util/errors.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/errors.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -243,8 +243,8 @@
 	return;
 }
 
-std::stack&lt;SOURCE_LINE&gt; UserStackTraceHelper::call_stack;
-UserStackTraceHelper::UserStackTraceHelper( SOURCE_LINE srcline)
+std::stack&lt;SOURCE_LINE*&gt; UserStackTraceHelper::call_stack;
+UserStackTraceHelper::UserStackTraceHelper( SOURCE_LINE* srcline)
 {
   #ifdef DEBUG
   //  debug_log(GetStackNodeString(srcline).c_str());
@@ -258,32 +258,32 @@
   call_stack.pop();
 }
 
-std::string UserStackTraceHelper::GetStackNodeString(SOURCE_LINE stNode)
+std::string UserStackTraceHelper::GetStackNodeString(SOURCE_LINE* stNode)
 {
   std::string strFile;
-  char *_file = strstr(stNode.file, &quot;source&quot;);
+  char *_file = strstr(stNode-&gt;file, &quot;source&quot;);
   if (_file) 
     strFile = _file;
   
   char line[20] = {0};
-  sprintf(line, &quot;%d&quot;, stNode.line);
+  sprintf(line, &quot;%d&quot;, stNode-&gt;line);
       
   std::string strName;
-  if(stNode.name!=NULL)
-    strName = std::string(&quot; &quot;) + stNode.name;
+  if(stNode-&gt;name!=NULL)
+    strName = std::string(&quot; &quot;) + stNode-&gt;name;
   
-  return std::string(&quot;from: &quot;) + strFile + &quot;, line &quot; + line + &quot; funct: &quot; + stNode.funct + strName + &quot;\n&quot;;
+  return std::string(&quot;from: &quot;) + strFile + &quot;, line &quot; + line + &quot; funct: &quot; + stNode-&gt;funct + strName + &quot;\n&quot;;
 }
 
 std::string UserStackTraceHelper::get_stack_trace_string()
 {
   std::string stack_string = &quot;&quot;;
   
-  std::stack&lt;SOURCE_LINE&gt; tmp;
+  std::stack&lt;SOURCE_LINE*&gt; tmp;
   tmp = call_stack;
   while(!tmp.empty())
     {
-      SOURCE_LINE stNode = tmp.top();
+      SOURCE_LINE* stNode = tmp.top();
       stack_string += GetStackNodeString(stNode);
       tmp.pop();
     }

Modified: trunk/source/util/errors.h
===================================================================
--- trunk/source/util/errors.h	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/errors.h	2004-09-20 21:04:58 UTC (rev 60)
@@ -43,10 +43,10 @@
 /// be used to manage  call stack. 
 class UserStackTraceHelper 
 {
-  static std::stack&lt;SOURCE_LINE&gt; call_stack;
-  static std::string GetStackNodeString(SOURCE_LINE stNode);
+  static std::stack&lt;SOURCE_LINE*&gt; call_stack;
+  static std::string GetStackNodeString(SOURCE_LINE* stNode);
  public:
-  UserStackTraceHelper( SOURCE_LINE srcline);
+  UserStackTraceHelper( SOURCE_LINE* srcline);
   ~UserStackTraceHelper();
   
   /// \brief get stack trace string 
@@ -54,8 +54,8 @@
 };
 
 
-#define STACKTRACE SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, 0 }; UserStackTraceHelper _stacktrace_ ( _srcline );
-#define _STACKTRACE(A) SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, A }; UserStackTraceHelper _stacktrace_ ( _srcline );
+#define STACKTRACE static SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, 0 }; UserStackTraceHelper _stacktrace_ ( &amp;_srcline );
+#define _STACKTRACE(A) static SOURCE_LINE _srcline = { __LINE__, __FILE__, __FUNCTION__, A }; UserStackTraceHelper _stacktrace_ ( &amp;_srcline );
 
 
 extern &quot;C&quot; {

Modified: trunk/source/util/history.cpp
===================================================================
--- trunk/source/util/history.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/history.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -2,8 +2,8 @@
 #include &lt;math.h&gt;
 #include &quot;base.h&quot;
 #include &quot;history.h&quot;
+#include &quot;errors.h&quot;
 
-
 ////////////////////////////////////////////////////////////////////////
 //				Histograph stuff
 ////////////////////////////////////////////////////////////////////////
@@ -30,6 +30,7 @@
 */
 
 Histograph::Histograph(Uint16 max) {
+  STACKTRACE;
 	num = 0;
 	base = 0;
 	this-&gt;max = max;
@@ -42,9 +43,11 @@
 	delete[] element;
 }
 void Histograph::add_element(double v) {
+  STACKTRACE;
 	_add(v);
 }
 void Histograph::_add(double v) {
+  STACKTRACE;
 	int i;
 	if (num == max) {
 		num -= next_ratio;

Modified: trunk/source/util/random.cpp
===================================================================
--- trunk/source/util/random.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/random.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -41,9 +41,11 @@
 	ADDITIVE   = 123456789
 };
 Uint32 RNG_lcg64a::randi(Uint32 max) {
+  STACKTRACE;
 	return _rng_dist_32_flat(max, raw32());
 }
 Uint32 RNG_lcg64a::raw32() {
+  STACKTRACE;
 #	if defined(_MSC_VER) &amp;&amp; defined(__i386__) &amp;&amp; !defined(NO_ASM)
 		split_int_64 i64 = s64;
 		_asm { mov eax, [i64.s.high] } 
@@ -73,6 +75,7 @@
 	return s64.s.high;
 }
 Uint64 RNG_lcg64a::raw64() {
+  STACKTRACE;
 	Uint64 bob = raw32();
 	bob = (bob &lt;&lt; 32) | raw32();
 	return bob;
@@ -95,11 +98,13 @@
 }
 
 void RNG_lcg64a::seed( int s ) {
+  STACKTRACE;
 	s64.s.low = s;
 	s64.s.high = 0;
 	return;
 }
 void RNG_lcg64a::seed_more( int s ) {
+  STACKTRACE;
 	if (s64.s.high &amp; 0x80000000) raw32();
 	raw32();
 	s64.s.low += ((s64.s.high &gt;&gt; 27) | (s64.s.high &lt;&lt; 5)) ^ s;

Modified: trunk/source/util/sound.cpp
===================================================================
--- trunk/source/util/sound.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/sound.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,11 +24,12 @@
 
 #include &lt;allegro.h&gt;
 #include &quot;other/twconfig.h&quot;
+#include &quot;errors.h&quot;
 
-
 SoundSystem tw_sound;
 SoundSystem::SoundSystem(bool sound_on)
 {
+  STACKTRACE;
   mix_ok = false;
   current_music = &quot;&quot;;
   
@@ -96,6 +97,7 @@
   
 void SoundSystem::play_music(const std::string file, int loops)
 {
+  STACKTRACE;
   if(!mix_ok || current_music == file)
     return;
   
@@ -141,6 +143,7 @@
 
 void SoundSystem::play_sound(const std::string file, double vol)
 {
+  STACKTRACE;
   if(!mix_ok || sound_off)
     return;
   
@@ -180,6 +183,7 @@
 
 void SoundSystem::stop_sound(const std::string file)
 {
+  STACKTRACE;
   if(!mix_ok || sound_off)
     return;
   
@@ -201,6 +205,7 @@
 
 void SoundSystem::set_music_volume(double vol)
 {
+  STACKTRACE;
   if(!mix_ok)
     return;
   
@@ -230,6 +235,7 @@
 
 void SoundSystem::set_sound_volume(double vol)
 {
+  STACKTRACE;
   if(!mix_ok)
     return;
   
@@ -249,17 +255,20 @@
 
 double SoundSystem::load_music_volume()
 {
+  STACKTRACE;
   tw_set_config_file(&quot;client.ini&quot;);
   return get_config_float(&quot;Sound&quot;, &quot;MusicVolume&quot;, 0.5);
 }
 
 double SoundSystem::load_sound_volume()
 {
+  STACKTRACE;
   tw_set_config_file(&quot;client.ini&quot;);
   return get_config_float(&quot;Sound&quot;, &quot;SoundVolume&quot;, 0.5);
 }
 
 bool SoundSystem::playing_music()
 {
+  STACKTRACE;
   return Mix_PlayingMusic();
 }

Modified: trunk/source/util/vector2.cpp
===================================================================
--- trunk/source/util/vector2.cpp	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/source/util/vector2.cpp	2004-09-20 21:04:58 UTC (rev 60)
@@ -4,15 +4,21 @@
 #include &quot;vector2.h&quot;
 #include &quot;random.h&quot;
 #include &quot;round.h&quot;
+#include &quot;errors.h&quot;
 //#include &quot;../melee.h&quot;
 
-Vector2::Vector2(Vector2i v2i) : x(v2i.x), y(v2i.y) {}
+Vector2::Vector2(Vector2i v2i) : x(v2i.x), y(v2i.y) 
+{
+  STACKTRACE;
+}
 Vector2i Vector2::round()
 {
+  STACKTRACE;
 	return Vector2i(iround(x), iround(y));
 }
 Vector2i Vector2::truncate()
 {
+  STACKTRACE;
 	return Vector2i(int(x), int(y));
 }
 
@@ -71,6 +77,7 @@
 
 Vector3D::Vector3D(double ax, double ay, double az)
 {
+  STACKTRACE;
 	x = ax;
 	y = ay;
 	z = az;
@@ -78,16 +85,19 @@
 
 double Vector3D::dot(Vector3D v)
 {
+  STACKTRACE;
 	return x*v.x + y*v.y + z*v.z;
 }
 
 Vector3D Vector3D::cross(Vector3D b)
 {
+  STACKTRACE;
 	return Vector3D(y*b.z - z*b.y, -x*b.z + z*b.x, x*b.y - y*b.x);
 }
 
 void Vector3D::normalize()
 {
+  STACKTRACE;
 	double r;
 	r = sqrt(x*x + y*y + z*z);
 	x /= r;

Modified: trunk/web/index.html
===================================================================
--- trunk/web/index.html	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/web/index.html	2004-09-20 21:04:58 UTC (rev 60)
@@ -24,7 +24,6 @@
 &lt;/div&gt;
 
 &lt;div class=&quot;main&quot;&gt;
-  &lt;h2&gt;About&lt;/h2&gt;
   &lt;h3 class=&quot;important&quot;&gt;TW-Light&lt;/h3&gt;
   &lt;p class=&quot;indented&quot;&gt;
   TW-Light is an open source clone/sequel to the epic cross-genre game

Modified: trunk/web/style.css
===================================================================
--- trunk/web/style.css	2004-09-19 19:09:06 UTC (rev 59)
+++ trunk/web/style.css	2004-09-20 21:04:58 UTC (rev 60)
@@ -106,7 +106,7 @@
 .main {
   color: #ffffff;
   background-color: #001133;
-  background-image: url(./_background.jpg);
+/*  background-image: url(./bluepurplenebula2.jpg);*/
   margin-left: 1em;
   margin-right: 1em;
   margin-top: 1em;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000007.html">[Tw-light-svn] r59 - in trunk/source: . melee
</A></li>
	<LI>Next message: <A HREF="000009.html">[Tw-light-svn] r61 - in trunk: gamedata/default_ini/ships gamedata/ships source source/ais source/melee
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
