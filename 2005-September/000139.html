<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r193 - in trunk: . mingw-libs/include msvc-libs/include source/libraries source/libraries/boost source/libraries/boost/config source/libraries/boost/config/abi source/libraries/boost/config/compiler source/libraries/boost/config/platform source/libraries/boost/config/stdlib source/libraries/boost/detail
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r193%20-%20in%20trunk%3A%20.%20mingw-libs/include%20msvc-libs/include%20source/libraries%20source/libraries/boost%20source/libraries/boost/config%20source/libraries/boost/config/abi%20source/libraries/boost/config/compiler%20source/libraries/boost/config/platform%20source/libraries/boost/config/stdlib%20source/libraries/boost/detail&In-Reply-To=%3C200509240543.j8O5h0Dt013684%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000138.html">
   <LINK REL="Next"  HREF="000140.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r193 - in trunk: . mingw-libs/include msvc-libs/include source/libraries source/libraries/boost source/libraries/boost/config source/libraries/boost/config/abi source/libraries/boost/config/compiler source/libraries/boost/config/platform source/libraries/boost/config/stdlib source/libraries/boost/detail</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r193%20-%20in%20trunk%3A%20.%20mingw-libs/include%20msvc-libs/include%20source/libraries%20source/libraries/boost%20source/libraries/boost/config%20source/libraries/boost/config/abi%20source/libraries/boost/config/compiler%20source/libraries/boost/config/platform%20source/libraries/boost/config/stdlib%20source/libraries/boost/detail&In-Reply-To=%3C200509240543.j8O5h0Dt013684%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r193 - in trunk: . mingw-libs/include msvc-libs/include source/libraries source/libraries/boost source/libraries/boost/config source/libraries/boost/config/abi source/libraries/boost/config/compiler source/libraries/boost/config/platform source/libraries/boost/config/stdlib source/libraries/boost/detail">yurand at berlios.de
       </A><BR>
    <I>Sat Sep 24 07:43:00 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000138.html">[Tw-light-svn] r192 - in trunk: . gamedata/default_ini source source/libraries/jpgalleg source/other source/util
</A></li>
        <LI>Next message: <A HREF="000140.html">[Tw-light-svn] r194 - trunk/source/melee
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#139">[ date ]</a>
              <a href="thread.html#139">[ thread ]</a>
              <a href="subject.html#139">[ subject ]</a>
              <a href="author.html#139">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2005-09-24 07:41:48 +0200 (Sat, 24 Sep 2005)
New Revision: 193

Added:
   trunk/source/libraries/boost/
   trunk/source/libraries/boost/assert.hpp
   trunk/source/libraries/boost/checked_delete.hpp
   trunk/source/libraries/boost/config.hpp
   trunk/source/libraries/boost/config/
   trunk/source/libraries/boost/config/abi/
   trunk/source/libraries/boost/config/abi/borland_prefix.hpp
   trunk/source/libraries/boost/config/abi/borland_suffix.hpp
   trunk/source/libraries/boost/config/abi/msvc_prefix.hpp
   trunk/source/libraries/boost/config/abi/msvc_suffix.hpp
   trunk/source/libraries/boost/config/abi_prefix.hpp
   trunk/source/libraries/boost/config/abi_suffix.hpp
   trunk/source/libraries/boost/config/auto_link.hpp
   trunk/source/libraries/boost/config/compiler/
   trunk/source/libraries/boost/config/compiler/borland.hpp
   trunk/source/libraries/boost/config/compiler/comeau.hpp
   trunk/source/libraries/boost/config/compiler/common_edg.hpp
   trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp
   trunk/source/libraries/boost/config/compiler/digitalmars.hpp
   trunk/source/libraries/boost/config/compiler/gcc.hpp
   trunk/source/libraries/boost/config/compiler/greenhills.hpp
   trunk/source/libraries/boost/config/compiler/hp_acc.hpp
   trunk/source/libraries/boost/config/compiler/intel.hpp
   trunk/source/libraries/boost/config/compiler/kai.hpp
   trunk/source/libraries/boost/config/compiler/metrowerks.hpp
   trunk/source/libraries/boost/config/compiler/mpw.hpp
   trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp
   trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp
   trunk/source/libraries/boost/config/compiler/vacpp.hpp
   trunk/source/libraries/boost/config/compiler/visualc.hpp
   trunk/source/libraries/boost/config/platform/
   trunk/source/libraries/boost/config/platform/aix.hpp
   trunk/source/libraries/boost/config/platform/amigaos.hpp
   trunk/source/libraries/boost/config/platform/beos.hpp
   trunk/source/libraries/boost/config/platform/bsd.hpp
   trunk/source/libraries/boost/config/platform/cygwin.hpp
   trunk/source/libraries/boost/config/platform/hpux.hpp
   trunk/source/libraries/boost/config/platform/irix.hpp
   trunk/source/libraries/boost/config/platform/linux.hpp
   trunk/source/libraries/boost/config/platform/macos.hpp
   trunk/source/libraries/boost/config/platform/solaris.hpp
   trunk/source/libraries/boost/config/platform/win32.hpp
   trunk/source/libraries/boost/config/posix_features.hpp
   trunk/source/libraries/boost/config/requires_threads.hpp
   trunk/source/libraries/boost/config/select_compiler_config.hpp
   trunk/source/libraries/boost/config/select_platform_config.hpp
   trunk/source/libraries/boost/config/select_stdlib_config.hpp
   trunk/source/libraries/boost/config/stdlib/
   trunk/source/libraries/boost/config/stdlib/dinkumware.hpp
   trunk/source/libraries/boost/config/stdlib/libcomo.hpp
   trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp
   trunk/source/libraries/boost/config/stdlib/modena.hpp
   trunk/source/libraries/boost/config/stdlib/msl.hpp
   trunk/source/libraries/boost/config/stdlib/roguewave.hpp
   trunk/source/libraries/boost/config/stdlib/sgi.hpp
   trunk/source/libraries/boost/config/stdlib/stlport.hpp
   trunk/source/libraries/boost/config/stdlib/vacpp.hpp
   trunk/source/libraries/boost/config/suffix.hpp
   trunk/source/libraries/boost/config/user.hpp
   trunk/source/libraries/boost/detail/
   trunk/source/libraries/boost/detail/lightweight_mutex.hpp
   trunk/source/libraries/boost/detail/lwm_pthreads.hpp
   trunk/source/libraries/boost/detail/lwm_win32.hpp
   trunk/source/libraries/boost/detail/lwm_win32_cs.hpp
   trunk/source/libraries/boost/detail/lwm_win32_nt.hpp
   trunk/source/libraries/boost/detail/shared_count.hpp
   trunk/source/libraries/boost/detail/workaround.hpp
   trunk/source/libraries/boost/non_type.hpp
   trunk/source/libraries/boost/scoped_array.hpp
   trunk/source/libraries/boost/scoped_ptr.hpp
   trunk/source/libraries/boost/shared_array.hpp
   trunk/source/libraries/boost/shared_container_iterator.hpp
   trunk/source/libraries/boost/shared_ptr.hpp
   trunk/source/libraries/boost/smart_ptr.hpp
   trunk/source/libraries/boost/throw_exception.hpp
   trunk/source/libraries/boost/type.hpp
   trunk/source/libraries/boost/weak_ptr.hpp
Removed:
   trunk/mingw-libs/include/boost/
   trunk/msvc-libs/include/boost/
Modified:
   trunk/SConstruct
   trunk/makefile
   trunk/sources.lst
Log:
fixed make command
removed boost depend

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/SConstruct	2005-09-24 05:41:48 UTC (rev 193)
@@ -251,7 +251,7 @@
                        'TW_SVNVERSION=\\&quot;' + SVNVERSION+ '\\&quot;'])
 
 env.Append(LIBS =  [&quot;alleg&quot;, &quot;winmm&quot;, &quot;ws2_32&quot;, &quot;SDL&quot;,&quot;SDLmain&quot;,&quot;SDL_mixer&quot;,&quot;python24&quot;,&quot;z&quot;])
-env.Append(CPPPATH=[&quot;#source&quot;])
+env.Append(CPPPATH=[&quot;#source&quot;,&quot;#source/libraries&quot;])
 
 tw = env.Program(&quot;tw-light&quot;, twsource)
 

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/makefile	2005-09-24 05:41:48 UTC (rev 193)
@@ -178,9 +178,8 @@
 
 source/generated/tml_wrap.cpp: source/python/game.i source/tml/gameaction.h source/util/sound.h source/tml/gameconfig.h source/tml/gamedialog.h source/tml/eventmanager.h
 	$(SWIG) -c++ -python -o source/generated/tml_wrap.cpp -outdir source/generated/ source/python/game.i
-	cp source/generated/tml.py $(DATAPATH)/python/
+	cp source/generated/tml.py gamedata/python/
 
-
 $(OBJDIR)/%.o: %.cpp
 	$(CX) -MMD $(CFLAGS) -c $&lt; -o $@
 
@@ -227,6 +226,7 @@
 install:
 	./install-sh -c -m 755 $(NAME) $(EXECPATH)/$(NAME)
 	CPPROG=&quot;cp -r&quot; ./install-sh -c gamedata $(DATAPATH)
+	cp source/generated/tml.py $(DATAPATH)/python/
 
 uninstall:
 	$(RM) $(EXECPATH)/$(NAME)

Added: trunk/source/libraries/boost/assert.hpp
===================================================================
--- trunk/source/libraries/boost/assert.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/assert.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,38 @@
+//
+//  boost/assert.hpp - BOOST_ASSERT(expr)
+//
+//  Copyright (c) 2001, 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  Note: There are no include guards. This is intentional.
+//
+//  See <A HREF="http://www.boost.org/libs/utility/assert.html">http://www.boost.org/libs/utility/assert.html</A> for documentation.
+//
+
+#undef BOOST_ASSERT
+
+#if defined(BOOST_DISABLE_ASSERTS)
+
+# define BOOST_ASSERT(expr) ((void)0)
+
+#elif defined(BOOST_ENABLE_ASSERT_HANDLER)
+
+#include &lt;boost/current_function.hpp&gt;
+
+namespace boost
+{
+
+void assertion_failed(char const * expr, char const * function, char const * file, long line); // user defined
+
+} // namespace boost
+
+#define BOOST_ASSERT(expr) ((expr)? ((void)0): ::boost::assertion_failed(#expr, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
+
+#else
+# include &lt;assert.h&gt;
+# define BOOST_ASSERT(expr) assert(expr)
+#endif

Added: trunk/source/libraries/boost/checked_delete.hpp
===================================================================
--- trunk/source/libraries/boost/checked_delete.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/checked_delete.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,71 @@
+#ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED
+#define BOOST_CHECKED_DELETE_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/checked_delete.hpp
+//
+//  Copyright (c) 1999, 2000, 2001, 2002 boost.org
+//  Copyright (c) 2002, 2003 Peter Dimov
+//  Copyright (c) 2003 Daniel Frey
+//  Copyright (c) 2003 Howard Hinnant
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/utility/checked_delete.html">http://www.boost.org/libs/utility/checked_delete.html</A> for documentation.
+//
+
+namespace boost
+{
+
+// verify that types are complete for increased safety
+
+template&lt;class T&gt; inline void checked_delete(T * x)
+{
+    // intentionally complex - simplification causes regressions
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete x;
+}
+
+template&lt;class T&gt; inline void checked_array_delete(T * x)
+{
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete [] x;
+}
+
+template&lt;class T&gt; struct checked_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        // boost:: disables ADL
+        boost::checked_delete(x);
+    }
+};
+
+template&lt;class T&gt; struct checked_array_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        boost::checked_array_delete(x);
+    }
+};
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED

Added: trunk/source/libraries/boost/config/abi/borland_prefix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/borland_prefix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/borland_prefix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,27 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  for C++ Builder the following options effect the ABI:
+//
+//  -b (on or off - effect emum sizes)
+//  -Vx  (on or off - empty members)
+//  -Ve (on or off - empty base classes)
+//  -aX (alignment - 5 options).
+//  -pX (Calling convention - 4 options)
+//  -VmX (member pointer size and layout - 5 options)
+//  -VC (on or off, changes name mangling)
+//  -Vl (on or off, changes struct layout).
+
+//  In addition the following warnings are sufficiently annoying (and
+//  unfixable) to have them turned off by default:
+//
+//  8027 - functions containing [for|while] loops are not expanded inline
+//  8026 - functions taking class by value arguments are not expanded inline
+
+#pragma nopushoptwarn
+#  pragma option push -Vx -Ve -a8 -b -pc -Vmv -VC- -Vl- -w-8027 -w-8026
+
+
+

Added: trunk/source/libraries/boost/config/abi/borland_suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/borland_suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/borland_suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,12 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#  pragma option pop
+#pragma nopushoptwarn
+
+
+
+
+

Added: trunk/source/libraries/boost/config/abi/msvc_prefix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/msvc_prefix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/msvc_prefix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,8 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#pragma pack(push,8)
+
+

Added: trunk/source/libraries/boost/config/abi/msvc_suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi/msvc_suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi/msvc_suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,8 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#pragma pack(pop)
+
+

Added: trunk/source/libraries/boost/config/abi_prefix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi_prefix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi_prefix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,20 @@
+//  abi_prefix header  -------------------------------------------------------//
+
+// &#169; Copyright John Maddock 2003
+   
+// Use, modification and distribution are subject to the Boost Software License,
+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>).
+
+#ifndef BOOST_CONFIG_ABI_PREFIX_HPP
+# define BOOST_CONFIG_ABI_PREFIX_HPP
+#else
+# error double inclusion of header boost/config/abi_prefix.hpp is an error
+#endif
+
+#include &lt;boost/config.hpp&gt;
+
+// this must occur after all other includes and before any code appears:
+#ifdef BOOST_HAS_ABI_HEADERS
+#  include BOOST_ABI_PREFIX
+#endif

Added: trunk/source/libraries/boost/config/abi_suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/abi_suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/abi_suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,23 @@
+//  abi_sufffix header  -------------------------------------------------------//
+
+// &#169; Copyright John Maddock 2003
+   
+// Use, modification and distribution are subject to the Boost Software License,
+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>).
+
+// This header should be #included AFTER code that was preceded by a #include
+// &lt;boost/config/abi_prefix.hpp&gt;.
+
+#ifndef BOOST_CONFIG_ABI_PREFIX_HPP
+# error Header boost/config/abi_prefix.hpp must only be used after boost/config/abi_prefix.hpp
+#else
+# undef BOOST_CONFIG_ABI_PREFIX_HPP
+#endif
+
+// the suffix header occurs after all of our code:
+#ifdef BOOST_HAS_ABI_HEADERS
+#  include BOOST_ABI_SUFFIX
+#endif
+
+

Added: trunk/source/libraries/boost/config/auto_link.hpp
===================================================================
--- trunk/source/libraries/boost/config/auto_link.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/auto_link.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,331 @@
+//  (C) Copyright John Maddock 2003.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+ /*
+  *   LOCATION:    see <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+  *   FILE         auto_link.hpp
+  *   VERSION      see &lt;boost/version.hpp&gt;
+  *   DESCRIPTION: Automatic library inclusion for Borland/Microsoft compilers.
+  */
+
+/*************************************************************************
+
+USAGE:
+~~~~~~
+
+Before including this header you must define one or more of define the following macros:
+
+BOOST_LIB_NAME:       Required: A string containing the basename of the library,
+                      for example boost_regex.
+BOOST_DYN_LINK:       Optional: when set link to dll rather than static library.
+BOOST_LIB_DIAGNOSTIC: Optional: when set the header will print out the name
+                      of the library selected (useful for debugging).
+
+These macros will be undef'ed at the end of the header, further this header
+has no include guards - so be sure to include it only once from your library!
+
+Algorithm:
+~~~~~~~~~~
+
+Libraries for Borland and Microsoft compilers are automatically
+selected here, the name of the lib is selected according to the following
+formula:
+
+BOOST_LIB_PREFIX
+   + BOOST_LIB_NAME
+   + &quot;_&quot;
+   + BOOST_LIB_TOOLSET
+   + BOOST_LIB_THREAD_OPT
+   + BOOST_LIB_RT_OPT
+   &quot;-&quot;
+   + BOOST_LIB_VERSION
+
+These are defined as:
+
+BOOST_LIB_PREFIX:     &quot;lib&quot; for static libraries otherwise &quot;&quot;.
+
+BOOST_LIB_NAME:       The base name of the lib ( for example boost_regex).
+
+BOOST_LIB_TOOLSET:    The compiler toolset name (vc6, vc7, bcb5 etc).
+
+BOOST_LIB_THREAD_OPT: &quot;-mt&quot; for multithread builds, otherwise nothing.
+
+BOOST_LIB_RT_OPT:     A suffix that indicates the runtime library used,
+                      contains one or more of the following letters after
+                      a hiphen:
+
+                      s      static runtime (dynamic if not present).
+                      d      debug build (release if not present).
+                      g      debug/diagnostic runtime (release if not present).
+                      p      STLPort Build.
+
+BOOST_LIB_VERSION:    The Boost version, in the form x_y, for Boost version x.y.
+
+
+***************************************************************************/
+
+#ifdef __cplusplus
+#  ifndef BOOST_CONFIG_HPP
+#     include &lt;boost/config.hpp&gt;
+#  endif
+#elif defined(_MSC_VER) &amp;&amp; !defined(__MWERKS__) &amp;&amp; !defined(__EDG_VERSION__)
+//
+// C language compatability (no, honestly)
+//
+#  define BOOST_MSVC _MSC_VER
+#  define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)
+#  define BOOST_DO_STRINGIZE(X) #X
+#endif
+//
+// Only include what follows for known and supported compilers:
+//
+#if (defined(BOOST_MSVC) &amp;&amp; defined(_MSC_EXTENSIONS)) \
+    || defined(__BORLANDC__) \
+    || (defined(__MWERKS__) &amp;&amp; defined(_WIN32) &amp;&amp; (__MWERKS__ &gt;= 0x3000)) \
+    || (defined(__ICL) &amp;&amp; defined(_MSC_EXTENSIONS) &amp;&amp; (_MSC_VER &gt;= 1200))
+
+#ifndef BOOST_VERSION_HPP
+#  include &lt;boost/version.hpp&gt;
+#endif
+
+#ifndef BOOST_LIB_NAME
+#  error &quot;Macro BOOST_LIB_NAME not set (internal error)&quot;
+#endif
+
+//
+// error check:
+//
+#if defined(__MSVC_RUNTIME_CHECKS) &amp;&amp; !defined(_DEBUG)
+#  pragma message(&quot;Using the /RTC option without specifying a debug runtime will lead to linker errors&quot;)
+#  pragma message(&quot;Hint: go to the code generation options and switch to one of the debugging runtimes&quot;)
+#  error &quot;Incompatible build options&quot;
+#endif
+//
+// select toolset:
+//
+#if defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC == 1200)
+
+   // vc6:
+#  define BOOST_LIB_TOOLSET &quot;vc6&quot;
+
+#elif defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC == 1300)
+
+   // vc7:
+#  define BOOST_LIB_TOOLSET &quot;vc7&quot;
+
+#elif defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC &gt;= 1310)
+
+   // vc71:
+#  define BOOST_LIB_TOOLSET &quot;vc71&quot;
+
+#elif defined(__BORLANDC__)
+
+   // CBuilder 6:
+#  define BOOST_LIB_TOOLSET &quot;bcb&quot;
+
+#elif defined(__ICL)
+
+   // Intel C++, no version number:
+#  define BOOST_LIB_TOOLSET &quot;iw&quot;
+
+#elif defined(__MWERKS__) &amp;&amp; (__MWERKS__ &lt;= 0x31FF )
+
+   // Metrowerks CodeWarrior 8.x
+#  define BOOST_LIB_TOOLSET &quot;cw8&quot;
+
+#elif defined(__MWERKS__) &amp;&amp; (__MWERKS__ &lt;= 0x32FF )
+
+   // Metrowerks CodeWarrior 9.x
+#  define BOOST_LIB_TOOLSET &quot;cw9&quot;
+
+#endif
+
+//
+// select thread opt:
+//
+#if defined(_MT) || defined(__MT__)
+#  define BOOST_LIB_THREAD_OPT &quot;-mt&quot;
+#else
+#  define BOOST_LIB_THREAD_OPT
+#endif
+
+#if defined(_MSC_VER) || defined(__MWERKS__)
+
+#  ifdef _DLL
+
+#     if (defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) &amp;&amp; (defined(_STLP_OWN_IOSTREAMS) || defined(__STL_OWN_IOSTREAMS))
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-gdp&quot;
+#        elif defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT &quot;-gdp&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-p&quot;
+#        endif
+
+#     elif defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-gdpn&quot;
+#        elif defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT &quot;-gdpn&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-pn&quot;
+#        endif
+
+#     else
+
+#        if defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT &quot;-gd&quot;
+#        else
+#            define BOOST_LIB_RT_OPT
+#        endif
+
+#     endif
+
+#  else
+
+#     if (defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) &amp;&amp; (defined(_STLP_OWN_IOSTREAMS) || defined(__STL_OWN_IOSTREAMS))
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-sgdp&quot;
+#        elif defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT &quot;-sgdp&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-sp&quot;
+#        endif
+
+#     elif defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-sgdpn&quot;
+#        elif defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT &quot;-sgdpn&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-spn&quot;
+#        endif
+
+#     else
+
+#        if defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT &quot;-sgd&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-s&quot;
+#        endif
+
+#     endif
+
+#  endif
+
+#elif defined(__BORLANDC__)
+
+//
+// figure out whether we want the debug builds or not:
+//
+#pragma defineonoption BOOST_BORLAND_DEBUG -v
+//
+// sanity check:
+//
+#if defined(__STL_DEBUG) || defined(_STLP_DEBUG)
+#error &quot;Pre-built versions of the Boost libraries are not provided in STLPort-debug form&quot;
+#endif
+
+#  ifdef _RTLDLL
+
+#     ifdef BOOST_BORLAND_DEBUG
+#         define BOOST_LIB_RT_OPT &quot;-d&quot;
+#     else
+#         define BOOST_LIB_RT_OPT
+#     endif
+
+#  else
+
+#     ifdef BOOST_BORLAND_DEBUG
+#         define BOOST_LIB_RT_OPT &quot;-sd&quot;
+#     else
+#         define BOOST_LIB_RT_OPT &quot;-s&quot;
+#     endif
+
+#  endif
+
+#endif
+
+//
+// select linkage opt:
+//
+#if (defined(_DLL) || defined(_RTLDLL)) &amp;&amp; defined(BOOST_DYN_LINK)
+#  define BOOST_LIB_PREFIX
+#elif defined(BOOST_DYN_LINK)
+#  error &quot;Mixing a dll boost library with a static runtime is a really bad idea...&quot;
+#else
+#  define BOOST_LIB_PREFIX &quot;lib&quot;
+#endif
+
+//
+// now include the lib:
+//
+#if defined(BOOST_LIB_NAME) \
+      &amp;&amp; defined(BOOST_LIB_PREFIX) \
+      &amp;&amp; defined(BOOST_LIB_TOOLSET) \
+      &amp;&amp; defined(BOOST_LIB_THREAD_OPT) \
+      &amp;&amp; defined(BOOST_LIB_RT_OPT) \
+      &amp;&amp; defined(BOOST_LIB_VERSION)
+
+#  pragma comment(lib, BOOST_LIB_PREFIX BOOST_STRINGIZE(BOOST_LIB_NAME) &quot;-&quot; BOOST_LIB_TOOLSET BOOST_LIB_THREAD_OPT BOOST_LIB_RT_OPT &quot;-&quot; BOOST_LIB_VERSION &quot;.lib&quot;)
+#ifdef BOOST_LIB_DIAGNOSTIC
+#  pragma message (&quot;Linking to lib file: &quot; BOOST_LIB_PREFIX BOOST_STRINGIZE(BOOST_LIB_NAME) &quot;-&quot; BOOST_LIB_TOOLSET BOOST_LIB_THREAD_OPT BOOST_LIB_RT_OPT &quot;-&quot; BOOST_LIB_VERSION &quot;.lib&quot;)
+#endif
+
+#else
+#  error &quot;some required macros where not defined (internal logic error).&quot;
+#endif
+
+
+#endif // _MSC_VER || __BORLANDC__
+
+//
+// finally undef any macros we may have set:
+//
+#ifdef BOOST_LIB_PREFIX
+#  undef BOOST_LIB_PREFIX
+#endif
+#if defined(BOOST_LIB_NAME)
+#  undef BOOST_LIB_NAME
+#endif
+#if defined(BOOST_LIB_TOOLSET)
+#  undef BOOST_LIB_TOOLSET
+#endif
+#if defined(BOOST_LIB_THREAD_OPT)
+#  undef BOOST_LIB_THREAD_OPT
+#endif
+#if defined(BOOST_LIB_RT_OPT)
+#  undef BOOST_LIB_RT_OPT
+#endif
+#if defined(BOOST_LIB_LINK_OPT)
+#  undef BOOST_LIB_LINK_OPT
+#endif
+#if defined(BOOST_LIB_DEBUG_OPT)
+#  undef BOOST_LIB_DEBUG_OPT
+#endif
+#if defined(BOOST_DYN_LINK)
+#  undef BOOST_DYN_LINK
+#endif
+
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/borland.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/borland.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/borland.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,167 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright David Abrahams 2002 - 2003.
+//  (C) Copyright Aleksey Gurtovoy 2002.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Borland C++ compiler setup:
+
+// Version 5.0 and below:
+#   if __BORLANDC__ &lt;= 0x0550
+// Borland C++Builder 4 and 5:
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#     if __BORLANDC__ == 0x0550
+// Borland C++Builder 5, command-line compiler 5.5:
+#       define BOOST_NO_OPERATORS_IN_NAMESPACE
+#     endif
+#   endif
+
+// Version 5.51 and below:
+#if (__BORLANDC__ &lt;= 0x551)
+#  define BOOST_NO_CV_SPECIALIZATIONS
+#  define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#  define BOOST_NO_DEDUCED_TYPENAME
+#endif
+
+#if (__BORLANDC__ &lt;= 0x564)
+#  define BOOST_NO_SFINAE
+#endif
+
+// Version 7.0 (Kylix) and below:
+#if (__BORLANDC__ &lt;= 0x570)
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#  define BOOST_NO_PRIVATE_IN_AGGREGATE
+#  define BOOST_NO_USING_TEMPLATE
+#  define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#  define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+   // we shouldn't really need this - but too many things choke
+   // without it, this needs more investigation:
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#  ifdef NDEBUG
+      // fix broken &lt;cstring&gt; so that Boost.test works:
+#     include &lt;cstring&gt;
+#     undef strcmp
+#  endif
+
+//
+// new bug in 5.61:
+#if (__BORLANDC__ &gt;= 0x561) &amp;&amp; (__BORLANDC__ &lt;= 0x570)
+   // this seems to be needed by the command line compiler, but not the IDE:
+#  define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#endif
+
+#  ifdef _WIN32
+#     define BOOST_NO_SWPRINTF
+#  elif defined(linux) || defined(__linux__) || defined(__linux)
+      // we should really be able to do without this
+      // but the wcs* functions aren't imported into std::
+#     define BOOST_NO_STDC_NAMESPACE
+      // _CPPUNWIND doesn't get automatically set for some reason:
+#     pragma defineonoption BOOST_CPPUNWIND -x
+#  endif
+#endif
+
+//
+// Post 0x561 we have long long and stdint.h:
+#if __BORLANDC__ &gt;= 0x561
+#  ifndef __NO_LONG_LONG
+#     define BOOST_HAS_LONG_LONG
+#  endif
+   // On non-Win32 platforms let the platform config figure this out:
+#  ifdef _WIN32
+#      define BOOST_HAS_STDINT_H
+#  endif
+#endif
+
+// Borland C++Builder 6 defaults to using STLPort.  If _USE_OLD_RW_STL is
+// defined, then we have 0x560 or greater with the Rogue Wave implementation
+// which presumably has the std::DBL_MAX bug.
+#if ((__BORLANDC__ &gt;= 0x550) &amp;&amp; (__BORLANDC__ &lt; 0x560)) || defined(_USE_OLD_RW_STL)
+// &lt;climits&gt; is partly broken, some macros define symbols that are really in
+// namespace std, so you end up having to use illegal constructs like
+// std::DBL_MAX, as a fix we'll just include float.h and have done with:
+#include &lt;float.h&gt;
+#endif
+//
+// __int64:
+//
+#if (__BORLANDC__ &gt;= 0x530) &amp;&amp; !defined(__STRICT_ANSI__)
+#  define BOOST_HAS_MS_INT64
+#endif
+//
+// check for exception handling support:
+//
+#if !defined(_CPPUNWIND) &amp;&amp; !defined(BOOST_CPPUNWIND) &amp;&amp; !defined(__EXCEPTIONS)
+#  define BOOST_NO_EXCEPTIONS
+#endif
+//
+// all versions have a &lt;dirent.h&gt;:
+//
+#ifndef __STRICT_ANSI__
+#  define BOOST_HAS_DIRENT_H
+#endif
+//
+// all versions support __declspec:
+//
+#ifndef __STRICT_ANSI__
+#  define BOOST_HAS_DECLSPEC
+#endif
+//
+// ABI fixing headers:
+//
+#if __BORLANDC__ &lt; 0x600 // not implemented for version 6 compiler yet
+#ifndef BOOST_ABI_PREFIX
+#  define BOOST_ABI_PREFIX &quot;boost/config/abi/borland_prefix.hpp&quot;
+#endif
+#ifndef BOOST_ABI_SUFFIX
+#  define BOOST_ABI_SUFFIX &quot;boost/config/abi/borland_suffix.hpp&quot;
+#endif
+#endif
+//
+// Disable Win32 support in ANSI mode:
+//
+#if __BORLANDC__ &lt; 0x600
+#  pragma defineonoption BOOST_DISABLE_WIN32 -A
+#elif defined(__STRICT_ANSI__)
+#  define BOOST_DISABLE_WIN32
+#endif
+//
+// MSVC compatibility mode does some nasty things:
+//
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1200)
+#  define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#  define BOOST_NO_VOID_RETURNS
+#endif
+
+#define BOOST_COMPILER &quot;Borland C++ version &quot; BOOST_STRINGIZE(__BORLANDC__)
+
+//
+// versions check:
+// we don't support Borland prior to version 5.4:
+#if __BORLANDC__ &lt; 0x540
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 1536 (Builder X preview):
+#if (__BORLANDC__ &gt; 1536)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  else
+#     pragma message( &quot;Unknown compiler version - please run the configure tests and report the results&quot;)
+#  endif
+#endif
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/comeau.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/comeau.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/comeau.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,64 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Douglas Gregor 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2003. 
+//  (C) Copyright Beman Dawes 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Comeau C++ compiler setup:
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+#if (__COMO_VERSION__ &lt;= 4245) || !defined(BOOST_STRICT_CONFIG)
+
+#  ifdef _WIN32
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+#  if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1300
+#     define BOOST_NO_STDC_NAMESPACE
+#     if _MSC_VER &gt; 100
+         // only set this in non-strict mode:
+#        define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#     endif
+#  endif
+
+// Void returns don't work when emulating VC 6 (Peter Dimov)
+
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER == 1200)
+#     define BOOST_NO_VOID_RETURNS
+#  endif
+
+#endif  // version 4245
+
+//
+// enable __int64 support in VC emulation mode
+//
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
+#     define BOOST_HAS_MS_INT64
+#  endif
+
+#define BOOST_COMPILER &quot;Comeau compiler version &quot; BOOST_STRINGIZE(__COMO_VERSION__)
+
+//
+// versions check:
+// we don't know Comeau prior to version 4245:
+#if __COMO_VERSION__ &lt; 4245
+#  error &quot;Compiler not configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 4245:
+#if (__COMO_VERSION__ &gt; 4245)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/common_edg.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/common_edg.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/common_edg.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,53 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//
+// Options common to all edg based compilers.
+//
+// This is included from within the individual compiler mini-configs.
+
+#ifndef  __EDG_VERSION__
+#  error This file requires that __EDG_VERSION__ be defined.
+#endif
+
+#if (__EDG_VERSION__ &lt;= 238)
+#   define BOOST_NO_INTEGRAL_INT64_T
+#   define BOOST_NO_SFINAE
+#endif
+
+#if (__EDG_VERSION__ &lt;= 240)
+#   define BOOST_NO_VOID_RETURNS
+#endif
+
+#if (__EDG_VERSION__ &lt;= 241) &amp;&amp; !defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP)
+#   define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#endif
+
+#if (__EDG_VERSION__ &lt;= 244) &amp;&amp; !defined(BOOST_NO_TEMPLATE_TEMPLATES)
+#   define BOOST_NO_TEMPLATE_TEMPLATES
+#endif 
+
+// See also kai.hpp which checks a Kai-specific symbol for EH
+# if !defined(__KCC) &amp;&amp; !defined(__EXCEPTIONS)
+#     define BOOST_NO_EXCEPTIONS
+# endif
+
+# if !defined(__NO_LONG_LONG)
+#     define BOOST_HAS_LONG_LONG
+# endif
+
+#ifdef c_plusplus
+// EDG has &quot;long long&quot; in non-strict mode
+// However, some libraries have insufficient &quot;long long&quot; support
+// #define BOOST_HAS_LONG_LONG
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/compaq_cxx.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,19 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Dec Alpha True64 C++ compiler setup:
+
+#define BOOST_COMPILER &quot;Dec Alpha True64 &quot; BOOST_STRINGIZE(__DECCXX_VER)
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+//
+// versions check:
+// Nothing to do here?
+
+
+

Added: trunk/source/libraries/boost/config/compiler/digitalmars.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/digitalmars.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/digitalmars.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,31 @@
+//  Copyright (C) Christof Meerwald 2003
+//  Copyright (C) Dan Watkins 2003
+//
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  Digital Mars C++ compiler setup:
+#define BOOST_COMPILER __DMC_VERSION_STRING__
+
+#define BOOST_HAS_LONG_LONG
+#define BOOST_HAS_PRAGMA_ONCE
+
+#define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#define BOOST_NO_OPERATORS_IN_NAMESPACE
+#define BOOST_NO_SFINAE
+#define BOOST_NO_TEMPLATE_TEMPLATES
+#define BOOST_NO_USING_TEMPLATE
+#define BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING
+#define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+
+// check for exception handling support:
+#ifndef _CPPUNWIND
+#  define BOOST_NO_EXCEPTIONS
+#endif
+
+#if (__DMC__ &lt; 0x833)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif

Added: trunk/source/libraries/boost/config/compiler/gcc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/gcc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/gcc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,96 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001 - 2002. 
+//  (C) Copyright Beman Dawes 2001 - 2003. 
+//  (C) Copyright Douglas Gregor 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Synge Todo 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  GNU C++ compiler setup:
+
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ == 91
+       // egcs 1.1 won't parse shared_ptr.hpp without this:
+#      define BOOST_NO_AUTO_PTR
+#   endif
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 95
+      //
+      // Prior to gcc 2.95 member templates only partly
+      // work - define BOOST_MSVC6_MEMBER_TEMPLATES
+      // instead since inline member templates mostly work.
+      //
+#     define BOOST_NO_MEMBER_TEMPLATES
+#     if __GNUC_MINOR__ &gt;= 9
+#       define BOOST_MSVC6_MEMBER_TEMPLATES
+#     endif
+#   endif
+
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 96
+#     define BOOST_NO_SFINAE
+#   endif
+
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 97
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#     define BOOST_NO_OPERATORS_IN_NAMESPACE
+#   endif
+
+#   if __GNUC__ &lt; 3
+#      define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+#      define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#   endif
+
+#ifndef __EXCEPTIONS
+# define BOOST_NO_EXCEPTIONS
+#endif
+
+//
+// Bug specific to gcc 3.1 and 3.2:
+//
+#if (__GNUC__ == 3) &amp;&amp; ((__GNUC_MINOR__ == 1) || (__GNUC_MINOR__ == 2))
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#endif
+
+//
+// Threading support: Turn this on unconditionally here (except for
+// those platforms where we can know for sure). It will get turned off again
+// later if no threading API is detected.
+//
+#if !defined(__MINGW32__) &amp;&amp; !defined(linux) &amp;&amp; !defined(__linux) &amp;&amp; !defined(__linux__)
+# define BOOST_HAS_THREADS
+#endif 
+
+//
+// gcc has &quot;long long&quot;
+//
+#define BOOST_HAS_LONG_LONG
+
+//
+// gcc implements the named return value optimization since version 3.1
+//
+#if __GNUC__ &gt; 3 || ( __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 1 )
+#define BOOST_HAS_NRVO
+#endif
+
+#define BOOST_COMPILER &quot;GNU C++ version &quot; __VERSION__
+
+//
+// versions check:
+// we don't know gcc prior to version 2.90:
+#if (__GNUC__ == 2) &amp;&amp; (__GNUC_MINOR__ &lt; 90)
+#  error &quot;Compiler not configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 3.4:
+#if (__GNUC__ &gt; 3) || ((__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt; 4))
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  else
+#     warning &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/compiler/greenhills.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/greenhills.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/greenhills.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,28 @@
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Greenhills C++ compiler setup:
+
+#define BOOST_COMPILER &quot;Greenhills C++ version &quot; BOOST_STRINGIZE(__ghs)
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+//
+// versions check:
+// we don't support Greenhills prior to version 0:
+#if __ghs &lt; 0
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0:
+#if (__ghs &gt; 0)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/compiler/hp_acc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/hp_acc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/hp_acc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,67 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Toon Knapen 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  HP aCC C++ compiler setup:
+
+#if (__HP_aCC &lt;= 33100)
+#    define BOOST_NO_INTEGRAL_INT64_T
+#    define BOOST_NO_OPERATORS_IN_NAMESPACE
+#  if !defined(_NAMESPACE_STD)
+#     define BOOST_NO_STD_LOCALE
+#     define BOOST_NO_STRINGSTREAM
+#  endif
+#endif
+
+#if (__HP_aCC &lt;= 33300)
+// member templates are sufficiently broken that we disable them for now
+#    define BOOST_NO_MEMBER_TEMPLATES
+#    define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#    define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+#endif
+
+#if (__HP_aCC &lt;= 33900) || !defined(BOOST_STRICT_CONFIG)
+#    define BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#    define BOOST_NO_TEMPLATE_TEMPLATES
+#    define BOOST_NO_SWPRINTF
+#    define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+//     std lib config should set this one already:
+//#    define BOOST_NO_STD_ALLOCATOR
+#endif 
+
+// optional features rather than defects:
+#if (__HP_aCC &gt;= 33900)
+#    define BOOST_HAS_LONG_LONG
+#    define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#endif
+
+#if (__HP_aCC &lt;= 53800 )
+#    define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#endif
+
+#define BOOST_COMPILER &quot;HP aCC version &quot; BOOST_STRINGIZE(__HP_aCC)
+
+//
+// versions check:
+// we don't support HP aCC prior to version 0:
+#if __HP_aCC &lt; 33000
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0:
+#if (__HP_aCC &gt; 53800)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/intel.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/intel.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/intel.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,114 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Aleksey Gurtovoy 2002 - 2003. 
+//  (C) Copyright Guillaume Melquiond 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2003. 
+//  (C) Copyright Martin Wille 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Intel compiler setup:
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+#if defined(__INTEL_COMPILER)
+#  define BOOST_INTEL_CXX_VERSION __INTEL_COMPILER
+#elif defined(__ICL)
+#  define BOOST_INTEL_CXX_VERSION __ICL
+#elif defined(__ICC)
+#  define BOOST_INTEL_CXX_VERSION __ICC
+#elif defined(__ECC)
+#  define BOOST_INTEL_CXX_VERSION __ECC
+#endif
+
+#define BOOST_COMPILER &quot;Intel C++ version &quot; BOOST_STRINGIZE(BOOST_INTEL_CXX_VERSION)
+#define BOOST_INTEL BOOST_INTEL_CXX_VERSION
+
+#if (BOOST_INTEL_CXX_VERSION &lt;= 500) &amp;&amp; defined(_MSC_VER)
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#endif
+
+#if (BOOST_INTEL_CXX_VERSION &lt;= 600) || !defined(BOOST_STRICT_CONFIG)
+
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1300) // added check for &lt;= VC 7 (Peter Dimov)
+
+// Boost libraries assume strong standard conformance unless otherwise
+// indicated by a config macro. As configured by Intel, the EDG front-end
+// requires certain compiler options be set to achieve that strong conformance.
+// Particularly /Qoption,c,--arg_dep_lookup (reported by Kirk Klobe &amp; Thomas Witt)
+// and /Zc:wchar_t,forScope. See boost-root/tools/build/intel-win32-tools.jam for
+// details as they apply to particular versions of the compiler. When the
+// compiler does not predefine a macro indicating if an option has been set,
+// this config file simply assumes the option has been set.
+// Thus BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP will not be defined, even if
+// the compiler option is not enabled.
+
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+// Void returns, 64 bit integrals don't work when emulating VC 6 (Peter Dimov)
+
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1200)
+#     define BOOST_NO_VOID_RETURNS
+#     define BOOST_NO_INTEGRAL_INT64_T
+#  endif
+
+#endif
+
+// See <A HREF="http://aspn.activestate.com/ASPN/Mail/Message/boost/1614864">http://aspn.activestate.com/ASPN/Mail/Message/boost/1614864</A>
+#if BOOST_INTEL_CXX_VERSION &lt; 700
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#else
+// _WCHAR_T_DEFINED is the Win32 spelling
+// _WCHAR_T is the Linux spelling
+#  if !defined(_WCHAR_T_DEFINED) &amp;&amp; !defined(_WCHAR_T)
+#    define BOOST_NO_INTRINSIC_WCHAR_T
+#  endif
+#endif
+
+#if (BOOST_INTEL_CXX_VERSION &lt;= 800) || !defined(BOOST_STRICT_CONFIG)
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#endif
+
+#if _MSC_VER+0 &gt;= 1000
+#  if _MSC_VER &gt;= 1200
+#     define BOOST_HAS_MS_INT64
+#  endif
+#  define BOOST_NO_SWPRINTF
+#elif defined(_WIN32)
+#  define BOOST_DISABLE_WIN32
+#endif
+
+// I checked version 6.0 build 020312Z, it implements the NRVO.
+// Correct this as you find out which version of the compiler
+// implemented the NRVO first.  (Daniel Frey)
+#if (BOOST_INTEL_CXX_VERSION &gt;= 600)
+#  define BOOST_HAS_NRVO
+#endif
+
+//
+// versions check:
+// we don't support Intel prior to version 5.0:
+#if BOOST_INTEL_CXX_VERSION &lt; 500
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version:
+#if (BOOST_INTEL_CXX_VERSION &gt; 800)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  elif defined(_MSC_VER)
+#     pragma message(&quot;Unknown compiler version - please run the configure tests and report the results&quot;)
+#  endif
+#endif
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/kai.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/kai.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/kai.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,35 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Kai C++ compiler setup:
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+#   if (__KCC_VERSION &lt;= 4001) || !defined(BOOST_STRICT_CONFIG)
+      // at least on Sun, the contents of &lt;cwchar&gt; is not in namespace std
+#     define BOOST_NO_STDC_NAMESPACE
+#   endif
+
+// see also common_edg.hpp which needs a special check for __KCC
+# if !defined(_EXCEPTIONS)
+#     define BOOST_NO_EXCEPTIONS
+# endif
+
+#define BOOST_COMPILER &quot;Kai C++ version &quot; BOOST_STRINGIZE(__KCC_VERSION)
+
+//
+// last known and checked version is 4001:
+#if (__KCC_VERSION &gt; 4001)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/compiler/metrowerks.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/metrowerks.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/metrowerks.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,94 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright David Abrahams 2001 - 2002. 
+//  (C) Copyright Beman Dawes 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Metrowerks C++ compiler setup:
+
+// locale support is disabled when linking with the dynamic runtime
+#   ifdef _MSL_NO_LOCALE
+#     define BOOST_NO_STD_LOCALE
+#   endif 
+
+#   if __MWERKS__ &lt;= 0x2301  // 5.3
+#     define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#     define BOOST_NO_POINTER_TO_MEMBER_CONST
+#     define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#     define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#   endif
+
+#   if __MWERKS__ &lt;= 0x2401  // 6.2
+//#     define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#   endif
+
+#   if(__MWERKS__ &lt;= 0x2407)  // 7.x
+#     define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#     define BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#   endif
+
+#   if(__MWERKS__ &lt;= 0x3003)  // 8.x
+#     define BOOST_NO_SFINAE
+#    endif
+
+#   if(__MWERKS__ &lt;= 0x3202)  // 9.2
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#    endif
+
+#if !__option(wchar_type)
+#   define BOOST_NO_INTRINSIC_WCHAR_T
+#endif
+
+#if !__option(exceptions)
+#   define BOOST_NO_EXCEPTIONS
+#endif
+
+#if (__INTEL__ &amp;&amp; _WIN32) || (__POWERPC__ &amp;&amp; macintosh)
+#   if __MWERKS__ == 0x3000
+#     define BOOST_COMPILER_VERSION 8.0
+#   elif __MWERKS__ == 0x3001
+#     define BOOST_COMPILER_VERSION 8.1
+#   elif __MWERKS__ == 0x3002
+#     define BOOST_COMPILER_VERSION 8.2
+#   elif __MWERKS__ == 0x3003
+#     define BOOST_COMPILER_VERSION 8.3
+#   elif __MWERKS__ == 0x3200
+#     define BOOST_COMPILER_VERSION 9.0
+#   elif __MWERKS__ == 0x3201
+#     define BOOST_COMPILER_VERSION 9.1
+#   elif __MWERKS__ == 0x3202
+#     define BOOST_COMPILER_VERSION 9.2
+#   else
+#     define BOOST_COMPILER_VERSION __MWERKS__
+#   endif
+#else
+#  define BOOST_COMPILER_VERSION __MWERKS__
+#endif
+
+#define BOOST_COMPILER &quot;Metrowerks CodeWarrior C++ version &quot; BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
+
+//
+// versions check:
+// we don't support Metrowerks prior to version 5.3:
+#if __MWERKS__ &lt; 0x2301
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version:
+#if (__MWERKS__ &gt; 0x3202)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/mpw.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/mpw.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/mpw.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,51 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  MPW C++ compilers setup:
+
+#   if    defined(__SC__)
+#     define BOOST_COMPILER &quot;MPW SCpp version &quot; BOOST_STRINGIZE(__SC__)
+#   elif defined(__MRC__)
+#     define BOOST_COMPILER &quot;MPW MrCpp version &quot; BOOST_STRINGIZE(__MRC__)
+#   else
+#     error &quot;Using MPW compiler configuration by mistake.  Please update.&quot;
+#   endif
+
+//
+// MPW 8.90:
+//
+#if (MPW_CPLUS &lt;= 0x890) || !defined(BOOST_STRICT_CONFIG)
+#  define BOOST_NO_CV_SPECIALIZATIONS
+#  define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#  define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#  define BOOST_NO_USING_TEMPLATE
+
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+
+#  define BOOST_NO_STD_ALLOCATOR /* actually a bug with const reference overloading */
+#endif
+
+//
+// versions check:
+// we don't support MPW prior to version 8.9:
+#if MPW_CPLUS &lt; 0x890
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0x890:
+#if (MPW_CPLUS &gt; 0x890)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/sgi_mipspro.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,24 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  SGI C++ compiler setup:
+
+#define BOOST_COMPILER &quot;SGI Irix compiler version &quot; BOOST_STRINGIZE(_COMPILER_VERSION)
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+//
+// Threading support:
+// Turn this on unconditionally here, it will get turned off again later
+// if no threading API is detected.
+//
+#define BOOST_HAS_THREADS
+//
+// version check:
+// probably nothing to do here?
+
+

Added: trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/sunpro_cc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,89 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright Peter Dimov 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002 - 2003. 
+//  (C) Copyright David Abrahams 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Sun C++ compiler setup:
+
+#    if __SUNPRO_CC &lt;= 0x500
+#      define BOOST_NO_MEMBER_TEMPLATES
+#      define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#    endif
+
+#    if (__SUNPRO_CC &lt;= 0x520)
+       //
+       // Sunpro 5.2 and earler:
+       //
+       // although sunpro 5.2 supports the syntax for
+       // inline initialization it often gets the value
+       // wrong, especially where the value is computed
+       // from other constants (J Maddock 6th May 2001)
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+
+       // Although sunpro 5.2 supports the syntax for
+       // partial specialization, it often seems to
+       // bind to the wrong specialization.  Better
+       // to disable it until suppport becomes more stable
+       // (J Maddock 6th May 2001).
+#      define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#    endif
+
+#    if (__SUNPRO_CC &lt;= 0x530) || !defined(BOOST_STRICT_CONFIG)
+       // Requesting debug info (-g) with Boost.Python results
+       // in an internal compiler error for &quot;static const&quot;
+       // initialized in-class.
+       //    &gt;&gt; Assertion:   (../links/dbg_cstabs.cc, line 611)
+       //         while processing ../test.cpp at line 0.
+       // (Jens Maurer according to Gottfried Gan&#223;auge 04 Mar 2002)
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+
+       // SunPro 5.3 has better support for partial specialization,
+       // but breaks when compiling std::less&lt;shared_ptr&lt;T&gt; &gt;
+       // (Jens Maurer 4 Nov 2001).
+
+       // std::less specialization fixed as reported by George
+       // Heintzelman; partial specialization re-enabled
+       // (Peter Dimov 17 Jan 2002)
+
+//#      define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+       // integral constant expressions with 64 bit numbers fail
+#      define BOOST_NO_INTEGRAL_INT64_T
+#    endif
+
+#    if (__SUNPRO_CC &lt;= 0x540) || !defined(BOOST_STRICT_CONFIG)
+#      define BOOST_NO_TEMPLATE_TEMPLATES
+       // see <A HREF="http://lists.boost.org/MailArchives/boost/msg47184.php">http://lists.boost.org/MailArchives/boost/msg47184.php</A>
+       // and <A HREF="http://lists.boost.org/MailArchives/boost/msg47220.php">http://lists.boost.org/MailArchives/boost/msg47220.php</A>
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#      define BOOST_NO_SFINAE
+#      define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+#    endif
+
+#define BOOST_COMPILER &quot;Sun compiler version &quot; BOOST_STRINGIZE(__SUNPRO_CC)
+
+//
+// versions check:
+// we don't support sunpro prior to version 4:
+#if __SUNPRO_CC &lt; 0x400
+#error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0x530:
+#if (__SUNPRO_CC &gt; 0x530)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/vacpp.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/vacpp.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/vacpp.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,56 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Toon Knapen 2001 - 2003. 
+//  (C) Copyright Lie-Quan Lee 2001. 
+//  (C) Copyright Markus Sch&#246;pflin 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Visual Age (IBM) C++ compiler setup:
+
+#if __IBMCPP__ &lt;= 501
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#  define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#endif
+
+#if (__IBMCPP__ &lt;= 502) 
+// Actually the compiler supports inclass member initialization but it
+// requires a definition for the class member and it doesn't recognize
+// it as an integral constant expression when used as a template argument.
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#endif
+
+#if (__IBMCPP__ &lt;= 600) || !defined(BOOST_STRICT_CONFIG)
+#endif
+
+//
+// On AIX thread support seems to be indicated by _THREAD_SAFE:
+//
+#ifdef _THREAD_SAFE
+#  define BOOST_HAS_THREADS
+#endif
+
+#define BOOST_COMPILER &quot;IBM Visual Age version &quot; BOOST_STRINGIZE(__IBMCPP__)
+
+//
+// versions check:
+// we don't support Visual age prior to version 5:
+#if __IBMCPP__ &lt; 500
+#error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 600:
+#if (__IBMCPP__ &gt; 600)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+

Added: trunk/source/libraries/boost/config/compiler/visualc.hpp
===================================================================
--- trunk/source/libraries/boost/config/compiler/visualc.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/compiler/visualc.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,146 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Microsoft Visual C++ compiler setup:
+
+#define BOOST_MSVC _MSC_VER
+
+// turn off the warnings before we #include anything
+#pragma warning( disable : 4503 ) // warning: decorated name length exceeded
+
+#if _MSC_VER &lt;= 1200  // 1200 == VC++ 6.0
+#pragma warning( disable : 4786 ) // ident trunc to '255' chars in debug info
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#  define BOOST_NO_VOID_RETURNS
+#  define BOOST_NO_EXCEPTION_STD_NAMESPACE
+   // disable min/max macro defines on vc6:
+   //
+#endif
+
+#if (_MSC_VER &lt;= 1300)  // 1300 == VC++ 7.0
+
+#if !defined(_MSC_EXTENSIONS) &amp;&amp; !defined(BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS)      // VC7 bug with /Za
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#endif
+
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_PRIVATE_IN_AGGREGATE
+#  define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_DEDUCED_TYPENAME
+#  define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+
+//    VC++ 6/7 has member templates but they have numerous problems including
+//    cases of silent failure, so for safety we define:
+#  define BOOST_NO_MEMBER_TEMPLATES
+//    For VC++ experts wishing to attempt workarounds, we define:
+#  define BOOST_MSVC6_MEMBER_TEMPLATES
+
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#  define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#  define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#  define BOOST_NO_USING_TEMPLATE
+#  define BOOST_NO_SWPRINTF
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#  define BOOST_NO_SFINAE
+#  if (_MSC_VER &gt; 1200)
+#     define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#  endif
+
+#endif
+
+#if _MSC_VER &lt; 1310 // 1310 == VC++ 7.1
+#  define BOOST_NO_SWPRINTF
+#endif
+
+#if _MSC_VER &lt;= 1310
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#endif
+
+#ifndef _NATIVE_WCHAR_T_DEFINED
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#endif
+
+//   
+// check for exception handling support:   
+#ifndef _CPPUNWIND   
+#  define BOOST_NO_EXCEPTIONS   
+#endif 
+
+//
+// __int64 support:
+//
+#if (_MSC_VER &gt;= 1200)
+#   define BOOST_HAS_MS_INT64
+#endif
+#if (_MSC_VER &gt;= 1310) &amp;&amp; defined(_MSC_EXTENSIONS)
+#   define BOOST_HAS_LONG_LONG
+#endif
+//
+// disable Win32 API's if compiler extentions are
+// turned off:
+//
+#ifndef _MSC_EXTENSIONS
+#  define BOOST_DISABLE_WIN32
+#endif
+
+//
+// all versions support __declspec:
+//
+#define BOOST_HAS_DECLSPEC
+//
+// prefix and suffix headers:
+//
+#ifndef BOOST_ABI_PREFIX
+#  define BOOST_ABI_PREFIX &quot;boost/config/abi/msvc_prefix.hpp&quot;
+#endif
+#ifndef BOOST_ABI_SUFFIX
+#  define BOOST_ABI_SUFFIX &quot;boost/config/abi/msvc_suffix.hpp&quot;
+#endif
+
+# if _MSC_VER == 1200
+#   define BOOST_COMPILER_VERSION 6.0
+# elif _MSC_VER == 1300
+#   define BOOST_COMPILER_VERSION 7.0
+# elif _MSC_VER == 1310
+#   define BOOST_COMPILER_VERSION 7.1
+# else
+#   define BOOST_COMPILER_VERSION _MSC_VER
+# endif
+
+#define BOOST_COMPILER &quot;Microsoft Visual C++ version &quot; BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
+
+//
+// versions check:
+// we don't support Visual C++ prior to version 6:
+#if _MSC_VER &lt; 1200
+#error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 1310:
+#if (_MSC_VER &gt; 1310)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  else
+#     pragma message(&quot;Unknown compiler version - please run the configure tests and report the results&quot;)
+#  endif
+#endif
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/aix.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/aix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/aix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,33 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  IBM/Aix specific config options:
+
+#define BOOST_PLATFORM &quot;IBM Aix&quot;
+
+#define BOOST_HAS_UNISTD_H
+#define BOOST_HAS_NL_TYPES_H
+#define BOOST_HAS_NANOSLEEP
+#define BOOST_HAS_CLOCK_GETTIME
+
+// This needs support in &quot;boost/cstdint.hpp&quot; exactly like FreeBSD.
+// This platform has header named &lt;inttypes.h&gt; which includes all
+// the things needed.
+#define BOOST_HAS_STDINT_H
+
+// Threading API's:
+#define BOOST_HAS_PTHREADS
+#define BOOST_HAS_PTHREAD_DELAY_NP
+#define BOOST_HAS_SCHED_YIELD
+//#define BOOST_HAS_PTHREAD_YIELD
+
+// boilerplate code:
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/amigaos.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/amigaos.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/amigaos.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,15 @@
+//  (C) Copyright John Maddock 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+#define BOOST_PLATFORM &quot;AmigaOS&quot;
+
+#define BOOST_DISABLE_THREADS
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_STD_WSTRING
+#define BOOST_NO_INTRINSIC_WCHAR_T
+ 
+

Added: trunk/source/libraries/boost/config/platform/beos.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/beos.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/beos.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,26 @@
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  BeOS specific config options:
+
+#define BOOST_PLATFORM &quot;BeOS&quot;
+
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_CWCTYPE
+#define BOOST_HAS_UNISTD_H
+
+#define BOOST_HAS_BETHREADS
+
+#ifndef BOOST_DISABLE_THREADS
+#  define BOOST_HAS_THREADS
+#endif
+
+// boilerplate code:
+#include &lt;boost/config/posix_features.hpp&gt;
+ 
+
+

Added: trunk/source/libraries/boost/config/platform/bsd.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/bsd.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/bsd.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,68 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Douglas Gregor 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  generic BSD config options:
+
+#if !defined(__FreeBSD__) &amp;&amp; !defined(__NetBSD__) &amp;&amp; !defined(__OpenBSD__)
+#error &quot;This platform is not BSD&quot;
+#endif
+
+#ifdef __FreeBSD__
+#define BOOST_PLATFORM &quot;FreeBSD &quot; BOOST_STRINGIZE(__FreeBSD__)
+#elif defined(__NetBSD__)
+#define BOOST_PLATFORM &quot;NetBSD &quot; BOOST_STRINGIZE(__NetBSD__)
+#elif defined(__OpenBSD__)
+#define BOOST_PLATFORM &quot;OpenBSD &quot; BOOST_STRINGIZE(__OpenBSD__)
+#endif
+
+//
+// is this the correct version check?
+// FreeBSD has &lt;nl_types.h&gt; but does not
+// advertise the fact in &lt;unistd.h&gt;:
+//
+#if defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &gt;= 3)
+#  define BOOST_HAS_NL_TYPES_H
+#endif
+
+//
+// FreeBSD 3.x has pthreads support, but defines _POSIX_THREADS in &lt;pthread.h&gt;
+// and not in &lt;unistd.h&gt;
+//
+#if defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt;= 3)
+#  define BOOST_HAS_PTHREADS
+#endif
+
+//
+// No wide character support in the BSD header files:
+//
+#define BOOST_NO_CWCHAR
+
+//
+// The BSD &lt;ctype.h&gt; has macros only, no functions:
+//
+#define BOOST_NO_CTYPE_FUNCTIONS
+
+//
+// thread API's not auto detected:
+//
+#define BOOST_HAS_SCHED_YIELD
+#define BOOST_HAS_NANOSLEEP
+#define BOOST_HAS_GETTIMEOFDAY
+#define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#define BOOST_HAS_SIGACTION
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/cygwin.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/cygwin.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/cygwin.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,48 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  cygwin specific config options:
+
+#define BOOST_PLATFORM &quot;Cygwin&quot;
+#define BOOST_NO_CWCTYPE
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_SWPRINTF
+#define BOOST_HAS_DIRENT_H
+
+//
+// Threading API:
+// See if we have POSIX threads, if we do use them, otherwise
+// revert to native Win threads.
+#define BOOST_HAS_UNISTD_H
+#include &lt;unistd.h&gt;
+#if defined(_POSIX_THREADS) &amp;&amp; (_POSIX_THREADS+0 &gt;= 0) &amp;&amp; !defined(BOOST_HAS_WINTHREADS)
+#  define BOOST_HAS_PTHREADS
+#  define BOOST_HAS_SCHED_YIELD
+#  define BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#  define BOOST_HAS_SIGACTION
+#else
+#  if !defined(BOOST_HAS_WINTHREADS)
+#     define BOOST_HAS_WINTHREADS
+#  endif
+#  define BOOST_HAS_FTIME
+#endif
+
+//
+// find out if we have a stdint.h, there should be a better way to do this:
+//
+#include &lt;sys/types.h&gt;
+#ifdef _STDINT_H
+#define BOOST_HAS_STDINT_H
+#endif
+
+// boilerplate code:
+#include &lt;boost/config/posix_features.hpp&gt;
+ 
+
+
+

Added: trunk/source/libraries/boost/config/platform/hpux.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/hpux.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/hpux.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,62 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Toon Knapen 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  hpux specific config options:
+
+#define BOOST_PLATFORM &quot;HP-UX&quot;
+
+// In principle, HP-UX has a nice &lt;stdint.h&gt; under the name &lt;inttypes.h&gt;
+// However, it has the following problem:
+// Use of UINT32_C(0) results in &quot;0u l&quot; for the preprocessed source
+// (verifyable with gcc 2.95.3, assumed for HP aCC)
+// #define BOOST_HAS_STDINT_H
+
+#define BOOST_NO_SWPRINTF 
+#define BOOST_NO_CWCTYPE
+
+#ifdef __GNUC__
+   // GNU C on HP-UX does not support threads (checked up to gcc 3.3)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+// the following are always available:
+#ifndef BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_GETTIMEOFDAY
+#endif
+#ifndef BOOST_HAS_SCHED_YIELD
+#    define BOOST_HAS_SCHED_YIELD
+#endif
+#ifndef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#    define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#endif
+#ifndef BOOST_HAS_NL_TYPES_H
+#    define BOOST_HAS_NL_TYPES_H
+#endif
+#ifndef BOOST_HAS_NANOSLEEP
+#    define BOOST_HAS_NANOSLEEP
+#endif
+#ifndef BOOST_HAS_GETTIMEOFDAY
+#    define BOOST_HAS_GETTIMEOFDAY
+#endif
+#ifndef BOOST_HAS_DIRENT_H
+#    define BOOST_HAS_DIRENT_H
+#endif
+#ifndef BOOST_HAS_CLOCK_GETTIME
+#    define BOOST_HAS_CLOCK_GETTIME
+#endif
+#ifndef BOOST_HAS_SIGACTION
+#  define BOOST_HAS_SIGACTION
+#endif
+
+

Added: trunk/source/libraries/boost/config/platform/irix.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/irix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/irix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,31 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  SGI Irix specific config options:
+
+#define BOOST_PLATFORM &quot;SGI Irix&quot;
+
+#define BOOST_NO_SWPRINTF 
+//
+// these are not auto detected by POSIX feature tests:
+//
+#define BOOST_HAS_GETTIMEOFDAY
+#define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+
+#ifdef __GNUC__
+   // GNU C on IRIX does not support threads (checked up to gcc 3.3)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+

Added: trunk/source/libraries/boost/config/platform/linux.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/linux.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/linux.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,98 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  linux specific config options:
+
+#define BOOST_PLATFORM &quot;linux&quot;
+
+// make sure we have __GLIBC_PREREQ if available at all
+#include &lt;cstdlib&gt;
+
+//
+// &lt;stdint.h&gt; added to glibc 2.1.1
+// We can only test for 2.1 though:
+//
+#if defined(__GLIBC__) &amp;&amp; ((__GLIBC__ &gt; 2) || ((__GLIBC__ == 2) &amp;&amp; (__GLIBC_MINOR__ &gt;= 1)))
+   // &lt;stdint.h&gt; defines int64_t unconditionally, but &lt;sys/types.h&gt; defines
+   // int64_t only if __GNUC__.  Thus, assume a fully usable &lt;stdint.h&gt;
+   // only when using GCC.
+#  if defined __GNUC__
+#    define BOOST_HAS_STDINT_H
+#  endif
+#endif
+
+#if defined(__LIBCOMO__)
+   //
+   // como on linux doesn't have std:: c functions:
+   // NOTE: versions of libcomo prior to beta28 have octal version numbering,
+   // e.g. version 25 is 21 (dec)
+   //
+#  if __LIBCOMO_VERSION__ &lt;= 20
+#    define BOOST_NO_STDC_NAMESPACE
+#  endif
+
+#  if __LIBCOMO_VERSION__ &lt;= 21
+#    define BOOST_NO_SWPRINTF
+#  endif
+
+#endif
+
+//
+// If glibc is past version 2 then we definitely have
+// gettimeofday, earlier versions may or may not have it:
+//
+#if defined(__GLIBC__) &amp;&amp; (__GLIBC__ &gt;= 2)
+#  define BOOST_HAS_GETTIMEOFDAY
+#endif
+
+#ifdef __USE_POSIX199309
+#  define BOOST_HAS_NANOSLEEP
+#endif
+
+#if defined(__GLIBC__) &amp;&amp; defined(__GLIBC_PREREQ)
+// __GLIBC_PREREQ is available since 2.1.2
+
+   // swprintf is available since glibc 2.2.0
+#  if !__GLIBC_PREREQ(2,2) || (!defined(__USE_ISOC99) &amp;&amp; !defined(__USE_UNIX98))
+#    define BOOST_NO_SWPRINTF
+#  endif
+#else
+#  define BOOST_NO_SWPRINTF
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+#ifndef __GNUC__
+//
+// if the compiler is not gcc we still need to be able to parse
+// the GNU system headers, some of which (mainly &lt;stdint.h&gt;)
+// use GNU specific extensions:
+//
+#  ifndef __extension__
+#     define __extension__
+#  endif
+#  ifndef __const__
+#     define __const__ const
+#  endif
+#  ifndef __volatile__
+#     define __volatile__ volatile
+#  endif
+#  ifndef __signed__
+#     define __signed__ signed
+#  endif
+#  ifndef __typeof__
+#     define __typeof__ typeof
+#  endif
+#  ifndef __inline__
+#     define __inline__ inline
+#  endif
+#endif
+
+

Added: trunk/source/libraries/boost/config/platform/macos.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/macos.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/macos.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,70 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Bill Kempf 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Mac OS specific config options:
+
+#define BOOST_PLATFORM &quot;Mac OS&quot;
+
+#if __MACH__ &amp;&amp; !defined(_MSL_USING_MSL_C)
+
+// Using the Mac OS X system BSD-style C library.
+
+#  define BOOST_NO_CTYPE_FUNCTIONS
+#  define BOOST_NO_CWCHAR
+#  ifndef BOOST_HAS_UNISTD_H
+#    define BOOST_HAS_UNISTD_H
+#  endif
+// boilerplate code:
+#  ifndef TARGET_CARBON
+#     include &lt;boost/config/posix_features.hpp&gt;
+#  endif
+#  ifndef BOOST_HAS_STDINT_H
+#     define BOOST_HAS_STDINT_H
+#  endif
+
+//
+// BSD runtime has pthreads, sigaction, sched_yield and gettimeofday,
+// of these only pthreads are advertised in &lt;unistd.h&gt;, so set the 
+// other options explicitly:
+//
+#  define BOOST_HAS_SCHED_YIELD
+#  define BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_SIGACTION
+
+#  if (__GNUC__ &lt; 3) &amp;&amp; !defined( __APPLE_CC__)
+
+// GCC strange &quot;ignore std&quot; mode works better if you pretend everything
+// is in the std namespace, for the most part.
+
+#    define BOOST_NO_STDC_NAMESPACE
+#  endif
+
+#else
+
+// Using the MSL C library.
+
+// We will eventually support threads in non-Carbon builds, but we do
+// not support this yet.
+#  if TARGET_CARBON
+
+#    define BOOST_HAS_MPTASKS
+
+// The MP task implementation of Boost Threads aims to replace MP-unsafe
+// parts of the MSL, so we turn on threads unconditionally.
+#    define BOOST_HAS_THREADS
+
+// The remote call manager depends on this.
+#    define BOOST_BIND_ENABLE_PASCAL
+
+#  endif
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/platform/solaris.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/solaris.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/solaris.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,21 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  sun specific config options:
+
+#define BOOST_PLATFORM &quot;Sun Solaris&quot;
+
+#define BOOST_HAS_GETTIMEOFDAY
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+
+

Added: trunk/source/libraries/boost/config/platform/win32.hpp
===================================================================
--- trunk/source/libraries/boost/config/platform/win32.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/platform/win32.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,86 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Bill Kempf 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Win32 specific config options:
+
+#define BOOST_PLATFORM &quot;Win32&quot;
+
+#if defined(__GNUC__) &amp;&amp; !defined(BOOST_NO_SWPRINTF)
+#  define BOOST_NO_SWPRINTF
+#endif
+
+#if !defined(__GNUC__) &amp;&amp; !defined(BOOST_HAS_DECLSPEC)
+#  define BOOST_HAS_DECLSPEC
+#endif
+
+#if defined(__MINGW32__) &amp;&amp; ((__GNUC__ &gt; 3) || ((__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 2)))
+#  define BOOST_HAS_STDINT_H
+#  define __STDC_LIMIT_MACROS
+#endif
+
+//
+// Win32 will normally be using native Win32 threads,
+// but there is a pthread library avaliable as an option,
+// we used to disable this when BOOST_DISABLE_WIN32 was 
+// defined but no longer - this should allow some
+// files to be compiled in strict mode - while maintaining
+// a consistent setting of BOOST_HAS_THREADS across
+// all translation units (needed for shared_ptr etc).
+//
+#ifndef BOOST_HAS_PTHREADS
+#  define BOOST_HAS_WINTHREADS
+#endif
+
+#ifndef BOOST_DISABLE_WIN32
+// WEK: Added
+#define BOOST_HAS_FTIME
+
+#endif
+
+//
+// disable min/max macros:
+//
+#ifdef min
+#  undef min
+#endif
+#ifdef max
+#  undef max
+#endif
+#ifndef NOMINMAX
+#  define NOMINMAX
+#endif
+
+#ifdef BOOST_MSVC
+#include &lt;algorithm&gt; // for existing std::min and std::max
+namespace std{
+  // Apparently, something in the Microsoft libraries requires the &quot;long&quot;
+  // overload, because it calls the min/max functions with arguments of
+  // slightly different type.  (If this proves to be incorrect, this
+  // whole &quot;BOOST_MSVC&quot; section can be removed.)
+  inline long min(long __a, long __b) {
+    return __b &lt; __a ? __b : __a;
+  }
+  inline long max(long __a, long __b) {
+    return  __a &lt; __b ? __b : __a;
+  }
+  // The &quot;long double&quot; overload is required, otherwise user code calling
+  // min/max for floating-point numbers will use the &quot;long&quot; overload.
+  // (SourceForge bug #495495)
+  inline long double min(long double __a, long double __b) {
+    return __b &lt; __a ? __b : __a;
+  }
+  inline long double max(long double __a, long double __b) {
+    return  __a &lt; __b ? __b : __a;
+  }
+}
+using std::min;
+using std::max;
+#     endif
+
+

Added: trunk/source/libraries/boost/config/posix_features.hpp
===================================================================
--- trunk/source/libraries/boost/config/posix_features.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/posix_features.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,87 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// All POSIX feature tests go in this file,
+// Note that we test _POSIX_C_SOURCE and _XOPEN_SOURCE as well
+// _POSIX_VERSION and _XOPEN_VERSION: on some systems POSIX API's
+// may be present but none-functional unless _POSIX_C_SOURCE and
+// _XOPEN_SOURCE have been defined to the right value (it's up
+// to the user to do this *before* including any header, although
+// in most cases the compiler will do this for you).
+
+#  if defined(BOOST_HAS_UNISTD_H)
+#     include &lt;unistd.h&gt;
+
+      // XOpen has &lt;nl_types.h&gt;, but is this the correct version check?
+#     if defined(_XOPEN_VERSION) &amp;&amp; (_XOPEN_VERSION &gt;= 3)
+#        define BOOST_HAS_NL_TYPES_H
+#     endif
+
+      // POSIX version 6 requires &lt;stdint.h&gt;
+#     if defined(_POSIX_VERSION) &amp;&amp; (_POSIX_VERSION &gt;= 200100)
+#        define BOOST_HAS_STDINT_H
+#     endif
+
+      // POSIX version 2 requires &lt;dirent.h&gt;
+#     if defined(_POSIX_VERSION) &amp;&amp; (_POSIX_VERSION &gt;= 199009L)
+#        define BOOST_HAS_DIRENT_H
+#     endif
+
+      // POSIX version 3 requires &lt;signal.h&gt; to have sigaction:
+#     if defined(_POSIX_VERSION) &amp;&amp; (_POSIX_VERSION &gt;= 199506L)
+#        define BOOST_HAS_SIGACTION
+#     endif
+      // POSIX defines _POSIX_THREADS &gt; 0 for pthread support,
+      // however some platforms define _POSIX_THREADS without
+      // a value, hence the (_POSIX_THREADS+0 &gt;= 0) check.
+      // Strictly speaking this may catch platforms with a
+      // non-functioning stub &lt;pthreads.h&gt;, but such occurrences should
+      // occur very rarely if at all.
+#     if defined(_POSIX_THREADS) &amp;&amp; (_POSIX_THREADS+0 &gt;= 0) &amp;&amp; !defined(BOOST_HAS_WINTHREADS) &amp;&amp; !defined(BOOST_HAS_MPTASKS)
+#        define BOOST_HAS_PTHREADS
+#     endif
+
+      // BOOST_HAS_NANOSLEEP:
+      // This is predicated on _POSIX_TIMERS or _XOPEN_REALTIME:
+#     if (defined(_POSIX_TIMERS) &amp;&amp; (_POSIX_TIMERS+0 &gt;= 0)) \
+             || (defined(_XOPEN_REALTIME) &amp;&amp; (_XOPEN_REALTIME+0 &gt;= 0))
+#        define BOOST_HAS_NANOSLEEP
+#     endif
+
+      // BOOST_HAS_CLOCK_GETTIME:
+      // This is predicated on _POSIX_TIMERS (also on _XOPEN_REALTIME
+      // but at least one platform - linux - defines that flag without
+      // defining clock_gettime):
+#     if (defined(_POSIX_TIMERS) &amp;&amp; (_POSIX_TIMERS+0 &gt;= 0))
+#        define BOOST_HAS_CLOCK_GETTIME
+#     endif
+
+      // BOOST_HAS_SCHED_YIELD:
+      // This is predicated on _POSIX_PRIORITY_SCHEDULING or
+      // on _POSIX_THREAD_PRIORITY_SCHEDULING or on _XOPEN_REALTIME.
+#     if defined(_POSIX_PRIORITY_SCHEDULING) &amp;&amp; (_POSIX_PRIORITY_SCHEDULING+0 &gt; 0)\
+            || (defined(_POSIX_THREAD_PRIORITY_SCHEDULING) &amp;&amp; (_POSIX_THREAD_PRIORITY_SCHEDULING+0 &gt; 0))\
+            || (defined(_XOPEN_REALTIME) &amp;&amp; (_XOPEN_REALTIME+0 &gt;= 0))
+#        define BOOST_HAS_SCHED_YIELD
+#     endif
+
+      // BOOST_HAS_GETTIMEOFDAY:
+      // BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE:
+      // These are predicated on _XOPEN_VERSION, and appears to be first released
+      // in issue 4, version 2 (_XOPEN_VERSION &gt; 500).
+#     if defined(_XOPEN_VERSION) &amp;&amp; (_XOPEN_VERSION+0 &gt;= 500)
+#        define BOOST_HAS_GETTIMEOFDAY
+#        if defined(_XOPEN_SOURCE) &amp;&amp; (_XOPEN_SOURCE &gt;= 500)
+#           define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#        endif
+#     endif
+
+#  endif
+
+
+

Added: trunk/source/libraries/boost/config/requires_threads.hpp
===================================================================
--- trunk/source/libraries/boost/config/requires_threads.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/requires_threads.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,92 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+#ifndef BOOST_CONFIG_REQUIRES_THREADS_HPP
+#define BOOST_CONFIG_REQUIRES_THREADS_HPP
+
+#ifndef BOOST_CONFIG_HPP
+#  include &lt;boost/config.hpp&gt;
+#endif
+
+#if defined(BOOST_DISABLE_THREADS)
+
+//
+// special case to handle versions of gcc which don't currently support threads:
+//
+#if defined(__GNUC__) &amp;&amp; ((__GNUC__ &lt; 3) || (__GNUC_MINOR__ &lt;= 3) || !defined(BOOST_STRICT_CONFIG))
+//
+// this is checked up to gcc 3.3:
+//
+#if defined(__sgi) || defined(__hpux)
+#  error &quot;Multi-threaded programs are not supported by gcc on HPUX or Irix (last checked with gcc 3.3)&quot;
+#endif
+
+#endif
+
+#  error &quot;Threading support unavaliable: it has been explicitly disabled with BOOST_DISABLE_THREADS&quot;
+
+#elif !defined(BOOST_HAS_THREADS)
+
+# if defined __COMO__
+//  Comeau C++
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -D_MT (Windows) or -D_REENTRANT (Unix)&quot;
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
+//  Intel
+#ifdef _WIN32
+#  error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: either /MT /MTd /MD or /MDd&quot;
+#else
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -openmp&quot;
+#endif
+
+# elif defined __GNUC__
+//  GNU C++:
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -pthread (Linux), -pthreads (Solaris) or -mthreads (Mingw32)&quot;
+
+#elif defined __sgi
+//  SGI MIPSpro C++
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -D_SGI_MP_SOURCE&quot;
+
+#elif defined __DECCXX
+//  Compaq Tru64 Unix cxx
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -pthread&quot;
+
+#elif defined __BORLANDC__
+//  Borland
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -tWM&quot;
+
+#elif defined  __MWERKS__
+//  Metrowerks CodeWarrior
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: either -runtime sm, -runtime smd, -runtime dm, or -runtime dmd&quot;
+
+#elif defined  __SUNPRO_CC
+//  Sun Workshop Compiler C++
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -mt&quot;
+
+#elif defined __HP_aCC
+//  HP aCC
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -mt&quot;
+
+#elif defined(__IBMCPP__)
+//  IBM Visual Age
+#   error &quot;Compiler threading support is not turned on. Please compile the code with the xlC_r compiler&quot;
+
+#elif defined _MSC_VER
+//  Microsoft Visual C++
+//
+//  Must remain the last #elif since some other vendors (Metrowerks, for
+//  example) also #define _MSC_VER
+#  error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: either /MT /MTd /MD or /MDd&quot;
+
+#else
+
+#  error &quot;Compiler threading support is not turned on.  Please consult your compiler's documentation for the appropriate options to use&quot;
+
+#endif // compilers
+
+#endif // BOOST_HAS_THREADS
+
+#endif // BOOST_CONFIG_REQUIRES_THREADS_HPP

Added: trunk/source/libraries/boost/config/select_compiler_config.hpp
===================================================================
--- trunk/source/libraries/boost/config/select_compiler_config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/select_compiler_config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,83 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Martin Wille 2003.
+//  (C) Copyright Guillaume Melquiond 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// locate which compiler we are using and define
+// BOOST_COMPILER_CONFIG as needed: 
+
+# if defined __COMO__
+//  Comeau C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/comeau.hpp&quot;
+
+#elif defined __DMC__
+//  Digital Mars C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/digitalmars.hpp&quot;
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
+//  Intel
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/intel.hpp&quot;
+
+# elif defined __GNUC__
+//  GNU C++:
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/gcc.hpp&quot;
+
+#elif defined __KCC
+//  Kai C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/kai.hpp&quot;
+
+#elif defined __sgi
+//  SGI MIPSpro C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/sgi_mipspro.hpp&quot;
+
+#elif defined __DECCXX
+//  Compaq Tru64 Unix cxx
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/compaq_cxx.hpp&quot;
+
+#elif defined __ghs
+//  Greenhills C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/greenhills.hpp&quot;
+
+#elif defined __BORLANDC__
+//  Borland
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/borland.hpp&quot;
+
+#elif defined  __MWERKS__
+//  Metrowerks CodeWarrior
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/metrowerks.hpp&quot;
+
+#elif defined  __SUNPRO_CC
+//  Sun Workshop Compiler C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/sunpro_cc.hpp&quot;
+
+#elif defined __HP_aCC
+//  HP aCC
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/hp_acc.hpp&quot;
+
+#elif defined(__MRC__) || defined(__SC__)
+//  MPW MrCpp or SCpp
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/mpw.hpp&quot;
+
+#elif defined(__IBMCPP__)
+//  IBM Visual Age
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/vacpp.hpp&quot;
+
+#elif defined _MSC_VER
+//  Microsoft Visual C++
+//
+//  Must remain the last #elif since some other vendors (Metrowerks, for
+//  example) also #define _MSC_VER
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/visualc.hpp&quot;
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the compiler:
+#  error &quot;Unknown compiler - please configure (<A HREF="http://www.boost.org/libs/config/config.htm#configuring">http://www.boost.org/libs/config/config.htm#configuring</A>) and report the results to the main boost mailing list (<A HREF="http://www.boost.org/more/mailing_lists.htm#main">http://www.boost.org/more/mailing_lists.htm#main</A>)&quot;
+
+#endif

Added: trunk/source/libraries/boost/config/select_platform_config.hpp
===================================================================
--- trunk/source/libraries/boost/config/select_platform_config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/select_platform_config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,86 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// locate which platform we are on and define BOOST_PLATFORM_CONFIG as needed.
+// Note that we define the headers to include using &quot;header_name&quot; not
+// &lt;header_name&gt; in order to prevent macro expansion within the header
+// name (for example &quot;linux&quot; is a macro on linux systems).
+
+#if defined(linux) || defined(__linux) || defined(__linux__)
+// linux:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/linux.hpp&quot;
+
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+// BSD:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/bsd.hpp&quot;
+
+#elif defined(sun) || defined(__sun)
+// solaris:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/solaris.hpp&quot;
+
+#elif defined(__sgi)
+// SGI Irix:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/irix.hpp&quot;
+
+#elif defined(__hpux)
+// hp unix:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/hpux.hpp&quot;
+
+#elif defined(__CYGWIN__)
+// cygwin is not win32:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/cygwin.hpp&quot;
+
+#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
+// win32:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/win32.hpp&quot;
+
+#elif defined(__BEOS__)
+// BeOS
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/beos.hpp&quot;
+
+#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)
+// MacOS
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/macos.hpp&quot;
+
+#elif defined(__IBMCPP__)
+// IBM
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/aix.hpp&quot;
+
+#elif defined(__amigaos__)
+// AmigaOS
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/amigaos.hpp&quot;
+
+#else
+
+#  if defined(unix) \
+      || defined(__unix) \
+      || defined(_XOPEN_SOURCE) \
+      || defined(_POSIX_SOURCE)
+
+   // generic unix platform:
+
+#  ifndef BOOST_HAS_UNISTD_H
+#     define BOOST_HAS_UNISTD_H
+#  endif
+
+#  include &lt;boost/config/posix_features.hpp&gt;
+
+#  endif
+
+#  if defined (BOOST_ASSERT_CONFIG)
+      // this must come last - generate an error if we don't
+      // recognise the platform:
+#     error &quot;Unknown platform - please configure and report the results to boost.org&quot;
+#  endif
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/select_stdlib_config.hpp
===================================================================
--- trunk/source/libraries/boost/config/select_stdlib_config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/select_stdlib_config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,68 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// locate which std lib we are using and define BOOST_STDLIB_CONFIG as needed:
+
+// we need to include a std lib header here in order to detect which
+// library is in use, use &lt;utility&gt; as it's about the smallest
+// of the std lib headers - do not rely on this header being included -
+// users can short-circuit this header if they know whose std lib
+// they are using.
+
+#include &lt;utility&gt;
+
+#if defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+// STLPort library; this _must_ come first, otherwise since
+// STLport typically sits on top of some other library, we
+// can end up detecting that first rather than STLport:
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/stlport.hpp&quot;
+
+#elif defined(__LIBCOMO__)
+// Comeau STL:
+#define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/libcomo.hpp&quot;
+
+#elif defined(__STD_RWCOMPILER_H__) || defined(_RWSTD_VER)
+// Rogue Wave library:
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/roguewave.hpp&quot;
+
+#elif defined(__GLIBCPP__)
+// GNU libstdc++ 3
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/libstdcpp3.hpp&quot;
+
+#elif defined(__STL_CONFIG_H)
+// generic SGI STL
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/sgi.hpp&quot;
+
+#elif defined(__MSL_CPP__)
+// MSL standard lib:
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/msl.hpp&quot;
+
+#elif defined(__IBMCPP__)
+// take the default VACPP std lib
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/vacpp.hpp&quot;
+
+#elif defined(MSIPL_COMPILE_H)
+// Modena C++ standard library
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/modena.hpp&quot;
+
+#elif (defined(_YVALS) &amp;&amp; !defined(__IBMCPP__)) || defined(_CPPLIB_VER)
+// Dinkumware Library (this has to appear after any possible replacement libraries):
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/dinkumware.hpp&quot;
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the library:
+#  error &quot;Unknown standard library - please configure and report the results to boost.org&quot;
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/dinkumware.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/dinkumware.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/dinkumware.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,96 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright Jens Maurer 2001.
+//  (C) Copyright Peter Dimov 2001.
+//  (C) Copyright David Abrahams 2002.
+//  (C) Copyright Guillaume Melquiond 2003.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Dinkumware standard library config:
+
+#if !defined(_YVALS) &amp;&amp; !defined(_CPPLIB_VER)
+#include &lt;utility&gt;
+#if !defined(_YVALS) &amp;&amp; !defined(_CPPLIB_VER)
+#error This is not the Dinkumware lib!
+#endif
+#endif
+
+
+#if defined(_CPPLIB_VER) &amp;&amp; (_CPPLIB_VER &gt;= 306)
+   // full dinkumware 3.06 and above
+   // fully conforming provided the compiler supports it:
+#  if !(defined(_GLOBAL_USING) &amp;&amp; (_GLOBAL_USING+0 &gt; 0)) &amp;&amp; !defined(__BORLANDC__) &amp;&amp; !defined(_STD) &amp;&amp; !(defined(__ICC) &amp;&amp; (__ICC &gt;= 700))   // can be defined in yvals.h
+#     define BOOST_NO_STDC_NAMESPACE
+#  endif
+#  if !(defined(_HAS_MEMBER_TEMPLATES_REBIND) &amp;&amp; (_HAS_MEMBER_TEMPLATES_REBIND+0 &gt; 0)) &amp;&amp; !(defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt; 1300)) &amp;&amp; defined(BOOST_MSVC)
+#     define BOOST_NO_STD_ALLOCATOR
+#  endif
+#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#  if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1300)) &amp;&amp; !defined(__BORLANDC__)
+      // if this lib version is set up for vc6 then there is no std::use_facet:
+#     define BOOST_NO_STD_USE_FACET
+#     define BOOST_HAS_TWO_ARG_USE_FACET
+      // C lib functions aren't in namespace std either:
+#     define BOOST_NO_STDC_NAMESPACE
+      // and nor is &lt;exception&gt;
+#     define BOOST_NO_EXCEPTION_STD_NAMESPACE
+#  endif
+// There's no numeric_limits&lt;long long&gt; support unless _LONGLONG is defined:
+#  if !defined(_LONGLONG) &amp;&amp; (_CPPLIB_VER &lt;= 310)
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#  endif
+// 3.06 appears to have (non-sgi versions of) &lt;hash_set&gt; &amp; &lt;hash_map&gt;,
+// and no &lt;slist&gt; at all
+#else
+#  define BOOST_MSVC_STD_ITERATOR 1
+#  define BOOST_NO_STD_ITERATOR
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#  define BOOST_NO_STDC_NAMESPACE
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_NO_STD_OUTPUT_ITERATOR_ASSIGN
+#  define BOOST_HAS_MACRO_USE_FACET
+#  ifndef _CPPLIB_VER
+      // Updated Dinkum library defines this, and provides
+      // its own min and max definitions.
+#     define BOOST_NO_STD_MIN_MAX
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#  endif
+#endif
+
+
+#if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1300) &amp;&amp; !defined(__BORLANDC__)) || !defined(_CPPLIB_VER) || (_CPPLIB_VER &lt; 306)
+   // if we're using a dinkum lib that's
+   // been configured for VC6/7 then there is
+   // no iterator traits (true even for icl)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+#if defined(__ICL) &amp;&amp; defined(_CPPLIB_VER) &amp;&amp; (_CPPLIB_VER &lt;= 310)
+// Intel C++ chokes over any non-trivial use of &lt;locale&gt;
+// this may be an overly restrictive define, but regex fails without it:
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+#ifdef _CPPLIB_VER
+#  define BOOST_DINKUMWARE_STDLIB _CPPLIB_VER
+#else
+#  define BOOST_DINKUMWARE_STDLIB 1
+#endif
+
+#ifdef _CPPLIB_VER
+#  define BOOST_STDLIB &quot;Dinkumware standard library version &quot; BOOST_STRINGIZE(_CPPLIB_VER)
+#else
+#  define BOOST_STDLIB &quot;Dinkumware standard library version 1.x&quot;
+#endif
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/libcomo.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/libcomo.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/libcomo.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,37 @@
+//  (C) Copyright John Maddock 2002 - 2003. 
+//  (C) Copyright Jens Maurer 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Comeau STL:
+
+#if !defined(__LIBCOMO__)
+#  include &lt;utility&gt;
+#  if !defined(__LIBCOMO__)
+#      error &quot;This is not the Comeau STL!&quot;
+#  endif
+#endif
+
+//
+// std::streambuf&lt;wchar_t&gt; is non-standard
+// NOTE: versions of libcomo prior to beta28 have octal version numbering,
+// e.g. version 25 is 21 (dec)
+#if __LIBCOMO_VERSION__ &lt;= 22
+#  define BOOST_NO_STD_WSTREAMBUF
+#endif
+
+//
+// Intrinsic type_traits support.
+// The SGI STL has it's own __type_traits class, which
+// has intrinsic compiler support with SGI's compilers.
+// Whatever map SGI style type traits to boost equivalents:
+//
+#define BOOST_HAS_SGI_TYPE_TRAITS
+
+#define BOOST_STDLIB &quot;Comeau standard library &quot; BOOST_STRINGIZE(__LIBCOMO_VERSION__)
+
+

Added: trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/libstdcpp3.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,27 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  config for libstdc++ v3
+//  not much to go in here:
+
+#define BOOST_STDLIB &quot;GNU libstdc++ version &quot; BOOST_STRINGIZE(__GLIBCPP__)
+
+#ifndef _GLIBCPP_USE_WCHAR_T
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_CWCTYPE
+#  define BOOST_NO_STD_WSTRING
+#  define BOOST_NO_STD_WSTREAMBUF
+#endif
+ 
+#ifndef _GLIBCPP_USE_LONG_LONG
+// May have been set by compiler/*.hpp, but &quot;long long&quot; without library
+// support is useless.
+#  undef BOOST_HAS_LONG_LONG
+#endif
+
+

Added: trunk/source/libraries/boost/config/stdlib/modena.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/modena.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/modena.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,30 @@
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Modena C++ standard library (comes with KAI C++)
+
+#if !defined(MSIPL_COMPILE_H)
+#  include &lt;utility&gt;
+#  if !defined(__MSIPL_COMPILE_H)
+#      error &quot;This is not the Modena C++ library!&quot;
+#  endif
+#endif
+
+#ifndef MSIPL_NL_TYPES
+#define BOOST_NO_STD_MESSAGES
+#endif
+
+#ifndef MSIPL_WCHART
+#define BOOST_NO_STD_WSTRING
+#endif
+
+#define BOOST_STDLIB &quot;Modena C++ standard library&quot;
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/msl.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/msl.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/msl.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,52 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Darin Adler 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Metrowerks standard library:
+
+#ifndef __MSL_CPP__
+#  include &lt;utility&gt;
+#  ifndef __MSL_CPP__
+#     error This is not the MSL standard library!
+#  endif
+#endif
+
+#if __MSL_CPP__ &gt;= 0x6000  // Pro 6
+#  define BOOST_HAS_HASH
+#  define BOOST_STD_EXTENSION_NAMESPACE Metrowerks
+#endif
+#define BOOST_HAS_SLIST
+
+#if __MSL_CPP__ &lt; 0x6209
+#  define BOOST_NO_STD_MESSAGES
+#endif
+
+// check C lib version for &lt;stdint.h&gt;
+#include &lt;cstddef&gt;
+
+#if defined(__MSL__) &amp;&amp; (__MSL__ &gt;= 0x5000)
+#  define BOOST_HAS_STDINT_H
+#  define BOOST_HAS_UNISTD_H
+   // boilerplate code:
+#  include &lt;boost/config/posix_features.hpp&gt;
+#endif
+
+#if defined(_MWMT) || _MSL_THREADSAFE
+#  define BOOST_HAS_THREADS
+#endif
+
+
+#define BOOST_STDLIB &quot;Metrowerks Standard Library version &quot; BOOST_STRINGIZE(__MSL_CPP__)
+
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/roguewave.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/roguewave.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/roguewave.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,121 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Rogue Wave std lib:
+
+#if !defined(__STD_RWCOMPILER_H__) &amp;&amp; !defined(_RWSTD_VER)
+#  include &lt;utility&gt;
+#  if !defined(__STD_RWCOMPILER_H__) &amp;&amp; !defined(_RWSTD_VER)
+#     error This is not the Rogue Wave standard library
+#  endif
+#endif
+//
+// figure out a consistent version number:
+//
+#ifndef _RWSTD_VER
+#  define BOOST_RWSTD_VER 0x010000
+#elif _RWSTD_VER &lt; 0x010000
+#  define BOOST_RWSTD_VER (_RWSTD_VER &lt;&lt; 8)
+#else
+#  define BOOST_RWSTD_VER _RWSTD_VER
+#endif
+
+#ifndef _RWSTD_VER
+#  define BOOST_STDLIB &quot;Rogue Wave standard library version (Unknown version)&quot;
+#else
+#  define BOOST_STDLIB &quot;Rogue Wave standard library version &quot; BOOST_STRINGIZE(_RWSTD_VER)
+#endif
+
+//
+// Prior to version 2.2.0 the primary template for std::numeric_limits
+// does not have compile time constants, even though specializations of that
+// template do:
+//
+#if BOOST_RWSTD_VER &lt; 0x020200
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#endif
+
+#if BOOST_RWSTD_VER &lt;= 0x020101
+#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+# endif
+
+//
+// Borland version of numeric_limits lacks __int64 specialisation:
+//
+#ifdef __BORLANDC__
+#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#endif
+
+//
+// No std::iterator if it can't figure out default template args:
+//
+#if defined(_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) || defined(RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) || (BOOST_RWSTD_VER &lt; 0x020000)
+#  define BOOST_NO_STD_ITERATOR
+#endif
+
+//
+// No iterator traits without partial specialization:
+//
+#if defined(_RWSTD_NO_CLASS_PARTIAL_SPEC) || defined(RWSTD_NO_CLASS_PARTIAL_SPEC)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// Prior to version 2.0, std::auto_ptr was buggy, and there were no
+// new-style iostreams, and no conformant std::allocator:
+//
+#if (BOOST_RWSTD_VER &lt; 0x020000)
+#  define BOOST_NO_AUTO_PTR
+#  define BOOST_NO_STRINGSTREAM
+#  define BOOST_NO_STD_ALLOCATOR
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// No template iterator constructors without member template support:
+//
+#if defined(RWSTD_NO_MEMBER_TEMPLATES) || defined(_RWSTD_NO_MEMBER_TEMPLATES)
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#endif
+
+//
+// RW defines _RWSTD_ALLOCATOR if the allocator is conformant and in use
+// (the or _HPACC_ part is a hack - the library seems to define _RWSTD_ALLOCATOR
+// on HP aCC systems even though the allocator is in fact broken):
+//
+#if !defined(_RWSTD_ALLOCATOR) || (defined(__HP_aCC) &amp;&amp; __HP_aCC &lt;= 33100)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// If we have a std::locale, we still may not have std::use_facet:
+//
+#if defined(_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE) &amp;&amp; !defined(BOOST_NO_STD_LOCALE)
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_HAS_TWO_ARG_USE_FACET
+#endif
+
+//
+// There's no std::distance prior to version 2, or without
+// partial specialization support:
+//
+#if (BOOST_RWSTD_VER &lt; 0x020000) || defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)
+    #define BOOST_NO_STD_DISTANCE
+#endif
+
+//
+// Some versions of the rogue wave library don't have assignable
+// OutputIterators:
+//
+#if BOOST_RWSTD_VER &lt; 0x020100
+#  define BOOST_NO_STD_OUTPUT_ITERATOR_ASSIGN
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/sgi.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/sgi.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/sgi.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,111 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  generic SGI STL:
+
+#if !defined(__STL_CONFIG_H)
+#  include &lt;utility&gt;
+#  if !defined(__STL_CONFIG_H)
+#      error &quot;This is not the SGI STL!&quot;
+#  endif
+#endif
+
+//
+// No std::iterator traits without partial specialisation:
+//
+#if !defined(__STL_CLASS_PARTIAL_SPECIALIZATION)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// No std::stringstream with gcc &lt; 3
+//
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3) &amp;&amp; \
+     ((__GNUC_MINOR__ &lt; 95) || (__GNUC_MINOR__ == 96)) &amp;&amp; \
+     !defined(__STL_USE_NEW_IOSTREAMS) || \
+   defined(__APPLE_CC__)
+   // Note that we only set this for GNU C++ prior to 2.95 since the
+   // latest patches for that release do contain a minimal &lt;sstream&gt;
+   // If you are running a 2.95 release prior to 2.95.3 then this will need
+   // setting, but there is no way to detect that automatically (other
+   // than by running the configure script).
+   // Also, the unofficial GNU C++ 2.96 included in RedHat 7.1 doesn't
+   // have &lt;sstream&gt;.
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// Assume no std::locale without own iostreams (this may be an
+// incorrect assumption in some cases):
+//
+#if !defined(__SGI_STL_OWN_IOSTREAMS) &amp;&amp; !defined(__STL_USE_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// Original native SGI streams have non-standard std::messages facet:
+//
+#if defined(__sgi) &amp;&amp; (_COMPILER_VERSION &lt;= 650) &amp;&amp; !defined(__SGI_STL_OWN_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// SGI's new iostreams have missing &quot;const&quot; in messages&lt;&gt;::open
+//
+#if defined(__sgi) &amp;&amp; (_COMPILER_VERSION &lt;= 740) &amp;&amp; defined(__STL_USE_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_MESSAGES
+#endif
+
+//
+// No template iterator constructors, or std::allocator
+// without member templates:
+//
+#if !defined(__STL_MEMBER_TEMPLATES)
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// We always have SGI style hash_set, hash_map, and slist:
+//
+#define BOOST_HAS_HASH
+#define BOOST_HAS_SLIST
+
+//
+// If this is GNU libstdc++2, then no &lt;limits&gt; and no std::wstring:
+//
+#if (defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3))
+#  include &lt;string&gt;
+#  if defined(__BASTRING__)
+#     define BOOST_NO_LIMITS
+// Note: &lt;boost/limits.hpp&gt; will provide compile-time constants
+#     undef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#     define BOOST_NO_STD_WSTRING
+#  endif
+#endif
+
+//
+// There is no standard iterator unless we have namespace support:
+//
+#if !defined(__STL_USE_NAMESPACES)
+#  define BOOST_NO_STD_ITERATOR
+#endif
+
+//
+// Intrinsic type_traits support.
+// The SGI STL has it's own __type_traits class, which
+// has intrinsic compiler support with SGI's compilers.
+// Whatever map SGI style type traits to boost equivalents:
+//
+#define BOOST_HAS_SGI_TYPE_TRAITS
+
+#define BOOST_STDLIB &quot;SGI standard library&quot;
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/stlport.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/stlport.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/stlport.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,169 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  STLPort standard library config:
+
+#if !defined(__SGI_STL_PORT) &amp;&amp; !defined(_STLPORT_VERSION)
+#  include &lt;utility&gt;
+#  if !defined(__SGI_STL_PORT) &amp;&amp; !defined(_STLPORT_VERSION)
+#      error &quot;This is not STLPort!&quot;
+#  endif
+#endif
+
+//
+// __STL_STATIC_CONST_INIT_BUG implies BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+// for versions prior to 4.1(beta)
+//
+#if (defined(__STL_STATIC_CONST_INIT_BUG) || defined(_STLP_STATIC_CONST_INIT_BUG)) &amp;&amp; (__SGI_STL_PORT &lt;= 0x400)
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#endif
+
+//
+// If STLport thinks that there is no partial specialisation, then there is no
+// std::iterator traits:
+//
+#if !(defined(_STLP_CLASS_PARTIAL_SPECIALIZATION) || defined(__STL_CLASS_PARTIAL_SPECIALIZATION))
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// No new style iostreams on GCC without STLport's iostreams enabled:
+//
+#if (defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3)) &amp;&amp; !(defined(__SGI_STL_OWN_IOSTREAMS) || defined(_STLP_OWN_IOSTREAMS))
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// No new iostreams implies no std::locale, and no std::stringstream:
+//
+#if defined(__STL_NO_IOSTREAMS) || defined(__STL_NO_NEW_IOSTREAMS) || defined(_STLP_NO_IOSTREAMS) || defined(_STLP_NO_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// If the streams are not native, and we have a &quot;using ::x&quot; compiler bug
+// then the io stream facets are not available in namespace std::
+//
+#ifdef _STLPORT_VERSION
+#  if !defined(_STLP_OWN_IOSTREAMS) &amp;&amp; defined(_STLP_USE_NAMESPACES) &amp;&amp; defined(BOOST_NO_USING_TEMPLATE) &amp;&amp; !defined(__BORLANDC__)
+#     define BOOST_NO_STD_LOCALE
+#  endif
+#else
+#  if !defined(__SGI_STL_OWN_IOSTREAMS) &amp;&amp; defined(__STL_USE_NAMESPACES) &amp;&amp; defined(BOOST_NO_USING_TEMPLATE) &amp;&amp; !defined(__BORLANDC__)
+#     define BOOST_NO_STD_LOCALE
+#  endif
+#endif
+
+//
+// Without member template support enabled, their are no template
+// iterate constructors, and no std::allocator:
+//
+#if !(defined(__STL_MEMBER_TEMPLATES) || defined(_STLP_MEMBER_TEMPLATES))
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+//
+// however we always have at least a partial allocator:
+//
+#define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+
+#if !defined(_STLP_MEMBER_TEMPLATE_CLASSES)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+#if defined(_STLP_NO_MEMBER_TEMPLATE_KEYWORD) &amp;&amp; defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC &lt;= 1300)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// We always have SGI style hash_set, hash_map, and slist:
+//
+#define BOOST_HAS_HASH
+#define BOOST_HAS_SLIST
+
+//
+// STLport does a good job of importing names into namespace std::,
+// but doesn't always get them all, define BOOST_NO_STDC_NAMESPACE, since our
+// workaround does not conflict with STLports:
+//
+//
+// Harold Howe says:
+// Borland switched to STLport in BCB6. Defining BOOST_NO_STDC_NAMESPACE with
+// BCB6 does cause problems. If we detect C++ Builder, then don't define 
+// BOOST_NO_STDC_NAMESPACE
+//
+#if !defined(__BORLANDC__) &amp;&amp; !defined(__DMC__)
+//
+// If STLport is using it's own namespace, and the real names are in
+// the global namespace, then we duplicate STLport's using declarations
+// (by defining BOOST_NO_STDC_NAMESPACE), we do this because STLport doesn't
+// necessarily import all the names we need into namespace std::
+// 
+#  if (defined(__STL_IMPORT_VENDOR_CSTD) \
+         || defined(__STL_USE_OWN_NAMESPACE) \
+         || defined(_STLP_IMPORT_VENDOR_CSTD) \
+         || defined(_STLP_USE_OWN_NAMESPACE)) \
+      &amp;&amp; (defined(__STL_VENDOR_GLOBAL_CSTD) || defined (_STLP_VENDOR_GLOBAL_CSTD))
+#     define BOOST_NO_STDC_NAMESPACE
+#     define BOOST_NO_EXCEPTION_STD_NAMESPACE
+#  endif
+#elif defined(__BORLANDC__) &amp;&amp; __BORLANDC__ &lt; 0x560
+// STLport doesn't import std::abs correctly:
+#include &lt;stdlib.h&gt;
+namespace std { using ::abs; }
+// and strcmp/strcpy don't get imported either ('cos they are macros)
+#include &lt;string.h&gt;
+#ifdef strcpy
+#  undef strcpy
+#endif
+#ifdef strcmp
+#  undef strcmp
+#endif
+#ifdef _STLP_VENDOR_CSTD
+namespace std{ using _STLP_VENDOR_CSTD::strcmp; using _STLP_VENDOR_CSTD::strcpy; }
+#endif
+#endif
+
+//
+// std::use_facet may be non-standard, uses a class instead:
+//
+#if defined(__STL_NO_EXPLICIT_FUNCTION_TMPL_ARGS) || defined(_STLP_NO_EXPLICIT_FUNCTION_TMPL_ARGS)
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_HAS_STLP_USE_FACET
+#endif
+
+//
+// If STLport thinks there are no wide functions, &lt;cwchar&gt; etc. is not working; but
+// only if BOOST_NO_STDC_NAMESPACE is not defined (if it is then we do the import 
+// into std:: ourselves).
+//
+#if defined(_STLP_NO_NATIVE_WIDE_FUNCTIONS) &amp;&amp; !defined(BOOST_NO_STDC_NAMESPACE)
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_CWCTYPE
+#endif
+
+//
+// Borland ships a version of STLport with C++ Builder 6 that lacks
+// hashtables and the like:
+//
+#if defined(__BORLANDC__) &amp;&amp; (__BORLANDC__ == 0x560)
+#  undef BOOST_HAS_HASH
+#endif
+
+
+#define BOOST_STDLIB &quot;STLPort standard library version &quot; BOOST_STRINGIZE(__SGI_STL_PORT)
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/config/stdlib/vacpp.hpp
===================================================================
--- trunk/source/libraries/boost/config/stdlib/vacpp.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/stdlib/vacpp.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,17 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+#if __IBMCPP__ &lt;= 501
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+#define BOOST_HAS_MACRO_USE_FACET
+
+#define BOOST_STDLIB &quot;Visual Age default standard library&quot;
+
+
+

Added: trunk/source/libraries/boost/config/suffix.hpp
===================================================================
--- trunk/source/libraries/boost/config/suffix.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/suffix.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,508 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Bill Kempf 2002. 
+//  (C) Copyright Jens Maurer 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Gennaro Prota 2003. 
+//  (C) Copyright Eric Friedman 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  <A HREF="http://www.boost.org/libs/config">http://www.boost.org/libs/config</A>
+//
+//  This file is intended to be stable, and relatively unchanging.
+//  It should contain boilerplate code only - no compiler specific
+//  code unless it is unavoidable - no changes unless unavoidable.
+
+#ifndef BOOST_CONFIG_SUFFIX_HPP
+#define BOOST_CONFIG_SUFFIX_HPP
+
+//
+// look for long long by looking for the appropriate macros in &lt;limits.h&gt;.
+// Note that we use limits.h rather than climits for maximal portability,
+// remember that since these just declare a bunch of macros, there should be
+// no namespace issues from this.
+//
+#include &lt;limits.h&gt;
+# if !defined(BOOST_HAS_LONG_LONG)                                              \
+   &amp;&amp; !(defined(BOOST_MSVC) &amp;&amp; BOOST_MSVC &lt;=1300) &amp;&amp; !defined(__BORLANDC__)     \
+   &amp;&amp; (defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX))
+#  define BOOST_HAS_LONG_LONG
+#endif
+#if !defined(BOOST_HAS_LONG_LONG) &amp;&amp; !defined(BOOST_NO_INTEGRAL_INT64_T)
+#  define BOOST_NO_INTEGRAL_INT64_T
+#endif
+
+// GCC 3.x will clean up all of those nasty macro definitions that
+// BOOST_NO_CTYPE_FUNCTIONS is intended to help work around, so undefine
+// it under GCC 3.x.
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3) &amp;&amp; defined(BOOST_NO_CTYPE_FUNCTIONS)
+#  undef BOOST_NO_CTYPE_FUNCTIONS
+#endif
+
+
+//
+// Assume any extensions are in namespace std:: unless stated otherwise:
+//
+#  ifndef BOOST_STD_EXTENSION_NAMESPACE
+#    define BOOST_STD_EXTENSION_NAMESPACE std
+#  endif
+
+//
+// If cv-qualified specializations are not allowed, then neither are cv-void ones:
+//
+#  if defined(BOOST_NO_CV_SPECIALIZATIONS) \
+      &amp;&amp; !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+#     define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  endif
+
+//
+// If there is no numeric_limits template, then it can't have any compile time
+// constants either!
+//
+#  if defined(BOOST_NO_LIMITS) \
+      &amp;&amp; !defined(BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS)
+#     define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#     define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#  endif
+
+//
+// if there is no long long then there is no specialisation
+// for numeric_limits&lt;long long&gt; either:
+//
+#if !defined(BOOST_HAS_LONG_LONG) &amp;&amp; !defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)
+#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#endif
+
+//
+// if there is no __int64 then there is no specialisation
+// for numeric_limits&lt;__int64&gt; either:
+//
+#if !defined(BOOST_HAS_MS_INT64) &amp;&amp; !defined(BOOST_NO_MS_INT64_NUMERIC_LIMITS)
+#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#endif
+
+//
+// if member templates are supported then so is the
+// VC6 subset of member templates:
+//
+#  if !defined(BOOST_NO_MEMBER_TEMPLATES) \
+       &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#     define BOOST_MSVC6_MEMBER_TEMPLATES
+#  endif
+
+//
+// Without partial specialization, can't test for partial specialisation bugs:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      &amp;&amp; !defined(BOOST_BCB_PARTIAL_SPECIALIZATION_BUG)
+#     define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG
+#  endif
+
+//
+// Without partial specialization, we can't have array-type partial specialisations:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      &amp;&amp; !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+#     define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+#  endif
+
+//
+// Without partial specialization, std::iterator_traits can't work:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      &amp;&amp; !defined(BOOST_NO_STD_ITERATOR_TRAITS)
+#     define BOOST_NO_STD_ITERATOR_TRAITS
+#  endif
+
+//
+// Without member template support, we can't have template constructors
+// in the standard library either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS)
+#     define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  endif
+
+//
+// Without member template support, we can't have a conforming
+// std::allocator template either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_NO_STD_ALLOCATOR)
+#     define BOOST_NO_STD_ALLOCATOR
+#  endif
+
+//
+// without ADL support then using declarations will break ADL as well:
+//
+#if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP) &amp;&amp; !defined(BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL)
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#endif
+
+//
+// If we have a standard allocator, then we have a partial one as well:
+//
+#if !defined(BOOST_NO_STD_ALLOCATOR)
+#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#endif
+
+//
+// We can't have a working std::use_facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) &amp;&amp; !defined(BOOST_NO_STD_USE_FACET)
+#     define BOOST_NO_STD_USE_FACET
+#  endif
+
+//
+// We can't have a std::messages facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) &amp;&amp; !defined(BOOST_NO_STD_MESSAGES)
+#     define BOOST_NO_STD_MESSAGES
+#  endif
+
+//
+// We can't have a working std::wstreambuf if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) &amp;&amp; !defined(BOOST_NO_STD_WSTREAMBUF)
+#     define BOOST_NO_STD_WSTREAMBUF
+#  endif
+
+//
+// We can't have a &lt;cwctype&gt; if there is no &lt;cwchar&gt;:
+//
+#  if defined(BOOST_NO_CWCHAR) &amp;&amp; !defined(BOOST_NO_CWCTYPE)
+#     define BOOST_NO_CWCTYPE
+#  endif
+
+//
+// We can't have a swprintf if there is no &lt;cwchar&gt;:
+//
+#  if defined(BOOST_NO_CWCHAR) &amp;&amp; !defined(BOOST_NO_SWPRINTF)
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+//
+// If Win32 support is turned off, then we must turn off
+// threading support also, unless there is some other
+// thread API enabled:
+//
+#if defined(BOOST_DISABLE_WIN32) &amp;&amp; defined(_WIN32) \
+   &amp;&amp; !defined(BOOST_DISABLE_THREADS) &amp;&amp; !defined(BOOST_HAS_PTHREADS)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+//
+// Turn on threading support if the compiler thinks that it's in
+// multithreaded mode.  We put this here because there are only a
+// limited number of macros that identify this (if there's any missing
+// from here then add to the appropriate compiler section):
+//
+#if (defined(__MT__) || defined(_MT) || defined(_REENTRANT) \
+    || defined(_PTHREADS)) &amp;&amp; !defined(BOOST_HAS_THREADS)
+#  define BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if BOOST_DISABLE_THREADS is defined:
+//
+#if defined(BOOST_DISABLE_THREADS) &amp;&amp; defined(BOOST_HAS_THREADS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if we don't recognise the threading API:
+//
+#if defined(BOOST_HAS_THREADS) &amp;&amp; !defined(BOOST_HAS_PTHREADS)\
+      &amp;&amp; !defined(BOOST_HAS_WINTHREADS) &amp;&amp; !defined(BOOST_HAS_BETHREADS)\
+      &amp;&amp; !defined(BOOST_HAS_MPTASKS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading detail macros off if we don't (want to) use threading
+//
+#ifndef BOOST_HAS_THREADS
+#  undef BOOST_HAS_PTHREADS
+#  undef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#  undef BOOST_HAS_WINTHREADS
+#  undef BOOST_HAS_BETHREADS
+#  undef BOOST_HAS_MPTASKS
+#endif
+
+//
+// If the compiler claims to be C99 conformant, then it had better
+// have a &lt;stdint.h&gt;:
+//
+#  if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901)
+#     define BOOST_HAS_STDINT_H
+#  endif
+
+//
+// Define BOOST_NO_SLIST and BOOST_NO_HASH if required.
+// Note that this is for backwards compatibility only.
+//
+#  ifndef BOOST_HAS_SLIST
+#     define BOOST_NO_SLIST
+#  endif
+
+#  ifndef BOOST_HAS_HASH
+#     define BOOST_NO_HASH
+#  endif
+
+//  BOOST_HAS_ABI_HEADERS
+//  This macro gets set if we have headers that fix the ABI,
+//  and prevent ODR violations when linking to external libraries:
+#if defined(BOOST_ABI_PREFIX) &amp;&amp; defined(BOOST_ABI_SUFFIX) &amp;&amp; !defined(BOOST_HAS_ABI_HEADERS)
+#  define BOOST_HAS_ABI_HEADERS
+#endif
+
+#if defined(BOOST_HAS_ABI_HEADERS) &amp;&amp; defined(BOOST_DISABLE_ABI_HEADERS)
+#  undef BOOST_HAS_ABI_HEADERS
+#endif
+
+//  BOOST_NO_STDC_NAMESPACE workaround  --------------------------------------//
+//  Because std::size_t usage is so common, even in boost headers which do not
+//  otherwise use the C library, the &lt;cstddef&gt; workaround is included here so
+//  that ugly workaround code need not appear in many other boost headers.
+//  NOTE WELL: This is a workaround for non-conforming compilers; &lt;cstddef&gt; 
+//  must still be #included in the usual places so that &lt;cstddef&gt; inclusion
+//  works as expected with standard conforming compilers.  The resulting
+//  double inclusion of &lt;cstddef&gt; is harmless.
+
+# ifdef BOOST_NO_STDC_NAMESPACE
+#   include &lt;cstddef&gt;
+    namespace std { using ::ptrdiff_t; using ::size_t; }
+# endif
+
+//  BOOST_NO_STD_MIN_MAX workaround  -----------------------------------------//
+
+#  ifdef BOOST_NO_STD_MIN_MAX
+
+namespace std {
+  template &lt;class _Tp&gt;
+  inline const _Tp&amp; min(const _Tp&amp; __a, const _Tp&amp; __b) {
+    return __b &lt; __a ? __b : __a;
+  }
+  template &lt;class _Tp&gt;
+  inline const _Tp&amp; max(const _Tp&amp; __a, const _Tp&amp; __b) {
+    return  __a &lt; __b ? __b : __a;
+  }
+}
+
+#  endif
+
+// BOOST_STATIC_CONSTANT workaround --------------------------------------- //
+// On compilers which don't allow in-class initialization of static integral
+// constant members, we must use enums as a workaround if we want the constants
+// to be available at compile-time. This macro gives us a convenient way to
+// declare such constants.
+
+#  ifdef BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#       define BOOST_STATIC_CONSTANT(type, assignment) enum { assignment }
+#  else
+#     define BOOST_STATIC_CONSTANT(type, assignment) static const type assignment
+#  endif
+
+// BOOST_USE_FACET workaround ----------------------------------------------//
+// When the standard library does not have a conforming std::use_facet there
+// are various workarounds available, but they differ from library to library.
+// This macro provides a consistent way to access a locale's facets.
+// Usage:
+//    replace
+//       std::use_facet&lt;Type&gt;(loc);
+//    with
+//       BOOST_USE_FACET(Type, loc);
+//    Note do not add a std:: prefix to the front of BOOST_USE_FACET!
+
+#if defined(BOOST_NO_STD_USE_FACET)
+#  ifdef BOOST_HAS_TWO_ARG_USE_FACET
+#     define BOOST_USE_FACET(Type, loc) std::use_facet(loc, static_cast&lt;Type*&gt;(0))
+#  elif defined(BOOST_HAS_MACRO_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) std::_USE(loc, Type)
+#  elif defined(BOOST_HAS_STLP_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) (*std::_Use_facet&lt;Type &gt;(loc))
+#  endif
+#else
+#  define BOOST_USE_FACET(Type, loc) std::use_facet&lt; Type &gt;(loc)
+#endif
+
+// BOOST_NESTED_TEMPLATE workaround ------------------------------------------//
+// Member templates are supported by some compilers even though they can't use
+// the A::template member&lt;U&gt; syntax, as a workaround replace:
+//
+// typedef typename A::template rebind&lt;U&gt; binder;
+//
+// with:
+//
+// typedef typename A::BOOST_NESTED_TEMPLATE rebind&lt;U&gt; binder;
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#  define BOOST_NESTED_TEMPLATE template
+#else
+#  define BOOST_NESTED_TEMPLATE
+#endif
+
+// BOOST_UNREACHABLE_RETURN(x) workaround -------------------------------------//
+// Normally evaluates to nothing, unless BOOST_NO_UNREACHABLE_RETURN_DETECTION
+// is defined, in which case it evaluates to return x; Use when you have a return
+// statement that can never be reached.
+
+#ifdef BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#  define BOOST_UNREACHABLE_RETURN(x) return x;
+#else
+#  define BOOST_UNREACHABLE_RETURN(x)
+#endif
+
+// BOOST_DEDUCED_TYPENAME workaround ------------------------------------------//
+//
+// Some compilers don't support the use of `typename' for dependent
+// types in deduced contexts, e.g.
+//
+//     template &lt;class T&gt; void f(T, typename T::type);
+//                                  ^^^^^^^^
+// Replace these declarations with:
+//
+//     template &lt;class T&gt; void f(T, BOOST_DEDUCED_TYPENAME T::type);
+
+#ifndef BOOST_NO_DEDUCED_TYPENAME
+#  define BOOST_DEDUCED_TYPENAME typename
+#else 
+#  define BOOST_DEDUCED_TYPENAME
+#endif
+
+// BOOST_[APPEND_]EXPLICIT_TEMPLATE_[NON_]TYPE macros --------------------------//
+//
+// Some compilers have problems with function templates whose
+// template parameters don't appear in the function parameter
+// list (basically they just link one instantiation of the
+// template in the final executable). These macros provide a
+// uniform way to cope with the problem with no effects on the
+// calling syntax.
+
+// Example:
+//
+//  #include &lt;iostream&gt;
+//  #include &lt;ostream&gt;
+//  #include &lt;typeinfo&gt;
+//
+//  template &lt;int n&gt;
+//  void f() { std::cout &lt;&lt; n &lt;&lt; ' '; }
+//
+//  template &lt;typename T&gt;
+//  void g() { std::cout &lt;&lt; typeid(T).name() &lt;&lt; ' '; }
+//
+//  int main() {
+//    f&lt;1&gt;();
+//    f&lt;2&gt;();
+//
+//    g&lt;int&gt;();
+//    g&lt;double&gt;();
+//  }
+//
+// With VC++ 6.0 the output is:
+//
+//   2 2 double double
+//
+// To fix it, write
+//
+//   template &lt;int n&gt;
+//   void f(BOOST_EXPLICIT_TEMPLATE_NON_TYPE(int, n)) { ... }
+//
+//   template &lt;typename T&gt;
+//   void g(BOOST_EXPLICIT_TEMPLATE_TYPE(T)) { ... }
+//
+
+
+#if defined BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+
+#  include &quot;boost/type.hpp&quot;
+#  include &quot;boost/non_type.hpp&quot;
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)         boost::type&lt;t&gt;* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)    boost::type&lt;t&gt;*
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)  boost::non_type&lt;t, v&gt;* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)  boost::non_type&lt;t, v&gt;*
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)         \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)    \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)  \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)  \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#else
+
+// no workaround needed: expand to nothing
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+
+#endif // defined BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+
+
+// ---------------------------------------------------------------------------//
+
+//
+// Helper macro BOOST_STRINGIZE:
+// Converts the parameter X to a string after macro replacement
+// on X has been performed.
+//
+#define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)
+#define BOOST_DO_STRINGIZE(X) #X
+
+//
+// Helper macro BOOST_JOIN:
+// The following piece of macro magic joins the two 
+// arguments together, even when one of the arguments is
+// itself a macro (see 16.3.1 in C++ standard).  The key
+// is that macro expansion of macro arguments does not
+// occur in BOOST_DO_JOIN2 but does in BOOST_DO_JOIN.
+//
+#define BOOST_JOIN( X, Y ) BOOST_DO_JOIN( X, Y )
+#define BOOST_DO_JOIN( X, Y ) BOOST_DO_JOIN2(X,Y)
+#define BOOST_DO_JOIN2( X, Y ) X##Y
+
+//
+// Set some default values for compiler/library/platform names.
+// These are for debugging config setup only:
+//
+#  ifndef BOOST_COMPILER
+#     define BOOST_COMPILER &quot;Unknown ISO C++ Compiler&quot;
+#  endif
+#  ifndef BOOST_STDLIB
+#     define BOOST_STDLIB &quot;Unknown ISO standard library&quot;
+#  endif
+#  ifndef BOOST_PLATFORM
+#     if defined(unix) || defined(__unix) || defined(_XOPEN_SOURCE) \
+         || defined(_POSIX_SOURCE)
+#        define BOOST_PLATFORM &quot;Generic Unix&quot;
+#     else
+#        define BOOST_PLATFORM &quot;Unknown&quot;
+#     endif
+#  endif
+
+#endif
+
+
+

Added: trunk/source/libraries/boost/config/user.hpp
===================================================================
--- trunk/source/libraries/boost/config/user.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config/user.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,124 @@
+//  boost/config/user.hpp  ---------------------------------------------------//
+
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  Do not check in modified versions of this file,
+//  This file may be customized by the end user, but not by boost.
+
+//
+//  Use this file to define a site and compiler specific
+//  configuration policy:
+//
+
+// define this to locate a compiler config file:
+// #define BOOST_COMPILER_CONFIG &lt;myheader&gt;
+
+// define this to locate a stdlib config file:
+// #define BOOST_STDLIB_CONFIG   &lt;myheader&gt;
+
+// define this to locate a platform config file:
+// #define BOOST_PLATFORM_CONFIG &lt;myheader&gt;
+
+// define this to disable compiler config,
+// use if your compiler config has nothing to set:
+// #define BOOST_NO_COMPILER_CONFIG
+
+// define this to disable stdlib config,
+// use if your stdlib config has nothing to set:
+// #define BOOST_NO_STDLIB_CONFIG
+
+// define this to disable platform config,
+// use if your platform config has nothing to set:
+// #define BOOST_NO_PLATFORM_CONFIG
+
+// define this to disable all config options,
+// excluding the user config.  Use if your
+// setup is fully ISO compliant, and has no
+// useful extensions, or for autoconf generated
+// setups:
+// #define BOOST_NO_CONFIG
+
+// define this to make the config &quot;optimistic&quot;
+// about unknown compiler versions.  Normally
+// unknown compiler versions are assumed to have
+// all the defects of the last known version, however
+// setting this flag, causes the config to assume
+// that unknown compiler versions are fully conformant
+// with the standard:
+// #define BOOST_STRICT_CONFIG
+
+// define this to cause the config to halt compilation
+// with an #error if it encounters anything unknown --
+// either an unknown compiler version or an unknown
+// compiler/platform/library:
+// #define BOOST_ASSERT_CONFIG
+
+
+// define if you want to disable threading support, even
+// when available:
+// #define BOOST_DISABLE_THREADS
+
+// define when you want to disable Win32 specific features
+// even when available:
+// #define BOOST_DISABLE_WIN32
+
+// BOOST_DISABLE_ABI_HEADERS: Stops boost headers from including any 
+// prefix/suffix headers that normally control things like struct 
+// packing and alignment. 
+// #define BOOST_DISABLE_ABI_HEADERS
+
+// BOOST_ABI_PREFIX: A prefix header to include in place of whatever
+// boost.config would normally select, any replacement should set up 
+// struct packing and alignment options as required. 
+// #define BOOST_ABI_PREFIX my-header-name
+
+// BOOST_ABI_SUFFIX: A suffix header to include in place of whatever 
+// boost.config would normally select, any replacement should undo 
+// the effects of the prefix header. 
+// #define BOOST_ABI_SUFFIX my-header-name
+
+// BOOST_ALL_DYN_LINK: Forces all libraries that have separate source, 
+// to be linked as dll's rather than static libraries on Microsoft Windows 
+// (this macro is used to turn on __declspec(dllimport) modifiers, so that 
+// the compiler knows which symbols to look for in a dll rather than in a 
+// static library).  Note that there may be some libraries that can only 
+// be statically linked (Boost.Test for example) and others which may only 
+// be dynamically linked (Boost.Threads for example), in these cases this 
+// macro has no effect.
+// #define BOOST_ALL_DYN_LINK
+ 
+// BOOST_WHATEVER_DYN_LINK: Forces library &quot;whatever&quot; to be linked as a dll 
+// rather than a static library on Microsoft Windows: replace the WHATEVER 
+// part of the macro name with the name of the library that you want to 
+// dynamically link to, for example use BOOST_DATE_TIME_DYN_LINK or 
+// BOOST_REGEX_DYN_LINK etc (this macro is used to turn on __declspec(dllimport) 
+// modifiers, so that the compiler knows which symbols to look for in a dll 
+// rather than in a static library).  
+// Note that there may be some libraries that can only be statically linked 
+// (Boost.Test for example) and others which may only be dynamically linked 
+// (Boost.Threads for example), in these cases this macro is unsupported.
+// #define BOOST_WHATEVER_DYN_LINK
+ 
+// BOOST_ALL_NO_LIB: Tells the config system not to automatically select 
+// which libraries to link against.  
+// Normally if a compiler supports #pragma lib, then the correct library 
+// build variant will be automatically selected and linked against, 
+// simply by the act of including one of that library's headers.  
+// This macro turns that feature off.
+// #define BOOST_ALL_NO_LIB
+ 
+// BOOST_WHATEVER_NO_LIB: Tells the config system not to automatically 
+// select which library to link against for library &quot;whatever&quot;, 
+// replace WHATEVER in the macro name with the name of the library; 
+// for example BOOST_DATE_TIME_NO_LIB or BOOST_REGEX_NO_LIB.  
+// Normally if a compiler supports #pragma lib, then the correct library 
+// build variant will be automatically selected and linked against, simply 
+// by the act of including one of that library's headers.  This macro turns 
+// that feature off.
+// #define BOOST_WHATEVER_NO_LIB
+ 
+
+

Added: trunk/source/libraries/boost/config.hpp
===================================================================
--- trunk/source/libraries/boost/config.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/config.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,70 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John Maddock 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org/libs/config">http://www.boost.org/libs/config</A> for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  <A HREF="http://www.boost.org/libs/config">http://www.boost.org/libs/config</A>
+//
+//  CAUTION: This file is intended to be completely stable -
+//           DO NOT MODIFY THIS FILE!
+//
+
+#ifndef BOOST_CONFIG_HPP
+#define BOOST_CONFIG_HPP
+
+// if we don't have a user config, then use the default location:
+#if !defined(BOOST_USER_CONFIG) &amp;&amp; !defined(BOOST_NO_USER_CONFIG)
+#  define BOOST_USER_CONFIG &lt;boost/config/user.hpp&gt;
+#endif
+// include it first:
+#ifdef BOOST_USER_CONFIG
+#  include BOOST_USER_CONFIG
+#endif
+
+// if we don't have a compiler config set, try and find one:
+#if !defined(BOOST_COMPILER_CONFIG) &amp;&amp; !defined(BOOST_NO_COMPILER_CONFIG) &amp;&amp; !defined(BOOST_NO_CONFIG)
+#  include &lt;boost/config/select_compiler_config.hpp&gt;
+#endif
+// if we have a compiler config, include it now:
+#ifdef BOOST_COMPILER_CONFIG
+#  include BOOST_COMPILER_CONFIG
+#endif
+
+// if we don't have a std library config set, try and find one:
+#if !defined(BOOST_STDLIB_CONFIG) &amp;&amp; !defined(BOOST_NO_STDLIB_CONFIG) &amp;&amp; !defined(BOOST_NO_CONFIG)
+#  include &lt;boost/config/select_stdlib_config.hpp&gt;
+#endif
+// if we have a std library config, include it now:
+#ifdef BOOST_STDLIB_CONFIG
+#  include BOOST_STDLIB_CONFIG
+#endif
+
+// if we don't have a platform config set, try and find one:
+#if !defined(BOOST_PLATFORM_CONFIG) &amp;&amp; !defined(BOOST_NO_PLATFORM_CONFIG) &amp;&amp; !defined(BOOST_NO_CONFIG)
+#  include &lt;boost/config/select_platform_config.hpp&gt;
+#endif
+// if we have a platform config, include it now:
+#ifdef BOOST_PLATFORM_CONFIG
+#  include BOOST_PLATFORM_CONFIG
+#endif
+
+// get config suffix code:
+#include &lt;boost/config/suffix.hpp&gt;
+
+#endif  // BOOST_CONFIG_HPP
+
+
+
+
+
+
+
+
+
+
+

Added: trunk/source/libraries/boost/detail/lightweight_mutex.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lightweight_mutex.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lightweight_mutex.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,99 @@
+#ifndef BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED
+#define BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lightweight_mutex.hpp - lightweight mutex
+//
+//  Copyright (c) 2002, 2003 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  typedef &lt;unspecified&gt; boost::detail::lightweight_mutex;
+//
+//  boost::detail::lightweight_mutex meets a subset of the Mutex concept
+//  requirements: <A HREF="http://www.boost.org/libs/thread/doc/mutex_concept.html#Mutex">http://www.boost.org/libs/thread/doc/mutex_concept.html#Mutex</A>
+//
+//  * Used by the smart pointer library
+//  * Performance oriented
+//  * Header-only implementation
+//  * Small memory footprint
+//  * Not a general purpose mutex, use boost::mutex, CRITICAL_SECTION or
+//    pthread_mutex instead.
+//  * Never spin in a tight lock/do-something/unlock loop, since
+//    lightweight_mutex does not guarantee fairness.
+//  * Never keep a lightweight_mutex locked for long periods.
+//
+//  The current implementation can use a pthread_mutex, a CRITICAL_SECTION,
+//  or a platform-specific spinlock.
+//
+//  You can force a particular implementation by defining BOOST_LWM_USE_PTHREADS,
+//  BOOST_LWM_USE_CRITICAL_SECTION, or BOOST_LWM_USE_SPINLOCK.
+//
+//  If neither macro has been defined, the default is to use a spinlock on Win32,
+//  and a pthread_mutex otherwise.
+//
+//  Note that a spinlock is not a general synchronization primitive. In particular,
+//  it is not guaranteed to be a memory barrier, and it is possible to &quot;livelock&quot;
+//  if a lower-priority thread has acquired the spinlock but a higher-priority
+//  thread is spinning trying to acquire the same lock.
+//
+//  For these reasons, spinlocks have been disabled by default except on Windows,
+//  where a spinlock can be several orders of magnitude faster than a CRITICAL_SECTION.
+
+
+//  Note: lwm_linux.hpp has been disabled by default; see the comments
+//        inside for more info.
+
+
+#include &lt;boost/config.hpp&gt;
+
+//  Note to implementors: if you write a platform-specific spinlock
+//  for a platform that supports pthreads, be sure to test its performance
+//  against the pthreads-based version using shared_ptr_timing_test.cpp and
+//  shared_ptr_mt_test.cpp. Custom versions are usually not worth the trouble
+//  _unless_ the performance gains are substantial.
+//
+//  Be sure to compare against a &quot;real&quot; pthreads library;
+//  shared_ptr_timing_test.cpp will compile succesfully with a stub do-nothing
+//  pthreads library, since it doesn't create any threads.
+
+#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)) &amp;&amp; !defined(BOOST_LWM_USE_CRITICAL_SECTION) &amp;&amp; !defined(BOOST_LWM_USE_PTHREADS)
+# define BOOST_LWM_WIN32
+#endif
+
+#if !defined(BOOST_HAS_THREADS)
+#  if defined(BOOST_LWM_WIN32)
+#    include &lt;boost/detail/lwm_win32_nt.hpp&gt;
+#  else
+#    include &lt;boost/detail/lwm_nop.hpp&gt;
+#  endif
+#elif defined(BOOST_LWM_USE_SPINLOCK) &amp;&amp; defined(BOOST_USE_ASM_ATOMIC_H)
+#  include &lt;boost/detail/lwm_linux.hpp&gt;
+#elif defined(BOOST_LWM_USE_CRITICAL_SECTION)
+#  include &lt;boost/detail/lwm_win32_cs.hpp&gt;
+#elif defined(BOOST_LWM_USE_PTHREADS)
+#  include &lt;boost/detail/lwm_pthreads.hpp&gt;
+#elif defined(BOOST_LWM_WIN32)
+#  include &lt;boost/detail/lwm_win32.hpp&gt;
+#elif defined(BOOST_LWM_USE_SPINLOCK) &amp;&amp; defined(__sgi)
+#  include &lt;boost/detail/lwm_irix.hpp&gt;
+#elif defined(BOOST_LWM_USE_SPINLOCK) &amp;&amp; defined(__GLIBCPP__)
+#  include &lt;boost/detail/lwm_gcc.hpp&gt;
+#elif defined(BOOST_HAS_PTHREADS)
+#  define BOOST_LWM_USE_PTHREADS
+#  include &lt;boost/detail/lwm_pthreads.hpp&gt;
+#else
+// Use #define BOOST_DISABLE_THREADS to avoid the error
+#  error Unrecognized threading platform
+#endif
+
+#endif // #ifndef BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_pthreads.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_pthreads.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_pthreads.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,87 @@
+#ifndef BOOST_DETAIL_LWM_PTHREADS_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_PTHREADS_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_pthreads.hpp
+//
+//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#include &lt;pthread.h&gt;
+
+namespace boost
+{
+
+namespace detail
+{
+
+class lightweight_mutex
+{
+private:
+
+    pthread_mutex_t m_;
+
+    lightweight_mutex(lightweight_mutex const &amp;);
+    lightweight_mutex &amp; operator=(lightweight_mutex const &amp;);
+
+public:
+
+    lightweight_mutex()
+    {
+
+// HPUX 10.20 / DCE has a nonstandard pthread_mutex_init
+
+#if defined(__hpux) &amp;&amp; defined(_DECTHREADS_)
+        pthread_mutex_init(&amp;m_, pthread_mutexattr_default);
+#else
+        pthread_mutex_init(&amp;m_, 0);
+#endif
+    }
+
+    ~lightweight_mutex()
+    {
+        pthread_mutex_destroy(&amp;m_);
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        pthread_mutex_t &amp; m_;
+
+        scoped_lock(scoped_lock const &amp;);
+        scoped_lock &amp; operator=(scoped_lock const &amp;);
+
+    public:
+
+        scoped_lock(lightweight_mutex &amp; m): m_(m.m_)
+        {
+            pthread_mutex_lock(&amp;m_);
+        }
+
+        ~scoped_lock()
+        {
+            pthread_mutex_unlock(&amp;m_);
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_PTHREADS_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_win32.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_win32.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_win32.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,123 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#ifdef BOOST_USE_WINDOWS_H
+#  include &lt;windows.h&gt;
+#endif
+
+#ifdef __BORLANDC__
+# pragma warn -8027     // Functions containing while are not expanded inline
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+#ifndef BOOST_USE_WINDOWS_H
+
+#ifdef _WIN64
+
+// Intel 6.0 on Win64 version, posted by Tim Fenders to [boost-users]
+
+extern &quot;C&quot; long_type __cdecl _InterlockedExchange(long volatile *, long);
+
+#pragma intrinsic(_InterlockedExchange)
+
+inline long InterlockedExchange(long volatile* lp, long l)
+{
+    return _InterlockedExchange(lp, l);
+}
+
+#else  // _WIN64
+
+extern &quot;C&quot; __declspec(dllimport) long __stdcall InterlockedExchange(long volatile *, long);
+
+#endif // _WIN64
+
+extern &quot;C&quot; __declspec(dllimport) void __stdcall Sleep(unsigned long);
+
+#endif // #ifndef BOOST_USE_WINDOWS_H
+
+class lightweight_mutex
+{
+private:
+
+    long l_;
+
+    lightweight_mutex(lightweight_mutex const &amp;);
+    lightweight_mutex &amp; operator=(lightweight_mutex const &amp;);
+
+public:
+
+    lightweight_mutex(): l_(0)
+    {
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        lightweight_mutex &amp; m_;
+
+        scoped_lock(scoped_lock const &amp;);
+        scoped_lock &amp; operator=(scoped_lock const &amp;);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex &amp; m): m_(m)
+        {
+            while( InterlockedExchange(&amp;m_.l_, 1) )
+            {
+                // Note: changed to Sleep(1) from Sleep(0).
+                // According to MSDN, Sleep(0) will never yield
+                // to a lower-priority thread, whereas Sleep(1)
+                // will. Performance seems not to be affected.
+
+                Sleep(1);
+            }
+        }
+
+        ~scoped_lock()
+        {
+            InterlockedExchange(&amp;m_.l_, 0);
+
+            // Note: adding a yield here will make
+            // the spinlock more fair and will increase the overall
+            // performance of some applications substantially in
+            // high contention situations, but will penalize the
+            // low contention / single thread case up to 5x
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8027     // Functions containing while are not expanded inline
+#endif
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_win32_cs.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_win32_cs.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_win32_cs.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,105 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32_cs.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#ifdef BOOST_USE_WINDOWS_H
+#  include &lt;windows.h&gt;
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+#ifndef BOOST_USE_WINDOWS_H
+
+struct CRITICAL_SECTION
+{
+    struct critical_section_debug * DebugInfo;
+    long LockCount;
+    long RecursionCount;
+    void * OwningThread;
+    void * LockSemaphore;
+#if defined(_WIN64)
+    unsigned __int64 SpinCount;
+#else
+    unsigned long SpinCount;
+#endif
+};
+
+extern &quot;C&quot; __declspec(dllimport) void __stdcall InitializeCriticalSection(CRITICAL_SECTION *);
+extern &quot;C&quot; __declspec(dllimport) void __stdcall EnterCriticalSection(CRITICAL_SECTION *);
+extern &quot;C&quot; __declspec(dllimport) void __stdcall LeaveCriticalSection(CRITICAL_SECTION *);
+extern &quot;C&quot; __declspec(dllimport) void __stdcall DeleteCriticalSection(CRITICAL_SECTION *);
+
+#endif // #ifndef BOOST_USE_WINDOWS_H
+
+class lightweight_mutex
+{
+private:
+
+    CRITICAL_SECTION cs_;
+
+    lightweight_mutex(lightweight_mutex const &amp;);
+    lightweight_mutex &amp; operator=(lightweight_mutex const &amp;);
+
+public:
+
+    lightweight_mutex()
+    {
+        InitializeCriticalSection(&amp;cs_);
+    }
+
+    ~lightweight_mutex()
+    {
+        DeleteCriticalSection(&amp;cs_);
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        lightweight_mutex &amp; m_;
+
+        scoped_lock(scoped_lock const &amp;);
+        scoped_lock &amp; operator=(scoped_lock const &amp;);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex &amp; m): m_(m)
+        {
+            EnterCriticalSection(&amp;m_.cs_);
+        }
+
+        ~scoped_lock()
+        {
+            LeaveCriticalSection(&amp;m_.cs_);
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/lwm_win32_nt.hpp
===================================================================
--- trunk/source/libraries/boost/detail/lwm_win32_nt.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/lwm_win32_nt.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,64 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32_nt.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  &quot;No threads&quot; version of lwm_win32.hpp; binary compatible but no-op.
+//
+
+namespace boost
+{
+
+namespace detail
+{
+
+class lightweight_mutex
+{
+private:
+
+    long l_;
+
+    lightweight_mutex(lightweight_mutex const &amp;);
+    lightweight_mutex &amp; operator=(lightweight_mutex const &amp;);
+
+public:
+
+    lightweight_mutex(): l_(0)
+    {
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        scoped_lock(scoped_lock const &amp;);
+        scoped_lock &amp; operator=(scoped_lock const &amp;);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex &amp;)
+        {
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/shared_count.hpp
===================================================================
--- trunk/source/libraries/boost/detail/shared_count.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/shared_count.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,555 @@
+#ifndef BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED
+#define BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  detail/shared_count.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#include &lt;boost/config.hpp&gt;
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR) &amp;&amp; defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+# error BOOST_SP_USE_STD_ALLOCATOR and BOOST_SP_USE_QUICK_ALLOCATOR are incompatible.
+#endif
+
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/throw_exception.hpp&gt;
+#include &lt;boost/detail/lightweight_mutex.hpp&gt;
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+#include &lt;boost/detail/quick_allocator.hpp&gt;
+#endif
+
+#include &lt;memory&gt;           // std::auto_ptr, std::allocator
+#include &lt;functional&gt;       // std::less
+#include &lt;exception&gt;        // std::exception
+#include &lt;new&gt;              // std::bad_alloc
+#include &lt;typeinfo&gt;         // std::type_info in get_deleter
+#include &lt;cstddef&gt;          // std::size_t
+
+#ifdef __BORLANDC__
+# pragma warn -8026     // Functions with excep. spec. are not expanded inline
+# pragma warn -8027     // Functions containing try are not expanded inline
+#endif
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook(void * px, std::size_t size, void * pn);
+void sp_array_constructor_hook(void * px);
+void sp_scalar_destructor_hook(void * px, std::size_t size, void * pn);
+void sp_array_destructor_hook(void * px);
+
+#endif
+
+
+// The standard library that comes with Borland C++ 5.5.1
+// defines std::exception and its members as having C calling
+// convention (-pc). When the definition of bad_weak_ptr
+// is compiled with -ps, the compiler issues an error.
+// Hence, the temporary #pragma option -pc below. The version
+// check is deliberately conservative.
+
+#if defined(__BORLANDC__) &amp;&amp; __BORLANDC__ == 0x551
+# pragma option push -pc
+#endif
+
+class bad_weak_ptr: public std::exception
+{
+public:
+
+    virtual char const * what() const throw()
+    {
+        return &quot;boost::bad_weak_ptr&quot;;
+    }
+};
+
+#if defined(__BORLANDC__) &amp;&amp; __BORLANDC__ == 0x551
+# pragma option pop
+#endif
+
+namespace detail
+{
+
+class sp_counted_base
+{
+private:
+
+    typedef detail::lightweight_mutex mutex_type;
+
+public:
+
+    sp_counted_base(): use_count_(1), weak_count_(1)
+    {
+    }
+
+    virtual ~sp_counted_base() // nothrow
+    {
+    }
+
+    // dispose() is called when use_count_ drops to zero, to release
+    // the resources managed by *this.
+
+    virtual void dispose() = 0; // nothrow
+
+    // destruct() is called when weak_count_ drops to zero.
+
+    virtual void destruct() // nothrow
+    {
+        delete this;
+    }
+
+    virtual void * get_deleter(std::type_info const &amp; ti) = 0;
+
+    void add_ref_copy()
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        ++use_count_;
+    }
+
+    void add_ref_lock()
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        if(use_count_ == 0) boost::throw_exception(boost::bad_weak_ptr());
+        ++use_count_;
+    }
+
+    void release() // nothrow
+    {
+        {
+#if defined(BOOST_HAS_THREADS)
+            mutex_type::scoped_lock lock(mtx_);
+#endif
+            long new_use_count = --use_count_;
+
+            if(new_use_count != 0) return;
+        }
+
+        dispose();
+        weak_release();
+    }
+
+    void weak_add_ref() // nothrow
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        ++weak_count_;
+    }
+
+    void weak_release() // nothrow
+    {
+        long new_weak_count;
+
+        {
+#if defined(BOOST_HAS_THREADS)
+            mutex_type::scoped_lock lock(mtx_);
+#endif
+            new_weak_count = --weak_count_;
+        }
+
+        if(new_weak_count == 0)
+        {
+            destruct();
+        }
+    }
+
+    long use_count() const // nothrow
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        return use_count_;
+    }
+
+private:
+
+    sp_counted_base(sp_counted_base const &amp;);
+    sp_counted_base &amp; operator= (sp_counted_base const &amp;);
+
+    long use_count_;        // #shared
+    long weak_count_;       // #weak + (#shared != 0)
+
+#if defined(BOOST_HAS_THREADS) || defined(BOOST_LWM_WIN32)
+    mutable mutex_type mtx_;
+#endif
+};
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+template&lt;class T&gt; void cbi_call_constructor_hook(sp_counted_base * pn, T * px, checked_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_scalar_constructor_hook(px, sizeof(T), pn);
+}
+
+template&lt;class T&gt; void cbi_call_constructor_hook(sp_counted_base *, T * px, checked_array_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_array_constructor_hook(px);
+}
+
+template&lt;class P, class D&gt; void cbi_call_constructor_hook(sp_counted_base *, P const &amp;, D const &amp;, long)
+{
+}
+
+template&lt;class T&gt; void cbi_call_destructor_hook(sp_counted_base * pn, T * px, checked_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_scalar_destructor_hook(px, sizeof(T), pn);
+}
+
+template&lt;class T&gt; void cbi_call_destructor_hook(sp_counted_base *, T * px, checked_array_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_array_destructor_hook(px);
+}
+
+template&lt;class P, class D&gt; void cbi_call_destructor_hook(sp_counted_base *, P const &amp;, D const &amp;, long)
+{
+}
+
+#endif
+
+//
+// Borland's Codeguard trips up over the -Vx- option here:
+//
+#ifdef __CODEGUARD__
+# pragma option push -Vx-
+#endif
+
+template&lt;class P, class D&gt; class sp_counted_base_impl: public sp_counted_base
+{
+private:
+
+    P ptr; // copy constructor must not throw
+    D del; // copy constructor must not throw
+
+    sp_counted_base_impl(sp_counted_base_impl const &amp;);
+    sp_counted_base_impl &amp; operator= (sp_counted_base_impl const &amp;);
+
+    typedef sp_counted_base_impl&lt;P, D&gt; this_type;
+
+public:
+
+    // pre: initial_use_count &lt;= initial_weak_count, d(p) must not throw
+
+    sp_counted_base_impl(P p, D d): ptr(p), del(d)
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        detail::cbi_call_constructor_hook(this, p, d, 0);
+#endif
+    }
+
+    virtual void dispose() // nothrow
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        detail::cbi_call_destructor_hook(this, ptr, del, 0);
+#endif
+        del(ptr);
+    }
+
+    virtual void * get_deleter(std::type_info const &amp; ti)
+    {
+        return ti == typeid(D)? &amp;del: 0;
+    }
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR)
+
+    void * operator new(std::size_t)
+    {
+        return std::allocator&lt;this_type&gt;().allocate(1, static_cast&lt;this_type *&gt;(0));
+    }
+
+    void operator delete(void * p)
+    {
+        std::allocator&lt;this_type&gt;().deallocate(static_cast&lt;this_type *&gt;(p), 1);
+    }
+
+#endif
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+
+    void * operator new(std::size_t)
+    {
+        return quick_allocator&lt;this_type&gt;::alloc();
+    }
+
+    void operator delete(void * p)
+    {
+        quick_allocator&lt;this_type&gt;::dealloc(p);
+    }
+
+#endif
+};
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+int const shared_count_id = 0x2C35F101;
+int const   weak_count_id = 0x298C38A4;
+
+#endif
+
+class weak_count;
+
+class shared_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class weak_count;
+
+public:
+
+    shared_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+    }
+
+    template&lt;class P, class D&gt; shared_count(P p, D d): pi_(0)
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = new sp_counted_base_impl&lt;P, D&gt;(p, d);
+        }
+        catch(...)
+        {
+            d(p); // delete p
+            throw;
+        }
+
+#else
+
+        pi_ = new sp_counted_base_impl&lt;P, D&gt;(p, d);
+
+        if(pi_ == 0)
+        {
+            d(p); // delete p
+            boost::throw_exception(std::bad_alloc());
+        }
+
+#endif
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    // auto_ptr&lt;Y&gt; is special cased to provide the strong guarantee
+
+    template&lt;class Y&gt;
+    explicit shared_count(std::auto_ptr&lt;Y&gt; &amp; r): pi_(new sp_counted_base_impl&lt; Y *, checked_deleter&lt;Y&gt; &gt;(r.get(), checked_deleter&lt;Y&gt;()))
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        r.release();
+    }
+
+#endif 
+
+    ~shared_count() // nothrow
+    {
+        if(pi_ != 0) pi_-&gt;release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    shared_count(shared_count const &amp; r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_-&gt;add_ref_copy();
+    }
+
+    explicit shared_count(weak_count const &amp; r); // throws bad_weak_ptr when r.use_count() == 0
+
+    shared_count &amp; operator= (shared_count const &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp-&gt;add_ref_copy();
+        if(pi_ != 0) pi_-&gt;release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    void swap(shared_count &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_-&gt;use_count(): 0;
+    }
+
+    bool unique() const // nothrow
+    {
+        return use_count() == 1;
+    }
+
+    friend inline bool operator==(shared_count const &amp; a, shared_count const &amp; b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator&lt;(shared_count const &amp; a, shared_count const &amp; b)
+    {
+        return std::less&lt;sp_counted_base *&gt;()(a.pi_, b.pi_);
+    }
+
+    void * get_deleter(std::type_info const &amp; ti) const
+    {
+        return pi_? pi_-&gt;get_deleter(ti): 0;
+    }
+};
+
+#ifdef __CODEGUARD__
+# pragma option pop
+#endif
+
+
+class weak_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class shared_count;
+
+public:
+
+    weak_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(weak_count_id)
+#endif
+    {
+    }
+
+    weak_count(shared_count const &amp; r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_-&gt;weak_add_ref();
+    }
+
+    weak_count(weak_count const &amp; r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_-&gt;weak_add_ref();
+    }
+
+    ~weak_count() // nothrow
+    {
+        if(pi_ != 0) pi_-&gt;weak_release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    weak_count &amp; operator= (shared_count const &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp-&gt;weak_add_ref();
+        if(pi_ != 0) pi_-&gt;weak_release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    weak_count &amp; operator= (weak_count const &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp-&gt;weak_add_ref();
+        if(pi_ != 0) pi_-&gt;weak_release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    void swap(weak_count &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_-&gt;use_count(): 0;
+    }
+
+    friend inline bool operator==(weak_count const &amp; a, weak_count const &amp; b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator&lt;(weak_count const &amp; a, weak_count const &amp; b)
+    {
+        return std::less&lt;sp_counted_base *&gt;()(a.pi_, b.pi_);
+    }
+};
+
+inline shared_count::shared_count(weak_count const &amp; r): pi_(r.pi_)
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+{
+    if(pi_ != 0)
+    {
+        pi_-&gt;add_ref_lock();
+    }
+    else
+    {
+        boost::throw_exception(boost::bad_weak_ptr());
+    }
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8027     // Functions containing try are not expanded inline
+# pragma warn .8026     // Functions with excep. spec. are not expanded inline
+#endif
+
+#endif  // #ifndef BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED

Added: trunk/source/libraries/boost/detail/workaround.hpp
===================================================================
--- trunk/source/libraries/boost/detail/workaround.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/detail/workaround.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,74 @@
+// Copyright David Abrahams 2002. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// &quot;as is&quot; without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+#ifndef WORKAROUND_DWA2002126_HPP
+# define WORKAROUND_DWA2002126_HPP
+
+// Compiler/library version workaround macro
+//
+// Usage:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, &lt;= 1200)
+//        ... // workaround code here
+//     #endif
+//
+// When BOOST_STRICT_CONFIG is defined, expands to 0. Otherwise, the
+// first argument must be undefined or expand to a numeric
+// value. The above expands to:
+//
+//     (BOOST_MSVC) != 0 &amp;&amp; (BOOST_MSVC) &lt;= 1200
+//
+// When used for workarounds that apply to the latest known version 
+// and all earlier versions of a compiler, the following convention 
+// should be observed:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1301))
+//
+// The version number in this case corresponds to the last version in
+// which the workaround was known to have been required. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is not the defined, the macro
+// BOOST_TESTED_AT(x) expands to &quot;!= 0&quot;, which effectively activates
+// the workaround for any version of the compiler. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is defined, a compiler warning or
+// error will be issued if the compiler version exceeds the argument
+// to BOOST_TESTED_AT().  This can be used to locate workarounds which
+// may be obsoleted by newer versions.
+
+# ifndef BOOST_STRICT_CONFIG
+
+#  define BOOST_WORKAROUND(symbol, test)                \
+        ((symbol != 0) &amp;&amp; (1 % (( (symbol test) ) + 1)))
+//                              ^ ^           ^ ^
+// The extra level of parenthesis nesting above, along with the
+// BOOST_OPEN_PAREN indirection below, is required to satisfy the
+// broken preprocessor in MWCW 8.3 and earlier.
+//
+// The basic mechanism works as follows:
+//      (symbol test) + 1        =&gt;   if (symbol test) then 2 else 1
+//      1 % ((symbol test) + 1)  =&gt;   if (symbol test) then 1 else 0
+//
+// The complication with % is for cooperation with BOOST_TESTED_AT().
+// When &quot;test&quot; is BOOST_TESTED_AT(x) and
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is #defined,
+//
+//      symbol test              =&gt;   if (symbol &lt;= x) then 1 else -1
+//      (symbol test) + 1        =&gt;   if (symbol &lt;= x) then 2 else 0
+//      1 % ((symbol test) + 1)  =&gt;   if (symbol &lt;= x) then 1 else divide-by-zero
+//
+
+#  ifdef BOOST_DETECT_OUTDATED_WORKAROUNDS
+#   define BOOST_OPEN_PAREN (
+#   define BOOST_TESTED_AT(value)  &gt; value) ?(-1): BOOST_OPEN_PAREN 1
+#  else
+#   define BOOST_TESTED_AT(value) != ((value)-(value))
+#  endif
+
+# else
+
+#  define BOOST_WORKAROUND(symbol, test) 0
+
+# endif 
+
+#endif // WORKAROUND_DWA2002126_HPP

Added: trunk/source/libraries/boost/non_type.hpp
===================================================================
--- trunk/source/libraries/boost/non_type.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/non_type.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,24 @@
+// (C) Copyright Gennaro Prota 2003. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// &quot;as is&quot; without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+
+
+#ifndef BOOST_NON_TYPE_HPP_GP_20030417
+#define BOOST_NON_TYPE_HPP_GP_20030417
+
+
+namespace boost {
+
+  // Just a simple &quot;envelope&quot; for non-type template parameters. Useful
+  // to work around some MSVC deficiencies.
+
+ template &lt;typename T, T n&gt;
+ struct non_type { };
+
+
+}
+
+
+#endif // include guard

Added: trunk/source/libraries/boost/scoped_array.hpp
===================================================================
--- trunk/source/libraries/boost/scoped_array.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/scoped_array.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,136 @@
+#ifndef BOOST_SCOPED_ARRAY_HPP_INCLUDED
+#define BOOST_SCOPED_ARRAY_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/smart_ptr/scoped_array.htm">http://www.boost.org/libs/smart_ptr/scoped_array.htm</A>
+//
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/config.hpp&gt;   // in case ptrdiff_t not in std
+
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#include &lt;cstddef&gt;            // for std::ptrdiff_t
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_array_constructor_hook(void * p);
+void sp_array_destructor_hook(void * p);
+
+#endif
+
+//  scoped_array extends scoped_ptr to arrays. Deletion of the array pointed to
+//  is guaranteed, either on destruction of the scoped_array or via an explicit
+//  reset(). Use shared_array or std::vector if your needs are more complex.
+
+template&lt;class T&gt; class scoped_array // noncopyable
+{
+private:
+
+    T * ptr;
+
+    scoped_array(scoped_array const &amp;);
+    scoped_array &amp; operator=(scoped_array const &amp;);
+
+    typedef scoped_array&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_array(T * p = 0) : ptr(p) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_array_constructor_hook(ptr);
+#endif
+    }
+
+    ~scoped_array() // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_array_destructor_hook(ptr);
+#endif
+        boost::checked_array_delete(ptr);
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        BOOST_ASSERT(p == 0 || p != ptr); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T &amp; operator[](std::ptrdiff_t i) const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        BOOST_ASSERT(i &gt;= 0);
+        return ptr[i];
+    }
+
+    T * get() const // never throws
+    {
+        return ptr;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return ptr != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::ptr;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return ptr == 0;
+    }
+
+    void swap(scoped_array &amp; b) // never throws
+    {
+        T * tmp = b.ptr;
+        b.ptr = ptr;
+        ptr = tmp;
+    }
+
+};
+
+template&lt;class T&gt; inline void swap(scoped_array&lt;T&gt; &amp; a, scoped_array&lt;T&gt; &amp; b) // never throws
+{
+    a.swap(b);
+}
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_SCOPED_ARRAY_HPP_INCLUDED

Added: trunk/source/libraries/boost/scoped_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/scoped_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/scoped_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,158 @@
+#ifndef BOOST_SCOPED_PTR_HPP_INCLUDED
+#define BOOST_SCOPED_PTR_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/smart_ptr/scoped_ptr.htm">http://www.boost.org/libs/smart_ptr/scoped_ptr.htm</A>
+//
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#ifndef BOOST_NO_AUTO_PTR
+# include &lt;memory&gt;          // for std::auto_ptr
+#endif
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook(void * p);
+void sp_scalar_destructor_hook(void * p);
+
+#endif
+
+//  scoped_ptr mimics a built-in pointer except that it guarantees deletion
+//  of the object pointed to, either on destruction of the scoped_ptr or via
+//  an explicit reset(). scoped_ptr is a simple solution for simple needs;
+//  use shared_ptr or std::auto_ptr if your needs are more complex.
+
+template&lt;class T&gt; class scoped_ptr // noncopyable
+{
+private:
+
+    T * ptr;
+
+    scoped_ptr(scoped_ptr const &amp;);
+    scoped_ptr &amp; operator=(scoped_ptr const &amp;);
+
+    typedef scoped_ptr&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_ptr(T * p = 0): ptr(p) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook(ptr);
+#endif
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    explicit scoped_ptr(std::auto_ptr&lt;T&gt; p): ptr(p.release()) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook(ptr);
+#endif
+    }
+
+#endif
+
+    ~scoped_ptr() // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_destructor_hook(ptr);
+#endif
+        boost::checked_delete(ptr);
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        BOOST_ASSERT(p == 0 || p != ptr); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T &amp; operator*() const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        return *ptr;
+    }
+
+    T * operator-&gt;() const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        return ptr;
+    }
+
+    T * get() const // never throws
+    {
+        return ptr;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return ptr != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::ptr;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return ptr == 0;
+    }
+
+    void swap(scoped_ptr &amp; b) // never throws
+    {
+        T * tmp = b.ptr;
+        b.ptr = ptr;
+        ptr = tmp;
+    }
+};
+
+template&lt;class T&gt; inline void swap(scoped_ptr&lt;T&gt; &amp; a, scoped_ptr&lt;T&gt; &amp; b) // never throws
+{
+    a.swap(b);
+}
+
+// get_pointer(p) is a generic way to say p.get()
+
+template&lt;class T&gt; inline T * get_pointer(scoped_ptr&lt;T&gt; const &amp; p)
+{
+    return p.get();
+}
+
+} // namespace boost
+
+#endif // #ifndef BOOST_SCOPED_PTR_HPP_INCLUDED

Added: trunk/source/libraries/boost/shared_array.hpp
===================================================================
--- trunk/source/libraries/boost/shared_array.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/shared_array.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,176 @@
+#ifndef BOOST_SHARED_ARRAY_HPP_INCLUDED
+#define BOOST_SHARED_ARRAY_HPP_INCLUDED
+
+//
+//  shared_array.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/smart_ptr/shared_array.htm">http://www.boost.org/libs/smart_ptr/shared_array.htm</A> for documentation.
+//
+
+#include &lt;boost/config.hpp&gt;   // for broken compiler workarounds
+
+#if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#include &lt;boost/detail/shared_array_nmt.hpp&gt;
+#else
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+
+#include &lt;boost/detail/shared_count.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#include &lt;cstddef&gt;            // for std::ptrdiff_t
+#include &lt;algorithm&gt;          // for std::swap
+#include &lt;functional&gt;         // for std::less
+
+namespace boost
+{
+
+//
+//  shared_array
+//
+//  shared_array extends shared_ptr to arrays.
+//  The array pointed to is deleted when the last shared_array pointing to it
+//  is destroyed or reset.
+//
+
+template&lt;class T&gt; class shared_array
+{
+private:
+
+    // Borland 5.5.1 specific workarounds
+    typedef checked_array_deleter&lt;T&gt; deleter;
+    typedef shared_array&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit shared_array(T * p = 0): px(p), pn(p, deleter())
+    {
+    }
+
+    //
+    // Requirements: D's copy constructor must not throw
+    //
+    // shared_array will release p by calling d(p)
+    //
+
+    template&lt;class D&gt; shared_array(T * p, D d): px(p), pn(p, d)
+    {
+    }
+
+//  generated copy constructor, assignment, destructor are fine
+
+    void reset(T * p = 0)
+    {
+        BOOST_ASSERT(p == 0 || p != px);
+        this_type(p).swap(*this);
+    }
+
+    template &lt;class D&gt; void reset(T * p, D d)
+    {
+        this_type(p, d).swap(*this);
+    }
+
+    T &amp; operator[] (std::ptrdiff_t i) const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        BOOST_ASSERT(i &gt;= 0);
+        return px[i];
+    }
+    
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return px != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::px;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return px == 0;
+    }
+
+    bool unique() const // never throws
+    {
+        return pn.unique();
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    void swap(shared_array&lt;T&gt; &amp; other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+private:
+
+    T * px;                     // contained pointer
+    detail::shared_count pn;    // reference counter
+
+};  // shared_array
+
+template&lt;class T&gt; inline bool operator==(shared_array&lt;T&gt; const &amp; a, shared_array&lt;T&gt; const &amp; b) // never throws
+{
+    return a.get() == b.get();
+}
+
+template&lt;class T&gt; inline bool operator!=(shared_array&lt;T&gt; const &amp; a, shared_array&lt;T&gt; const &amp; b) // never throws
+{
+    return a.get() != b.get();
+}
+
+template&lt;class T&gt; inline bool operator&lt;(shared_array&lt;T&gt; const &amp; a, shared_array&lt;T&gt; const &amp; b) // never throws
+{
+    return std::less&lt;T*&gt;()(a.get(), b.get());
+}
+
+template&lt;class T&gt; void swap(shared_array&lt;T&gt; &amp; a, shared_array&lt;T&gt; &amp; b) // never throws
+{
+    a.swap(b);
+}
+
+} // namespace boost
+
+#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+#endif  // #ifndef BOOST_SHARED_ARRAY_HPP_INCLUDED

Added: trunk/source/libraries/boost/shared_container_iterator.hpp
===================================================================
--- trunk/source/libraries/boost/shared_container_iterator.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/shared_container_iterator.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,62 @@
+// (C) Copyright Ronald Garcia 2002. Permission to copy, use, modify, sell and
+// distribute this software is granted provided this copyright notice appears
+// in all copies. This software is provided &quot;as is&quot; without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+
+// See <A HREF="http://www.boost.org/libs/utility/shared_container_iterator.html">http://www.boost.org/libs/utility/shared_container_iterator.html</A> for documentation.
+
+#ifndef SHARED_CONTAINER_ITERATOR_RG08102002_HPP
+#define SHARED_CONTAINER_ITERATOR_RG08102002_HPP
+
+#include &quot;boost/iterator_adaptors.hpp&quot;
+#include &quot;boost/shared_ptr.hpp&quot;
+#include &lt;utility&gt;
+
+namespace boost {
+
+template &lt;typename Container&gt;
+class shared_container_iterator : public iterator_adaptor&lt;
+                                    shared_container_iterator&lt;Container&gt;,
+                                    typename Container::iterator&gt; {
+
+  typedef iterator_adaptor&lt;
+    shared_container_iterator&lt;Container&gt;,
+    typename Container::iterator&gt; super_t;
+
+  typedef typename Container::iterator iterator_t;
+  typedef boost::shared_ptr&lt;Container&gt; container_ref_t;
+
+  container_ref_t container_ref;
+public:
+  shared_container_iterator() { }
+
+  shared_container_iterator(iterator_t const&amp; x,container_ref_t const&amp; c) :
+    super_t(x), container_ref(c) { }
+
+
+};
+
+template &lt;typename Container&gt;
+shared_container_iterator&lt;Container&gt;
+make_shared_container_iterator(typename Container::iterator iter,
+                               boost::shared_ptr&lt;Container&gt; const&amp; container) {
+  typedef shared_container_iterator&lt;Container&gt; iterator;
+  return iterator(iter,container);
+}
+
+
+
+template &lt;typename Container&gt;
+std::pair&lt;
+  shared_container_iterator&lt;Container&gt;,
+  shared_container_iterator&lt;Container&gt; &gt;
+make_shared_container_range(boost::shared_ptr&lt;Container&gt; const&amp; container) {
+  return
+    std::make_pair(
+      make_shared_container_iterator(container-&gt;begin(),container),
+      make_shared_container_iterator(container-&gt;end(),container));
+}
+
+
+} // namespace boost
+#endif  // SHARED_CONTAINER_ITERATOR_RG08102002_HPP

Added: trunk/source/libraries/boost/shared_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/shared_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/shared_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,474 @@
+#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
+#define BOOST_SHARED_PTR_HPP_INCLUDED
+
+//
+//  shared_ptr.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/libs/smart_ptr/shared_ptr.htm</A> for documentation.
+//
+
+#include &lt;boost/config.hpp&gt;   // for broken compiler workarounds
+
+#if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#include &lt;boost/detail/shared_ptr_nmt.hpp&gt;
+#else
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/throw_exception.hpp&gt;
+#include &lt;boost/detail/shared_count.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#include &lt;memory&gt;               // for std::auto_ptr
+#include &lt;algorithm&gt;            // for std::swap
+#include &lt;functional&gt;           // for std::less
+#include &lt;typeinfo&gt;             // for std::bad_cast
+#include &lt;iosfwd&gt;               // for std::basic_ostream
+
+#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
+# pragma warning(push)
+# pragma warning(disable:4284) // odd return type for operator-&gt;
+#endif
+
+namespace boost
+{
+
+template&lt;class T&gt; class weak_ptr;
+template&lt;class T&gt; class enable_shared_from_this;
+
+namespace detail
+{
+
+struct static_cast_tag {};
+struct const_cast_tag {};
+struct dynamic_cast_tag {};
+struct polymorphic_cast_tag {};
+
+template&lt;class T&gt; struct shared_ptr_traits
+{
+    typedef T &amp; reference;
+};
+
+template&lt;&gt; struct shared_ptr_traits&lt;void&gt;
+{
+    typedef void reference;
+};
+
+#if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+
+template&lt;&gt; struct shared_ptr_traits&lt;void const&gt;
+{
+    typedef void reference;
+};
+
+template&lt;&gt; struct shared_ptr_traits&lt;void volatile&gt;
+{
+    typedef void reference;
+};
+
+template&lt;&gt; struct shared_ptr_traits&lt;void const volatile&gt;
+{
+    typedef void reference;
+};
+
+#endif
+
+// enable_shared_from_this support
+
+template&lt;class T, class Y&gt; void sp_enable_shared_from_this(boost::enable_shared_from_this&lt;T&gt; * pe, Y * px, shared_count const &amp; pn)
+{
+    if(pe != 0) pe-&gt;_internal_weak_this._internal_assign(px, pn);
+}
+
+inline void sp_enable_shared_from_this(void const volatile *, void const volatile *, shared_count const &amp;)
+{
+}
+
+} // namespace detail
+
+
+//
+//  shared_ptr
+//
+//  An enhanced relative of scoped_ptr with reference counted copy semantics.
+//  The object pointed to is deleted when the last shared_ptr pointing to it
+//  is destroyed or reset.
+//
+
+template&lt;class T&gt; class shared_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workaround
+    typedef shared_ptr&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+    typedef T value_type;
+    typedef T * pointer;
+    typedef typename detail::shared_ptr_traits&lt;T&gt;::reference reference;
+
+    shared_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+    template&lt;class Y&gt;
+    explicit shared_ptr(Y * p): px(p), pn(p, checked_deleter&lt;Y&gt;()) // Y must be complete
+    {
+        detail::sp_enable_shared_from_this(p, p, pn);
+    }
+
+    //
+    // Requirements: D's copy constructor must not throw
+    //
+    // shared_ptr will release p by calling d(p)
+    //
+
+    template&lt;class Y, class D&gt; shared_ptr(Y * p, D d): px(p), pn(p, d)
+    {
+        detail::sp_enable_shared_from_this(p, p, pn);
+    }
+
+//  generated copy constructor, assignment, destructor are fine...
+
+//  except that Borland C++ has a bug, and g++ with -Wsynth warns
+#if defined(__BORLANDC__) || defined(__GNUC__)
+
+    shared_ptr &amp; operator=(shared_ptr const &amp; r) // never throws
+    {
+        px = r.px;
+        pn = r.pn; // shared_count::op= doesn't throw
+        return *this;
+    }
+
+#endif
+
+    template&lt;class Y&gt;
+    explicit shared_ptr(weak_ptr&lt;Y&gt; const &amp; r): pn(r.pn) // may throw
+    {
+        // it is now safe to copy r.px, as pn(r.pn) did not throw
+        px = r.px;
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r): px(r.px), pn(r.pn) // never throws
+    {
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::static_cast_tag): px(static_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::const_cast_tag): px(const_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::dynamic_cast_tag): px(dynamic_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+        if(px == 0) // need to allocate new counter -- the cast failed
+        {
+            pn = detail::shared_count();
+        }
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::polymorphic_cast_tag): px(dynamic_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+        if(px == 0)
+        {
+            boost::throw_exception(std::bad_cast());
+        }
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template&lt;class Y&gt;
+    explicit shared_ptr(std::auto_ptr&lt;Y&gt; &amp; r): px(r.get()), pn()
+    {
+        Y * tmp = r.get();
+        pn = detail::shared_count(r);
+        detail::sp_enable_shared_from_this(tmp, tmp, pn);
+    }
+
+#endif
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC &gt; 1200)
+
+    template&lt;class Y&gt;
+    shared_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r) // never throws
+    {
+        px = r.px;
+        pn = r.pn; // shared_count::op= doesn't throw
+        return *this;
+    }
+
+#endif
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template&lt;class Y&gt;
+    shared_ptr &amp; operator=(std::auto_ptr&lt;Y&gt; &amp; r)
+    {
+        this_type(r).swap(*this);
+        return *this;
+    }
+
+#endif
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    template&lt;class Y&gt; void reset(Y * p) // Y must be complete
+    {
+        BOOST_ASSERT(p == 0 || p != px); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    template&lt;class Y, class D&gt; void reset(Y * p, D d)
+    {
+        this_type(p, d).swap(*this);
+    }
+
+    reference operator* () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return *px;
+    }
+
+    T * operator-&gt; () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return px;
+    }
+    
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return px != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::px;
+    }
+
+#endif
+
+    // operator! is redundant, but some compilers need it
+
+    bool operator! () const // never throws
+    {
+        return px == 0;
+    }
+
+    bool unique() const // never throws
+    {
+        return pn.unique();
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    void swap(shared_ptr&lt;T&gt; &amp; other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    template&lt;class Y&gt; bool _internal_less(shared_ptr&lt;Y&gt; const &amp; rhs) const
+    {
+        return pn &lt; rhs.pn;
+    }
+
+    void * _internal_get_deleter(std::type_info const &amp; ti) const
+    {
+        return pn.get_deleter(ti);
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template&lt;class Y&gt; friend class shared_ptr;
+    template&lt;class Y&gt; friend class weak_ptr;
+
+
+#endif
+
+    T * px;                     // contained pointer
+    detail::shared_count pn;    // reference counter
+
+};  // shared_ptr
+
+template&lt;class T, class U&gt; inline bool operator==(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b)
+{
+    return a.get() == b.get();
+}
+
+template&lt;class T, class U&gt; inline bool operator!=(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b)
+{
+    return a.get() != b.get();
+}
+
+#if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 96
+
+// Resolve the ambiguity between our op!= and the one in rel_ops
+
+template&lt;class T&gt; inline bool operator!=(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;T&gt; const &amp; b)
+{
+    return a.get() != b.get();
+}
+
+#endif
+
+template&lt;class T, class U&gt; inline bool operator&lt;(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b)
+{
+    return a._internal_less(b);
+}
+
+template&lt;class T&gt; inline void swap(shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp; b)
+{
+    a.swap(b);
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::static_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::const_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::dynamic_cast_tag());
+}
+
+// shared_*_cast names are deprecated. Use *_pointer_cast instead.
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_static_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::static_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_dynamic_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::dynamic_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_polymorphic_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::polymorphic_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_polymorphic_downcast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    BOOST_ASSERT(dynamic_cast&lt;T *&gt;(r.get()) == r.get());
+    return shared_static_cast&lt;T&gt;(r);
+}
+
+// get_pointer() enables boost::mem_fn to recognize shared_ptr
+
+template&lt;class T&gt; inline T * get_pointer(shared_ptr&lt;T&gt; const &amp; p)
+{
+    return p.get();
+}
+
+// operator&lt;&lt;
+
+#if defined(__GNUC__) &amp;&amp;  (__GNUC__ &lt; 3)
+
+template&lt;class Y&gt; std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, shared_ptr&lt;Y&gt; const &amp; p)
+{
+    os &lt;&lt; p.get();
+    return os;
+}
+
+#else
+
+# if defined(BOOST_MSVC) &amp;&amp; BOOST_WORKAROUND(BOOST_MSVC, &lt;= 1200 &amp;&amp; __SGI_STL_PORT)
+// MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL
+using std::basic_ostream;
+template&lt;class E, class T, class Y&gt; basic_ostream&lt;E, T&gt; &amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt; &amp; os, shared_ptr&lt;Y&gt; const &amp; p)
+# else
+template&lt;class E, class T, class Y&gt; std::basic_ostream&lt;E, T&gt; &amp; operator&lt;&lt; (std::basic_ostream&lt;E, T&gt; &amp; os, shared_ptr&lt;Y&gt; const &amp; p)
+# endif 
+{
+    os &lt;&lt; p.get();
+    return os;
+}
+
+#endif
+
+// get_deleter (experimental)
+
+#if (defined(__GNUC__) &amp;&amp;  (__GNUC__ &lt; 3)) || (defined(__EDG_VERSION__) &amp;&amp; (__EDG_VERSION__ &lt;= 238))
+
+// g++ 2.9x doesn't allow static_cast&lt;X const *&gt;(void *)
+// apparently EDG 2.38 also doesn't accept it
+
+template&lt;class D, class T&gt; D * get_deleter(shared_ptr&lt;T&gt; const &amp; p)
+{
+    void const * q = p._internal_get_deleter(typeid(D));
+    return const_cast&lt;D *&gt;(static_cast&lt;D const *&gt;(q));
+}
+
+#else
+
+template&lt;class D, class T&gt; D * get_deleter(shared_ptr&lt;T&gt; const &amp; p)
+{
+    return static_cast&lt;D *&gt;(p._internal_get_deleter(typeid(D)));
+}
+
+#endif
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif    
+
+#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+#endif  // #ifndef BOOST_SHARED_PTR_HPP_INCLUDED

Added: trunk/source/libraries/boost/smart_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/smart_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/smart_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,29 @@
+//
+//  smart_ptr.hpp
+//
+//  For convenience, this header includes the rest of the smart
+//  pointer library headers.
+//
+//  Copyright (c) 1998-2002 boost.org
+//  Copyright (c) 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/smart_ptr/smart_ptr.htm">http://www.boost.org/libs/smart_ptr/smart_ptr.htm</A>
+//
+
+#include &lt;boost/config.hpp&gt;
+
+#include &lt;boost/scoped_ptr.hpp&gt;
+#include &lt;boost/scoped_array.hpp&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/shared_array.hpp&gt;
+
+#if !defined(BOOST_NO_MEMBER_TEMPLATES) || defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+# include &lt;boost/weak_ptr.hpp&gt;
+# include &lt;boost/intrusive_ptr.hpp&gt;
+# include &lt;boost/enable_shared_from_this.hpp&gt;
+#endif

Added: trunk/source/libraries/boost/throw_exception.hpp
===================================================================
--- trunk/source/libraries/boost/throw_exception.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/throw_exception.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,47 @@
+#ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED
+#define BOOST_THROW_EXCEPTION_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/throw_exception.hpp
+//
+//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/utility/throw_exception.html">http://www.boost.org/libs/utility/throw_exception.html</A>
+//
+
+#include &lt;boost/config.hpp&gt;
+
+#ifdef BOOST_NO_EXCEPTIONS
+# include &lt;exception&gt;
+#endif
+
+namespace boost
+{
+
+#ifdef BOOST_NO_EXCEPTIONS
+
+void throw_exception(std::exception const &amp; e); // user defined
+
+#else
+
+template&lt;class E&gt; void throw_exception(E const &amp; e)
+{
+    throw e;
+}
+
+#endif
+
+} // namespace boost
+
+#endif // #ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED

Added: trunk/source/libraries/boost/type.hpp
===================================================================
--- trunk/source/libraries/boost/type.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/type.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,19 @@
+// (C) Copyright David Abrahams 2001. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// &quot;as is&quot; without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+
+#ifndef BOOST_TYPE_DWA20010120_HPP
+# define BOOST_TYPE_DWA20010120_HPP
+
+namespace boost {
+
+  // Just a simple &quot;type envelope&quot;. Useful in various contexts, mostly to work
+  // around some MSVC deficiencies.
+  template &lt;class T&gt;
+  struct type {};
+
+}
+
+#endif // BOOST_TYPE_DWA20010120_HPP

Added: trunk/source/libraries/boost/weak_ptr.hpp
===================================================================
--- trunk/source/libraries/boost/weak_ptr.hpp	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/source/libraries/boost/weak_ptr.hpp	2005-09-24 05:41:48 UTC (rev 193)
@@ -0,0 +1,193 @@
+#ifndef BOOST_WEAK_PTR_HPP_INCLUDED
+#define BOOST_WEAK_PTR_HPP_INCLUDED
+
+//
+//  weak_ptr.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/smart_ptr/weak_ptr.htm">http://www.boost.org/libs/smart_ptr/weak_ptr.htm</A> for documentation.
+//
+
+#include &lt;boost/shared_ptr.hpp&gt;
+
+#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
+# pragma warning(push)
+# pragma warning(disable:4284) // odd return type for operator-&gt;
+#endif
+
+namespace boost
+{
+
+template&lt;class T&gt; class weak_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workarounds
+    typedef weak_ptr&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    weak_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+//  generated copy constructor, assignment, destructor are fine
+
+
+//
+//  The &quot;obvious&quot; converting constructor implementation:
+//
+//  template&lt;class Y&gt;
+//  weak_ptr(weak_ptr&lt;Y&gt; const &amp; r): px(r.px), pn(r.pn) // never throws
+//  {
+//  }
+//
+//  has a serious problem.
+//
+//  r.px may already have been invalidated. The px(r.px)
+//  conversion may require access to *r.px (virtual inheritance).
+//
+//  It is not possible to avoid spurious access violations since
+//  in multithreaded programs r.px may be invalidated at any point.
+//
+
+    template&lt;class Y&gt;
+    weak_ptr(weak_ptr&lt;Y&gt; const &amp; r): pn(r.pn) // never throws
+    {
+        px = r.lock().get();
+    }
+
+    template&lt;class Y&gt;
+    weak_ptr(shared_ptr&lt;Y&gt; const &amp; r): px(r.px), pn(r.pn) // never throws
+    {
+    }
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC &gt; 1200)
+
+    template&lt;class Y&gt;
+    weak_ptr &amp; operator=(weak_ptr&lt;Y&gt; const &amp; r) // never throws
+    {
+        px = r.lock().get();
+        pn = r.pn;
+        return *this;
+    }
+
+    template&lt;class Y&gt;
+    weak_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r) // never throws
+    {
+        px = r.px;
+        pn = r.pn;
+        return *this;
+    }
+
+#endif
+
+    shared_ptr&lt;T&gt; lock() const // never throws
+    {
+#if defined(BOOST_HAS_THREADS)
+
+        // optimization: avoid throw overhead
+        if(expired())
+        {
+            return shared_ptr&lt;element_type&gt;();
+        }
+
+        try
+        {
+            return shared_ptr&lt;element_type&gt;(*this);
+        }
+        catch(bad_weak_ptr const &amp;)
+        {
+            // Q: how can we get here?
+            // A: another thread may have invalidated r after the use_count test above.
+            return shared_ptr&lt;element_type&gt;();
+        }
+
+#else
+
+        // optimization: avoid try/catch overhead when single threaded
+        return expired()? shared_ptr&lt;element_type&gt;(): shared_ptr&lt;element_type&gt;(*this);
+
+#endif
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    bool expired() const // never throws
+    {
+        return pn.use_count() == 0;
+    }
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    void swap(this_type &amp; other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    void _internal_assign(T * px2, detail::shared_count const &amp; pn2)
+    {
+        px = px2;
+        pn = pn2;
+    }
+
+    template&lt;class Y&gt; bool _internal_less(weak_ptr&lt;Y&gt; const &amp; rhs) const
+    {
+        return pn &lt; rhs.pn;
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template&lt;class Y&gt; friend class weak_ptr;
+    template&lt;class Y&gt; friend class shared_ptr;
+
+#endif
+
+    T * px;                     // contained pointer
+    detail::weak_count pn;      // reference counter
+
+};  // weak_ptr
+
+template&lt;class T, class U&gt; inline bool operator&lt;(weak_ptr&lt;T&gt; const &amp; a, weak_ptr&lt;U&gt; const &amp; b)
+{
+    return a._internal_less(b);
+}
+
+template&lt;class T&gt; void swap(weak_ptr&lt;T&gt; &amp; a, weak_ptr&lt;T&gt; &amp; b)
+{
+    a.swap(b);
+}
+
+// deprecated, provided for backward compatibility
+template&lt;class T&gt; shared_ptr&lt;T&gt; make_shared(weak_ptr&lt;T&gt; const &amp; r)
+{
+    return r.lock();
+}
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif    
+
+#endif  // #ifndef BOOST_WEAK_PTR_HPP_INCLUDED

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-09-18 19:57:13 UTC (rev 192)
+++ trunk/sources.lst	2005-09-24 05:41:48 UTC (rev 193)
@@ -1,6 +1,6 @@
-source/python/python_class.cpp
 source/python/game.cpp
 source/other/starmap.cpp
+source/python/python_class.cpp
 source/other/planet3d.cpp
 source/other/gobwarpouttrail.cpp
 source/other/fontmorph.cpp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000138.html">[Tw-light-svn] r192 - in trunk: . gamedata/default_ini source source/libraries/jpgalleg source/other source/util
</A></li>
	<LI>Next message: <A HREF="000140.html">[Tw-light-svn] r194 - trunk/source/melee
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#139">[ date ]</a>
              <a href="thread.html#139">[ thread ]</a>
              <a href="subject.html#139">[ subject ]</a>
              <a href="author.html#139">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
