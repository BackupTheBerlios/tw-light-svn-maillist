From youbastrd at sheep.berlios.de  Mon Nov  1 21:24:46 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Mon, 1 Nov 2004 21:24:46 +0100
Subject: [Tw-light-svn] r94 - branches
Message-ID: <200411012024.iA1KOkF5023940@sheep.berlios.de>

Author: youbastrd
Date: 2004-11-01 21:24:45 +0100 (Mon, 01 Nov 2004)
New Revision: 94

Added:
   branches/mp-branch-2/
Log:
Creating the multiplayer branch, attempr #2

Copied: branches/mp-branch-2 (from rev 93, trunk)



From youbastrd at sheep.berlios.de  Fri Nov  5 08:25:23 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Fri, 5 Nov 2004 08:25:23 +0100
Subject: [Tw-light-svn] r95 - branches/mp-branch-2/source/libraries/raknet
Message-ID: <200411050725.iA57PNj1007148@sheep.berlios.de>

Author: youbastrd
Date: 2004-11-05 08:25:22 +0100 (Fri, 05 Nov 2004)
New Revision: 95

Modified:
   branches/mp-branch-2/source/libraries/raknet/ArrayList.h
   branches/mp-branch-2/source/libraries/raknet/AsynchronousFileIO.cpp
   branches/mp-branch-2/source/libraries/raknet/BinarySearchTree.h
   branches/mp-branch-2/source/libraries/raknet/BitStream.cpp
   branches/mp-branch-2/source/libraries/raknet/BitStream.h
   branches/mp-branch-2/source/libraries/raknet/ClientContextStruct.h
   branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.cpp
   branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.h
   branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.cpp
   branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.h
   branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectHeader.h
   branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectManager.cpp
   branches/mp-branch-2/source/libraries/raknet/EncodeClassName.cpp
   branches/mp-branch-2/source/libraries/raknet/GetTime.cpp
   branches/mp-branch-2/source/libraries/raknet/GetTime.h
   branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.cpp
   branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.h
   branches/mp-branch-2/source/libraries/raknet/InternalPacket.h
   branches/mp-branch-2/source/libraries/raknet/InternalPacketPool.cpp
   branches/mp-branch-2/source/libraries/raknet/LinkedList.h
   branches/mp-branch-2/source/libraries/raknet/Multiplayer.h
   branches/mp-branch-2/source/libraries/raknet/NetworkTypes.cpp
   branches/mp-branch-2/source/libraries/raknet/NetworkTypes.h
   branches/mp-branch-2/source/libraries/raknet/PacketEnumerations.h
   branches/mp-branch-2/source/libraries/raknet/PacketPriority.h
   branches/mp-branch-2/source/libraries/raknet/Queue.h
   branches/mp-branch-2/source/libraries/raknet/RakClient.cpp
   branches/mp-branch-2/source/libraries/raknet/RakClient.h
   branches/mp-branch-2/source/libraries/raknet/RakClientInterface.h
   branches/mp-branch-2/source/libraries/raknet/RakNetworkFactory.h
   branches/mp-branch-2/source/libraries/raknet/RakPeer.cpp
   branches/mp-branch-2/source/libraries/raknet/RakPeer.h
   branches/mp-branch-2/source/libraries/raknet/RakPeerInterface.h
   branches/mp-branch-2/source/libraries/raknet/RakServer.cpp
   branches/mp-branch-2/source/libraries/raknet/RakServer.h
   branches/mp-branch-2/source/libraries/raknet/RakServerInterface.h
   branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.cpp
   branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.h
   branches/mp-branch-2/source/libraries/raknet/SHA1.h
   branches/mp-branch-2/source/libraries/raknet/SocketLayer.cpp
   branches/mp-branch-2/source/libraries/raknet/SocketLayer.h
   branches/mp-branch-2/source/libraries/raknet/StringCompressor.cpp
   branches/mp-branch-2/source/libraries/raknet/StringCompressor.h
Log:
updating raknet library code to newer version

Modified: branches/mp-branch-2/source/libraries/raknet/ArrayList.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/ArrayList.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/ArrayList.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -125,11 +125,7 @@
 template <class list_type>
 inline list_type& List<list_type>::operator[] (unsigned long position)
 {
-	if (position >= list_size)
-	{
-		assert(0); // Reading past the end of the list
-		return array[0];
-	}
+	assert (position < list_size);
 	return array[position];
 }
 

Modified: branches/mp-branch-2/source/libraries/raknet/AsynchronousFileIO.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/AsynchronousFileIO.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/AsynchronousFileIO.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -269,7 +269,7 @@
 				{
 					assert(dwIoSize>0);
 
-					ProcessNetworkPacket(lpOverlapped->playerId.binaryAddress, lpOverlapped->playerId.port, lpOverlapped->data, dwIoSize, lpOverlapped->rakPeer);
+					ProcessNetworkPacket(lpOverlapped->binaryAddress, lpOverlapped->port, lpOverlapped->data, dwIoSize, lpOverlapped->rakPeer);
 	
 					// Issue a new read so we always have one outstanding read per socket
 					// Finished a read.  Reuse the overlapped pointer

Modified: branches/mp-branch-2/source/libraries/raknet/BinarySearchTree.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/BinarySearchTree.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/BinarySearchTree.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -52,6 +52,8 @@
 The assignment operator is defined between BinarySearchTree and AVLBalancedBinarySearchTree as long as they are of the same template type. However, passing a BinarySearchTree to an AVLBalancedBinarySearchTree will lose its structure unless it happened to be AVL balanced to begin with
 Requires queue_linked_list.cpp for the breadth first search used in the copy constructor, overloaded assignment operator, and display_breadth_first_search.
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
+
 */
 
 #ifndef __BINARY_SEARCH_TREE_H
@@ -156,7 +158,7 @@
 				break;
 		}
 
-		if (current==root)
+		if (current==this->root)
 			break;
 
 		current=find_parent(*(current->item));
@@ -234,11 +236,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A->left=C;
+		if (this->direction==this->LEFT) A->left=C;
 			else A->right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this->root=C;  // If B has no parent parent then B must have been the root node
 
 	B->left = D;
 	C->right = B;
@@ -293,11 +295,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A->left=C;
+		if (this->direction==this->LEFT) A->left=C;
 			else A->right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this->root=C;  // If B has no parent parent then B must have been the root node
 
 	B->right = D;
 	C->left = B;
@@ -314,7 +316,7 @@
 template <class BinarySearchTreeType>
 AVLBalancedBinarySearchTree<BinarySearchTreeType>::~AVLBalancedBinarySearchTree()
 {
-	clear();
+	this->clear();
 }
 
 template <class BinarySearchTreeType>
@@ -358,7 +360,7 @@
 template <class BinarySearchTreeType>
 BinarySearchTree<BinarySearchTreeType>::~BinarySearchTree()
 {
-	clear();
+	this->clear();
 }
 
 template <class BinarySearchTreeType>
@@ -367,7 +369,7 @@
 	static typename BinarySearchTree::node* tempnode;
 	static BinarySearchTreeType* dummyptr=0;
 	tempnode = find (element, &tempnode);
-	if (direction==NOT_FOUND)
+	if (this->direction==this->NOT_FOUND)
 		return dummyptr;
 
 	return tempnode->item;
@@ -378,24 +380,24 @@
 {
 	static typename BinarySearchTree::node* current;
 
-	current=root;
+	current=this->root;
 	*parent=0;
-	direction=ROOT;
+	this->direction=this->ROOT;
 
 	if (BinarySearchTree_size==0L) 
 	{
-		direction=NOT_FOUND;
+		this->direction=this->NOT_FOUND;
 		return current=0;
 	}
 
 	// Check if the item is at the root
-	if (element == *(current->item)) {direction=ROOT; return current;}
+	if (element == *(current->item)) {this->direction=this->ROOT; return current;}
 
 	while (true)
 	{	
 		// Move pointer
-		if (element < *(current->item)) {*parent=current; direction=LEFT; current=current->left;}
-		else if (element > *(current->item)) {*parent=current; direction=RIGHT; current=current->right;}
+		if (element < *(current->item)) {*parent=current; this->direction=this->LEFT; current=current->left;}
+		else if (element > *(current->item)) {*parent=current; this->direction=this->RIGHT; current=current->right;}
 		
 		if (current==0) break;
 
@@ -404,7 +406,7 @@
 	}
 	
 
-	direction=NOT_FOUND;
+	this->direction=this->NOT_FOUND;
 	return current=0;
 }
 

Modified: branches/mp-branch-2/source/libraries/raknet/BitStream.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/BitStream.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/BitStream.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -26,6 +26,8 @@
 #include <stdio.h>
 #include <string.h>
 
+using namespace RakNet;
+
 BitStream::BitStream()
 {
 	numberOfBitsUsed=0;
@@ -35,7 +37,7 @@
 #ifdef _DEBUG
 	assert(data);
 #endif
-	memset(data, 0, 32);
+	//memset(data, 0, 32);
 	copyData=true;
 }
 
@@ -48,7 +50,7 @@
 	#ifdef _DEBUG
 	assert(data);
 	#endif
-	memset(data, 0, initialBytesToAllocate);
+//	memset(data, 0, initialBytesToAllocate);
 	copyData=true;
 }
 
@@ -92,14 +94,18 @@
 
 void BitStream::Reset(void)
 {
+	if (numberOfBitsUsed>0)
+	{
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsUsed));
+	}
 	// Don't free memory here for speed efficiency
 	//free(data);  // Use realloc and free so we are more efficient than delete and new for resizing
 	numberOfBitsUsed=0;
 	//numberOfBitsAllocated=8;
 	readOffset=0;
 	//data=(unsigned char*)malloc(1);
-	if (numberOfBitsAllocated>0)
-		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
+//	if (numberOfBitsAllocated>0)
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
 }
 
 // Write the native types to the end of the buffer
@@ -598,8 +604,11 @@
 {
 	AddBitsAndReallocate(1);
 
-	// New bits are set to 0 as default
-	numberOfBitsUsed++;
+	// New bytes need to be zeroed
+	if ((numberOfBitsUsed%8)==0)
+		data[numberOfBitsUsed>>3] = 0;
+
+	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
  // Write a 1
@@ -607,7 +616,12 @@
 {
 	AddBitsAndReallocate(1);
 
-	data[numberOfBitsUsed>>3] |= 0x80 >> (numberOfBitsUsed%8); // Set the bit to 1
+	int numberOfBitsMod8 = numberOfBitsUsed%8;
+	if (numberOfBitsMod8==0)
+		data[numberOfBitsUsed>>3] = 0x80;
+	else
+		data[numberOfBitsUsed>>3] |= 0x80 >> (numberOfBitsMod8); // Set the bit to 1
+	
 	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
@@ -681,8 +695,8 @@
 // Write numberToWrite bits from the input source
 void BitStream::WriteBits(unsigned char *input, int numberOfBitsToWrite, bool rightAlignedBits)
 {
-	if (numberOfBitsToWrite<=0)
-		return;
+//	if (numberOfBitsToWrite<=0)
+//		return;
 
 	AddBitsAndReallocate(numberOfBitsToWrite);
 	int offset=0;
@@ -691,19 +705,31 @@
 
 	numberOfBitsUsedMod8=numberOfBitsUsed%8;
 
-	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToWrite>0)
+	//do
 	{
 		dataByte = *(input+offset);
 		if (numberOfBitsToWrite<8 && rightAlignedBits) // rightAlignedBits means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation)
 			dataByte<<=8-numberOfBitsToWrite;	 // shift left to get the bits on the left, as in our internal representation
 
-		// Copy over the new data.
-		*(data+(numberOfBitsUsed>>3)) |= dataByte >> (numberOfBitsUsedMod8); // First half
-		if (8 - (numberOfBitsUsedMod8) < 8 && 8 - (numberOfBitsUsedMod8) < numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
-			*(data+(numberOfBitsUsed>>3) + 1) |= (unsigned char)(dataByte << (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
-	
+		// Writing to a new byte each time
+		if (numberOfBitsUsedMod8==0)
+			*(data+(numberOfBitsUsed>>3)) = dataByte;
+		else
+		{
+			// Copy over the new data.
+			*(data+(numberOfBitsUsed>>3)) |= dataByte >> (numberOfBitsUsedMod8); // First half
+			if (8 - (numberOfBitsUsedMod8) < 8 && 8 - (numberOfBitsUsedMod8) < numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
+			{
+				*(data+(numberOfBitsUsed>>3) + 1) = (unsigned char)(dataByte << (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
+			}
+		}
+
 		if (numberOfBitsToWrite>=8)
+		{
 			numberOfBitsUsed+= 8;
+		}
 		else
 		{
 			numberOfBitsUsed+= numberOfBitsToWrite;
@@ -711,8 +737,8 @@
 		numberOfBitsToWrite-= 8;
 		
 		offset++;
-	} while(numberOfBitsToWrite>0);
-
+	}
+//	} while(numberOfBitsToWrite>0);
 }
 
 // Set the stream to some initial data.  For internal use
@@ -760,7 +786,7 @@
 			Write(b);
 
 			WriteBits(input,(currentByte+1)<<3, true);
-			currentByte--;
+	//		currentByte--;
 
 	
 			return;
@@ -793,8 +819,8 @@
 	#ifdef _DEBUG
 	assert(numberOfBitsToRead>0);
 	#endif
-	if (numberOfBitsToRead<=0)
-		return false;
+//	if (numberOfBitsToRead<=0)
+//		return false;
 
 	if (readOffset+numberOfBitsToRead >numberOfBitsUsed)
 		return false;
@@ -806,7 +832,9 @@
 
 	readOffsetMod8=readOffset%8;
 
-	do
+//	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToRead>0)
 	{
 			*(output + offset) |= *(data+(readOffset>>3)) << (readOffsetMod8); // First half
 
@@ -825,7 +853,8 @@
 
 			offset++;
 
-	} while(numberOfBitsToRead>0);
+	}
+	//} while(numberOfBitsToRead>0);
 
 	return true;
 }
@@ -920,7 +949,7 @@
 		#ifdef _DEBUG
 		assert(data); // Make sure realloc succeeded
 		#endif
-		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
+//		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
 	}
 
 	if (newNumberOfBitsAllocated > numberOfBitsAllocated)

Modified: branches/mp-branch-2/source/libraries/raknet/BitStream.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/BitStream.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/BitStream.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -10,6 +10,9 @@
 #ifndef  __BITSTREAM_H
 #define __BITSTREAM_H
 
+namespace RakNet
+{
+
 #define BITS_TO_BYTES(x) (((x)+7)>>3)
 
 class BitStream
@@ -168,4 +171,6 @@
 	bool copyData;
 };
 
+}
+
 #endif

Modified: branches/mp-branch-2/source/libraries/raknet/ClientContextStruct.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/ClientContextStruct.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/ClientContextStruct.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -30,7 +30,8 @@
 	OVERLAPPED overlapped;
 	char data[MAXIMUM_MTU_SIZE]; // Used to hold data to send
 	int length; // Length of the actual data to send, always under MAXIMUM_MTU_SIZE
-	PlayerID playerId;
+	unsigned long binaryAddress;
+	unsigned short port;
 	RakPeer *rakPeer;
 	bool read; // Set to true for reads, false for writes
 };

Modified: branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -9,6 +9,9 @@
 {
 	keySet=false;
 }
+DataBlockEncryptor::~DataBlockEncryptor()
+{
+}
 bool DataBlockEncryptor::IsKeySet(void) const
 {
 	return keySet;
@@ -40,21 +43,22 @@
 
 	assert(input && inputLength);
 
+
 	// randomChar will randomize the data so the same data sent twice will not look the same
 	randomChar=(unsigned char)randomMT();
 
-
 	// 16-(((x-1) % 16)+1) 
 
 	// # of padding bytes is 16 -(((input_length + extra_data -1) % 16)+1)
 	paddingBytes = (unsigned char)(16 -(((inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad) -1) % 16)+1));
-	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
 
 	// Randomize the pad size variable
 	encodedPad=(unsigned char)randomMT();
 	encodedPad<<=4;
 	encodedPad|=paddingBytes;
 
+	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
+
 	// Write the data first, in case we are overwriting ourselves
 	if (input==output)
 		memmove(output+sizeof(checkSum)+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes, input, inputLength);
@@ -108,9 +112,6 @@
 	
 	if (input==0 || inputLength<16 || (inputLength % 16) != 0)
 	{
-#ifdef _DEBUG
-		assert(0);
-#endif
 		return false;
 	}
 
@@ -121,7 +122,7 @@
 
 		for (byteIndex=0; byteIndex<16; byteIndex++)
 		{
-			if (index+16==inputLength)
+			if (index+16==(unsigned)inputLength)
 				input[index+byteIndex]^=input[byteIndex];
 			else
 				input[index+byteIndex]^=input[index+16+byteIndex];
@@ -142,10 +143,11 @@
 	// Ignore the high 4 bytes
 	paddingBytes=encodedPad&0x0F;
 
+
 	// Get the data length
 	*outputLength=inputLength - sizeof(randomChar)-sizeof(checkSum)-sizeof(encodedPad)-paddingBytes;
 
-	// Calculate the checksum on the data
+	// Calculate the checksum on the data.
 	checkSumCalculator.add(input+sizeof(checkSum), *outputLength+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes);
 	if (checkSum != checkSumCalculator.get())
 		return false;
@@ -156,5 +158,6 @@
 	else
 		memcpy(output, input+sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes, *outputLength);
 
+
 	return true;
 }

Modified: branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/DataBlockEncryptor.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -7,6 +7,7 @@
 {
 public:
 	DataBlockEncryptor();
+	~DataBlockEncryptor();
 	bool IsKeySet(void) const;
 
 	void SetKey(const unsigned char key[16]);

Modified: branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -17,6 +17,7 @@
 #include <string.h>
 #include "DistributedNetworkObjectManager.h"
 
+
 DistributedNetworkObject::DistributedNetworkObject()
 {
 	maximumUpdateFrequency=50; // 50 ms by default
@@ -35,8 +36,8 @@
 	if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface())
 	{
 		// These 3 lines of code will broadcast to destroy the object
-		BitStream bitStream;
-		SerializeClassHeader(&bitStream, 0, false, false, 0);
+		RakNet::BitStream bitStream;
+		SerializeClassHeader(&bitStream, 0, 0, false, 0);
 		BroadcastSerializedClass(&bitStream);
 	}
 
@@ -55,8 +56,8 @@
 void DistributedNetworkObject::DestroyObjectOnNetwork(void)
 {
 	// These 3 lines of code will broadcast to destroy the object
-	BitStream bitStream;
-	SerializeClassHeader(&bitStream, 0, false, false, 0);
+	RakNet::BitStream bitStream;
+	SerializeClassHeader(&bitStream, 0, 0, false, 0);
 	BroadcastSerializedClass(&bitStream);
 
 	DistributedNetworkObjectManager::Instance()->UnregisterNetworkObject(this);
@@ -68,7 +69,7 @@
 	}
 }
 
-void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority)
+void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority)
 {
 	// Was memory previously allocated?
 	if (heapNodeList[memoryBlockIndex].lastWriteValue)
@@ -96,7 +97,7 @@
 	heapNodeList[memoryBlockIndex].watchedData=memoryBlock;
 
 	// Initialize nextUpdateTime to the current time.
-	heapNodeList[memoryBlockIndex].nextUpdateTime=getTime();
+	heapNodeList[memoryBlockIndex].nextUpdateTime=RakNetGetTime();
 
 	// Set the authority
 	heapNodeList[memoryBlockIndex].serverAuthority=serverAuthority;
@@ -130,12 +131,12 @@
 }
 // Same as ProcessDistributedMemoryStack, but for the heapNodeList.
 // Returns true if data was written
-bool DistributedNetworkObject::WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite)
+bool DistributedNetworkObject::WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite)
 {
     int heapNodeIndex;
 	unsigned long time;
-	BitStream heapData(256);
-	time=getTime();
+	RakNet::BitStream heapData(256);
+	time=RakNetGetTime();
 	unsigned char numberOfBlocksWritten;
 
 	numberOfBlocksWritten=0;
@@ -143,7 +144,7 @@
 	for (heapNodeIndex=0; heapNodeIndex < 256; heapNodeIndex++)
 	{
 		// Is this a block we are responsible for updating, and it is time to update?
-		if (IsMemoryBlockIndexUsed(heapNodeIndex) &&
+		if (IsMemoryBlockIndexUsed((unsigned char)heapNodeIndex) &&
 			forceWrite ||
 			(time >= heapNodeList[heapNodeIndex].nextUpdateTime &&
 			((DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && heapNodeList[heapNodeIndex].serverAuthority) ||
@@ -172,24 +173,35 @@
 
 	if (numberOfBlocksWritten>0)
 	{
+		bitStream->Write(true);
 		bitStream->WriteCompressed(numberOfBlocksWritten);
 		bitStream->Write((char*)heapData.GetData(), heapData.GetNumberOfBytesUsed());
 		return true;
 	}
+	else
+		bitStream->Write(false);
 
+	if (forceWrite)
+		WriteCreationData(bitStream);
+
 	return false;
 }
 
-void DistributedNetworkObject::WriteToHeapFromBitstream(BitStream *bitStream)
+void DistributedNetworkObject::WriteToHeapFromBitstream(RakNet::BitStream *bitStream)
 {
 	int index;
 	unsigned char heapNodeIndex;
 	unsigned char numberOfBlocksWritten;
+	bool anyDataWritten;
 
 #ifdef _DEBUG
 	unsigned short usedBlockSize;
 #endif
 
+	bitStream->Read(anyDataWritten);
+	if (anyDataWritten==false)
+		return;
+
 	bitStream->ReadCompressed(numberOfBlocksWritten);
 
 	for (index=0; index < numberOfBlocksWritten; index++)
@@ -230,7 +242,7 @@
 }
 
 // Writes to or reads from a bitstream for all distributed memory.  This function does not need to be modified by the end-user
-bool DistributedNetworkObject::ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
+bool DistributedNetworkObject::ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
 {
 	return false;
 }
@@ -256,7 +268,7 @@
 	 (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->IsConnected()))
 	{
 		char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 
 		if (isClassIDEncoded)
 			memcpy(classIdentifier, classID, MAXIMUM_CLASS_IDENTIFIER_LENGTH);
@@ -267,24 +279,34 @@
 		// The only purpose of registering and unregistering network objects is so we can call SendAllDistributedObjects from
 		// DistributedNetworkObjectManager to new players
 		firstTimeAddedToRegistry = DistributedNetworkObjectManager::Instance()->RegisterNetworkObject(this,classIdentifier, localObjectIdentifier);
+		if (serverProcess && firstTimeAddedToRegistry && isClassIDEncoded==false)
+		{
+			// This is like a local echo - call OnDistributedObjectCreation for the server when it is not
+			// created by the network
+			if (OnDistributedObjectCreation(UNASSIGNED_PLAYER_ID)==false)
+			{
+				DistributedNetworkObjectManager::Instance()->UnregisterNetworkObject(this);
+				return;
+			}
+		}
 
 		// This logic is correct - ProcessDistributedMemoryStack has a side effect of updating network memory to the last send so you don't
 		// want to call it unnecessarily
 		if (firstTimeAddedToRegistry && (localObject || DistributedNetworkObjectManager::Instance()->GetRakServerInterface()))
 		{
-			SerializeClassHeader(&bitStream, classIdentifier, true, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&bitStream, classIdentifier, 2, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
 			ProcessDistributedMemoryStack(&bitStream, true, true,serverProcess);
-			WriteToBitstreamFromHeap(&bitStream, true);
+			WriteToBitstreamFromHeap(&bitStream, true);	
 			BroadcastSerializedClass(&bitStream);
 		}
 		else if ((localObject == false || DistributedNetworkObjectManager::Instance()->GetRakServerInterface()) &&
-			getTime() > lastBroadcastTime + maximumUpdateFrequency)
+			RakNetGetTime() > lastBroadcastTime + maximumUpdateFrequency)
 		{
-			SerializeClassHeader(&bitStream, classIdentifier, true, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&bitStream, classIdentifier, 1, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
 			dataWritten1=ProcessDistributedMemoryStack(&bitStream, true, false,serverProcess);
 			dataWritten2=WriteToBitstreamFromHeap(&bitStream, false);
 			if (dataWritten1 || dataWritten2)
-			{					
+			{
 				BroadcastSerializedClass(&bitStream);
 			}
 		}
@@ -293,12 +315,20 @@
 	InterpolateDistributedMemory(serverProcess);
 }
 
+void DistributedNetworkObject::WriteCreationData(RakNet::BitStream *initialData)
+{
+}
+
+void DistributedNetworkObject::ReadCreationData(RakNet::BitStream *initialData)
+{
+}
+
 void DistributedNetworkObject::SetMaximumUpdateFrequency(unsigned long frequency)
 {
 	maximumUpdateFrequency=frequency;
 }
 
-void DistributedNetworkObject::BroadcastSerializedClass(BitStream *bitStream)
+void DistributedNetworkObject::BroadcastSerializedClass(RakNet::BitStream *bitStream)
 {
 	if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 	{
@@ -310,28 +340,28 @@
 		}
 
 		DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, localClient, true);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 	else if (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->IsConnected())
 	{
 		// This sends a request to create or update the object
 		DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 }
 
-void DistributedNetworkObject::SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex)
+void DistributedNetworkObject::SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex)
 {
 	static const unsigned char packetId = ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT;
 
 	bitStream->Write(packetId);
 
 	// Construction to true means we are creating or updating this object.  Otherwise it means we are destroying this object.
-	bitStream->Write(construction);
+	bitStream->WriteBits((unsigned char*)&action, 2);
 
 	bitStream->Write(GetID());
 
-	if (construction)
+	if (action==2)
 	{
 		bitStream->Write(classIdentifier, classIdentifier[0]+1);
 	}
@@ -339,23 +369,39 @@
 	bitStream->Write(localObject);
 	if (localObject)
 		bitStream->Write(localObjectIndex);
+
+	if (action==2)
+	{
+		if (clientOwnerID==UNASSIGNED_PLAYER_ID)
+		{
+			bitStream->Write(false);
+		}
+		else
+		{
+			bitStream->Write(true);
+			bitStream->Write((char*)&clientOwnerID, sizeof(PlayerID));
+		}
+	}
+
 }
 
-bool DistributedNetworkObject::DeserializeClassHeader(BitStream *bitStream, bool &construction, ObjectID &objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex)
+bool DistributedNetworkObject::DeserializeClassHeader(RakNet::BitStream *bitStream, int &action, ObjectID &objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex, PlayerID &pid)
 {
 	unsigned char packetId;
+	bool hasClientOwnerID;
 	if (bitStream->Read(packetId)==false)
 		return false;
 
 	assert(packetId==ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT);
 
-	if (bitStream->Read(construction)==false)
+	action=0;
+	if (bitStream->ReadBits((unsigned char*)&action,2)==false)
 		return false;
 
 	if (bitStream->Read(objectId)==false)
 		return false;
 
-	if (construction)
+	if (action==2)
 	{
 		unsigned char classNameLength;
 		if (bitStream->Read(classNameLength)==false)
@@ -365,6 +411,8 @@
 
 		classIdentifier[0]=classNameLength;
 	}
+	else
+		classIdentifier=0;
 
 	bool isLocalObjectInpacket;
 	if (bitStream->Read(isLocalObjectInpacket)==false)
@@ -375,6 +423,19 @@
 			return false;
 	}
 
+	if (action==2)
+	{
+		if (bitStream->Read(hasClientOwnerID)==false)
+			return false;
+		if (hasClientOwnerID)
+		{
+			if (bitStream->Read((char*)&pid, sizeof(PlayerID))==false)
+				return false;
+		}
+		else
+			pid=UNASSIGNED_PLAYER_ID;
+	}	
+
 	return true;
 }
 
@@ -389,7 +450,6 @@
 
 bool DistributedNetworkObject::OnDistributedObjectCreation(PlayerID senderID)
 {
-	localObject=false;
 #ifdef _DEBUG
 	assert(GetID()!=UNASSIGNED_OBJECT_ID);
 #endif
@@ -430,3 +490,9 @@
 {
 	clientOwnerID=id;
 }
+
+void DistributedNetworkObject::SetLocalObject(bool b)
+{
+	localObject=b;
+}
+

Modified: branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObject.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -7,13 +7,13 @@
 
 // Refer to the appropriate license agreement for distribution, modification, and warranty rights.
 
+#ifndef __DISTRIBUTED_NETWORK_OBJECT
+#define __DISTRIBUTED_NETWORK_OBJECT
+
 #include "NetworkObject.h"
 #include "EncodeClassName.h"
-class BitStream;
+#include "BitStream.h"
 
-#ifndef __DISTRIBUTED_NETWORK_OBJECT
-#define __DISTRIBUTED_NETWORK_OBJECT
-
 class DistributedNetworkObject : public NetworkObject
 {
 public:
@@ -33,7 +33,6 @@
 	// If you wish to block deletion, override OnDistributedObjectDestruction
 	virtual void DestroyObjectOnNetwork(void);
 
-
 	// Server only function -
 	// By default, when a client creates an object only it can update the client authoritative members
 	// Of the class it creates.  You can also set this manually with SetClientOwnerID
@@ -55,7 +54,7 @@
 	
 	// Tags memory to be synchronized.  You can set the server or the client as the authority for this block.
 	// Only the authority will write this memory to the network when it is changed.
-	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority);
+	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority);
 
 	// Untags memory that was formerly synchronized.
 	void DesynchronizeMemory(unsigned char memoryBlockIndex);
@@ -73,7 +72,19 @@
 	// --------------------------------------------------------------------------
 	// Events
 	// --------------------------------------------------------------------------
+	// When object creation data is needed, WriteCreationData is called.
+	// This function is for you to write any data that is needed to create or initialize the object
+	// On remote systems
+	virtual void WriteCreationData(RakNet::BitStream *initialData);
 
+	// When an object is created, ReadCreationData is called immediately after a 
+	// successful call to OnDistributedObjectCreation
+	// This function is for you to read any data written from WriteCreationData
+	// on remote systems.  If the object is created by the client, this function is
+	// also called by the creator of the object when sent back from the server in case the
+	// server overrode any settings
+	virtual void ReadCreationData(RakNet::BitStream *initialData);
+
 	// When distributed data changes for an object, this function gets called.  Default behavior is to do nothing.
 	// Override it if you want to perform updates when data is changed
 	// On the server it is also important to override this to make sure the data the client just sent you is reasonable.
@@ -101,34 +112,37 @@
 
 	// You don't need to modify this
 	// Sends the bitstream to other systems
-	virtual void BroadcastSerializedClass(BitStream *bitStream);
+	virtual void BroadcastSerializedClass(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Writes the header identifying the class, objectID, and whether the object is being created or destroyed
-	virtual void SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex);
-	static bool DeserializeClassHeader(BitStream *bitStream, bool &construction, ObjectID &objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex);
+	// action of 0 means destruction, 1 means update, 2 means create
+	virtual void SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex);
+	static bool DeserializeClassHeader(RakNet::BitStream *bitStream, int &action, ObjectID &objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex, PlayerID &pid);
 
 	// You don't need to modify this
 	// Returns true if this object was locally created, as opposed to created by the network
 	bool IsLocalObject(void) const;
+	void SetLocalObject(bool b);
 
 	// Writes to or reads from a bitstream for all distributed memory on the stack.  This function does not need to be modified by the end-user
 	// Returns true if any data was written
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to false, but for the heapNodeList.
 	// Returns true if data was written
-	bool WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite);
+	bool WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to true, but for the heapNodeList.
-	void WriteToHeapFromBitstream(BitStream *bitStream);
+	void WriteToHeapFromBitstream(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Returns the identifier for an object that has not yet had SetID called on it
 	unsigned char GetLocalObjectIdentifier(void) const;
 
-	// Server only - select which client can update the client authoritative members of this object.
-	// UNASSIGNED_PLAYER_ID no client owns the object, so any client can update the object.
+	// This is set to who created this object.
+	// On the server, this also determines who can update the client authoritative members of this object.
+	// You can manually set it to UNASSIGNED_PLAYER_ID so no client owns the object, so any client can update the object.
 	PlayerID GetClientOwnerID(void) const;
 	void SetClientOwnerID(PlayerID id);
 

Modified: branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectHeader.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -49,7 +49,7 @@
 	BaseClass::DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -70,7 +70,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_CODE(AuthoritativeNetwork1, VariableName1)	\
@@ -132,7 +132,7 @@
 	DOM_CORE_EXPANDED(AuthoritativeNetwork,VariableType,VariableName, ReadCode, ReadDummyCode, WriteCode, VariableName!=VariableName##_LastKnownValue)	\
 	if (isWrite==false && dataChanged==true)	\
 	{	\
-		VariableName##_InterpolationStartTime=getTime();	\
+		VariableName##_InterpolationStartTime=RakNetGetTime();	\
 		VariableName##_InterpolationEndTime=VariableName##_InterpolationStartTime+maximumUpdateFrequency;	\
 		VariableName##_InitialValue=VariableName;	\
 		VariableName##_FinalValue=VariableName##_LastReadValue;	\
@@ -214,7 +214,7 @@
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -234,7 +234,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -260,7 +260,7 @@
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -282,7 +282,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -313,7 +313,7 @@
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -337,7 +337,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -373,7 +373,7 @@
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -399,7 +399,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -440,7 +440,7 @@
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 	SynchronizationMethod6##_INTERPOLATION_MEMORY_INIT(VariableName6)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -468,7 +468,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -480,4 +480,4 @@
 	SynchronizationMethod6##_INTERPOLATION_CODE(AuthoritativeNetwork6, VariableName6)	\
 }
 
-// Extend this pattern as many times as necessary.  If anyone figures out a way to automate a way to do that with the preprocessor let me know
\ No newline at end of file
+// Extend this pattern as many times as necessary.  If anyone figures out a way to automate a way to do that with the preprocessor let me know

Modified: branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectManager.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -90,9 +90,14 @@
 DistributedNetworkObject *DistributedNetworkObjectManager::GetClassInstanceByIdentifier(char *classIdentifier)
 {
 	unsigned i;
+
+	if (classIdentifier[0]==0)
+		return 0;
+
 	for (i=0; i < classList.size(); i++)
 	{
 		// Byte 0 of the class identifier holds the length of the remaining bytes
+		// The +1 is because we also compare the first byte
 		if (memcmp(classIdentifier, classList[i]->GetEncodedClassName(), classList[i]->GetEncodedClassName()[0]+1)==0)
 			return classList[i]->GetObject();
 	}
@@ -106,15 +111,17 @@
 	// Assert that the first byte of the packet is ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT
 
 	char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-	BitStream bitStream(packet->data, packet->length, true);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, true);
 	ObjectID objectId;
 	DistributedNetworkObject* object=0;
-	bool construction;
+	int action;
+	PlayerID pid;
+	bool isLocalObject;
+	unsigned char localObjectIndex;
+	pid=UNASSIGNED_PLAYER_ID;
 
 
-	bool isLocalObject;
-	unsigned char localObjectIndex;
-	if (DistributedNetworkObject::DeserializeClassHeader(&bitStream, construction, objectId, classIdentifier,isLocalObject,localObjectIndex)==false)
+	if (DistributedNetworkObject::DeserializeClassHeader(&bitStream, action, objectId, classIdentifier,isLocalObject,localObjectIndex,pid)==false)
 		return 0; // Some kind of corrupted packet, or the server was active but not registered, or the client was active but not registered
 
 	bool serverProcess=true;
@@ -125,7 +132,7 @@
 			serverProcess=false;
 	}
 
-	if (construction)
+	if (action>=1)
 	{
 		if (objectId!=UNASSIGNED_OBJECT_ID)
 		{
@@ -146,7 +153,10 @@
 
 			if (object==0)
 			{
-				assert(0); // Unknown class identifier
+				// If this assert hits then one system tried to create a class that was
+				// not registered with REGISTER_DISTRIBUTED_NETWORK_OBJECT on this system.
+				// Byte 0 of 0 means no class identifier was encoded
+				assert(classIdentifier[0]==0);
 				return 0;
 			}
 
@@ -154,6 +164,9 @@
 				DistributedNetworkObjectManager::Instance()->GetRakServerInterface()==0)
 				object->SetID(objectId);
 
+			if (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && pid!=UNASSIGNED_PLAYER_ID)
+				object->SetClientOwnerID(pid); // So the client knows who is the owner of the object
+
 			object->ProcessDistributedMemoryStack(&bitStream, false, false, serverProcess);
 			object->WriteToHeapFromBitstream(&bitStream);
 
@@ -165,6 +178,11 @@
 					delete object;
 					object=0;
 				}
+				else
+				{
+					object->SetLocalObject(false);
+					object->ReadCreationData(&bitStream);
+				}
 			}
 			else if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 			{
@@ -176,7 +194,7 @@
 
 					// Tell the sender that the object creation was rejected
 					static const unsigned char objectRejectedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED;
-					BitStream rejectionBitStream;
+					RakNet::BitStream rejectionBitStream;
 					rejectionBitStream.Write(objectRejectedID);
 					rejectionBitStream.Write(localObjectIndex);
 
@@ -184,12 +202,16 @@
 				}
 				else
 				{
+					object->SetLocalObject(false);
+					object->ReadCreationData(&bitStream);
+
 					// Receipt of this packet will set the object ID for the client so future data packets can be processed
 					static const unsigned char objectAcceptedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED;
-					BitStream acceptanceBitStream;
+					RakNet::BitStream acceptanceBitStream;
 					acceptanceBitStream.Write(objectAcceptedID);
 					acceptanceBitStream.Write(localObjectIndex);
 					acceptanceBitStream.Write(object->GetID());
+					acceptanceBitStream.Write((char*)&packet->playerId, sizeof(PlayerID));
 
 					DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->Send(&acceptanceBitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->playerId, false);
 
@@ -202,11 +224,11 @@
 					object->BroadcastSerializedClass(&bitStream);
 					*/
 
-					object->UpdateDistributedObject(classIdentifier, true);
-
 					// If the client creates the object, it is considered the owner
 					object->SetClientOwnerID(packet->playerId);
 
+					object->UpdateDistributedObject(classIdentifier, true);
+
 				}
 			}
 		}
@@ -234,7 +256,7 @@
 			if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 			{
 				bitStream.Reset();
-				object->SerializeClassHeader(&bitStream, classIdentifier, true, false, 0);
+				object->SerializeClassHeader(&bitStream, classIdentifier, action, false, 0);
 				object->ProcessDistributedMemoryStack(&bitStream, true, true,true);
 				object->WriteToBitstreamFromHeap(&bitStream, true);
 				object->BroadcastSerializedClass(&bitStream);
@@ -250,6 +272,17 @@
 			return 0;
 		}
 
+		// If this is the server and the client is trying to destroy it, make sure it is either the
+		// owner or no owner is set
+		if (serverProcess)
+		{
+			if (object->GetClientOwnerID()!=UNASSIGNED_PLAYER_ID &&
+				object->GetClientOwnerID()!=packet->playerId &&
+				object->AllowSpectatorUpdate(packet->playerId)==false)
+				// Client trying to update an object it does not own - and it was not allowed to
+				return 0;
+		}
+
 		object->OnDistributedObjectDestruction(packet->playerId);
 		object=0;
 	}
@@ -262,13 +295,16 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 	ObjectID objectID;
+	PlayerID pid;
 
-	BitStream bitStream(packet->data, packet->length, false);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
 	if (bitStream.Read(objectID)==0)
 		return;
+	if (bitStream.Read((char*)&pid, sizeof(PlayerID))==0)
+		return;
 
 	// Find the object with this index
 	object = GetObjectByLocalObjectIndex(localObjectIndex);
@@ -286,6 +322,12 @@
 		delete object;
 		object=0;
 	}
+	else
+	{
+		object->SetLocalObject(false);
+		object->SetClientOwnerID(pid);
+	}
+
 }
 
 void DistributedNetworkObjectManager::HandleDistributedNetworkObjectPacketCreationRejected(Packet *packet)
@@ -293,7 +335,7 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 
-	BitStream bitStream(packet->data, packet->length, false);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
@@ -336,12 +378,12 @@
 			}
 		}
 
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 		unsigned i;
 		for (i=0; i < distributedNetworkObjectInstanceRegistry.size(); i++)
 		{
 			bitStream.Reset();
-			distributedNetworkObjectInstanceRegistry[i]->object->SerializeClassHeader(&bitStream, distributedNetworkObjectInstanceRegistry[i]->classIdentifier, true, false, 255);
+			distributedNetworkObjectInstanceRegistry[i]->object->SerializeClassHeader(&bitStream, distributedNetworkObjectInstanceRegistry[i]->classIdentifier, 2, false, 255);
 
 			// Note to self - ProcessDistributedMemoryStack with write to true will update network memory.  During the next normal updates
 			// any changes that occured in the meantime won't be distributed.  Is this something to be concerned about?

Modified: branches/mp-branch-2/source/libraries/raknet/EncodeClassName.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/EncodeClassName.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/EncodeClassName.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -13,7 +13,7 @@
 
 void EncodeClassName(char *name, char *identifier)
 {
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 	int index=0;
 	unsigned char byte;
 	while (index < MAXIMUM_CLASS_IDENTIFIER_LENGTH-1)

Modified: branches/mp-branch-2/source/libraries/raknet/GetTime.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/GetTime.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/GetTime.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -9,28 +9,43 @@
 
 #include "GetTime.h"
 
-////#include "MemoryManager.h"
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <sys/time.h>
+#endif
 
-GetTime GetTime::instance;
-
-GetTime::GetTime()
+unsigned long RakNetGetTime(void)
 {
-// For some reason this fails in the constructor
-//	QueryPerformanceFrequency(&yo);
-//	counts = yo.QuadPart >> 10;
-	initialized=false;
-}
+#ifdef _WIN32
+	static LARGE_INTEGER yo;
+	static LONGLONG counts;
+#else
+	static timeval tp, initialTime;
+#endif
+	static bool initialized=false;
+	if (initialized==false)
+	{
+#ifdef _WIN32
+		QueryPerformanceFrequency(&yo);
+		// The original code shifted right 10 bits
+		//counts = yo.QuadPart >> 10;
+		// It gives the wrong value since 2^10 is not 1000
+		counts = yo.QuadPart / 1000;
+#else
+		gettimeofday(&initialTime, 0); 
+#endif
+		initialized=true; 
+	}
 
-void GetTime::Init(void)
-{
-	#ifdef _WIN32
-	QueryPerformanceFrequency(&yo);
-	// The original code shifted right 10 bits
-	//counts = yo.QuadPart >> 10;
-	// It gives the wrong value since 2^10 is not 1000
-	counts = yo.QuadPart / 1000;
-	#else
-	gettimeofday(&initialTime, 0); 
-	#endif
-	initialized=true; 
+#ifdef _WIN32
+	LARGE_INTEGER PerfVal;
+	QueryPerformanceCounter(&PerfVal);
+	return (unsigned long)(PerfVal.QuadPart/counts);
+#else
+	gettimeofday(&tp, 0);
+
+	// Seconds to ms and microseconds to ms
+	return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
+#endif
 }

Modified: branches/mp-branch-2/source/libraries/raknet/GetTime.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/GetTime.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/GetTime.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -10,53 +10,7 @@
 #ifndef __GET_TIME_H
 #define __GET_TIME_H
 
-#ifdef _WIN32
-#include <windows.h>
-#else
-#include <sys/time.h>
-#endif
+extern unsigned long RakNetGetTime(void);
 
-// A utility class to get a more accurate time than timeGetTime()
-class GetTime
-{
-public:
-	// Call this before using the function.  It won't work in constructor calls though, so you have to call this in Winmain or main and
-	// not use the class in your constructors
-	void Init(void);
-
-	// Call this or use the #define getTime (below) to get the current time
-	inline unsigned long Time(void)
-	{
-		if (initialized==false) Init();
-
-		#ifdef _WIN32
-		LARGE_INTEGER PerfVal;
-		QueryPerformanceCounter(&PerfVal);
-		return (unsigned long)(PerfVal.QuadPart/counts);
-		#else
-		gettimeofday(&tp, 0);
-		// Seconds to ms and microseconds to ms
-		return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
-		#endif
-	}
-
-	~GetTime() {}
-	// static function because only static functions can access static members
-	static inline GetTime* Instance() {return &instance;}
-private:
-	static GetTime instance;
-	GetTime();
-    
-    	#ifdef _WIN32
-	LARGE_INTEGER yo;
-	LONGLONG counts;
-	#else
-	timeval tp, initialTime;
-	#endif
-	bool initialized;
-};
-
-#define getTime GetTime::Instance()->Time
-
 #endif
 

Modified: branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -109,7 +109,7 @@
 	bool tempPath[256]; // Maximum path length is 256
 	unsigned short tempPathLength;
 	HuffmanEncodingTreeNode *currentNode;
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 
 	// Generate the encryption table. From before, we have an array of pointers to all the leaves which contain pointers to their parents.
 	// This can be done more efficiently but this isn't bad and it's way easier to program and debug
@@ -148,7 +148,7 @@
 }
 
 // Pass an array of bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output)
+void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output)
 {
 	if (sizeInBytes<=0)
 		return;
@@ -179,7 +179,7 @@
 	}
 }
 
-int HuffmanEncodingTree::DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
+int HuffmanEncodingTree::DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
@@ -210,14 +210,14 @@
 }
 
 // Pass an array of encoded bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, BitStream* output)
+void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
 	if (sizeInBits<=0)
 		return;
 
-	BitStream bitStream(BITS_TO_BYTES(sizeInBits));
+	RakNet::BitStream bitStream(BITS_TO_BYTES(sizeInBits));
 	bitStream.SetData(input, sizeInBits); // Put the data in the BitStream class to make it easier to use
 
 	currentNode=root;

Modified: branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/HuffmanEncodingTree.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -11,8 +11,8 @@
 #define __HUFFMAN_ENCODING_TREE
 
 #include "HuffmanEncodingTreeNode.h"
+#include "BitStream.h"
 
-class BitStream;
 #include "LinkedList.h"
 
 // This generates special cases of the huffman encoding tree using 8 bit keys with the additional condition that unused combinations of 8 bits are treated as a frequency of 1
@@ -23,12 +23,12 @@
 	~HuffmanEncodingTree();
 
 	// Pass an array of bytes to array and a preallocated BitStream to receive the output
-	void EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output);
+	void EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output);
 
 	// Two versions that perform the same operation.
 	// The second version also the number of bytes in the stream, which may be greater than the max chars to write
-	int DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
-	void DecodeArray(unsigned char *input, int sizeInBits, BitStream* output);
+	int DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
+	void DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output);
 
 	// Given a frequency table of 256 elements, all with a frequency of 1 or more, generate the tree
 	void GenerateFromFrequencyTable(unsigned long frequencyTable[256]);

Modified: branches/mp-branch-2/source/libraries/raknet/InternalPacket.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/InternalPacket.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/InternalPacket.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -20,11 +20,10 @@
 {
 	bool isAcknowledgement; // True if this is an acknowledgement packet
 	PacketNumberType packetNumber; // The number of this packet, used as an identifier
-	char sha1Code[SHA1_LENGTH]; // The sha1Code, used to verify packet data integrity
 	PacketPriority priority; // The priority level of this packet
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 	unsigned long splitPacketId; // The ID of the split packet, if we have split packets
 	unsigned long splitPacketIndex; // If this is a split packet, the index into the array of split packets
 	unsigned long splitPacketCount; // The size of the array of split packets

Modified: branches/mp-branch-2/source/libraries/raknet/InternalPacketPool.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/InternalPacketPool.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/InternalPacketPool.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -15,6 +15,9 @@
 #ifdef _DEBUG
 	packetsReleased=0;
 #endif
+
+	// Speed things up by not reallocating at runtime when a mutex is locked.
+	pool.clearAndForceAllocation(1024);
 }
 
 InternalPacketPool::~InternalPacketPool()
@@ -49,6 +52,7 @@
 	poolMutex.Lock();
 	if (pool.size())
 		p=pool.pop();
+
 	poolMutex.Unlock();
 	if (p)
 		return p;

Modified: branches/mp-branch-2/source/libraries/raknet/LinkedList.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/LinkedList.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/LinkedList.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -95,6 +95,7 @@
 	B++;
 	B.peek();  // Returns 30
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
 
 */
 
@@ -176,15 +177,15 @@
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::beginning(void)
 {
-	if (root)
-		position=root;
+	if (this->root)
+		this->position=this->root;
 }
 
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::end(void)
 {
-	if (root)
-		position=root->previous;
+	if (this->root)
+		this->position=this->root->previous;
 }
 
 template <class LinkedListType>
@@ -195,71 +196,71 @@
 	if ((&original_copy) != this)
 	{
 	
-	clear();
+	this->clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this->root= new typename LinkedList::node;
 		// root->item = new LinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this->root = new typename LinkedList::node;
 		// root->item = new LinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this->position = new typename LinkedList::node;
 			// position->item = new LinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -270,21 +271,21 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>::CircularLinkedList()
 {
-	root=0;
-	position=0;
-	list_size=0L;
+	this->root=0;
+	this->position=0;
+	this->list_size=0L;
 }
 
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>::~CircularLinkedList()
 {
-	clear();
+	this->clear();
 }
 
 template <class LinkedListType>
 LinkedList<LinkedListType>::~LinkedList()
 {
-	clear();
+	this->clear();
 }
 
 template <class LinkedListType>
@@ -294,64 +295,64 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this->root= new typename LinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item) = *((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this->root = new typename LinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this->position = new typename LinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -362,66 +363,66 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item) = *((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this->root = new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this->position = new typename CircularLinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
+			this->position->item = original_copy_pointer->item;
 			if (original_copy_pointer == original_copy.position) save_position=position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -433,68 +434,68 @@
 	if ((&original_copy) != this)
 	{
 	
-	clear();
+	this->clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this->root = new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this->position = new typename CircularLinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -508,28 +509,28 @@
 
 	if (list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
 		//*(root->item)=input;
-		root->item = input;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->item = input;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this->position= new typename CircularLinkedList::node;
 		// position->item = new CircularLinkedListType;
-		root->next=position;
-		root->previous=position;
-		position->previous=root;
-		position->next=root;
+		this->root->next=this->position;
+		this->root->previous=this->position;
+		this->position->previous=this->root;
+		this->position->next=this->root;
 		// *(position->item)=input;
-		position->item = input;
-		root=position;  // Since we're inserting into a 1 element list the old root is now the second item
-		list_size=2L;
+		this->position->item = input;
+		this->root=this->position;  // Since we're inserting into a 1 element list the old root is now the second item
+		this->list_size=2L;
 	}
 
 	else
@@ -553,22 +554,22 @@
 		new_node->item = input;
 
 		// Point next of A to B
-		(position->previous)->next=new_node;
+		(this->position->previous)->next=new_node;
 
 		// Point last of B to A
-		new_node->previous=position->previous;
+		new_node->previous=this->position->previous;
 
 		// Point last of C to B
-		position->previous=new_node;
+		this->position->previous=new_node;
 
 		// Point next of B to C
-		new_node->next=position;
+		new_node->next=this->position;
 
 		 // Since the root pointer is bound to a node rather than an index this moves it back if you insert an element at the root
-		if (position==root) {root=new_node; position=root;}
+		if (this->position==this->root) {this->root=new_node; this->position=this->root;}
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this->list_size++;
 	}
 }
 
@@ -577,34 +578,34 @@
 {
 	node *new_node;
 
-	if (list_size==0L)
+	if (this->list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
 		// *(root->item)=input;
-		root->item=input;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->item=input;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// return *(position->item);
-		return position->item;
+		return this->position->item;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this->position= new typename CircularLinkedList::node;
 		// position->item = new CircularLinkedListType;
-		root->next=position;
-		root->previous=position;
-		position->previous=root;
-		position->next=root;
+		this->root->next=this->position;
+		this->root->previous=this->position;
+		this->position->previous=this->root;
+		this->position->next=this->root;
 		// *(position->item)=input;
-		position->item = input;
-		list_size=2L;
-		position=root;  // Don't move the position from the root
+		this->position->item = input;
+		this->list_size=2L;
+		this->position=this->root;  // Don't move the position from the root
 		// return *(position->item);
-		return position->item;
+		return this->position->item;
 	}
 
 	else
@@ -628,19 +629,19 @@
 		new_node->item=input;
 
 		// Point last of B to A
-		new_node->previous=position;
+		new_node->previous=this->position;
 
 		// Point next of B to C
-		new_node->next=(position->next);
+		new_node->next=(this->position->next);
 
 		// Point last of C to B
-		(position->next)->previous=new_node;
+		(this->position->next)->previous=new_node;
 
 		// Point next of A to B
-		(position->next)=new_node;
+		(this->position->next)=new_node;
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this->list_size++;
 		
 		// return *(new_node->item);
 		return new_node->item;
@@ -650,9 +651,9 @@
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::replace(const CircularLinkedListType& input)
 {
-	if (list_size>0L)
+	if (this->list_size>0L)
 		// *(position->item)=input;
-		position->item=input;
+		this->position->item=input;
 }
 
 template <class CircularLinkedListType>
@@ -660,26 +661,26 @@
 {
 	node* new_position;
 
-	if (list_size==0L) return;
+	if (this->list_size==0L) return;
 
-	else if (list_size==1L)
+	else if (this->list_size==1L)
 	{
 		// delete root->item;
-		delete root;
-		root=position=0;
-		list_size=0L;
+		delete this->root;
+		this->root=this->position=0;
+		this->list_size=0L;
 	}
 
 	else
 	{
-		(position->previous)->next = position->next;
-		(position->next)->previous = position->previous;
-		new_position=position->next;
-		if (position==root) root=new_position;
+		(this->position->previous)->next = this->position->next;
+		(this->position->next)->previous = this->position->previous;
+		new_position=this->position->next;
+		if (this->position==this->root) this->root=new_position;
 		// delete position->item;
-		delete position;
-		position=new_position;
-		list_size--;
+		delete this->position;
+		this->position=new_position;
+		this->list_size--;
 	}
 }
 
@@ -688,10 +689,10 @@
 {
 	node *return_value,*old_position;
 	
-	old_position=position;
+	old_position=this->position;
  
 	return_value=find_pointer(input);
-	position=old_position;
+	this->position=old_position;
 
 	if (return_value!=0) return true;
 	else return false;	// Can't find the item don't do anything
@@ -704,7 +705,7 @@
  
 	return_value=find_pointer(input);
 
-	if (return_value!=0) {position=return_value; return true;}
+	if (return_value!=0) {this->position=return_value; return true;}
 	else return false;	// Can't find the item don't do anything
 }
 
@@ -713,8 +714,8 @@
 {
 	node* current;
 
-	if (list_size==0L) return 0;
-	current=root;
+	if (this->list_size==0L) return 0;
+	current=this->root;
 
 	// Search for the item starting from the root node and incrementing the pointer after every check
 	// If you wind up pointing at the root again you looped around the list so didn't find the item, in which case return 0
@@ -723,7 +724,7 @@
 		// if (*(current->item) == input) return current;
 		if (current->item == input) return current;
 		current=current->next;
-	} while (current != root);
+	} while (current != this->root);
 
 	return 0;
 	
@@ -732,14 +733,14 @@
 template <class CircularLinkedListType>
 inline unsigned long CircularLinkedList<CircularLinkedListType>::size(void)
 {
-	return list_size;
+	return this->list_size;
 }
 
 template <class CircularLinkedListType>
 inline CircularLinkedListType& CircularLinkedList<CircularLinkedListType>::peek(void)
 {
 	// return *(position->item);
-	return position->item;
+	return this->position->item;
 }
 
 template <class CircularLinkedListType>
@@ -755,7 +756,7 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator++()
 {
-	if (list_size!=0L) position=position->next;
+	if (this->list_size!=0L) position=position->next;
 	return *this;
 }
 
@@ -774,14 +775,14 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator++(int)
 {
-	return operator++();
+	return this->operator++();
 }
 
 // Prefix
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator--()
 {
-	if (list_size!=0L) position=position->previous;
+	if (this->list_size!=0L) this->position=this->position->previous;
 	return *this;
 }
 
@@ -800,21 +801,21 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator--(int)
 {
-	return operator--();
+	return this->operator--();
 }
 
 template <class CircularLinkedListType>
 void CircularLinkedList<CircularLinkedListType>::clear(void)
 {
-	if (list_size==0L) return;
-	else if (list_size==1L)// {delete root->item; delete root;}
-		{delete root;}
+	if (this->list_size==0L) return;
+	else if (this->list_size==1L)// {delete root->item; delete root;}
+		{delete this->root;}
 	else
 	{
 		node* current;
 		node* temp;
 
-		current=root;
+		current=this->root;
 
 		do
 		{
@@ -822,12 +823,12 @@
 			current=current->next;
 		//	delete temp->item;
 			delete temp;
-		} while (current!=root);
+		} while (current!=this->root);
 	}
 
-	list_size=0L;
-	root=0;
-	position=0;
+	this->list_size=0L;
+	this->root=0;
+	this->position=0;
 }
 
 template <class CircularLinkedListType>
@@ -837,10 +838,10 @@
 	node* ptr;
 
 	if (L.list_size == 0L) return;
-	if (list_size == 0L) *this = L;
+	if (this->list_size == 0L) *this = L;
 
 	ptr = L.root;
-	position=root->previous;
+	this->position=this->root->previous;
 	
 	// Cycle through each element in L and add it to the current list
 	for (counter = 0; counter < L.list_size; counter++)
@@ -851,18 +852,18 @@
 
 		// Update pointers.  Moving ptr keeps the current pointer at the end of the list since the add function does not move the pointer
 		ptr=ptr->next;
-		position=position->next;
+		this->position=this->position->next;
 	}
 }
 
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::sort(void)
 {
-	if (list_size<=1L) return;
+	if (this->list_size<=1L) return;
 
 	// Call equal operator to assign result of mergesort to current object
 	*this = mergesort(*this);
-	position=root;
+	this->position=this->root;
 }
 
 template <class CircularLinkedListType>
@@ -1015,7 +1016,7 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator++()
 {
-	if ((list_size!=0L) && (position->next!=root)) position=position->next;
+	if ((this->list_size!=0L) && (this->position->next!=this->root)) this->position=this->position->next;
 	return *this;
 }
 /*
@@ -1033,14 +1034,14 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator++(int)
 {
-	return operator++();
+	return this->operator++();
 }
 
 // Prefix
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator--()
 {
-	if ((list_size!=0L) && (position!=root)) position=position->previous;
+	if ((this->list_size!=0L) && (this->position!=this->root)) this->position=this->position->previous;
 	return *this;
 }
 /*
@@ -1059,7 +1060,7 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator--(int)
 {
-	return operator--();
+	return this->operator--();
 }
 
 } // End namespace

Modified: branches/mp-branch-2/source/libraries/raknet/Multiplayer.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/Multiplayer.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/Multiplayer.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -33,6 +33,7 @@
 	virtual void ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteExistingConnection(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionRequestAccepted(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
@@ -133,6 +134,9 @@
 		case ID_REMOTE_EXISTING_CONNECTION:
 			ReceiveRemoteExistingConnection(p,interfaceType);
 		break;
+		case ID_REMOTE_STATIC_DATA:
+			ReceiveRemoteStaticData(p,interfaceType);
+		break;
 		case ID_CONNECTION_BANNED:
 			ReceiveConnectionBanned(p, interfaceType);
 		break;
@@ -209,8 +213,8 @@
 void Multiplayer<InterfaceType>::ProcessUnhandledPacket(Packet *p, unsigned char packetIdentifier, InterfaceType *interfaceType)
 {
 	// Remove the annoying warnings
-	packetIdentifier;
-	interfaceType;
+	//packetIdentifier;
+	//interfaceType;
 
 	// This class should have been overrided to handle user defined packets
 #ifdef _DEBUG
@@ -276,6 +280,17 @@
 }
 
 template <class InterfaceType>
+void Multiplayer<InterfaceType>::ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType)
+{
+	// A client got the remote static data for another system
+	//  Client only.
+#ifdef _DEBUG
+	printf("ID_REMOTE_STATIC_DATA from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+template <class InterfaceType>
 void Multiplayer<InterfaceType>::ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType)
 {
 	// We are banned from connecting to the system specified in packet->playerId

Modified: branches/mp-branch-2/source/libraries/raknet/NetworkTypes.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/NetworkTypes.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/NetworkTypes.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -27,4 +27,3 @@
 {
 	return left.binaryAddress<right.binaryAddress || left.port<right.port;
 }
-

Modified: branches/mp-branch-2/source/libraries/raknet/NetworkTypes.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/NetworkTypes.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/NetworkTypes.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -12,6 +12,7 @@
 
 typedef unsigned short ObjectID;
 typedef unsigned char UniqueIDType;
+typedef unsigned short PlayerIndex;
 
 struct PlayerID
 {
@@ -24,6 +25,7 @@
 	friend int operator < (const PlayerID& left, const PlayerID& right);
 };
 
+
 struct RequestedConnectionStruct
 {
 	PlayerID playerId; // Who we wanted to connect to
@@ -35,38 +37,43 @@
 
 struct Packet
 {
+	PlayerIndex playerIndex; // Server only - this is the index into the player array that this playerId maps to
 	PlayerID playerId;
 	unsigned long length;
 	unsigned long bitSize; // Same as length but represents bits.  Length is obsolete and retained for backwards compatibility
-	char* data;
+	unsigned char* data;
 };
 
 #pragma pack(push,1)
-#pragma pack(1)
 struct ConnectionAcceptStruct
 {
 	unsigned char typeId;
 	unsigned short remotePort;
 	PlayerID externalID; // We tell the remote system its own IP / port this way
+	PlayerIndex playerIndex; // For internal use
 };
+#pragma pack(pop)
 
-#pragma pack(1)
+#pragma pack(push,1)
 struct PingStruct
 {
 	unsigned char typeId; // ID_PING or ID_PONG
 	unsigned long sendPingTime;
 	unsigned long sendPongTime;
 };
+#pragma pack(pop)
 
-#pragma pack(1)
+#pragma pack(push,1)
 struct UnconnectedPingStruct
 {
 	unsigned char typeId; // ID_PING or ID_PONG
 	unsigned long sendPingTime;
 };
+#pragma pack(pop)
 
 // Timestamp automatically used for this type of packet
-#pragma pack(1)
+
+#pragma pack(push,1)
 struct SetRandomNumberSeedStruct
 {
 	unsigned char ts; // ID_TIMESTAMP
@@ -75,16 +82,18 @@
 	unsigned long seed;
 	unsigned long nextSeed;
 };
+#pragma pack(pop)
 
-#pragma pack(1)
+#pragma pack(push,1)
 struct NewIncomingConnectionStruct
 {
 	unsigned char typeId; // ID_NEW_INCOMING_CONNECTION
 	PlayerID externalID; // We tell the remote system its own IP / port this way
 };
-
 #pragma pack(pop)
 
+
+const PlayerIndex UNASSIGNED_PLAYER_INDEX=65535;
 const PlayerID UNASSIGNED_PLAYER_ID={0xFFFFFFFF, 0xFFFF};
 const ObjectID UNASSIGNED_OBJECT_ID=65535;
 const int PING_TIMES_ARRAY_SIZE=5;

Modified: branches/mp-branch-2/source/libraries/raknet/PacketEnumerations.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/PacketEnumerations.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/PacketEnumerations.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -18,12 +18,12 @@
 	// Ignore these:
 	ID_PING, // Ping (internal use only)
 	ID_PONG, // Pong.  Returned if we ping a system we are not connected so
+	ID_PING_OPEN_CONNECTIONS, // Only reply to the unconnected ping if we have open connections
 	ID_REQUEST_STATIC_DATA, // Someone asked for our static data (internal use only)
 	ID_CONNECTION_REQUEST, // Asking for a new connection (internal use only)
 	ID_SECURED_CONNECTION_RESPONSE, // Connecting to a secured server/peer
 	ID_SECURED_CONNECTION_CONFIRMATION, // Connecting to a secured server/peer
 	ID_RPC, // Remote procedure call (internal use only)
-	ID_RECEIVED_RELAYED_STATIC_DATA, // Server / Client only - Sending the static data for another system (internal use only)
 	ID_BROADCAST_PINGS, // Server / Client only - The server is broadcasting the pings of all players in the game (internal use only)
 	ID_SET_RANDOM_NUMBER_SEED, // Server / Client only - The server is broadcasting a random number seed (internal use only)
 	ID_RPC_WITH_TIMESTAMP, // Same as RPC, but treat the first 4 bytes as a timestamp
@@ -33,13 +33,14 @@
 	ID_REMOTE_CONNECTION_LOST, // [CLIENT] In a client/server enviroment, a client other than ourselves has been forcefully dropped.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_NEW_INCOMING_CONNECTION, // [CLIENT] In a client/server enviroment, a client other than ourselves has connected.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_EXISTING_CONNECTION, // [CLIENT] On our initial connection to the server, we are told of every other client in the game.  Packet::playerID is modified to reflect the playerID of this client.
+	ID_REMOTE_STATIC_DATA, // [CLIENT] - Got the data for another client
 	ID_CONNECTION_BANNED, // [PEER|CLIENT] We are banned from the system we attempted to connect to.
 	ID_CONNECTION_REQUEST_ACCEPTED, // [CLIENT] In a client/server enviroment, our connection request to the server has been accepted.
 	ID_NEW_INCOMING_CONNECTION, // [PEER|SERVER] A remote system has successfully connected.
 	ID_NO_FREE_INCOMING_CONNECTIONS, // [PEER|CLIENT] The system we attempted to connect to is not accepting new connections.
 	ID_DISCONNECTION_NOTIFICATION, // [PEER|SERVER|CLIENT] The system specified in Packet::playerID has disconnected from us.  For the client, this would mean the server has shutdown.
 	ID_CONNECTION_LOST, // [PEER|SERVER|CLIENT] Reliable packets cannot be delivered to the system specifed in Packet::playerID.  The connection to that system has been closed.
-	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient.
+	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient. Requires that you call StartOccasionalPing.
 	ID_RECEIVED_STATIC_DATA, // [PEER|SERVER|CLIENT] We got a bitstream containing static data.  You can now read this data.  This packet is transmitted automatically on connections, and can also be manually sent.
 	ID_INVALID_PASSWORD, // [PEER|CLIENT] The remote system is using a password and has refused our connection because we did not set the correct password.
 	ID_MODIFIED_PACKET, // [PEER|SERVER|CLIENT] A packet has been tampered with in transit.  The sender is contained in Packet::playerID.
@@ -57,7 +58,6 @@
 	ID_MASTER_SERVER_DELIST_SERVER, // [MASTERSERVER] Remove a game server from the master server.
 	ID_MASTER_SERVER_UPDATE_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or update the information for a server.
 	ID_MASTER_SERVER_SET_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or set the information for a server.
-	ID_RESERVED2, // For future versions
 	ID_RESERVED3, // For future versions
 	ID_RESERVED4, // For future versions
 	ID_RESERVED5, // For future versions
@@ -74,6 +74,7 @@
 	// In the unlikely event that you need more than 256 types, including the built-in types, then you'll need
 	// to request a special edition with larger identifiers, or change it yourself
 	//
+    ID_PRESENCE_CREATION,
 
 
 

Modified: branches/mp-branch-2/source/libraries/raknet/PacketPriority.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/PacketPriority.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/PacketPriority.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -12,6 +12,7 @@
 
 enum PacketPriority
 {
+	SYSTEM_PRIORITY, // System priority is for system related messaging.  Don't use it.
 	HIGH_PRIORITY,
 	MEDIUM_PRIORITY,
 	LOW_PRIORITY,

Modified: branches/mp-branch-2/source/libraries/raknet/Queue.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/Queue.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/Queue.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -29,6 +29,8 @@
 This function doubles the amount of memory allocated when the queue is filled
 This is better than the linked list version for a queue that doesn't go from one extreme to the other with size changes.
 
+9/04 Giblet - commented out body of compress() function, as it is invalid and breaks newer compilers
+
 */
 
 #ifndef __QUEUE_H
@@ -255,7 +257,7 @@
 template <class queue_type>
 void Queue<queue_type>::compress (void)
 {
-		queue_type* new_array;
+		/*queue_type* new_array;
 
 		if (allocation_size==0) return;
 
@@ -273,7 +275,7 @@
 		
 		// Delete the old array and move the pointer to the new array
 		delete []array;
-		array=new_array;
+		array=new_array;*/
 }
 
 template <class queue_type>

Modified: branches/mp-branch-2/source/libraries/raknet/RakClient.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakClient.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakClient.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -28,13 +28,12 @@
 {
 }
 
-bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)
+bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)
 {
-	if (highPriorityThreads)
-		RakPeer::Initialize(1, clientPort,1);
-	else
-		RakPeer::Initialize(1, clientPort,0);
+	RakPeer::Disconnect(100L);
 
+	RakPeer::Initialize(1, clientPort,threadSleepTimer);
+
 	if (host[0] < '0' || host[0] > '2')
 	{
 		host = (char*) SocketLayer::Instance()->DomainNameToIP(host);
@@ -52,20 +51,27 @@
 	return RakPeer::Connect(host, serverPort, password, (int)strlen(password));
 }
 
-void RakClient::Disconnect(void)
+void RakClient::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-void RakClient::InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)
+void RakClient::InitializeSecurity(char *RSAe, char *RSAn)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, 0, RSAe, RSAn);
+	RakPeer::InitializeSecurity(RSAe, RSAn,0,0);
 }
 
 void RakClient::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakClient::HasPassword(void) const
@@ -73,18 +79,18 @@
 	return password[0]!=0;
 }
 
-bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
-bool RakClient::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
 Packet* RakClient::Receive(void)
@@ -94,10 +100,16 @@
 	// Intercept specific client / server feature packets
 	if (packet)
 	{
-		BitStream bitStream(packet->data, packet->length, false);
+		RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 		bitStream.IgnoreBits(8); // Ignore identifier
 		int i;
-		if (
+		if (packet->data[0]==ID_CONNECTION_REQUEST_ACCEPTED)
+		{
+			ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) packet->data;
+			localPlayerIndex = cas->playerIndex;
+			packet->playerIndex=cas->playerIndex;
+		}
+		else if (
 			packet->data[0]==ID_REMOTE_NEW_INCOMING_CONNECTION ||
 			packet->data[0]==ID_REMOTE_EXISTING_CONNECTION ||
 			packet->data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
@@ -105,29 +117,36 @@
 		{
 			bitStream.Read(packet->playerId.binaryAddress);
 			bitStream.Read(packet->playerId.port);
+			if (bitStream.Read((unsigned short&)packet->playerIndex)==false)
+			{
+				DeallocatePacket(packet);
+				return 0;
+			}
 
-			i = GetOtherClientIndexByPlayerID(packet->playerId);
-			if (i>=0)
-				otherClients[i].isActive=false;
+
+			if (packet->data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
+				packet->data[0]==ID_REMOTE_CONNECTION_LOST)
+			{
+				i = GetOtherClientIndexByPlayerID(packet->playerId);
+				if (i>=0)
+					otherClients[i].isActive=false;
+			}			
 		}
-		else if (packet->data[0]==ID_RECEIVED_RELAYED_STATIC_DATA)
+		else if (packet->data[0]==ID_REMOTE_STATIC_DATA)
 		{
-			PlayerID staticDataOriginator;
-			bitStream.Read(staticDataOriginator.binaryAddress);
-			bitStream.Read(staticDataOriginator.port);
+			bitStream.Read(packet->playerId.binaryAddress);
+			bitStream.Read(packet->playerId.port);
 
-			i = GetOtherClientIndexByPlayerID(staticDataOriginator);
+			i = GetOtherClientIndexByPlayerID(packet->playerId);
 			if (i < 0)
 				i=GetFreeOtherClientIndex();
 			if (i>=0)
 			{
-				otherClients[i].playerId=staticDataOriginator;
+				otherClients[i].playerId=packet->playerId;
 				otherClients[i].isActive=true;
 				otherClients[i].staticData.Reset();
 				// The static data is what is left over in the stream
 				otherClients[i].staticData.Write((char*)bitStream.GetData()+BITS_TO_BYTES(bitStream.GetReadOffset()), bitStream.GetNumberOfBytesUsed()-BITS_TO_BYTES(bitStream.GetReadOffset()));
-				DeallocatePacket(packet);
-				return 0;
 			}
 		}
 		else if (packet->data[0]==ID_BROADCAST_PINGS)
@@ -189,10 +208,10 @@
 	RakPeer::Ping(remoteSystemList[0].playerId);
 }
 
-void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort)
+void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)
 {
 	RakPeer::Initialize(1, clientPort,0);
-	RakPeer::Ping(host, serverPort);
+	RakPeer::Ping(host, serverPort, onlyReplyOnAcceptingConnections);
 }
 
 int RakClient::GetAveragePing(void)
@@ -245,7 +264,7 @@
 
 unsigned long RakClient::GetSynchronizedRandomInteger(void) const
 {
-	if (getTime() > nextSeedUpdate)
+	if (RakNetGetTime() > nextSeedUpdate)
 		return nextSeed;
 	else
 		return seed;
@@ -287,18 +306,18 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakClient::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
-bool RakClient::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
 /*
@@ -329,7 +348,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakClient::GetStaticServerData(void)
+RakNet::BitStream * RakClient::GetStaticServerData(void)
 {
 	if (remoteSystemList==0)
 		return 0;
@@ -343,7 +362,7 @@
 	RakPeer::SetRemoteStaticData(remoteSystemList[0].playerId, data, length);
 }
 
-BitStream* RakClient::GetStaticClientData(PlayerID playerId)
+RakNet::BitStream * RakClient::GetStaticClientData(PlayerID playerId)
 {
 	int i;
 
@@ -433,71 +452,11 @@
 	return RakPeer::GetMTUSize();
 }
 
-double RakClient::GetPacketlossPercentile(void)
+RakNetStatisticsStruct* const RakClient::GetStatistics(void)
 {
-	return RakPeer::GetPacketlossPercentile();
+	return RakPeer::GetStatistics(remoteSystemList[0].playerId);
 }
 
-unsigned long RakClient::GetTransmittedPacketCount(void)
-{
-	return RakPeer::GetTransmittedPacketCount();
-}
-
-unsigned long RakClient::GetTransmittedFrameCount(void)
-{
-	return RakPeer::GetTransmittedFrameCount();
-}
-
-unsigned long RakClient::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakClient::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakClient::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakClient::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakClient::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakClient::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakClient::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakClient::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakClient::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakClient::GetConnectionTime(void)
-{
-	return RakPeer::GetConnectionTime(RakPeer::GetInternalID());
-}
-
 int RakClient::GetOtherClientIndexByPlayerID(PlayerID playerId)
 {
 	unsigned i;
@@ -520,3 +479,7 @@
 	return -1;
 }
 
+PlayerIndex RakClient::GetPlayerIndex(void)
+{
+	return localPlayerIndex;
+}

Modified: branches/mp-branch-2/source/libraries/raknet/RakClient.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakClient.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakClient.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -1,4 +1,4 @@
-// This file is part of RakNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
+// This file is part of RarkNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
 
 // Usage of Raknet is subject to the appropriate licence agreement.
 // "Shareware" Licensees with Rakkarsoft LLC are subject to the shareware license found at http://www.rakkarsoft.com/shareWareLicense.html which you agreed to upon purchase of a "Shareware license"
@@ -28,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads);
+	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer);
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	void Disconnect(void);
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -43,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn);
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	void InitializeSecurity(char *RSAe, char *RSAn);
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -57,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -84,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort);
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on "255.255.255.255"
+	// or you will get replies from clients as well.
+	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections);
 
 	// Returns the average of all ping times read
 	int GetAveragePing(void);
@@ -183,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -218,12 +220,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +237,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// Send the static server data to the server
@@ -285,21 +287,17 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost
-	unsigned long GetReceivedPacketCount(void); // How many packets were received
-	unsigned long GetBytesSent(void); // How many bytes have been sent.
-	unsigned long GetBytesReceived(void); // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(void); // Returns the time elapsed since you connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(void);
 
+	// For internal use
+	PlayerIndex GetPlayerIndex(void);
+
 	private:
 
 	int GetOtherClientIndexByPlayerID(PlayerID playerId);
@@ -310,11 +308,12 @@
 	{
 		PlayerID playerId;
 		short ping;
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		bool isActive;
 	} otherClients[32];
 	// Synchronized random integer
 	unsigned long seed, nextSeed, nextSeedUpdate;
+	PlayerIndex localPlayerIndex;
 	PlayerID externalPlayerID; // This is your external ID (and also IP) (returned from the server)
 };
 

Modified: branches/mp-branch-2/source/libraries/raknet/RakClientInterface.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakClientInterface.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakClientInterface.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -13,7 +13,8 @@
 #include "NetworkTypes.h"
 #include "PacketPriority.h"
 #include "RakPeerInterface.h"
-class BitStream;
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakClientInterface
 {
@@ -27,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)=0;
+	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)=0;
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	virtual void Disconnect(void)=0;
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -42,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)=0;
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	virtual void InitializeSecurity(char *RSAe, char *RSAn)=0;
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -56,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -83,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort)=0;
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on "255.255.255.255"
+	// or you will get replies from clients as well.
+	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Returns the average of all ping times read
 	virtual int GetAveragePing(void)=0;
@@ -182,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -218,12 +221,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +238,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// Send the static server data to the server
@@ -285,20 +288,16 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(void)=0; // Returns the time elapsed since you connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(void)=0;
+
+	// For internal use
+	virtual PlayerIndex GetPlayerIndex(void)=0;
 };
 
 #endif

Modified: branches/mp-branch-2/source/libraries/raknet/RakNetworkFactory.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakNetworkFactory.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakNetworkFactory.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -14,16 +14,16 @@
 class RakPeerInterface;
 
 #ifdef _WIN32
-#define EXPORT __declspec(dllexport)
+#define RAK_DLL_EXPORT __declspec(dllexport)
 #else
 // Unix needs no export, but for name mangling, keep the function name
 // clean. If you omit the 'extern "C"', the .so names will be
 // compiler dependent.
-#define EXPORT extern "C"
+#define RAK_DLL_EXPORT extern "C"
 #endif
 
 #if defined(DLL_EXPORTS) || defined(_USRDLL)
-class EXPORT RakNetworkFactory
+class RAK_DLL_EXPORT RakNetworkFactory
 #else
 //class __declspec( dllimport ) RakNetworkFactory
 class RakNetworkFactory

Modified: branches/mp-branch-2/source/libraries/raknet/RakPeer.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakPeer.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakPeer.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -27,20 +27,33 @@
 #include "PacketEnumerations.h"
 #include "HuffmanEncodingTree.h"
 #include "PacketPool.h"
-#include "RSA.h"
 #include "Rand.h"
 
+// alloca
+#ifdef _WIN32
+#include <malloc.h>
+#else
+#include <stdlib.h>
+#endif
+
 static const unsigned long SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION=5000;
 
+// UPDATE_THREAD_POLL_TIME is how often the update thread will poll to see
+// if receive wasn't called within UPDATE_THREAD_UPDATE_TIME.  If it wasn't called within that time,
+// the updating thread will activate and take over network communication until Receive is called again.
+//static const unsigned long UPDATE_THREAD_UPDATE_TIME=30;
+//static const unsigned long UPDATE_THREAD_POLL_TIME=30;
 
+//#define _TEST_AES
+
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Constructor
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 RakPeer::RakPeer()
 {
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 	memset(frequencyTable, 0, sizeof(unsigned long) * 256);
-	rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+	rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 	outputTree=inputTree=0;
 	connectionSocket=INVALID_SOCKET;
 	MTUSize=DEFAULT_MTU_SIZE;
@@ -51,8 +64,8 @@
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 	endThreads=true;
 	isMainLoopThreadActive=false;
-	isRecvfromThreadActive=false;
-	occasionalPing=true;
+//	isRecvfromThreadActive=false;
+	occasionalPing=false;
 	connectionSocket=INVALID_SOCKET;
 	myPlayerId=UNASSIGNED_PLAYER_ID;
 }
@@ -64,7 +77,7 @@
 {
 	unsigned i;
 
-	Disconnect();
+	Disconnect(0L);
 
 	// Clear out the lists:
 	for (i=0; i < requestedConnectionsList.size(); i++)
@@ -86,12 +99,12 @@
 // - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 // - A hybrid would set it to the sum of both types of connections
 // localPort: The port to listen for connections on.
-// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 //
 // Returns:
 // False on failure (can't create socket or thread), true on success.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)
+bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)
 {
 	unsigned i;
 
@@ -108,13 +121,15 @@
 
 	if (maximumNumberOfPeers==0)
 	{
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
 		remoteSystemList = new RemoteSystemStruct[MaximumNumberOfPeers];
 		for (i=0; i < MaximumNumberOfPeers; i++)
 		{
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID;
 		}
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
 
 		// Don't allow more incoming connections than we have peers.
 		if (maximumIncomingConnections>MaximumNumberOfPeers)
@@ -123,108 +138,93 @@
 		maximumNumberOfPeers=MaximumNumberOfPeers;
 	}
 
+	// For histogram statistics
+//	nextReadBytesTime=0;
+//	lastSentBytes=lastReceivedBytes=0;
+
 	if (endThreads)
 	{
+		lastUserUpdateCycle=0;
+
 		// Reset the frequency table that we use to save outgoing data
 		memset(frequencyTable, 0, sizeof(unsigned long) * 256);
 
 		// Reset the statistical data
-		rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+		rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 
+		updateCycleIsRunning=false;
 		endThreads=false;
 		// Create the threads
-		threadPriority=_threadPriority;
+		threadSleepTimer=_threadSleepTimer;
 
 		char ipList[10][16];
 		SocketLayer::Instance()->GetMyIP(ipList);
 		myPlayerId.port=localPort;
 		myPlayerId.binaryAddress=inet_addr(ipList[0]);
 
+		if (threadSleepTimer >=0)
+		{
 #ifdef _WIN32
-		if (isMainLoopThreadActive==false)
-		{
-			unsigned ProcessPacketsThreadID=0;
-			processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID);
-			if (threadPriority==2 && processPacketsThreadHandle)
-				SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
-			else if (processPacketsThreadHandle==0)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
-			}
+				unsigned ProcessPacketsThreadID=0;
+				processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID);
 
-			CloseHandle(processPacketsThreadHandle);
-			processPacketsThreadHandle=0;
+				if (processPacketsThreadHandle==0)
+				{
+					Disconnect(0L);
+					return false;
+				}
 
-		}
+				//	SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
 
-		if (isRecvfromThreadActive==false)
-		{
-			unsigned recvfromThreadID=0;
-			recvfromThreadHandle=(HANDLE)_beginthreadex(NULL, 0, RecvFromNetworkLoop, this, 0, &recvfromThreadID);
+				CloseHandle(processPacketsThreadHandle);
+				processPacketsThreadHandle=0;
 
-#ifndef __USE_IO_COMPLETION_PORTS
-			if (threadPriority==2 && recvfromThreadHandle)
-				SetThreadPriority(recvfromThreadHandle, THREAD_PRIORITY_HIGHEST);
-#endif
-
-			if (recvfromThreadHandle==0)
-			{
-				Disconnect();
-				return false;
 			}
 
-			CloseHandle(recvfromThreadHandle);
-			recvfromThreadHandle=0;
-		}
-
 #else
-		pthread_attr_t attr;
+			pthread_attr_t attr;
 
-		pthread_attr_init( &attr );
-		pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
-		if (threadPriority==2)
-		{
-			sched_param sp;
-			sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
-			pthread_attr_setschedparam(&attr, &sp);
-		}
+			pthread_attr_init( &attr );
+			pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
 
-		int error;
+			//		sched_param sp;
+			//		sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
+			//		pthread_attr_setschedparam(&attr, &sp);
 
-		if (isMainLoopThreadActive==false)
-		{
-			error = pthread_create( &processPacketsThreadHandle, &attr, &UpdateNetworkLoop, this );
-			if (error)
-			{
-				Disconnect();
-				return false;
-			}
-		}
+			int error;
 
-		if (	isRecvfromThreadActive==false)
-		{
-			error = pthread_create( &recvfromThreadHandle, &attr, &RecvFromNetworkLoop, this );
-			if (error)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
+				error = pthread_create( &processPacketsThreadHandle, &attr, &UpdateNetworkLoop, this );
+				if (error)
+				{
+					Disconnect(0L);
+					return false;
+				}
 			}
-		}
-		pthread_attr_destroy( &attr );
 
-		processPacketsThreadHandle=0;
+			processPacketsThreadHandle=0;
 #endif
 
-		// Wait for the threads to activate.  When they are active they will set these variables to true
-		while (isRecvfromThreadActive==false || isMainLoopThreadActive==false)
+
+			// Wait for the threads to activate.  When they are active they will set these variables to true
+			while (/*isRecvfromThreadActive==false || */isMainLoopThreadActive==false)
 #ifdef _WIN32
-			Sleep(10);
+				Sleep(10);
 #else
-			usleep(10 * 1000);
+				usleep(10 * 1000);
 #endif
 
-	}
+		}
+		else
+		{
+#ifdef __USE_IO_COMPLETION_PORTS
+			AsynchronousFileIO::Instance()->IncreaseUserCount();
+#endif
+		}
+	}		
 
 	return true;
 }
@@ -240,57 +240,61 @@
 // If you accept connections, you must call this or else secure connections will not be enabled
 // for incoming connections.
 // If you are connecting to another system, you can call this with values for the
-// (e and n) public keys before connecting to prevent MitM
+// (e and p,q) public keys before connecting to prevent MitM
 //
 // Parameters:
-// numberOfBytes:  How many bytes to use for each of the RSA keys.
-// RSAd - A pointer to the private key of length numberOfBytes.
-// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
+// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample
+// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+// If the private keys are 0, then a new key will be generated when this function is called
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakPeer::InitializeSecurity(char *RSAe, char *RSAn, char *RSAp, char *RSAq)
 {
 	if (endThreads==false)
 		return;
 
-	// You can specify e and n, d and e and n, or none.  Any other combination is invalid
-	if (!((RSAe && RSAn) || (RSAd==0 && RSAe==0 && RSAn==0)))
+	// Setting the client key is e,n,
+	// Setting the server key is p,q
+	// These are mutually exclusive
+	if ((RSAe && RSAn && (RSAp || RSAq)) ||
+		(RSAp && RSAq && (RSAe || RSAn)) ||
+		(RSAe && RSAn==0) ||
+		(RSAn && RSAe==0) ||
+		(RSAp && RSAq==0) ||
+		(RSAq && RSAp==0))
 	{
+		// Invalid parameters
 		assert(0);
-		return;
 	}
 
-	// For whatever reason the encoder / decoder fails randomly with data length 20 and bytes less than 32.
-	assert(numberOfBytes >= 32);
-	if (numberOfBytes < 32)
-	{
-		numberOfBytes=32;
-	}
+	seedMT(RakNetGetTime());
 
-	seedMT(getTime());
+	GenerateSYNCookieRandomNumber();
 
-	securedConnectionByteSize=numberOfBytes;
+	usingSecurity=true;
 
-	// Generate RSA keys
-	d.Init(numberOfBytes);
-	e.Init(numberOfBytes);
-	n.Init(numberOfBytes);
-
-	GenerateSYNCookieRandomNumber();
-
-	if (RSAd==0 && RSAe==0 && RSAn==0)
+	if (RSAe==0 && RSAn==0 &&RSAp==0 && RSAq==0)
 	{
 		keysLocallyGenerated=true;
-		GenerateKeys(d,e,n);
+		rsacrypt.generateKeys();
 	}
 	else
 	{
+		if (RSAe && RSAn)
+		{
+			// Save public keys
+			memcpy((char*)&publicKeyE, RSAe, sizeof(publicKeyE));
+			memcpy(publicKeyN, RSAn, sizeof(publicKeyN));
+		}
+		else if (RSAp && RSAq)
+		{
+			BIGHALFSIZE(RSA_BIT_SIZE, p);
+			BIGHALFSIZE(RSA_BIT_SIZE, q);
+			memcpy(p, RSAp, sizeof(p));
+			memcpy(q, RSAq, sizeof(q));
+			// Save private keys
+			rsacrypt.setPrivateKey(p, q);
+		}
 		keysLocallyGenerated=false;
-		if (RSAd)
-			memcpy(d.value, RSAd, numberOfBytes);
-		memcpy(e.value, RSAe, numberOfBytes);
-		memcpy(n.value, RSAn, numberOfBytes);
 	}
 }
 
@@ -304,7 +308,7 @@
 	if (endThreads==false)
 		return;
 
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -343,18 +347,20 @@
 void RakPeer::SetIncomingPassword(char* passwordData, int passwordDataLength)
 {
 	// Set the incoming password data
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
 	incomingPasswordBitStream.Reset();
 	if (passwordData && passwordDataLength>0)
 		incomingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
 // Returns the password set by SetIncomingPassword in a BitStream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream *RakPeer::GetIncomingPassword(void)
+RakNet::BitStream *RakPeer::GetIncomingPassword(void)
 {
 	return &incomingPasswordBitStream;
 }
@@ -364,7 +370,7 @@
 // Call this to connect to the specified host (ip or domain name) and server port.
 // Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 // This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 // successful, such as rejected connection or no response then neither of these things will happen.
 // Requires that you first call Initialize
 //
@@ -395,11 +401,13 @@
 		return false;
 
 	// Set the incoming password data
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
 	outgoingPasswordBitStream.Reset();
 	if (passwordData && passwordDataLength>0)
 		outgoingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
 
 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
 	if (host[0] < '0' || host[0] > '2')
@@ -417,9 +425,10 @@
 			 Packet *p;
 			 p = PacketPool::Instance()->GetPointer();
 
-			 p->data = new char [1];
+			 p->data = new unsigned char [1];
 			 p->data[0]=(unsigned char)ID_NO_FREE_INCOMING_CONNECTIONS;
 			 p->playerId=myPlayerId;
+			 p->playerIndex=(PlayerIndex)GetIndexFromPlayerID(myPlayerId);
 			 p->length = 1;
 
 			#ifdef _DEBUG
@@ -455,7 +464,7 @@
 				 NewIncomingConnectionStruct newIncomingConnectionStruct;
 				 newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 				 newIncomingConnectionStruct.externalID=myPlayerId;
-				 Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, myPlayerId, false);
+				 Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, myPlayerId, false);
 
 				 return true;
 			 }
@@ -473,30 +482,47 @@
 // Description:
 // Stops the network threads and close all connections.  Multiple calls are ok.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Disconnect(void)
+void RakPeer::Disconnect(unsigned long blockDuration)
 {
 	unsigned i;
-	unsigned short maxPeers=maximumNumberOfPeers;
+	unsigned short maxPeers=maximumNumberOfPeers; // This is done for threading reasons
 
 	// Call close connection in a loop for all open connections.
 	for (i=0; i < maxPeers; i++)
 	{
 		// CloseConnection uses maximumNumberOfPeers
-		CloseConnection(remoteSystemList[i].playerId, true);
+		CloseConnection(remoteSystemList[i].playerId, true, blockDuration);
+	
 	}
 
 	// Setting this to 0 allows remoteSystemList to be reallocated in Initialize and prevents threads from accessing the reliability layer
 	maximumNumberOfPeers=0;
 
-	// Stop the threads
-	endThreads=true;
+	if (endThreads==false)
+	{
+		// Stop the threads
+		endThreads=true;
 
-	while(isMainLoopThreadActive)
+		// Normally the thread will call DecreaseUserCount on termination but if we aren't using threads just do it
+		// manually
+#ifdef __USE_IO_COMPLETION_PORTS
+		if (threadSleepTimer<0)
+		{
+			AsynchronousFileIO::Instance()->DecreaseUserCount();
+		}
+#endif
+
+	}
+
+	if (threadSleepTimer>=0)
+	{
+		while(isMainLoopThreadActive)
 #ifdef _WIN32
-		Sleep(10);
+			Sleep(10);
 #else
-		usleep(10 * 1000);
+			usleep(10 * 1000);
 #endif
+	}
 
 	if (connectionSocket != INVALID_SOCKET)
 	{
@@ -511,14 +537,14 @@
 //		SocketLayer::Instance()->SendTo(connectionSocket, &c, 1, "127.0.0.1", myPlayerId.port);
 //	}
 
-	while(isRecvfromThreadActive)
-#ifdef _WIN32
-		Sleep(10);
-#else
-		usleep(10 * 1000);
-#endif
+//	while(isRecvfromThreadActive)
+//#ifdef _WIN32
+//		Sleep(10);
+//#else
+//		usleep(10 * 1000);
+//#endif
 
-	isSocketLayerBlocking=false;
+//	isSocketLayerBlocking=false;
 
 //	if (connectionSocket != INVALID_SOCKET)
 //	{
@@ -539,7 +565,15 @@
 
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i < requestedConnectionsList.size(); i++)
+		delete requestedConnectionsList[i];
+	requestedConnectionsList.clear();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
+
 	// Clear out the reliabilty layer list in case we want to reallocate it in a successive call to Init.
 	RemoteSystemStruct * temp = remoteSystemList;
 	remoteSystemList=0;
@@ -574,14 +608,25 @@
 		return false;
 	}
 
-	for (count=0, index=0; (remoteSystems==0 || count < *numberOfSystems) && index < maximumNumberOfPeers; ++index)
-		if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			if (remoteSystems)
-				remoteSystems[count]=remoteSystemList[index].playerId;
-			++count;
-		}
+	// This is called a lot so unroll the loop
+	if (remoteSystems)
+	{
+		for (count=0, index=0; index < maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+			{
+				if (count < *numberOfSystems)
+					remoteSystems[count]=remoteSystemList[index].playerId;
+				++count;
+			}
 
+	}
+	else
+	{
+		for (count=0, index=0; index < maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+				++count;
+	}
+
 	*numberOfSystems=(unsigned short)count;
 
 	return 0;
@@ -598,25 +643,31 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // - Packets are only ordered relative to other packets on the same stream
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // Returns:
 // False if we are not connected to the specified recipient.  True otherwise
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(data && length>0);
+#endif
 	if (data==0 || length < 0)
 		return false;
 
-	BitStream temp(data, length, false);
-	return Send(&temp, priority, reliability, orderingStream, playerId, broadcast);
+	RakNet::BitStream temp(data, length, false);
+	return Send(&temp, priority, reliability, orderingChannel, playerId, broadcast);
 
 }
 
-bool RakPeer::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(bitStream->GetNumberOfBytesUsed()>0);
+#endif
 	if (bitStream->GetNumberOfBytesUsed()==0)
 		return false;
 	if (remoteSystemList==0 || endThreads==true)
@@ -648,13 +699,13 @@
 
 			if (outputTree)
 			{
-				BitStream bitStreamCopy(bitStream->GetNumberOfBytesUsed());
+				RakNet::BitStream bitStreamCopy(bitStream->GetNumberOfBytesUsed());
 				outputTree->EncodeArray(bitStream->GetData(),bitStream->GetNumberOfBytesUsed(), &bitStreamCopy);
 				compressedBytesSent+=bitStreamCopy.GetNumberOfBytesUsed();
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&bitStreamCopy, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&bitStreamCopy, priority,reliability,orderingChannel, true, MTUSize);
 			}
 			else
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingChannel, true, MTUSize);
 
 			if (broadcast==false)
 				return true;
@@ -677,8 +728,15 @@
 {
 	if (!(IsActive()))	return 0;
 
+	// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+	// a mutex on the function is not necessary - only on the variable that indicates if the function is
+	// running
+//	lastUserUpdateCycle=RakNetGetTime();
+//	RunMutexedUpdateCycle();
+	
+
 	// Prepare to write out a bitstream containing all the synchronization data
-//	BitStream *bitStream=0;
+//	RakNet::BitStream *bitStream=0;
 /*
 	automaticVariableSynchronizationMutex.Lock();
 
@@ -759,7 +817,7 @@
 #endif
 
 		// Push the data into a bitstream for easy parsing
-		BitStream bitStream(data+1, length-1, false);
+		RakNet::BitStream bitStream(data+1, length-1, false);
 		UniqueIDType uniqueID;
 		bool hasSecondaryID;
 		ObjectID secondaryID;
@@ -828,18 +886,32 @@
 	Packet *val;
 	int offset;
 
-	incomingQueueMutex.Lock();
-	if (incomingPacketQueue.size() > 0)
+	while (1)
 	{
-		val = incomingPacketQueue.pop();
-	}
-	else
-	{
+		incomingQueueMutex.Lock();
+		if (incomingPacketQueue.size() > 0)
+		{
+			val = incomingPacketQueue.pop();
+		}
+		else
+		{
+			incomingQueueMutex.Unlock();
+			return 0;
+		}
+
 		incomingQueueMutex.Unlock();
-		return 0;
+
+		// Do RPC calls from the user thread, not the network update thread
+		if (val->data[0] == ID_RPC || val->data[0] == ID_RPC_WITH_TIMESTAMP)
+		{
+			HandleRPCPacket((char*)val->data, val->length, val->playerId);
+			DeallocatePacket(val);
+		}
+		else
+			break; // Send the packet to the user
 	}
-	incomingQueueMutex.Unlock();
 
+
 #ifdef _DEBUG
 	assert(val->data);
 #endif
@@ -848,7 +920,7 @@
 		((unsigned char)val->data[0] == ID_TIMESTAMP))
 	{
 		offset = sizeof(unsigned char);
-		ShiftIncomingTimestamp(val->data + offset, val->playerId);
+		ShiftIncomingTimestamp((char*)val->data + offset, val->playerId);
 	}
 
 	return val;
@@ -958,13 +1030,22 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // broadcast - Send this packet to everyone.
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakPeer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
+	RakNet::BitStream temp(data, BITS_TO_BYTES(bitLength), false);
+	if (data)
+		return RPC(uniqueID, &temp, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+	else
+		return RPC(uniqueID, 0, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+}
+
+bool RakPeer::RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+{
 #ifdef _DEBUG
 	assert(uniqueID && uniqueID[0]);
 #endif
@@ -976,13 +1057,13 @@
 		return false; // Unique ID is too long
 	}
 
-	if (shiftTimestamp && (data==0 || bitLength < 8 * sizeof(unsigned long)))
+	if (shiftTimestamp && bitStream && (bitStream->GetNumberOfBytesUsed() < sizeof(unsigned long)))
 	{
 		assert(0); // Not enough bits to shift!
 		return false;
 	}
 
-	BitStream outgoingBitStream;
+	RakNet::BitStream outgoingBitStream;
 	unsigned char uniqueIDLength, ch;
 	uniqueIDLength = (unsigned char)strlen(uniqueID);
 
@@ -995,9 +1076,9 @@
 	for (int counter=0; uniqueID[counter]; counter++)
 	{
 		ch = (unsigned char)toupper(uniqueID[counter]);
-// Dev-C++ doesn't support toupper.  How lame.
-    //  if (uniqueID[counter] > 'Z')
-  //      uniqueID[counter]-='a'-'A';
+		// Dev-C++ doesn't support toupper.  How lame.
+		//  if (uniqueID[counter] > 'Z')
+		//      uniqueID[counter]-='a'-'A';
 
 		if (ch < 'A' || ch > 'Z')
 		{
@@ -1009,27 +1090,22 @@
 
 		// Make the range of the char from 0 to 32
 		ch-='A';
-		outgoingBitStream.WriteBits((unsigned char*)&ch, 5, true); // Write the char with 5 bits
+		outgoingBitStream.WriteBits((unsigned char*)&ch, 5); // Write the char with 5 bits
 	}
 
-	if (data==0)
-		bitLength=0;
+	if (bitStream)
+		outgoingBitStream.WriteCompressed(bitStream->GetNumberOfBitsUsed());
+	else
+		outgoingBitStream.WriteCompressed((int)0);
 
-	outgoingBitStream.WriteCompressed(bitLength);
-
 	// False to write the raw data from another bitstream, rather than shifting from user data
-	if (bitLength > 0)
-		outgoingBitStream.WriteBits((unsigned char*)data, bitLength);
+	if (bitStream && bitStream->GetNumberOfBitsUsed() > 0)
+		outgoingBitStream.WriteBits(bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), false);
 
-	return Send(&outgoingBitStream, priority, reliability, orderingStream,playerId,broadcast);
-}
+	// For testing
+	//	HandleRPCPacket((char*)outgoingBitStream.GetData(), outgoingBitStream.GetNumberOfBytesUsed(), UNASSIGNED_PLAYER_ID);
 
-bool RakPeer::RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
-{
-	if (bitStream && bitStream->GetNumberOfBitsUsed()>0)
-		return RPC(uniqueID, (char*)bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
-	else
-		return RPC(uniqueID, 0,0, priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
+	return Send(&outgoingBitStream, priority, reliability, orderingChannel,playerId,broadcast);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1040,25 +1116,52 @@
 // target: Which connection to close
 // sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification)
+void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)
 {
+	unsigned i, stopWaitingTime;
 	if (remoteSystemList==0 || endThreads==true)
 		return;
 
 	if (sendDisconnectionNotification)
 	{
 		unsigned char c=ID_DISCONNECTION_NOTIFICATION;
-		Send((char*)&c, sizeof(c), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+		Send((char*)&c, sizeof(c), SYSTEM_PRIORITY, RELIABLE, 0, target, false);
+		lastUserUpdateCycle=RakNetGetTime();
+//		RunMutexedUpdateCycle();
 	}
-	
-	unsigned i;
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
-	for (i=0; i < maximumNumberOfPeers; i++)
+
+	i=0;
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	for (; i < maximumNumberOfPeers; i++)
 		if (remoteSystemList[i].playerId==target)
 		{
-			// One last update so the disconnect or other packets can go out
-			remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
+			// Send out any last packets
+			// Update isn't thread safe to call outside of the internal thread
+			// remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
 
+			if (blockDuration>=0)
+			{
+				stopWaitingTime=RakNetGetTime() + blockDuration;
+
+				while (RakNetGetTime() < stopWaitingTime)
+				{
+					// If this system is out of packets to send, then stop waiting
+					if (remoteSystemList[i].reliabilityLayer.GetStatistics()->messageSendBuffer[SYSTEM_PRIORITY]==0)
+						break;
+
+					// This will probably cause the update thread to run which will probably
+					// send the disconnection notification
+#ifdef _WIN32
+					Sleep(0);
+#else
+					usleep(0 * 1000);
+#endif
+//					lastUserUpdateCycle=RakNetGetTime();
+//					RunMutexedUpdateCycle();
+				}
+			}
+
 			// Reserve this reliability layer for ourselves
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID; // This one line causes future incoming packets to go through the reliability layer
 
@@ -1067,7 +1170,8 @@
 			break;
 		}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1217,11 +1321,13 @@
 		return false;
 
 	banListIndex=0;
+	if (banList.size()==0)
+		return false; // Skip the mutex if possible
 	banListMutex.Lock();
 	for (; banListIndex < banList.size(); banListIndex++)
 	{
 		characterIndex=0;
-		while (1)
+		while (true)
 		{
 			if (banList[banListIndex][characterIndex]==IP[characterIndex])
 			{
@@ -1275,9 +1381,9 @@
 
 	PingStruct ping;
 	ping.typeId=ID_PING;
-	ping.sendPingTime=getTime();
+	ping.sendPingTime=RakNetGetTime();
 
-	Send((char*)&ping, sizeof(PingStruct), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+	Send((char*)&ping, sizeof(PingStruct), SYSTEM_PRIORITY, UNRELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1290,10 +1396,11 @@
 // The sender and recipient must already be started via a successful call to Initialize
 //
 // Parameters:
-// host: Either a dotted IP address or a domain name
+// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 // remotePort: Which port to connect to on the remote machine.
+// onlyReplyOnAcceptingConnections: Only request a reply if the remote system has open connections
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Ping(char* host, unsigned short remotePort)
+void RakPeer::Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)
 {
 	if (host==0)
 		return;
@@ -1305,8 +1412,11 @@
 	}
 
 	UnconnectedPingStruct s;
-	s.typeId=ID_PING;
-	s.sendPingTime=getTime();
+	if (onlyReplyOnAcceptingConnections)
+		s.typeId=ID_PING_OPEN_CONNECTIONS;
+	else
+		s.typeId=ID_PING;
+	s.sendPingTime=RakNetGetTime();
 
 	SocketLayer::Instance()->SendTo(connectionSocket, (char*)&s, sizeof(UnconnectedPingStruct), (char*)host, remotePort);
 }
@@ -1372,7 +1482,7 @@
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
-// Ping the remote systems every so often.  This is on by default
+// Ping the remote systems every so often.  This is off by default
 // This will work anytime
 //
 // Parameters:
@@ -1557,7 +1667,7 @@
 // Returns:
 // The data passed to SetRemoteStaticData stored as a bitstream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream* RakPeer::GetRemoteStaticData(PlayerID playerId)
+RakNet::BitStream * RakPeer::GetRemoteStaticData(PlayerID playerId)
 {
 	if (playerId==myPlayerId)
 		return &localStaticData;
@@ -1609,13 +1719,13 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SendStaticData(PlayerID target)
 {
-	BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
+	RakNet::BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
 	reply.Write((unsigned char) ID_RECEIVED_STATIC_DATA);
 	reply.Write((char*)localStaticData.GetData(), localStaticData.GetNumberOfBytesUsed());
 	if (target==UNASSIGNED_PLAYER_ID)
-		Send(&reply, HIGH_PRIORITY, RELIABLE, 0, target, true);
+		Send(&reply, SYSTEM_PRIORITY, RELIABLE, 0, target, true);
 	else
-		Send(&reply, HIGH_PRIORITY, RELIABLE, 0, target, false);
+		Send(&reply, SYSTEM_PRIORITY, RELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1731,7 +1841,7 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 const char* RakPeer::GetLocalIP(unsigned int index)
 {
-	char ipList[10][16];
+	static char ipList[10][16];
 	if (index >=10)
 		index=9;
 	memset(ipList, 0, sizeof(char) * 16 * 10);
@@ -1873,9 +1983,9 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 float RakPeer::GetDecompressionRatio(void) const
 {
-	if (rawBytesRecieved>0L)
+	if (rawBytesReceived>0L)
 	{
-		return (float)compressedBytesRecieved / (float)rawBytesRecieved;
+		return (float)compressedBytesReceived / (float)rawBytesReceived;
 	}
 	else return 0.0f;
 }
@@ -1913,224 +2023,19 @@
 #ifdef _DEBUG
 		assert(packet->data);
 #endif
-		incomingPacketQueue.push(packet);
+		incomingPacketQueue.pushAtHead(packet);
 	}
 }
-
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-double RakPeer::GetPacketlossPercentile(void) const
+RakNetStatisticsStruct *  const RakPeer::GetStatistics(PlayerID playerId)
 {
-	unsigned i;
-	double value=0.0f;
-	int count=0;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0;
-
-	for (i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			count++;
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketlossPercentile();
-		}
-	}
-
-	if (count>0)
-		return value/(double)count;
-	else return 0.0;
+	RemoteSystemStruct *rss;
+	rss=GetRemoteSystemFromPlayerID(playerId);
+	if (rss)
+		return rss->reliabilityLayer.GetStatistics();
+	return 0;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &&remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedFrameCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedFrameCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetLostPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetLostPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetReceivedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetReceivedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSent(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesSent();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceived(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesReceived();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetUnacknowledgedSentPacketListSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetUnacknowledgedSentPacketListSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSentPerSecond(void) const
-{
-	return bytesSentPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceivedPerSecond(void) const
-{
-	return bytesReceivedPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetMaximumWindowSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetMaximumWindowSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetPacketOutputBufferSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketOutputBufferSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetConnectionTime(PlayerID playerId) const
-{
-	RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID(playerId);
-	if (remoteSystem)
-		return getTime() - remoteSystem->connectionTime;
-	else
-		return 0;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RecordConnectionAttempt(const char* host, unsigned short remotePort)
 {
 	PlayerID playerId;
@@ -2138,20 +2043,23 @@
 	s = new RequestedConnectionStruct;
 	IPToPlayerID(host, remotePort, &playerId);
 	s->playerId=playerId;
-	s->time=getTime();
+	s->time=RakNetGetTime();
 	s->setAESKey=false;
 	s->nextRequestTime=s->time + 2000;
 
 	// Record that we tried to connect to this host
-	rakPeerMutexes[requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Lock();
 	requestedConnectionsList.push(s);
-	rakPeerMutexes[requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RemoveFromRequestedConnectionsList(PlayerID playerId)
 {
 	int i;
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i < (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]->playerId==playerId)
@@ -2161,7 +2069,8 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 bool RakPeer::SendConnectionRequest(const char* host, unsigned short remotePort)
@@ -2169,7 +2078,7 @@
 	int j;
 
 	const unsigned char c=ID_CONNECTION_REQUEST;
-	BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
+	RakNet::BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
 	temp.Write(c);
 	if (outgoingPasswordBitStream.GetNumberOfBytesUsed()>0)
 		temp.Write((char*)outgoingPasswordBitStream.GetData(), outgoingPasswordBitStream.GetNumberOfBytesUsed());
@@ -2184,8 +2093,10 @@
 		temp.port=remotePort;
 		PushPortRefused(temp);
 		closesocket(connectionSocket);
-		rakPeerMutexes[requestedConnections_MUTEX].Lock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[requestedConnections_MUTEX].Lock();
 		delete requestedConnectionsList.pop();
+		if (threadSleepTimer>=0)
 		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 	}
 #endif
@@ -2225,9 +2136,9 @@
 
 		if (remoteSystem==0)
 		{
-			// No reliability layer available
-			unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-			SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId);
+			// Already connected.  Ignore duplicate connection requests
+		//	unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
+		//	SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			return;
 		}
 
@@ -2255,19 +2166,20 @@
 		ds.remotePort = myPlayerId.port;
 		#endif
 		ds.externalID=playerId;
+		ds.playerIndex=(PlayerIndex)GetIndexFromPlayerID(playerId);
 		// Write using the new socket so the client knows what port to use
-		int result=SocketLayer::Instance()->SendTo(connectionSocket, (char*)&ds, sizeof(ds), playerId);
+		int result=SocketLayer::Instance()->SendTo(connectionSocket, (char*)&ds, sizeof(ds), playerId.binaryAddress, playerId.port);
 
 		if (result!=0)
 		{
-			CloseConnection(playerId, false);
+			CloseConnection(playerId, false,0L);
 			return;
 		}
 	}
 	else
 	{
 		unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-		SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId);
+		SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2280,8 +2192,10 @@
 
 	numberOfIncomingConnections=0;
 	for (i=0; i < maximumNumberOfPeers; i++)
+	{
 		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].weInitiatedTheConnection==false)
 			numberOfIncomingConnections++;
+	}
 
 	return numberOfIncomingConnections;
 }
@@ -2291,13 +2205,26 @@
 	RemoteSystemStruct *remoteSystem=0;
 	unsigned i;
 
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	// If this guy is already connected, return 0.  This needs to be checked inside the mutex
+	// because threads may call the connection routine multiple times at the same time
 	for (i=0; i < maximumNumberOfPeers; i++)
+		if (remoteSystemList[i].playerId==playerId)
+		{
+			if (threadSleepTimer>=0)
+				rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+			return 0;
+		}
+
+	for (i=0; i < maximumNumberOfPeers; i++)
 	{
 		if (remoteSystemList[i].playerId==UNASSIGNED_PLAYER_ID)
 		{
 			if (setAESKey)
 				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(AESKey);
+			else
+				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(0);
 			// Reserve this reliability layer for ourselves
 			(remoteSystemList[i]).playerId=playerId; // This one line causes future incoming packets to go through the reliability layer
 			remoteSystem=remoteSystemList+i;
@@ -2305,7 +2232,8 @@
 		}
 	}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 
 	return remoteSystem;
 }
@@ -2325,9 +2253,9 @@
 	remoteSystem->nextPingTime=0; // Ping immediately
 	remoteSystem->weInitiatedTheConnection=weInitiatedTheConnection;
 	remoteSystem->staticData.Reset();
-	remoteSystem->connectionTime=getTime();
+	remoteSystem->connectionTime=RakNetGetTime();
 	remoteSystem->myExternalPlayerId=UNASSIGNED_PLAYER_ID;
-//	remoteSystem->reliabilityLayer.Reset();
+	remoteSystem->reliabilityLayer.Reset();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2359,7 +2287,7 @@
 
 	for (counter=0; counter < PING_TIMES_ARRAY_SIZE; counter++)
 	{
-		if (remoteSystem->pingAndClockDifferential[0].pingTime==-1)
+		if (remoteSystem->pingAndClockDifferential[counter].pingTime==-1)
 			break;
 
 		if (remoteSystem->pingAndClockDifferential[counter].pingTime < lowestPingSoFar)
@@ -2392,11 +2320,12 @@
 	// Number of bits of the data (long)
 	// The data
 
-	BitStream incomingBitStream(data, length, false);
+	RakNet::BitStream incomingBitStream(data, length, false);
 	unsigned char uniqueIDLength, ch, packetID;
 	char uniqueIdentifier[256];
 	int counter;
-	long bitLength;
+	unsigned long bitLength;
+	char *userData;
 
 	if (incomingBitStream.Read(packetID)==false)
 	{
@@ -2480,17 +2409,18 @@
 		}
 
 		// We have to copy into a new data chunk because the user data might not be byte aligned.
-		char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		//char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		userData=(char*)alloca(BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits()));
 
 		// The false means read out the internal representation of the bitstream data rather than
-		// Aligning it as we normally would with user data.  This is so the end user can cast the data received
+		// aligning it as we normally would with user data.  This is so the end user can cast the data received
 		// into a bitstream for reading
 		if (incomingBitStream.ReadBits((unsigned char*)userData, bitLength, false)==false)
 		{
 #ifdef _DEBUG
 			assert(0);
 #endif
-			delete [] userData;
+		//	delete [] userData;
 			return false; // Not enough data to read
 		}
 
@@ -2499,7 +2429,7 @@
 		// Call the function callback
 		node->functionName(userData, bitLength, playerId);
 		// Free the memory
-		delete [] userData;
+//		delete [] userData;
 	}
 
 	return true;
@@ -2508,12 +2438,17 @@
 #ifdef __USE_IO_COMPLETION_PORTS
 bool RakPeer::SetupIOCompletionPortSocket(int index)
 {
-	SOCKET newSocket = SocketLayer::Instance()->CreateBoundSocket(myPlayerId.port+index+1, false);
-	SocketLayer::Instance()->Connect(newSocket, remoteSystemList[index].playerId); // port is the port of the client
+	SOCKET newSocket;
+
+	if (remoteSystemList[index].reliabilityLayer.GetSocket()!=INVALID_SOCKET)
+		closesocket(remoteSystemList[index].reliabilityLayer.GetSocket());
+
+	newSocket = SocketLayer::Instance()->CreateBoundSocket(myPlayerId.port+index+1, false);
+	SocketLayer::Instance()->Connect(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port); // port is the port of the client
 	remoteSystemList[index].reliabilityLayer.SetSocket(newSocket);
 
 	// Associate our new socket with a completion port and do the first read
-	return SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId, this);
+	return SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port, this);
 }
 #endif
 
@@ -2530,15 +2465,15 @@
 		memcpy(newRandomNumber+i, (char*)&number, sizeof(number));
 	}
 
-	randomNumberExpirationTime = getTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
+	randomNumberExpirationTime = RakNetGetTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SecuredConnectionResponse(PlayerID playerId)
 {
 	CSHA1 sha1;
-	unsigned char *connectionRequestResponse;
-	// 20 bytes for the SHA1 hash
-	connectionRequestResponse = new unsigned char [1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20];
+	RSA_BIT_SIZE n;
+	big::u32 e;
+	unsigned char connectionRequestResponse[1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20];
 	connectionRequestResponse[0]=ID_SECURED_CONNECTION_RESPONSE;
 
 	// Hash the SYN-Cookie
@@ -2552,54 +2487,63 @@
 	// Write the cookie
 	memcpy(connectionRequestResponse+1, sha1.GetHash(), 20);
 
-	// Write the byte size
-	memcpy(connectionRequestResponse+1+20, (char*)&securedConnectionByteSize, securedConnectionByteSize);
-
 	// Write the public keys
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize), e.value, securedConnectionByteSize);
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize)+securedConnectionByteSize, n.value, securedConnectionByteSize);
+	rsacrypt.getPublicKey(e,n);
+	memcpy(connectionRequestResponse+1+20, (char*)&e, sizeof(big::u32));
+	memcpy(connectionRequestResponse+1+20+sizeof(big::u32), n, sizeof(RSA_BIT_SIZE));
 
 	// s2c public key, syn-cookie
-	SocketLayer::Instance()->SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20, playerId);
-	delete [] connectionRequestResponse;
+	SocketLayer::Instance()->SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20, playerId.binaryAddress, playerId.port);
 }
-void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data, int length)
+void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data)
 {
 	int i,j;
 	unsigned char randomNumber[20];
 	unsigned long number;
-	unsigned short rsaByteSize;
 	bool doSend;
 	Packet *packet;
-	mpuint source,result,packetE, packetN;
+	big::u32 e;
+	RSA_BIT_SIZE n, message,encryptedMessage;
+	big::RSACrypt<RSA_BIT_SIZE> rsaEncrypt;
 
-	doSend=false;
-	rsaByteSize=0;
+	// Make sure that we still want to connect
+	bool requestedConnection=false;
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i < (int)requestedConnectionsList.size();i++)
+	{
+		if (requestedConnectionsList[i]->playerId==playerId)
+		{
+			// We did request this connection
+			requestedConnection=true;
+			break;
+		}
+	}
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
-#ifdef _DEBUG
-	assert(sizeof(rsaByteSize)==sizeof(securedConnectionByteSize));
-#endif
+	if (requestedConnection==false)
+		return; // Don't want to connect
 
-	// Get the rsa byte size
-	memcpy((char*)&rsaByteSize, data+1+20, sizeof(rsaByteSize));
+	doSend=false;
 
-	// If the packet length is wrong for this byte size, return
-	if (length != (int)(1+20+sizeof(rsaByteSize)+rsaByteSize*2))
-		return;
+	// Copy out e and n
+	memcpy((char*)&e,data+1+20, sizeof(big::u32));
+	memcpy(n, data+1+20+sizeof(big::u32), sizeof(RSA_BIT_SIZE));
 
 	// If we preset a size and it doesn't match, or the keys do not match, then tell the user
-	if (securedConnectionByteSize > 0 && keysLocallyGenerated==false)
+	if (usingSecurity==true && keysLocallyGenerated==false)
 	{
-		if (securedConnectionByteSize != rsaByteSize ||
-			memcmp(data+1+20+sizeof(rsaByteSize), e.value, rsaByteSize)!=0 ||
-			memcmp(data+1+20+sizeof(rsaByteSize)+rsaByteSize, n.value, rsaByteSize)!=0)
+		if (memcmp((char*)&e, (char*)&publicKeyE, sizeof(big::u32))!=0 ||
+			memcmp(n, publicKeyN, sizeof(RSA_BIT_SIZE))!=0)
 		{
 			packet = PacketPool::Instance()->GetPointer();
-			packet->data = new char[1];
+			packet->data = new unsigned char[1];
 			packet->data[0]=ID_RSA_PUBLIC_KEY_MISMATCH;
 			packet->length=sizeof(char);
 			packet->bitSize=sizeof(char)*8;
 			packet->playerId=playerId;
+			packet->playerIndex=(PlayerIndex)GetIndexFromPlayerID(packet->playerId);
 			incomingQueueMutex.Lock();
 			incomingPacketQueue.push(packet);
 			incomingQueueMutex.Unlock();
@@ -2608,12 +2552,6 @@
 		}
 	}
 
-	// Copy the keys from the packet
-	packetE.Init(rsaByteSize);
-	packetN.Init(rsaByteSize);
-	memcpy(packetE.value,data+1+20+sizeof(rsaByteSize),rsaByteSize);
-	memcpy(packetN.value,data+1+20+sizeof(rsaByteSize)+rsaByteSize,rsaByteSize);
-
 	// Create a random number
 	for (i=0; i < sizeof(randomNumber); i+=sizeof(number))
 	{
@@ -2621,16 +2559,14 @@
 		memcpy(randomNumber+i, (char*)&number, sizeof(number));
 	}
 
-	// Encrypt the random number using RSA
-	source.Init(rsaByteSize);
-	result.Init(rsaByteSize);
+	memset(message, 0, sizeof(message));
+	assert(sizeof(message) >= sizeof(randomNumber));
+	memcpy(message, randomNumber, sizeof(randomNumber));
+	rsaEncrypt.setPublicKey(e,n);
+	rsaEncrypt.encrypt(message,encryptedMessage);
 
-	// This crummy rsa encoder doesn't work reliably with full blocks so WriteAndFill block doesn't work.
-	// source.WriteAndFillBlock((char*)randomNumber, 20);
-	memcpy(source.value, randomNumber, 20);
-	EncryptDecrypt(result, source, packetE, packetN);
-
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i < (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]->playerId==playerId)
@@ -2643,18 +2579,17 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
 	if (doSend)
 	{
-		char *reply;
-		reply = new char [1+20+rsaByteSize];
+		char reply[1+20+sizeof(RSA_BIT_SIZE)];
 		// c2s RSA(random number), same syn-cookie
 		reply[0]=ID_SECURED_CONNECTION_CONFIRMATION;
 		memcpy(reply+1, data+1, 20);  // Copy the syn-cookie
-		memcpy(reply+1+20, result.value, rsaByteSize); // Copy the encoded random number
-		SocketLayer::Instance()->SendTo(connectionSocket, reply, 1+20+rsaByteSize, playerId);
-		delete [] reply;
+		memcpy(reply+1+20, encryptedMessage, sizeof(RSA_BIT_SIZE)); // Copy the encoded random number
+		SocketLayer::Instance()->SendTo(connectionSocket, reply, 1+20+sizeof(RSA_BIT_SIZE), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2663,10 +2598,11 @@
 	// Tell the game we can't connect to this host
 	Packet *p;
 	p = PacketPool::Instance()->GetPointer();
-	p->data=new char[1];
+	p->data=new unsigned char[1];
 	p->data[0]=ID_REMOTE_PORT_REFUSED;
 	p->length=sizeof(char);
 	p->playerId=target; // We don't know this!
+	p->playerIndex=(PlayerIndex)GetIndexFromPlayerID(p->playerId);
 
 	#ifdef _DEBUG
 	assert(p->data);
@@ -2678,6 +2614,7 @@
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+/*
 #ifdef _WIN32
 unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments)
 #else
@@ -2739,7 +2676,7 @@
 #endif
 	return 0;
 }
-
+*/
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 #ifdef _WIN32
 void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer)
@@ -2756,18 +2693,31 @@
 	if (remoteSystem)
 	{
 		// Handle regular incoming data
+		// HandleSocketReceiveFromConnectedPlayer is only safe to be called from the same thread as Update,
+		// which is this thread
 		if (remoteSystem->reliabilityLayer.HandleSocketReceiveFromConnectedPlayer(data, length)==false)
 		{
-			// Cheater
-			Packet *packet = PacketPool::Instance()->GetPointer();
-			packet->data = new char[1];
-			packet->data[0]=ID_MODIFIED_PACKET;
-			packet->length=sizeof(char);
-			packet->bitSize=sizeof(char)*8;
-			packet->playerId=playerId;
-			rakPeer->incomingQueueMutex.Lock();
-			rakPeer->incomingPacketQueue.push(packet);
-			rakPeer->incomingQueueMutex.Unlock();
+			// These kinds of packets may have been duplicated and incorrectly determined to be
+			// cheat packets.  Anything else really is a cheat packet
+			if (!((unsigned char)(data)[0]==ID_CONNECTION_REQUEST ||
+				((unsigned char)(data)[0]==ID_PING && length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_PONG && length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_SECURED_CONNECTION_CONFIRMATION && length==1+20+sizeof(RSA_BIT_SIZE))
+				))
+			{
+				// Cheater
+				Packet *packet = PacketPool::Instance()->GetPointer();
+				packet->data = new unsigned char[1];
+				packet->data[0]=ID_MODIFIED_PACKET;
+				packet->length=sizeof(char);
+				packet->bitSize=sizeof(char)*8;
+				packet->playerId=playerId;
+				packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
+				rakPeer->incomingQueueMutex.Lock();
+				rakPeer->incomingPacketQueue.push(packet);
+				rakPeer->incomingQueueMutex.Unlock();
+			}
+			
 		}
 	}
 	else
@@ -2778,45 +2728,50 @@
 			if (rakPeer->GetNumberOfIncomingConnections() >= rakPeer->GetMaximumIncomingConnections())
 			{
 				unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
-			else if (rakPeer->securedConnectionByteSize==0)
+			char *password = data + sizeof(unsigned char);
+			int passwordLength = length - sizeof(unsigned char);
+			if (rakPeer->IsBanned(rakPeer->PlayerIDToDottedIP(playerId)))
 			{
-				char *password = data + sizeof(unsigned char);
-				int passwordLength = length - sizeof(unsigned char);
-				if (rakPeer->IsBanned(rakPeer->PlayerIDToDottedIP(playerId)))
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_CONNECTION_BANNED;
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
+			}
+			else if (rakPeer->incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &&
+				memcmp(password, rakPeer->incomingPasswordBitStream.GetData(), passwordLength)==0)
+			{
+				if (rakPeer->usingSecurity==false)
 				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_CONNECTION_BANNED;
-					SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
-				}
-				else if (rakPeer->incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &&
-					memcmp(password, rakPeer->incomingPasswordBitStream.GetData(), passwordLength)==0)
-				{
+#ifdef _TEST_AES
+					unsigned char AESKey[16];
+					// Save the AES key
+					for (i=0; i < 16; i++)
+						AESKey[i]=i;
+					rakPeer->HandleConnectionRequest(playerId, AESKey, true);
+#else
 					// Connect this player assuming we have open slots
 					rakPeer->HandleConnectionRequest(playerId, 0, false);
+#endif
 				}
 				else
-				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_INVALID_PASSWORD;
-					SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
-				}
+					rakPeer->SecuredConnectionResponse(playerId);
+				
 			}
 			else
 			{
-				rakPeer->SecuredConnectionResponse(playerId);
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_INVALID_PASSWORD;
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_RESPONSE &&
-			// 20 SHA1 + 1 packet header + 4 public key + sizeof(securedConnectionByteSize)
-			length >= 25 + sizeof(rakPeer->securedConnectionByteSize))
+			length==1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20)
 		{
-			rakPeer->SecuredConnectionConfirmation(playerId, data, length);
+			rakPeer->SecuredConnectionConfirmation(playerId, data);
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_CONFIRMATION &&
-			// 20 Syn cookie + 1 packet header + 20 encoded random number
-			length >= 41)
+			length==1+20+sizeof(RSA_BIT_SIZE))
 		{
 			CSHA1 sha1;
 			bool confirmedHash, newRandomNumber;
@@ -2841,7 +2796,7 @@
 				confirmedHash=true;
 				newRandomNumber=true;
 			}
-			else if (rakPeer->randomNumberExpirationTime < getTime())
+			else if (rakPeer->randomNumberExpirationTime < RakNetGetTime())
 			{
 				sha1.Reset();
 				sha1.Update((unsigned char*)&playerId.binaryAddress, sizeof(playerId.binaryAddress));
@@ -2855,20 +2810,18 @@
 
 			if (confirmedHash)
 			{
-				mpuint source,result;
 				int i;
 				unsigned char AESKey[16];
+				RSA_BIT_SIZE message,encryptedMessage;
 
 				// On connection accept, AES key is c2s RSA_Decrypt(random number) XOR s2c syn-cookie
 				// Get the random number first
-				source.Init(rakPeer->securedConnectionByteSize);
-				result.Init(rakPeer->securedConnectionByteSize);
-				memcpy(source.value, data+1+20, rakPeer->securedConnectionByteSize);
-				EncryptDecrypt(result, source, rakPeer->d, rakPeer->n);
+				memcpy(encryptedMessage, data+1+20, sizeof(RSA_BIT_SIZE));
+				rakPeer->rsacrypt.decrypt(encryptedMessage, message);
 
 				// Save the AES key
 				for (i=0; i < 16; i++)
-					AESKey[i]=data[1+i] ^ ((unsigned char*)(result.value))[i];
+					AESKey[i]=data[1+i] ^ ((unsigned char*)(message))[i];
 
 				// Connect this player assuming we have open slots
 				rakPeer->HandleConnectionRequest(playerId,AESKey, true);
@@ -2882,12 +2835,13 @@
 		{
 			 // Make sure this connection accept is from someone we wanted to connect to
 			bool requestedConnection;
-//			unsigned long time = getTime();
+//			unsigned long time = RakNetGetTime();
 			unsigned char AESKey[16];
 			bool setAESKey;
 			setAESKey=false;
 			requestedConnection=false;
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+			if (rakPeer->threadSleepTimer>=0)
+				rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 			for (i=0; i < rakPeer->requestedConnectionsList.size();i++)
 			{
 				if (rakPeer->requestedConnectionsList[i]->playerId==playerId)
@@ -2902,14 +2856,23 @@
 					break;
 				}
 			}
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			if (rakPeer->threadSleepTimer>=0)
+				rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
 			 if (requestedConnection)
 			 {
 				// Find a free remote system struct to use
 				ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) data;
 				playerId.port=cas->remotePort;
+
+#ifdef _TEST_AES
+				// Save the AES key
+				for (i=0; i < 16; i++)
+					AESKey[i]=i;
+				remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, AESKey,true);
+#else
 				remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, AESKey,setAESKey);
+#endif
 
 				if (remoteSystem!=0)
 				{
@@ -2923,9 +2886,9 @@
 					// Create a new nonblocking socket
 					remoteSystem->reliabilityLayer.SetSocket(SocketLayer::Instance()->CreateBoundSocket(rakPeer->myPlayerId.port, false));
 
-					SocketLayer::Instance()->Connect(remoteSystem->reliabilityLayer.GetSocket(), playerId);
+					SocketLayer::Instance()->Connect(remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port);
 					// Associate our new socket with a completion port and do the first read
-					b=SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(remoteSystem->reliabilityLayer.GetSocket(), playerId, rakPeer);
+					b=SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port, rakPeer);
 					//client->//reliabilityLayerMutex.Unlock();
 
 					if (b==false) // Some damn completion port error... windows is so unreliable
@@ -2939,11 +2902,13 @@
 
 					// Send the connection request complete to the game
 					Packet *packet = PacketPool::Instance()->GetPointer();
-					packet->data = new char[1];
-					packet->data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
-					packet->length=sizeof(char);
-					packet->bitSize=sizeof(char)*8;
+					packet->data = new unsigned char[sizeof(ConnectionAcceptStruct)];
+					memcpy(packet->data, data, sizeof(ConnectionAcceptStruct));
+					// packet->data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
+					packet->length=sizeof(ConnectionAcceptStruct);
+					packet->bitSize=sizeof(ConnectionAcceptStruct)*8;
 					packet->playerId=playerId;
+					packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
 
 					#ifdef _DEBUG
 					assert(packet->data);
@@ -2956,7 +2921,7 @@
 					newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 					newIncomingConnectionStruct.externalID=playerId;
 
-					rakPeer->Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, playerId, false);
+					rakPeer->Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, playerId, false);
 					rakPeer->Ping(playerId);
 					rakPeer->SendStaticData(playerId);
 				}
@@ -2964,7 +2929,7 @@
 				{
 					// Cancel the connection attempt
 					char c = ID_DISCONNECTION_NOTIFICATION;
-					SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
+					SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 				}
 			}
 			 else
@@ -2974,26 +2939,28 @@
 #endif
 			 }
 		 }
-		 else if ((unsigned char)(data)[0]== ID_PING && length==sizeof(UnconnectedPingStruct))
+		 else if (((unsigned char)(data)[0]== ID_PING  || (unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS) && length==sizeof(UnconnectedPingStruct))
 		 {
+			 if ((unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS && rakPeer->GetMaximumIncomingConnections()==0)
+				 return; // Sender wanted to get replies only for systems accepting connections
 			 data[0]=ID_PONG;
-			 SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, data, sizeof(UnconnectedPingStruct), playerId);
+			 SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, data, sizeof(UnconnectedPingStruct), playerId.binaryAddress, playerId.port);
 		 }
 		 else if ((unsigned char)(data)[0]== ID_PONG && length==sizeof(UnconnectedPingStruct))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
 
-			 packet->data = new char [sizeof(UnconnectedPingStruct)];
+			 packet->data = new unsigned char [sizeof(UnconnectedPingStruct)];
 			 unsigned long time;
 			 memcpy((char*)&time, data+sizeof(unsigned char), sizeof(unsigned long));
-			 time = getTime() - time;
+			 time = RakNetGetTime() - time;
 			 packet->data[0]=ID_PONG;
 			 memcpy(packet->data+sizeof(unsigned char), (char*)&time, sizeof(unsigned long));
 			 
 			 packet->length=sizeof(UnconnectedPingStruct);
 			 packet->bitSize=sizeof(UnconnectedPingStruct) * 8;
-
 			 packet->playerId=playerId;
+			 packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
 
 			 rakPeer->incomingQueueMutex.Lock();
 			 (rakPeer->incomingPacketQueue).push(packet);
@@ -3002,7 +2969,7 @@
 		 else if ((unsigned char)(data)[0]==ID_NO_FREE_INCOMING_CONNECTIONS && length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
-			 packet->data = new char [1 * sizeof(unsigned char)];
+			 packet->data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet->data[0]=ID_NO_FREE_INCOMING_CONNECTIONS;
 			 packet->length=1 * sizeof(unsigned char);
 			 packet->bitSize=8 * sizeof(unsigned char);
@@ -3013,7 +2980,7 @@
 		 else if ((unsigned char)(data)[0]==ID_CONNECTION_BANNED && length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
-			 packet->data = new char [1 * sizeof(unsigned char)];
+			 packet->data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet->data[0]=ID_CONNECTION_BANNED;
 			 packet->length=1 * sizeof(unsigned char);
 			 packet->bitSize=8 * sizeof(unsigned char);
@@ -3024,380 +2991,457 @@
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-#ifdef _WIN32
-unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
-#else
-void*  UpdateNetworkLoop( void*  arguments )
-#endif
+bool RakPeer::RunUpdateCycle(void)
 {
-	RakPeer *rakPeer = (RakPeer *)arguments;
-	RakPeer::RemoteSystemStruct* remoteSystemList=rakPeer->remoteSystemList;
 	RakPeer::RemoteSystemStruct* remoteSystem;
 	unsigned remoteSystemIndex;
 	Packet *packet;
 	long ping, lastPing;
-	bool anyPeersActive;
-	int currentSentBytes,currentReceivedBytes,lastSentBytes,lastReceivedBytes;
-	unsigned long time,nextReadBytesTime;
+//	int currentSentBytes,currentReceivedBytes;
 	unsigned numberOfBytesUsed;
 	unsigned numberOfBitsUsed;
 	//PlayerID authoritativeClientPlayerId;
-	BitStream dataBitStream(MAXIMUM_MTU_SIZE);
 	int bitSize, byteSize;
 	char *data;
-	unsigned short maximumNumberOfPeers;
+	int errorCode;
+	bool gotData;
+	unsigned long time;
 
-	// For histogram statistics
-	lastSentBytes=lastReceivedBytes=0;
-	nextReadBytesTime=0;
+	do
+	{
+		// Read a packet
+		gotData=SocketLayer::Instance()->RecvFrom(connectionSocket, this, &errorCode);
 
-	maximumNumberOfPeers = rakPeer->maximumNumberOfPeers;
+		if (gotData==false)
+		{
 
-	rakPeer->isMainLoopThreadActive=true;
+#ifdef _WIN32
+			if (errorCode==WSAECONNRESET)
+			{
+				PushPortRefused(UNASSIGNED_PLAYER_ID);
+				//closesocket(peer->connectionSocket);
 
-	while(rakPeer->endThreads==false)
-	{
-		// We calculate this from the lowest numerical player ID
-		//authoritativeClientPlayerId=UNASSIGNED_PLAYER_ID;
+				//peer->connectionSocket = SocketLayer::Instance()->CreateBoundSocket(peer->myPlayerId.port, true);
+			}
+			else if (errorCode!=0 && endThreads==false)
+			{
+#ifdef _DEBUG
+				printf("Server RecvFrom critical failure!\n");
+#endif
+				// Some kind of critical error
+				//	peer->isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#else
+			if (errorCode==-1)
+			{
+				//	isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#endif
+		}
+		if (endThreads)
+			return false;
+	} while (gotData); // Read until there is nothing left
 
-		// Get the current system time
-		time = getTime();
+	time = RakNetGetTime();
 
-		anyPeersActive=false;
-
-		// Update the requested connection list.
-		if (rakPeer->requestedConnectionsList.size()>0)
+	// Update the requested connection list.
+	if (requestedConnectionsList.size()>0)
+	{
+		remoteSystemIndex=0;
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+		while (remoteSystemIndex < requestedConnectionsList.size())
 		{
-			remoteSystemIndex=0;
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
-			while (remoteSystemIndex < rakPeer->requestedConnectionsList.size())
+			// After X seconds give up
+			if (time - requestedConnectionsList[remoteSystemIndex]->time > SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION*2)
 			{
-				// After X seconds give up
-				if (time - rakPeer->requestedConnectionsList[remoteSystemIndex]->time > SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION)
-				{
-                    delete rakPeer->requestedConnectionsList[remoteSystemIndex];
-					rakPeer->requestedConnectionsList.del(remoteSystemIndex);
-				}
-				else if (time > rakPeer->requestedConnectionsList[remoteSystemIndex]->nextRequestTime)
-				{
-					rakPeer->SendConnectionRequest(
-						rakPeer->PlayerIDToDottedIP(rakPeer->requestedConnectionsList[remoteSystemIndex]->playerId),
-						rakPeer->requestedConnectionsList[remoteSystemIndex]->playerId.port);
+				delete requestedConnectionsList[remoteSystemIndex];
+				requestedConnectionsList.del(remoteSystemIndex);
+			}
+			else if (time > requestedConnectionsList[remoteSystemIndex]->nextRequestTime)
+			{
+				SendConnectionRequest(
+					PlayerIDToDottedIP(requestedConnectionsList[remoteSystemIndex]->playerId),
+					requestedConnectionsList[remoteSystemIndex]->playerId.port);
 
-					// Send again 2 seconds later
-					rakPeer->requestedConnectionsList[remoteSystemIndex]->nextRequestTime=time + 2000;
-					remoteSystemIndex++;
-				}
-				else
-					remoteSystemIndex++;
+				// Send again 2 seconds later
+				requestedConnectionsList[remoteSystemIndex]->nextRequestTime=time + 2000;
+				remoteSystemIndex++;
 			}
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			else
+				remoteSystemIndex++;
 		}
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	}
 
-		for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
+	for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
+	{
+		if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
 		{
-			if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
+			// Found an active remote system
+			remoteSystem = remoteSystemList+remoteSystemIndex;
+			// Update is only safe to call from the same thread that calls HandleSocketReceiveFromConnectedPlayer,
+			// which is this thread
+			remoteSystem->reliabilityLayer.Update(connectionSocket, remoteSystem->playerId, MTUSize, time);
+
+			// Was the reliability layer unable to deliver a reliable packet?
+			if (remoteSystem->reliabilityLayer.IsDeadConnection())
 			{
-				// Found an active remote system
-				remoteSystem = remoteSystemList+remoteSystemIndex;
-				remoteSystem->reliabilityLayer.Update(rakPeer->connectionSocket, remoteSystem->playerId, rakPeer->MTUSize);
+				packet = PacketPool::Instance()->GetPointer();
 
-				anyPeersActive=true;
+				packet->data = new unsigned char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
+				packet->data[0]=ID_CONNECTION_LOST;
+				memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
 
-				// Was the reliability layer unable to deliver a reliable packet?
-				if (remoteSystem->reliabilityLayer.IsDeadConnection())
-				{
-					packet = PacketPool::Instance()->GetPointer();
+				packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
+				packet->bitSize=(sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()) * 8;
+				packet->playerId=remoteSystem->playerId;
+				packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					packet->data = new char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
-					packet->data[0]=ID_CONNECTION_LOST;
-					memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
-					packet->bitSize=(sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()) * 8;
+				CloseConnection(remoteSystem->playerId, false, 0L);
+				continue;
+			}
 
-					packet->playerId=remoteSystem->playerId;
+			// Did the reliability layer detect a modified packet?
+			if (remoteSystem->reliabilityLayer.IsCheater())
+			{
+				packet = PacketPool::Instance()->GetPointer();
+				packet->length=1;
+				packet->data = new unsigned char [1];
+				packet->data[0] = (unsigned char)ID_MODIFIED_PACKET;
+				packet->playerId=remoteSystem->playerId;
+				packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					rakPeer->incomingQueueMutex.Lock();
-					(rakPeer->incomingPacketQueue).push(packet);
-					rakPeer->incomingQueueMutex.Unlock();
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					rakPeer->CloseConnection(remoteSystem->playerId, false);
-					continue;
-				}
+				continue;
+			}
 
-				// Did the reliability layer detect a modified packet?
-				if (remoteSystem->reliabilityLayer.IsCheater())
-				{
-					packet = PacketPool::Instance()->GetPointer();
-					packet->length=1;
-					packet->data = new char [1];
-					packet->data[0] = (unsigned char)ID_MODIFIED_PACKET;
-					packet->playerId=remoteSystem->playerId;
+			// Ping this guy if it is time to do so
+			if (time > remoteSystem->nextPingTime && (occasionalPing || remoteSystem->lowestPing==-1))
+			{
+				remoteSystem->nextPingTime = time + 5000;
+				Ping(remoteSystem->playerId);
+			}
 
-					rakPeer->incomingQueueMutex.Lock();
-					(rakPeer->incomingPacketQueue).push(packet);
-					rakPeer->incomingQueueMutex.Unlock();
+			// Find whoever has the lowest player ID
+			//if (remoteSystem->playerId < authoritativeClientPlayerId)
+			//	authoritativeClientPlayerId=remoteSystem->playerId;
 
-					continue;
-				}
+			// Does the reliability layer have any packets waiting for us?
+			// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+			bitSize = remoteSystem->reliabilityLayer.Receive(&data);
 
-				if (rakPeer->occasionalPing)
+			while (bitSize > 0)
+			{
+				// Put the input through compression if necessary
+				if (inputTree)
 				{
-					// Ping this guy if it is time to do so
-					if (time > remoteSystem->nextPingTime)
+					RakNet::BitStream dataBitStream(MAXIMUM_MTU_SIZE);
+					// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
+					// larger data block.  It's slow, but the user should have known that anyway
+					dataBitStream.Reset();
+					dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
+					numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
+					numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
+					rawBytesReceived+=numberOfBytesUsed;
+					// Decompress the input data.
+
+#ifdef _DEBUG
+					assert(numberOfBitsUsed>0);
+#endif
+					unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
+					memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
+					dataBitStream.Reset();
+					inputTree->DecodeArray(dataCopy,numberOfBitsUsed, &dataBitStream);
+					compressedBytesReceived+=dataBitStream.GetNumberOfBytesUsed();
+					delete [] dataCopy;
+
+					byteSize = dataBitStream.GetNumberOfBytesUsed();
+					if (byteSize > BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
 					{
-						remoteSystem->nextPingTime = time + 5000;
-						rakPeer->Ping(remoteSystem->playerId);
+						delete [] data;
+						data = new char [byteSize];
 					}
+					memcpy(data, dataBitStream.GetData(), byteSize);
 				}
+				else
+					// Fast and easy - just use the data that was returned
+					byteSize = BITS_TO_BYTES(bitSize);
 
-				// Find whoever has the lowest player ID
-				//if (remoteSystem->playerId < authoritativeClientPlayerId)
-				//	authoritativeClientPlayerId=remoteSystem->playerId;
+				// Read any system packets
+				if ((unsigned char)data[0]==ID_PONG && byteSize==sizeof(PingStruct))
+				{
+					// Copy into the ping times array the current time - the value returned
+					// First extract the sent ping
+					PingStruct *ps = (PingStruct *)data;
 
-				// Does the reliability layer have any packets waiting for us?
-				bitSize = remoteSystem->reliabilityLayer.Receive(&data);
+					ping=time - ps->sendPingTime;
+					lastPing = remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime;
 
-				while (bitSize > 0)
-				{
-					// Put the input through compression if necessary
-					if (rakPeer->inputTree)
+					// Ignore super high spikes in the average
+					if (lastPing <= 0 || (((int)ping < (lastPing * 3)) && ping < 1200))
 					{
-						// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
-						// larger data block.  It's slow, but the user should have known that anyway
-						dataBitStream.Reset();
-						dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
-						numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
-						numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
-						rakPeer->rawBytesRecieved+=numberOfBytesUsed;
-						// Decompress the input data.
-						if (rakPeer->inputTree)
-						{
-#ifdef _DEBUG
-							assert(numberOfBitsUsed>0);
-#endif
-							unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
-							memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
-							dataBitStream.Reset();
-							rakPeer->inputTree->DecodeArray(dataCopy,numberOfBitsUsed, &dataBitStream);
-							rakPeer->compressedBytesRecieved+=dataBitStream.GetNumberOfBytesUsed();
-							delete [] dataCopy;
-						}
-						byteSize = dataBitStream.GetNumberOfBytesUsed();
-						if (byteSize > BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
-						{
-							delete [] data;
-							data = new char [byteSize];
-						}
-						memcpy(data, dataBitStream.GetData(), byteSize);
+						remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
+						// Thanks to Chris Taylor (cat02e at fsu.edu) for the improved timestamping algorithm
+						remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].clockDifferential=ps->sendPongTime - (time + ps->sendPingTime) / 2;
+						if (remoteSystem->lowestPing==-1 ||  remoteSystem->lowestPing > ping)
+							remoteSystem->lowestPing = ping;
+						// Most packets should arrive by the ping time.
+						remoteSystem->reliabilityLayer.SetLostPacketResendDelay(ping*2);
+
+						if (++(remoteSystem->pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
+							remoteSystem->pingAndClockDifferentialWriteIndex=0;
 					}
-					else
-						// Fast and easy - just use the data that was returned
-						byteSize = BITS_TO_BYTES(bitSize);
 
-					// Read any system packets
-					if ((unsigned char)data[0]==ID_PONG && byteSize==sizeof(PingStruct))
-					{
-						// Copy into the ping times array the current time - the value returned
-						// First extract the sent ping
-						PingStruct *ps = (PingStruct *)data;
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_PING && byteSize==sizeof(PingStruct))
+				{
+					PingStruct *ps = (PingStruct*)data;
+					ps->typeId=ID_PONG;
+					ps->sendPongTime=RakNetGetTime();
 
-						ping=time - ps->sendPingTime;
-						lastPing = remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime;
+					Send(data,byteSize, SYSTEM_PRIORITY, UNRELIABLE, 0, remoteSystem->playerId, false);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION && byteSize==sizeof(NewIncomingConnectionStruct))
+				{
+					Ping(remoteSystem->playerId);
+					SendStaticData(remoteSystem->playerId);
 
-						// Ignore super high spikes in the average
-						if (lastPing <= 0 || (((int)ping < (lastPing * 3)) && ping < 1200))
-						{
-							remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
-							// Thanks to Chris Taylor (cat02e at fsu.edu) for the improved timestamping algorithm
-							remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].clockDifferential=ps->sendPongTime - (time + ps->sendPingTime) / 2;
-							if (remoteSystem->lowestPing==-1 ||  remoteSystem->lowestPing > ping)
-								remoteSystem->lowestPing = ping;
-							remoteSystem->reliabilityLayer.SetLostPacketResendDelay(ping * 6);
+					NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
+					remoteSystem->myExternalPlayerId=newIncomingConnectionStruct->externalID;
 
-							if (++(remoteSystem->pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
-								remoteSystem->pingAndClockDifferentialWriteIndex=0;
-						}
+					// Send this info down to the game
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length=byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-						delete [] data;
-					}
-					else if ((unsigned char)data[0]==ID_PING && byteSize==sizeof(PingStruct))
+#ifdef _DEBUG
+					assert(packet->data);
+#endif
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				/*
+				else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
+				{
+				if (byteSize>2)
+				{
+				packet = PacketPool::Instance()->GetPointer();
+				packet->data = data;
+				packet->length=byteSize;
+				packet->bitSize=bitSize;
+				packet->playerId=remoteSystem->playerId;
+
+				synchronizedMemoryQueueMutex.Lock();
+				synchronizedMemoryPacketQueue.push(packet);
+				synchronizedMemoryQueueMutex.Unlock();
+				}
+				else
+				delete [] data;
+				}
+				*/
+				else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
+				{
+					packet = PacketPool::Instance()->GetPointer();
+					if (remoteSystem->staticData.GetNumberOfBytesUsed()>0)
 					{
-						PingStruct *ps = (PingStruct*)data;
-						ps->typeId=ID_PONG;
-						ps->sendPongTime=getTime();
+						packet->data = new unsigned char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
+						packet->data[0]=ID_DISCONNECTION_NOTIFICATION;
+						memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
 
-						rakPeer->Send(data,byteSize, HIGH_PRIORITY, UNRELIABLE, 0, remoteSystem->playerId, false);
+						packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
+						packet->bitSize=sizeof(char)*8 + remoteSystem->staticData.GetNumberOfBitsUsed();
+
 						delete [] data;
 					}
-					else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION && byteSize==sizeof(NewIncomingConnectionStruct))
+					else
 					{
-						rakPeer->Ping(remoteSystem->playerId);
-						rakPeer->SendStaticData(remoteSystem->playerId);
-
-						NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
-						remoteSystem->myExternalPlayerId=newIncomingConnectionStruct->externalID;
-
-						// Send this info down to the game
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length=byteSize;
+						packet->data=(unsigned char*)data;
 						packet->bitSize=bitSize;
-						packet->playerId=remoteSystem->playerId;
-
-#ifdef _DEBUG
-						assert(packet->data);
-#endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
+						packet->length=1;
 					}
-					/*
-					else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
-					{
-						if (byteSize>2)
-						{
-							packet = PacketPool::Instance()->GetPointer();
-							packet->data = data;
-							packet->length=byteSize;
-							packet->bitSize=bitSize;
-							packet->playerId=remoteSystem->playerId;
 
-							rakPeer->synchronizedMemoryQueueMutex.Lock();
-							rakPeer->synchronizedMemoryPacketQueue.push(packet);
-							rakPeer->synchronizedMemoryQueueMutex.Unlock();
-						}
-						else
-							delete [] data;
-					}
-					*/
-					else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
-					{
-						packet = PacketPool::Instance()->GetPointer();
-						if (remoteSystem->staticData.GetNumberOfBytesUsed()>0)
-						{
-							packet->data = new char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
-							packet->data[0]=ID_DISCONNECTION_NOTIFICATION;
-							memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-							packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
-							packet->bitSize=sizeof(char)*8 + remoteSystem->staticData.GetNumberOfBitsUsed();
+					CloseConnection(remoteSystem->playerId, false, 0L);
 
-							delete [] data;
-						}
-						else
-						{
-							packet->data=data;
-							packet->bitSize=bitSize;
-							packet->length=1;
-						}
-
-						packet->playerId=remoteSystem->playerId;
-
-						rakPeer->CloseConnection(remoteSystem->playerId, false);
-
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						// Relay this message to the game
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
+					// Relay this message to the game
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
 
-					}
-					else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
-					{
-						rakPeer->SendStaticData(remoteSystem->playerId);
-						delete [] data;
-					}
-					else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
-					{
-						remoteSystem->staticData.Reset();
-						remoteSystem->staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
+				}
+				else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
+				{
+					SendStaticData(remoteSystem->playerId);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
+				{
+					remoteSystem->staticData.Reset();
+					remoteSystem->staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
 
-						// Inform game server code that we got static data
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length = byteSize;
-						packet->bitSize=bitSize;
-						packet->playerId = remoteSystem->playerId;
+					// Inform game server code that we got static data
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length = byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId = remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
-					}
-					else if ((unsigned char)data[0] == ID_RPC || (unsigned char)data[0] == ID_RPC_WITH_TIMESTAMP)
-					{
-						rakPeer->HandleRPCPacket(data, byteSize, remoteSystem->playerId);
-						delete [] data;
-					}
-					else
-					{
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length=byteSize;
-						packet->bitSize=bitSize;
-						packet->playerId=remoteSystem->playerId;
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				else
+				{
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length=byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
-					}
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
 
-					// Does the reliability layer have any more packets waiting for us?
-					bitSize = remoteSystem->reliabilityLayer.Receive(&data);
-				}
+				// Does the reliability layer have any more packets waiting for us?
+				// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+				bitSize = remoteSystem->reliabilityLayer.Receive(&data);
 			}
 		}
+	}
 
 
-		// Statistics histogram
-		if (time > nextReadBytesTime)
+	/*
+	// Statistics histogram
+	if (time > nextReadBytesTime)
+	{
+		nextReadBytesTime = time + 1000L; // 1 second
+		for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
 		{
-			nextReadBytesTime = time + 1000L; // 1 second
-			currentSentBytes = rakPeer->GetBytesSent();
-			currentReceivedBytes = rakPeer->GetBytesReceived();
-			rakPeer->bytesSentPerSecond = currentSentBytes - lastSentBytes;
-			rakPeer->bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
-			lastSentBytes=currentSentBytes;
-			lastReceivedBytes=currentReceivedBytes;
-		}
+		currentSentBytes = GetBytesSent();
+		currentReceivedBytes = GetBytesReceived();
+		bytesSentPerSecond = currentSentBytes - lastSentBytes;
+		bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
+		lastSentBytes=currentSentBytes;
+		lastReceivedBytes=currentReceivedBytes;
+	}
+	*/
 
-		// Context switch so other threads can run
-		if (rakPeer->threadPriority==0)
+	return true;
+}
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+#ifdef _WIN32
+unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
+#else
+void*  UpdateNetworkLoop( void*  arguments )
+#endif
+{
+	RakPeer *rakPeer = (RakPeer *)arguments;
+//	unsigned long time;
+
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()->IncreaseUserCount();
+#endif
+
+	rakPeer->isMainLoopThreadActive=true;
+
+	while(rakPeer->endThreads==false)
+	{
+		/*
+		time=RakNetGetTime();
+
+		// Dynamic threading - how long we sleep and if we update
+		// depends on whether or not the user thread is updating
+		if (time > rakPeer->lastUserUpdateCycle && time - rakPeer->lastUserUpdateCycle > UPDATE_THREAD_UPDATE_TIME)
 		{
-			#ifdef _WIN32
-			Sleep(15);
-			#else
-			usleep(15 * 1000);
-			#endif
+			// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+			// a mutex on the function is not necessary - only on the variable that indicates if the function is
+			// running
+			rakPeer->RunMutexedUpdateCycle();
+			
+
+			// User is not updating the network.  Sleep a short time
+#ifdef _WIN32
+				Sleep(rakPeer->threadSleepTimer);
+#else
+				usleep(rakPeer->threadSleepTimer * 1000);
+#endif
 		}
-		else if (rakPeer->threadPriority==1)
+		else
 		{
+			// User is actively updating the network.  Only occasionally poll
 #ifdef _WIN32
-			Sleep(0);
+			Sleep(UPDATE_THREAD_POLL_TIME);
 #else
-			usleep(0 * 1000);
+			usleep(UPDATE_THREAD_POLL_TIME * 1000);
 #endif
 		}
-
-		if (anyPeersActive==false)		
-		{
+		*/
+		rakPeer->RunUpdateCycle();
 #ifdef _WIN32
-			Sleep(30);
+		Sleep(rakPeer->threadSleepTimer);
 #else
-			usleep(30 * 1000);
+		usleep(rakPeer->threadSleepTimer * 1000);
 #endif
-		}
 	}
 	rakPeer->isMainLoopThreadActive=false;
 
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()->DecreaseUserCount();
+#endif
+
+
 	return 0;
 }
+
+/*
+void RakPeer::RunMutexedUpdateCycle(void)
+{
+	rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+	if (updateCycleIsRunning==false)
+	{
+		updateCycleIsRunning=true;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+		RunUpdateCycle(); // Do one update per call to Receive
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+		updateCycleIsRunning=false;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+	}
+	else
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+}
+*/

Modified: branches/mp-branch-2/source/libraries/raknet/RakPeer.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakPeer.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakPeer.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -14,7 +14,8 @@
 #include "RakPeerInterface.h"
 #include "BinarySearchTree.h"
 #include "RPCNode.h"
-#include "MPUInt.h"
+#include "RSACrypt.h"
+#include "BitStream.h"
 
 class HuffmanEncodingTree;
 
@@ -42,11 +43,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority);
+	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer);
 
 	// Description:
 	// Must be called while offline
@@ -58,15 +59,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *RSAe, char *RSAn, char *RSAp, char *RSAq);
 
 	// Description
 	// Must be called while offline
@@ -98,13 +97,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -120,7 +119,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Returns true if the network threads are running
@@ -145,14 +148,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -207,13 +210,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -224,7 +227,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	void CloseConnection(PlayerID target, bool sendDisconnectionNotification);
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration);
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -297,9 +302,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	void Ping(char* host, unsigned short remotePort);
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections);
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -323,7 +329,7 @@
 	int GetLowestPing(PlayerID target) const;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -383,7 +389,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	BitStream* GetRemoteStaticData(PlayerID playerId);
+	RakNet::BitStream * GetRemoteStaticData(PlayerID playerId);
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -554,29 +560,25 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	double GetPacketlossPercentile(void) const; // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void) const; // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void) const; // How many frames were sent	
-	unsigned long GetLostPacketCount(void) const; // How many packets were lost
-	unsigned long GetReceivedPacketCount(void) const; // How many packets were received
-	unsigned long GetBytesSent(void) const; // How many bytes have been sent.
-	unsigned long GetBytesReceived(void) const; // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void) const; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void) const; // Returns the size of the flow control window, in packets.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void) const; // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId) const; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
 
 protected:
 
 #ifdef _WIN32
-	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
+//	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
 	friend void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend unsigned __stdcall UpdateNetworkLoop(LPVOID arguments);
 #else
-	friend void*  RecvFromNetworkLoop( void*  arguments );
+//	friend void*  RecvFromNetworkLoop( void*  arguments );
 	friend void ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend void*  UpdateNetworkLoop( void*  arguments );
 #endif
@@ -596,7 +598,7 @@
 		int pingAndClockDifferentialWriteIndex; // The index we are writing into the pingAndClockDifferential circular buffer
 		int lowestPing;
 		unsigned long nextPingTime; // When to next ping this player
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		unsigned long connectionTime;
 	};
 
@@ -634,11 +636,12 @@
 	bool SetupIOCompletionPortSocket(int index);
 	#endif
 
-	bool endThreads, isMainLoopThreadActive, isRecvfromThreadActive; // Tracks thread states
+	bool endThreads, isMainLoopThreadActive;
+	// bool isRecvfromThreadActive; // Tracks thread states
 	bool occasionalPing; // Do we occasionally ping the other systems?
 	unsigned short maximumNumberOfPeers,maximumIncomingConnections;
 	// localStaticData necessary because we may not have a RemoteSystemStruct representing ourselves in the list
-	BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData;
+	RakNet::BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData;
 	PlayerID myPlayerId;
 
 	// This is an array of pointers to RemoteSystemStruct
@@ -654,17 +657,20 @@
 		incomingPasswordBitStream_Mutex,
 		outgoingPasswordBitStream_Mutex,
 		remoteSystemList_Mutex, // This mutex is a writer lock for reserving player IDs only
+//		updateCycleIsRunning_Mutex,
 		NUMBER_OF_RAKPEER_MUTEXES
 	};
 	SimpleMutex rakPeerMutexes[NUMBER_OF_RAKPEER_MUTEXES];
 
+	// RunUpdateCycle is not thread safe but we don't need to mutex calls.  Just skip calls if it is running already
+	bool updateCycleIsRunning;
 
 	// The list of people we have tried to connect to recently
 	BasicDataStructures::Queue<RequestedConnectionStruct*> requestedConnectionsList;
 
 	// Data that both the client and the server needs
 	unsigned long bytesSentPerSecond, bytesReceivedPerSecond;
-	bool isSocketLayerBlocking;
+//	bool isSocketLayerBlocking;
 	//bool continualPing,isRecvfromThreadActive,isMainLoopThreadActive, endThreads, isSocketLayerBlocking;
 	unsigned long validationInteger;
 #ifdef _WIN32
@@ -694,25 +700,37 @@
 	// Compression stuff
 	unsigned long frequencyTable[256];
 	HuffmanEncodingTree *inputTree, *outputTree;
-	unsigned long rawBytesSent, rawBytesRecieved, compressedBytesSent, compressedBytesRecieved;
-	//void DecompressInput(BitStream *bitStream);
-	//void UpdateOutgoingFrequencyTable(BitStream* bitStream);
+	unsigned long rawBytesSent, rawBytesReceived, compressedBytesSent, compressedBytesReceived;
+	//void DecompressInput(RakNet::BitStream *bitStream);
+	//void UpdateOutgoingFrequencyTable(RakNet::BitStream * bitStream);
 	void GenerateSYNCookieRandomNumber(void);
 	void SecuredConnectionResponse(PlayerID playerId);
-	void SecuredConnectionConfirmation(PlayerID playerId, char* data, int length);
+	void SecuredConnectionConfirmation(PlayerID playerId, char* data);
+	bool RunUpdateCycle(void);
+	//void RunMutexedUpdateCycle(void);
 
 	BasicDataStructures::AVLBalancedBinarySearchTree<RPCNode> rpcTree;
 	int MTUSize;
 	bool trackFrequencyTable;
-	int threadPriority;
+	int threadSleepTimer;
 
 	SOCKET connectionSocket;
 
-	mpuint d,e,n;
-	unsigned short securedConnectionByteSize;
-	bool keysLocallyGenerated;
+	// Histogram statistics
+	//unsigned long nextReadBytesTime;
+	//int lastSentBytes,lastReceivedBytes;
+
+	// Encryption and security
+	big::RSACrypt<RSA_BIT_SIZE> rsacrypt;
+	big::u32 publicKeyE;
+	RSA_BIT_SIZE publicKeyN;
+	bool keysLocallyGenerated, usingSecurity;
 	unsigned long randomNumberExpirationTime;
 	unsigned char newRandomNumber[20], oldRandomNumber[20];
+
+	// How long it has been since things were updated by a call to receive
+	// Update thread uses this to determine how long to sleep for
+	unsigned long lastUserUpdateCycle;
 };
 
 #endif

Modified: branches/mp-branch-2/source/libraries/raknet/RakPeerInterface.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakPeerInterface.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakPeerInterface.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -10,9 +10,10 @@
 #ifndef __RAK_PEER_INTERFACE_H
 #define __RAK_PEER_INTERFACE_H
 
-class BitStream;
 #include "PacketPriority.h"
 #include "NetworkTypes.h"
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakPeerInterface
 {
@@ -36,11 +37,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)=0;
+	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)=0;
 
 	// Description:
 	// Must be called while offline
@@ -52,15 +53,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// RSAe, RSAn - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *RSAe, char *RSAn, char *RSAp, char *RSAq)=0;
 
 	// Description
 	// Must be called while offline
@@ -92,13 +91,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -114,7 +113,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Returns true if the network threads are running
@@ -138,14 +141,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -200,13 +203,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -217,7 +220,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification)=0;
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)=0;
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -290,9 +295,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	virtual void Ping(char* host, unsigned short remotePort)=0;
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	virtual void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -316,7 +322,7 @@
 	virtual int GetLowestPing(PlayerID target) const=0;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -375,7 +381,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	virtual BitStream* GetRemoteStaticData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetRemoteStaticData(PlayerID playerId)=0;
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -547,20 +553,16 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void) const=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void) const=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void) const=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void) const=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void) const=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void) const=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void) const=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void) const=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void) const=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void) const=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId) const=0; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: branches/mp-branch-2/source/libraries/raknet/RakServer.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakServer.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakServer.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -28,9 +28,9 @@
 {
 }
 
-void RakServer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakServer::InitializeSecurity(char *RSAp, char *RSAq)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, RSAd, RSAe, RSAn);
+	RakPeer::InitializeSecurity(0,0, RSAp, RSAq);
 }
 
 void RakServer::DisableSecurity(void)
@@ -38,19 +38,17 @@
 	RakPeer::DisableSecurity();
 }
 
-bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)
+bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)
 {
 	bool init;
 
-	if (highPriorityThreads)
-		init=RakPeer::Initialize(AllowedPlayers, port,1);
-	else
-		init=RakPeer::Initialize(AllowedPlayers, port,0);
+	RakPeer::Disconnect(30L);
 
+	init=RakPeer::Initialize(AllowedPlayers, port,threadSleepTimer);
 	RakPeer::SetMaximumIncomingConnections(AllowedPlayers);
 
 	// Random number seed
-	long time = getTime();
+	long time = RakNetGetTime();
 	seedMT(time);
 	seed=randomMT();
 	if (seed % 2 == 0) // Even
@@ -64,8 +62,15 @@
 
 void RakServer::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakServer::HasPassword(void)
@@ -73,19 +78,19 @@
 	return GetIncomingPassword()->GetNumberOfBytesUsed() > 0;
 }
 
-void RakServer::Disconnect(void)
+void RakServer::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
-bool RakServer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
 Packet* RakServer::Receive(void)
@@ -95,7 +100,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() && occasionalPing)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time > broadcastPingsTime || (packet && packet->data[0]==ID_RECEIVED_STATIC_DATA))
 		{
 			if (time > broadcastPingsTime)
@@ -103,7 +108,7 @@
 
 			unsigned i, count;
 			RemoteSystemStruct *remoteSystem;
-			BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
+			RakNet::BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
 			unsigned char typeId=ID_BROADCAST_PINGS;
 			bitStream.Write(typeId);
 			for (i=0, count=0; count < 32 && i < maximumNumberOfPeers; i++)
@@ -121,9 +126,9 @@
 			if (count>0) // If we wrote anything
 			{
 				if (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION) // If this was a new connection
-					Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false); // Send to the new connection
+					Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false); // Send to the new connection
 				else
-					Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
+					Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
 			}
 		}
 	}
@@ -131,7 +136,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() && synchronizedRandomInteger)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time > nextSeedUpdate || (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION))
 		{
 			if (time > nextSeedUpdate)
@@ -144,39 +149,39 @@
 
 			SetRandomNumberSeedStruct s;
 			s.ts=ID_TIMESTAMP;
-			s.timeStamp=getTime();
+			s.timeStamp=RakNetGetTime();
 			s.typeId=ID_SET_RANDOM_NUMBER_SEED;
 			s.seed=seed;
 			s.nextSeed=nextSeed;
 
 			if (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION)
-				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 			else
-				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 		}
 	}
 
 	if (packet)
-	{
+	{			
 		// Intercept specific client / server feature packets.  This will do an extra send and still pass on the data to the user
-		if (packet->data[0]==ID_RECEIVED_STATIC_DATA)
+		if (packet->data[0]==ID_REMOTE_STATIC_DATA)
 		{
 			if (relayStaticClientData)
 			{
 				// Relay static data to the other systems but the sender
-				BitStream bitStream(packet->length + sizeof(PlayerID));
-				unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+				RakNet::BitStream bitStream(packet->length + sizeof(PlayerID));
+				unsigned char typeId=ID_REMOTE_STATIC_DATA;
 				bitStream.Write(typeId);
 				bitStream.Write(packet->playerId.binaryAddress);
 				bitStream.Write(packet->playerId.port);
-				bitStream.Write(packet->data+sizeof(unsigned char), packet->length-sizeof(unsigned char));
-				Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				bitStream.Write((char*)packet->data+sizeof(unsigned char), packet->length-sizeof(unsigned char));
+				Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 			}			
 		}
 		else if (packet->data[0]==ID_DISCONNECTION_NOTIFICATION || packet->data[0]==ID_CONNECTION_LOST || packet->data[0]==ID_NEW_INCOMING_CONNECTION)
 		{
 			// Relay the disconnection
-			BitStream bitStream(packet->length + sizeof(PlayerID));
+			RakNet::BitStream bitStream(packet->length + sizeof(PlayerID));
 			unsigned char typeId;
 			if (packet->data[0]==ID_DISCONNECTION_NOTIFICATION)
 				typeId=ID_REMOTE_DISCONNECTION_NOTIFICATION;
@@ -187,7 +192,8 @@
 			bitStream.Write(typeId);
 			bitStream.Write(packet->playerId.binaryAddress);
 			bitStream.Write(packet->playerId.port);
-			Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, true);
+			bitStream.Write((unsigned short&)packet->playerIndex);
+			Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, true);
 
 			if (packet->data[0]==ID_NEW_INCOMING_CONNECTION)
 			{
@@ -201,19 +207,20 @@
 						bitStream.Write(typeId);
 						bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 						bitStream.Write(remoteSystemList[i].playerId.port);
+						bitStream.Write((unsigned short)i);
 						// One send to tell them of the connection
-						Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+						Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 
 						if (relayStaticClientData)
 						{
 							bitStream.Reset();
-							typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+							typeId=ID_REMOTE_STATIC_DATA;
 							bitStream.Write(typeId);
 							bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 							bitStream.Write(remoteSystemList[i].playerId.port);
 							bitStream.Write((char*)remoteSystemList[i].staticData.GetData(), remoteSystemList[i].staticData.GetNumberOfBytesUsed());
 							// Another send to tell them of the static data
-							Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+							Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 						}
 					}
 				}
@@ -226,7 +233,7 @@
 
 void RakServer::Kick(PlayerID playerId)
 {
-	RakPeer::CloseConnection(playerId, true);
+	RakPeer::CloseConnection(playerId, true, 0L);
 }
 
 void RakServer::DeallocatePacket(Packet *packet)
@@ -346,14 +353,14 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakServer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
-bool RakServer::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
 /*
@@ -382,7 +389,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakServer::GetStaticServerData(void)
+RakNet::BitStream * RakServer::GetStaticServerData(void)
 {
 	return RakPeer::GetRemoteStaticData(myPlayerId);
 }
@@ -402,7 +409,7 @@
 	RakPeer::SendStaticData(playerId);
 }
 
-BitStream* RakServer::GetStaticClientData(PlayerID playerId)
+RakNet::BitStream * RakServer::GetStaticClientData(PlayerID playerId)
 {
 	return RakPeer::GetRemoteStaticData(playerId);
 }
@@ -420,13 +427,13 @@
 		return; // No such playerChangedId
 
     // Relay static data to the other systems but the sender
-	BitStream bitStream(remoteSystem->staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
-	unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+	RakNet::BitStream bitStream(remoteSystem->staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
+	unsigned char typeId=ID_REMOTE_STATIC_DATA;
 	bitStream.Write(typeId);
 	bitStream.Write(playerChangedId.binaryAddress);
 	bitStream.Write(playerChangedId.port);
 	bitStream.Write((char*)remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
-	Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, playerToSendToId, true);
+	Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, playerToSendToId, true);
 }
 
 unsigned int RakServer::GetNumberOfAddresses(void)
@@ -488,69 +495,7 @@
 {
 	return RakPeer::GetMTUSize();
 }
-
-double RakServer::GetPacketlossPercentile(void)
+RakNetStatisticsStruct * const RakServer::GetStatistics(PlayerID playerId)
 {
-	return RakPeer::GetPacketlossPercentile();
+	return RakPeer::GetStatistics(playerId);
 }
-	
-unsigned long RakServer::GetTransmittedPacketCount(void)
-{
-	return RakPeer::GetTransmittedPacketCount();
-}
-
-unsigned long RakServer::GetTransmittedFrameCount(void)
-{
-	return RakPeer::GetTransmittedFrameCount();
-}
-
-unsigned long RakServer::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakServer::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakServer::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakServer::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakServer::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakServer::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakServer::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakServer::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakServer::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakServer::GetConnectionTime(PlayerID playerId)
-{
-	return RakPeer::GetConnectionTime(playerId);
-}
-

Modified: branches/mp-branch-2/source/libraries/raknet/RakServer.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakServer.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakServer.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -25,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port);
+	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port);
 
 	// Description:
 	// Must be called while offline
@@ -43,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *RSAp, char *RSAq);
 
 	// Description
 	// Must be called while offline
@@ -67,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -222,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -260,7 +260,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -286,12 +286,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,20 +382,16 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile among all connected clients
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent among all connected clients
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost among all connected clients
-	unsigned long GetReceivedPacketCount(void); // How many packets were received among all connected clients
-	unsigned long GetBytesSent(void); // How many bytes have been sent among all connected clients.
-	unsigned long GetBytesReceived(void); // How many bytes have been received among all connected clients.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId); // Returns when this client connected or 0 if not connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
 
 	private:
 

Modified: branches/mp-branch-2/source/libraries/raknet/RakServerInterface.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/RakServerInterface.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/RakServerInterface.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -13,7 +13,8 @@
 #include "NetworkTypes.h"
 #include "PacketPriority.h"
 #include "RakPeerInterface.h"
-class BitStream;
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakServerInterface
 {
@@ -24,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)=0;
+	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)=0;
 
 	// Description:
 	// Must be called while offline
@@ -42,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// RSAp, RSAq - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *RSAp, char *RSAq)=0;
 
 	// Description
 	// Must be called while offline
@@ -66,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -221,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -260,7 +261,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -286,12 +287,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,20 +383,16 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile among all connected clients
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent among all connected clients
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost among all connected clients
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received among all connected clients
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent among all connected clients.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received among all connected clients.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId)=0; // Returns when this client connected or 0 if not connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -11,6 +11,14 @@
 #include <assert.h>
 #include "GetTime.h"
 #include "SocketLayer.h"
+
+// alloca
+#ifdef _WIN32
+#include <malloc.h>
+#else
+#include <stdlib.h>
+#endif
+
 //#include "MemoryManager.h"
 
 // Defined in rand.cpp
@@ -19,18 +27,31 @@
 extern inline float frandomMT(void);
 
 static const int ACK_BIT_LENGTH=sizeof(PacketNumberType)*8+1;
-static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame
-static const int MINIMUM_WINDOW_SIZE=10; // how many packets can be sent unacknowledged before waiting for an ack
+static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame.
+static const int MINIMUM_WINDOW_SIZE=5; // how many packets can be sent unacknowledged before waiting for an ack
 
+#ifdef _INTERNET_SIMULATOR
+// Lag
+struct DataAndTime
+{
+	char data[2000];
+	int length;
+	unsigned long sendTime;
+};
+static BasicDataStructures::List<DataAndTime*> delayList;
+#endif
+
 //-------------------------------------------------------------------------------------------------------
 // Constructor
 //-------------------------------------------------------------------------------------------------------
 ReliabilityLayer::ReliabilityLayer() : updateBitStream(MAXIMUM_MTU_SIZE) // preallocate the update bitstream so we can avoid a lot of reallocs at runtime
 {
+	receivedPackets=0;
 	InitializeVariables();
 	#ifdef __USE_IO_COMPLETION_PORTS
 	readWriteSocket=INVALID_SOCKET;
 	#endif
+	freeThreadedMemoryOnNextUpdate=false;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -38,7 +59,7 @@
 //-------------------------------------------------------------------------------------------------------
 ReliabilityLayer::~ReliabilityLayer()
 {
-	FreeMemory();
+	FreeMemory(true); // Free all memory immediately
 	#ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket!=INVALID_SOCKET)
 		closesocket(readWriteSocket);
@@ -50,9 +71,8 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::Reset(void)
 {
-	FreeMemory();
+	FreeMemory(false); // False because Reset can be called by any thread
 	InitializeVariables();
-	encryptor.UnsetKey();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -99,11 +119,13 @@
 	memset(waitingForSequencedPacketReadIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(waitingForOrderedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(waitingForSequencedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
-	memset(receivedPackets, 0, RECEIVED_PACKET_LOG_LENGTH * sizeof(unsigned long));
+	memset(&statistics, 0, sizeof(statistics));
+	statistics.connectionStartTime=RakNetGetTime();
+	lastPacketCounterResetTime=statistics.connectionStartTime;
 	splitPacketId=0L;
 	packetNumber=0;
-	lastPacketSendTime=retransmittedPackets=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
-	lostPacketResendDelay=1000L;
+//	lastPacketSendTime=retransmittedFrames=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
+	SetLostPacketResendDelay(1000L);
 	deadConnection=cheater=false;
 	lastAckTime=0;
 	blockWindowIncreaseUntilTime=0;
@@ -111,110 +133,146 @@
 	windowSize=MINIMUM_WINDOW_SIZE;
 	lossyWindowSize=MAXIMUM_WINDOW_SIZE+1; // Infinite
 	lastWindowIncreaseSizeTime=0;
-	lastPacketReceivedTime=0;
+//	lastPacketReceivedTime=0;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Frees all allocated memory
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::FreeMemory(void)
+void ReliabilityLayer::FreeMemory(bool freeAllImmediately)
 {
-	unsigned i,j;
+	if (freeAllImmediately)
+	{
+		FreeThreadedMemory();
+		FreeThreadSafeMemory();		
+	}
+	else
+	{
+		FreeThreadSafeMemory();
+		freeThreadedMemoryOnNextUpdate=true;
+	}
+	
+}
+void ReliabilityLayer::FreeThreadedMemory(void)
+{
+	unsigned i;
 	InternalPacket *internalPacket;
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-		for (i=0; i < splitPacketList.size(); i++)
-		{
-			delete [] splitPacketList[i]->data;
-			InternalPacketPool::Instance()->ReleasePointer(splitPacketList[i]);
-		}
-		splitPacketList.clear();
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
-//	}
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	for (i=0; i < splitPacketList.size(); i++)
+	{
+		delete [] splitPacketList[i]->data;
+		InternalPacketPool::Instance()->ReleasePointer(splitPacketList[i]);
+	}
+	splitPacketList.clear();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-		for (i=0; i < NUMBER_OF_PRIORITIES; i++)
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+	while (outputQueue.size()>0)
+	{
+		internalPacket= outputQueue.pop();
+		delete [] internalPacket->data;
+		InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+	}
+	outputQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	}
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	for (i=0; i < orderingList.size(); i++)
+	{
+		if (orderingList[i])
 		{
-			for (j=0; j < sendQueue[i].size(); j++)
-			{
-				delete [] (sendQueue[i])[j]->data;
-				InternalPacketPool::Instance()->ReleasePointer((sendQueue[i])[j]);
-			}
-			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
-		}
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-//	}
+			BasicDataStructures::LinkedList<InternalPacket*>* theList = orderingList[i];
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-		for (i=0; i < orderingList.size(); i++)
-		{
-			if (orderingList[i])
+			if (theList)
 			{
-				BasicDataStructures::LinkedList<InternalPacket*>* theList = orderingList[i];
-
-				if (theList)
+				while (theList->size())
 				{
-					while (theList->size())
-					{
-						internalPacket = orderingList[i]->pop();
-						delete [] internalPacket->data;
-						InternalPacketPool::Instance()->ReleasePointer(internalPacket);
-					}
+					internalPacket = orderingList[i]->pop();
+					delete [] internalPacket->data;
+					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				}
 
-					delete theList;
-				}
+				delete theList;
 			}
 		}
-		orderingList.clear();
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-//	}
+	}
+	orderingList.clear();
+	//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while (acknowledgementQueue.size()>0)
-			InternalPacketPool::Instance()->ReleasePointer(acknowledgementQueue.pop());
-		acknowledgementQueue.clearAndForceAllocation(64);
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
-//	}
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	while (acknowledgementQueue.size()>0)
+		InternalPacketPool::Instance()->ReleasePointer(acknowledgementQueue.pop());
+	acknowledgementQueue.clearAndForceAllocation(64);
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-		while (outputQueue.size()>0)
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	while (resendQueue.size())
+	{
+		// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
+		internalPacket= resendQueue.pop();
+		if (internalPacket)
 		{
-			internalPacket= outputQueue.pop();
 			delete [] internalPacket->data;
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 		}
-		outputQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
-//	}
+	}
+	resendQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//	}
 
+	if (receivedPackets)
+	{
+		delete [] receivedPackets;
+		receivedPackets=0;
+	}
+}
+void ReliabilityLayer::FreeThreadSafeMemory(void)
+{
+	unsigned i,j;
+//	InternalPacket *internalPacket;
+
 //	if (bytesSent > 0 || bytesReceived > 0)
 //	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-		while (resendQueue.size())
+		
+		for (i=0; i < NUMBER_OF_PRIORITIES; i++)
 		{
-			// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-			internalPacket= resendQueue.pop();
-			if (internalPacket)
+			j=0;
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
+			for (; j < sendQueue[i].size(); j++)
 			{
-				delete [] internalPacket->data;
-				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				delete [] (sendQueue[i])[j]->data;
+				InternalPacketPool::Instance()->ReleasePointer((sendQueue[i])[j]);
 			}
+			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 		}
-		resendQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		
 //	}
 
-	InternalPacketPool::Instance()->ClearPool();
+
+#ifdef _INTERNET_SIMULATOR
+	for (i=0; i < delayList.size(); i++)
+		delete delayList[i];
+	delayList.clear();
+#endif
+
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -238,48 +296,59 @@
 	bool pushedPacket;
 	int count;
 
-	bytesReceived+=length + UDP_HEADER_SIZE;
+//	bytesReceived+=length + UDP_HEADER_SIZE;
+	
+	
 
 	// decode this whole chunk if the decoder is defined.
 	if (encryptor.IsKeySet())
 	{
 		if (encryptor.Decrypt((unsigned char*)buffer, length, (unsigned char*)buffer, &length)==false)
+		{
+			statistics.bitsWithBadCRCReceived+=length*8;
+			statistics.packetsWithBadCRCRecieved++;
 			return false;
+		}
 	}
 
-	BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
+	statistics.bitsReceived+=length*8;
+	statistics.packetsReceived++;
 
-	time = lastPacketReceivedTime = getTime();
+	RakNet::BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
 
+//	time = lastPacketReceivedTime = RakNetGetTime();
+	time=RakNetGetTime();
+
 	//printf("In HandleSocketReceiveFromConnectedPlayer %i bytes\n",length);
 	//for (int ass=0; ass < length && ass < 10; ass++)
 	//	printf("%i ", ((char*)(socketData.GetData()))[ass]);
 	//printf("\n\n");
 
 	// Parse the bitstream to create an internal packet
-	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&socketData);
+	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&socketData,time);
 
-
 	while (internalPacket)
 	{
 		if (internalPacket->isAcknowledgement)
 		{
+		//	printf("Got ack at %i\n", RakNetGetTime());
+
 			numberOfAcksInFrame++;
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 			if (resendQueue.size()==0)
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=0;  // Not resending anything so clear this var so we don't drop the connection on not getting any more acks
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 			else
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=time; // Just got an ack.  Record when we got it so we know the connection is alive
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 
 			// SHOW - ack received
@@ -290,11 +359,11 @@
 		}
 		else
 		{
-			receivedPacketsCount++;
+//			receivedPacketsCount++;
 
 			if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
 			{
-				SendAcknowledgementPacket(internalPacket->packetNumber);
+				SendAcknowledgementPacket(internalPacket->packetNumber, time);
 			}
 
 			// If this packet number was recently used then it has already been received.
@@ -303,8 +372,11 @@
 			// make it through within NUMBER_OF_TRIES tries. If the last time this packet 
 			// number was used is older than that
 			// then it must be a different packet
+			/*
 			if (internalPacket->packetNumber >= RECEIVED_PACKET_LOG_LENGTH)
 			{
+				statistics.invalidMessagesReceived++;
+
 				delete [] internalPacket->data;
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 				#ifdef _DEBUG
@@ -312,36 +384,66 @@
 				#endif
 				return true;
 			}
-			if (receivedPackets[internalPacket->packetNumber] > time - TIMEOUT_TIME) 
+			*/
+
+			// testing
+	//		if (internalPacket->reliability==UNRELIABLE)
+	//			printf("Got unreliable packet number %i\n", internalPacket->packetNumber);
+	//		else if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
+	//			printf("Got reliable packet number %i\n", internalPacket->packetNumber);
+
+			if (receivedPackets==0)
+			{
+				receivedPackets=new unsigned long[65536];// Range of PacketNumberType
+				memset(receivedPackets, 0, 65536 * sizeof(unsigned long));
+			}
+			else if (receivedPackets[internalPacket->packetNumber] > time - TIMEOUT_TIME) 
 				// I can receive RECEIVED_PACKET_LOG_LENGTH packets per TIMEOUT_TIME seconds before overrun on timestamps
 			{
 				// SHOW - duplicate packets
-				//printf("Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n",internalPacket->packetNumber);
+#ifdef _DEBUG
+				// printf("Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n",internalPacket->packetNumber);
+				// testing
+				//printf("Got duplicate packet\n");
+#endif
 
+				statistics.duplicateMessagesReceived++;
+
 				// Duplicate packet
 				delete [] internalPacket->data;
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 				goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 			}
 
+
+			statistics.messagesReceived++;
+
 			// Record that this particular packet was received at this time
 			receivedPackets[internalPacket->packetNumber]=time;
 
+			// Keep on top of deleting old unreliable split packets so they don't clog the list.
+			if (internalPacket->splitPacketCount>0)
+				DeleteOldUnreliableSplitPackets(time);
+
 			if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==UNRELIABLE_SEQUENCED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket->orderingStream < NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
+#ifdef _DEBUG
+					printf("Got invalid packet\n");
+#endif
 					delete [] internalPacket->data;
 					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (IsOlderOrderedPacket(internalPacket->orderingIndex, waitingForSequencedPacketReadIndex[internalPacket->orderingStream])==false)
+				if (IsOlderOrderedPacket(internalPacket->orderingIndex, waitingForSequencedPacketReadIndex[internalPacket->orderingChannel])==false)
 				{
+					statistics.sequencedMessagesInOrder++;
 
 					// Check for older packets in the output list.  Delete any found
 					// UPDATE:
@@ -351,12 +453,12 @@
 					// don't need the older ones because the odds are they will still arrive in order
 					/*
 					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket->orderingStream, outputQueue);
+					DeleteSequencedPacketsInList(internalPacket->orderingChannel, outputQueue);
 					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 					// Check for older packets in the split packet list.  Delete any found
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket->orderingStream, splitPacketList, internalPacket->splitPacketId);
+					DeleteSequencedPacketsInList(internalPacket->orderingChannel, splitPacketList, internalPacket->splitPacketId);
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 */
 					// Is this a split packet?
@@ -368,43 +470,42 @@
 						assert(internalPacket->splitPacketIndex < internalPacket->splitPacketCount);
 						assert(internalPacket->dataBitLength < MAXIMUM_MTU_SIZE*8);
 
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 						// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 						for (unsigned cnt=0; cnt < splitPacketList.size(); cnt++)
 							assert (!(splitPacketList[cnt]->splitPacketIndex==internalPacket->splitPacketIndex && splitPacketList[cnt]->splitPacketId==splitPacketId));
 						int splitPacketListSize = splitPacketList.size()+1;
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						#endif
 
 						// Check for a rebuilt packet
 						InsertIntoSplitPacketList(internalPacket);
 
 						// Sequenced
-						internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId);
+						internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId,time);
 
 						if (internalPacket)
 						{
 #ifdef _DEBUG
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize-internalPacket->splitPacketCount );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 							// Update our index to the newest packet
-							waitingForSequencedPacketReadIndex[internalPacket->orderingStream]=internalPacket->orderingIndex+1;
+							waitingForSequencedPacketReadIndex[internalPacket->orderingChannel]=internalPacket->orderingIndex+1;
 
 							// If there is a rebuilt packet, add it to the output queue
-							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 							outputQueue.push(internalPacket);
-							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 							internalPacket=0;
 						}
 #ifdef _DEBUG
 						else
 						{
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						}
 #endif
 						// else don't have all the parts yet
@@ -412,18 +513,19 @@
 					else
 					{
 						// Update our index to the newest packet
-						waitingForSequencedPacketReadIndex[internalPacket->orderingStream]=internalPacket->orderingIndex+1;
+						waitingForSequencedPacketReadIndex[internalPacket->orderingChannel]=internalPacket->orderingIndex+1;
 
 						// Not a split packet. Add the packet to the output queue
-						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 						outputQueue.push(internalPacket);
-						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 						internalPacket=0;
 					}
 				}
 				else
 				{
+					statistics.sequencedMessagesOutOfOrder++;
+					
 					// Older sequenced packet.  Discard it
 					delete [] internalPacket->data;
 					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
@@ -445,26 +547,26 @@
 
 				// Check for a rebuilt packet
 				if (internalPacket->reliability!=RELIABLE_ORDERED)
-					internalPacket->orderingStream=255; // Use 255 to designate not sequenced and not ordered
+					internalPacket->orderingChannel=255; // Use 255 to designate not sequenced and not ordered
 
 #ifdef _DEBUG
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 				// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 				for (unsigned cnt=0; cnt < splitPacketList.size(); cnt++)
 					assert (!(splitPacketList[cnt]->splitPacketIndex==internalPacket->splitPacketIndex && splitPacketList[cnt]->splitPacketId==internalPacket->splitPacketId));
 				int splitPacketListSize = splitPacketList.size()+1;
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 				InsertIntoSplitPacketList(internalPacket);
 
-				internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId);
+				internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId,time);
 
 				if (internalPacket==0)
 				{
 					#ifdef _DEBUG
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 					#endif
 
 					// Don't have all the parts yet
@@ -473,9 +575,9 @@
 				#ifdef _DEBUG
 				else
 				{
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize-internalPacket->splitPacketCount );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				}
 				#endif
 				// else continue down to handle RELIABLE_ORDERED
@@ -484,9 +586,9 @@
 			if (internalPacket->reliability==RELIABLE_ORDERED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket->orderingStream < NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
 					delete [] internalPacket->data;
@@ -494,27 +596,29 @@
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (waitingForOrderedPacketReadIndex[internalPacket->orderingStream]==internalPacket->orderingIndex)
+				if (waitingForOrderedPacketReadIndex[internalPacket->orderingChannel]==internalPacket->orderingIndex)
 				{
 					// Get the list to hold ordered packets for this stream
 					BasicDataStructures::LinkedList<InternalPacket*> *orderingListAtOrderingStream;
-					unsigned char orderingStreamCopy=internalPacket->orderingStream;
+					unsigned char orderingChannelCopy=internalPacket->orderingChannel;
 
+					statistics.orderedMessagesInOrder++;
+
 					// Push the packet for the user to read
-					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 					outputQueue.push(internalPacket);
-					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 					internalPacket=0; // Don't reference this any longer since other threads access it
 
 					// Wait for the next ordered packet in sequence
-					waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+					waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
-					reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingStreamCopy);
+					//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingChannelCopy);
 
 					if (orderingListAtOrderingStream!=0)
 					{
-						// There is a list for this ordering stream that may contain waiting packets.  Pop them in order
+						// There is a list for this ordering channel that may contain waiting packets.  Pop them in order
 
 						// Scan the list and pop packets that were delayed due to ordering in order
 						while (orderingListAtOrderingStream->size()>0)
@@ -524,18 +628,18 @@
 							pushedPacket=false;
 							while (count!=0)
 							{
-								if (orderingListAtOrderingStream->peek()->orderingIndex == waitingForOrderedPacketReadIndex[orderingStreamCopy])
+								if (orderingListAtOrderingStream->peek()->orderingIndex == waitingForOrderedPacketReadIndex[orderingChannelCopy])
 								{
 									// A packet was waiting, so output it in order.
 									// This is already mutexed above
 
 									// Push the packet for the user to read
-									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 									outputQueue.push(orderingListAtOrderingStream->pop());
-									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 									// Wait for the next ordered packet in sequence
-									waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+									waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
 									pushedPacket=true;
 
@@ -553,12 +657,14 @@
 						}
 
 					}
-					reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 
 					internalPacket=0;
 				}
 				else
 				{
+					statistics.orderedMessagesOutOfOrder++;
+
 					// This is a newer ordered packet than we are waiting for.  Store it for future use
 					AddToOrderingList(internalPacket);
 				}
@@ -567,13 +673,13 @@
 			}
 
 			// Nothing special about this packet.  Add it to the output queue
-			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 			outputQueue.push(internalPacket); 
-			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 			// Output queue fill rate test
 //			if (outputQueue.size()%50==0)
-//				printf("outputQueue.size()=%i Time=%i\n", outputQueue.size(), getTime());
+//				printf("outputQueue.size()=%i Time=%i\n", outputQueue.size(), RakNetGetTime());
 
 			internalPacket=0;
 		}
@@ -581,12 +687,15 @@
 		// Used for a goto to jump to the next packet immediately
 		CONTINUE_SOCKET_DATA_PARSE_LOOP:
 		// Parse the bitstream to create an internal packet
-		internalPacket = CreateInternalPacketFromBitStream(&socketData);
+		internalPacket = CreateInternalPacketFromBitStream(&socketData,time);
 	}
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-	if (numberOfAcksInFrame>=windowSize && sendQueue[HIGH_PRIORITY].size()>0)
+
+	// numberOfAcksInFrame>=windowSize is almost never true
+	if (numberOfAcksInFrame>=windowSize && (sendQueue[SYSTEM_PRIORITY].size()>0 || sendQueue[HIGH_PRIORITY].size()>0 || sendQueue[MEDIUM_PRIORITY].size()>0))
 	{
+
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 		if (windowSize < lossyWindowSize || time - lastWindowIncreaseSizeTime > lostPacketResendDelay*2) // Increases the window size slowly, testing for packetloss
 		{
 			// If we get a frame which clears out the resend queue after handling one or more acks, and we have packets waiting to go out,
@@ -607,8 +716,8 @@
 			if (windowSize==MAXIMUM_WINDOW_SIZE || windowSize - lossyWindowSize > 5)
 				lossyWindowSize++;
 		}
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 	}
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return true;
 }
@@ -620,14 +729,14 @@
 {
 	InternalPacket* internalPacket;
 
-	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 	if (outputQueue.size()>0)
 	{
-//		#ifdef _DEBUG
-//		assert(bitStream->GetNumberOfBitsUsed()==0);
-//		#endif
+		//		#ifdef _DEBUG
+		//		assert(bitStream->GetNumberOfBitsUsed()==0);
+		//		#endif
 		internalPacket = outputQueue.pop();
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 		//printf("In Receive %i bytes\n",(internalPacket->dataBitLength-1)/8+1);
 		//for (int ass=0; ass < (internalPacket->dataBitLength-1)/8+1 && ass < 10; ass++)
@@ -644,9 +753,10 @@
 	}
 	else
 	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 		return 0;
 	}
+	
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -654,14 +764,14 @@
 // bitStream contains the data to send
 // priority is what priority to send the data at
 // reliability is what reliability to use
-// ordering stream is from 0 to 255 and specifies what stream to use
+// ordering channel is from 0 to 255 and specifies what stream to use
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize)
+bool ReliabilityLayer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize)
 {
 	#ifdef _DEBUG
 	assert(!(reliability > RELIABLE_SEQUENCED || reliability < 0));
 	assert(!(priority > NUMBER_OF_PRIORITIES || priority < 0));
-	assert(!(orderingStream < 0 || orderingStream >= NUMBER_OF_ORDERED_STREAMS));
+	assert(!(orderingChannel < 0 || orderingChannel >= NUMBER_OF_ORDERED_STREAMS));
 	assert(bitStream->GetNumberOfBytesUsed()>0);
 	#endif
 
@@ -677,8 +787,8 @@
 	if (priority > NUMBER_OF_PRIORITIES || priority < 0)
 		priority = HIGH_PRIORITY;
 
-	if (orderingStream >= NUMBER_OF_ORDERED_STREAMS)
-		orderingStream=0;
+	if (orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
+		orderingChannel=0;
 
 	if (bitStream->GetNumberOfBytesUsed()==0)
 	{
@@ -694,7 +804,7 @@
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket->creationTime=getTime();
+	internalPacket->creationTime=RakNetGetTime();
 	if (makeDataCopy)
 	{
 		internalPacket->data = new char [bitStream->GetNumberOfBytesUsed()];
@@ -722,33 +832,27 @@
 
 	// If a split packet, we might have to upgrade the reliability
 	if (splitPacket)
-	{
-		// Split packets must be sent reliably.  Otherwise not all the parts might arrive
-		if (internalPacket->reliability==UNRELIABLE)
-			internalPacket->reliability=RELIABLE;
-		else if (internalPacket->reliability==UNRELIABLE_SEQUENCED)
-			internalPacket->reliability=RELIABLE_SEQUENCED;
-	}
+		statistics.numberOfSplitMessages++;
+	else
+		statistics.numberOfUnsplitMessages++;
 
 	// Increment the cyclical receivedPacketsIndex for use by the next packet.
 	// This variable is used as the identifier of the packet on the remote machine.
 	// When it cycles it will reuse older numbers but that is ok because by the time it
 	// cycles those older packets will be pretty much guaranteed to arrive by then
-	reliabilityLayerMutexes[packetNumber_MUTEX].Lock();
-	if (++packetNumber==RECEIVED_PACKET_LOG_LENGTH)
-		packetNumber=0;
-	reliabilityLayerMutexes[packetNumber_MUTEX].Unlock();
-
+	
+	IncrementPacketNumber(internalPacket->creationTime);
+	
 	if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==UNRELIABLE_SEQUENCED)
 	{
 		// Assign the sequence stream and index
-		internalPacket->orderingStream=orderingStream;
+		internalPacket->orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Lock();
-		internalPacket->orderingIndex=waitingForSequencedPacketWriteIndex[orderingStream]++;
+		internalPacket->orderingIndex=waitingForSequencedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Unlock();
 
-		// This packet supercedes all other sequenced packets on the same ordering stream
-		// Delete all packets in all send lists that are sequenced and on the same ordering stream
+		// This packet supercedes all other sequenced packets on the same ordering channel
+		// Delete all packets in all send lists that are sequenced and on the same ordering channel
 		// UPDATE:
 		// Disabled.  We don't have enough info to consistently do this.  Sometimes newer data does supercede
 		// older data such as with constantly declining health, but not in all cases.
@@ -758,30 +862,30 @@
 		for (int i=0; i < NUMBER_OF_PRIORITIES; i++)
 		{
 			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-			DeleteSequencedPacketsInList(orderingStream, sendQueue[i]);
+			DeleteSequencedPacketsInList(orderingChannel, sendQueue[i]);
 			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
 		}
 		*/
 	}
 	else if (internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// Assign the ordering stream and index
-		internalPacket->orderingStream=orderingStream;
+		// Assign the ordering channel and index
+		internalPacket->orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Lock();
-		internalPacket->orderingIndex=waitingForOrderedPacketWriteIndex[orderingStream]++;
+		internalPacket->orderingIndex=waitingForOrderedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Unlock();
 	}
 
 	if (splitPacket) // If it uses a secure header it will be generated here
 	{
 		// Must split the packet.  This will also generate the SHA1 if it is required.  It also adds it to the send list.
-		SplitPacketAndDeleteOriginal(internalPacket, MTUSize);
+		SplitPacketAndDeleteOriginal(internalPacket, MTUSize, internalPacket->creationTime);
 		return true;
 	}
 	
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Lock();
     sendQueue[internalPacket->priority].push(internalPacket);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Unlock();
 
 	return true;
 }
@@ -789,27 +893,35 @@
 //-------------------------------------------------------------------------------------------------------
 // Run this once per game cycle.  Handles internal lists and actually does the send
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize)
+void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time)
 {
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 		return;
 #endif
-//	unsigned resendQueueSize;
+	//	unsigned resendQueueSize;
 	bool reliableDataSent;
 	unsigned long lastAck;
 
+	if (freeThreadedMemoryOnNextUpdate)
+	{
+		freeThreadedMemoryOnNextUpdate=false;
+		FreeThreadedMemory();
+	}
+
 	// Accuracy isn't important on this value, and since this is called so often the mutex is sometimes causing deadlock problems.
 	// So it is presently disabled
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //	resendQueueSize=resendQueue.size();
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	lastAck=lastAckTime;
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
-	if (resendQueue.size()>0 && lastAck && getTime() - lastAck > TIMEOUT_TIME)
+	// Due to thread vagarities and the way I store the time to avoid slow calls to RakNetGetTime
+	// time may be less than lastAck
+	if (resendQueue.size()>0 && time > lastAck && lastAck && time - lastAck > TIMEOUT_TIME)
 	{
 		// SHOW - dead connection
 		// printf("The connection has been lost.\n");
@@ -818,7 +930,7 @@
 		return;
 	}
 
-	//if (outputWindowFullTime && getTime() > TIMEOUT_TIME + outputWindowFullTime)
+	//if (outputWindowFullTime && RakNetGetTime() > TIMEOUT_TIME + outputWindowFullTime)
 	//{
 	//	// We've waited a long time with no data from the other system.  Assume the connection is lost
 	//	deadConnection=true;
@@ -827,29 +939,60 @@
 
 	// Not a frame but a packet actually.
 	// However, in a sense it is a frame because we are filling multiple logical packets into one datagram
-	if (IsFrameReady())
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+
+	// Keep sending to available bandwidth
+	while (IsFrameReady(time))
 	{
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+		updateBitStream.Reset();
+		GenerateFrame(&updateBitStream, MTUSize, &reliableDataSent,time);
+		if (updateBitStream.GetNumberOfBitsUsed()>0)
+		{
+#ifndef _INTERNET_SIMULATOR
+			SendBitStream(s, playerId, &updateBitStream);
+#else
+			// Delay the send to simulate lag
+			DataAndTime *dt;
+			dt=new DataAndTime;
+			memcpy(dt->data, updateBitStream.GetData(), updateBitStream.GetNumberOfBytesUsed());
+			dt->length=updateBitStream.GetNumberOfBytesUsed();
+			dt->sendTime=time+100+(randomMT()%100);
+			delayList.insert(dt);
+#endif
+		}
+		else
+			break;
+	}
+	
 
-		do
+#ifdef _INTERNET_SIMULATOR
+	// Do any lagged sends
+	unsigned i=0;
+	while (i < delayList.size())
+	{
+		if (delayList[i]->sendTime<time)
 		{
 			updateBitStream.Reset();
-			GenerateFrame(&updateBitStream, MTUSize, &reliableDataSent);
-			if (updateBitStream.GetNumberOfBitsUsed()>0)
-			{
-				SendBitStream(s, playerId, &updateBitStream);
-			}
+			updateBitStream.Write(delayList[i]->data, delayList[i]->length);
+			// Send it now
+			SendBitStream(s, playerId, &updateBitStream);
 
-		} while (updateBitStream.GetNumberOfBitsUsed()>0 && IsFrameReady());
+			delete delayList[i];
+			delayList[i]=delayList[delayList.size()-1];
+			delayList.del();
+		}
+		else
+			i++;
+	}
+#endif
 
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
-	}
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Writes a bitstream to the socket
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream)
+void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream)
 {
  // SHOW - showing reliable flow
 //	if (bitStream->GetNumberOfBytesUsed()>50)
@@ -857,15 +1000,19 @@
 
 	int oldLength, length;
 
-	sentFrames++;
+//	sentFrames++;
 
 #ifdef _INTERNET_SIMULATOR
+
+	/*
 	// packetloss
-	if (randomMT() %100 <=10)
+	if (windowSize>MINIMUM_WINDOW_SIZE && frandomMT() <= (float)(windowSize-MINIMUM_WINDOW_SIZE)/(float)(MAXIMUM_WINDOW_SIZE-MINIMUM_WINDOW_SIZE))
 	{
-		lastPacketSendTime=getTime();
+		// printf("Frame %i lost\n", sentFrames);
+		lastPacketSendTime=RakNetGetTime();
 		return;
 	}
+	*/
 #endif
 
 
@@ -874,64 +1021,68 @@
 	{
 		length = bitStream->GetNumberOfBytesUsed();
 		oldLength = length;
+
 		encryptor.Encrypt((unsigned char*)bitStream->GetData(), length, (unsigned char*)bitStream->GetData(), &length);
+		statistics.encryptionBitsSent=(length-oldLength)*8;
 
-		if (encryptor.IsKeySet())
-			bytesSent+=length - oldLength;
+		// TODO - put back in
+		assert((length % 16 )== 0);
 	}
 	else
 	{
 		length = bitStream->GetNumberOfBytesUsed();
 	}
 
-
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 	{
-		assert(0);
-		return;
+		assert(0);	return;
 	}
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
 	SocketLayer::Instance()->Write(readWriteSocket, (const char*)bitStream->GetData(), length);
 #else
-    SocketLayer::Instance()->SendTo(s, (char*)bitStream->GetData(), length, playerId);
-#endif
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
+	//printf("total bits=%i length=%i\n", BITS_TO_BYTES(statistics.totalBitsSent), length);
+    SocketLayer::Instance()->SendTo(s, (char*)bitStream->GetData(), length, playerId.binaryAddress, playerId.port);
+#endif // __USE_IO_COMPLETION_PORTS
 
-	lastPacketSendTime=getTime();
+//	lastPacketSendTime=time;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Returns true if we can or should send a frame.  False if we should not
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::IsFrameReady(void)
+bool ReliabilityLayer::IsFrameReady(unsigned long time)
 {
 	if (IsSendThrottled()==false)
 		return true;
 
-	unsigned long time = getTime();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-
 	// Any acknowledgement packets waiting?  We will send these even if the send is throttled.
 	// Otherwise the throttle may never end
-	if (acknowledgementQueue.size()>0 &&
-		(acknowledgementQueue.size() >= MINIMUM_WINDOW_SIZE ||
-		acknowledgementQueue.peek()->nextActionTime < time))
+	if (acknowledgementQueue.size() >= MINIMUM_WINDOW_SIZE
+		// Try not waiting to send acks - will take more bandwidth but maybe less packetloss
+		// || acknowledgementQueue.peek()->nextActionTime < time
+		)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 		return true;
 	}
 	
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 	// Does the oldest packet need to be resent?  If so, send it.
 	// Otherwise the throttle may never end
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	if (resendQueue.size()>0 && resendQueue.peek() && resendQueue.peek()->nextActionTime < time)
 	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 		return true;
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 	// Send is throttled.  Don't send.
 	return false;
@@ -940,13 +1091,13 @@
 //-------------------------------------------------------------------------------------------------------
 // Generates a frame (coalesced packets)
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent)
+
+void ReliabilityLayer::GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time)
 {
 	InternalPacket *internalPacket;
 	int maxDataBitSize;
 	int reliableBits=0;
 	int nextPacketBitLength;
-	unsigned long time;
 	unsigned i;
 	bool isReliable,onlySendUnreliable;
 	bool acknowledgementPacketsSent;
@@ -959,11 +1110,11 @@
 
 	acknowledgementPacketsSent=false;
 
-	time = getTime();
 	*reliableDataSent=false;
+	
 
 	// Packet acknowledgements always go out first if they are overdue or if there are a lot of them
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Lock();
 	if (acknowledgementQueue.size()>0 &&
 		(acknowledgementQueue.size() >=MINIMUM_WINDOW_SIZE ||
@@ -971,110 +1122,114 @@
 	{
 		do
 		{
-
 			//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Unlock();
 			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+			statistics.acknowlegementsSent++;
+			statistics.acknowlegementBitsSent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			acknowledgementPacketsSent=true;
 
 			// Delete the acknowledgement
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			if (	output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
+			if (output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
 			{
-
 				// SHOW - show ack
-		//		printf("Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+				//printf("Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
+				statistics.packetsContainingOnlyAcknowlegements++;
 				goto END_OF_GENERATE_FRAME;
 			}
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 		} while(acknowledgementQueue.size() > 0);
 	}
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
+	
+
 	// SHOW - show ack
 	//if (output->GetNumberOfBitsUsed()>0)
-		//printf("Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+	//	printf("Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-	while (resendQueue.size() > 0 && (resendQueue.peek()==0 || resendQueue.peek()->nextActionTime < time))
+	while (resendQueue.size() > 0)
 	{
-		// Copy the first packet out of the resend list
-		internalPacket = resendQueue.pop();
-
-		if (internalPacket==0)
+		if (resendQueue.peek()==0)
+		{
+			resendQueue.pop();
 			continue; // This was a hole
+		}
 
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		if (resendQueue.peek()->nextActionTime < time)
+		{
+			internalPacket = resendQueue.pop();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			// Testing
+			//printf("Resending %i. queue size = %i\n", internalPacket->packetNumber, resendQueue.size());
 
-		nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
+			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
 
-		if (	output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
-		{
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			if (output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
+			{
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-			if (anyPacketsLost)
-			{
-				// The window size will decrease everytime we have to retransmit a frame
-				reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-				if (--windowSize < MINIMUM_WINDOW_SIZE)
-					windowSize=MINIMUM_WINDOW_SIZE;
-				reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-				lossyWindowSize=windowSize;
-				lastWindowIncreaseSizeTime=time;  // This will block the window size from increasing immediately
-				// SHOW - windowing
-				//printf("Frame lost.  New window size = %i.  Lossy window size = %i\n", windowSize, lossyWindowSize);
+				if (anyPacketsLost)
+				{
+					UpdatePacketloss(time);
+				}
+
+				goto END_OF_GENERATE_FRAME;
 			}
 
-			goto END_OF_GENERATE_FRAME;
-		}
+#ifdef _DEBUG
+			assert(internalPacket->priority>=0);
+			assert(internalPacket->reliability>=0);
+#endif
 
-		#ifdef _DEBUG
-		assert(internalPacket->priority>=0);
-		assert(internalPacket->reliability>=0);
-		#endif
+			// SHOW - show resends
+			//printf("Resending packet. resendQueue.size()=%i. Data=%s\n",resendQueue.size(), internalPacket->data);
 
-		// SHOW - show resends
-		//printf("Resending packet. resendQueue.size()=%i. Data=%s\n",resendQueue.size(), internalPacket->data);
+			// Write to the output bitstream
+//			sentPackets++;
+			statistics.messageResends++;
+			statistics.messageDataBitsResent+=internalPacket->dataBitLength;
 
-		// Write to the output bitstream
-		sentPackets++;
-		WriteToBitStreamFromInternalPacket(output, internalPacket);
-		*reliableDataSent=true;
+			statistics.messagesTotalBitsResent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
+			*reliableDataSent=true;
 
-		// Update packetloss
-		UpdatePacketloss();
-		anyPacketsLost=true;
+			//		if (output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
+			//			printf("Frame full of just acks and resends at time %i.\n", RakNetGetTime());
 
-		reliableBits+=internalPacket->dataBitLength;
-		internalPacket->nextActionTime = time + lostPacketResendDelay;
+			statistics.packetsContainingOnlyAcknowlegementsAndResends++;
 
-		// Put the packet back into the resend list at the correct spot
-		InsertPacketIntoResendQueue(internalPacket);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			anyPacketsLost=true;
+			internalPacket->nextActionTime = time + lostPacketResendDelay;
+
+			// Put the packet back into the resend list at the correct spot
+			InsertPacketIntoResendQueue(internalPacket, time);
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+
+		}
+		else
+		{
+			break;
+		}
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
+	
+
 	if (anyPacketsLost)
 	{
-		// The window size will decrease everytime we have to retransmit a frame
-		reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-		if (--windowSize < MINIMUM_WINDOW_SIZE)
-			windowSize=MINIMUM_WINDOW_SIZE;
-		reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-		lossyWindowSize=windowSize;
-		lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
-		// SHOW - windowing
-		//printf("Frame lost.  New window size = %i.  Lossy window size = %i\n", windowSize, lossyWindowSize);
+		// Update packetloss
+		UpdatePacketloss(time);
 	}
 
 	onlySendUnreliable=false;
@@ -1085,18 +1240,27 @@
 	// From highest to lowest priority, fill up the output bitstream from the send lists
 	for (i=0; i < NUMBER_OF_PRIORITIES; i++)
 	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	//	if (i==LOW_PRIORITY && sendQueue[LOW_PRIORITY].size() > 0 && (sendQueue[LOW_PRIORITY].size()%100)==0)
+	//	{
+	//		printf("%i\n", sendQueue[LOW_PRIORITY].size());
+	//	}
+
+		// Not mutexed - may give a wrong value if another thread is inserting something but it's ok
+		// Because we can avoid a slow mutex call a lot of the time
+		if (sendQueue[i].size()==0)
+			continue;
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		while (sendQueue[i].size())
 		{
 			internalPacket = sendQueue[i].pop();
-			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
 
-			if (	output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
+			if (output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
 			{
 				// This output won't fit.
-				reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+				reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 				sendQueue[i].pushAtHead(internalPacket); // Push this back at the head so it is the next thing to go out
 				break;
 			}
@@ -1107,14 +1271,17 @@
 				isReliable=false;
 
 			// Write to the output bitstream
-			sentPackets++;
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+//			sentPackets++;
+			statistics.messagesSent[i]++;
+			statistics.messageDataBitsSent[i]+=internalPacket->dataBitLength;
+			statistics.messageTotalBitsSent[i]+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			if (isReliable)
 			{
 				// Reliable packets are saved to resend later
 				reliableBits+=internalPacket->dataBitLength;
 				internalPacket->nextActionTime = time + lostPacketResendDelay;
-				InsertPacketIntoResendQueue(internalPacket);
+				//printf("Resending at %i\n", internalPacket->nextActionTime);
+				InsertPacketIntoResendQueue(internalPacket, time);
 
 				*reliableDataSent=true;
 			}
@@ -1125,44 +1292,48 @@
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 			}
 
-			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		}
 
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 	}
 
 	// Optimization - if we sent data but didn't send an acknowledgement packet previously then send them now
 	if (acknowledgementPacketsSent==false && output->GetNumberOfBitsUsed()>0)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while(output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH < maxDataBitSize && acknowledgementQueue.size() > 0)
+		if (acknowledgementQueue.size() > 0)
 		{
-			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			while(output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH < maxDataBitSize && acknowledgementQueue.size() > 0)
+			{
+				internalPacket = acknowledgementQueue.pop();
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
-			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+				// Write the acknowledgement to the output bitstream
+				WriteToBitStreamFromInternalPacket(output, internalPacket);
 
-			// Delete the acknowledgement
-			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				// Delete the acknowledgement
+				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		} 
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			} 
 
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		}
 	}
 
 END_OF_GENERATE_FRAME:
+;
 
-
-	if (output->GetNumberOfBitsUsed()>0)
-	{
+//	if (output->GetNumberOfBitsUsed()>0)
+//	{
 		// Update the throttle with the header
-		bytesSent+=output->GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
-	}
+//		bytesSent+=output->GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
+	//}
 }
 
+
 //-------------------------------------------------------------------------------------------------------
 // This will return true if we should not send at this time
 //-------------------------------------------------------------------------------------------------------
@@ -1170,9 +1341,9 @@
 {
 	int win;
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 	win = windowSize;
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return (int)resendQueue.size() >=win;
 }
@@ -1180,9 +1351,9 @@
 //-------------------------------------------------------------------------------------------------------
 // We lost a packet
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::UpdatePacketloss(void)
+void ReliabilityLayer::UpdatePacketloss(unsigned long time)
 {
-//	unsigned long time = getTime();
+//	unsigned long time = RakNetGetTime();
 	/*
 	maximumWindowSize = (unsigned int)((double)maximumWindowSize * DECREASE_THROUGHPUT_DELTA);
 	if (maximumWindowSize < MINIMUM_THROUGHPUT)
@@ -1197,7 +1368,18 @@
 
 
 //	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-	retransmittedPackets++;
+//	retransmittedFrames++;
+
+	// The window size will decrease everytime we have to retransmit a frame
+	//reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+	if (--windowSize < MINIMUM_WINDOW_SIZE)
+		windowSize=MINIMUM_WINDOW_SIZE;
+	//reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+	lossyWindowSize=windowSize;
+	lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
+	// SHOW - windowing
+//	if (resendQueue.size()>0)
+//		printf("Frame lost.  New window size = %i.  Lossy window size = %i. Time=%i. Next send time=%i\n", windowSize, lossyWindowSize, RakNetGetTime(),resendQueue.peek()->nextActionTime);
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1207,46 +1389,52 @@
 {
 	InternalPacket *internalPacket;
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	for (unsigned i=0; i < resendQueue.size(); i ++)
 	{
 		if (resendQueue[i] && packetNumber==resendQueue[i]->packetNumber)
 		{
+			// Found what we wanted to ack
+			statistics.acknowlegementsReceived++;
+
 			if (i==0)
 				internalPacket=resendQueue.pop();
 			else
 			{
+				
 				// Generate a hole
 				internalPacket = resendQueue[i];
+				// testing
+			//	printf("Removing packet %i from resend\n", internalPacket->packetNumber);
 				resendQueue[i]=0;
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 			// Save some of the data of the packet
 			reliability=internalPacket->reliability;
-			orderingStream=internalPacket->orderingStream;
+			orderingChannel=internalPacket->orderingChannel;
 			orderingIndex=internalPacket->orderingIndex;
 
 			// Delete the packet
 			delete [] internalPacket->data;
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering stream.
+			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering channel.
 			// This is because we no longer need to send these.
 			if (reliability==RELIABLE_SEQUENCED)
 			{
 				unsigned j=0;
 
-				reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 				while (j < resendQueue.size())
 				{
 					internalPacket = resendQueue[j];
-					if (internalPacket && internalPacket->reliability==RELIABLE_SEQUENCED && internalPacket->orderingStream==orderingStream && IsOlderOrderedPacket(internalPacket->orderingIndex, orderingIndex))
+					if (internalPacket && internalPacket->reliability==RELIABLE_SEQUENCED && internalPacket->orderingChannel==orderingChannel && IsOlderOrderedPacket(internalPacket->orderingIndex, orderingIndex))
 					{
 						// Delete the packet
 						delete [] internalPacket->data;
@@ -1256,21 +1444,24 @@
 
 					j++;
 				}
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			break;
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			return;
 		}
 	}
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+
+	// Didn't find what we wanted to ack
+	statistics.duplicateAcknowlegementsReceived++;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Acknowledge receipt of the packet with the specified packetNumber
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber)
+void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time)
 {
 	InternalPacket *internalPacket;
 
@@ -1303,16 +1494,16 @@
 	internalPacket->packetNumber=packetNumber;
 	internalPacket->isAcknowledgement=true;
 
-	internalPacket->creationTime = getTime();
+	internalPacket->creationTime = time;
 	// We send this acknowledgement no later than 1/4 the time the remote 
 	//machine would send the original packet again
 	// DEBUG
-	internalPacket->nextActionTime = internalPacket->creationTime + lostPacketResendDelay/4;
+	internalPacket->nextActionTime = internalPacket->creationTime + (lostPacketResendDelay>>2);
 	//internalPacket->nextActionTime = internalPacket->creationTime;
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	acknowledgementQueue.push(internalPacket);
-//	printf("<Server>Adding ack at time %i. acknowledgementQueue.size=%i\n",getTime(), acknowledgementQueue.size());
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	printf("<Server>Adding ack at time %i. acknowledgementQueue.size=%i\n",RakNetGetTime(), acknowledgementQueue.size());
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1338,11 +1529,11 @@
 	//bitStream->WriteBits((unsigned char*)&(internalPacket->reliability), 3, true);
 	bitLength+=3;
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		//bitStream->WriteBits((unsigned char*)&(internalPacket->orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		//bitStream->WriteBits((unsigned char*)&(internalPacket->orderingChannel), 5, true);
 		// -- bitLength+=5;
 
 		// ordering index is one byte
@@ -1381,14 +1572,22 @@
 //-------------------------------------------------------------------------------------------------------
 // Parse an internalPacket and create a bitstream to represent this data
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket)
+int ReliabilityLayer::WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket)
 {
 	#ifdef _DEBUG
 	assert(bitStream && internalPacket);
 	#endif
 
-	bitStream->AlignWriteToByteBoundary();
+	int start=bitStream->GetNumberOfBitsUsed();
 
+// testing
+//	if (internalPacket->reliability==UNRELIABLE)
+//		printf("Sending unreliable packet %i\n", internalPacket->packetNumber);
+//	else if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
+//		printf("Sending reliable packet number %i\n", internalPacket->packetNumber);
+
+	//bitStream->AlignWriteToByteBoundary();
+
 	// Write the packet number (2 bytes)
 	bitStream->Write(internalPacket->packetNumber);
 
@@ -1396,7 +1595,9 @@
 	bitStream->Write(internalPacket->isAcknowledgement);
 	// Acknowledgement packets have no more data than the packetnumber and whether it is an acknowledgement
 	if (internalPacket->isAcknowledgement)
-		return;
+	{
+		return bitStream->GetNumberOfBitsUsed()-start;
+	}
 
 	#ifdef _DEBUG
 	assert(internalPacket->dataBitLength>0);
@@ -1406,11 +1607,11 @@
 	unsigned char reliability = (unsigned char)internalPacket->reliability;
 	bitStream->WriteBits((unsigned char*)(&(reliability)), 3, true);
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStream->WriteBits((unsigned char*)&(internalPacket->orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStream->WriteBits((unsigned char*)&(internalPacket->orderingChannel), 5, true);
 
 		// ordering index is one byte
 		bitStream->Write(internalPacket->orderingIndex);
@@ -1433,30 +1634,35 @@
 	#endif
 	unsigned short length = (unsigned short) internalPacket->dataBitLength; // Ignore the 2 high bytes for WriteBits
 
-	bitStream->Write(length);
+	bitStream->WriteCompressed(length);
 
 	// Write the actual data.
 	bitStream->WriteAlignedBytes((unsigned char*)internalPacket->data, BITS_TO_BYTES(internalPacket->dataBitLength));
+	//bitStream->WriteBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
+
+	return bitStream->GetNumberOfBitsUsed()-start;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Parse a bitstream and create an internal packet to represent this data
 //-------------------------------------------------------------------------------------------------------
-InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(BitStream *bitStream)
+InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time)
 {
-	if (bitStream->GetNumberOfUnreadBits() < 8)
+	bool bitStreamSucceeded;
+	InternalPacket* internalPacket;
+
+	if (bitStream->GetNumberOfUnreadBits() < sizeof(internalPacket->packetNumber)*8)
 		return 0; // leftover bits
-
-	bool bitStreamSucceeded;
-	InternalPacket* internalPacket = InternalPacketPool::Instance()->GetPointer();
+	
+	internalPacket = InternalPacketPool::Instance()->GetPointer();
 #ifdef _DEBUG
 	// Remove boundschecker accessing undefined memory error
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket->creationTime=getTime();
+	internalPacket->creationTime=time;
 
-	bitStream->AlignReadToByteBoundary();
+	//bitStream->AlignReadToByteBoundary();
 
 	// Read the packet number (2 bytes)
 	bitStreamSucceeded = bitStream->Read(internalPacket->packetNumber);
@@ -1484,11 +1690,11 @@
 #endif
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 
-	// If the reliability requires an ordering stream and ordering index, we read those.
+	// If the reliability requires an ordering channel and ordering index, we read those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStreamSucceeded = bitStream->ReadBits((unsigned char*)&(internalPacket->orderingStream), 5);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStreamSucceeded = bitStream->ReadBits((unsigned char*)&(internalPacket->orderingChannel), 5);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
 #endif
@@ -1511,7 +1717,7 @@
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 	if (isSplitPacket)
 	{
-		// split packet indices are one byte (so one packet can be split up to 65535 times - maximum packet size would be about 500 * 65535)
+		// split packet indices are one byte (so one packet can be split ufp to 65535 times - maximum packet size would be about 500 * 65535)
 		bitStreamSucceeded = bitStream->Read(internalPacket->splitPacketId);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
@@ -1538,7 +1744,7 @@
 
 	
 	unsigned short length;
-	bitStreamSucceeded = bitStream->Read(length);
+	bitStreamSucceeded = bitStream->ReadCompressed(length);
 	// Read into an unsigned short.  Otherwise the data would be offset too high by two bytes
 #ifdef _DEBUG
 	assert(bitStreamSucceeded);
@@ -1556,6 +1762,7 @@
 	internalPacket->data[BITS_TO_BYTES(internalPacket->dataBitLength)-1]=0;
 	// Read the data the packet holds
 	bitStreamSucceeded = bitStream->ReadAlignedBytes((unsigned char*)internalPacket->data, BITS_TO_BYTES(internalPacket->dataBitLength));
+	//bitStreamSucceeded = bitStream->ReadBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
 	#ifdef _DEBUG
 	assert(bitStreamSucceeded);	if (bitStreamSucceeded==false) {delete [] internalPacket->data; InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 	#endif
@@ -1601,14 +1808,14 @@
 // Search the specified list for sequenced packets on the specified ordering 
 // stream, optionally skipping those with splitPacketId, and delete them
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId)
 {
 	unsigned i=0;
 
 	while (i < theList.size())
 	{
 		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&
-			theList[i]->orderingStream==orderingStream && (splitPacketId==-1 || theList[i]->splitPacketId!=splitPacketId))
+			theList[i]->orderingChannel==orderingChannel && (splitPacketId==-1 || theList[i]->splitPacketId!=splitPacketId))
 		{
 			InternalPacket *internalPacket = theList[i];
 			theList.del(i);
@@ -1624,7 +1831,7 @@
 // Search the specified list for sequenced packets with a value less than orderingIndex and delete them
 // Note - I added functionality so you can use the Queue as a list (in this case for searching) but it is less efficient to do so than a regular list
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue<InternalPacket*>&theList)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue<InternalPacket*>&theList)
 {
 	InternalPacket *internalPacket;
 	int listSize=theList.size();
@@ -1632,7 +1839,7 @@
 
 	while (i < listSize)
 	{
-		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&	theList[i]->orderingStream==orderingStream)
+		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&	theList[i]->orderingChannel==orderingChannel)
 		{
 			internalPacket = theList[i];
 			theList.del(i);
@@ -1674,7 +1881,7 @@
 // Split the passed packet into chunks under MTU_SIZEbytes (including headers) and save those new chunks
 // Optimized version
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize)
+void ReliabilityLayer::SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize, unsigned long time)
 {
 	// Doing all sizes in bytes in this function so I don't write partial bytes with split packets
 	internalPacket->splitPacketCount=1; // This causes GetBitStreamHeaderLength to account for the split packet header
@@ -1690,7 +1897,6 @@
 	if (encryptor.IsKeySet())
 		maxDataSize-=16; // Extra data for the encryptor
 
-
 	#ifdef _DEBUG
 	// Make sure we need to split the packet to begin with
 	assert(dataByteLength > maxDataSize - headerLength);
@@ -1705,8 +1911,11 @@
 	// Calculate how many packets we need to create
 	internalPacket->splitPacketCount = (unsigned short)((dataByteLength-1) / (maximumSendBlock) + 1);
 
+	statistics.totalSplits+=internalPacket->splitPacketCount;
+
 	// Optimization
-	internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];
+	// internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];
+	internalPacketArray = (InternalPacket**)alloca(sizeof(InternalPacket*)*internalPacket->splitPacketCount);
 	for (i=0; i < (int)internalPacket->splitPacketCount; i++)
 	{
 		internalPacketArray[i]=InternalPacketPool::Instance()->GetPointer();
@@ -1739,11 +1948,7 @@
 		{
 			// For every further packet we use a new packetNumber.
 			// Note that all split packets are reliable
-			reliabilityLayerMutexes[packetNumber_MUTEX].Lock();
-			internalPacketArray[splitPacketIndex]->packetNumber=packetNumber;
-			if (++packetNumber==RECEIVED_PACKET_LOG_LENGTH)
-				packetNumber=0;
-			reliabilityLayerMutexes[packetNumber_MUTEX].Unlock();
+			IncrementPacketNumber(time);
 		}
 
 		// Add the new packet to send list at the correct priority
@@ -1759,16 +1964,16 @@
 	splitPacketId++; // It's ok if this wraps to 0
 
 	// Copy all the new packets into the split packet list
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Lock();
 	for (i=0; i < (int)internalPacket->splitPacketCount; i++)
 		sendQueue[internalPacket->priority].push(internalPacketArray[i]);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Unlock();
 
 	// Delete the original
 	delete [] internalPacket->data;
 	InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-	delete [] internalPacketArray;
+	//delete [] internalPacketArray;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1776,9 +1981,9 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::InsertIntoSplitPacketList(InternalPacket * internalPacket)
 {
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	splitPacketList.insert(internalPacket);
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1786,7 +1991,7 @@
 //reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
 // Optimized version
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId)
+InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time)
 {
 	int i,j,size;
 	// How much data all blocks but the last hold
@@ -1796,7 +2001,7 @@
 	int *indexList;
 	int indexListIndex;
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	size = splitPacketList.size();
 
 	for (i=0; i < size; i++)
@@ -1806,19 +2011,21 @@
 			// Is there enough elements in the list to have all the parts?
 			if (splitPacketList[i]->splitPacketCount > splitPacketList.size() - i)
 			{
-				if (splitPacketList.size() % 100 == 0)
-					printf("%i\n", splitPacketList.size());
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//			if (splitPacketList.size() % 100 == 0 || splitPacketList[i]->splitPacketCount-splitPacketList.size()<100)
+	//				printf("%i out of %i\n", splitPacketList.size(), splitPacketList[i]->splitPacketCount);
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				return 0;
 			}
 
+	//		printf("%i out of %i\n", splitPacketList.size(), splitPacketList[i]->splitPacketCount);
 			// Keep track of the indices of the elements through our first scan so we don't have to rescan to find them
 			indexListIndex=0;
 
 			numParts=1;
 			bitlength=splitPacketList[i]->dataBitLength;
 
-			indexList = new int[splitPacketList[i]->splitPacketCount];
+			// indexList = new int[splitPacketList[i]->splitPacketCount];
+			indexList = (int*) alloca(sizeof(int)*splitPacketList[i]->splitPacketCount);
 			indexList[indexListIndex++]=i;
 
 			maxDataSize=BITS_TO_BYTES(splitPacketList[i]->dataBitLength);
@@ -1838,7 +2045,7 @@
 			if (numParts==splitPacketList[i]->splitPacketCount)
 			{
 				// All the parts are here
-				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0);
+				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0,time);
 				internalPacket->data=new char[BITS_TO_BYTES(bitlength)];
 #ifdef _DEBUG
 				internalPacket->splitPacketCount = splitPacketList[i]->splitPacketCount;
@@ -1898,28 +2105,74 @@
 					else
 						j++;
 
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
-				delete [] indexList;
+			//	delete [] indexList;
 
 				return internalPacket;
 			}
 
-			delete [] indexList;
+		//	delete [] indexList;
 			break;
 		}
 	}
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
 	return 0;
 }
 
+// Delete any unreliable split packets that have long since expired
+void ReliabilityLayer::DeleteOldUnreliableSplitPackets(unsigned long time)
+{
+	unsigned size,i,orderingIndexToDelete;
+	unsigned long newestUnreliableSplitPacket;
+	bool found;
+	InternalPacket *temp;
+
+	// Scan through the list for split packets that were sent unreliably.
+	// If the newest unreliable split packet for a particular ID is more than 3000 ms old, then
+	// delete all of them of that id
+
+	size = splitPacketList.size();
+	newestUnreliableSplitPacket=0L;
+	found=false;
+
+	for (i=0; i < size; i++)
+	{
+		if ((splitPacketList[i]->reliability==UNRELIABLE || splitPacketList[i]->reliability==UNRELIABLE_SEQUENCED) &&
+			splitPacketList[i]->creationTime >= newestUnreliableSplitPacket)
+		{
+			orderingIndexToDelete=splitPacketList[i]->orderingIndex;
+			newestUnreliableSplitPacket=splitPacketList[i]->creationTime;
+			found=true;
+		}
+	}
+
+	if (found && time-newestUnreliableSplitPacket > 5000)
+	{
+		// Delete all split packets that use orderingIndexToDelete
+		i=0;
+		while (i < splitPacketList.size())
+		{
+			if (splitPacketList[i]->orderingIndex==orderingIndexToDelete)
+			{
+				temp=splitPacketList[i];
+				splitPacketList[i]=splitPacketList[splitPacketList.size()-1];
+				splitPacketList.del(); // Removes the last element
+				InternalPacketPool::Instance()->ReleasePointer(temp);
+			}
+			else
+				i++;
+		}
+	}
+}
+
 //-------------------------------------------------------------------------------------------------------
 // Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 // Does not copy any split data parameters as that information is always generated does not have any reason to be copied
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength)
+InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time)
 {
 	InternalPacket *copy = InternalPacketPool::Instance()->GetPointer();
 #ifdef _DEBUG
@@ -1936,11 +2189,11 @@
 		copy->data=0;
 
 	copy->dataBitLength=dataByteLength<<3;
-	copy->creationTime = getTime();
+	copy->creationTime = time;
 	copy->isAcknowledgement=original->isAcknowledgement;
 	copy->nextActionTime=0;
 	copy->orderingIndex=original->orderingIndex;
-	copy->orderingStream=original->orderingStream;
+	copy->orderingChannel=original->orderingChannel;
 	copy->packetNumber=original->packetNumber;
 	copy->priority=original->priority;
 	copy->reliability=original->reliability;
@@ -1952,12 +2205,12 @@
 // Get the specified ordering list
 // LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 //-------------------------------------------------------------------------------------------------------
-BasicDataStructures::LinkedList<InternalPacket*> *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingStream)
+BasicDataStructures::LinkedList<InternalPacket*> *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingChannel)
 {
-	if (orderingStream >= orderingList.size())
+	if (orderingChannel >= orderingList.size())
 		return 0;
 
-	return orderingList[orderingStream];
+	return orderingList[orderingChannel];
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1966,37 +2219,37 @@
 void ReliabilityLayer::AddToOrderingList(InternalPacket * internalPacket)
 {
 	#ifdef _DEBUG
-	assert(internalPacket->orderingStream< NUMBER_OF_ORDERED_STREAMS);
+	assert(internalPacket->orderingChannel< NUMBER_OF_ORDERED_STREAMS);
 	#endif
-	if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)	
+	if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)	
 		return;
 
-	reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-	if (internalPacket->orderingStream >= orderingList.size() || orderingList[internalPacket->orderingStream]==0)
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	if (internalPacket->orderingChannel >= orderingList.size() || orderingList[internalPacket->orderingChannel]==0)
 	{
 		// Need a linked list in this index
-		orderingList.replace(new BasicDataStructures::LinkedList<InternalPacket*>, 0, internalPacket->orderingStream);
-		(orderingList[internalPacket->orderingStream])->add(internalPacket);
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		orderingList.replace(new BasicDataStructures::LinkedList<InternalPacket*>, 0, internalPacket->orderingChannel);
+		(orderingList[internalPacket->orderingChannel])->add(internalPacket);
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 		return;
 	}
 	else
 	{
 		// Have a linked list in this index
-		if (orderingList[internalPacket->orderingStream]->size()==0)
+		if (orderingList[internalPacket->orderingChannel]->size()==0)
 		{
 			// The linked list is empty
-			(orderingList[internalPacket->orderingStream])->add(internalPacket);
+			(orderingList[internalPacket->orderingChannel])->add(internalPacket);
 		}
 		else
 		{
 			BasicDataStructures::LinkedList<InternalPacket*> *theList;
-			theList = GetOrderingListAtOrderingStream(internalPacket->orderingStream);
+			theList = GetOrderingListAtOrderingStream(internalPacket->orderingChannel);
 			// Add this packet in no particular order
 			theList->beginning();
 			theList->insert(internalPacket);
 		}
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 	}
 }
 
@@ -2005,17 +2258,16 @@
 // THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 // reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket)
+void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time)
 {
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	if (lastAckTime==0 || resendQueue.size()==0)
-		lastAckTime=getTime(); // Start the timer for the ack of this packet if we aren't already waiting for an ack
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+		lastAckTime=time; // Start the timer for the ack of this packet if we aren't already waiting for an ack
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	resendQueue.push(internalPacket);
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -2031,36 +2283,40 @@
 //-------------------------------------------------------------------------------------------------------
 // How long to wait between packet resends
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i) {if (i > 0) lostPacketResendDelay=i; if (lostPacketResendDelay<1000) lostPacketResendDelay=1000;}
+void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i)
+{
+	if (i > 0) lostPacketResendDelay=i;
+	if (lostPacketResendDelay<150) // To avoid unnecessary packetloss, this value should be UPDATE_THREAD_UPDATE_TIME + UPDATE_THREAD_POLL_TIME at a minimum
+		lostPacketResendDelay=150;
+}
 
 //-------------------------------------------------------------------------------------------------------
 // Statistics
 //-------------------------------------------------------------------------------------------------------
-double ReliabilityLayer::GetPacketlossPercentile(void) const {if 
-(sentPackets>0) return (double)retransmittedPackets / (double)sentPackets; 
-else return 0.0;}
-unsigned long ReliabilityLayer::GetTransmittedPacketCount(void) const 
-{return sentPackets;}
-unsigned long ReliabilityLayer::GetTransmittedFrameCount(void) const 
-{return sentFrames;}
-unsigned long ReliabilityLayer::GetLostPacketCount(void) const {return 
-retransmittedPackets;}
-unsigned long ReliabilityLayer::GetReceivedPacketCount(void) const {return 
-receivedPacketsCount;}
-unsigned long ReliabilityLayer::GetBytesSent(void) const {return bytesSent;}
-unsigned long ReliabilityLayer::GetBytesReceived(void) const {return 
-bytesReceived;}
-unsigned long ReliabilityLayer::GetUnacknowledgedSentPacketListSize(void) 
-{return resendQueue.size();}
-unsigned long ReliabilityLayer::GetPacketOutputBufferSize(void)
+RakNetStatisticsStruct * const ReliabilityLayer::GetStatistics(void)
 {
-	int val=0; 
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-	for (int count=0; count<NUMBER_OF_PRIORITIES; count++)
-		val+= sendQueue[count].size();
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-	return val;
+	int i;
+	for (i=0; i < NUMBER_OF_PRIORITIES; i++)
+	{
+		statistics.messageSendBuffer[i]=sendQueue[i].size();
+	}
+
+	statistics.acknowlegementsPending=acknowledgementQueue.size();
+	statistics.messagesWaitingForReassembly=splitPacketList.size();
+	statistics.internalOutputQueueSize=outputQueue.size();
+	statistics.windowSize=windowSize;
+	statistics.lossySize=lossyWindowSize==MAXIMUM_WINDOW_SIZE+1 ? 0 : lossyWindowSize;
+	statistics.messagesOnResendQueue=resendQueue.size();
+
+	return &statistics;
 }
-unsigned long ReliabilityLayer::GetMaximumWindowSize(void) const {return windowSize;}
-unsigned long ReliabilityLayer::GetLastPacketReceivedTime(void) const {return lastPacketReceivedTime;}
 
+//-------------------------------------------------------------------------------------------------------
+// Update the current packet number for sends
+//-------------------------------------------------------------------------------------------------------
+void ReliabilityLayer::IncrementPacketNumber(unsigned long time)
+{
+	reliabilityLayerMutexes[packetNumber_MUTEX].Lock();
+	++packetNumber;
+	reliabilityLayerMutexes[packetNumber_MUTEX].Unlock();
+}
\ No newline at end of file

Modified: branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/ReliabilityLayer.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -21,23 +21,14 @@
 #include "InternalPacket.h"
 #include "InternalPacketPool.h"
 #include "DataBlockEncryptor.h"
+#include "RakNetStatistics.h"
 
 #define UDP_HEADER_SIZE 28
 #define NUMBER_OF_ORDERED_STREAMS 32 // 2^5
 
-const unsigned long TIMEOUT_TIME = 20000; // If no response to a reliable packet for this long kill the connection
-// -----------------------------------------------------------------------------------------------------------------
-// If you change MAX_AVERAGE_PACKETS_PER_SECOND or TIMEOUT_TIME,
-// you must make sure RECEIVED_PACKET_LOG_LENGTH < the range of PacketNumberType (held in InternalPacket.h)
-// -----------------------------------------------------------------------------------------------------------------
- // *** Pay attention to the value of RECEIVED_PACKET_LOG_LENGTH when changing this! ***
-const int MAX_AVERAGE_PACKETS_PER_SECOND=400;
- 
-// *** This value must be less than the range of PacketNumberType. PacketNumberType is in InternalPacket.h  ***
-const int RECEIVED_PACKET_LOG_LENGTH=(TIMEOUT_TIME/1000)*MAX_AVERAGE_PACKETS_PER_SECOND;
-// -----------------------------------------------------------------------------------------------------------------
+const unsigned long TIMEOUT_TIME = 10000; // If no response to a reliable packet for this long kill the connection
 
-class BitStream;
+#include "BitStream.h"
 
 class ReliabilityLayer
 {
@@ -48,18 +39,23 @@
 	// Destructor
 	~ReliabilityLayer();
 
-	// Resets the layer for reuse
+	// Resets the layer for reuse.
+	// Callable from multiple threads
 	void Reset(void);
 
 	// Sets up encryption
+	// Callable from multiple threads
 	void SetEncryptionKey(const unsigned char *key);
 
 	// Assign a socket for the reliability layer to use for writing
+	// Callable from multiple threads
 	void SetSocket(SOCKET s);
 
 	// Get the socket held by the reliability layer
+	// Callable from multiple threads
 	SOCKET GetSocket(void);
 
+	// Must be called by the same thread as update
 	// Packets are read directly from the socket layer and skip the reliability layer  because unconnected players do not use the reliability layer
 	// This function takes packet data after a player has been confirmed as connected.  The game should not use that data directly
 	// because some data is used internally, such as packet acknowledgement and split packets
@@ -67,17 +63,20 @@
 	bool HandleSocketReceiveFromConnectedPlayer(char *buffer, int length);
 
 	// This gets an end-user packet already parsed out. Returns number of BITS put into the buffer
+	// Callable from multiple threads
 	int Receive(char**data);
 
 	// Puts data on the send queue
 	// bitStream contains the data to send
 	// priority is what priority to send the data at
 	// reliability is what reliability to use
-	// ordering stream is from 0 to 31 and specifies what stream to use
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize);
+	// ordering channel is from 0 to 31 and specifies what stream to use
+	// Callable from multiple threads
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize);
 
 	// Run this once per game cycle.  Handles internal lists and actually does the send
-	void Update(SOCKET s, PlayerID playerId, int MTUSize);
+	// Must be called by the same thread as HandleSocketReceiveFromConnectedPlayer
+	void Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time);
 
 	// If Read returns -1 and this returns true then a modified packet was detected
 	bool IsCheater(void) const;
@@ -89,44 +88,36 @@
 	void SetLostPacketResendDelay(unsigned long i);
 
 	// Statistics
-	double GetPacketlossPercentile(void) const;
-	unsigned long GetTransmittedPacketCount(void) const;
-	unsigned long GetTransmittedFrameCount(void) const;
-	unsigned long GetLostPacketCount(void) const;
-	unsigned long GetReceivedPacketCount(void) const;
-	unsigned long GetBytesSent(void) const;
-	unsigned long GetBytesReceived(void) const;
-	unsigned long GetUnacknowledgedSentPacketListSize(void);
-	unsigned long GetPacketOutputBufferSize(void);
-	unsigned long GetMaximumWindowSize(void) const;
-	unsigned long GetLastPacketReceivedTime(void) const;
+	RakNetStatisticsStruct * const GetStatistics(void);
+
 private:
 	// Returns true if we can or should send a frame.  False if we should not
-	bool IsFrameReady(void);
+	bool IsFrameReady(unsigned long time);
 
 	// Generates a frame (coalesced packets)
-	void GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent);
+	void GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time);
 
 	// Writes a bitstream to the socket
-	void SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream);
+	void SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream);
 
 	// Parse an internalPacket and create a bitstream to represent this data
-	void WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket);
+	// Returns number of bits used
+	int WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket);
 
 	// Parse a bitstream and create an internal packet to represent this data
-	InternalPacket* CreateInternalPacketFromBitStream(BitStream *bitStream);
+	InternalPacket* CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time);
 
 	// Does what the function name says
 	void RemovePacketFromResendQueueAndDeleteOlderReliableSequenced(PacketNumberType packetNumber);
 
 	// Acknowledge receipt of the packet with the specified packetNumber
-	void SendAcknowledgementPacket(PacketNumberType packetNumber);
+	void SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time);
 
 	// This will return true if we should not send at this time
 	bool IsSendThrottled(void);
 
 	// We lost a packet
-	void UpdatePacketloss(void);
+	void UpdatePacketloss(unsigned long time);
 
 	// Parse an internalPacket and figure out how many header bits would be written.  Returns that number
 	int GetBitStreamHeaderLength(const InternalPacket *const internalPacket);
@@ -137,30 +128,33 @@
 	// Check the SHA1 code
 	bool CheckSHA1(char code[SHA1_LENGTH], unsigned char * const buffer, unsigned long nbytes);
 
-	// Search the specified list for sequenced packets on the specified ordering stream, optionally skipping those with splitPacketId, and delete them
-	void  DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId=-1);
+	// Search the specified list for sequenced packets on the specified ordering channel, optionally skipping those with splitPacketId, and delete them
+	void  DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId=-1);
 	// Search the specified list for sequenced packets with a value less than orderingIndex and delete them
-	void DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue<InternalPacket*>&theList);
+	void DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue<InternalPacket*>&theList);
 
 	// Returns true if newPacketOrderingIndex is older than the waitingForPacketOrderingIndex
 	bool IsOlderOrderedPacket(unsigned char newPacketOrderingIndex, unsigned char waitingForPacketOrderingIndex);
 
 	// Split the passed packet into chunks under MTU_SIZE bytes (including headers) and save those new chunks
-	void SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize);
+	void SplitPacketAndDeleteOriginal(InternalPacket *internalPacket, int MTUSize, unsigned long time);
 
 	// Insert a packet into the split packet list
 	void InsertIntoSplitPacketList(InternalPacket * internalPacket);
 
 	// Take all split chunks with the specified splitPacketId and try to reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
-	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId);
+	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time);
 
+	// Delete any unreliable split packets that have long since expired
+	void DeleteOldUnreliableSplitPackets(unsigned long time);
+
 	// Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 	// Does not copy any split data parameters as that information is always generated does not have any reason to be copied
-	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength);
+	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time);
 
 	// Get the specified ordering list
 	// LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-	BasicDataStructures::LinkedList<InternalPacket*> *GetOrderingListAtOrderingStream(unsigned char orderingStream);
+	BasicDataStructures::LinkedList<InternalPacket*> *GetOrderingListAtOrderingStream(unsigned char orderingChannel);
 
 	// Add the internal packet to the ordering list in order based on order index
 	void AddToOrderingList(InternalPacket * internalPacket);
@@ -168,27 +162,35 @@
 	// Inserts a packet into the resend list in order
 	// THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 	// reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-	void InsertPacketIntoResendQueue(InternalPacket *internalPacket);
+	void InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time);
 
-	// Frees all allocated memory
-	void FreeMemory(void);
+	// Memory handling
+	void FreeMemory(bool freeAllImmediately);
+	void FreeThreadedMemory(void);
+	void FreeThreadSafeMemory(void);
 	
 	// Initialize the variables
 	void InitializeVariables(void);
 
+	// Update the current packet number for sends
+	void IncrementPacketNumber(unsigned long time);
+
 	// STUFF TO MUTEX HERE
 	enum
 	{
-		splitPacketList_MUTEX,
-		sendQueue_MUTEX,
-		resendQueue_MUTEX,
-		orderingList_MUTEX,
-		acknowledgementQueue_MUTEX,
-		outputQueue_MUTEX,
+		// splitPacketList_MUTEX, // We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		sendQueueSystemPriority_MUTEX,
+		sendQueueHighPriority_MUTEX,
+		sendQueueMediumPriority_MUTEX,
+		sendQueueLowPriority_MUTEX,
+		//resendQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//orderingList_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//acknowledgementQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		// outputQueue_MUTEX,// We don't have to mutex this as long as Recieve and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		packetNumber_MUTEX,
-		windowSize_MUTEX,
-		lastAckTime_MUTEX,
-		updateBitStream_MUTEX,
+		// windowSize_MUTEX, // Causes long delays for some reason
+		//lastAckTime_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//updateBitStream_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		waitingForOrderedPacketWriteIndex_MUTEX,
 		waitingForSequencedPacketWriteIndex_MUTEX,
 		NUMBER_OF_RELIABILITY_LAYER_MUTEXES
@@ -202,7 +204,7 @@
 	PacketNumberType packetNumber;
 	//unsigned long windowSize;
 	unsigned long lastAckTime;
-	BitStream updateBitStream;
+	RakNet::BitStream updateBitStream;
 	unsigned char waitingForOrderedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS], waitingForSequencedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS];
 	// Used for flow control (changed to regular TCP sliding window)
 	//	unsigned long maximumWindowSize, bytesSentSinceAck;
@@ -211,11 +213,13 @@
 	// STUFF TO NOT MUTEX HERE (called from non-conflicting threads, or value is not important)
 	unsigned char waitingForOrderedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS],waitingForSequencedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS];
 	bool deadConnection, cheater;
-	unsigned long lastPacketSendTime,retransmittedPackets, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
+//	unsigned long lastPacketSendTime,retransmittedFrames, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
 	unsigned long lostPacketResendDelay;
 	unsigned long splitPacketId;
-	unsigned long receivedPackets[RECEIVED_PACKET_LOG_LENGTH];
+	unsigned long *receivedPackets;
 	unsigned long blockWindowIncreaseUntilTime;
+	RakNetStatisticsStruct statistics;
+	unsigned long lastPacketCounterResetTime;
 
 	// Windowing algorithm:
 	// Start at a minimum size
@@ -231,6 +235,8 @@
 	#ifdef __USE_IO_COMPLETION_PORTS
 	SOCKET readWriteSocket;
 	#endif
+
+	bool freeThreadedMemoryOnNextUpdate; // This variable is so that free memory can be called by only the update thread so we don't have to mutex things so much
 };
 
 #endif

Modified: branches/mp-branch-2/source/libraries/raknet/SHA1.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/SHA1.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/SHA1.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -21,11 +21,8 @@
 #include <stdio.h> // Needed for file access
 #include <memory.h> // Needed for memset and memcpy
 #include <string.h> // Needed for strcat and strcpy
+#include "Types.h"
 
-#ifdef _WINDOWS
-#define LITTLE_ENDIAN
-#endif
-
 #define MAX_FILE_READ_BUFFER 8000
 #define SHA1_LENGTH 20
 
@@ -33,7 +30,7 @@
 {
 public:
 	// Rotate x bits to the left
-	#define ROL32(value, bits) (((value)<<(bits))|((value)>>(32-(bits))))
+//	#define ROL32(value, bits) (((value)<<(bits))|((value)>>(32-(bits))))
 
 	#ifdef LITTLE_ENDIAN
 		#define SHABLK0(i) (block->l[i] = (ROL32(block->l[i],24) & 0xFF00FF00) \

Modified: branches/mp-branch-2/source/libraries/raknet/SocketLayer.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/SocketLayer.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/SocketLayer.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -17,6 +17,7 @@
 #else
 #include <string.h> // memcpy
 #include <unistd.h>
+#include <fcntl.h>
 #endif
 
 #include "ExtendedOverlappedPool.h"
@@ -75,14 +76,14 @@
 	}
 }
 
-SOCKET SocketLayer::Connect(SOCKET writeSocket, PlayerID playerId)
+SOCKET SocketLayer::Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port)
 {
 	assert(writeSocket!=INVALID_SOCKET);
 	sockaddr_in connectSocketAddress;
 
 	connectSocketAddress.sin_family = AF_INET;
-	connectSocketAddress.sin_port = htons(playerId.port);
-	connectSocketAddress.sin_addr.s_addr = playerId.binaryAddress;
+	connectSocketAddress.sin_port = htons(port);
+	connectSocketAddress.sin_addr.s_addr = binaryAddress;
 
 	if (connect(writeSocket, (struct sockaddr *)&connectSocketAddress, sizeof(struct sockaddr)) != 0)
 	{
@@ -147,6 +148,38 @@
 		#endif
 	}
 
+	//Set non-blocking
+#ifdef _WIN32
+	unsigned long nonblocking = 1;
+	if (ioctlsocket(listenSocket, FIONBIO, &nonblocking)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#else
+	if (fcntl(listenSocket, F_SETFL, O_NONBLOCK)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#endif
+
+	// Set broadcast capable
+	if ( setsockopt(listenSocket, SOL_SOCKET, SO_BROADCAST,(char *)&sock_opt, sizeof(sock_opt)) == -1)
+	{
+#if defined(_WIN32) && defined(_DEBUG)
+		DWORD dwIOError = GetLastError();
+		LPVOID messageBuffer;
+		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 	  FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
+			NULL, dwIOError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),// Default language
+			(LPTSTR) &messageBuffer, 0, NULL); 
+		// something has gone wrong here... 
+		printf("setsockopt(SO_BROADCAST) failed:Error code - %d\n%s",dwIOError, messageBuffer ); 
+		//Free the buffer. 
+		LocalFree(messageBuffer ); 
+#endif
+	}
+
 	// Listen on our designated Port#
 	listenerSocketAddress.sin_port = htons(port);
 
@@ -209,7 +242,7 @@
 }
 
 // Start an asynchronous read using the specified socket.
-bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer *rakPeer)
+bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer *rakPeer)
 {
 	#ifdef __USE_IO_COMPLETION_PORTS
 	assert(readSocket!=INVALID_SOCKET);
@@ -219,7 +252,8 @@
 
 	ExtendedOverlappedStruct* eos = ExtendedOverlappedPool::Instance()->GetPointer();
 	memset(&(eos->overlapped), 0, sizeof(OVERLAPPED));
-	eos->playerId=playerId;
+	eos->binaryAddress=binaryAddress;
+	eos->port=port;
 	eos->rakPeer=rakPeer;
 	eos->length=MAXIMUM_MTU_SIZE;
 
@@ -239,13 +273,8 @@
 	return true;
 }
 
-int SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer)
+bool SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode)
 {
-	if (s==INVALID_SOCKET)
-	{
-		return SOCKET_ERROR;
-	}
-
 	int len;
 	char data[MAXIMUM_MTU_SIZE];
 	sockaddr_in sa;
@@ -260,6 +289,12 @@
 	sa.sin_addr.s_addr=0;
 #endif
 
+	if (s==INVALID_SOCKET)
+	{
+		*errorCode=SOCKET_ERROR;
+		return false;
+	}
+
 	len = recvfrom(s, data, MAXIMUM_MTU_SIZE, 0, (sockaddr*)&sa, (socklen_t*)&len2);
 
 //	if (len>0)
@@ -269,9 +304,10 @@
 	{
 #ifdef _DEBUG
 		printf("Error: recvfrom returned 0 on a connectionless blocking call\non port %i.  This is a bug with Zone Alarm.  Please turn off Zone Alarm.\n",ntohs(sa.sin_port));
-#endif
 		assert(0);
-		return 0;
+#endif		
+		*errorCode=SOCKET_ERROR;
+		return false;
 	}
 
 	if (len!=SOCKET_ERROR)
@@ -282,13 +318,20 @@
 		//	strcpy(ip, "127.0.0.1");
         ProcessNetworkPacket(sa.sin_addr.s_addr, portnum,data, len, rakPeer);
 
-		return 0;
+		return true;
 	}
 	else
 	{
 
-#if defined(_WIN32)
+		*errorCode=0;
+
+#if defined(_WIN32) && defined(_DEBUG)
 		DWORD dwIOError = WSAGetLastError();
+		
+		if (dwIOError == WSAEWOULDBLOCK)
+		{
+			return false;
+		}
 
 		if (dwIOError==WSAECONNRESET)
 		{
@@ -296,7 +339,8 @@
 			printf("A previous send operation resulted in an ICMP Port Unreachable message.\n");
 			#endif
 
-			return dwIOError;
+			*errorCode=dwIOError;
+			return false;
 		}
 		else
 		{
@@ -319,10 +363,10 @@
 #endif
 	}
 
-	return 0;
+	return false;
 }
 
-int SocketLayer::SendTo(SOCKET s, char *data, int length, PlayerID playerId)
+int SocketLayer::SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port)
 {
 	if (s==INVALID_SOCKET)
 	{
@@ -331,8 +375,8 @@
 
 	int len;
 	sockaddr_in sa;
-	sa.sin_port = htons(playerId.port);
-	sa.sin_addr.s_addr = playerId.binaryAddress;
+	sa.sin_port = htons(port);
+	sa.sin_addr.s_addr = binaryAddress;
 	sa.sin_family = AF_INET;
 	do {
 		len = sendto(s, data, length, 0, (const sockaddr*)&sa, sizeof(struct sockaddr_in));
@@ -374,10 +418,9 @@
 
 int SocketLayer::SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port)
 {
-	PlayerID temp;
-	temp.binaryAddress=inet_addr(ip);
-	temp.port=port;
-	return SendTo(s,data,length,temp);
+	unsigned long binaryAddress;
+	binaryAddress=inet_addr(ip);
+	return SendTo(s,data,length,binaryAddress,port);
 }
 
 void SocketLayer::GetMyIP(char ipList[10][16])

Modified: branches/mp-branch-2/source/libraries/raknet/SocketLayer.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/SocketLayer.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/SocketLayer.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -37,21 +37,20 @@
 	SocketLayer();
 	~SocketLayer();
 	static inline SocketLayer* Instance() {return &I;}
-	SOCKET Connect(SOCKET writeSocket, PlayerID playerId);
+	SOCKET Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port);
 	SOCKET CreateBoundSocket(unsigned short port, bool blockingSocket); // Creates a socket to listen for incoming connections on the specified port
 	const char* DomainNameToIP(const char *domainName);
 	#ifdef __USE_IO_COMPLETION_PORTS
 	void AssociateSocketWithCompletionPort(SOCKET socket, ClientContextStruct* completionKey);
 #endif
 	// Start an asynchronous read using the specified socket.  The callback will use the specified PlayerID (associated with this socket) and call either the client or the server callback (one or the other should be 0)
-	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer* rakPeer);
+	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer* rakPeer);
 	void Write(SOCKET writeSocket, const char* data, int length);
-	// Given a listen socket and an event object triggered when a new connection occurs, return the new socket of the new connection along with the IP and port of the caller
-	// Returns the error code on failure, 0 on success
-	int RecvFrom(SOCKET s, RakPeer *rakPeer);
+	// Returns true if you successfully read data
+	bool RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode);
 	void GetMyIP(char ipList[10][16]);
 	int SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port);
-	int SendTo(SOCKET s, char *data, int length, PlayerID playerId);
+	int SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port);
 	
 	private:
 	static bool socketLayerStarted;

Modified: branches/mp-branch-2/source/libraries/raknet/StringCompressor.cpp
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/StringCompressor.cpp	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/StringCompressor.cpp	2004-11-05 07:25:22 UTC (rev 95)
@@ -3,10 +3,12 @@
 #include "BitStream.h"
 #include <assert.h>
 #include <string.h>
+#include <memory.h>
 
 StringCompressor StringCompressor::instance;
 
-unsigned long englishCharacterFrequencies[] =
+// Generated from various chat logs on the internet.
+unsigned long englishCharacterFrequencies[256] =
 {
 0,
 0,
@@ -18,9 +20,10 @@
 0,
 0,
 0,
-5655,
+722,
 0,
 0,
+2,
 0,
 0,
 0,
@@ -39,101 +42,101 @@
 0,
 0,
 0,
+11084,
+58,
+63,
+1,
 0,
-64995,
-2,
-515,
-3,
-3,
-5,
-13,
-125,
-289,
-294,
+31,
 0,
+317,
+64,
+64,
+44,
 0,
-1968,
-558,
-4849,
-91,
-244,
-795,
-459,
-323,
-379,
-210,
-155,
-138,
-280,
-590,
-150,
-46,
-4,
-3,
-4,
+695,
+62,
+980,
+266,
 69,
-28,
-595,
-161,
-950,
-364,
-430,
-326,
-221,
-308,
-712,
-189,
+67,
 56,
-181,
-318,
-426,
-256,
-676,
+7,
+73,
+3,
 14,
-458,
-1247,
-853,
-253,
-105,
-297,
-53,
-81,
 2,
-235,
-0,
-235,
-0,
+69,
+1,
+167,
+9,
+1,
 2,
+25,
+94,
 0,
-11400,
-2156,
-6665,
-5543,
-19692,
-3186,
-2759,
-5614,
-12742,
+195,
+139,
+34,
+96,
+48,
+103,
+56,
+125,
+653,
+21,
+5,
+23,
+64,
+85,
+44,
+34,
+7,
+92,
+76,
+147,
+12,
+14,
 57,
-1191,
-6009,
-4271,
-11288,
-13376,
-3619,
-106,
-10492,
-12069,
-14885,
-5462,
-1664,
-1850,
-265,
-3591,
-169,
+15,
+39,
+15,
+1,
+1,
+1,
+2,
+3,
 0,
+3611,
+845,
+1077,
+1884,
+5870,
+841,
+1057,
+2501,
+3212,
+164,
+531,
+2019,
+1330,
+3056,
+4037,
+848,
+47,
+2586,
+2919,
+4771,
+1707,
+535,
+1106,
+152,
+1243,
+100,
 0,
+2,
 0,
+10,
 0,
 0,
 0,
@@ -262,12 +265,12 @@
 0,
 0,
 0,
-0,
 0
 };
 
 StringCompressor::StringCompressor()
 {
+	huffmanEncodingTree=0;
 }
 
 void StringCompressor::GenerateHuffmanEncodingTree(void)
@@ -275,18 +278,41 @@
 	huffmanEncodingTree = new HuffmanEncodingTree;
 	huffmanEncodingTree->GenerateFromFrequencyTable(englishCharacterFrequencies);
 }
+void StringCompressor::GenerateTreeFromStrings(unsigned char *input, unsigned inputLength)
+{
+	unsigned index;
+	unsigned long frequencyTable[256];
+
+	if (inputLength==0)
+		return;
+
+	// Zero out the frequency table
+	memset(frequencyTable, 0, sizeof(frequencyTable));
+
+	// Generate the frequency table from the strings
+	for (index=0; index < inputLength; index++);
+		frequencyTable[input[index]]++;
+
+	// Delete the old tree, if there is done
+	if (huffmanEncodingTree)
+		delete huffmanEncodingTree;
+
+	// Build the tree
+	huffmanEncodingTree = new HuffmanEncodingTree;
+	huffmanEncodingTree->GenerateFromFrequencyTable(frequencyTable);
+}
 StringCompressor::~StringCompressor()
 {
 	if (huffmanEncodingTree)
 		delete huffmanEncodingTree;
 }
 
-void StringCompressor::EncodeString(char *input, int maxCharsToWrite, BitStream *output)
+void StringCompressor::EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output)
 {
 	if (input==0)
 		return;
 
-	BitStream encodedBitStream;
+	RakNet::BitStream encodedBitStream;
 	unsigned short stringBitLength;
 	int charsToWrite;
 
@@ -300,12 +326,12 @@
 
 	huffmanEncodingTree->EncodeArray((unsigned char*) input, charsToWrite, &encodedBitStream);
 
-	stringBitLength = encodedBitStream.GetNumberOfBitsUsed();
+	stringBitLength = (unsigned short)encodedBitStream.GetNumberOfBitsUsed();
 	output->WriteCompressed(stringBitLength);
 	output->WriteBits(encodedBitStream.GetData(), stringBitLength);
 }
 
-void StringCompressor::DecodeString(char *output, int maxCharsToWrite, BitStream *input)
+bool StringCompressor::DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input)
 {
 	unsigned short stringBitLength;
 	int bytesInStream;
@@ -315,14 +341,18 @@
 
 	output[0]=0;
 
-	
 	if (input->ReadCompressed(stringBitLength)==false)
-		return;
+		return false;
 
+	if (input->GetNumberOfUnreadBits() < stringBitLength)
+		return false;
+
 	bytesInStream=huffmanEncodingTree->DecodeArray(input, stringBitLength, maxCharsToWrite, (unsigned char*) output);
 	if (bytesInStream < maxCharsToWrite)
 		output[bytesInStream]=0;
 	else
 		output[maxCharsToWrite-1]=0;
+
+	return true;
 }
 

Modified: branches/mp-branch-2/source/libraries/raknet/StringCompressor.h
===================================================================
--- branches/mp-branch-2/source/libraries/raknet/StringCompressor.h	2004-11-01 20:24:45 UTC (rev 94)
+++ branches/mp-branch-2/source/libraries/raknet/StringCompressor.h	2004-11-05 07:25:22 UTC (rev 95)
@@ -3,8 +3,8 @@
 #ifndef __STRING_COMPRESSOR_H
 #define __STRING_COMPRESSOR_H
 
+#include "BitStream.h"
 class HuffmanEncodingTree;
-class BitStream;
 
 class StringCompressor
 {
@@ -14,12 +14,17 @@
 	// static function because only static functions can access static members
 	static inline StringCompressor* Instance() {return &instance;}
 
+	// Given an array of strings, such as a chat log, generate the optimal encoding tree for it.
+	// This function is optional and if it is not called a default tree will be used instead.
+	void GenerateTreeFromStrings(unsigned char *input, unsigned inputLength);
+
 	// Writes input to output, compressed.  Takes care of the null terminator for you
-	void EncodeString(char *input, int maxCharsToWrite, BitStream *output);
+	void EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output);
 
 	// Writes input to output, uncompressed.  Takes care of the null terminator for you.
 	// maxCharsToWrite should be the allocated size of output
-	void DecodeString(char *output, int maxCharsToWrite, BitStream *input);
+	bool DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input);
+
 private:
 	void GenerateHuffmanEncodingTree(void);
 	StringCompressor();



From youbastrd at sheep.berlios.de  Fri Nov  5 08:29:11 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Fri, 5 Nov 2004 08:29:11 +0100
Subject: [Tw-light-svn] r96 - in branches/mp-branch-2: . source source/games source/melee
Message-ID: <200411050729.iA57TBTT007235@sheep.berlios.de>

Author: youbastrd
Date: 2004-11-05 08:29:10 +0100 (Fri, 05 Nov 2004)
New Revision: 96

Added:
   branches/mp-branch-2/source/games/MultiplayerGame.cpp
   branches/mp-branch-2/source/games/MultiplayerGame.h
Modified:
   branches/mp-branch-2/makefile
   branches/mp-branch-2/source/melee/mcbodies.cpp
   branches/mp-branch-2/source/melee/mcbodies.h
   branches/mp-branch-2/source/melee/mframe.cpp
   branches/mp-branch-2/source/melee/mframe.h
   branches/mp-branch-2/source/scp.cpp
   branches/mp-branch-2/sources.lst
Log:
adding rudementary multiplayer code: Stars class is created, synchronized, and deleted on the network between the server and zero or more clients.  

Modified: branches/mp-branch-2/makefile
===================================================================
--- branches/mp-branch-2/makefile	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/makefile	2004-11-05 07:29:10 UTC (rev 96)
@@ -202,6 +202,12 @@
 add_stacktrace:
 	find source -name '*.cpp'|grep -v 'libraries'|grep -v 'errors.cpp'|grep -v 'utils.cpp'|xargs ./Util/addStackTrace.pl 
 
+run: all
+	$(NAME)
+
+run-multiplayer: all
+	$(NAME) -play game MultiplayerGameServer & sleep 3 && $(NAME) -play game MultiplayerGameClient
+
 install:
 	./install-sh -c -m 755 $(NAME) $(EXECPATH)/$(NAME)
 	CPPROG="cp -r" ./install-sh -c gamedata $(DATAPATH)

Added: branches/mp-branch-2/source/games/MultiplayerGame.cpp
===================================================================
--- branches/mp-branch-2/source/games/MultiplayerGame.cpp	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/source/games/MultiplayerGame.cpp	2004-11-05 07:29:10 UTC (rev 96)
@@ -0,0 +1,583 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+
+#include "MultiplayerGame.h"
+
+
+#include "libraries/raknet/RakClientInterface.h"
+#include "libraries/raknet/RakServerInterface.h"
+#include "Raknet/RakNetworkFactory.h"	
+
+// If you don't want to use distributed network objects, delete this include
+#include "../libraries/raknet/DistributedNetworkObjectManager.h"
+#include "../libraries/raknet/PacketEnumerations.h"
+#include "../libraries/raknet/NetworkTypes.h"
+#include <assert.h>
+#include <stdio.h>
+#include "../libraries/raknet/GetTime.h"
+
+#include <algorithm>
+#include <functional>
+
+#ifdef DEBUGMODE
+    #define _DEBUG
+#endif
+#ifdef DEBUG
+	#define _DEBUG
+#endif
+
+#ifdef _DEBUG
+#include <memory.h>
+#endif
+
+//#include <iostream>	
+
+MultiplayerGameTemplate::MultiplayerGameTemplate() :
+    server(RakNetworkFactory::GetRakServerInterface()),
+    client(RakNetworkFactory::GetRakClientInterface()),
+    _isServer(false)
+{
+    message.print(5000,15,"Game on!");
+}
+
+static void destroyNetworkObject2(Presence *p){ if (p) p->DestroyObjectOnNetwork(); }
+
+MultiplayerGameTemplate::~MultiplayerGameTemplate()
+{
+	printf("MultiplayerGameTemplate::~MultiplayerGameTemplate()\n");
+//	this->Game::~Game();
+//	std::for_each(presence.begin(),presence.end(), destroyNetworkObject2 );
+    RakNetworkFactory::DestroyRakServerInterface(server);
+    RakNetworkFactory::DestroyRakClientInterface(client);
+}
+
+
+
+void MultiplayerGameTemplate::init(Log *log) { 
+    Game::init(log); 
+    prepare();
+    
+    //asteroid = new Asteroid();
+    //add(asteroid);
+
+    
+    //humanTeam = new_team();
+    //yehat = (YehatTerminator*)create_ship(channel_server, "yehte", "WussieBot", random(size), random(PI2), humanTeam);
+    //add( yehat->get_ship_phaser() );
+    //add_focus(yehat);
+    
+    if (isServer()) {
+        stars = new Stars();
+        add( stars );
+        //stars->UpdateDistributedObject("Stars");
+
+    	//printf("server:init");
+    	//PresenceRegistry::GetInstance()->toString();        	
+    	//Stars * stars = new Stars();
+    	//printf("server:init: adding stars with (%s:%d)\n", stars->GetClassName(), stars->GetClassID());
+    	//PresenceRegistry::GetInstance()->toString();
+	    //add( stars );
+	    //add(new Asteroid());
+	    
+        
+		/*
+        add(new Asteroid());
+        add(new Asteroid());*/
+    }
+}
+
+
+void MultiplayerGameTemplate::calculate() { 
+	rakClientMultiplayer.ProcessPackets(client);
+	rakServerMultiplayer.ProcessPackets(server);
+
+	Game::calculate();
+	if (isServer() && stars) {
+		stars->num_stars ++;
+	}
+	//printf("MPGame::calculate()[");
+	//cout << "MPGame::calculate()[";
+//	for (UniverseObjectListIterator iter = universeObjects.begin();
+//		 iter != universeObjects.end();
+//		 ++iter)
+//	{
+//		if (*iter) {
+//			//printf(" %s", (*iter)->getClassName());
+//			//cout << " " << (*iter)->getClassName();
+//			(*iter)->calculate();
+//		}
+//	}
+	//printf("]\n");
+	//cout << "]" << endl;
+	//cout.flush();
+	
+//	for (UniverseObjectTypeIterator iter = universeObjects.begin();
+//         iter != universeObjects.end();
+//         ++iter)
+//    {
+//        (*iter)->UpdateDistributedObject((*iter)->GetClassName());
+//    }
+	//if (stars) {
+	//	stars->UpdateDistributedObject("Stars");
+	//}
+}
+
+
+
+void MultiplayerGameTemplate::add(SpaceLocation *p)
+{
+    Game::add(p);
+    _add(p);
+}
+    
+
+void MultiplayerGameTemplate::add(Presence *p) 
+{
+    Game::add(p);   
+    _add(p);
+}
+
+
+void MultiplayerGameTemplate::_add(Presence *p) 
+{
+	printf("Adding: [%s]\n", p->getClassName());
+/*    //if (isServer()) {
+    	if (p->GetClassID() == 0) {
+    		cout <<"Skipping adding a " << p->GetClassName() << endl;
+    		cout.flush();
+    		return;
+    	}
+    	printf("adding: (%s:%d) ObjectID=%d ", p->GetClassName(), p->GetClassID(), p->GetObjectID());
+        PresenceCreationDescription pc( p->GetObjectID(), p->GetClassID() );
+        printf("as (%s:%d)\n", 
+        	PresenceRegistry::GetInstance()->getClassName(pc.presenceType),
+        	pc.presenceType);
+        
+        bool b = server->Send((char*)&pc, sizeof(PresenceCreationDescription), HIGH_PRIORITY, RELIABLE_ORDERED, 0, UNASSIGNED_PLAYER_ID, true);
+        if (!b)
+        	tw_error("couldn't send packet in MPGame::_add()");
+    //}
+    */
+}
+
+
+
+/*void MultiplayerGameTemplate<InterfaceType>::ProcessUnhandledPacket(Packet *p, unsigned char packetIdentifier, InterfaceType *interfaceType)
+{
+	cout << "got an unhandled packet packetIdentifier=" << packetIdentifier << endl;
+    switch (packetIdentifier) {
+        case ID_PRESENCE_CREATION:
+        {
+            //if (isServer())
+            //    return;
+            printf(" (presence creation)");
+            PresenceCreationDescription * pc = (PresenceCreationDescription*) p->data;
+        
+            assert(p->length == sizeof(PresenceCreationDescription));
+            if (p->length != sizeof(PresenceCreationDescription)) {
+                tw_error("Got a PresenceCreationDescription request that was the wrong size.");
+                return;
+            }
+            
+            assert(GET_OBJECT_FROM_ID(pc->objectId) == NULL);
+            if (GET_OBJECT_FROM_ID(pc->objectId) != NULL) {
+                tw_error("Got a PresenceCreationDescription request for an object that already exists.");
+                return;
+            }
+            
+            message.print(15000,15,"Got a presence creation packet, it's a %s", PresenceRegistry::GetInstance()->getClassName(pc->presenceType));
+            printf("Got a presence creation packet, it's a %s", PresenceRegistry::GetInstance()->getClassName(pc->presenceType));
+            
+            //Presence * presence = PresenceRegistry::GetInstance()->createPresenceFromNetworkDescription(pc);
+            Presence * presence = PresenceRegistry::GetInstance()->GetPresenceClassDefaultInstance(pc->presenceType);
+            Game::add(presence);
+            
+//            switch (pc->presenceType) {
+//                case PT_ASTEROID:
+//                    add(new Asteroid());
+//                    break;
+//                
+//                case PT_YEHAT_TERMINATOR:
+//                   {TeamCode human = new_team();
+//                    Control *c = create_control(channel_server, "Human");
+//                    Ship *s = create_ship("yehte", c, Vector2(size.x/2,size.y/2), 0, human);
+//                    add(s->get_ship_phaser());
+//                    add_focus(s);}
+//                    break;
+//                
+//                case PT_UNKNOWN:
+//                default:
+//                    message.print(10000,15,"Tried to add unknown object: %s", p->data);
+//                    ;
+//            };
+        }
+        break;
+        
+        default:
+            message.print(5000,15,"Unknown data: %s", p->data);
+    };
+    
+	// Remove the annoying warnings
+	//packetIdentifier;
+	//interfaceType;
+
+	// This class should have been overrided to handle user defined packets
+#ifdef _DEBUG
+	// Uncomment this to show output as integers
+	
+//	int i;
+//	static unsigned packetNumber=0;
+//	// Raw output (nonstring)
+//	message.print(5000,15,"MultiplayerGameTemplate::ProcessUnhandledPacket (%i) (%i): ", packetNumber++, p->length);
+//	for (i=0; i < p->length; i++)
+//	message.print(5000,15,"%i ",p->data[i]);
+//	message.print(5000,15,"");
+	
+
+	// Uncomment this to show output as a string
+	
+	// Raw output (string)
+
+	
+#endif
+	printf("\n");
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteDisconnectionNotification(Packet *packet,InterfaceType *interfaceType)
+{
+	cout << "Client: someone else has disconnected." << endl;
+	cout.flush();
+	// Another system has disconnected.  Client only.
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_DISCONNECTION_NOTIFICATION,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType)
+{
+	// Another system has been dropped by the server.  Client only.
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_CONNECTION_LOST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_CONNECTION_LOST,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType)
+{
+	// Another system has connected.  Client only.
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_NEW_INCOMING_CONNECTION,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemoteExistingConnection(Packet *packet,InterfaceType *interfaceType)
+{
+	// We just connected to the server and are getting a list of players already connected
+	// Note due to thread timing you might get both this and ID_REMOTE_NEW_INCOMING_CONNECTION when first connecting.
+	//  Client only.
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_EXISTING_CONNECTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType)
+{
+	// We are banned from connecting to the system specified in packet->playerId
+	// Peer or client
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_BANNED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionRequestAccepted(Packet *packet, InterfaceType *interfaceType)
+{
+    message.print(5000,15,"We're accepted to connect");
+	// Our request to connect to another system has been accepted.  Client only.
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_REQUEST_ACCEPTED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_CONNECTION_REQUEST_ACCEPTED,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveNewIncomingConnection(Packet *packet, InterfaceType *interfaceType)
+{
+	// Another system has requested to connect to us, which we have accepted.  Server or peer only.
+    //message.print(10000,15,"%s has connected", ((StaticClientDataStruct*)(server->GetStaticClientData(packet->playerId))->GetData())->name);
+    
+    //TeamCode human = new_team();
+    //Control *c = create_control(channel_server, "Human");
+    //Ship *s = create_ship("yehte", c, Vector2(size.x/2,size.y/2), 0, human);
+    //add(s->get_ship_phaser());
+    //add_focus(s);
+  
+#ifdef _DEBUG
+	message.print(5000,15,"ID_NEW_INCOMING_CONNECTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_NEW_INCOMING_CONNECTION,interfaceType);
+
+	// This will send all existing distributed objects to the new player
+//#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+	DistributedNetworkObjectManager::Instance()->SendAllDistributedObjects(packet->playerId);
+//#endif
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionResumption(Packet *packet, InterfaceType *interfaceType)
+{
+	// Someone who was already connected to us connected again.  Server or peer only.
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_RESUMPTION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_CONNECTION_RESUMPTION,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveNoFreeIncomingConnections(Packet *packet, InterfaceType *interfaceType)
+{
+	// The system we connected to has no free slots to connect to
+	// Set free slots by calling SetMaximumIncomingConnections
+	// Client or peer only.
+#ifdef _DEBUG
+	message.print(5000,15,"ID_NO_FREE_INCOMING_CONNECTIONS from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_NO_FREE_INCOMING_CONNECTIONS,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDisconnectionNotification(Packet *packet, InterfaceType *interfaceType)
+{
+	// A remote system terminated the connection.  packet->playerId specifies which remote system
+#ifdef _DEBUG
+	message.print(5000,15,"ID_DISCONNECTION_NOTIFICATION from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_DISCONNECTION_NOTIFICATION,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveConnectionLost(Packet *packet, InterfaceType *interfaceType)
+{
+	// The network cannot send reliable packets so has terminated the connection. packet->playerId specifies which remote system
+#ifdef _DEBUG
+	message.print(5000,15,"ID_CONNECTION_LOST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_CONNECTION_LOST,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceivedStaticData(Packet *packet, InterfaceType *interfaceType)
+{
+	// Another system has just sent their static data to us (which we recorded automatically)
+#ifdef _DEBUG
+	message.print(5000,15,"ID_RECEIVED_STATIC_DATA from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_RECEIVED_STATIC_DATA,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveInvalidPassword(Packet *packet, InterfaceType *interfaceType)
+{
+	// Our connection to another system was refused because the passwords do not match
+#ifdef _DEBUG
+	message.print(5000,15,"ID_INVALID_PASSWORD from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_INVALID_PASSWORD,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveModifiedPacket(Packet *packet, InterfaceType *interfaceType)
+{
+	// The network layer has detected packet tampering
+	// This does NOT automatically close the connection
+#ifdef _DEBUG
+	message.print(5000,15,"ID_MODIFIED_PACKET from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_MODIFIED_PACKET,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveRemotePortRefused(Packet *packet, InterfaceType *interfaceType)
+{
+	// The remote system has responded with ICMP_PORT_UNREACHABLE
+#ifdef _DEBUG
+	message.print(5000,15,"ID_REMOTE_PORT_REFUSED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_REMOTE_PORT_REFUSED,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveVoicePacket(Packet *packet, InterfaceType *interfaceType)
+{
+	// We got a voice packet
+#ifdef _DEBUG
+	message.print(5000,15,"ID_VOICE_PACKET from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+//	ProcessUnhandledPacket(packet, ID_VOICE_PACKET,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceivePong(Packet *packet, InterfaceType *interfaceType)
+{
+	// Peer or client.  Response from a ping for an unconnected system.
+//#ifdef _DEBUG
+	unsigned long time;
+	memcpy((char*)&time, packet->data+sizeof(unsigned char), sizeof(unsigned long));
+	message.print(5000,15,"ID_PONG from PlayerID:%u:%u on %p. Value is %i",packet->playerId.binaryAddress, packet->playerId.port, interfaceType, time);
+//#endif
+	//	ProcessUnhandledPacket(packet, ID_PONG,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObject(Packet *packet,InterfaceType *interfaceType)
+{
+	// Packet to create a distributed network object
+#ifdef _DEBUG
+	message.print(5000,15,"ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+
+	#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+
+	// This packet is only valid if the server or client was registered with the DistributedNetworkObjectManager
+	// If you this this assert, you need to call
+	// DistributedNetworkObjectManager::Instance()->RegisterRakServerInterface(myInstanceOfRakServer);
+	// and / or
+	// DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(myInstanceOfRakClient);
+	assert(DistributedNetworkObjectManager::Instance()->GetRakClientInterface() || DistributedNetworkObjectManager::Instance()->GetRakServerInterface());
+
+	DistributedNetworkObjectManager::Instance()->HandleDistributedNetworkObjectPacket(packet);
+	#endif
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObjectCreationAccepted(Packet *packet,InterfaceType *interfaceType)
+{
+	// Client only - creation of a distributed network object was accepted
+#ifdef _DEBUG
+	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+
+#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+	// This packet is only valid if the client was registered with the DistributedNetworkObjectManager
+	// DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(myInstanceOfRakClient);
+	assert(DistributedNetworkObjectManager::Instance()->GetRakClientInterface());
+
+	DistributedNetworkObjectManager::Instance()->HandleDistributedNetworkObjectPacketCreationAccepted(packet);
+#endif
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveDistributedNetworkObjectCreationRejected(Packet *packet,InterfaceType *interfaceType)
+{
+	// Client only - creation of a distributed network object was accepted
+#ifdef _DEBUG
+	message.print(5000,15,"ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+
+#ifdef __DISTRIBUTED_NETWORK_OBJECT_MANAGER_H
+	// This packet is only valid if the client was registered with the DistributedNetworkObjectManager
+	// DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(myInstanceOfRakClient);
+	assert(DistributedNetworkObjectManager::Instance()->GetRakClientInterface());
+
+	DistributedNetworkObjectManager::Instance()->HandleDistributedNetworkObjectPacketCreationRejected(packet);
+#endif
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherRequestFileList(Packet *packet, InterfaceType *interfaceType)
+{
+	// Request for a list of files served by the autopatcher.
+	// Send to Autopatcher::SendDownloadableFileList(packet->playerId)
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILE_LIST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_REQUEST_FILE_LIST,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherFileList(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got a list of files served by a remote autopatcher
+	// Send to Autopatcher::OnAutopatcherFileList(packet, bool);
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_FILE_LIST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_FILE_LIST,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherRequestFiles(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got a request for a set of files from our autopatcher
+	// Send to Autopatcher::OnAutopatcherRequestFiles(packet);
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_REQUEST_FILES from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_REQUEST_FILES,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherSetDownloadList(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got confirmation of what files we are about to get from the remote autopatcher
+	// Send to Autopatcher::OnAutopatcherSetDownloadList(packet);
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_SET_DOWNLOAD_LIST from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_SET_DOWNLOAD_LIST,interfaceType);
+}
+
+
+void MultiplayerGameTemplate<InterfaceType>::ReceiveAutopatcherWriteFile(Packet *packet, InterfaceType *interfaceType)
+{
+	// Got a file from a remote autopatcher
+	// Send to Autopatcher::OnAutopatcherWriteFile(packet);
+#ifdef _DEBUG
+	message.print(5000,15,"ID_AUTOPATCHER_WRITE_FILE from PlayerID:%u:%u on %p.",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	// ProcessUnhandledPacket(packet, ID_AUTOPATCHER_WRITE_FILE,interfaceType);
+};
+
+// Copied from Multiplayer.cpp
+// If the first byte is ID_TIMESTAMP, then we want the 5th byte
+// Otherwise we want the 1st byte
+//unsigned char GetPacketIdentifier(Packet *p)
+//{
+//	if (p==0)
+//		return 255;
+//
+//	if ((unsigned char)p->data[0] == ID_TIMESTAMP)
+//	{
+//		assert(p->length > sizeof(unsigned char) + sizeof(unsigned long));
+//		return (unsigned char) p->data[sizeof(unsigned char) + sizeof(unsigned long)];
+//	}
+//	else
+//		return (unsigned char) p->data[0];
+//}
+*/
+REGISTER_GAME(MultiplayerGameClient, "MultiplayerGameClient")
+REGISTER_GAME(MultiplayerGameServer, "MultiplayerGameServer")

Added: branches/mp-branch-2/source/games/MultiplayerGame.h
===================================================================
--- branches/mp-branch-2/source/games/MultiplayerGame.h	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/source/games/MultiplayerGame.h	2004-11-05 07:29:10 UTC (rev 96)
@@ -0,0 +1,257 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef MULTIPLAYERGAME_HEADER
+#define MULTIPLAYERGAME_HEADER
+
+#include "allegro.h"
+#include "melee.h"
+#include "scp.h"
+#include "frame.h"
+#include "melee/mgame.h"
+#include "melee/mview.h"
+#include "melee/mship.h"
+#include "melee/mcbodies.h"
+#include "../libraries/raknet/NetworkTypes.h"
+#include "../libraries/raknet/PacketEnumerations.h"
+#include "../libraries/raknet/RakNetworkFactory.h"
+#include "../libraries/raknet/RakClientInterface.h"
+#include "../libraries/raknet/RakServerInterface.h"
+#include "../libraries/raknet/NetworkTypes.h"
+#include "../libraries/raknet/BitStream.h"
+#include "../libraries/raknet/Multiplayer.h"
+#include "sc1ships.h"
+
+#include <iostream>
+	
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <time.h>
+
+
+//! A class to implement Multiplayer Games with.  You should subclass this, rather than using it directly.
+//! You should also create a server and client class that can be used to start a game in the GUI and from the
+//! commandline (see MultiplayerGameServer for more explaination on how to do this).
+//! 
+//! This has default implementations of methods needed to:
+//! - start a server 
+//! - have clients connect to it
+//! - let players on a client to join a game.  Once in a game, players can:
+//! - - when first joining a match, select a fleet, according to the FleetSelectionPolicy
+//! - - when spawning, select a ship from their fleet, according to the SpawnTimeShipSelectionPolicy
+//! - - fly their ship, fire its weapons, etc.
+//! - - blow up other ships etc, and get blown up themselves, keeping score all the while.  Great fun!
+//! - the server will finish the game according to its victory conditions.
+//! 
+//! This class is templated to use any of three RakNet interface types. 
+//! Examples:
+//! - using MultiplayerGameTemplate<RakClientInterface> means we're using a RakClientInterface
+//! - using MultiplayerGameTemplate<RakServerInterface> means we're using a RakServerInterface
+//! - using MultiplayerGameTemplate<RakPeerInterface> means we're using a RakPeerInterface
+//!
+//! @see MultiplayerGameServer
+//! @see MultiplayerGameClient
+//! @see FleetSelectionPolicy
+//! @see SpawnTimeShipSelectionPolicy
+
+//template <class InterfaceType>
+class MultiplayerGameTemplate : 
+	//public Multiplayer<InterfaceType>,
+	public Game
+{
+public:
+    
+	//! 
+	MultiplayerGameTemplate();
+
+    //!
+	virtual ~MultiplayerGameTemplate();
+	
+	YehatTerminator * yehat;
+	TeamCode humanTeam;
+
+	
+	// Methods and data stuctures from class Game /////////////////////////////////////////////////
+	
+	//! pre-initialization (enough so that the destructor won't crash)
+	virtual void preinit() { Game::preinit(); }	
+	
+    //! initialization (loading data, creating a few game objects, whatever)
+    virtual void init(Log *log);
+    
+    //! changes the view.  That is, the method that the screen is drawn for the user is selected.
+    //! @param new_view the View data structure to use.
+    virtual void change_view (View *new_view) { Game::change_view(new_view); }
+    
+    //! changes the view.  That is, the method that the screen is drawn for the user is selected.
+    //! @param name the name of the view method
+    virtual void change_view (const char * name ) { Game::change_view(name); }
+    
+    //! called before doing anything with game objects contained within you.  
+    virtual void prepare() { Game::prepare(); }
+    
+    //! called once per game loop.  Performs all game logic.
+    virtual void calculate();
+    
+    //! called once per game execution.  This contains the game loop itself.
+    virtual void play() { Game::play(); }
+    
+    //! draws the entire world to a specific frame.
+    virtual void animate(Frame *frame) { Game::animate(frame); }
+    
+    //! draws the entire world.
+    virtual void animate() { Game::animate(); }
+
+  	//! called when an object is killed/died/exploded in the game.
+    //! \param who the SpaceObject that is in the process of dying.  Note that this may be a ship, an asteroid, a projectile, anything.
+    //! \param source this is what killed the SpaceObject who.  Note that it may be NULL
+  	virtual void object_died(SpaceObject *who, SpaceLocation *source) { Game::object_died(who, source); }
+  	
+  	//! called when a ship is killed/died/exploded in the game.
+    //!  TODO say which of these is true:
+    //!	 Note that object_died() will also be called when this happens.
+    //!	 Note that object_died() will *not* be called when this happens.
+    //! \param who the Ship that is in the immediate process of dying
+    //! \param source the target which killed the ship.  Note that it may not be a Ship, and it may be NULL
+  	virtual void ship_died(Ship *who, SpaceLocation *source) { Game::ship_died(who, source); }
+
+	//! Determines if the game has loaded/prepared all its data structures and ready to start.
+    //! @return true if the game is ready to start, false otherwise.
+	virtual bool game_ready() {return Game::game_ready(); }
+    
+    /// add space location to universe
+    /// @see SpaceLocation
+    virtual void add(SpaceLocation *p);
+    
+    /// add presence from universe
+    /// @see Presence
+    virtual void add(Presence *p);
+
+protected:
+    ///
+    virtual void _add(Presence * p);
+    
+public: 
+	
+// methods exclusive to this class /////////////////////////////////////////////////////////	
+	virtual bool isServer() { return _isServer; }
+	
+protected:
+    RakServerInterface * server;
+    RakClientInterface * client;
+    
+    Multiplayer<RakClientInterface> rakClientMultiplayer;
+	Multiplayer<RakServerInterface> rakServerMultiplayer;
+
+protected:
+	bool _isServer;
+    
+    Asteroid * asteroid;
+    Stars * stars;
+};
+
+//! This class is exposed to the list of available games.  Note that this class is
+//! for testing only, and it shouldn't be used as an actual gametype.  Instead,
+//! subclass MultiplayerGameTemplate, putting all functionality in there.  Then
+//! make two classes similar to MultiplayerGameClient and MultiplayerGameServer, like so:
+//! 
+//! template <class InterfaceType>
+//! class YourGameTemplate : 
+//! 	public MultiplayerGameTemplate<InterfaceType>,
+//! 	public Game
+//! {
+//!   ... // implement your game here by customizing methods here
+//! }
+//!
+//! class YourGameClient : public YourGameTemplate<RakClientInterface> { 
+//! public:
+//!   YourGameServer() { networkInterface = RakNetworkFactory::GetRakServerInterface(); }
+//!   ~YourGameServer() { RakNetworkFactory::DestroyRakServerInterface(networkInterface); }
+//! };
+//!
+//! class YourGameServer : public YourGameServerTemplate<RakClientInterface> { 
+//! public:
+//!   YourGameServer() { networkInterface = RakNetworkFactory::GetRakClientInterface(); }
+//!   ~YourGameServer() { RakNetworkFactory::DestroyRakClientInterface(networkInterface); }
+//! };
+//!
+class MultiplayerGameServer : public MultiplayerGameTemplate//<RakServerInterface> 
+{ 
+public:
+	MultiplayerGameServer()
+    { 
+        _isServer = true;
+        stars = NULL;
+        //server->SetStaticServerData((char*)&staticServerData, sizeof(staticServerData));
+        bool b = server->Start(2, 0, true, 15515);
+        if (!b)
+            throw "Can't start server!";
+        DistributedNetworkObjectManager::Instance()->RegisterRakServerInterface(server);
+        message.print(60000,15,"Started server!");
+	}
+	~MultiplayerGameServer() { }
+    
+    virtual void calculate() {
+        MultiplayerGameTemplate::calculate();
+        if (stars) {
+        //	message.print(1000,15,"server: num stars=%d", stars->num_stars);
+            //cout << "server: num stars=" << stars->num_stars << endl;
+            //cout.flush();
+        }
+    }
+    
+//protected:
+    //StaticServerDataStruct staticServerData;
+};
+
+class MultiplayerGameClient : public MultiplayerGameTemplate//<RakClientInterface> 
+{ 
+public:
+	MultiplayerGameClient()
+    { 
+      //networkInterface = client;
+      //client->SetStaticClientData(UNASSIGNED_PLAYER_ID, (char*)&staticClientData, sizeof(StaticClientDataStruct));
+      bool b = false;
+      while (!b) {
+        b = client->Connect("127.0.0.1", 15515, 15516, 0, true);
+        if (!b)
+            message.out("Couldn't connect, retrying...");
+      }
+      stars = NULL;
+      DistributedNetworkObjectManager::Instance()->RegisterRakClientInterface(client);
+      message.print(60000,15,"Connected to server as PlayerID (%s)!", client->PlayerIDToDottedIP(client->GetPlayerID()));
+    }
+	~MultiplayerGameClient() { }
+	
+    virtual void calculate() {
+        //MultiplayerGameTemplate<RakClientInterface>::calculate();
+        MultiplayerGameTemplate::calculate();
+        //if (stars) {
+        //    cout << "client: num stars=" << stars->num_stars << endl;
+         //   cout.flush();
+        //	message.print(1000,15,"client: num stars=%d", stars->num_stars);
+        //}
+    }
+//protected:
+  //  StaticClientDataStruct staticClientData;
+};
+
+
+
+	
+	
+#endif

Modified: branches/mp-branch-2/source/melee/mcbodies.cpp
===================================================================
--- branches/mp-branch-2/source/melee/mcbodies.cpp	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/source/melee/mcbodies.cpp	2004-11-05 07:29:10 UTC (rev 96)
@@ -405,6 +405,7 @@
 }
 Stars::~Stars() 
 {
+	printf("Stars::~stars()\n");
   int i;
   for(i = 0; i < num_pics; i++) delete pic[i];
   delete[] pic;
@@ -466,3 +467,7 @@
     }
   return;
 }
+
+//static void regsiterStars() { 	REGISTER_DISTRIBUTED_CLASS(Stars); }
+//CALL_BEFORE_MAIN(regsiterStars);
+

Modified: branches/mp-branch-2/source/melee/mcbodies.h
===================================================================
--- branches/mp-branch-2/source/melee/mcbodies.h	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/source/melee/mcbodies.h	2004-11-05 07:29:10 UTC (rev 96)
@@ -69,7 +69,8 @@
 	virtual void _event( Event *e);
 	public:
 	Stars();
-	~Stars();
+	virtual ~Stars();
+	virtual char * getClassName() const { return "Stars"; }
 	SpaceSprite **pic;
 	double width;
 	double height;
@@ -83,6 +84,9 @@
 	void animate(Frame *space);
 	void select_view( View **view);
 	View **v;
+	
+	REGISTER_1_DISTRIBUTED_OBJECT_MEMBERS(Presence,
+		DOM_COPY_COMPRESSED, DOM_SERVER_AUTHORITATIVE, int, num_stars	)
 };
 
 /// \brief helpers for drawing your own starfields

Modified: branches/mp-branch-2/source/melee/mframe.cpp
===================================================================
--- branches/mp-branch-2/source/melee/mframe.cpp	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/source/melee/mframe.cpp	2004-11-05 07:29:10 UTC (rev 96)
@@ -39,8 +39,22 @@
 #include "other/twconfig.h"
 #include "scp.h"
 
+#include "libraries/raknet/Multiplayer.h"
+// *** DISTRIBUTED OBJECT USER NOTE #1 ***
+// The distributed object system requires "DistributedNetworkObjectHeader.h"
+#include "libraries/raknet/DistributedNetworkObjectHeader.h"
+#include "libraries/raknet/RakServerInterface.h"
+#include "libraries/raknet/RakClientInterface.h"
+#include "libraries/raknet/RakNetworkFactory.h"
+#include "libraries/raknet/BitStream.h"
+#include "libraries/raknet/Rand.h"
+
+
 int total_presences;
 
+///A list of every object in the game universe.
+//UniverseObjectList universeObjects;
+
 #define DEATH_FRAMES 4
 //setting this too low will cause crashes
 //setting it too high will waste CPU power and RAM
@@ -308,6 +322,7 @@
 	id = 0;
 	_depth = 0;
 	set_depth(DEPTH_PRESENCE);
+//	universeObjects.push_back(this);
 	}
 
 void Presence::animate(Frame *space) {
@@ -318,6 +333,7 @@
 void Presence::calculate() 
 {
   STACKTRACE;
+  this->UpdateDistributedObject(getClassName());
 }
 bool Presence::die() 
 {
@@ -334,6 +350,7 @@
 
 Presence::~Presence() {STACKTRACE
 	total_presences -= 1;
+	printf("Presence::~Presence()\n");
 	}
 
 bool Presence::isLocation() const {
@@ -367,6 +384,37 @@
 	return ((attributes & ATTRIB_SYNCHED) != 0);
 	}
 
+bool Presence::OnDistributedObjectCreation(PlayerID senderID)
+{
+	if (game)
+		game->add(this);
+	return true; // Allow object creation by returning true
+}
+
+// Overload this to show a message
+void Presence::OnDistributedObjectDestruction(PlayerID senderID)
+{
+	printf("Presence::OnDistributedObjectDestruction\n");
+//	flush(stdout);
+//	for (UniverseObjectListIterator iter = universeObjects.begin(); 
+//	     iter != universeObjects.end();
+//	     ++iter)
+//    {
+//    	 if (*iter == this) {
+//    	 	universeObjects.erase(iter);
+//    	 	break;
+//    	 }
+//    }
+//	delete this;
+//   if (game)
+//   	   game->remove(this);
+}
+
+
+
+
+
+
 SpaceLocation *Presence::get_focus() {
   STACKTRACE;
 	return NULL;
@@ -967,12 +1015,15 @@
   return;
 }
 
-static void delete_presence(Presence* p){delete p;}
-static void delete_item(SpaceLocation* p){delete p;}
+static void delete_presence(Presence* p){if (p) delete p;}
+static void delete_item(SpaceLocation* p){if (p) delete p;}
+static void destroyNetworkObject(Presence *p){ if (p) p->DestroyObjectOnNetwork(); }
 void Physics::destroy_all() {
   STACKTRACE;
+  std::for_each(presence.begin(),presence.end(), destroyNetworkObject );
   std::for_each(presence.begin(),presence.end(), delete_presence);
   presence.clear();
+  std::for_each(item.begin(),item.end(),destroyNetworkObject);
   std::for_each(item.begin(),item.end(),delete_item);
   item.clear();
 }
@@ -1388,3 +1439,6 @@
       ship_died((Ship*)who, source);
     }
 }
+
+//static void registerSpaceLocation() { 	REGISTER_DISTRIBUTED_CLASS(SpaceLocation); }
+//CALL_BEFORE_MAIN(registerSpaceLocation);

Modified: branches/mp-branch-2/source/melee/mframe.h
===================================================================
--- branches/mp-branch-2/source/melee/mframe.h	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/source/melee/mframe.h	2004-11-05 07:29:10 UTC (rev 96)
@@ -20,6 +20,31 @@
 #include <list>
 #include <vector>
 
+#include "libraries/raknet/Multiplayer.h"
+// *** DISTRIBUTED OBJECT USER NOTE #1 ***
+// The distributed object system requires "DistributedNetworkObjectHeader.h"
+#include "libraries/raknet/DistributedNetworkObjectHeader.h"
+#include "libraries/raknet/RakServerInterface.h"
+#include "libraries/raknet/RakClientInterface.h"
+#include "libraries/raknet/RakNetworkFactory.h"
+#include "libraries/raknet/BitStream.h"
+#include "libraries/raknet/Rand.h"
+
+
+
+//#include "melee.h"
+//#include "melee.h"          //used by all TW source files.  well, mostly. 
+//#include "melee/mgame.h"    //Game stuff
+
+//class Game;
+//extern class Game *&game;
+
+//class Presence;
+//typedef std::vector<Presence*> UniverseObjectList;
+//typedef UniverseObjectList::iterator UniverseObjectListIterator;
+//extern UniverseObjectList universeObjects;
+
+
 //debuging purposes only:
 extern int total_presences;
 
@@ -133,7 +158,7 @@
 };
 
 /// \brief Any item in the game
-class Presence : public BaseClass 
+class Presence : public BaseClass, public DistributedNetworkObject
 { 
   friend class Physics;
  public:
@@ -147,8 +172,8 @@
   double get_depth();
   friend int compare_depth (const void *_a, const void *_b) ;
   
-  inline void add(SpaceLocation *o) {physics->add(o);}
-  inline void add(Presence *p) {physics->add(p);}
+  virtual inline void add(SpaceLocation *o) {physics->add(o);}
+  virtual inline void add(Presence *p) {physics->add(p);}
   
   /// displays ? on screen (NOT permitted to affect game physics in any way)
   virtual void animate(Frame *space); 
@@ -170,7 +195,16 @@
   bool isShip() const ;      ///< returns true if it is the specified engine-defined type
   bool isShot() const;       ///< returns true if it is the specified engine-defined type
   bool isSynched() const;    ///< returns true if it is the specified engine-defined type
-  
+
+  ///
+  virtual char * getClassName() const { return "Presence"; }
+
+  ///
+  virtual bool OnDistributedObjectCreation(PlayerID senderID);
+
+  /// Overload this to show a message
+  virtual void OnDistributedObjectDestruction(PlayerID senderID);
+
 };
 
 /// \brief any item in the game that has a location, base class for all items in game
@@ -243,6 +277,8 @@
   virtual void change_pos(double scale);
 
   SpaceLocation(SpaceLocation *creator, Vector2 lpos, double langle);
+  SpaceLocation() { } // TODO make this work correctly!
+  virtual char * getClassName() const { return "SpaceLocation"; }
   virtual void death();      ///< called after an item is killed
   virtual ~SpaceLocation();  ///< called when an item is deallocated
 
@@ -290,6 +326,9 @@
   virtual void animate(Frame *space); 
   /// advance the item frame_time milliseconds in time
   virtual void calculate(); 
+  
+	REGISTER_1_DISTRIBUTED_OBJECT_MEMBERS(Presence,
+		DOM_INTERPOLATE_UNCOMPRESSED, DOM_CLIENT_AUTHORITATIVE, Vector2, pos)
 };
 
 /// \brief any item with a sprite (only SpaceObjects can bounce)

Modified: branches/mp-branch-2/source/scp.cpp
===================================================================
--- branches/mp-branch-2/source/scp.cpp	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/source/scp.cpp	2004-11-05 07:29:10 UTC (rev 96)
@@ -524,6 +524,10 @@
 #ifndef UNITTEST
 int main(int argc, char *argv[]) {
 	int r;
+	
+	REGISTER_DISTRIBUTED_CLASS(SpaceLocation);//TODO move this somewhere else
+	REGISTER_DISTRIBUTED_CLASS(Stars);
+	
 	r = tw_main(argc, argv);
 	return r;
 }

Modified: branches/mp-branch-2/sources.lst
===================================================================
--- branches/mp-branch-2/sources.lst	2004-11-05 07:25:22 UTC (rev 95)
+++ branches/mp-branch-2/sources.lst	2004-11-05 07:29:10 UTC (rev 96)
@@ -1,184 +1,186 @@
+source/ais/c_input.cpp
+source/ais/c_other.cpp
 source/ais/c_wussie.cpp
-source/ais/c_other.cpp
-source/ais/c_input.cpp
+source/doxygen.cpp
 source/frame.cpp
-source/util/random.cpp
-source/util/vector2.cpp
-source/util/round.c
-source/util/history.cpp
-source/util/types.cpp
-source/util/aautil.c
-source/util/sound.cpp
-source/util/get_time.c
-source/util/aarot.c
-source/util/aastr.c
-source/util/errors.cpp
-source/util/errors_c.c
-source/util/endian.cpp
-source/util/pmask.c
-source/util/base.cpp
+source/games/gdefender.cpp
+source/games/gflmelee.cpp
 source/games/ggob.cpp
-source/games/gflmelee.cpp
-source/games/gdefender.cpp
 source/games/glegacies.cpp
+source/games/MultiplayerGame.cpp
+source/gui.cpp
+source/input.cpp
+source/libraries/agup/aalg.c
+source/libraries/agup/aase.c
+source/libraries/agup/abeos.c
+source/libraries/agup/abitmap.c
+source/libraries/agup/agtk.c
+source/libraries/agup/agup.c
+source/libraries/agup/ans.c
+source/libraries/agup/aphoton.c
+source/libraries/agup/awin95.c
+source/libraries/jpgalleg/decode.c
+source/libraries/jpgalleg/encode.c
+source/libraries/jpgalleg/io.c
+source/libraries/jpgalleg/jpgalleg.c
+source/libraries/lua/lapi.c
+source/libraries/lua/lcode.c
+source/libraries/lua/ldebug.c
+source/libraries/lua/ldo.c
+source/libraries/lua/ldump.c
+source/libraries/lua/lfunc.c
+source/libraries/lua/lgc.c
+source/libraries/lua/lib/lauxlib.c
+source/libraries/lua/lib/lbaselib.c
+source/libraries/lua/lib/ldblib.c
+source/libraries/lua/lib/liolib.c
+source/libraries/lua/lib/lmathlib.c
+source/libraries/lua/lib/loadlib.c
+source/libraries/lua/lib/lstrlib.c
+source/libraries/lua/lib/ltablib.c
+source/libraries/lua/llex.c
+source/libraries/lua/lmem.c
+source/libraries/lua/lobject.c
+source/libraries/lua/lopcodes.c
+source/libraries/lua/lparser.c
+source/libraries/lua/lstate.c
+source/libraries/lua/lstring.c
+source/libraries/lua/ltable.c
+source/libraries/lua/ltests.c
+source/libraries/lua/ltm.c
+source/libraries/lua/lundump.c
+source/libraries/lua/lvm.c
+source/libraries/lua/lzio.c
+source/libraries/raknet/AES128.cpp
+source/libraries/raknet/AsynchronousFileIO.cpp
+source/libraries/raknet/BitStream.cpp
+source/libraries/raknet/CheckSum.cpp
+source/libraries/raknet/DataBlockEncryptor.cpp
+source/libraries/raknet/DistributedNetworkObject.cpp
+source/libraries/raknet/DistributedNetworkObjectManager.cpp
+source/libraries/raknet/DistributedNetworkObjectStub.cpp
+source/libraries/raknet/EncodeClassName.cpp
+source/libraries/raknet/Euclid.cpp
+source/libraries/raknet/ExtendedOverlappedPool.cpp
+source/libraries/raknet/GetTime.cpp
+source/libraries/raknet/HuffmanEncodingTree.cpp
+source/libraries/raknet/HuffmanEncodingTreeFactory.cpp
+source/libraries/raknet/InternalPacketPool.cpp
+source/libraries/raknet/MPUInt.cpp
+source/libraries/raknet/NetworkObject.cpp
+source/libraries/raknet/NetworkTypes.cpp
+source/libraries/raknet/PacketPool.cpp
+source/libraries/raknet/RakClient.cpp
+source/libraries/raknet/RakNetStatistics.cpp
+source/libraries/raknet/RakNetworkFactory.cpp
+source/libraries/raknet/RakPeer.cpp
+source/libraries/raknet/RakServer.cpp
+source/libraries/raknet/rand.cpp
+source/libraries/raknet/ReliabilityLayer.cpp
+source/libraries/raknet/RPCNode.cpp
+source/libraries/raknet/RSA.cpp
+source/libraries/raknet/SHA1.cpp
+source/libraries/raknet/SimpleMutex.cpp
+source/libraries/raknet/SocketLayer.cpp
+source/libraries/raknet/StringCompressor.cpp
+source/melee/manim.cpp
+source/melee/mcbodies.cpp
+source/melee/mcontrol.cpp
+source/melee/mfleet.cpp
+source/melee/mframe.cpp
+source/melee/mgame.cpp
+source/melee/mhelpers.cpp
+source/melee/mitems.cpp
 source/melee/mlog.cpp
-source/melee/mitems.cpp
+source/melee/mmain.cpp
+source/melee/mmath.cpp
 source/melee/mnet1.cpp
 source/melee/moptions.cpp
-source/melee/mgame.cpp
-source/melee/mhelpers.cpp
-source/melee/mfleet.cpp
-source/melee/mview.cpp
 source/melee/mship.cpp
-source/melee/mcontrol.cpp
-source/melee/manim.cpp
-source/melee/mframe.cpp
 source/melee/mshot.cpp
 source/melee/mshpdata.cpp
 source/melee/mshppan.cpp
 source/melee/msprite.cpp
-source/melee/mcbodies.cpp
-source/melee/mmain.cpp
 source/melee/mtarget.cpp
-source/melee/mmath.cpp
-source/other/orbit.cpp
+source/melee/mview.cpp
 source/other/configrw.cpp
-source/other/shippart.cpp
+source/other/dialogs.cpp
 source/other/fontmorph.cpp
-source/other/vtarget.cpp
-source/other/twconfig.cpp
-source/other/vbodies.cpp
 source/other/gup.cpp
+source/other/nullphas.cpp
 source/other/objanim.cpp
-source/other/nullphas.cpp
+source/other/orbit.cpp
 source/other/planet3d.cpp
 source/other/radar.cpp
-source/other/dialogs.cpp
-source/ships/shptauar.cpp
-source/ships/shpbogce.cpp
-source/ships/shpaktgu.cpp
-source/ships/shptauda.cpp
-source/ships/shpforsh.cpp
-source/ships/shptaume.cpp
-source/ships/shpdragr.cpp
-source/ships/shptausl.cpp
-source/ships/shptaust.cpp
-source/ships/shptauto.cpp
-source/ships/shpgarty.cpp
-source/ships/shprogsq.cpp
-source/ships/shpzeksh.cpp
-source/ships/shpconca.cpp
-source/ships/shpchoex.cpp
-source/ships/shpconho.cpp
-source/ships/shpilwsp.cpp
-source/ships/shpalabc.cpp
-source/ships/shpyusra.cpp
-source/ships/shpbahbu.cpp
-source/ships/shpbipka.cpp
-source/ships/shpwolmi.cpp
-source/ships/shpearc3.cpp
-source/ships/shpkahbo.cpp
-source/ships/shpstaba.cpp
-source/tests/testmain.cpp
-source/tests/testdatapath.cpp
-source/libraries/lua/lib/ldblib.c
-source/libraries/lua/lib/lauxlib.c
-source/libraries/lua/lib/lbaselib.c
-source/libraries/lua/lib/loadlib.c
-source/libraries/lua/lib/ltablib.c
-source/libraries/lua/lib/lmathlib.c
-source/libraries/lua/lib/lstrlib.c
-source/libraries/lua/lib/liolib.c
-source/libraries/lua/lundump.c
-source/libraries/lua/ldebug.c
-source/libraries/lua/ldo.c
-source/libraries/lua/lgc.c
-source/libraries/lua/ltm.c
-source/libraries/lua/lvm.c
-source/libraries/lua/lcode.c
-source/libraries/lua/ldump.c
-source/libraries/lua/lfunc.c
-source/libraries/lua/lparser.c
-source/libraries/lua/ltable.c
-source/libraries/lua/ltests.c
-source/libraries/lua/lstate.c
-source/libraries/lua/lapi.c
-source/libraries/lua/llex.c
-source/libraries/lua/lmem.c
-source/libraries/lua/lzio.c
-source/libraries/lua/lopcodes.c
-source/libraries/lua/lobject.c
-source/libraries/lua/lstring.c
-source/libraries/agup/aphoton.c
-source/libraries/agup/ans.c
-source/libraries/agup/awin95.c
-source/libraries/agup/aalg.c
-source/libraries/agup/aase.c
-source/libraries/agup/agtk.c
-source/libraries/agup/agup.c
-source/libraries/agup/abeos.c
-source/libraries/agup/abitmap.c
-source/libraries/raknet/AES128.cpp
-source/libraries/raknet/PacketPool.cpp
-source/libraries/raknet/ExtendedOverlappedPool.cpp
-source/libraries/raknet/RakServer.cpp
-source/libraries/raknet/RPCNode.cpp
-source/libraries/raknet/RSA.cpp
-source/libraries/raknet/RakClient.cpp
-source/libraries/raknet/HuffmanEncodingTreeFactory.cpp
-source/libraries/raknet/RakPeer.cpp
-source/libraries/raknet/SocketLayer.cpp
-source/libraries/raknet/StringCompressor.cpp
-source/libraries/raknet/DataBlockEncryptor.cpp
-source/libraries/raknet/InternalPacketPool.cpp
-source/libraries/raknet/SHA1.cpp
-source/libraries/raknet/rand.cpp
-source/libraries/raknet/GetTime.cpp
-source/libraries/raknet/EncodeClassName.cpp
-source/libraries/raknet/NetworkObject.cpp
-source/libraries/raknet/SimpleMutex.cpp
-source/libraries/raknet/Euclid.cpp
-source/libraries/raknet/DistributedNetworkObjectStub.cpp
-source/libraries/raknet/ReliabilityLayer.cpp
-source/libraries/raknet/AsynchronousFileIO.cpp
-source/libraries/raknet/HuffmanEncodingTree.cpp
-source/libraries/raknet/BitStream.cpp
-source/libraries/raknet/RakNetworkFactory.cpp
-source/libraries/raknet/DistributedNetworkObject.cpp
-source/libraries/raknet/MPUInt.cpp
-source/libraries/raknet/CheckSum.cpp
-source/libraries/raknet/DistributedNetworkObjectManager.cpp
-source/libraries/raknet/NetworkTypes.cpp
-source/libraries/jpgalleg/io.c
-source/libraries/jpgalleg/encode.c
-source/libraries/jpgalleg/decode.c
-source/libraries/jpgalleg/jpgalleg.c
-source/scp.cpp
-source/doxygen.cpp
-source/input.cpp
+source/other/shippart.cpp
+source/other/twconfig.cpp
+source/other/vbodies.cpp
+source/other/vtarget.cpp
+source/sc1ships/shpandgu.cpp
+source/sc1ships/shparisk.cpp
+source/sc1ships/shpchebr.cpp
 source/sc1ships/shpearcr.cpp
-source/sc1ships/shpchebr.cpp
-source/sc1ships/shpandgu.cpp
 source/sc1ships/shpilwav.cpp
 source/sc1ships/shpkzedr.cpp
-source/sc1ships/shpyehte.cpp
+source/sc1ships/shpmmrxf.cpp
+source/sc1ships/shpmycpo.cpp
+source/sc1ships/shpshosc.cpp
+source/sc1ships/shpspael.cpp
 source/sc1ships/shpsyrpe.cpp
-source/sc1ships/shpspael.cpp
+source/sc1ships/shpumgdr.cpp
 source/sc1ships/shpvuxin.cpp
-source/sc1ships/shpumgdr.cpp
-source/sc1ships/shparisk.cpp
-source/sc1ships/shpmycpo.cpp
-source/sc1ships/shpmmrxf.cpp
-source/sc1ships/shpshosc.cpp
-source/sc2ships/shpthrto.cpp
-source/sc2ships/shporzne.cpp
+source/sc1ships/shpyehte.cpp
+source/sc2ships/shpchmav.cpp
 source/sc2ships/shpdruma.cpp
+source/sc2ships/shpkohma.cpp
 source/sc2ships/shpmeltr.cpp
-source/sc2ships/shpchmav.cpp
-source/sc2ships/shpkohma.cpp
-source/sc2ships/shputwju.cpp
-source/sc2ships/shpsupbl.cpp
+source/sc2ships/shporzne.cpp
 source/sc2ships/shppkufu.cpp
 source/sc2ships/shpslypr.cpp
+source/sc2ships/shpsupbl.cpp
+source/sc2ships/shpthrto.cpp
+source/sc2ships/shputwju.cpp
 source/sc2ships/shpzfpst.cpp
-source/gui.cpp
+source/scp.cpp
+source/ships/shpaktgu.cpp
+source/ships/shpalabc.cpp
+source/ships/shpbahbu.cpp
+source/ships/shpbipka.cpp
+source/ships/shpbogce.cpp
+source/ships/shpchoex.cpp
+source/ships/shpconca.cpp
+source/ships/shpconho.cpp
+source/ships/shpdragr.cpp
+source/ships/shpearc3.cpp
+source/ships/shpforsh.cpp
+source/ships/shpgarty.cpp
+source/ships/shpilwsp.cpp
+source/ships/shpkahbo.cpp
+source/ships/shprogsq.cpp
+source/ships/shpstaba.cpp
+source/ships/shptauar.cpp
+source/ships/shptauda.cpp
+source/ships/shptaume.cpp
+source/ships/shptausl.cpp
+source/ships/shptaust.cpp
+source/ships/shptauto.cpp
+source/ships/shpwolmi.cpp
+source/ships/shpyusra.cpp
+source/ships/shpzeksh.cpp
+source/tests/testdatapath.cpp
+source/tests/testmain.cpp
+source/util/aarot.c
+source/util/aastr.c
+source/util/aautil.c
+source/util/base.cpp
+source/util/endian.cpp
+source/util/errors.cpp
+source/util/errors_c.c
+source/util/get_time.c
+source/util/history.cpp
+source/util/pmask.c
+source/util/random.cpp
+source/util/round.c
+source/util/sound.cpp
+source/util/types.cpp
+source/util/vector2.cpp



From youbastrd at sheep.berlios.de  Mon Nov 22 19:58:51 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Mon, 22 Nov 2004 19:58:51 +0100
Subject: [Tw-light-svn] r97 - branches/mp-branch-2/source/games trunk/source/games
Message-ID: <200411221858.iAMIwpAm000443@sheep.berlios.de>

Author: youbastrd
Date: 2004-11-22 19:58:50 +0100 (Mon, 22 Nov 2004)
New Revision: 97

Modified:
   branches/mp-branch-2/source/games/glegacies.cpp
   trunk/source/games/glegacies.cpp
Log:
quick n dirty compile fix

Modified: branches/mp-branch-2/source/games/glegacies.cpp
===================================================================
--- branches/mp-branch-2/source/games/glegacies.cpp	2004-11-05 07:29:10 UTC (rev 96)
+++ branches/mp-branch-2/source/games/glegacies.cpp	2004-11-22 18:58:50 UTC (rev 97)
@@ -33,10 +33,10 @@
 #include "scp.h"
 #include "other/dialogs.h"
 
-#include "gadventure.h"
+//#include "gadventure.h"
 
 /// TW Legacies Adventure Game 
 ///
 
-REGISTER_GAME ( LegaciesGame, "TW:Legacies" )
+//REGISTER_GAME(LegaciesGame,"TW:Legacies")
 

Modified: trunk/source/games/glegacies.cpp
===================================================================
--- trunk/source/games/glegacies.cpp	2004-11-05 07:29:10 UTC (rev 96)
+++ trunk/source/games/glegacies.cpp	2004-11-22 18:58:50 UTC (rev 97)
@@ -33,10 +33,10 @@
 #include "scp.h"
 #include "other/dialogs.h"
 
-#include "gadventure.h"
+//#include "gadventure.h"
 
 /// TW Legacies Adventure Game 
 ///
 
-REGISTER_GAME ( LegaciesGame, "TW:Legacies" )
+//REGISTER_GAME ( LegaciesGame, "TW:Legacies" )
 



From yurand at sheep.berlios.de  Sun Nov 28 11:13:17 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 28 Nov 2004 11:13:17 +0100
Subject: [Tw-light-svn] r98 - in trunk/source: . util
Message-ID: <200411281013.iASADHJN015643@sheep.berlios.de>

Author: yurand
Date: 2004-11-28 11:13:16 +0100 (Sun, 28 Nov 2004)
New Revision: 98

Modified:
   trunk/source/scp.cpp
   trunk/source/util/sound.cpp
Log:
Fixed issue 0000032: Add command-line parameters to disable sound 


Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-11-22 18:58:50 UTC (rev 97)
+++ trunk/source/scp.cpp	2004-11-28 10:13:16 UTC (rev 98)
@@ -593,61 +593,77 @@
     set_gamma( gamma );
     
     int inputs = 7;
+    bool sound_enabled = true;
     
     // parse command-line arguments
-    for (i = 1; i < argc; i += 1) {
-      if (false) ;
-      else if (!strcmp(argv[i], "-res") && (argc > i + 2)) {
-	log_debug("command-line argument -res\n");
-	screen_width = atoi(argv[i+1]);
-	screen_height = atoi(argv[i+2]);
-	i += 2;
-      }
-      else if (!strcmp(argv[i], "-bpp") && (argc > i + 1)) {
-	log_debug("command-line argument -bpp\n");
-	screen_bpp = atoi(argv[i+1]);
-	i += 1;
-      }
-      else if (!strcmp(argv[i], "-fullscreen") && (argc > i + 0)) {
-	log_debug("command-line argument -fullscreen\n");
-	fullscreen = true;
-      }
-      else if (!strcmp(argv[i], "-window") && (argc > i + 0)) {
-	log_debug("command-line argument -window\n");
-	fullscreen = false;
-      }
-      else if (!strcmp(argv[i], "-nokeyboard") && (argc > i + 0)) {
-	log_debug("command-line argument -nokeyboard\n");
-	inputs &= ~1;
-      }
-      else if (!strcmp(argv[i], "-nomouse") && (argc > i + 0)) {
-	log_debug("command-line argument -nomouse\n");
-	inputs &= ~2;
-      }
-      else if (!strcmp(argv[i], "-nojoystick") && (argc > i + 0)) {
-	log_debug("command-line argument -nojoystick\n");
-	inputs &= ~4;
-			}
-      else if (!strcmp(argv[i], "-noidle") && (argc > i + 0)) {
-	log_debug("command-line argument -noidle\n");
-	_no_idle = 1;
-      }
-      else if (!strcmp(argv[i], "-play") && (argc > i + 2)) {
-	log_debug("command-line argument -play\n");
-	auto_play = argv[i+1];
-	auto_param = argv[i+2];
-	i += 2;
-	if ((argc > i + 0) && (argv[i][0] != '-')) 
+    for (i = 1; i < argc; i += 1) 
+      {
+	if (!strcmp(argv[i], "-res") && (argc > i + 2)) 
 	  {
-	    auto_port = atoi(argv[i]);
+	    log_debug("command-line argument -res\n");
+	    screen_width = atoi(argv[i+1]);
+	    screen_height = atoi(argv[i+2]);
+	    i += 2;
+	  }
+	else if (!strcmp(argv[i], "-bpp") && (argc > i + 1)) 
+	  {
+	    log_debug("command-line argument -bpp\n");
+	    screen_bpp = atoi(argv[i+1]);
 	    i += 1;
 	  }
+	else if (!strcmp(argv[i], "-fullscreen")) 
+	  {
+	    log_debug("command-line argument -fullscreen\n");
+	    fullscreen = true;
+	  }
+	else if (!strcmp(argv[i], "-window")) 
+	  {
+	    log_debug("command-line argument -window\n");
+	    fullscreen = false;
+	  }
+	else if(!strcmp(argv[i], "-nosound")) 
+	  {
+	    sound_enabled = false;
+	  }
+	else if (!strcmp(argv[i], "-nokeyboard")) 
+	  {
+	    log_debug("command-line argument -nokeyboard\n");
+	    inputs &= ~1;
+	  }
+	else if (!strcmp(argv[i], "-nomouse")) 
+	  {
+	    log_debug("command-line argument -nomouse\n");
+	    inputs &= ~2;
+	  }
+	else if (!strcmp(argv[i], "-nojoystick")) 
+	  {
+	    log_debug("command-line argument -nojoystick\n");
+	    inputs &= ~4;
+	  }
+	else if (!strcmp(argv[i], "-noidle")) 
+	  {
+	    log_debug("command-line argument -noidle\n");
+	    _no_idle = 1;
+	  }
+	else if (!strcmp(argv[i], "-play") && (argc > i + 2)) 
+	  {
+	    log_debug("command-line argument -play\n");
+	    auto_play = argv[i+1];
+	    auto_param = argv[i+2];
+	    i += 2;
+	    if ((argc > i + 0) && (argv[i][0] != '-')) 
+	      {
+		auto_port = atoi(argv[i]);
+		i += 1;
+	      }
+	  }
+	else 
+	  {
+	    log_debug("unrecognized command-line argument:");
+	    log_debug(argv[i]);
+	    log_debug("\n");
+	  }
       }
-      else 
-	{
-	  log_debug("unrecognized command-line argument\n");
-	}
-    }
     
     log_debug("command-line arguments parsed\n");
     
@@ -669,7 +685,7 @@
 
     enable_input(inputs);
     
-    SoundSystem sound;
+    SoundSystem sound(sound_enabled);
     tw_sound = &sound;
     tw_sound->set_sound_volume(tw_sound->load_sound_volume());
     tw_sound->set_music_volume(tw_sound->load_music_volume());

Modified: trunk/source/util/sound.cpp
===================================================================
--- trunk/source/util/sound.cpp	2004-11-22 18:58:50 UTC (rev 97)
+++ trunk/source/util/sound.cpp	2004-11-28 10:13:16 UTC (rev 98)
@@ -270,6 +270,9 @@
 
 bool SoundSystem::playing_music()
 {
+  if(!mix_ok)
+    return false;
+  
   STACKTRACE;
   return Mix_PlayingMusic();
 }



From yurand at sheep.berlios.de  Sun Nov 28 11:55:28 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 28 Nov 2004 11:55:28 +0100
Subject: [Tw-light-svn] r99 - trunk/source/util
Message-ID: <200411281055.iASAtS1p016754@sheep.berlios.de>

Author: yurand
Date: 2004-11-28 11:55:27 +0100 (Sun, 28 Nov 2004)
New Revision: 99

Modified:
   trunk/source/util/sound.cpp
Log:
Fixed issue 0000025: Sound settings are not being saved properly 


Modified: trunk/source/util/sound.cpp
===================================================================
--- trunk/source/util/sound.cpp	2004-11-28 10:13:16 UTC (rev 98)
+++ trunk/source/util/sound.cpp	2004-11-28 10:55:27 UTC (rev 99)
@@ -210,6 +210,9 @@
   if(!mix_ok)
     return;
   
+  tw_set_config_file("client.ini");
+  set_config_float("Sound", "MusicVolume", vol);
+
   if(vol < 0.05) 
     {
       Mix_HaltMusic();
@@ -230,8 +233,6 @@
 	  play_music(music);
 	}
     }
-  tw_set_config_file("client.ini");
-  set_config_float("Sound", "MusicVolume", vol);
 }
 
 void SoundSystem::set_sound_volume(double vol)
@@ -243,7 +244,6 @@
   if(vol < 0.05) 
     {
       sound_off = true;
-      return;
     } 
   else 
     {



From yurand at sheep.berlios.de  Sun Nov 28 12:51:41 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 28 Nov 2004 12:51:41 +0100
Subject: [Tw-light-svn] r100 - in trunk: gamedata/default_ini source/util
Message-ID: <200411281151.iASBpfVE026882@sheep.berlios.de>

Author: yurand
Date: 2004-11-28 12:51:35 +0100 (Sun, 28 Nov 2004)
New Revision: 100

Modified:
   trunk/gamedata/default_ini/client.ini
   trunk/source/util/sound.cpp
   trunk/source/util/sound.h
Log:
Fixed issue 0000021: Sounds are delayed 


Modified: trunk/gamedata/default_ini/client.ini
===================================================================
--- trunk/gamedata/default_ini/client.ini	2004-11-28 10:55:27 UTC (rev 99)
+++ trunk/gamedata/default_ini/client.ini	2004-11-28 11:51:35 UTC (rev 100)
@@ -23,6 +23,7 @@
 [Sound]
 SoundVolume = 0.5
 MusicVolume = 0.5
+SoundBuffer = 1024
 
 
 [Planet]

Modified: trunk/source/util/sound.cpp
===================================================================
--- trunk/source/util/sound.cpp	2004-11-28 10:55:27 UTC (rev 99)
+++ trunk/source/util/sound.cpp	2004-11-28 11:51:35 UTC (rev 100)
@@ -42,15 +42,19 @@
       return;
     }
   
-  //sounds don't sound good on Windows unless the buffer size is 4k,
-  //but this seems to cause crashes on other systems...
-#ifdef WIN32
-  const size_t buf_size = 4096;
-#else
-  const size_t buf_size = 1024;
-#endif
+  tw_set_config_file("client.ini");
+  buf_size_ = get_config_int("Sound", "SoundBuffer", 1024);
+  if(buf_size_<1024)
+    {
+      buf_size_=1024;
+    }
+  else if(buf_size_>4096)
+    {
+      buf_size_ = 4096;
+    }
+
   
-  int res = Mix_OpenAudio(MIX_DEFAULT_FREQUENCY,MIX_DEFAULT_FORMAT,2,buf_size);
+  int res = Mix_OpenAudio(MIX_DEFAULT_FREQUENCY,MIX_DEFAULT_FORMAT,2,buf_size_);
   if(res >= 0) 
     {
       mix_ok = true;

Modified: trunk/source/util/sound.h
===================================================================
--- trunk/source/util/sound.h	2004-11-28 10:55:27 UTC (rev 99)
+++ trunk/source/util/sound.h	2004-11-28 11:51:35 UTC (rev 100)
@@ -38,6 +38,8 @@
   Uint16 format;
   int channels;
 
+  size_t buf_size_;
+
  public:
   SoundSystem(bool sound_on = true);
   ~SoundSystem();



From yurand at sheep.berlios.de  Sun Nov 28 18:15:56 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 28 Nov 2004 18:15:56 +0100
Subject: [Tw-light-svn] r101 - trunk/source/libraries/raknet
Message-ID: <200411281715.iASHFu0w014812@sheep.berlios.de>

Author: yurand
Date: 2004-11-28 18:15:55 +0100 (Sun, 28 Nov 2004)
New Revision: 101

Modified:
   trunk/source/libraries/raknet/ArrayList.h
   trunk/source/libraries/raknet/AsynchronousFileIO.cpp
   trunk/source/libraries/raknet/BinarySearchTree.h
   trunk/source/libraries/raknet/BitStream.cpp
   trunk/source/libraries/raknet/BitStream.h
   trunk/source/libraries/raknet/ClientContextStruct.h
   trunk/source/libraries/raknet/DataBlockEncryptor.cpp
   trunk/source/libraries/raknet/DataBlockEncryptor.h
   trunk/source/libraries/raknet/DistributedNetworkObject.cpp
   trunk/source/libraries/raknet/DistributedNetworkObject.h
   trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h
   trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp
   trunk/source/libraries/raknet/EncodeClassName.cpp
   trunk/source/libraries/raknet/GetTime.cpp
   trunk/source/libraries/raknet/GetTime.h
   trunk/source/libraries/raknet/HuffmanEncodingTree.cpp
   trunk/source/libraries/raknet/HuffmanEncodingTree.h
   trunk/source/libraries/raknet/InternalPacket.h
   trunk/source/libraries/raknet/InternalPacketPool.cpp
   trunk/source/libraries/raknet/LinkedList.h
   trunk/source/libraries/raknet/Multiplayer.h
   trunk/source/libraries/raknet/NetworkTypes.cpp
   trunk/source/libraries/raknet/NetworkTypes.h
   trunk/source/libraries/raknet/PacketEnumerations.h
   trunk/source/libraries/raknet/PacketPriority.h
   trunk/source/libraries/raknet/Queue.h
   trunk/source/libraries/raknet/RakClient.cpp
   trunk/source/libraries/raknet/RakClient.h
   trunk/source/libraries/raknet/RakClientInterface.h
   trunk/source/libraries/raknet/RakNetworkFactory.h
   trunk/source/libraries/raknet/RakPeer.cpp
   trunk/source/libraries/raknet/RakPeer.h
   trunk/source/libraries/raknet/RakPeerInterface.h
   trunk/source/libraries/raknet/RakServer.cpp
   trunk/source/libraries/raknet/RakServer.h
   trunk/source/libraries/raknet/RakServerInterface.h
   trunk/source/libraries/raknet/ReliabilityLayer.cpp
   trunk/source/libraries/raknet/ReliabilityLayer.h
   trunk/source/libraries/raknet/SHA1.h
   trunk/source/libraries/raknet/SimpleMutex.cpp
   trunk/source/libraries/raknet/SimpleMutex.h
   trunk/source/libraries/raknet/SocketLayer.cpp
   trunk/source/libraries/raknet/SocketLayer.h
   trunk/source/libraries/raknet/StringCompressor.cpp
   trunk/source/libraries/raknet/StringCompressor.h
Log:
Updating RakNet sources to latest version since they fixed some compile 
errors


Modified: trunk/source/libraries/raknet/ArrayList.h
===================================================================
--- trunk/source/libraries/raknet/ArrayList.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ArrayList.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -125,11 +125,7 @@
 template <class list_type>
 inline list_type& List<list_type>::operator[] (unsigned long position)
 {
-	if (position >= list_size)
-	{
-		assert(0); // Reading past the end of the list
-		return array[0];
-	}
+	assert (position < list_size);
 	return array[position];
 }
 

Modified: trunk/source/libraries/raknet/AsynchronousFileIO.cpp
===================================================================
--- trunk/source/libraries/raknet/AsynchronousFileIO.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/AsynchronousFileIO.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -269,7 +269,7 @@
 				{
 					assert(dwIoSize>0);
 
-					ProcessNetworkPacket(lpOverlapped->playerId.binaryAddress, lpOverlapped->playerId.port, lpOverlapped->data, dwIoSize, lpOverlapped->rakPeer);
+					ProcessNetworkPacket(lpOverlapped->binaryAddress, lpOverlapped->port, lpOverlapped->data, dwIoSize, lpOverlapped->rakPeer);
 	
 					// Issue a new read so we always have one outstanding read per socket
 					// Finished a read.  Reuse the overlapped pointer

Modified: trunk/source/libraries/raknet/BinarySearchTree.h
===================================================================
--- trunk/source/libraries/raknet/BinarySearchTree.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/BinarySearchTree.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -52,6 +52,8 @@
 The assignment operator is defined between BinarySearchTree and AVLBalancedBinarySearchTree as long as they are of the same template type. However, passing a BinarySearchTree to an AVLBalancedBinarySearchTree will lose its structure unless it happened to be AVL balanced to begin with
 Requires queue_linked_list.cpp for the breadth first search used in the copy constructor, overloaded assignment operator, and display_breadth_first_search.
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
+
 */
 
 #ifndef __BINARY_SEARCH_TREE_H
@@ -156,7 +158,7 @@
 				break;
 		}
 
-		if (current==root)
+		if (current==this->root)
 			break;
 
 		current=find_parent(*(current->item));
@@ -234,11 +236,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A->left=C;
+		if (this->direction==this->LEFT) A->left=C;
 			else A->right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this->root=C;  // If B has no parent parent then B must have been the root node
 
 	B->left = D;
 	C->right = B;
@@ -293,11 +295,11 @@
 	if (A)
 	{
 		// Direction was set by the last find_parent call
-		if (direction==LEFT) A->left=C;
+		if (this->direction==this->LEFT) A->left=C;
 			else A->right=C;
 	}
 	else
-		root=C;  // If B has no parent parent then B must have been the root node
+		this->root=C;  // If B has no parent parent then B must have been the root node
 
 	B->right = D;
 	C->left = B;
@@ -314,7 +316,7 @@
 template <class BinarySearchTreeType>
 AVLBalancedBinarySearchTree<BinarySearchTreeType>::~AVLBalancedBinarySearchTree()
 {
-	clear();
+	this->clear();
 }
 
 template <class BinarySearchTreeType>
@@ -358,7 +360,7 @@
 template <class BinarySearchTreeType>
 BinarySearchTree<BinarySearchTreeType>::~BinarySearchTree()
 {
-	clear();
+	this->clear();
 }
 
 template <class BinarySearchTreeType>
@@ -367,7 +369,7 @@
 	static typename BinarySearchTree::node* tempnode;
 	static BinarySearchTreeType* dummyptr=0;
 	tempnode = find (element, &tempnode);
-	if (direction==NOT_FOUND)
+	if (this->direction==this->NOT_FOUND)
 		return dummyptr;
 
 	return tempnode->item;
@@ -378,24 +380,24 @@
 {
 	static typename BinarySearchTree::node* current;
 
-	current=root;
+	current=this->root;
 	*parent=0;
-	direction=ROOT;
+	this->direction=this->ROOT;
 
 	if (BinarySearchTree_size==0L) 
 	{
-		direction=NOT_FOUND;
+		this->direction=this->NOT_FOUND;
 		return current=0;
 	}
 
 	// Check if the item is at the root
-	if (element == *(current->item)) {direction=ROOT; return current;}
+	if (element == *(current->item)) {this->direction=this->ROOT; return current;}
 
 	while (true)
 	{	
 		// Move pointer
-		if (element < *(current->item)) {*parent=current; direction=LEFT; current=current->left;}
-		else if (element > *(current->item)) {*parent=current; direction=RIGHT; current=current->right;}
+		if (element < *(current->item)) {*parent=current; this->direction=this->LEFT; current=current->left;}
+		else if (element > *(current->item)) {*parent=current; this->direction=this->RIGHT; current=current->right;}
 		
 		if (current==0) break;
 
@@ -404,7 +406,7 @@
 	}
 	
 
-	direction=NOT_FOUND;
+	this->direction=this->NOT_FOUND;
 	return current=0;
 }
 

Modified: trunk/source/libraries/raknet/BitStream.cpp
===================================================================
--- trunk/source/libraries/raknet/BitStream.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/BitStream.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -26,6 +26,8 @@
 #include <stdio.h>
 #include <string.h>
 
+using namespace RakNet;
+
 BitStream::BitStream()
 {
 	numberOfBitsUsed=0;
@@ -35,7 +37,7 @@
 #ifdef _DEBUG
 	assert(data);
 #endif
-	memset(data, 0, 32);
+	//memset(data, 0, 32);
 	copyData=true;
 }
 
@@ -48,7 +50,7 @@
 	#ifdef _DEBUG
 	assert(data);
 	#endif
-	memset(data, 0, initialBytesToAllocate);
+//	memset(data, 0, initialBytesToAllocate);
 	copyData=true;
 }
 
@@ -92,14 +94,18 @@
 
 void BitStream::Reset(void)
 {
+	if (numberOfBitsUsed>0)
+	{
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsUsed));
+	}
 	// Don't free memory here for speed efficiency
 	//free(data);  // Use realloc and free so we are more efficient than delete and new for resizing
 	numberOfBitsUsed=0;
 	//numberOfBitsAllocated=8;
 	readOffset=0;
 	//data=(unsigned char*)malloc(1);
-	if (numberOfBitsAllocated>0)
-		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
+//	if (numberOfBitsAllocated>0)
+//		memset(data, 0, BITS_TO_BYTES(numberOfBitsAllocated));
 }
 
 // Write the native types to the end of the buffer
@@ -598,8 +604,11 @@
 {
 	AddBitsAndReallocate(1);
 
-	// New bits are set to 0 as default
-	numberOfBitsUsed++;
+	// New bytes need to be zeroed
+	if ((numberOfBitsUsed%8)==0)
+		data[numberOfBitsUsed>>3] = 0;
+
+	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
  // Write a 1
@@ -607,7 +616,12 @@
 {
 	AddBitsAndReallocate(1);
 
-	data[numberOfBitsUsed>>3] |= 0x80 >> (numberOfBitsUsed%8); // Set the bit to 1
+	int numberOfBitsMod8 = numberOfBitsUsed%8;
+	if (numberOfBitsMod8==0)
+		data[numberOfBitsUsed>>3] = 0x80;
+	else
+		data[numberOfBitsUsed>>3] |= 0x80 >> (numberOfBitsMod8); // Set the bit to 1
+	
 	numberOfBitsUsed++; // This ++ was in the line above - but boundschecker didn't like that for some reason.
 }
 
@@ -681,8 +695,8 @@
 // Write numberToWrite bits from the input source
 void BitStream::WriteBits(unsigned char *input, int numberOfBitsToWrite, bool rightAlignedBits)
 {
-	if (numberOfBitsToWrite<=0)
-		return;
+//	if (numberOfBitsToWrite<=0)
+//		return;
 
 	AddBitsAndReallocate(numberOfBitsToWrite);
 	int offset=0;
@@ -691,19 +705,31 @@
 
 	numberOfBitsUsedMod8=numberOfBitsUsed%8;
 
-	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToWrite>0)
+	//do
 	{
 		dataByte = *(input+offset);
 		if (numberOfBitsToWrite<8 && rightAlignedBits) // rightAlignedBits means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation)
 			dataByte<<=8-numberOfBitsToWrite;	 // shift left to get the bits on the left, as in our internal representation
 
-		// Copy over the new data.
-		*(data+(numberOfBitsUsed>>3)) |= dataByte >> (numberOfBitsUsedMod8); // First half
-		if (8 - (numberOfBitsUsedMod8) < 8 && 8 - (numberOfBitsUsedMod8) < numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
-			*(data+(numberOfBitsUsed>>3) + 1) |= (unsigned char)(dataByte << (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
-	
+		// Writing to a new byte each time
+		if (numberOfBitsUsedMod8==0)
+			*(data+(numberOfBitsUsed>>3)) = dataByte;
+		else
+		{
+			// Copy over the new data.
+			*(data+(numberOfBitsUsed>>3)) |= dataByte >> (numberOfBitsUsedMod8); // First half
+			if (8 - (numberOfBitsUsedMod8) < 8 && 8 - (numberOfBitsUsedMod8) < numberOfBitsToWrite) // If we didn't write it all out in the first half (8 - (numberOfBitsUsed%8) is the number we wrote in the first half)
+			{
+				*(data+(numberOfBitsUsed>>3) + 1) = (unsigned char)(dataByte << (8 - (numberOfBitsUsedMod8))); // Second half (overlaps byte boundary)
+			}
+		}
+
 		if (numberOfBitsToWrite>=8)
+		{
 			numberOfBitsUsed+= 8;
+		}
 		else
 		{
 			numberOfBitsUsed+= numberOfBitsToWrite;
@@ -711,8 +737,8 @@
 		numberOfBitsToWrite-= 8;
 		
 		offset++;
-	} while(numberOfBitsToWrite>0);
-
+	}
+//	} while(numberOfBitsToWrite>0);
 }
 
 // Set the stream to some initial data.  For internal use
@@ -760,7 +786,7 @@
 			Write(b);
 
 			WriteBits(input,(currentByte+1)<<3, true);
-			currentByte--;
+	//		currentByte--;
 
 	
 			return;
@@ -793,8 +819,8 @@
 	#ifdef _DEBUG
 	assert(numberOfBitsToRead>0);
 	#endif
-	if (numberOfBitsToRead<=0)
-		return false;
+//	if (numberOfBitsToRead<=0)
+//		return false;
 
 	if (readOffset+numberOfBitsToRead >numberOfBitsUsed)
 		return false;
@@ -806,7 +832,9 @@
 
 	readOffsetMod8=readOffset%8;
 
-	do
+//	do
+	// Faster to put the while at the top surprisingly enough
+	while(numberOfBitsToRead>0)
 	{
 			*(output + offset) |= *(data+(readOffset>>3)) << (readOffsetMod8); // First half
 
@@ -825,7 +853,8 @@
 
 			offset++;
 
-	} while(numberOfBitsToRead>0);
+	}
+	//} while(numberOfBitsToRead>0);
 
 	return true;
 }
@@ -920,7 +949,7 @@
 		#ifdef _DEBUG
 		assert(data); // Make sure realloc succeeded
 		#endif
-		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
+//		memset(data+newByteOffset, 0,  ((newNumberOfBitsAllocated-1)>>3) - ((numberOfBitsAllocated-1)>>3)); // Set the new data block to 0
 	}
 
 	if (newNumberOfBitsAllocated > numberOfBitsAllocated)

Modified: trunk/source/libraries/raknet/BitStream.h
===================================================================
--- trunk/source/libraries/raknet/BitStream.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/BitStream.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -10,6 +10,9 @@
 #ifndef  __BITSTREAM_H
 #define __BITSTREAM_H
 
+namespace RakNet
+{
+
 #define BITS_TO_BYTES(x) (((x)+7)>>3)
 
 class BitStream
@@ -168,4 +171,6 @@
 	bool copyData;
 };
 
+}
+
 #endif

Modified: trunk/source/libraries/raknet/ClientContextStruct.h
===================================================================
--- trunk/source/libraries/raknet/ClientContextStruct.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ClientContextStruct.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -30,7 +30,8 @@
 	OVERLAPPED overlapped;
 	char data[MAXIMUM_MTU_SIZE]; // Used to hold data to send
 	int length; // Length of the actual data to send, always under MAXIMUM_MTU_SIZE
-	PlayerID playerId;
+	unsigned long binaryAddress;
+	unsigned short port;
 	RakPeer *rakPeer;
 	bool read; // Set to true for reads, false for writes
 };

Modified: trunk/source/libraries/raknet/DataBlockEncryptor.cpp
===================================================================
--- trunk/source/libraries/raknet/DataBlockEncryptor.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DataBlockEncryptor.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -9,6 +9,9 @@
 {
 	keySet=false;
 }
+DataBlockEncryptor::~DataBlockEncryptor()
+{
+}
 bool DataBlockEncryptor::IsKeySet(void) const
 {
 	return keySet;
@@ -40,21 +43,22 @@
 
 	assert(input && inputLength);
 
+
 	// randomChar will randomize the data so the same data sent twice will not look the same
 	randomChar=(unsigned char)randomMT();
 
-
 	// 16-(((x-1) % 16)+1) 
 
 	// # of padding bytes is 16 -(((input_length + extra_data -1) % 16)+1)
 	paddingBytes = (unsigned char)(16 -(((inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad) -1) % 16)+1));
-	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
 
 	// Randomize the pad size variable
 	encodedPad=(unsigned char)randomMT();
 	encodedPad<<=4;
 	encodedPad|=paddingBytes;
 
+	*outputLength=inputLength + sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes;
+
 	// Write the data first, in case we are overwriting ourselves
 	if (input==output)
 		memmove(output+sizeof(checkSum)+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes, input, inputLength);
@@ -108,9 +112,6 @@
 	
 	if (input==0 || inputLength<16 || (inputLength % 16) != 0)
 	{
-#ifdef _DEBUG
-		assert(0);
-#endif
 		return false;
 	}
 
@@ -121,7 +122,7 @@
 
 		for (byteIndex=0; byteIndex<16; byteIndex++)
 		{
-			if (index+16==inputLength)
+			if (index+16==(unsigned)inputLength)
 				input[index+byteIndex]^=input[byteIndex];
 			else
 				input[index+byteIndex]^=input[index+16+byteIndex];
@@ -142,10 +143,11 @@
 	// Ignore the high 4 bytes
 	paddingBytes=encodedPad&0x0F;
 
+
 	// Get the data length
 	*outputLength=inputLength - sizeof(randomChar)-sizeof(checkSum)-sizeof(encodedPad)-paddingBytes;
 
-	// Calculate the checksum on the data
+	// Calculate the checksum on the data.
 	checkSumCalculator.add(input+sizeof(checkSum), *outputLength+sizeof(randomChar)+sizeof(encodedPad)+paddingBytes);
 	if (checkSum != checkSumCalculator.get())
 		return false;
@@ -156,5 +158,6 @@
 	else
 		memcpy(output, input+sizeof(randomChar)+sizeof(checkSum)+sizeof(encodedPad)+paddingBytes, *outputLength);
 
+
 	return true;
 }

Modified: trunk/source/libraries/raknet/DataBlockEncryptor.h
===================================================================
--- trunk/source/libraries/raknet/DataBlockEncryptor.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DataBlockEncryptor.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -7,6 +7,7 @@
 {
 public:
 	DataBlockEncryptor();
+	~DataBlockEncryptor();
 	bool IsKeySet(void) const;
 
 	void SetKey(const unsigned char key[16]);

Modified: trunk/source/libraries/raknet/DistributedNetworkObject.cpp
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObject.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObject.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -17,6 +17,7 @@
 #include <string.h>
 #include "DistributedNetworkObjectManager.h"
 
+
 DistributedNetworkObject::DistributedNetworkObject()
 {
 	maximumUpdateFrequency=50; // 50 ms by default
@@ -35,8 +36,8 @@
 	if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface())
 	{
 		// These 3 lines of code will broadcast to destroy the object
-		BitStream bitStream;
-		SerializeClassHeader(&bitStream, 0, false, false, 0);
+		RakNet::BitStream bitStream;
+		SerializeClassHeader(&bitStream, 0, 0, false, 0);
 		BroadcastSerializedClass(&bitStream);
 	}
 
@@ -55,8 +56,8 @@
 void DistributedNetworkObject::DestroyObjectOnNetwork(void)
 {
 	// These 3 lines of code will broadcast to destroy the object
-	BitStream bitStream;
-	SerializeClassHeader(&bitStream, 0, false, false, 0);
+	RakNet::BitStream bitStream;
+	SerializeClassHeader(&bitStream, 0, 0, false, 0);
 	BroadcastSerializedClass(&bitStream);
 
 	DistributedNetworkObjectManager::Instance()->UnregisterNetworkObject(this);
@@ -68,7 +69,7 @@
 	}
 }
 
-void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority)
+void DistributedNetworkObject::SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority)
 {
 	// Was memory previously allocated?
 	if (heapNodeList[memoryBlockIndex].lastWriteValue)
@@ -96,7 +97,7 @@
 	heapNodeList[memoryBlockIndex].watchedData=memoryBlock;
 
 	// Initialize nextUpdateTime to the current time.
-	heapNodeList[memoryBlockIndex].nextUpdateTime=getTime();
+	heapNodeList[memoryBlockIndex].nextUpdateTime=RakNetGetTime();
 
 	// Set the authority
 	heapNodeList[memoryBlockIndex].serverAuthority=serverAuthority;
@@ -130,12 +131,12 @@
 }
 // Same as ProcessDistributedMemoryStack, but for the heapNodeList.
 // Returns true if data was written
-bool DistributedNetworkObject::WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite)
+bool DistributedNetworkObject::WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite)
 {
     int heapNodeIndex;
 	unsigned long time;
-	BitStream heapData(256);
-	time=getTime();
+	RakNet::BitStream heapData(256);
+	time=RakNetGetTime();
 	unsigned char numberOfBlocksWritten;
 
 	numberOfBlocksWritten=0;
@@ -143,7 +144,7 @@
 	for (heapNodeIndex=0; heapNodeIndex < 256; heapNodeIndex++)
 	{
 		// Is this a block we are responsible for updating, and it is time to update?
-		if (IsMemoryBlockIndexUsed(heapNodeIndex) &&
+		if (IsMemoryBlockIndexUsed((unsigned char)heapNodeIndex) &&
 			forceWrite ||
 			(time >= heapNodeList[heapNodeIndex].nextUpdateTime &&
 			((DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && heapNodeList[heapNodeIndex].serverAuthority) ||
@@ -172,24 +173,35 @@
 
 	if (numberOfBlocksWritten>0)
 	{
+		bitStream->Write(true);
 		bitStream->WriteCompressed(numberOfBlocksWritten);
 		bitStream->Write((char*)heapData.GetData(), heapData.GetNumberOfBytesUsed());
 		return true;
 	}
+	else
+		bitStream->Write(false);
 
+	if (forceWrite)
+		WriteCreationData(bitStream);
+
 	return false;
 }
 
-void DistributedNetworkObject::WriteToHeapFromBitstream(BitStream *bitStream)
+void DistributedNetworkObject::WriteToHeapFromBitstream(RakNet::BitStream *bitStream)
 {
 	int index;
 	unsigned char heapNodeIndex;
 	unsigned char numberOfBlocksWritten;
+	bool anyDataWritten;
 
 #ifdef _DEBUG
 	unsigned short usedBlockSize;
 #endif
 
+	bitStream->Read(anyDataWritten);
+	if (anyDataWritten==false)
+		return;
+
 	bitStream->ReadCompressed(numberOfBlocksWritten);
 
 	for (index=0; index < numberOfBlocksWritten; index++)
@@ -230,7 +242,7 @@
 }
 
 // Writes to or reads from a bitstream for all distributed memory.  This function does not need to be modified by the end-user
-bool DistributedNetworkObject::ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
+bool DistributedNetworkObject::ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)
 {
 	return false;
 }
@@ -256,7 +268,7 @@
 	 (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->IsConnected()))
 	{
 		char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 
 		if (isClassIDEncoded)
 			memcpy(classIdentifier, classID, MAXIMUM_CLASS_IDENTIFIER_LENGTH);
@@ -267,24 +279,34 @@
 		// The only purpose of registering and unregistering network objects is so we can call SendAllDistributedObjects from
 		// DistributedNetworkObjectManager to new players
 		firstTimeAddedToRegistry = DistributedNetworkObjectManager::Instance()->RegisterNetworkObject(this,classIdentifier, localObjectIdentifier);
+		if (serverProcess && firstTimeAddedToRegistry && isClassIDEncoded==false)
+		{
+			// This is like a local echo - call OnDistributedObjectCreation for the server when it is not
+			// created by the network
+			if (OnDistributedObjectCreation(UNASSIGNED_PLAYER_ID)==false)
+			{
+				DistributedNetworkObjectManager::Instance()->UnregisterNetworkObject(this);
+				return;
+			}
+		}
 
 		// This logic is correct - ProcessDistributedMemoryStack has a side effect of updating network memory to the last send so you don't
 		// want to call it unnecessarily
 		if (firstTimeAddedToRegistry && (localObject || DistributedNetworkObjectManager::Instance()->GetRakServerInterface()))
 		{
-			SerializeClassHeader(&bitStream, classIdentifier, true, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&bitStream, classIdentifier, 2, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
 			ProcessDistributedMemoryStack(&bitStream, true, true,serverProcess);
-			WriteToBitstreamFromHeap(&bitStream, true);
+			WriteToBitstreamFromHeap(&bitStream, true);	
 			BroadcastSerializedClass(&bitStream);
 		}
 		else if ((localObject == false || DistributedNetworkObjectManager::Instance()->GetRakServerInterface()) &&
-			getTime() > lastBroadcastTime + maximumUpdateFrequency)
+			RakNetGetTime() > lastBroadcastTime + maximumUpdateFrequency)
 		{
-			SerializeClassHeader(&bitStream, classIdentifier, true, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
+			SerializeClassHeader(&bitStream, classIdentifier, 1, firstTimeAddedToRegistry && DistributedNetworkObjectManager::Instance()->GetRakClientInterface(), localObjectIdentifier);
 			dataWritten1=ProcessDistributedMemoryStack(&bitStream, true, false,serverProcess);
 			dataWritten2=WriteToBitstreamFromHeap(&bitStream, false);
 			if (dataWritten1 || dataWritten2)
-			{					
+			{
 				BroadcastSerializedClass(&bitStream);
 			}
 		}
@@ -293,12 +315,20 @@
 	InterpolateDistributedMemory(serverProcess);
 }
 
+void DistributedNetworkObject::WriteCreationData(RakNet::BitStream *initialData)
+{
+}
+
+void DistributedNetworkObject::ReadCreationData(RakNet::BitStream *initialData)
+{
+}
+
 void DistributedNetworkObject::SetMaximumUpdateFrequency(unsigned long frequency)
 {
 	maximumUpdateFrequency=frequency;
 }
 
-void DistributedNetworkObject::BroadcastSerializedClass(BitStream *bitStream)
+void DistributedNetworkObject::BroadcastSerializedClass(RakNet::BitStream *bitStream)
 {
 	if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 	{
@@ -310,28 +340,28 @@
 		}
 
 		DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, localClient, true);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 	else if (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->IsConnected())
 	{
 		// This sends a request to create or update the object
 		DistributedNetworkObjectManager::Instance()->GetRakClientInterface()->Send(bitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0);
-		lastBroadcastTime=getTime();
+		lastBroadcastTime=RakNetGetTime();
 	}
 }
 
-void DistributedNetworkObject::SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex)
+void DistributedNetworkObject::SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex)
 {
 	static const unsigned char packetId = ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT;
 
 	bitStream->Write(packetId);
 
 	// Construction to true means we are creating or updating this object.  Otherwise it means we are destroying this object.
-	bitStream->Write(construction);
+	bitStream->WriteBits((unsigned char*)&action, 2);
 
 	bitStream->Write(GetID());
 
-	if (construction)
+	if (action==2)
 	{
 		bitStream->Write(classIdentifier, classIdentifier[0]+1);
 	}
@@ -339,23 +369,39 @@
 	bitStream->Write(localObject);
 	if (localObject)
 		bitStream->Write(localObjectIndex);
+
+	if (action==2)
+	{
+		if (clientOwnerID==UNASSIGNED_PLAYER_ID)
+		{
+			bitStream->Write(false);
+		}
+		else
+		{
+			bitStream->Write(true);
+			bitStream->Write((char*)&clientOwnerID, sizeof(PlayerID));
+		}
+	}
+
 }
 
-bool DistributedNetworkObject::DeserializeClassHeader(BitStream *bitStream, bool &construction, ObjectID &objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex)
+bool DistributedNetworkObject::DeserializeClassHeader(RakNet::BitStream *bitStream, int &action, ObjectID &objectId, char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex, PlayerID &pid)
 {
 	unsigned char packetId;
+	bool hasClientOwnerID;
 	if (bitStream->Read(packetId)==false)
 		return false;
 
 	assert(packetId==ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT);
 
-	if (bitStream->Read(construction)==false)
+	action=0;
+	if (bitStream->ReadBits((unsigned char*)&action,2)==false)
 		return false;
 
 	if (bitStream->Read(objectId)==false)
 		return false;
 
-	if (construction)
+	if (action==2)
 	{
 		unsigned char classNameLength;
 		if (bitStream->Read(classNameLength)==false)
@@ -365,6 +411,8 @@
 
 		classIdentifier[0]=classNameLength;
 	}
+	else
+		classIdentifier=0;
 
 	bool isLocalObjectInpacket;
 	if (bitStream->Read(isLocalObjectInpacket)==false)
@@ -375,6 +423,19 @@
 			return false;
 	}
 
+	if (action==2)
+	{
+		if (bitStream->Read(hasClientOwnerID)==false)
+			return false;
+		if (hasClientOwnerID)
+		{
+			if (bitStream->Read((char*)&pid, sizeof(PlayerID))==false)
+				return false;
+		}
+		else
+			pid=UNASSIGNED_PLAYER_ID;
+	}	
+
 	return true;
 }
 
@@ -389,7 +450,6 @@
 
 bool DistributedNetworkObject::OnDistributedObjectCreation(PlayerID senderID)
 {
-	localObject=false;
 #ifdef _DEBUG
 	assert(GetID()!=UNASSIGNED_OBJECT_ID);
 #endif
@@ -430,3 +490,9 @@
 {
 	clientOwnerID=id;
 }
+
+void DistributedNetworkObject::SetLocalObject(bool b)
+{
+	localObject=b;
+}
+

Modified: trunk/source/libraries/raknet/DistributedNetworkObject.h
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObject.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObject.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -7,13 +7,13 @@
 
 // Refer to the appropriate license agreement for distribution, modification, and warranty rights.
 
+#ifndef __DISTRIBUTED_NETWORK_OBJECT
+#define __DISTRIBUTED_NETWORK_OBJECT
+
 #include "NetworkObject.h"
 #include "EncodeClassName.h"
-class BitStream;
+#include "BitStream.h"
 
-#ifndef __DISTRIBUTED_NETWORK_OBJECT
-#define __DISTRIBUTED_NETWORK_OBJECT
-
 class DistributedNetworkObject : public NetworkObject
 {
 public:
@@ -33,7 +33,6 @@
 	// If you wish to block deletion, override OnDistributedObjectDestruction
 	virtual void DestroyObjectOnNetwork(void);
 
-
 	// Server only function -
 	// By default, when a client creates an object only it can update the client authoritative members
 	// Of the class it creates.  You can also set this manually with SetClientOwnerID
@@ -55,7 +54,7 @@
 	
 	// Tags memory to be synchronized.  You can set the server or the client as the authority for this block.
 	// Only the authority will write this memory to the network when it is changed.
-	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, int memoryBlockSize, bool serverAuthority);
+	void SynchronizeMemory(unsigned char memoryBlockIndex, char* memoryBlock, unsigned short memoryBlockSize, bool serverAuthority);
 
 	// Untags memory that was formerly synchronized.
 	void DesynchronizeMemory(unsigned char memoryBlockIndex);
@@ -73,7 +72,19 @@
 	// --------------------------------------------------------------------------
 	// Events
 	// --------------------------------------------------------------------------
+	// When object creation data is needed, WriteCreationData is called.
+	// This function is for you to write any data that is needed to create or initialize the object
+	// On remote systems
+	virtual void WriteCreationData(RakNet::BitStream *initialData);
 
+	// When an object is created, ReadCreationData is called immediately after a 
+	// successful call to OnDistributedObjectCreation
+	// This function is for you to read any data written from WriteCreationData
+	// on remote systems.  If the object is created by the client, this function is
+	// also called by the creator of the object when sent back from the server in case the
+	// server overrode any settings
+	virtual void ReadCreationData(RakNet::BitStream *initialData);
+
 	// When distributed data changes for an object, this function gets called.  Default behavior is to do nothing.
 	// Override it if you want to perform updates when data is changed
 	// On the server it is also important to override this to make sure the data the client just sent you is reasonable.
@@ -101,34 +112,37 @@
 
 	// You don't need to modify this
 	// Sends the bitstream to other systems
-	virtual void BroadcastSerializedClass(BitStream *bitStream);
+	virtual void BroadcastSerializedClass(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Writes the header identifying the class, objectID, and whether the object is being created or destroyed
-	virtual void SerializeClassHeader(BitStream *bitStream, char *classIdentifier, bool construction, bool localObject, unsigned char localObjectIndex);
-	static bool DeserializeClassHeader(BitStream *bitStream, bool &construction, ObjectID &objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex);
+	// action of 0 means destruction, 1 means update, 2 means create
+	virtual void SerializeClassHeader(RakNet::BitStream *bitStream, char *classIdentifier, int action, bool localObject, unsigned char localObjectIndex);
+	static bool DeserializeClassHeader(RakNet::BitStream *bitStream, int &action, ObjectID &objectId,char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH], bool &localObject, unsigned char &localObjectIndex, PlayerID &pid);
 
 	// You don't need to modify this
 	// Returns true if this object was locally created, as opposed to created by the network
 	bool IsLocalObject(void) const;
+	void SetLocalObject(bool b);
 
 	// Writes to or reads from a bitstream for all distributed memory on the stack.  This function does not need to be modified by the end-user
 	// Returns true if any data was written
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to false, but for the heapNodeList.
 	// Returns true if data was written
-	bool WriteToBitstreamFromHeap(BitStream *bitStream, bool forceWrite);
+	bool WriteToBitstreamFromHeap(RakNet::BitStream *bitStream, bool forceWrite);
 
 	// Same as ProcessDistributedMemoryStack with isWrite to true, but for the heapNodeList.
-	void WriteToHeapFromBitstream(BitStream *bitStream);
+	void WriteToHeapFromBitstream(RakNet::BitStream *bitStream);
 
 	// You don't need to modify this
 	// Returns the identifier for an object that has not yet had SetID called on it
 	unsigned char GetLocalObjectIdentifier(void) const;
 
-	// Server only - select which client can update the client authoritative members of this object.
-	// UNASSIGNED_PLAYER_ID no client owns the object, so any client can update the object.
+	// This is set to who created this object.
+	// On the server, this also determines who can update the client authoritative members of this object.
+	// You can manually set it to UNASSIGNED_PLAYER_ID so no client owns the object, so any client can update the object.
 	PlayerID GetClientOwnerID(void) const;
 	void SetClientOwnerID(PlayerID id);
 

Modified: trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObjectHeader.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -49,7 +49,7 @@
 	BaseClass::DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -70,7 +70,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
 	SynchronizationMethod1##_INTERPOLATION_CODE(AuthoritativeNetwork1, VariableName1)	\
@@ -132,7 +132,7 @@
 	DOM_CORE_EXPANDED(AuthoritativeNetwork,VariableType,VariableName, ReadCode, ReadDummyCode, WriteCode, VariableName!=VariableName##_LastKnownValue)	\
 	if (isWrite==false && dataChanged==true)	\
 	{	\
-		VariableName##_InterpolationStartTime=getTime();	\
+		VariableName##_InterpolationStartTime=RakNetGetTime();	\
 		VariableName##_InterpolationEndTime=VariableName##_InterpolationStartTime+maximumUpdateFrequency;	\
 		VariableName##_InitialValue=VariableName;	\
 		VariableName##_FinalValue=VariableName##_LastReadValue;	\
@@ -214,7 +214,7 @@
 	SynchronizationMethod1##_INTERPOLATION_MEMORY_INIT(VariableName1)	\
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -234,7 +234,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -260,7 +260,7 @@
 	SynchronizationMethod2##_INTERPOLATION_MEMORY_INIT(VariableName2)	\
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 }	\
-virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -282,7 +282,7 @@
 \
 virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 		DistributedMemoryInit(isServerAuthoritative);	\
@@ -313,7 +313,7 @@
 	SynchronizationMethod3##_INTERPOLATION_MEMORY_INIT(VariableName3)	\
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -337,7 +337,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -373,7 +373,7 @@
 	SynchronizationMethod4##_INTERPOLATION_MEMORY_INIT(VariableName4)	\
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -399,7 +399,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\
@@ -440,7 +440,7 @@
 	SynchronizationMethod5##_INTERPOLATION_MEMORY_INIT(VariableName5)	\
 	SynchronizationMethod6##_INTERPOLATION_MEMORY_INIT(VariableName6)	\
 }	\
-	virtual bool ProcessDistributedMemoryStack(BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
+	virtual bool ProcessDistributedMemoryStack(RakNet::BitStream *bitStream, bool isWrite, bool forceWrite, bool isServerAuthoritative)	\
 {	\
 	bool anyDataWritten=false;	\
 	bool dataChanged=false;	\
@@ -468,7 +468,7 @@
 	\
 	virtual void InterpolateDistributedMemory(bool isServerAuthoritative) \
 {	\
-	unsigned long currentTime=getTime();	\
+	unsigned long currentTime=RakNetGetTime();	\
 	float percentageOfTimeElapsed;	\
 	if (distributedMemoryInitialized==false)	\
 	DistributedMemoryInit(isServerAuthoritative);	\

Modified: trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp
===================================================================
--- trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/DistributedNetworkObjectManager.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -90,9 +90,14 @@
 DistributedNetworkObject *DistributedNetworkObjectManager::GetClassInstanceByIdentifier(char *classIdentifier)
 {
 	unsigned i;
+
+	if (classIdentifier[0]==0)
+		return 0;
+
 	for (i=0; i < classList.size(); i++)
 	{
 		// Byte 0 of the class identifier holds the length of the remaining bytes
+		// The +1 is because we also compare the first byte
 		if (memcmp(classIdentifier, classList[i]->GetEncodedClassName(), classList[i]->GetEncodedClassName()[0]+1)==0)
 			return classList[i]->GetObject();
 	}
@@ -106,15 +111,17 @@
 	// Assert that the first byte of the packet is ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT
 
 	char classIdentifier[MAXIMUM_CLASS_IDENTIFIER_LENGTH];
-	BitStream bitStream(packet->data, packet->length, true);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, true);
 	ObjectID objectId;
 	DistributedNetworkObject* object=0;
-	bool construction;
+	int action;
+	PlayerID pid;
+	bool isLocalObject;
+	unsigned char localObjectIndex;
+	pid=UNASSIGNED_PLAYER_ID;
 
 
-	bool isLocalObject;
-	unsigned char localObjectIndex;
-	if (DistributedNetworkObject::DeserializeClassHeader(&bitStream, construction, objectId, classIdentifier,isLocalObject,localObjectIndex)==false)
+	if (DistributedNetworkObject::DeserializeClassHeader(&bitStream, action, objectId, classIdentifier,isLocalObject,localObjectIndex,pid)==false)
 		return 0; // Some kind of corrupted packet, or the server was active but not registered, or the client was active but not registered
 
 	bool serverProcess=true;
@@ -125,7 +132,7 @@
 			serverProcess=false;
 	}
 
-	if (construction)
+	if (action>=1)
 	{
 		if (objectId!=UNASSIGNED_OBJECT_ID)
 		{
@@ -146,7 +153,10 @@
 
 			if (object==0)
 			{
-				assert(0); // Unknown class identifier
+				// If this assert hits then one system tried to create a class that was
+				// not registered with REGISTER_DISTRIBUTED_NETWORK_OBJECT on this system.
+				// Byte 0 of 0 means no class identifier was encoded
+				assert(classIdentifier[0]==0);
 				return 0;
 			}
 
@@ -154,6 +164,9 @@
 				DistributedNetworkObjectManager::Instance()->GetRakServerInterface()==0)
 				object->SetID(objectId);
 
+			if (DistributedNetworkObjectManager::Instance()->GetRakClientInterface() && pid!=UNASSIGNED_PLAYER_ID)
+				object->SetClientOwnerID(pid); // So the client knows who is the owner of the object
+
 			object->ProcessDistributedMemoryStack(&bitStream, false, false, serverProcess);
 			object->WriteToHeapFromBitstream(&bitStream);
 
@@ -165,6 +178,11 @@
 					delete object;
 					object=0;
 				}
+				else
+				{
+					object->SetLocalObject(false);
+					object->ReadCreationData(&bitStream);
+				}
 			}
 			else if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 			{
@@ -176,7 +194,7 @@
 
 					// Tell the sender that the object creation was rejected
 					static const unsigned char objectRejectedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_REJECTED;
-					BitStream rejectionBitStream;
+					RakNet::BitStream rejectionBitStream;
 					rejectionBitStream.Write(objectRejectedID);
 					rejectionBitStream.Write(localObjectIndex);
 
@@ -184,12 +202,16 @@
 				}
 				else
 				{
+					object->SetLocalObject(false);
+					object->ReadCreationData(&bitStream);
+
 					// Receipt of this packet will set the object ID for the client so future data packets can be processed
 					static const unsigned char objectAcceptedID = ID_DISTRIBUTED_NETWORK_OBJECT_CREATION_ACCEPTED;
-					BitStream acceptanceBitStream;
+					RakNet::BitStream acceptanceBitStream;
 					acceptanceBitStream.Write(objectAcceptedID);
 					acceptanceBitStream.Write(localObjectIndex);
 					acceptanceBitStream.Write(object->GetID());
+					acceptanceBitStream.Write((char*)&packet->playerId, sizeof(PlayerID));
 
 					DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->Send(&acceptanceBitStream, HIGH_PRIORITY, RELIABLE_ORDERED, 0, packet->playerId, false);
 
@@ -202,11 +224,11 @@
 					object->BroadcastSerializedClass(&bitStream);
 					*/
 
-					object->UpdateDistributedObject(classIdentifier, true);
-
 					// If the client creates the object, it is considered the owner
 					object->SetClientOwnerID(packet->playerId);
 
+					object->UpdateDistributedObject(classIdentifier, true);
+
 				}
 			}
 		}
@@ -234,7 +256,7 @@
 			if (DistributedNetworkObjectManager::Instance()->GetRakServerInterface() && DistributedNetworkObjectManager::Instance()->GetRakServerInterface()->IsActive())
 			{
 				bitStream.Reset();
-				object->SerializeClassHeader(&bitStream, classIdentifier, true, false, 0);
+				object->SerializeClassHeader(&bitStream, classIdentifier, action, false, 0);
 				object->ProcessDistributedMemoryStack(&bitStream, true, true,true);
 				object->WriteToBitstreamFromHeap(&bitStream, true);
 				object->BroadcastSerializedClass(&bitStream);
@@ -250,6 +272,17 @@
 			return 0;
 		}
 
+		// If this is the server and the client is trying to destroy it, make sure it is either the
+		// owner or no owner is set
+		if (serverProcess)
+		{
+			if (object->GetClientOwnerID()!=UNASSIGNED_PLAYER_ID &&
+				object->GetClientOwnerID()!=packet->playerId &&
+				object->AllowSpectatorUpdate(packet->playerId)==false)
+				// Client trying to update an object it does not own - and it was not allowed to
+				return 0;
+		}
+
 		object->OnDistributedObjectDestruction(packet->playerId);
 		object=0;
 	}
@@ -262,13 +295,16 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 	ObjectID objectID;
+	PlayerID pid;
 
-	BitStream bitStream(packet->data, packet->length, false);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
 	if (bitStream.Read(objectID)==0)
 		return;
+	if (bitStream.Read((char*)&pid, sizeof(PlayerID))==0)
+		return;
 
 	// Find the object with this index
 	object = GetObjectByLocalObjectIndex(localObjectIndex);
@@ -286,6 +322,12 @@
 		delete object;
 		object=0;
 	}
+	else
+	{
+		object->SetLocalObject(false);
+		object->SetClientOwnerID(pid);
+	}
+
 }
 
 void DistributedNetworkObjectManager::HandleDistributedNetworkObjectPacketCreationRejected(Packet *packet)
@@ -293,7 +335,7 @@
 	unsigned char localObjectIndex;
 	DistributedNetworkObject* object;
 
-	BitStream bitStream(packet->data, packet->length, false);
+	RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 	bitStream.IgnoreBits(sizeof(unsigned char)*8); // Skip the packet identifier
 	if (bitStream.Read(localObjectIndex)==0)
 		return;
@@ -336,12 +378,12 @@
 			}
 		}
 
-		BitStream bitStream;
+		RakNet::BitStream bitStream;
 		unsigned i;
 		for (i=0; i < distributedNetworkObjectInstanceRegistry.size(); i++)
 		{
 			bitStream.Reset();
-			distributedNetworkObjectInstanceRegistry[i]->object->SerializeClassHeader(&bitStream, distributedNetworkObjectInstanceRegistry[i]->classIdentifier, true, false, 255);
+			distributedNetworkObjectInstanceRegistry[i]->object->SerializeClassHeader(&bitStream, distributedNetworkObjectInstanceRegistry[i]->classIdentifier, 2, false, 255);
 
 			// Note to self - ProcessDistributedMemoryStack with write to true will update network memory.  During the next normal updates
 			// any changes that occured in the meantime won't be distributed.  Is this something to be concerned about?

Modified: trunk/source/libraries/raknet/EncodeClassName.cpp
===================================================================
--- trunk/source/libraries/raknet/EncodeClassName.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/EncodeClassName.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -13,7 +13,7 @@
 
 void EncodeClassName(char *name, char *identifier)
 {
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 	int index=0;
 	unsigned char byte;
 	while (index < MAXIMUM_CLASS_IDENTIFIER_LENGTH-1)

Modified: trunk/source/libraries/raknet/GetTime.cpp
===================================================================
--- trunk/source/libraries/raknet/GetTime.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/GetTime.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -9,28 +9,43 @@
 
 #include "GetTime.h"
 
-////#include "MemoryManager.h"
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <sys/time.h>
+#endif
 
-GetTime GetTime::instance;
-
-GetTime::GetTime()
+unsigned long RakNetGetTime(void)
 {
-// For some reason this fails in the constructor
-//	QueryPerformanceFrequency(&yo);
-//	counts = yo.QuadPart >> 10;
-	initialized=false;
-}
+#ifdef _WIN32
+	static LARGE_INTEGER yo;
+	static LONGLONG counts;
+#else
+	static timeval tp, initialTime;
+#endif
+	static bool initialized=false;
+	if (initialized==false)
+	{
+#ifdef _WIN32
+		QueryPerformanceFrequency(&yo);
+		// The original code shifted right 10 bits
+		//counts = yo.QuadPart >> 10;
+		// It gives the wrong value since 2^10 is not 1000
+		counts = yo.QuadPart / 1000;
+#else
+		gettimeofday(&initialTime, 0); 
+#endif
+		initialized=true; 
+	}
 
-void GetTime::Init(void)
-{
-	#ifdef _WIN32
-	QueryPerformanceFrequency(&yo);
-	// The original code shifted right 10 bits
-	//counts = yo.QuadPart >> 10;
-	// It gives the wrong value since 2^10 is not 1000
-	counts = yo.QuadPart / 1000;
-	#else
-	gettimeofday(&initialTime, 0); 
-	#endif
-	initialized=true; 
+#ifdef _WIN32
+	LARGE_INTEGER PerfVal;
+	QueryPerformanceCounter(&PerfVal);
+	return (unsigned long)(PerfVal.QuadPart/counts);
+#else
+	gettimeofday(&tp, 0);
+
+	// Seconds to ms and microseconds to ms
+	return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
+#endif
 }

Modified: trunk/source/libraries/raknet/GetTime.h
===================================================================
--- trunk/source/libraries/raknet/GetTime.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/GetTime.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -10,53 +10,7 @@
 #ifndef __GET_TIME_H
 #define __GET_TIME_H
 
-#ifdef _WIN32
-#include <windows.h>
-#else
-#include <sys/time.h>
-#endif
+extern unsigned long RakNetGetTime(void);
 
-// A utility class to get a more accurate time than timeGetTime()
-class GetTime
-{
-public:
-	// Call this before using the function.  It won't work in constructor calls though, so you have to call this in Winmain or main and
-	// not use the class in your constructors
-	void Init(void);
-
-	// Call this or use the #define getTime (below) to get the current time
-	inline unsigned long Time(void)
-	{
-		if (initialized==false) Init();
-
-		#ifdef _WIN32
-		LARGE_INTEGER PerfVal;
-		QueryPerformanceCounter(&PerfVal);
-		return (unsigned long)(PerfVal.QuadPart/counts);
-		#else
-		gettimeofday(&tp, 0);
-		// Seconds to ms and microseconds to ms
-		return (tp.tv_sec - initialTime.tv_sec) * 1000 + (tp.tv_usec - initialTime.tv_usec) / 1000;
-		#endif
-	}
-
-	~GetTime() {}
-	// static function because only static functions can access static members
-	static inline GetTime* Instance() {return &instance;}
-private:
-	static GetTime instance;
-	GetTime();
-    
-    	#ifdef _WIN32
-	LARGE_INTEGER yo;
-	LONGLONG counts;
-	#else
-	timeval tp, initialTime;
-	#endif
-	bool initialized;
-};
-
-#define getTime GetTime::Instance()->Time
-
 #endif
 

Modified: trunk/source/libraries/raknet/HuffmanEncodingTree.cpp
===================================================================
--- trunk/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/HuffmanEncodingTree.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -109,7 +109,7 @@
 	bool tempPath[256]; // Maximum path length is 256
 	unsigned short tempPathLength;
 	HuffmanEncodingTreeNode *currentNode;
-	BitStream bitStream;
+	RakNet::BitStream bitStream;
 
 	// Generate the encryption table. From before, we have an array of pointers to all the leaves which contain pointers to their parents.
 	// This can be done more efficiently but this isn't bad and it's way easier to program and debug
@@ -148,7 +148,7 @@
 }
 
 // Pass an array of bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output)
+void HuffmanEncodingTree::EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output)
 {
 	if (sizeInBytes<=0)
 		return;
@@ -179,7 +179,7 @@
 	}
 }
 
-int HuffmanEncodingTree::DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
+int HuffmanEncodingTree::DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
@@ -210,14 +210,14 @@
 }
 
 // Pass an array of encoded bytes to array and a preallocated BitStream to receive the output
-void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, BitStream* output)
+void HuffmanEncodingTree::DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output)
 {
 	HuffmanEncodingTreeNode *currentNode;
 
 	if (sizeInBits<=0)
 		return;
 
-	BitStream bitStream(BITS_TO_BYTES(sizeInBits));
+	RakNet::BitStream bitStream(BITS_TO_BYTES(sizeInBits));
 	bitStream.SetData(input, sizeInBits); // Put the data in the BitStream class to make it easier to use
 
 	currentNode=root;

Modified: trunk/source/libraries/raknet/HuffmanEncodingTree.h
===================================================================
--- trunk/source/libraries/raknet/HuffmanEncodingTree.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/HuffmanEncodingTree.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -11,8 +11,8 @@
 #define __HUFFMAN_ENCODING_TREE
 
 #include "HuffmanEncodingTreeNode.h"
+#include "BitStream.h"
 
-class BitStream;
 #include "LinkedList.h"
 
 // This generates special cases of the huffman encoding tree using 8 bit keys with the additional condition that unused combinations of 8 bits are treated as a frequency of 1
@@ -23,12 +23,12 @@
 	~HuffmanEncodingTree();
 
 	// Pass an array of bytes to array and a preallocated BitStream to receive the output
-	void EncodeArray(unsigned char *input, int sizeInBytes, BitStream* output);
+	void EncodeArray(unsigned char *input, int sizeInBytes, RakNet::BitStream * output);
 
 	// Two versions that perform the same operation.
 	// The second version also the number of bytes in the stream, which may be greater than the max chars to write
-	int DecodeArray(BitStream* input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
-	void DecodeArray(unsigned char *input, int sizeInBits, BitStream* output);
+	int DecodeArray(RakNet::BitStream * input, int sizeInBits, int maxCharsToWrite, unsigned char *output);
+	void DecodeArray(unsigned char *input, int sizeInBits, RakNet::BitStream * output);
 
 	// Given a frequency table of 256 elements, all with a frequency of 1 or more, generate the tree
 	void GenerateFromFrequencyTable(unsigned long frequencyTable[256]);

Modified: trunk/source/libraries/raknet/InternalPacket.h
===================================================================
--- trunk/source/libraries/raknet/InternalPacket.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/InternalPacket.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -20,11 +20,10 @@
 {
 	bool isAcknowledgement; // True if this is an acknowledgement packet
 	PacketNumberType packetNumber; // The number of this packet, used as an identifier
-	char sha1Code[SHA1_LENGTH]; // The sha1Code, used to verify packet data integrity
 	PacketPriority priority; // The priority level of this packet
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 	unsigned long splitPacketId; // The ID of the split packet, if we have split packets
 	unsigned long splitPacketIndex; // If this is a split packet, the index into the array of split packets
 	unsigned long splitPacketCount; // The size of the array of split packets

Modified: trunk/source/libraries/raknet/InternalPacketPool.cpp
===================================================================
--- trunk/source/libraries/raknet/InternalPacketPool.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/InternalPacketPool.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -15,6 +15,9 @@
 #ifdef _DEBUG
 	packetsReleased=0;
 #endif
+
+	// Speed things up by not reallocating at runtime when a mutex is locked.
+	pool.clearAndForceAllocation(1024);
 }
 
 InternalPacketPool::~InternalPacketPool()
@@ -49,6 +52,7 @@
 	poolMutex.Lock();
 	if (pool.size())
 		p=pool.pop();
+
 	poolMutex.Unlock();
 	if (p)
 		return p;

Modified: trunk/source/libraries/raknet/LinkedList.h
===================================================================
--- trunk/source/libraries/raknet/LinkedList.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/LinkedList.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -95,6 +95,7 @@
 	B++;
 	B.peek();  // Returns 30
 
+9/04 Giblet - updated code to work with new compilers adhering more closely to ISO standard
 
 */
 
@@ -176,15 +177,15 @@
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::beginning(void)
 {
-	if (root)
-		position=root;
+	if (this->root)
+		this->position=this->root;
 }
 
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::end(void)
 {
-	if (root)
-		position=root->previous;
+	if (this->root)
+		this->position=this->root->previous;
 }
 
 template <class LinkedListType>
@@ -195,71 +196,71 @@
 	if ((&original_copy) != this)
 	{
 	
-	clear();
+	this->clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this->root= new typename LinkedList::node;
 		// root->item = new LinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this->root = new typename LinkedList::node;
 		// root->item = new LinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this->position = new typename LinkedList::node;
 			// position->item = new LinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -270,21 +271,21 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>::CircularLinkedList()
 {
-	root=0;
-	position=0;
-	list_size=0L;
+	this->root=0;
+	this->position=0;
+	this->list_size=0L;
 }
 
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>::~CircularLinkedList()
 {
-	clear();
+	this->clear();
 }
 
 template <class LinkedListType>
 LinkedList<LinkedListType>::~LinkedList()
 {
-	clear();
+	this->clear();
 }
 
 template <class LinkedListType>
@@ -294,64 +295,64 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename LinkedList::node;
+		this->root= new typename LinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item) = *((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename LinkedList::node;
+		this->root = new typename LinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename LinkedList::node;
+			this->position = new typename LinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -362,66 +363,66 @@
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 		return;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item) = *((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this->root = new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			
 
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this->position = new typename CircularLinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
+			this->position->item = original_copy_pointer->item;
 			if (original_copy_pointer == original_copy.position) save_position=position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -433,68 +434,68 @@
 	if ((&original_copy) != this)
 	{
 	
-	clear();
+	this->clear();
 
 
 	if (original_copy.list_size==0L) 
 	{
-		root=0;
-		position=0;
-		list_size=0L;
+		this->root=0;
+		this->position=0;
+		this->list_size=0L;
 	}
 	else if (original_copy.list_size==1L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
+		this->root->item = original_copy.root->item;
 	}
 	else
 	{
 		// Setup the first part of the root node
 		original_copy_pointer=original_copy.root;
-		root = new typename CircularLinkedList::node;
+		this->root = new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
-		position = root;
+		this->position = this->root;
 		// *(root->item)=*((original_copy.root)->item);
-		root->item = original_copy.root->item;
-		if (original_copy_pointer == original_copy.position) save_position=position;
+		this->root->item = original_copy.root->item;
+		if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 		do
 		{
 			// Save the current element
-			last=position;
+			this->last=this->position;
 
 			// Point to the next node in the source list
 			original_copy_pointer=original_copy_pointer->next;
 
 			// Create a new node and point position to it
-			position = new typename CircularLinkedList::node;
+			this->position = new typename CircularLinkedList::node;
 			// position->item = new CircularLinkedListType;
 
 			// Copy the item to the new node
 			// *(position->item)=*(original_copy_pointer->item);
-			position->item = original_copy_pointer->item;
-			if (original_copy_pointer == original_copy.position) save_position=position;
+			this->position->item = original_copy_pointer->item;
+			if (original_copy_pointer == original_copy.position) save_position=this->position;
 
 			// Set the previous pointer for the new node
-			(position->previous) = last;
+			(this->position->previous) = this->last;
 
 			// Set the next pointer for the old node to the new node
-			(last->next) =position;
+			(this->last->next) =this->position;
 
 		} while ((original_copy_pointer->next) != (original_copy.root));
 
 		// Complete the circle.  Set the next pointer of the newest node to the root and the previous pointer of the root to the newest node
-		position->next=root;
-		root->previous=position;
+		this->position->next=this->root;
+		this->root->previous=this->position;
 
-		list_size=original_copy.list_size;
-		position=save_position;
+		this->list_size=original_copy.list_size;
+		this->position=save_position;
 	}
 }
 
@@ -508,28 +509,28 @@
 
 	if (list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
 		//*(root->item)=input;
-		root->item = input;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->item = input;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this->position= new typename CircularLinkedList::node;
 		// position->item = new CircularLinkedListType;
-		root->next=position;
-		root->previous=position;
-		position->previous=root;
-		position->next=root;
+		this->root->next=this->position;
+		this->root->previous=this->position;
+		this->position->previous=this->root;
+		this->position->next=this->root;
 		// *(position->item)=input;
-		position->item = input;
-		root=position;  // Since we're inserting into a 1 element list the old root is now the second item
-		list_size=2L;
+		this->position->item = input;
+		this->root=this->position;  // Since we're inserting into a 1 element list the old root is now the second item
+		this->list_size=2L;
 	}
 
 	else
@@ -553,22 +554,22 @@
 		new_node->item = input;
 
 		// Point next of A to B
-		(position->previous)->next=new_node;
+		(this->position->previous)->next=new_node;
 
 		// Point last of B to A
-		new_node->previous=position->previous;
+		new_node->previous=this->position->previous;
 
 		// Point last of C to B
-		position->previous=new_node;
+		this->position->previous=new_node;
 
 		// Point next of B to C
-		new_node->next=position;
+		new_node->next=this->position;
 
 		 // Since the root pointer is bound to a node rather than an index this moves it back if you insert an element at the root
-		if (position==root) {root=new_node; position=root;}
+		if (this->position==this->root) {this->root=new_node; this->position=this->root;}
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this->list_size++;
 	}
 }
 
@@ -577,34 +578,34 @@
 {
 	node *new_node;
 
-	if (list_size==0L)
+	if (this->list_size==0L)
 	{
-		root= new typename CircularLinkedList::node;
+		this->root= new typename CircularLinkedList::node;
 		// root->item = new CircularLinkedListType;
 		// *(root->item)=input;
-		root->item=input;
-		root->next=root;
-		root->previous=root;
-		list_size=1L;
-		position=root;
+		this->root->item=input;
+		this->root->next=this->root;
+		this->root->previous=this->root;
+		this->list_size=1L;
+		this->position=this->root;
 		// return *(position->item);
-		return position->item;
+		return this->position->item;
 	}
 
 	else if (list_size==1L)
 	{
-		position= new typename CircularLinkedList::node;
+		this->position= new typename CircularLinkedList::node;
 		// position->item = new CircularLinkedListType;
-		root->next=position;
-		root->previous=position;
-		position->previous=root;
-		position->next=root;
+		this->root->next=this->position;
+		this->root->previous=this->position;
+		this->position->previous=this->root;
+		this->position->next=this->root;
 		// *(position->item)=input;
-		position->item = input;
-		list_size=2L;
-		position=root;  // Don't move the position from the root
+		this->position->item = input;
+		this->list_size=2L;
+		this->position=this->root;  // Don't move the position from the root
 		// return *(position->item);
-		return position->item;
+		return this->position->item;
 	}
 
 	else
@@ -628,19 +629,19 @@
 		new_node->item=input;
 
 		// Point last of B to A
-		new_node->previous=position;
+		new_node->previous=this->position;
 
 		// Point next of B to C
-		new_node->next=(position->next);
+		new_node->next=(this->position->next);
 
 		// Point last of C to B
-		(position->next)->previous=new_node;
+		(this->position->next)->previous=new_node;
 
 		// Point next of A to B
-		(position->next)=new_node;
+		(this->position->next)=new_node;
 
 		// Increase the recorded size of the list by one
-		list_size++;
+		this->list_size++;
 		
 		// return *(new_node->item);
 		return new_node->item;
@@ -650,9 +651,9 @@
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::replace(const CircularLinkedListType& input)
 {
-	if (list_size>0L)
+	if (this->list_size>0L)
 		// *(position->item)=input;
-		position->item=input;
+		this->position->item=input;
 }
 
 template <class CircularLinkedListType>
@@ -660,26 +661,26 @@
 {
 	node* new_position;
 
-	if (list_size==0L) return;
+	if (this->list_size==0L) return;
 
-	else if (list_size==1L)
+	else if (this->list_size==1L)
 	{
 		// delete root->item;
-		delete root;
-		root=position=0;
-		list_size=0L;
+		delete this->root;
+		this->root=this->position=0;
+		this->list_size=0L;
 	}
 
 	else
 	{
-		(position->previous)->next = position->next;
-		(position->next)->previous = position->previous;
-		new_position=position->next;
-		if (position==root) root=new_position;
+		(this->position->previous)->next = this->position->next;
+		(this->position->next)->previous = this->position->previous;
+		new_position=this->position->next;
+		if (this->position==this->root) this->root=new_position;
 		// delete position->item;
-		delete position;
-		position=new_position;
-		list_size--;
+		delete this->position;
+		this->position=new_position;
+		this->list_size--;
 	}
 }
 
@@ -688,10 +689,10 @@
 {
 	node *return_value,*old_position;
 	
-	old_position=position;
+	old_position=this->position;
  
 	return_value=find_pointer(input);
-	position=old_position;
+	this->position=old_position;
 
 	if (return_value!=0) return true;
 	else return false;	// Can't find the item don't do anything
@@ -704,7 +705,7 @@
  
 	return_value=find_pointer(input);
 
-	if (return_value!=0) {position=return_value; return true;}
+	if (return_value!=0) {this->position=return_value; return true;}
 	else return false;	// Can't find the item don't do anything
 }
 
@@ -713,8 +714,8 @@
 {
 	node* current;
 
-	if (list_size==0L) return 0;
-	current=root;
+	if (this->list_size==0L) return 0;
+	current=this->root;
 
 	// Search for the item starting from the root node and incrementing the pointer after every check
 	// If you wind up pointing at the root again you looped around the list so didn't find the item, in which case return 0
@@ -723,7 +724,7 @@
 		// if (*(current->item) == input) return current;
 		if (current->item == input) return current;
 		current=current->next;
-	} while (current != root);
+	} while (current != this->root);
 
 	return 0;
 	
@@ -732,14 +733,14 @@
 template <class CircularLinkedListType>
 inline unsigned long CircularLinkedList<CircularLinkedListType>::size(void)
 {
-	return list_size;
+	return this->list_size;
 }
 
 template <class CircularLinkedListType>
 inline CircularLinkedListType& CircularLinkedList<CircularLinkedListType>::peek(void)
 {
 	// return *(position->item);
-	return position->item;
+	return this->position->item;
 }
 
 template <class CircularLinkedListType>
@@ -755,7 +756,7 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator++()
 {
-	if (list_size!=0L) position=position->next;
+	if (this->list_size!=0L) position=position->next;
 	return *this;
 }
 
@@ -774,14 +775,14 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator++(int)
 {
-	return operator++();
+	return this->operator++();
 }
 
 // Prefix
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator--()
 {
-	if (list_size!=0L) position=position->previous;
+	if (this->list_size!=0L) this->position=this->position->previous;
 	return *this;
 }
 
@@ -800,21 +801,21 @@
 template <class CircularLinkedListType>
 CircularLinkedList<CircularLinkedListType>& CircularLinkedList<CircularLinkedListType>::operator--(int)
 {
-	return operator--();
+	return this->operator--();
 }
 
 template <class CircularLinkedListType>
 void CircularLinkedList<CircularLinkedListType>::clear(void)
 {
-	if (list_size==0L) return;
-	else if (list_size==1L)// {delete root->item; delete root;}
-		{delete root;}
+	if (this->list_size==0L) return;
+	else if (this->list_size==1L)// {delete root->item; delete root;}
+		{delete this->root;}
 	else
 	{
 		node* current;
 		node* temp;
 
-		current=root;
+		current=this->root;
 
 		do
 		{
@@ -822,12 +823,12 @@
 			current=current->next;
 		//	delete temp->item;
 			delete temp;
-		} while (current!=root);
+		} while (current!=this->root);
 	}
 
-	list_size=0L;
-	root=0;
-	position=0;
+	this->list_size=0L;
+	this->root=0;
+	this->position=0;
 }
 
 template <class CircularLinkedListType>
@@ -837,10 +838,10 @@
 	node* ptr;
 
 	if (L.list_size == 0L) return;
-	if (list_size == 0L) *this = L;
+	if (this->list_size == 0L) *this = L;
 
 	ptr = L.root;
-	position=root->previous;
+	this->position=this->root->previous;
 	
 	// Cycle through each element in L and add it to the current list
 	for (counter = 0; counter < L.list_size; counter++)
@@ -851,18 +852,18 @@
 
 		// Update pointers.  Moving ptr keeps the current pointer at the end of the list since the add function does not move the pointer
 		ptr=ptr->next;
-		position=position->next;
+		this->position=this->position->next;
 	}
 }
 
 template <class CircularLinkedListType>
 inline void CircularLinkedList<CircularLinkedListType>::sort(void)
 {
-	if (list_size<=1L) return;
+	if (this->list_size<=1L) return;
 
 	// Call equal operator to assign result of mergesort to current object
 	*this = mergesort(*this);
-	position=root;
+	this->position=this->root;
 }
 
 template <class CircularLinkedListType>
@@ -1015,7 +1016,7 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator++()
 {
-	if ((list_size!=0L) && (position->next!=root)) position=position->next;
+	if ((this->list_size!=0L) && (this->position->next!=this->root)) this->position=this->position->next;
 	return *this;
 }
 /*
@@ -1033,14 +1034,14 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator++(int)
 {
-	return operator++();
+	return this->operator++();
 }
 
 // Prefix
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator--()
 {
-	if ((list_size!=0L) && (position!=root)) position=position->previous;
+	if ((this->list_size!=0L) && (this->position!=this->root)) this->position=this->position->previous;
 	return *this;
 }
 /*
@@ -1059,7 +1060,7 @@
 template <class LinkedListType>
 LinkedList<LinkedListType>& LinkedList<LinkedListType>::operator--(int)
 {
-	return operator--();
+	return this->operator--();
 }
 
 } // End namespace

Modified: trunk/source/libraries/raknet/Multiplayer.h
===================================================================
--- trunk/source/libraries/raknet/Multiplayer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/Multiplayer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -33,6 +33,7 @@
 	virtual void ReceiveRemoteConnectionLost(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveRemoteExistingConnection(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveConnectionRequestAccepted(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveNewIncomingConnection(Packet *packet,InterfaceType *interfaceType);
@@ -46,6 +47,7 @@
 	virtual void ReceiveRemotePortRefused(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceiveVoicePacket(Packet *packet,InterfaceType *interfaceType);
 	virtual void ReceivePong(Packet *packet,InterfaceType *interfaceType);
+	virtual void ReceiveAdvertisedSystem(Packet *packet,InterfaceType *interfaceType);
 	// -----------------------------------------------------------------
 
 	// -----------------------------------------------------------------
@@ -133,6 +135,9 @@
 		case ID_REMOTE_EXISTING_CONNECTION:
 			ReceiveRemoteExistingConnection(p,interfaceType);
 		break;
+		case ID_REMOTE_STATIC_DATA:
+			ReceiveRemoteStaticData(p,interfaceType);
+		break;
 		case ID_CONNECTION_BANNED:
 			ReceiveConnectionBanned(p, interfaceType);
 		break;
@@ -169,6 +174,9 @@
 		case ID_PONG:
 			ReceivePong(p,interfaceType);
 			break;
+		case ID_ADVERTISE_SYSTEM:
+			ReceiveAdvertisedSystem(p,interfaceType);
+			break;
 		case ID_UPDATE_DISTRIBUTED_NETWORK_OBJECT:
 			ReceiveDistributedNetworkObject(p,interfaceType);
 			break;
@@ -276,6 +284,17 @@
 }
 
 template <class InterfaceType>
+void Multiplayer<InterfaceType>::ReceiveRemoteStaticData(Packet *packet,InterfaceType *interfaceType)
+{
+	// A client got the remote static data for another system
+	//  Client only.
+#ifdef _DEBUG
+	printf("ID_REMOTE_STATIC_DATA from PlayerID:%u:%u on %p.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+	//	ProcessUnhandledPacket(packet, ID_REMOTE_EXISTING_CONNECTION,interfaceType);
+}
+
+template <class InterfaceType>
 void Multiplayer<InterfaceType>::ReceiveConnectionBanned(Packet *packet,InterfaceType *interfaceType)
 {
 	// We are banned from connecting to the system specified in packet->playerId
@@ -410,14 +429,31 @@
 {
 	// Peer or client.  Response from a ping for an unconnected system.
 #ifdef _DEBUG
-	unsigned long time;
+	unsigned long time, dataLength;
 	memcpy((char*)&time, packet->data+sizeof(unsigned char), sizeof(unsigned long));
-	printf("ID_PONG from PlayerID:%u:%u on %p. Value is %i\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType, time);
+	dataLength = packet->length - sizeof(unsigned char) - sizeof(unsigned long);
+	printf("ID_PONG from PlayerID:%u:%u on %p.\nPing is %i\nData is %i bytes long.\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType, time, dataLength);
+	if (dataLength > 0)
+		printf("Data is %s\n", packet->data+sizeof(unsigned char)+sizeof(unsigned long));
 #endif
 	//	ProcessUnhandledPacket(packet, ID_PONG,interfaceType);
 }
 
 template <class InterfaceType>
+void Multiplayer<InterfaceType>::ReceiveAdvertisedSystem(Packet *packet,InterfaceType *interfaceType)
+{
+	// Got a packet from another RakNet system indicating that it exists.
+	// Currently this is used for the master server for the server to indicate its external
+	// IP to a client as well as open the NAT
+#ifdef _DEBUG
+	printf("ID_ADVERTISED_SYSTEM from PlayerID:%u:%u on %p.\nIf you are running a client connecting to a server behind a NAT, you should\ncall Disconnect and connect to the to the IP specified by packet->playerId instead\n",packet->playerId.binaryAddress, packet->playerId.port, interfaceType);
+#endif
+
+	// When you get this packet, you should disconnect if you are not already connected.  Then connect
+	// To the IP / port given by packet->playerID.  You can translate a PlayerID to an IP with PlayerIDToDottedIP
+}
+
+template <class InterfaceType>
 void Multiplayer<InterfaceType>::ReceiveDistributedNetworkObject(Packet *packet,InterfaceType *interfaceType)
 {
 	// Packet to create a distributed network object

Modified: trunk/source/libraries/raknet/NetworkTypes.cpp
===================================================================
--- trunk/source/libraries/raknet/NetworkTypes.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/NetworkTypes.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -27,4 +27,3 @@
 {
 	return left.binaryAddress<right.binaryAddress || left.port<right.port;
 }
-

Modified: trunk/source/libraries/raknet/NetworkTypes.h
===================================================================
--- trunk/source/libraries/raknet/NetworkTypes.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/NetworkTypes.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -12,6 +12,7 @@
 
 typedef unsigned short ObjectID;
 typedef unsigned char UniqueIDType;
+typedef unsigned short PlayerIndex;
 
 struct PlayerID
 {
@@ -24,6 +25,7 @@
 	friend int operator < (const PlayerID& left, const PlayerID& right);
 };
 
+
 struct RequestedConnectionStruct
 {
 	PlayerID playerId; // Who we wanted to connect to
@@ -35,10 +37,11 @@
 
 struct Packet
 {
+	PlayerIndex playerIndex; // Server only - this is the index into the player array that this playerId maps to
 	PlayerID playerId;
 	unsigned long length;
 	unsigned long bitSize; // Same as length but represents bits.  Length is obsolete and retained for backwards compatibility
-	char* data;
+	unsigned char* data;
 };
 
 #pragma pack(push,1)
@@ -48,6 +51,7 @@
 	unsigned char typeId;
 	unsigned short remotePort;
 	PlayerID externalID; // We tell the remote system its own IP / port this way
+	PlayerIndex playerIndex; // For internal use
 };
 
 #pragma pack(1)
@@ -85,6 +89,7 @@
 
 #pragma pack(pop)
 
+const PlayerIndex UNASSIGNED_PLAYER_INDEX=65535;
 const PlayerID UNASSIGNED_PLAYER_ID={0xFFFFFFFF, 0xFFFF};
 const ObjectID UNASSIGNED_OBJECT_ID=65535;
 const int PING_TIMES_ARRAY_SIZE=5;

Modified: trunk/source/libraries/raknet/PacketEnumerations.h
===================================================================
--- trunk/source/libraries/raknet/PacketEnumerations.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/PacketEnumerations.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -17,29 +17,30 @@
 	//
 	// Ignore these:
 	ID_PING, // Ping (internal use only)
-	ID_PONG, // Pong.  Returned if we ping a system we are not connected so
+	ID_PING_OPEN_CONNECTIONS, // Only reply to the unconnected ping if we have open connections
 	ID_REQUEST_STATIC_DATA, // Someone asked for our static data (internal use only)
 	ID_CONNECTION_REQUEST, // Asking for a new connection (internal use only)
 	ID_SECURED_CONNECTION_RESPONSE, // Connecting to a secured server/peer
 	ID_SECURED_CONNECTION_CONFIRMATION, // Connecting to a secured server/peer
 	ID_RPC, // Remote procedure call (internal use only)
-	ID_RECEIVED_RELAYED_STATIC_DATA, // Server / Client only - Sending the static data for another system (internal use only)
 	ID_BROADCAST_PINGS, // Server / Client only - The server is broadcasting the pings of all players in the game (internal use only)
 	ID_SET_RANDOM_NUMBER_SEED, // Server / Client only - The server is broadcasting a random number seed (internal use only)
 	ID_RPC_WITH_TIMESTAMP, // Same as RPC, but treat the first 4 bytes as a timestamp
 	// Handle these below.  Possible recipients in [...]
+	ID_PONG, // [CLIENT|PEER] Pong.  Returned if we ping a system we are not connected so.  First byte is ID_PONG, second 4 bytes is the ping, following bytes is system specific enumeration data.
 	ID_RSA_PUBLIC_KEY_MISMATCH, // [CLIENT|PEER] We preset an RSA public key which does not match what the system we connected to is using.
 	ID_REMOTE_DISCONNECTION_NOTIFICATION, // [CLIENT] In a client/server enviroment, a client other than ourselves has disconnected gracefully.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_CONNECTION_LOST, // [CLIENT] In a client/server enviroment, a client other than ourselves has been forcefully dropped.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_NEW_INCOMING_CONNECTION, // [CLIENT] In a client/server enviroment, a client other than ourselves has connected.  Packet::playerID is modified to reflect the playerID of this client.
 	ID_REMOTE_EXISTING_CONNECTION, // [CLIENT] On our initial connection to the server, we are told of every other client in the game.  Packet::playerID is modified to reflect the playerID of this client.
+	ID_REMOTE_STATIC_DATA, // [CLIENT] - Got the data for another client
 	ID_CONNECTION_BANNED, // [PEER|CLIENT] We are banned from the system we attempted to connect to.
 	ID_CONNECTION_REQUEST_ACCEPTED, // [CLIENT] In a client/server enviroment, our connection request to the server has been accepted.
 	ID_NEW_INCOMING_CONNECTION, // [PEER|SERVER] A remote system has successfully connected.
 	ID_NO_FREE_INCOMING_CONNECTIONS, // [PEER|CLIENT] The system we attempted to connect to is not accepting new connections.
 	ID_DISCONNECTION_NOTIFICATION, // [PEER|SERVER|CLIENT] The system specified in Packet::playerID has disconnected from us.  For the client, this would mean the server has shutdown.
 	ID_CONNECTION_LOST, // [PEER|SERVER|CLIENT] Reliable packets cannot be delivered to the system specifed in Packet::playerID.  The connection to that system has been closed.
-	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient.
+	ID_TIMESTAMP, // [PEER|SERVER|CLIENT] The four bytes following this byte represent an unsigned long which is automatically modified by the difference in system times between the sender and the recipient. Requires that you call StartOccasionalPing.
 	ID_RECEIVED_STATIC_DATA, // [PEER|SERVER|CLIENT] We got a bitstream containing static data.  You can now read this data.  This packet is transmitted automatically on connections, and can also be manually sent.
 	ID_INVALID_PASSWORD, // [PEER|CLIENT] The remote system is using a password and has refused our connection because we did not set the correct password.
 	ID_MODIFIED_PACKET, // [PEER|SERVER|CLIENT] A packet has been tampered with in transit.  The sender is contained in Packet::playerID.
@@ -57,9 +58,8 @@
 	ID_MASTER_SERVER_DELIST_SERVER, // [MASTERSERVER] Remove a game server from the master server.
 	ID_MASTER_SERVER_UPDATE_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or update the information for a server.
 	ID_MASTER_SERVER_SET_SERVER, // [MASTERSERVER|MASTERCLIENT] Add or set the information for a server.
-	ID_RESERVED2, // For future versions
-	ID_RESERVED3, // For future versions
-	ID_RESERVED4, // For future versions
+	ID_RELAYED_CONNECTION_NOTIFICATION, // [MASTERSERVER|MASTERCLIENT] This message indicates a game client is connecting to a game server, and is relayed through the master server.
+	ID_ADVERTISE_SYSTEM, // [PEER|SERVER|CLIENT] Inform a remote system of our IP/Port.
 	ID_RESERVED5, // For future versions
 	ID_RESERVED6, // For future versions
 	ID_RESERVED7, // For future versions

Modified: trunk/source/libraries/raknet/PacketPriority.h
===================================================================
--- trunk/source/libraries/raknet/PacketPriority.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/PacketPriority.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -12,6 +12,7 @@
 
 enum PacketPriority
 {
+	SYSTEM_PRIORITY, // System priority is for system related messaging.  Don't use it.
 	HIGH_PRIORITY,
 	MEDIUM_PRIORITY,
 	LOW_PRIORITY,

Modified: trunk/source/libraries/raknet/Queue.h
===================================================================
--- trunk/source/libraries/raknet/Queue.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/Queue.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -29,6 +29,8 @@
 This function doubles the amount of memory allocated when the queue is filled
 This is better than the linked list version for a queue that doesn't go from one extreme to the other with size changes.
 
+9/04 Giblet - commented out body of compress() function, as it is invalid and breaks newer compilers
+
 */
 
 #ifndef __QUEUE_H
@@ -255,7 +257,7 @@
 template <class queue_type>
 void Queue<queue_type>::compress (void)
 {
-		queue_type* new_array;
+		/*queue_type* new_array;
 
 		if (allocation_size==0) return;
 
@@ -273,7 +275,7 @@
 		
 		// Delete the old array and move the pointer to the new array
 		delete []array;
-		array=new_array;
+		array=new_array;*/
 }
 
 template <class queue_type>

Modified: trunk/source/libraries/raknet/RakClient.cpp
===================================================================
--- trunk/source/libraries/raknet/RakClient.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakClient.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -28,13 +28,12 @@
 {
 }
 
-bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)
+bool RakClient::Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)
 {
-	if (highPriorityThreads)
-		RakPeer::Initialize(1, clientPort,1);
-	else
-		RakPeer::Initialize(1, clientPort,0);
+	RakPeer::Disconnect(100L);
 
+	RakPeer::Initialize(1, clientPort,threadSleepTimer);
+
 	if (host[0] < '0' || host[0] > '2')
 	{
 		host = (char*) SocketLayer::Instance()->DomainNameToIP(host);
@@ -52,20 +51,27 @@
 	return RakPeer::Connect(host, serverPort, password, (int)strlen(password));
 }
 
-void RakClient::Disconnect(void)
+void RakClient::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-void RakClient::InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)
+void RakClient::InitializeSecurity(char *pubKeyP, char *pubKeyQ)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, 0, RSAe, RSAn);
+	RakPeer::InitializeSecurity(pubKeyP, pubKeyQ,0,0);
 }
 
 void RakClient::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakClient::HasPassword(void) const
@@ -73,18 +79,18 @@
 	return password[0]!=0;
 }
 
-bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
-bool RakClient::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)
+bool RakClient::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, remoteSystemList[0].playerId, false);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false);
 }
 
 Packet* RakClient::Receive(void)
@@ -94,10 +100,16 @@
 	// Intercept specific client / server feature packets
 	if (packet)
 	{
-		BitStream bitStream(packet->data, packet->length, false);
+		RakNet::BitStream bitStream((char*)packet->data, packet->length, false);
 		bitStream.IgnoreBits(8); // Ignore identifier
 		int i;
-		if (
+		if (packet->data[0]==ID_CONNECTION_REQUEST_ACCEPTED)
+		{
+			ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) packet->data;
+			localPlayerIndex = cas->playerIndex;
+			packet->playerIndex=cas->playerIndex;
+		}
+		else if (
 			packet->data[0]==ID_REMOTE_NEW_INCOMING_CONNECTION ||
 			packet->data[0]==ID_REMOTE_EXISTING_CONNECTION ||
 			packet->data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
@@ -105,29 +117,36 @@
 		{
 			bitStream.Read(packet->playerId.binaryAddress);
 			bitStream.Read(packet->playerId.port);
+			if (bitStream.Read((unsigned short&)packet->playerIndex)==false)
+			{
+				DeallocatePacket(packet);
+				return 0;
+			}
 
-			i = GetOtherClientIndexByPlayerID(packet->playerId);
-			if (i>=0)
-				otherClients[i].isActive=false;
+
+			if (packet->data[0]==ID_REMOTE_DISCONNECTION_NOTIFICATION ||
+				packet->data[0]==ID_REMOTE_CONNECTION_LOST)
+			{
+				i = GetOtherClientIndexByPlayerID(packet->playerId);
+				if (i>=0)
+					otherClients[i].isActive=false;
+			}			
 		}
-		else if (packet->data[0]==ID_RECEIVED_RELAYED_STATIC_DATA)
+		else if (packet->data[0]==ID_REMOTE_STATIC_DATA)
 		{
-			PlayerID staticDataOriginator;
-			bitStream.Read(staticDataOriginator.binaryAddress);
-			bitStream.Read(staticDataOriginator.port);
+			bitStream.Read(packet->playerId.binaryAddress);
+			bitStream.Read(packet->playerId.port);
 
-			i = GetOtherClientIndexByPlayerID(staticDataOriginator);
+			i = GetOtherClientIndexByPlayerID(packet->playerId);
 			if (i < 0)
 				i=GetFreeOtherClientIndex();
 			if (i>=0)
 			{
-				otherClients[i].playerId=staticDataOriginator;
+				otherClients[i].playerId=packet->playerId;
 				otherClients[i].isActive=true;
 				otherClients[i].staticData.Reset();
 				// The static data is what is left over in the stream
 				otherClients[i].staticData.Write((char*)bitStream.GetData()+BITS_TO_BYTES(bitStream.GetReadOffset()), bitStream.GetNumberOfBytesUsed()-BITS_TO_BYTES(bitStream.GetReadOffset()));
-				DeallocatePacket(packet);
-				return 0;
 			}
 		}
 		else if (packet->data[0]==ID_BROADCAST_PINGS)
@@ -189,10 +208,10 @@
 	RakPeer::Ping(remoteSystemList[0].playerId);
 }
 
-void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort)
+void RakClient::PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)
 {
 	RakPeer::Initialize(1, clientPort,0);
-	RakPeer::Ping(host, serverPort);
+	RakPeer::Ping(host, serverPort, onlyReplyOnAcceptingConnections);
 }
 
 int RakClient::GetAveragePing(void)
@@ -245,7 +264,7 @@
 
 unsigned long RakClient::GetSynchronizedRandomInteger(void) const
 {
-	if (getTime() > nextSeedUpdate)
+	if (RakNetGetTime() > nextSeedUpdate)
 		return nextSeed;
 	else
 		return seed;
@@ -287,18 +306,18 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakClient::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
-bool RakClient::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)
+bool RakClient::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)
 {
 	if (remoteSystemList==0)
 		return false;
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, remoteSystemList[0].playerId, false, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, remoteSystemList[0].playerId, false, shiftTimestamp);
 }
 
 /*
@@ -329,7 +348,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakClient::GetStaticServerData(void)
+RakNet::BitStream * RakClient::GetStaticServerData(void)
 {
 	if (remoteSystemList==0)
 		return 0;
@@ -343,7 +362,7 @@
 	RakPeer::SetRemoteStaticData(remoteSystemList[0].playerId, data, length);
 }
 
-BitStream* RakClient::GetStaticClientData(PlayerID playerId)
+RakNet::BitStream * RakClient::GetStaticClientData(PlayerID playerId)
 {
 	int i;
 
@@ -433,71 +452,21 @@
 	return RakPeer::GetMTUSize();
 }
 
-double RakClient::GetPacketlossPercentile(void)
+void RakClient::AllowConnectionResponseIPMigration(bool allow)
 {
-	return RakPeer::GetPacketlossPercentile();
+	RakPeer::AllowConnectionResponseIPMigration(allow);
 }
 
-unsigned long RakClient::GetTransmittedPacketCount(void)
+void RakClient::AdvertiseSystem(char *host, unsigned short remotePort)
 {
-	return RakPeer::GetTransmittedPacketCount();
+	RakPeer::AdvertiseSystem(host, remotePort);
 }
 
-unsigned long RakClient::GetTransmittedFrameCount(void)
+RakNetStatisticsStruct* const RakClient::GetStatistics(void)
 {
-	return RakPeer::GetTransmittedFrameCount();
+	return RakPeer::GetStatistics(remoteSystemList[0].playerId);
 }
 
-unsigned long RakClient::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakClient::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakClient::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakClient::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakClient::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakClient::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakClient::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakClient::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakClient::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakClient::GetConnectionTime(void)
-{
-	return RakPeer::GetConnectionTime(RakPeer::GetInternalID());
-}
-
 int RakClient::GetOtherClientIndexByPlayerID(PlayerID playerId)
 {
 	unsigned i;
@@ -520,3 +489,7 @@
 	return -1;
 }
 
+PlayerIndex RakClient::GetPlayerIndex(void)
+{
+	return localPlayerIndex;
+}

Modified: trunk/source/libraries/raknet/RakClient.h
===================================================================
--- trunk/source/libraries/raknet/RakClient.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakClient.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -1,4 +1,4 @@
-// This file is part of RakNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
+// This file is part of RarkNet Copyright 2003, 2004 Rakkarsoft LLC and Kevin Jenkins.
 
 // Usage of Raknet is subject to the appropriate licence agreement.
 // "Shareware" Licensees with Rakkarsoft LLC are subject to the shareware license found at http://www.rakkarsoft.com/shareWareLicense.html which you agreed to upon purchase of a "Shareware license"
@@ -28,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads);
+	bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer);
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	void Disconnect(void);
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -43,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn);
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	void InitializeSecurity(char *pubKeyP, char *pubKeyQ);
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -57,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream);
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel);
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -84,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort);
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on "255.255.255.255"
+	// or you will get replies from clients as well.
+	void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections);
 
 	// Returns the average of all ping times read
 	int GetAveragePing(void);
@@ -183,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -218,12 +220,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +237,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// Send the static server data to the server
@@ -285,21 +287,33 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost
-	unsigned long GetReceivedPacketCount(void); // How many packets were received
-	unsigned long GetBytesSent(void); // How many bytes have been sent.
-	unsigned long GetBytesReceived(void); // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(void); // Returns the time elapsed since you connected
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	void AllowConnectionResponseIPMigration(bool allow);
 
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	void AdvertiseSystem(char *host, unsigned short remotePort);
+
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(void);
+
+	// For internal use
+	PlayerIndex GetPlayerIndex(void);
+
 	private:
 
 	int GetOtherClientIndexByPlayerID(PlayerID playerId);
@@ -310,11 +324,12 @@
 	{
 		PlayerID playerId;
 		short ping;
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		bool isActive;
 	} otherClients[32];
 	// Synchronized random integer
 	unsigned long seed, nextSeed, nextSeedUpdate;
+	PlayerIndex localPlayerIndex;
 	PlayerID externalPlayerID; // This is your external ID (and also IP) (returned from the server)
 };
 

Modified: trunk/source/libraries/raknet/RakClientInterface.h
===================================================================
--- trunk/source/libraries/raknet/RakClientInterface.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakClientInterface.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -13,7 +13,8 @@
 #include "NetworkTypes.h"
 #include "PacketPriority.h"
 #include "RakPeerInterface.h"
-class BitStream;
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakClientInterface
 {
@@ -27,14 +28,15 @@
 	// serverPort is which port to connect to on the remote machine. clientPort is the port you want the client to use.
 	// Both ports must be open for UDP
 	// validationInteger is legacy and unused
-	// Set highPriorityThreads to true (recommended) for a real-time responsive client.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Returns true on successful initiation, false otherwise
-	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, bool highPriorityThreads)=0;
+	virtual bool Connect(char* host, unsigned short serverPort, unsigned short clientPort, unsigned long connectionValidationInteger, int threadSleepTimer)=0;
 
 	// Stops the client, stops synchronized data, and resets all internal data. 
 	// Does nothing if the client is not connected to begin with
-	virtual void Disconnect(void)=0;
+	// blockDuration is how long you should wait for all remaining packets to go out
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Can be called to use specific public RSA keys. (e and n)
@@ -42,10 +44,8 @@
 	// If a key has been altered.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAe, char *RSAn)=0;
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample.  Can be 0
+	virtual void InitializeSecurity(char *pubKeyP, char *pubKeyQ)=0;
 
 	// Set the password to use when connecting to a server.  The password persists between connections.
 	// Pass 0 for no password.
@@ -56,13 +56,13 @@
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the data stream of length length
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// This function only works while the client is connected (Use the Connect function).  Returns false on failure, true on success
 	// Sends the BitStream
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream)=0;
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel)=0;
 
 	// Call this to get a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -83,7 +83,10 @@
 	// networking system if it is not already initialized.  You can stop the networking system
 	// by calling Disconnect()
 	// The final ping time will be encoded in the following 4 bytes (2-5) as an unsigned long
-	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort)=0;
+	// You can specify if the server should only reply if it has an open connection or not
+	// This must be true for LAN broadcast server discovery on "255.255.255.255"
+	// or you will get replies from clients as well.
+	virtual void PingServer(char* host, unsigned short serverPort, unsigned short clientPort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Returns the average of all ping times read
 	virtual int GetAveragePing(void)=0;
@@ -182,8 +185,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -218,12 +221,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the server may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// The client internally maintains a data struct that is automatically sent to the server on connection
@@ -235,10 +238,10 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// Send the static server data to the server
@@ -285,20 +288,32 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(void)=0; // Returns the time elapsed since you connected
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	virtual void AllowConnectionResponseIPMigration(bool allow)=0;
+
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	virtual void AdvertiseSystem(char *host, unsigned short remotePort)=0;
+
+	// Description:
+	// Returns a structure containing a large set of network statistics for the server/client connection
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(void)=0;
+
+	// For internal use
+	virtual PlayerIndex GetPlayerIndex(void)=0;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/RakNetworkFactory.h
===================================================================
--- trunk/source/libraries/raknet/RakNetworkFactory.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakNetworkFactory.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -14,16 +14,16 @@
 class RakPeerInterface;
 
 #ifdef _WIN32
-#define EXPORT __declspec(dllexport)
+#define RAK_DLL_EXPORT __declspec(dllexport)
 #else
 // Unix needs no export, but for name mangling, keep the function name
 // clean. If you omit the 'extern "C"', the .so names will be
 // compiler dependent.
-#define EXPORT extern "C"
+#define RAK_DLL_EXPORT extern "C"
 #endif
 
 #if defined(DLL_EXPORTS) || defined(_USRDLL)
-class EXPORT RakNetworkFactory
+class RAK_DLL_EXPORT RakNetworkFactory
 #else
 //class __declspec( dllimport ) RakNetworkFactory
 class RakNetworkFactory

Modified: trunk/source/libraries/raknet/RakPeer.cpp
===================================================================
--- trunk/source/libraries/raknet/RakPeer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakPeer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -27,20 +27,33 @@
 #include "PacketEnumerations.h"
 #include "HuffmanEncodingTree.h"
 #include "PacketPool.h"
-#include "RSA.h"
 #include "Rand.h"
 
+// alloca
+#ifdef _WIN32
+#include <malloc.h>
+#else
+#include <stdlib.h>
+#endif
+
 static const unsigned long SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION=5000;
 
+// UPDATE_THREAD_POLL_TIME is how often the update thread will poll to see
+// if receive wasn't called within UPDATE_THREAD_UPDATE_TIME.  If it wasn't called within that time,
+// the updating thread will activate and take over network communication until Receive is called again.
+//static const unsigned long UPDATE_THREAD_UPDATE_TIME=30;
+//static const unsigned long UPDATE_THREAD_POLL_TIME=30;
 
+//#define _TEST_AES
+
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Constructor
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 RakPeer::RakPeer()
 {
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 	memset(frequencyTable, 0, sizeof(unsigned long) * 256);
-	rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+	rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 	outputTree=inputTree=0;
 	connectionSocket=INVALID_SOCKET;
 	MTUSize=DEFAULT_MTU_SIZE;
@@ -51,10 +64,11 @@
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 	endThreads=true;
 	isMainLoopThreadActive=false;
-	isRecvfromThreadActive=false;
-	occasionalPing=true;
+//	isRecvfromThreadActive=false;
+	occasionalPing=false;
 	connectionSocket=INVALID_SOCKET;
 	myPlayerId=UNASSIGNED_PLAYER_ID;
+	allowConnectionResponseIPMigration=false;
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -64,7 +78,7 @@
 {
 	unsigned i;
 
-	Disconnect();
+	Disconnect(0L);
 
 	// Clear out the lists:
 	for (i=0; i < requestedConnectionsList.size(); i++)
@@ -86,12 +100,12 @@
 // - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 // - A hybrid would set it to the sum of both types of connections
 // localPort: The port to listen for connections on.
-// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 //
 // Returns:
 // False on failure (can't create socket or thread), true on success.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)
+bool RakPeer::Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)
 {
 	unsigned i;
 
@@ -108,13 +122,15 @@
 
 	if (maximumNumberOfPeers==0)
 	{
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
 		remoteSystemList = new RemoteSystemStruct[MaximumNumberOfPeers];
 		for (i=0; i < MaximumNumberOfPeers; i++)
 		{
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID;
 		}
-		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Unlock();
 
 		// Don't allow more incoming connections than we have peers.
 		if (maximumIncomingConnections>MaximumNumberOfPeers)
@@ -123,108 +139,93 @@
 		maximumNumberOfPeers=MaximumNumberOfPeers;
 	}
 
+	// For histogram statistics
+//	nextReadBytesTime=0;
+//	lastSentBytes=lastReceivedBytes=0;
+
 	if (endThreads)
 	{
+		lastUserUpdateCycle=0;
+
 		// Reset the frequency table that we use to save outgoing data
 		memset(frequencyTable, 0, sizeof(unsigned long) * 256);
 
 		// Reset the statistical data
-		rawBytesSent=rawBytesRecieved=compressedBytesSent=compressedBytesRecieved=0;
+		rawBytesSent=rawBytesReceived=compressedBytesSent=compressedBytesReceived=0;
 
+		updateCycleIsRunning=false;
 		endThreads=false;
 		// Create the threads
-		threadPriority=_threadPriority;
+		threadSleepTimer=_threadSleepTimer;
 
 		char ipList[10][16];
 		SocketLayer::Instance()->GetMyIP(ipList);
 		myPlayerId.port=localPort;
 		myPlayerId.binaryAddress=inet_addr(ipList[0]);
 
+		if (threadSleepTimer >=0)
+		{
 #ifdef _WIN32
-		if (isMainLoopThreadActive==false)
-		{
-			unsigned ProcessPacketsThreadID=0;
-			processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID);
-			if (threadPriority==2 && processPacketsThreadHandle)
-				SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
-			else if (processPacketsThreadHandle==0)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
-			}
+				unsigned ProcessPacketsThreadID=0;
+				processPacketsThreadHandle=(HANDLE)_beginthreadex(NULL, 0, UpdateNetworkLoop, this, 0, &ProcessPacketsThreadID);
 
-			CloseHandle(processPacketsThreadHandle);
-			processPacketsThreadHandle=0;
+				if (processPacketsThreadHandle==0)
+				{
+					Disconnect(0L);
+					return false;
+				}
 
-		}
+				//	SetThreadPriority(processPacketsThreadHandle, THREAD_PRIORITY_HIGHEST);
 
-		if (isRecvfromThreadActive==false)
-		{
-			unsigned recvfromThreadID=0;
-			recvfromThreadHandle=(HANDLE)_beginthreadex(NULL, 0, RecvFromNetworkLoop, this, 0, &recvfromThreadID);
+				CloseHandle(processPacketsThreadHandle);
+				processPacketsThreadHandle=0;
 
-#ifndef __USE_IO_COMPLETION_PORTS
-			if (threadPriority==2 && recvfromThreadHandle)
-				SetThreadPriority(recvfromThreadHandle, THREAD_PRIORITY_HIGHEST);
-#endif
-
-			if (recvfromThreadHandle==0)
-			{
-				Disconnect();
-				return false;
 			}
 
-			CloseHandle(recvfromThreadHandle);
-			recvfromThreadHandle=0;
-		}
-
 #else
-		pthread_attr_t attr;
+			pthread_attr_t attr;
 
-		pthread_attr_init( &attr );
-		pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
-		if (threadPriority==2)
-		{
-			sched_param sp;
-			sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
-			pthread_attr_setschedparam(&attr, &sp);
-		}
+			pthread_attr_init( &attr );
+			pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_DETACHED );
 
-		int error;
+			//		sched_param sp;
+			//		sp.sched_priority = sched_get_priority_max(SCHED_OTHER);
+			//		pthread_attr_setschedparam(&attr, &sp);
 
-		if (isMainLoopThreadActive==false)
-		{
-			error = pthread_create( &processPacketsThreadHandle, &attr, &UpdateNetworkLoop, this );
-			if (error)
-			{
-				Disconnect();
-				return false;
-			}
-		}
+			int error;
 
-		if (	isRecvfromThreadActive==false)
-		{
-			error = pthread_create( &recvfromThreadHandle, &attr, &RecvFromNetworkLoop, this );
-			if (error)
+			if (isMainLoopThreadActive==false)
 			{
-				Disconnect();
-				return false;
+				error = pthread_create( &processPacketsThreadHandle, &attr, &UpdateNetworkLoop, this );
+				if (error)
+				{
+					Disconnect(0L);
+					return false;
+				}
 			}
-		}
-		pthread_attr_destroy( &attr );
 
-		processPacketsThreadHandle=0;
+			processPacketsThreadHandle=0;
 #endif
 
-		// Wait for the threads to activate.  When they are active they will set these variables to true
-		while (isRecvfromThreadActive==false || isMainLoopThreadActive==false)
+
+			// Wait for the threads to activate.  When they are active they will set these variables to true
+			while (/*isRecvfromThreadActive==false || */isMainLoopThreadActive==false)
 #ifdef _WIN32
-			Sleep(10);
+				Sleep(10);
 #else
-			usleep(10 * 1000);
+				usleep(10 * 1000);
 #endif
 
-	}
+		}
+		else
+		{
+#ifdef __USE_IO_COMPLETION_PORTS
+			AsynchronousFileIO::Instance()->IncreaseUserCount();
+#endif
+		}
+	}		
 
 	return true;
 }
@@ -240,57 +241,61 @@
 // If you accept connections, you must call this or else secure connections will not be enabled
 // for incoming connections.
 // If you are connecting to another system, you can call this with values for the
-// (e and n) public keys before connecting to prevent MitM
+// (e and p,q) public keys before connecting to prevent MitM
 //
 // Parameters:
-// numberOfBytes:  How many bytes to use for each of the RSA keys.
-// RSAd - A pointer to the private key of length numberOfBytes.
-// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
+// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample
+// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+// If the private keys are 0, then a new key will be generated when this function is called
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakPeer::InitializeSecurity(char *pubKeyP, char *pubKeyQ, char *privKeyE, char *privKeyN)
 {
 	if (endThreads==false)
 		return;
 
-	// You can specify e and n, d and e and n, or none.  Any other combination is invalid
-	if (!((RSAe && RSAn) || (RSAd==0 && RSAe==0 && RSAn==0)))
+	// Setting the client key is e,n,
+	// Setting the server key is p,q
+	// These are mutually exclusive
+	if ((pubKeyP && pubKeyQ && (privKeyE || privKeyN)) ||
+		(privKeyE && privKeyN && (pubKeyP || pubKeyQ)) ||
+		(pubKeyP && pubKeyQ==0) ||
+		(pubKeyQ && pubKeyP==0) ||
+		(privKeyE && privKeyN==0) ||
+		(privKeyN && privKeyE==0))
 	{
+		// Invalid parameters
 		assert(0);
-		return;
 	}
 
-	// For whatever reason the encoder / decoder fails randomly with data length 20 and bytes less than 32.
-	assert(numberOfBytes >= 32);
-	if (numberOfBytes < 32)
-	{
-		numberOfBytes=32;
-	}
+	seedMT(RakNetGetTime());
 
-	seedMT(getTime());
+	GenerateSYNCookieRandomNumber();
 
-	securedConnectionByteSize=numberOfBytes;
+	usingSecurity=true;
 
-	// Generate RSA keys
-	d.Init(numberOfBytes);
-	e.Init(numberOfBytes);
-	n.Init(numberOfBytes);
-
-	GenerateSYNCookieRandomNumber();
-
-	if (RSAd==0 && RSAe==0 && RSAn==0)
+	if (pubKeyP==0 && pubKeyQ==0 &&privKeyE==0 && privKeyN==0)
 	{
 		keysLocallyGenerated=true;
-		GenerateKeys(d,e,n);
+		rsacrypt.generateKeys();
 	}
 	else
 	{
+		if (pubKeyP && pubKeyQ)
+		{
+			// Save public keys
+			memcpy((char*)&publicKeyP, pubKeyP, sizeof(publicKeyP));
+			memcpy(publicKeyQ, pubKeyQ, sizeof(publicKeyQ));
+		}
+		else if (privKeyE && privKeyN)
+		{
+			BIGHALFSIZE(RSA_BIT_SIZE, p);
+			BIGHALFSIZE(RSA_BIT_SIZE, q);
+			memcpy(p, privKeyE, sizeof(p));
+			memcpy(q, privKeyN, sizeof(q));
+			// Save private keys
+			rsacrypt.setPrivateKey(p, q);
+		}
 		keysLocallyGenerated=false;
-		if (RSAd)
-			memcpy(d.value, RSAd, numberOfBytes);
-		memcpy(e.value, RSAe, numberOfBytes);
-		memcpy(n.value, RSAn, numberOfBytes);
 	}
 }
 
@@ -304,7 +309,7 @@
 	if (endThreads==false)
 		return;
 
-	securedConnectionByteSize=0;
+	usingSecurity=false;
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -343,18 +348,20 @@
 void RakPeer::SetIncomingPassword(char* passwordData, int passwordDataLength)
 {
 	// Set the incoming password data
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Lock();
 	incomingPasswordBitStream.Reset();
 	if (passwordData && passwordDataLength>0)
 		incomingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[incomingPasswordBitStream_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
 // Returns the password set by SetIncomingPassword in a BitStream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream *RakPeer::GetIncomingPassword(void)
+RakNet::BitStream *RakPeer::GetIncomingPassword(void)
 {
 	return &incomingPasswordBitStream;
 }
@@ -364,7 +371,7 @@
 // Call this to connect to the specified host (ip or domain name) and server port.
 // Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 // This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 // successful, such as rejected connection or no response then neither of these things will happen.
 // Requires that you first call Initialize
 //
@@ -395,11 +402,13 @@
 		return false;
 
 	// Set the incoming password data
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Lock();
 	outgoingPasswordBitStream.Reset();
 	if (passwordData && passwordDataLength>0)
 		outgoingPasswordBitStream.Write(passwordData, passwordDataLength);
-	rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[outgoingPasswordBitStream_Mutex].Unlock();
 
 	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
 	if (host[0] < '0' || host[0] > '2')
@@ -417,9 +426,10 @@
 			 Packet *p;
 			 p = PacketPool::Instance()->GetPointer();
 
-			 p->data = new char [1];
+			 p->data = new unsigned char [1];
 			 p->data[0]=(unsigned char)ID_NO_FREE_INCOMING_CONNECTIONS;
 			 p->playerId=myPlayerId;
+			 p->playerIndex=(PlayerIndex)GetIndexFromPlayerID(myPlayerId);
 			 p->length = 1;
 
 			#ifdef _DEBUG
@@ -455,7 +465,7 @@
 				 NewIncomingConnectionStruct newIncomingConnectionStruct;
 				 newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 				 newIncomingConnectionStruct.externalID=myPlayerId;
-				 Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, myPlayerId, false);
+				 Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, myPlayerId, false);
 
 				 return true;
 			 }
@@ -473,30 +483,47 @@
 // Description:
 // Stops the network threads and close all connections.  Multiple calls are ok.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Disconnect(void)
+void RakPeer::Disconnect(unsigned long blockDuration)
 {
 	unsigned i;
-	unsigned short maxPeers=maximumNumberOfPeers;
+	unsigned short maxPeers=maximumNumberOfPeers; // This is done for threading reasons
 
 	// Call close connection in a loop for all open connections.
 	for (i=0; i < maxPeers; i++)
 	{
 		// CloseConnection uses maximumNumberOfPeers
-		CloseConnection(remoteSystemList[i].playerId, true);
+		CloseConnection(remoteSystemList[i].playerId, true, blockDuration);
+	
 	}
 
 	// Setting this to 0 allows remoteSystemList to be reallocated in Initialize and prevents threads from accessing the reliability layer
 	maximumNumberOfPeers=0;
 
-	// Stop the threads
-	endThreads=true;
+	if (endThreads==false)
+	{
+		// Stop the threads
+		endThreads=true;
 
-	while(isMainLoopThreadActive)
+		// Normally the thread will call DecreaseUserCount on termination but if we aren't using threads just do it
+		// manually
+#ifdef __USE_IO_COMPLETION_PORTS
+		if (threadSleepTimer<0)
+		{
+			AsynchronousFileIO::Instance()->DecreaseUserCount();
+		}
+#endif
+
+	}
+
+	if (threadSleepTimer>=0)
+	{
+		while(isMainLoopThreadActive)
 #ifdef _WIN32
-		Sleep(10);
+			Sleep(10);
 #else
-		usleep(10 * 1000);
+			usleep(10 * 1000);
 #endif
+	}
 
 	if (connectionSocket != INVALID_SOCKET)
 	{
@@ -511,14 +538,14 @@
 //		SocketLayer::Instance()->SendTo(connectionSocket, &c, 1, "127.0.0.1", myPlayerId.port);
 //	}
 
-	while(isRecvfromThreadActive)
-#ifdef _WIN32
-		Sleep(10);
-#else
-		usleep(10 * 1000);
-#endif
+//	while(isRecvfromThreadActive)
+//#ifdef _WIN32
+//		Sleep(10);
+//#else
+//		usleep(10 * 1000);
+//#endif
 
-	isSocketLayerBlocking=false;
+//	isSocketLayerBlocking=false;
 
 //	if (connectionSocket != INVALID_SOCKET)
 //	{
@@ -539,7 +566,15 @@
 
 	bytesSentPerSecond=bytesReceivedPerSecond=0;
 
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i < requestedConnectionsList.size(); i++)
+		delete requestedConnectionsList[i];
+	requestedConnectionsList.clear();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
+
 	// Clear out the reliabilty layer list in case we want to reallocate it in a successive call to Init.
 	RemoteSystemStruct * temp = remoteSystemList;
 	remoteSystemList=0;
@@ -574,14 +609,25 @@
 		return false;
 	}
 
-	for (count=0, index=0; (remoteSystems==0 || count < *numberOfSystems) && index < maximumNumberOfPeers; ++index)
-		if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			if (remoteSystems)
-				remoteSystems[count]=remoteSystemList[index].playerId;
-			++count;
-		}
+	// This is called a lot so unroll the loop
+	if (remoteSystems)
+	{
+		for (count=0, index=0; index < maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+			{
+				if (count < *numberOfSystems)
+					remoteSystems[count]=remoteSystemList[index].playerId;
+				++count;
+			}
 
+	}
+	else
+	{
+		for (count=0, index=0; index < maximumNumberOfPeers; ++index)
+			if (remoteSystemList[index].playerId!=UNASSIGNED_PLAYER_ID)
+				++count;
+	}
+
 	*numberOfSystems=(unsigned short)count;
 
 	return 0;
@@ -598,25 +644,31 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // - Packets are only ordered relative to other packets on the same stream
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // Returns:
 // False if we are not connected to the specified recipient.  True otherwise
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(data && length>0);
+#endif
 	if (data==0 || length < 0)
 		return false;
 
-	BitStream temp(data, length, false);
-	return Send(&temp, priority, reliability, orderingStream, playerId, broadcast);
+	RakNet::BitStream temp(data, length, false);
+	return Send(&temp, priority, reliability, orderingChannel, playerId, broadcast);
 
 }
 
-bool RakPeer::Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakPeer::Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
+#ifdef _DEBUG
+	assert(bitStream->GetNumberOfBytesUsed()>0);
+#endif
 	if (bitStream->GetNumberOfBytesUsed()==0)
 		return false;
 	if (remoteSystemList==0 || endThreads==true)
@@ -648,13 +700,13 @@
 
 			if (outputTree)
 			{
-				BitStream bitStreamCopy(bitStream->GetNumberOfBytesUsed());
+				RakNet::BitStream bitStreamCopy(bitStream->GetNumberOfBytesUsed());
 				outputTree->EncodeArray(bitStream->GetData(),bitStream->GetNumberOfBytesUsed(), &bitStreamCopy);
 				compressedBytesSent+=bitStreamCopy.GetNumberOfBytesUsed();
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&bitStreamCopy, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(&bitStreamCopy, priority,reliability,orderingChannel, true, MTUSize);
 			}
 			else
-				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingStream, true, MTUSize);
+				remoteSystemList[remoteSystemIndex].reliabilityLayer.Send(bitStream, priority,reliability,orderingChannel, true, MTUSize);
 
 			if (broadcast==false)
 				return true;
@@ -677,8 +729,15 @@
 {
 	if (!(IsActive()))	return 0;
 
+	// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+	// a mutex on the function is not necessary - only on the variable that indicates if the function is
+	// running
+//	lastUserUpdateCycle=RakNetGetTime();
+//	RunMutexedUpdateCycle();
+	
+
 	// Prepare to write out a bitstream containing all the synchronization data
-//	BitStream *bitStream=0;
+//	RakNet::BitStream *bitStream=0;
 /*
 	automaticVariableSynchronizationMutex.Lock();
 
@@ -759,7 +818,7 @@
 #endif
 
 		// Push the data into a bitstream for easy parsing
-		BitStream bitStream(data+1, length-1, false);
+		RakNet::BitStream bitStream(data+1, length-1, false);
 		UniqueIDType uniqueID;
 		bool hasSecondaryID;
 		ObjectID secondaryID;
@@ -828,18 +887,32 @@
 	Packet *val;
 	int offset;
 
-	incomingQueueMutex.Lock();
-	if (incomingPacketQueue.size() > 0)
+	while (1)
 	{
-		val = incomingPacketQueue.pop();
-	}
-	else
-	{
+		incomingQueueMutex.Lock();
+		if (incomingPacketQueue.size() > 0)
+		{
+			val = incomingPacketQueue.pop();
+		}
+		else
+		{
+			incomingQueueMutex.Unlock();
+			return 0;
+		}
+
 		incomingQueueMutex.Unlock();
-		return 0;
+
+		// Do RPC calls from the user thread, not the network update thread
+		if (val->data[0] == ID_RPC || val->data[0] == ID_RPC_WITH_TIMESTAMP)
+		{
+			HandleRPCPacket((char*)val->data, val->length, val->playerId);
+			DeallocatePacket(val);
+		}
+		else
+			break; // Send the packet to the user
 	}
-	incomingQueueMutex.Unlock();
 
+
 #ifdef _DEBUG
 	assert(val->data);
 #endif
@@ -848,7 +921,7 @@
 		((unsigned char)val->data[0] == ID_TIMESTAMP))
 	{
 		offset = sizeof(unsigned char);
-		ShiftIncomingTimestamp(val->data + offset, val->playerId);
+		ShiftIncomingTimestamp((char*)val->data + offset, val->playerId);
 	}
 
 	return val;
@@ -958,13 +1031,22 @@
 // bitStream: The bitstream to send
 // priority: What priority level to send on.
 // reliability: How reliability to send this data
-// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 // broadcast - Send this packet to everyone.
 // playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 // broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-bool RakPeer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakPeer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
+	RakNet::BitStream temp(data, BITS_TO_BYTES(bitLength), false);
+	if (data)
+		return RPC(uniqueID, &temp, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+	else
+		return RPC(uniqueID, 0, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
+}
+
+bool RakPeer::RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+{
 #ifdef _DEBUG
 	assert(uniqueID && uniqueID[0]);
 #endif
@@ -976,13 +1058,13 @@
 		return false; // Unique ID is too long
 	}
 
-	if (shiftTimestamp && (data==0 || bitLength < 8 * sizeof(unsigned long)))
+	if (shiftTimestamp && bitStream && (bitStream->GetNumberOfBytesUsed() < sizeof(unsigned long)))
 	{
 		assert(0); // Not enough bits to shift!
 		return false;
 	}
 
-	BitStream outgoingBitStream;
+	RakNet::BitStream outgoingBitStream;
 	unsigned char uniqueIDLength, ch;
 	uniqueIDLength = (unsigned char)strlen(uniqueID);
 
@@ -995,9 +1077,9 @@
 	for (int counter=0; uniqueID[counter]; counter++)
 	{
 		ch = (unsigned char)toupper(uniqueID[counter]);
-// Dev-C++ doesn't support toupper.  How lame.
-    //  if (uniqueID[counter] > 'Z')
-  //      uniqueID[counter]-='a'-'A';
+		// Dev-C++ doesn't support toupper.  How lame.
+		//  if (uniqueID[counter] > 'Z')
+		//      uniqueID[counter]-='a'-'A';
 
 		if (ch < 'A' || ch > 'Z')
 		{
@@ -1009,27 +1091,19 @@
 
 		// Make the range of the char from 0 to 32
 		ch-='A';
-		outgoingBitStream.WriteBits((unsigned char*)&ch, 5, true); // Write the char with 5 bits
+		outgoingBitStream.WriteBits((unsigned char*)&ch, 5); // Write the char with 5 bits
 	}
 
-	if (data==0)
-		bitLength=0;
+	outgoingBitStream.WriteCompressed(bitStream->GetNumberOfBitsUsed());
 
-	outgoingBitStream.WriteCompressed(bitLength);
-
 	// False to write the raw data from another bitstream, rather than shifting from user data
-	if (bitLength > 0)
-		outgoingBitStream.WriteBits((unsigned char*)data, bitLength);
+	if (bitStream && bitStream->GetNumberOfBitsUsed() > 0)
+		outgoingBitStream.WriteBits(bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), false);
 
-	return Send(&outgoingBitStream, priority, reliability, orderingStream,playerId,broadcast);
-}
+	// For testing
+	//	HandleRPCPacket((char*)outgoingBitStream.GetData(), outgoingBitStream.GetNumberOfBytesUsed(), UNASSIGNED_PLAYER_ID);
 
-bool RakPeer::RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
-{
-	if (bitStream && bitStream->GetNumberOfBitsUsed()>0)
-		return RPC(uniqueID, (char*)bitStream->GetData(), bitStream->GetNumberOfBitsUsed(), priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
-	else
-		return RPC(uniqueID, 0,0, priority, reliability, orderingStream, playerId, broadcast,shiftTimestamp);
+	return Send(&outgoingBitStream, priority, reliability, orderingChannel,playerId,broadcast);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1040,25 +1114,52 @@
 // target: Which connection to close
 // sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification)
+void RakPeer::CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)
 {
+	unsigned i, stopWaitingTime;
 	if (remoteSystemList==0 || endThreads==true)
 		return;
 
 	if (sendDisconnectionNotification)
 	{
 		unsigned char c=ID_DISCONNECTION_NOTIFICATION;
-		Send((char*)&c, sizeof(c), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+		Send((char*)&c, sizeof(c), SYSTEM_PRIORITY, RELIABLE, 0, target, false);
+		lastUserUpdateCycle=RakNetGetTime();
+//		RunMutexedUpdateCycle();
 	}
-	
-	unsigned i;
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
-	for (i=0; i < maximumNumberOfPeers; i++)
+
+	i=0;
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	for (; i < maximumNumberOfPeers; i++)
 		if (remoteSystemList[i].playerId==target)
 		{
-			// One last update so the disconnect or other packets can go out
-			remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
+			// Send out any last packets
+			// Update isn't thread safe to call outside of the internal thread
+			// remoteSystemList[i].reliabilityLayer.Update(connectionSocket, remoteSystemList[i].playerId, MTUSize);
 
+			if (blockDuration>=0)
+			{
+				stopWaitingTime=RakNetGetTime() + blockDuration;
+
+				while (RakNetGetTime() < stopWaitingTime)
+				{
+					// If this system is out of packets to send, then stop waiting
+					if (remoteSystemList[i].reliabilityLayer.GetStatistics()->messageSendBuffer[SYSTEM_PRIORITY]==0)
+						break;
+
+					// This will probably cause the update thread to run which will probably
+					// send the disconnection notification
+#ifdef _WIN32
+					Sleep(0);
+#else
+					usleep(0 * 1000);
+#endif
+//					lastUserUpdateCycle=RakNetGetTime();
+//					RunMutexedUpdateCycle();
+				}
+			}
+
 			// Reserve this reliability layer for ourselves
 			remoteSystemList[i].playerId=UNASSIGNED_PLAYER_ID; // This one line causes future incoming packets to go through the reliability layer
 
@@ -1067,7 +1168,8 @@
 			break;
 		}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1217,11 +1319,13 @@
 		return false;
 
 	banListIndex=0;
+	if (banList.size()==0)
+		return false; // Skip the mutex if possible
 	banListMutex.Lock();
 	for (; banListIndex < banList.size(); banListIndex++)
 	{
 		characterIndex=0;
-		while (1)
+		while (true)
 		{
 			if (banList[banListIndex][characterIndex]==IP[characterIndex])
 			{
@@ -1275,9 +1379,9 @@
 
 	PingStruct ping;
 	ping.typeId=ID_PING;
-	ping.sendPingTime=getTime();
+	ping.sendPingTime=RakNetGetTime();
 
-	Send((char*)&ping, sizeof(PingStruct), HIGH_PRIORITY, UNRELIABLE, 0, target, false);
+	Send((char*)&ping, sizeof(PingStruct), SYSTEM_PRIORITY, UNRELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1290,10 +1394,11 @@
 // The sender and recipient must already be started via a successful call to Initialize
 //
 // Parameters:
-// host: Either a dotted IP address or a domain name
+// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 // remotePort: Which port to connect to on the remote machine.
+// onlyReplyOnAcceptingConnections: Only request a reply if the remote system has open connections
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-void RakPeer::Ping(char* host, unsigned short remotePort)
+void RakPeer::Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)
 {
 	if (host==0)
 		return;
@@ -1305,8 +1410,11 @@
 	}
 
 	UnconnectedPingStruct s;
-	s.typeId=ID_PING;
-	s.sendPingTime=getTime();
+	if (onlyReplyOnAcceptingConnections)
+		s.typeId=ID_PING_OPEN_CONNECTIONS;
+	else
+		s.typeId=ID_PING;
+	s.sendPingTime=RakNetGetTime();
 
 	SocketLayer::Instance()->SendTo(connectionSocket, (char*)&s, sizeof(UnconnectedPingStruct), (char*)host, remotePort);
 }
@@ -1372,7 +1480,7 @@
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
-// Ping the remote systems every so often.  This is on by default
+// Ping the remote systems every so often.  This is off by default
 // This will work anytime
 //
 // Parameters:
@@ -1557,7 +1665,7 @@
 // Returns:
 // The data passed to SetRemoteStaticData stored as a bitstream
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-BitStream* RakPeer::GetRemoteStaticData(PlayerID playerId)
+RakNet::BitStream * RakPeer::GetRemoteStaticData(PlayerID playerId)
 {
 	if (playerId==myPlayerId)
 		return &localStaticData;
@@ -1609,17 +1717,33 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SendStaticData(PlayerID target)
 {
-	BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
+	RakNet::BitStream reply(sizeof(unsigned char) + localStaticData.GetNumberOfBytesUsed());
 	reply.Write((unsigned char) ID_RECEIVED_STATIC_DATA);
 	reply.Write((char*)localStaticData.GetData(), localStaticData.GetNumberOfBytesUsed());
 	if (target==UNASSIGNED_PLAYER_ID)
-		Send(&reply, HIGH_PRIORITY, RELIABLE, 0, target, true);
+		Send(&reply, SYSTEM_PRIORITY, RELIABLE, 0, target, true);
 	else
-		Send(&reply, HIGH_PRIORITY, RELIABLE, 0, target, false);
+		Send(&reply, SYSTEM_PRIORITY, RELIABLE, 0, target, false);
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
+// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+// See the Ping sample project for how this is used.
+// data: a block of data to store, or 0 for none
+// length: The length of data in bytes, or 0 for none
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+void RakPeer::SetOfflinePingResponse(char *data, const unsigned long length)
+{
+	rakPeerMutexes[offlinePingResponse_Mutex].Lock();
+	offlinePingResponse.Reset();
+	if (data && length > 0)
+		offlinePingResponse.Write(data, length);
+	rakPeerMutexes[offlinePingResponse_Mutex].Unlock();
+}
+
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// Description:
 // Return the unique PlayerID that represents you on the the network
 // Note that unlike in previous versions, this is a struct and is not sequential
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -1731,7 +1855,7 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 const char* RakPeer::GetLocalIP(unsigned int index)
 {
-	char ipList[10][16];
+	static char ipList[10][16];
 	if (index >=10)
 		index=9;
 	memset(ipList, 0, sizeof(char) * 16 * 10);
@@ -1741,6 +1865,42 @@
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 // Description:
+// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+// when connection to servers with multiple IP addresses
+//
+// Parameters:
+// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+void RakPeer::AllowConnectionResponseIPMigration(bool allow)
+{
+	allowConnectionResponseIPMigration=allow;
+}
+
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// Description:
+// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+//
+// Requires:
+// The sender and recipient must already be started via a successful call to Initialize
+//
+// host: Either a dotted IP address or a domain name
+// remotePort: Which port to connect to on the remote machine.
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+void RakPeer::AdvertiseSystem(char *host, unsigned short remotePort)
+{
+	// If the host starts with something other than 0, 1, or 2 it's (probably) a domain name.
+	if (host[0] < '0' || host[0] > '2')
+	{
+		host = (char*) SocketLayer::Instance()->DomainNameToIP(host);
+	}
+
+	unsigned char c = ID_ADVERTISE_SYSTEM;
+	SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(c), (char*)host, remotePort);	
+}
+
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// Description:
 // Enables or disables our tracking of bytes input to and output from the network.
 // This is required to get a frequency table, which is used to generate a new compression layer.
 // You can call this at any time - however you SHOULD only call it when disconnected.  Otherwise you will only track
@@ -1873,9 +2033,9 @@
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 float RakPeer::GetDecompressionRatio(void) const
 {
-	if (rawBytesRecieved>0L)
+	if (rawBytesReceived>0L)
 	{
-		return (float)compressedBytesRecieved / (float)rawBytesRecieved;
+		return (float)compressedBytesReceived / (float)rawBytesReceived;
 	}
 	else return 0.0f;
 }
@@ -1913,224 +2073,19 @@
 #ifdef _DEBUG
 		assert(packet->data);
 #endif
-		incomingPacketQueue.push(packet);
+		incomingPacketQueue.pushAtHead(packet);
 	}
 }
-
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-double RakPeer::GetPacketlossPercentile(void) const
+RakNetStatisticsStruct *  const RakPeer::GetStatistics(PlayerID playerId)
 {
-	unsigned i;
-	double value=0.0f;
-	int count=0;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0;
-
-	for (i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			count++;
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketlossPercentile();
-		}
-	}
-
-	if (count>0)
-		return value/(double)count;
-	else return 0.0;
+	RemoteSystemStruct *rss;
+	rss=GetRemoteSystemFromPlayerID(playerId);
+	if (rss)
+		return rss->reliabilityLayer.GetStatistics();
+	return 0;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID &&remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetTransmittedFrameCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetTransmittedFrameCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetLostPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetLostPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetReceivedPacketCount(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].reliabilityLayer.GetBytesSent()>0)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetReceivedPacketCount();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSent(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesSent();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceived(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetBytesReceived();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetUnacknowledgedSentPacketListSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetUnacknowledgedSentPacketListSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesSentPerSecond(void) const
-{
-	return bytesSentPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetBytesReceivedPerSecond(void) const
-{
-	return bytesReceivedPerSecond;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetMaximumWindowSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetMaximumWindowSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetPacketOutputBufferSize(void) const
-{
-	unsigned i;
-	unsigned value;
-
-	if (remoteSystemList==0 || endThreads==true)
-		return 0L;
-
-	for (value=0,i=0; i < maximumNumberOfPeers; i++)
-	{
-		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID)
-		{
-			value+=remoteSystemList[i].reliabilityLayer.GetPacketOutputBufferSize();
-		}
-	}
-
-	return value;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-unsigned long RakPeer::GetConnectionTime(PlayerID playerId) const
-{
-	RemoteSystemStruct *remoteSystem = GetRemoteSystemFromPlayerID(playerId);
-	if (remoteSystem)
-		return getTime() - remoteSystem->connectionTime;
-	else
-		return 0;
-}
-// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RecordConnectionAttempt(const char* host, unsigned short remotePort)
 {
 	PlayerID playerId;
@@ -2138,20 +2093,23 @@
 	s = new RequestedConnectionStruct;
 	IPToPlayerID(host, remotePort, &playerId);
 	s->playerId=playerId;
-	s->time=getTime();
+	s->time=RakNetGetTime();
 	s->setAESKey=false;
 	s->nextRequestTime=s->time + 2000;
 
 	// Record that we tried to connect to this host
-	rakPeerMutexes[requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Lock();
 	requestedConnectionsList.push(s);
-	rakPeerMutexes[requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::RemoveFromRequestedConnectionsList(PlayerID playerId)
 {
 	int i;
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i < (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]->playerId==playerId)
@@ -2161,7 +2119,8 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 bool RakPeer::SendConnectionRequest(const char* host, unsigned short remotePort)
@@ -2169,7 +2128,7 @@
 	int j;
 
 	const unsigned char c=ID_CONNECTION_REQUEST;
-	BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
+	RakNet::BitStream temp(sizeof(unsigned char) + outgoingPasswordBitStream.GetNumberOfBytesUsed());
 	temp.Write(c);
 	if (outgoingPasswordBitStream.GetNumberOfBytesUsed()>0)
 		temp.Write((char*)outgoingPasswordBitStream.GetData(), outgoingPasswordBitStream.GetNumberOfBytesUsed());
@@ -2184,8 +2143,10 @@
 		temp.port=remotePort;
 		PushPortRefused(temp);
 		closesocket(connectionSocket);
-		rakPeerMutexes[requestedConnections_MUTEX].Lock();
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[requestedConnections_MUTEX].Lock();
 		delete requestedConnectionsList.pop();
+		if (threadSleepTimer>=0)
 		rakPeerMutexes[requestedConnections_MUTEX].Unlock();
 	}
 #endif
@@ -2225,9 +2186,9 @@
 
 		if (remoteSystem==0)
 		{
-			// No reliability layer available
-			unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-			SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId);
+			// Already connected.  Ignore duplicate connection requests
+		//	unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
+		//	SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			return;
 		}
 
@@ -2255,19 +2216,20 @@
 		ds.remotePort = myPlayerId.port;
 		#endif
 		ds.externalID=playerId;
+		ds.playerIndex=(PlayerIndex)GetIndexFromPlayerID(playerId);
 		// Write using the new socket so the client knows what port to use
-		int result=SocketLayer::Instance()->SendTo(connectionSocket, (char*)&ds, sizeof(ds), playerId);
+		int result=SocketLayer::Instance()->SendTo(connectionSocket, (char*)&ds, sizeof(ds), playerId.binaryAddress, playerId.port);
 
 		if (result!=0)
 		{
-			CloseConnection(playerId, false);
+			CloseConnection(playerId, false,0L);
 			return;
 		}
 	}
 	else
 	{
 		unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-		SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId);
+		SocketLayer::Instance()->SendTo(connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2280,8 +2242,10 @@
 
 	numberOfIncomingConnections=0;
 	for (i=0; i < maximumNumberOfPeers; i++)
+	{
 		if (remoteSystemList[i].playerId!=UNASSIGNED_PLAYER_ID && remoteSystemList[i].weInitiatedTheConnection==false)
 			numberOfIncomingConnections++;
+	}
 
 	return numberOfIncomingConnections;
 }
@@ -2291,13 +2255,26 @@
 	RemoteSystemStruct *remoteSystem=0;
 	unsigned i;
 
-	rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::remoteSystemList_Mutex].Lock();
+	// If this guy is already connected, return 0.  This needs to be checked inside the mutex
+	// because threads may call the connection routine multiple times at the same time
 	for (i=0; i < maximumNumberOfPeers; i++)
+		if (remoteSystemList[i].playerId==playerId)
+		{
+			if (threadSleepTimer>=0)
+				rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+			return 0;
+		}
+
+	for (i=0; i < maximumNumberOfPeers; i++)
 	{
 		if (remoteSystemList[i].playerId==UNASSIGNED_PLAYER_ID)
 		{
 			if (setAESKey)
 				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(AESKey);
+			else
+				(remoteSystemList[i]).reliabilityLayer.SetEncryptionKey(0);
 			// Reserve this reliability layer for ourselves
 			(remoteSystemList[i]).playerId=playerId; // This one line causes future incoming packets to go through the reliability layer
 			remoteSystem=remoteSystemList+i;
@@ -2305,7 +2282,8 @@
 		}
 	}
 
-	rakPeerMutexes[remoteSystemList_Mutex].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[remoteSystemList_Mutex].Unlock();
 
 	return remoteSystem;
 }
@@ -2325,9 +2303,9 @@
 	remoteSystem->nextPingTime=0; // Ping immediately
 	remoteSystem->weInitiatedTheConnection=weInitiatedTheConnection;
 	remoteSystem->staticData.Reset();
-	remoteSystem->connectionTime=getTime();
+	remoteSystem->connectionTime=RakNetGetTime();
 	remoteSystem->myExternalPlayerId=UNASSIGNED_PLAYER_ID;
-//	remoteSystem->reliabilityLayer.Reset();
+	remoteSystem->reliabilityLayer.Reset();
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2359,7 +2337,7 @@
 
 	for (counter=0; counter < PING_TIMES_ARRAY_SIZE; counter++)
 	{
-		if (remoteSystem->pingAndClockDifferential[0].pingTime==-1)
+		if (remoteSystem->pingAndClockDifferential[counter].pingTime==-1)
 			break;
 
 		if (remoteSystem->pingAndClockDifferential[counter].pingTime < lowestPingSoFar)
@@ -2392,11 +2370,12 @@
 	// Number of bits of the data (long)
 	// The data
 
-	BitStream incomingBitStream(data, length, false);
+	RakNet::BitStream incomingBitStream(data, length, false);
 	unsigned char uniqueIDLength, ch, packetID;
 	char uniqueIdentifier[256];
 	int counter;
-	long bitLength;
+	unsigned long bitLength;
+	char *userData;
 
 	if (incomingBitStream.Read(packetID)==false)
 	{
@@ -2480,17 +2459,18 @@
 		}
 
 		// We have to copy into a new data chunk because the user data might not be byte aligned.
-		char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		//char *userData = new char[BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits())];
+		userData=(char*)alloca(BITS_TO_BYTES(incomingBitStream.GetNumberOfUnreadBits()));
 
 		// The false means read out the internal representation of the bitstream data rather than
-		// Aligning it as we normally would with user data.  This is so the end user can cast the data received
+		// aligning it as we normally would with user data.  This is so the end user can cast the data received
 		// into a bitstream for reading
 		if (incomingBitStream.ReadBits((unsigned char*)userData, bitLength, false)==false)
 		{
 #ifdef _DEBUG
 			assert(0);
 #endif
-			delete [] userData;
+		//	delete [] userData;
 			return false; // Not enough data to read
 		}
 
@@ -2499,7 +2479,7 @@
 		// Call the function callback
 		node->functionName(userData, bitLength, playerId);
 		// Free the memory
-		delete [] userData;
+//		delete [] userData;
 	}
 
 	return true;
@@ -2508,12 +2488,17 @@
 #ifdef __USE_IO_COMPLETION_PORTS
 bool RakPeer::SetupIOCompletionPortSocket(int index)
 {
-	SOCKET newSocket = SocketLayer::Instance()->CreateBoundSocket(myPlayerId.port+index+1, false);
-	SocketLayer::Instance()->Connect(newSocket, remoteSystemList[index].playerId); // port is the port of the client
+	SOCKET newSocket;
+
+	if (remoteSystemList[index].reliabilityLayer.GetSocket()!=INVALID_SOCKET)
+		closesocket(remoteSystemList[index].reliabilityLayer.GetSocket());
+
+	newSocket = SocketLayer::Instance()->CreateBoundSocket(myPlayerId.port+index+1, false);
+	SocketLayer::Instance()->Connect(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port); // port is the port of the client
 	remoteSystemList[index].reliabilityLayer.SetSocket(newSocket);
 
 	// Associate our new socket with a completion port and do the first read
-	return SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId, this);
+	return SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(newSocket, remoteSystemList[index].playerId.binaryAddress,remoteSystemList[index].playerId.port, this);
 }
 #endif
 
@@ -2530,15 +2515,15 @@
 		memcpy(newRandomNumber+i, (char*)&number, sizeof(number));
 	}
 
-	randomNumberExpirationTime = getTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
+	randomNumberExpirationTime = RakNetGetTime() + SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION;
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 void RakPeer::SecuredConnectionResponse(PlayerID playerId)
 {
 	CSHA1 sha1;
-	unsigned char *connectionRequestResponse;
-	// 20 bytes for the SHA1 hash
-	connectionRequestResponse = new unsigned char [1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20];
+	RSA_BIT_SIZE n;
+	big::u32 e;
+	unsigned char connectionRequestResponse[1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20];
 	connectionRequestResponse[0]=ID_SECURED_CONNECTION_RESPONSE;
 
 	// Hash the SYN-Cookie
@@ -2552,54 +2537,63 @@
 	// Write the cookie
 	memcpy(connectionRequestResponse+1, sha1.GetHash(), 20);
 
-	// Write the byte size
-	memcpy(connectionRequestResponse+1+20, (char*)&securedConnectionByteSize, securedConnectionByteSize);
-
 	// Write the public keys
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize), e.value, securedConnectionByteSize);
-	memcpy(connectionRequestResponse+1+20+sizeof(securedConnectionByteSize)+securedConnectionByteSize, n.value, securedConnectionByteSize);
+	rsacrypt.getPublicKey(e,n);
+	memcpy(connectionRequestResponse+1+20, (char*)&e, sizeof(big::u32));
+	memcpy(connectionRequestResponse+1+20+sizeof(big::u32), n, sizeof(RSA_BIT_SIZE));
 
 	// s2c public key, syn-cookie
-	SocketLayer::Instance()->SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(securedConnectionByteSize)+securedConnectionByteSize*2 + 20, playerId);
-	delete [] connectionRequestResponse;
+	SocketLayer::Instance()->SendTo(connectionSocket, (char*)connectionRequestResponse, 1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20, playerId.binaryAddress, playerId.port);
 }
-void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data, int length)
+void RakPeer::SecuredConnectionConfirmation(PlayerID playerId, char* data)
 {
 	int i,j;
 	unsigned char randomNumber[20];
 	unsigned long number;
-	unsigned short rsaByteSize;
 	bool doSend;
 	Packet *packet;
-	mpuint source,result,packetE, packetN;
+	big::u32 e;
+	RSA_BIT_SIZE n, message,encryptedMessage;
+	big::RSACrypt<RSA_BIT_SIZE> pubKeyPncrypt;
 
-	doSend=false;
-	rsaByteSize=0;
+	// Make sure that we still want to connect
+	bool requestedConnection=false;
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	for (i=0; i < (int)requestedConnectionsList.size();i++)
+	{
+		if (requestedConnectionsList[i]->playerId==playerId)
+		{
+			// We did request this connection
+			requestedConnection=true;
+			break;
+		}
+	}
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
-#ifdef _DEBUG
-	assert(sizeof(rsaByteSize)==sizeof(securedConnectionByteSize));
-#endif
+	if (requestedConnection==false)
+		return; // Don't want to connect
 
-	// Get the rsa byte size
-	memcpy((char*)&rsaByteSize, data+1+20, sizeof(rsaByteSize));
+	doSend=false;
 
-	// If the packet length is wrong for this byte size, return
-	if (length != (int)(1+20+sizeof(rsaByteSize)+rsaByteSize*2))
-		return;
+	// Copy out e and n
+	memcpy((char*)&e,data+1+20, sizeof(big::u32));
+	memcpy(n, data+1+20+sizeof(big::u32), sizeof(RSA_BIT_SIZE));
 
 	// If we preset a size and it doesn't match, or the keys do not match, then tell the user
-	if (securedConnectionByteSize > 0 && keysLocallyGenerated==false)
+	if (usingSecurity==true && keysLocallyGenerated==false)
 	{
-		if (securedConnectionByteSize != rsaByteSize ||
-			memcmp(data+1+20+sizeof(rsaByteSize), e.value, rsaByteSize)!=0 ||
-			memcmp(data+1+20+sizeof(rsaByteSize)+rsaByteSize, n.value, rsaByteSize)!=0)
+		if (memcmp((char*)&e, (char*)&publicKeyP, sizeof(big::u32))!=0 ||
+			memcmp(n, publicKeyQ, sizeof(RSA_BIT_SIZE))!=0)
 		{
 			packet = PacketPool::Instance()->GetPointer();
-			packet->data = new char[1];
+			packet->data = new unsigned char[1];
 			packet->data[0]=ID_RSA_PUBLIC_KEY_MISMATCH;
 			packet->length=sizeof(char);
 			packet->bitSize=sizeof(char)*8;
 			packet->playerId=playerId;
+			packet->playerIndex=(PlayerIndex)GetIndexFromPlayerID(packet->playerId);
 			incomingQueueMutex.Lock();
 			incomingPacketQueue.push(packet);
 			incomingQueueMutex.Unlock();
@@ -2608,12 +2602,6 @@
 		}
 	}
 
-	// Copy the keys from the packet
-	packetE.Init(rsaByteSize);
-	packetN.Init(rsaByteSize);
-	memcpy(packetE.value,data+1+20+sizeof(rsaByteSize),rsaByteSize);
-	memcpy(packetN.value,data+1+20+sizeof(rsaByteSize)+rsaByteSize,rsaByteSize);
-
 	// Create a random number
 	for (i=0; i < sizeof(randomNumber); i+=sizeof(number))
 	{
@@ -2621,16 +2609,14 @@
 		memcpy(randomNumber+i, (char*)&number, sizeof(number));
 	}
 
-	// Encrypt the random number using RSA
-	source.Init(rsaByteSize);
-	result.Init(rsaByteSize);
+	memset(message, 0, sizeof(message));
+	assert(sizeof(message) >= sizeof(randomNumber));
+	memcpy(message, randomNumber, sizeof(randomNumber));
+	pubKeyPncrypt.setPublicKey(e,n);
+	pubKeyPncrypt.encrypt(message,encryptedMessage);
 
-	// This crummy rsa encoder doesn't work reliably with full blocks so WriteAndFill block doesn't work.
-	// source.WriteAndFillBlock((char*)randomNumber, 20);
-	memcpy(source.value, randomNumber, 20);
-	EncryptDecrypt(result, source, packetE, packetN);
-
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
 	for (i=0; i < (int)requestedConnectionsList.size();)
 	{
 		if (requestedConnectionsList[i]->playerId==playerId)
@@ -2643,18 +2629,17 @@
 			break;
 		}
 	}
-	rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	if (threadSleepTimer>=0)
+		rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 
 	if (doSend)
 	{
-		char *reply;
-		reply = new char [1+20+rsaByteSize];
+		char reply[1+20+sizeof(RSA_BIT_SIZE)];
 		// c2s RSA(random number), same syn-cookie
 		reply[0]=ID_SECURED_CONNECTION_CONFIRMATION;
 		memcpy(reply+1, data+1, 20);  // Copy the syn-cookie
-		memcpy(reply+1+20, result.value, rsaByteSize); // Copy the encoded random number
-		SocketLayer::Instance()->SendTo(connectionSocket, reply, 1+20+rsaByteSize, playerId);
-		delete [] reply;
+		memcpy(reply+1+20, encryptedMessage, sizeof(RSA_BIT_SIZE)); // Copy the encoded random number
+		SocketLayer::Instance()->SendTo(connectionSocket, reply, 1+20+sizeof(RSA_BIT_SIZE), playerId.binaryAddress, playerId.port);
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
@@ -2663,10 +2648,11 @@
 	// Tell the game we can't connect to this host
 	Packet *p;
 	p = PacketPool::Instance()->GetPointer();
-	p->data=new char[1];
+	p->data=new unsigned char[1];
 	p->data[0]=ID_REMOTE_PORT_REFUSED;
 	p->length=sizeof(char);
 	p->playerId=target; // We don't know this!
+	p->playerIndex=(PlayerIndex)GetIndexFromPlayerID(p->playerId);
 
 	#ifdef _DEBUG
 	assert(p->data);
@@ -2678,6 +2664,7 @@
 }
 
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+/*
 #ifdef _WIN32
 unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments)
 #else
@@ -2739,7 +2726,7 @@
 #endif
 	return 0;
 }
-
+*/
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 #ifdef _WIN32
 void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer)
@@ -2756,18 +2743,33 @@
 	if (remoteSystem)
 	{
 		// Handle regular incoming data
+		// HandleSocketReceiveFromConnectedPlayer is only safe to be called from the same thread as Update,
+		// which is this thread
 		if (remoteSystem->reliabilityLayer.HandleSocketReceiveFromConnectedPlayer(data, length)==false)
 		{
-			// Cheater
-			Packet *packet = PacketPool::Instance()->GetPointer();
-			packet->data = new char[1];
-			packet->data[0]=ID_MODIFIED_PACKET;
-			packet->length=sizeof(char);
-			packet->bitSize=sizeof(char)*8;
-			packet->playerId=playerId;
-			rakPeer->incomingQueueMutex.Lock();
-			rakPeer->incomingPacketQueue.push(packet);
-			rakPeer->incomingQueueMutex.Unlock();
+			// These kinds of packets may have been duplicated and incorrectly determined to be
+			// cheat packets.  Anything else really is a cheat packet
+			if (!((unsigned char)(data)[0]==ID_CONNECTION_REQUEST ||
+				((unsigned char)(data)[0]==ID_PING && length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_PONG && length>=sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS && length==sizeof(UnconnectedPingStruct)) ||
+				((unsigned char)(data)[0]==ID_ADVERTISE_SYSTEM && length==sizeof(unsigned char)) ||
+				((unsigned char)(data)[0]==ID_SECURED_CONNECTION_CONFIRMATION && length==1+20+sizeof(RSA_BIT_SIZE))
+				))
+			{
+				// Cheater
+				Packet *packet = PacketPool::Instance()->GetPointer();
+				packet->data = new unsigned char[1];
+				packet->data[0]=ID_MODIFIED_PACKET;
+				packet->length=sizeof(char);
+				packet->bitSize=sizeof(char)*8;
+				packet->playerId=playerId;
+				packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
+				rakPeer->incomingQueueMutex.Lock();
+				rakPeer->incomingPacketQueue.push(packet);
+				rakPeer->incomingQueueMutex.Unlock();
+			}
+			
 		}
 	}
 	else
@@ -2778,45 +2780,50 @@
 			if (rakPeer->GetNumberOfIncomingConnections() >= rakPeer->GetMaximumIncomingConnections())
 			{
 				unsigned char c = ID_NO_FREE_INCOMING_CONNECTIONS;
-				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
-			else if (rakPeer->securedConnectionByteSize==0)
+			char *password = data + sizeof(unsigned char);
+			int passwordLength = length - sizeof(unsigned char);
+			if (rakPeer->IsBanned(rakPeer->PlayerIDToDottedIP(playerId)))
 			{
-				char *password = data + sizeof(unsigned char);
-				int passwordLength = length - sizeof(unsigned char);
-				if (rakPeer->IsBanned(rakPeer->PlayerIDToDottedIP(playerId)))
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_CONNECTION_BANNED;
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
+			}
+			else if (rakPeer->incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &&
+				memcmp(password, rakPeer->incomingPasswordBitStream.GetData(), passwordLength)==0)
+			{
+				if (rakPeer->usingSecurity==false)
 				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_CONNECTION_BANNED;
-					SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
-				}
-				else if (rakPeer->incomingPasswordBitStream.GetNumberOfBytesUsed()==passwordLength &&
-					memcmp(password, rakPeer->incomingPasswordBitStream.GetData(), passwordLength)==0)
-				{
+#ifdef _TEST_AES
+					unsigned char AESKey[16];
+					// Save the AES key
+					for (i=0; i < 16; i++)
+						AESKey[i]=i;
+					rakPeer->HandleConnectionRequest(playerId, AESKey, true);
+#else
 					// Connect this player assuming we have open slots
 					rakPeer->HandleConnectionRequest(playerId, 0, false);
+#endif
 				}
 				else
-				{
-					// This one we only send once since we don't care if it arrives.
-					unsigned char c = ID_INVALID_PASSWORD;
-					SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
-				}
+					rakPeer->SecuredConnectionResponse(playerId);
+				
 			}
 			else
 			{
-				rakPeer->SecuredConnectionResponse(playerId);
+				// This one we only send once since we don't care if it arrives.
+				unsigned char c = ID_INVALID_PASSWORD;
+				SocketLayer::Instance()->SendTo(rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 			}
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_RESPONSE &&
-			// 20 SHA1 + 1 packet header + 4 public key + sizeof(securedConnectionByteSize)
-			length >= 25 + sizeof(rakPeer->securedConnectionByteSize))
+			length==1+sizeof(big::u32) + sizeof(RSA_BIT_SIZE) + 20)
 		{
-			rakPeer->SecuredConnectionConfirmation(playerId, data, length);
+			rakPeer->SecuredConnectionConfirmation(playerId, data);
 		}
 		else if ((unsigned char)(data)[0]== ID_SECURED_CONNECTION_CONFIRMATION &&
-			// 20 Syn cookie + 1 packet header + 20 encoded random number
-			length >= 41)
+			length==1+20+sizeof(RSA_BIT_SIZE))
 		{
 			CSHA1 sha1;
 			bool confirmedHash, newRandomNumber;
@@ -2841,7 +2848,7 @@
 				confirmedHash=true;
 				newRandomNumber=true;
 			}
-			else if (rakPeer->randomNumberExpirationTime < getTime())
+			else if (rakPeer->randomNumberExpirationTime < RakNetGetTime())
 			{
 				sha1.Reset();
 				sha1.Update((unsigned char*)&playerId.binaryAddress, sizeof(playerId.binaryAddress));
@@ -2855,20 +2862,18 @@
 
 			if (confirmedHash)
 			{
-				mpuint source,result;
 				int i;
 				unsigned char AESKey[16];
+				RSA_BIT_SIZE message,encryptedMessage;
 
 				// On connection accept, AES key is c2s RSA_Decrypt(random number) XOR s2c syn-cookie
 				// Get the random number first
-				source.Init(rakPeer->securedConnectionByteSize);
-				result.Init(rakPeer->securedConnectionByteSize);
-				memcpy(source.value, data+1+20, rakPeer->securedConnectionByteSize);
-				EncryptDecrypt(result, source, rakPeer->d, rakPeer->n);
+				memcpy(encryptedMessage, data+1+20, sizeof(RSA_BIT_SIZE));
+				rakPeer->rsacrypt.decrypt(encryptedMessage, message);
 
 				// Save the AES key
 				for (i=0; i < 16; i++)
-					AESKey[i]=data[1+i] ^ ((unsigned char*)(result.value))[i];
+					AESKey[i]=data[1+i] ^ ((unsigned char*)(message))[i];
 
 				// Connect this player assuming we have open slots
 				rakPeer->HandleConnectionRequest(playerId,AESKey, true);
@@ -2882,34 +2887,50 @@
 		{
 			 // Make sure this connection accept is from someone we wanted to connect to
 			bool requestedConnection;
-//			unsigned long time = getTime();
+//			unsigned long time = RakNetGetTime();
 			unsigned char AESKey[16];
 			bool setAESKey;
 			setAESKey=false;
-			requestedConnection=false;
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
-			for (i=0; i < rakPeer->requestedConnectionsList.size();i++)
+
+			if (rakPeer->allowConnectionResponseIPMigration==false)
 			{
-				if (rakPeer->requestedConnectionsList[i]->playerId==playerId)
+				requestedConnection=false;
+				if (rakPeer->threadSleepTimer>=0)
+					rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+				for (i=0; i < rakPeer->requestedConnectionsList.size();i++)
 				{
-					// We did request this connection
-					requestedConnection=true;
-					setAESKey=rakPeer->requestedConnectionsList[i]->setAESKey;
-					if (setAESKey)
-						memcpy(AESKey, rakPeer->requestedConnectionsList[i]->AESKey, 16);
-					delete rakPeer->requestedConnectionsList[i];
-					rakPeer->requestedConnectionsList.del(i);
-					break;
+					if (rakPeer->requestedConnectionsList[i]->playerId==playerId)
+					{
+						// We did request this connection
+						requestedConnection=true;
+						setAESKey=rakPeer->requestedConnectionsList[i]->setAESKey;
+						if (setAESKey)
+							memcpy(AESKey, rakPeer->requestedConnectionsList[i]->AESKey, 16);
+						delete rakPeer->requestedConnectionsList[i];
+						rakPeer->requestedConnectionsList.del(i);
+						break;
+					}
 				}
+				if (rakPeer->threadSleepTimer>=0)
+					rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
 			}
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			else
+				requestedConnection=true; // Don't bother checking who replied			
 
 			 if (requestedConnection)
 			 {
 				// Find a free remote system struct to use
 				ConnectionAcceptStruct* cas = (ConnectionAcceptStruct*) data;
 				playerId.port=cas->remotePort;
+
+#ifdef _TEST_AES
+				// Save the AES key
+				for (i=0; i < 16; i++)
+					AESKey[i]=i;
+				remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, AESKey,true);
+#else
 				remoteSystem=rakPeer->AssignPlayerIDToRemoteSystemList(playerId, AESKey,setAESKey);
+#endif
 
 				if (remoteSystem!=0)
 				{
@@ -2923,9 +2944,9 @@
 					// Create a new nonblocking socket
 					remoteSystem->reliabilityLayer.SetSocket(SocketLayer::Instance()->CreateBoundSocket(rakPeer->myPlayerId.port, false));
 
-					SocketLayer::Instance()->Connect(remoteSystem->reliabilityLayer.GetSocket(), playerId);
+					SocketLayer::Instance()->Connect(remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port);
 					// Associate our new socket with a completion port and do the first read
-					b=SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(remoteSystem->reliabilityLayer.GetSocket(), playerId, rakPeer);
+					b=SocketLayer::Instance()->AssociateSocketWithCompletionPortAndRead(remoteSystem->reliabilityLayer.GetSocket(), playerId.binaryAddress, playerId.port, rakPeer);
 					//client->//reliabilityLayerMutex.Unlock();
 
 					if (b==false) // Some damn completion port error... windows is so unreliable
@@ -2939,11 +2960,13 @@
 
 					// Send the connection request complete to the game
 					Packet *packet = PacketPool::Instance()->GetPointer();
-					packet->data = new char[1];
-					packet->data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
-					packet->length=sizeof(char);
-					packet->bitSize=sizeof(char)*8;
+					packet->data = new unsigned char[sizeof(ConnectionAcceptStruct)];
+					memcpy(packet->data, data, sizeof(ConnectionAcceptStruct));
+					// packet->data[0]=ID_CONNECTION_REQUEST_ACCEPTED;
+					packet->length=sizeof(ConnectionAcceptStruct);
+					packet->bitSize=sizeof(ConnectionAcceptStruct)*8;
 					packet->playerId=playerId;
+					packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
 
 					#ifdef _DEBUG
 					assert(packet->data);
@@ -2956,7 +2979,7 @@
 					newIncomingConnectionStruct.typeId=ID_NEW_INCOMING_CONNECTION;
 					newIncomingConnectionStruct.externalID=playerId;
 
-					rakPeer->Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), HIGH_PRIORITY, RELIABLE, 0, playerId, false);
+					rakPeer->Send((char*)&newIncomingConnectionStruct, sizeof(newIncomingConnectionStruct), SYSTEM_PRIORITY, RELIABLE, 0, playerId, false);
 					rakPeer->Ping(playerId);
 					rakPeer->SendStaticData(playerId);
 				}
@@ -2964,7 +2987,7 @@
 				{
 					// Cancel the connection attempt
 					char c = ID_DISCONNECTION_NOTIFICATION;
-					SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId);
+					SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*)&c, sizeof(char), playerId.binaryAddress, playerId.port);
 				}
 			}
 			 else
@@ -2974,26 +2997,48 @@
 #endif
 			 }
 		 }
-		 else if ((unsigned char)(data)[0]== ID_PING && length==sizeof(UnconnectedPingStruct))
+		 else if (((unsigned char)(data)[0]==ID_PING || (unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS)
+			 && length==sizeof(UnconnectedPingStruct))
 		 {
+			 if ((unsigned char)(data)[0]==ID_PING_OPEN_CONNECTIONS && rakPeer->GetMaximumIncomingConnections()==0)
+				 return; // Sender wanted to get replies only for systems accepting connections
 			 data[0]=ID_PONG;
-			 SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, data, sizeof(UnconnectedPingStruct), playerId);
+			 RakNet::BitStream tempBitStream(sizeof(UnconnectedPingStruct));
+			 tempBitStream.Write(data, sizeof(UnconnectedPingStruct));
+			 rakPeer->rakPeerMutexes[RakPeer::offlinePingResponse_Mutex].Lock();
+			 tempBitStream.Write((char*)rakPeer->offlinePingResponse.GetData(), rakPeer->offlinePingResponse.GetNumberOfBytesUsed());
+			 rakPeer->rakPeerMutexes[RakPeer::offlinePingResponse_Mutex].Unlock();
+			 SocketLayer::Instance()->SendTo( rakPeer->connectionSocket, (char*) tempBitStream.GetData(), tempBitStream.GetNumberOfBytesUsed(), playerId.binaryAddress, playerId.port);
 		 }
-		 else if ((unsigned char)(data)[0]== ID_PONG && length==sizeof(UnconnectedPingStruct))
+		 else if ((unsigned char)(data)[0]==ID_ADVERTISE_SYSTEM && length==sizeof(unsigned char))
 		 {
+			 // Push this up to the game
 			 Packet *packet = PacketPool::Instance()->GetPointer();
+			 packet->data = new unsigned char [1 * sizeof(unsigned char)];
+			 packet->data[0]=ID_ADVERTISE_SYSTEM;
+			 packet->length=1 * sizeof(unsigned char);
+			 packet->bitSize=8 * sizeof(unsigned char);
+			 rakPeer->incomingQueueMutex.Lock();
+			 (rakPeer->incomingPacketQueue).push(packet);
+			 rakPeer->incomingQueueMutex.Unlock();
+		 }			 
+		 else if ((unsigned char)(data)[0]== ID_PONG && length>=sizeof(UnconnectedPingStruct))
+		 {
+			 Packet *packet = PacketPool::Instance()->GetPointer();
+			 unsigned long time;
 
-			 packet->data = new char [sizeof(UnconnectedPingStruct)];
-			 unsigned long time;
+			 // Write ID_PONG, then the time, then the unconnected data
+			 packet->data = new unsigned char [length];
+			 memcpy(packet->data, data, length);
+
 			 memcpy((char*)&time, data+sizeof(unsigned char), sizeof(unsigned long));
-			 time = getTime() - time;
-			 packet->data[0]=ID_PONG;
+			 time = RakNetGetTime() - time;
 			 memcpy(packet->data+sizeof(unsigned char), (char*)&time, sizeof(unsigned long));
 			 
-			 packet->length=sizeof(UnconnectedPingStruct);
-			 packet->bitSize=sizeof(UnconnectedPingStruct) * 8;
-
+			 packet->length=length;
+			 packet->bitSize=packet->length * 8;
 			 packet->playerId=playerId;
+			 packet->playerIndex=(PlayerIndex)rakPeer->GetIndexFromPlayerID(playerId);
 
 			 rakPeer->incomingQueueMutex.Lock();
 			 (rakPeer->incomingPacketQueue).push(packet);
@@ -3002,7 +3047,7 @@
 		 else if ((unsigned char)(data)[0]==ID_NO_FREE_INCOMING_CONNECTIONS && length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
-			 packet->data = new char [1 * sizeof(unsigned char)];
+			 packet->data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet->data[0]=ID_NO_FREE_INCOMING_CONNECTIONS;
 			 packet->length=1 * sizeof(unsigned char);
 			 packet->bitSize=8 * sizeof(unsigned char);
@@ -3013,7 +3058,7 @@
 		 else if ((unsigned char)(data)[0]==ID_CONNECTION_BANNED && length==sizeof(unsigned char))
 		 {
 			 Packet *packet = PacketPool::Instance()->GetPointer();
-			 packet->data = new char [1 * sizeof(unsigned char)];
+			 packet->data = new unsigned char [1 * sizeof(unsigned char)];
 			 packet->data[0]=ID_CONNECTION_BANNED;
 			 packet->length=1 * sizeof(unsigned char);
 			 packet->bitSize=8 * sizeof(unsigned char);
@@ -3024,380 +3069,457 @@
 	}
 }
 // --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-#ifdef _WIN32
-unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
-#else
-void*  UpdateNetworkLoop( void*  arguments )
-#endif
+bool RakPeer::RunUpdateCycle(void)
 {
-	RakPeer *rakPeer = (RakPeer *)arguments;
-	RakPeer::RemoteSystemStruct* remoteSystemList=rakPeer->remoteSystemList;
 	RakPeer::RemoteSystemStruct* remoteSystem;
 	unsigned remoteSystemIndex;
 	Packet *packet;
 	long ping, lastPing;
-	bool anyPeersActive;
-	int currentSentBytes,currentReceivedBytes,lastSentBytes,lastReceivedBytes;
-	unsigned long time,nextReadBytesTime;
+//	int currentSentBytes,currentReceivedBytes;
 	unsigned numberOfBytesUsed;
 	unsigned numberOfBitsUsed;
 	//PlayerID authoritativeClientPlayerId;
-	BitStream dataBitStream(MAXIMUM_MTU_SIZE);
 	int bitSize, byteSize;
 	char *data;
-	unsigned short maximumNumberOfPeers;
+	int errorCode;
+	bool gotData;
+	unsigned long time;
 
-	// For histogram statistics
-	lastSentBytes=lastReceivedBytes=0;
-	nextReadBytesTime=0;
+	do
+	{
+		// Read a packet
+		gotData=SocketLayer::Instance()->RecvFrom(connectionSocket, this, &errorCode);
 
-	maximumNumberOfPeers = rakPeer->maximumNumberOfPeers;
+		if (gotData==false)
+		{
 
-	rakPeer->isMainLoopThreadActive=true;
+#ifdef _WIN32
+			if (errorCode==WSAECONNRESET)
+			{
+				PushPortRefused(UNASSIGNED_PLAYER_ID);
+				//closesocket(peer->connectionSocket);
 
-	while(rakPeer->endThreads==false)
-	{
-		// We calculate this from the lowest numerical player ID
-		//authoritativeClientPlayerId=UNASSIGNED_PLAYER_ID;
+				//peer->connectionSocket = SocketLayer::Instance()->CreateBoundSocket(peer->myPlayerId.port, true);
+			}
+			else if (errorCode!=0 && endThreads==false)
+			{
+#ifdef _DEBUG
+				printf("Server RecvFrom critical failure!\n");
+#endif
+				// Some kind of critical error
+				//	peer->isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#else
+			if (errorCode==-1)
+			{
+				//	isRecvfromThreadActive=false;
+				endThreads=true;
+				Disconnect(0L);
+				return false;
+			}
+#endif
+		}
+		if (endThreads)
+			return false;
+	} while (gotData); // Read until there is nothing left
 
-		// Get the current system time
-		time = getTime();
+	time = RakNetGetTime();
 
-		anyPeersActive=false;
-
-		// Update the requested connection list.
-		if (rakPeer->requestedConnectionsList.size()>0)
+	// Update the requested connection list.
+	if (requestedConnectionsList.size()>0)
+	{
+		remoteSystemIndex=0;
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
+		while (remoteSystemIndex < requestedConnectionsList.size())
 		{
-			remoteSystemIndex=0;
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Lock();
-			while (remoteSystemIndex < rakPeer->requestedConnectionsList.size())
+			// After X seconds give up
+			if (time - requestedConnectionsList[remoteSystemIndex]->time > SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION*2)
 			{
-				// After X seconds give up
-				if (time - rakPeer->requestedConnectionsList[remoteSystemIndex]->time > SYN_COOKIE_OLD_RANDOM_NUMBER_DURATION)
-				{
-                    delete rakPeer->requestedConnectionsList[remoteSystemIndex];
-					rakPeer->requestedConnectionsList.del(remoteSystemIndex);
-				}
-				else if (time > rakPeer->requestedConnectionsList[remoteSystemIndex]->nextRequestTime)
-				{
-					rakPeer->SendConnectionRequest(
-						rakPeer->PlayerIDToDottedIP(rakPeer->requestedConnectionsList[remoteSystemIndex]->playerId),
-						rakPeer->requestedConnectionsList[remoteSystemIndex]->playerId.port);
+				delete requestedConnectionsList[remoteSystemIndex];
+				requestedConnectionsList.del(remoteSystemIndex);
+			}
+			else if (time > requestedConnectionsList[remoteSystemIndex]->nextRequestTime)
+			{
+				SendConnectionRequest(
+					PlayerIDToDottedIP(requestedConnectionsList[remoteSystemIndex]->playerId),
+					requestedConnectionsList[remoteSystemIndex]->playerId.port);
 
-					// Send again 2 seconds later
-					rakPeer->requestedConnectionsList[remoteSystemIndex]->nextRequestTime=time + 2000;
-					remoteSystemIndex++;
-				}
-				else
-					remoteSystemIndex++;
+				// Send again 2 seconds later
+				requestedConnectionsList[remoteSystemIndex]->nextRequestTime=time + 2000;
+				remoteSystemIndex++;
 			}
-			rakPeer->rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+			else
+				remoteSystemIndex++;
 		}
+		if (threadSleepTimer>=0)
+			rakPeerMutexes[RakPeer::requestedConnections_MUTEX].Unlock();
+	}
 
-		for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
+	for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
+	{
+		if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
 		{
-			if (remoteSystemList[remoteSystemIndex].playerId!=UNASSIGNED_PLAYER_ID)
+			// Found an active remote system
+			remoteSystem = remoteSystemList+remoteSystemIndex;
+			// Update is only safe to call from the same thread that calls HandleSocketReceiveFromConnectedPlayer,
+			// which is this thread
+			remoteSystem->reliabilityLayer.Update(connectionSocket, remoteSystem->playerId, MTUSize, time);
+
+			// Was the reliability layer unable to deliver a reliable packet?
+			if (remoteSystem->reliabilityLayer.IsDeadConnection())
 			{
-				// Found an active remote system
-				remoteSystem = remoteSystemList+remoteSystemIndex;
-				remoteSystem->reliabilityLayer.Update(rakPeer->connectionSocket, remoteSystem->playerId, rakPeer->MTUSize);
+				packet = PacketPool::Instance()->GetPointer();
 
-				anyPeersActive=true;
+				packet->data = new unsigned char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
+				packet->data[0]=ID_CONNECTION_LOST;
+				memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
 
-				// Was the reliability layer unable to deliver a reliable packet?
-				if (remoteSystem->reliabilityLayer.IsDeadConnection())
-				{
-					packet = PacketPool::Instance()->GetPointer();
+				packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
+				packet->bitSize=(sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()) * 8;
+				packet->playerId=remoteSystem->playerId;
+				packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					packet->data = new char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
-					packet->data[0]=ID_CONNECTION_LOST;
-					memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
-					packet->bitSize=(sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()) * 8;
+				CloseConnection(remoteSystem->playerId, false, 0L);
+				continue;
+			}
 
-					packet->playerId=remoteSystem->playerId;
+			// Did the reliability layer detect a modified packet?
+			if (remoteSystem->reliabilityLayer.IsCheater())
+			{
+				packet = PacketPool::Instance()->GetPointer();
+				packet->length=1;
+				packet->data = new unsigned char [1];
+				packet->data[0] = (unsigned char)ID_MODIFIED_PACKET;
+				packet->playerId=remoteSystem->playerId;
+				packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-					rakPeer->incomingQueueMutex.Lock();
-					(rakPeer->incomingPacketQueue).push(packet);
-					rakPeer->incomingQueueMutex.Unlock();
+				incomingQueueMutex.Lock();
+				(incomingPacketQueue).push(packet);
+				incomingQueueMutex.Unlock();
 
-					rakPeer->CloseConnection(remoteSystem->playerId, false);
-					continue;
-				}
+				continue;
+			}
 
-				// Did the reliability layer detect a modified packet?
-				if (remoteSystem->reliabilityLayer.IsCheater())
-				{
-					packet = PacketPool::Instance()->GetPointer();
-					packet->length=1;
-					packet->data = new char [1];
-					packet->data[0] = (unsigned char)ID_MODIFIED_PACKET;
-					packet->playerId=remoteSystem->playerId;
+			// Ping this guy if it is time to do so
+			if (time > remoteSystem->nextPingTime && (occasionalPing || remoteSystem->lowestPing==-1))
+			{
+				remoteSystem->nextPingTime = time + 5000;
+				Ping(remoteSystem->playerId);
+			}
 
-					rakPeer->incomingQueueMutex.Lock();
-					(rakPeer->incomingPacketQueue).push(packet);
-					rakPeer->incomingQueueMutex.Unlock();
+			// Find whoever has the lowest player ID
+			//if (remoteSystem->playerId < authoritativeClientPlayerId)
+			//	authoritativeClientPlayerId=remoteSystem->playerId;
 
-					continue;
-				}
+			// Does the reliability layer have any packets waiting for us?
+			// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+			bitSize = remoteSystem->reliabilityLayer.Receive(&data);
 
-				if (rakPeer->occasionalPing)
+			while (bitSize > 0)
+			{
+				// Put the input through compression if necessary
+				if (inputTree)
 				{
-					// Ping this guy if it is time to do so
-					if (time > remoteSystem->nextPingTime)
+					RakNet::BitStream dataBitStream(MAXIMUM_MTU_SIZE);
+					// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
+					// larger data block.  It's slow, but the user should have known that anyway
+					dataBitStream.Reset();
+					dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
+					numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
+					numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
+					rawBytesReceived+=numberOfBytesUsed;
+					// Decompress the input data.
+
+#ifdef _DEBUG
+					assert(numberOfBitsUsed>0);
+#endif
+					unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
+					memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
+					dataBitStream.Reset();
+					inputTree->DecodeArray(dataCopy,numberOfBitsUsed, &dataBitStream);
+					compressedBytesReceived+=dataBitStream.GetNumberOfBytesUsed();
+					delete [] dataCopy;
+
+					byteSize = dataBitStream.GetNumberOfBytesUsed();
+					if (byteSize > BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
 					{
-						remoteSystem->nextPingTime = time + 5000;
-						rakPeer->Ping(remoteSystem->playerId);
+						delete [] data;
+						data = new char [byteSize];
 					}
+					memcpy(data, dataBitStream.GetData(), byteSize);
 				}
+				else
+					// Fast and easy - just use the data that was returned
+					byteSize = BITS_TO_BYTES(bitSize);
 
-				// Find whoever has the lowest player ID
-				//if (remoteSystem->playerId < authoritativeClientPlayerId)
-				//	authoritativeClientPlayerId=remoteSystem->playerId;
+				// Read any system packets
+				if ((unsigned char)data[0]==ID_PONG && byteSize==sizeof(PingStruct))
+				{
+					// Copy into the ping times array the current time - the value returned
+					// First extract the sent ping
+					PingStruct *ps = (PingStruct *)data;
 
-				// Does the reliability layer have any packets waiting for us?
-				bitSize = remoteSystem->reliabilityLayer.Receive(&data);
+					ping=time - ps->sendPingTime;
+					lastPing = remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime;
 
-				while (bitSize > 0)
-				{
-					// Put the input through compression if necessary
-					if (rakPeer->inputTree)
+					// Ignore super high spikes in the average
+					if (lastPing <= 0 || (((int)ping < (lastPing * 3)) && ping < 1200))
 					{
-						// Since we are decompressing input, we need to copy to a bitstream, decompress, then copy back to a probably
-						// larger data block.  It's slow, but the user should have known that anyway
-						dataBitStream.Reset();
-						dataBitStream.WriteAlignedBytes((unsigned char*)data, BITS_TO_BYTES(bitSize));
-						numberOfBytesUsed = dataBitStream.GetNumberOfBytesUsed();
-						numberOfBitsUsed = dataBitStream.GetNumberOfBitsUsed();
-						rakPeer->rawBytesRecieved+=numberOfBytesUsed;
-						// Decompress the input data.
-						if (rakPeer->inputTree)
-						{
-#ifdef _DEBUG
-							assert(numberOfBitsUsed>0);
-#endif
-							unsigned char *dataCopy = new unsigned char[numberOfBytesUsed];
-							memcpy(dataCopy, dataBitStream.GetData(), numberOfBytesUsed);
-							dataBitStream.Reset();
-							rakPeer->inputTree->DecodeArray(dataCopy,numberOfBitsUsed, &dataBitStream);
-							rakPeer->compressedBytesRecieved+=dataBitStream.GetNumberOfBytesUsed();
-							delete [] dataCopy;
-						}
-						byteSize = dataBitStream.GetNumberOfBytesUsed();
-						if (byteSize > BITS_TO_BYTES(bitSize)) // Probably the case - otherwise why decompress?
-						{
-							delete [] data;
-							data = new char [byteSize];
-						}
-						memcpy(data, dataBitStream.GetData(), byteSize);
+						remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
+						// Thanks to Chris Taylor (cat02e at fsu.edu) for the improved timestamping algorithm
+						remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].clockDifferential=ps->sendPongTime - (time + ps->sendPingTime) / 2;
+						if (remoteSystem->lowestPing==-1 ||  remoteSystem->lowestPing > ping)
+							remoteSystem->lowestPing = ping;
+						// Most packets should arrive by the ping time.
+						remoteSystem->reliabilityLayer.SetLostPacketResendDelay(ping*2);
+
+						if (++(remoteSystem->pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
+							remoteSystem->pingAndClockDifferentialWriteIndex=0;
 					}
-					else
-						// Fast and easy - just use the data that was returned
-						byteSize = BITS_TO_BYTES(bitSize);
 
-					// Read any system packets
-					if ((unsigned char)data[0]==ID_PONG && byteSize==sizeof(PingStruct))
-					{
-						// Copy into the ping times array the current time - the value returned
-						// First extract the sent ping
-						PingStruct *ps = (PingStruct *)data;
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_PING && byteSize==sizeof(PingStruct))
+				{
+					PingStruct *ps = (PingStruct*)data;
+					ps->typeId=ID_PONG;
+					ps->sendPongTime=RakNetGetTime();
 
-						ping=time - ps->sendPingTime;
-						lastPing = remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime;
+					Send(data,byteSize, SYSTEM_PRIORITY, UNRELIABLE, 0, remoteSystem->playerId, false);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION && byteSize==sizeof(NewIncomingConnectionStruct))
+				{
+					Ping(remoteSystem->playerId);
+					SendStaticData(remoteSystem->playerId);
 
-						// Ignore super high spikes in the average
-						if (lastPing <= 0 || (((int)ping < (lastPing * 3)) && ping < 1200))
-						{
-							remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].pingTime=(short)ping;
-							// Thanks to Chris Taylor (cat02e at fsu.edu) for the improved timestamping algorithm
-							remoteSystem->pingAndClockDifferential[remoteSystem->pingAndClockDifferentialWriteIndex].clockDifferential=ps->sendPongTime - (time + ps->sendPingTime) / 2;
-							if (remoteSystem->lowestPing==-1 ||  remoteSystem->lowestPing > ping)
-								remoteSystem->lowestPing = ping;
-							remoteSystem->reliabilityLayer.SetLostPacketResendDelay(ping * 6);
+					NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
+					remoteSystem->myExternalPlayerId=newIncomingConnectionStruct->externalID;
 
-							if (++(remoteSystem->pingAndClockDifferentialWriteIndex) == PING_TIMES_ARRAY_SIZE)
-								remoteSystem->pingAndClockDifferentialWriteIndex=0;
-						}
+					// Send this info down to the game
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length=byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-						delete [] data;
-					}
-					else if ((unsigned char)data[0]==ID_PING && byteSize==sizeof(PingStruct))
+#ifdef _DEBUG
+					assert(packet->data);
+#endif
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				/*
+				else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
+				{
+				if (byteSize>2)
+				{
+				packet = PacketPool::Instance()->GetPointer();
+				packet->data = data;
+				packet->length=byteSize;
+				packet->bitSize=bitSize;
+				packet->playerId=remoteSystem->playerId;
+
+				synchronizedMemoryQueueMutex.Lock();
+				synchronizedMemoryPacketQueue.push(packet);
+				synchronizedMemoryQueueMutex.Unlock();
+				}
+				else
+				delete [] data;
+				}
+				*/
+				else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
+				{
+					packet = PacketPool::Instance()->GetPointer();
+					if (remoteSystem->staticData.GetNumberOfBytesUsed()>0)
 					{
-						PingStruct *ps = (PingStruct*)data;
-						ps->typeId=ID_PONG;
-						ps->sendPongTime=getTime();
+						packet->data = new unsigned char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
+						packet->data[0]=ID_DISCONNECTION_NOTIFICATION;
+						memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
 
-						rakPeer->Send(data,byteSize, HIGH_PRIORITY, UNRELIABLE, 0, remoteSystem->playerId, false);
+						packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
+						packet->bitSize=sizeof(char)*8 + remoteSystem->staticData.GetNumberOfBitsUsed();
+
 						delete [] data;
 					}
-					else if ((unsigned char)data[0]==ID_NEW_INCOMING_CONNECTION && byteSize==sizeof(NewIncomingConnectionStruct))
+					else
 					{
-						rakPeer->Ping(remoteSystem->playerId);
-						rakPeer->SendStaticData(remoteSystem->playerId);
-
-						NewIncomingConnectionStruct *newIncomingConnectionStruct = (NewIncomingConnectionStruct *) data;
-						remoteSystem->myExternalPlayerId=newIncomingConnectionStruct->externalID;
-
-						// Send this info down to the game
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length=byteSize;
+						packet->data=(unsigned char*)data;
 						packet->bitSize=bitSize;
-						packet->playerId=remoteSystem->playerId;
-
-#ifdef _DEBUG
-						assert(packet->data);
-#endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
+						packet->length=1;
 					}
-					/*
-					else if ((unsigned char)data[0]==ID_SYNCHRONIZE_MEMORY)
-					{
-						if (byteSize>2)
-						{
-							packet = PacketPool::Instance()->GetPointer();
-							packet->data = data;
-							packet->length=byteSize;
-							packet->bitSize=bitSize;
-							packet->playerId=remoteSystem->playerId;
 
-							rakPeer->synchronizedMemoryQueueMutex.Lock();
-							rakPeer->synchronizedMemoryPacketQueue.push(packet);
-							rakPeer->synchronizedMemoryQueueMutex.Unlock();
-						}
-						else
-							delete [] data;
-					}
-					*/
-					else if ((unsigned char)data[0]==ID_DISCONNECTION_NOTIFICATION)
-					{
-						packet = PacketPool::Instance()->GetPointer();
-						if (remoteSystem->staticData.GetNumberOfBytesUsed()>0)
-						{
-							packet->data = new char [sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed()];
-							packet->data[0]=ID_DISCONNECTION_NOTIFICATION;
-							memcpy(packet->data+sizeof(char), remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
-							packet->length=sizeof(char) + remoteSystem->staticData.GetNumberOfBytesUsed();
-							packet->bitSize=sizeof(char)*8 + remoteSystem->staticData.GetNumberOfBitsUsed();
+					CloseConnection(remoteSystem->playerId, false, 0L);
 
-							delete [] data;
-						}
-						else
-						{
-							packet->data=data;
-							packet->bitSize=bitSize;
-							packet->length=1;
-						}
-
-						packet->playerId=remoteSystem->playerId;
-
-						rakPeer->CloseConnection(remoteSystem->playerId, false);
-
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						// Relay this message to the game
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
+					// Relay this message to the game
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
 
-					}
-					else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
-					{
-						rakPeer->SendStaticData(remoteSystem->playerId);
-						delete [] data;
-					}
-					else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
-					{
-						remoteSystem->staticData.Reset();
-						remoteSystem->staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
+				}
+				else if ((unsigned char)data[0]==ID_REQUEST_STATIC_DATA)
+				{
+					SendStaticData(remoteSystem->playerId);
+					delete [] data;
+				}
+				else if ((unsigned char)data[0] == ID_RECEIVED_STATIC_DATA)
+				{
+					remoteSystem->staticData.Reset();
+					remoteSystem->staticData.Write((char*)data+sizeof(unsigned char), byteSize-1);
 
-						// Inform game server code that we got static data
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length = byteSize;
-						packet->bitSize=bitSize;
-						packet->playerId = remoteSystem->playerId;
+					// Inform game server code that we got static data
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length = byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId = remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
-					}
-					else if ((unsigned char)data[0] == ID_RPC || (unsigned char)data[0] == ID_RPC_WITH_TIMESTAMP)
-					{
-						rakPeer->HandleRPCPacket(data, byteSize, remoteSystem->playerId);
-						delete [] data;
-					}
-					else
-					{
-						packet = PacketPool::Instance()->GetPointer();
-						packet->data = data;
-						packet->length=byteSize;
-						packet->bitSize=bitSize;
-						packet->playerId=remoteSystem->playerId;
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
+				else
+				{
+					packet = PacketPool::Instance()->GetPointer();
+					packet->data = (unsigned char*)data;
+					packet->length=byteSize;
+					packet->bitSize=bitSize;
+					packet->playerId=remoteSystem->playerId;
+					packet->playerIndex=(PlayerIndex)remoteSystemIndex;
 
 #ifdef _DEBUG
-						assert(packet->data);
+					assert(packet->data);
 #endif
-						rakPeer->incomingQueueMutex.Lock();
-						rakPeer->incomingPacketQueue.push(packet);
-						rakPeer->incomingQueueMutex.Unlock();
-					}
+					incomingQueueMutex.Lock();
+					incomingPacketQueue.push(packet);
+					incomingQueueMutex.Unlock();
+				}
 
-					// Does the reliability layer have any more packets waiting for us?
-					bitSize = remoteSystem->reliabilityLayer.Receive(&data);
-				}
+				// Does the reliability layer have any more packets waiting for us?
+				// To be thread safe, this has to be called in the same thread as HandleSocketReceiveFromConnectedPlayer
+				bitSize = remoteSystem->reliabilityLayer.Receive(&data);
 			}
 		}
+	}
 
 
-		// Statistics histogram
-		if (time > nextReadBytesTime)
+	/*
+	// Statistics histogram
+	if (time > nextReadBytesTime)
+	{
+		nextReadBytesTime = time + 1000L; // 1 second
+		for (remoteSystemIndex=0; remoteSystemIndex < maximumNumberOfPeers; ++remoteSystemIndex)
 		{
-			nextReadBytesTime = time + 1000L; // 1 second
-			currentSentBytes = rakPeer->GetBytesSent();
-			currentReceivedBytes = rakPeer->GetBytesReceived();
-			rakPeer->bytesSentPerSecond = currentSentBytes - lastSentBytes;
-			rakPeer->bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
-			lastSentBytes=currentSentBytes;
-			lastReceivedBytes=currentReceivedBytes;
-		}
+		currentSentBytes = GetBytesSent();
+		currentReceivedBytes = GetBytesReceived();
+		bytesSentPerSecond = currentSentBytes - lastSentBytes;
+		bytesReceivedPerSecond = currentReceivedBytes - lastReceivedBytes;
+		lastSentBytes=currentSentBytes;
+		lastReceivedBytes=currentReceivedBytes;
+	}
+	*/
 
-		// Context switch so other threads can run
-		if (rakPeer->threadPriority==0)
+	return true;
+}
+// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+#ifdef _WIN32
+unsigned __stdcall UpdateNetworkLoop(LPVOID arguments)
+#else
+void*  UpdateNetworkLoop( void*  arguments )
+#endif
+{
+	RakPeer *rakPeer = (RakPeer *)arguments;
+//	unsigned long time;
+
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()->IncreaseUserCount();
+#endif
+
+	rakPeer->isMainLoopThreadActive=true;
+
+	while(rakPeer->endThreads==false)
+	{
+		/*
+		time=RakNetGetTime();
+
+		// Dynamic threading - how long we sleep and if we update
+		// depends on whether or not the user thread is updating
+		if (time > rakPeer->lastUserUpdateCycle && time - rakPeer->lastUserUpdateCycle > UPDATE_THREAD_UPDATE_TIME)
 		{
-			#ifdef _WIN32
-			Sleep(15);
-			#else
-			usleep(15 * 1000);
-			#endif
+			// Only one thread should call RunUpdateCycle at a time.  We don't need to delay calls so
+			// a mutex on the function is not necessary - only on the variable that indicates if the function is
+			// running
+			rakPeer->RunMutexedUpdateCycle();
+			
+
+			// User is not updating the network.  Sleep a short time
+#ifdef _WIN32
+				Sleep(rakPeer->threadSleepTimer);
+#else
+				usleep(rakPeer->threadSleepTimer * 1000);
+#endif
 		}
-		else if (rakPeer->threadPriority==1)
+		else
 		{
+			// User is actively updating the network.  Only occasionally poll
 #ifdef _WIN32
-			Sleep(0);
+			Sleep(UPDATE_THREAD_POLL_TIME);
 #else
-			usleep(0 * 1000);
+			usleep(UPDATE_THREAD_POLL_TIME * 1000);
 #endif
 		}
-
-		if (anyPeersActive==false)		
-		{
+		*/
+		rakPeer->RunUpdateCycle();
 #ifdef _WIN32
-			Sleep(30);
+		Sleep(rakPeer->threadSleepTimer);
 #else
-			usleep(30 * 1000);
+		usleep(rakPeer->threadSleepTimer * 1000);
 #endif
-		}
 	}
 	rakPeer->isMainLoopThreadActive=false;
 
+#ifdef __USE_IO_COMPLETION_PORTS
+	AsynchronousFileIO::Instance()->DecreaseUserCount();
+#endif
+
+
 	return 0;
 }
+
+/*
+void RakPeer::RunMutexedUpdateCycle(void)
+{
+	rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+	if (updateCycleIsRunning==false)
+	{
+		updateCycleIsRunning=true;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+		RunUpdateCycle(); // Do one update per call to Receive
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Lock();
+		updateCycleIsRunning=false;
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+	}
+	else
+		rakPeerMutexes[RakPeer::updateCycleIsRunning_Mutex].Unlock();
+}
+*/

Modified: trunk/source/libraries/raknet/RakPeer.h
===================================================================
--- trunk/source/libraries/raknet/RakPeer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakPeer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -14,7 +14,8 @@
 #include "RakPeerInterface.h"
 #include "BinarySearchTree.h"
 #include "RPCNode.h"
-#include "MPUInt.h"
+#include "RSACrypt.h"
+#include "BitStream.h"
 
 class HuffmanEncodingTree;
 
@@ -42,11 +43,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority);
+	bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer);
 
 	// Description:
 	// Must be called while offline
@@ -58,15 +59,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *pubKeyP, char *pubKeyQ, char *privKeyE, char *privKeyN);
 
 	// Description
 	// Must be called while offline
@@ -98,13 +97,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -120,7 +119,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// Description:
 	// Returns true if the network threads are running
@@ -145,14 +148,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
-	bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -207,13 +210,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -224,7 +227,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	void CloseConnection(PlayerID target, bool sendDisconnectionNotification);
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration);
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -297,9 +302,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	void Ping(char* host, unsigned short remotePort);
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections);
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -323,7 +329,7 @@
 	int GetLowestPing(PlayerID target) const;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -383,7 +389,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	BitStream* GetRemoteStaticData(PlayerID playerId);
+	RakNet::BitStream * GetRemoteStaticData(PlayerID playerId);
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -404,6 +410,13 @@
 	// target: Who to send your static data to.  Specify UNASSIGNED_PLAYER_ID to broadcast to all
 	void SendStaticData(PlayerID target);
 
+	// Description:
+	// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	void SetOfflinePingResponse(char *data, const unsigned long length);
+
 	// --------------------------------------------------------------------------------------------
 	// Network Functions - Functions dealing with the network in general
 	// --------------------------------------------------------------------------------------------
@@ -463,9 +476,37 @@
 	const char* PlayerIDToDottedIP(PlayerID playerId) const;
 
 	// Description:
+	// Converts a dotted IP to a playerId
+	//
+	// Parameters:
+	// host: [input] Either a dotted IP address or a domain name
+	// remotePort: [input] Which port to connect to on the remote machine.
+	// playerId: [output] The result of this operation
+	void IPToPlayerID(const char* host, unsigned short remotePort, PlayerID *playerId);
+
+	// Description:
 	// Returns an IP address at index 0 to GetNumberOfAddresses-1
 	const char* GetLocalIP(unsigned int index);
 
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	void AllowConnectionResponseIPMigration(bool allow);
+
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// Requires:
+	// The sender and recipient must already be started via a successful call to Initialize
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	void AdvertiseSystem(char *host, unsigned short remotePort);
+
 	// --------------------------------------------------------------------------------------------
 	// Compression Functions - Functions related to the compression layer
 	// --------------------------------------------------------------------------------------------
@@ -554,29 +595,25 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	double GetPacketlossPercentile(void) const; // The average outgoing packetloss percentile
-	unsigned long GetTransmittedPacketCount(void) const; // How many packets were sent
-	unsigned long GetTransmittedFrameCount(void) const; // How many frames were sent	
-	unsigned long GetLostPacketCount(void) const; // How many packets were lost
-	unsigned long GetReceivedPacketCount(void) const; // How many packets were received
-	unsigned long GetBytesSent(void) const; // How many bytes have been sent.
-	unsigned long GetBytesReceived(void) const; // How many bytes have been received.
-	unsigned long GetUnacknowledgedSentPacketListSize(void) const; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void) const; // Returns the size of the flow control window, in packets.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void) const; // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId) const; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
 
 protected:
 
 #ifdef _WIN32
-	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
+//	friend unsigned __stdcall RecvFromNetworkLoop(LPVOID arguments);
 	friend void __stdcall ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend unsigned __stdcall UpdateNetworkLoop(LPVOID arguments);
 #else
-	friend void*  RecvFromNetworkLoop( void*  arguments );
+//	friend void*  RecvFromNetworkLoop( void*  arguments );
 	friend void ProcessNetworkPacket(unsigned long binaryAddress, unsigned short port, char *data, int length, RakPeer *rakPeer);
 	friend void*  UpdateNetworkLoop( void*  arguments );
 #endif
@@ -596,15 +633,13 @@
 		int pingAndClockDifferentialWriteIndex; // The index we are writing into the pingAndClockDifferential circular buffer
 		int lowestPing;
 		unsigned long nextPingTime; // When to next ping this player
-		BitStream staticData;
+		RakNet::BitStream staticData;
 		unsigned long connectionTime;
 	};
 
 	void RecordConnectionAttempt(const char* host, unsigned short remotePort);
 	void RemoveFromRequestedConnectionsList(PlayerID playerId);
 	bool SendConnectionRequest(const char* host, unsigned short remotePort);
-	// Converts a dotted IP to a playerId
-	void IPToPlayerID(const char* host, unsigned short remotePort, PlayerID *playerId);
 	// Get the reliability layer associated with a playerID.  Returns 0 if none
 	RemoteSystemStruct *GetRemoteSystemFromPlayerID(PlayerID playerID) const;
 	// When we get a connection request from an ip / port, either accept or reject it
@@ -634,11 +669,12 @@
 	bool SetupIOCompletionPortSocket(int index);
 	#endif
 
-	bool endThreads, isMainLoopThreadActive, isRecvfromThreadActive; // Tracks thread states
+	bool endThreads, isMainLoopThreadActive;
+	// bool isRecvfromThreadActive; // Tracks thread states
 	bool occasionalPing; // Do we occasionally ping the other systems?
 	unsigned short maximumNumberOfPeers,maximumIncomingConnections;
 	// localStaticData necessary because we may not have a RemoteSystemStruct representing ourselves in the list
-	BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData;
+	RakNet::BitStream incomingPasswordBitStream, outgoingPasswordBitStream, localStaticData, offlinePingResponse;
 	PlayerID myPlayerId;
 
 	// This is an array of pointers to RemoteSystemStruct
@@ -654,17 +690,21 @@
 		incomingPasswordBitStream_Mutex,
 		outgoingPasswordBitStream_Mutex,
 		remoteSystemList_Mutex, // This mutex is a writer lock for reserving player IDs only
+//		updateCycleIsRunning_Mutex,
+		offlinePingResponse_Mutex,
 		NUMBER_OF_RAKPEER_MUTEXES
 	};
 	SimpleMutex rakPeerMutexes[NUMBER_OF_RAKPEER_MUTEXES];
 
+	// RunUpdateCycle is not thread safe but we don't need to mutex calls.  Just skip calls if it is running already
+	bool updateCycleIsRunning;
 
 	// The list of people we have tried to connect to recently
 	BasicDataStructures::Queue<RequestedConnectionStruct*> requestedConnectionsList;
 
 	// Data that both the client and the server needs
 	unsigned long bytesSentPerSecond, bytesReceivedPerSecond;
-	bool isSocketLayerBlocking;
+//	bool isSocketLayerBlocking;
 	//bool continualPing,isRecvfromThreadActive,isMainLoopThreadActive, endThreads, isSocketLayerBlocking;
 	unsigned long validationInteger;
 #ifdef _WIN32
@@ -694,25 +734,41 @@
 	// Compression stuff
 	unsigned long frequencyTable[256];
 	HuffmanEncodingTree *inputTree, *outputTree;
-	unsigned long rawBytesSent, rawBytesRecieved, compressedBytesSent, compressedBytesRecieved;
-	//void DecompressInput(BitStream *bitStream);
-	//void UpdateOutgoingFrequencyTable(BitStream* bitStream);
+	unsigned long rawBytesSent, rawBytesReceived, compressedBytesSent, compressedBytesReceived;
+	//void DecompressInput(RakNet::BitStream *bitStream);
+	//void UpdateOutgoingFrequencyTable(RakNet::BitStream * bitStream);
 	void GenerateSYNCookieRandomNumber(void);
 	void SecuredConnectionResponse(PlayerID playerId);
-	void SecuredConnectionConfirmation(PlayerID playerId, char* data, int length);
+	void SecuredConnectionConfirmation(PlayerID playerId, char* data);
+	bool RunUpdateCycle(void);
+	//void RunMutexedUpdateCycle(void);
 
 	BasicDataStructures::AVLBalancedBinarySearchTree<RPCNode> rpcTree;
 	int MTUSize;
 	bool trackFrequencyTable;
-	int threadPriority;
+	int threadSleepTimer;
 
 	SOCKET connectionSocket;
 
-	mpuint d,e,n;
-	unsigned short securedConnectionByteSize;
-	bool keysLocallyGenerated;
+	// Histogram statistics
+	//unsigned long nextReadBytesTime;
+	//int lastSentBytes,lastReceivedBytes;
+
+	// Encryption and security
+	big::RSACrypt<RSA_BIT_SIZE> rsacrypt;
+	big::u32 publicKeyP;
+	RSA_BIT_SIZE publicKeyQ;
+	bool keysLocallyGenerated, usingSecurity;
 	unsigned long randomNumberExpirationTime;
 	unsigned char newRandomNumber[20], oldRandomNumber[20];
+
+	// How long it has been since things were updated by a call to receive
+	// Update thread uses this to determine how long to sleep for
+	unsigned long lastUserUpdateCycle;
+
+	// True to allow connection accepted packets from anyone.  False to only allow these packets from servers
+	// we requested a connection to.
+	bool allowConnectionResponseIPMigration;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/RakPeerInterface.h
===================================================================
--- trunk/source/libraries/raknet/RakPeerInterface.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakPeerInterface.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -10,9 +10,10 @@
 #ifndef __RAK_PEER_INTERFACE_H
 #define __RAK_PEER_INTERFACE_H
 
-class BitStream;
 #include "PacketPriority.h"
 #include "NetworkTypes.h"
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakPeerInterface
 {
@@ -36,11 +37,11 @@
 	// - A pure client would set this to 1.  A pure server would set it to the number of allowed clients.
 	// - A hybrid would set it to the sum of both types of connections
 	// localPort: The port to listen for connections on.
-	// _threadPriority: 0 for regular priority (0-8 players), 1 for high priority (High performance applications), and 2 for ultra-high priority (MMO server)
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	//
 	// Returns:
 	// False on failure (can't create socket or thread), true on success.
-	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadPriority)=0;
+	virtual bool Initialize(unsigned short MaximumNumberOfPeers, unsigned short localPort,int _threadSleepTimer)=0;
 
 	// Description:
 	// Must be called while offline
@@ -52,15 +53,13 @@
 	// If you accept connections, you must call this or else secure connections will not be enabled
 	// for incoming connections.
 	// If you are connecting to another system, you can call this with values for the
-	// (e and n) public keys before connecting to prevent MitM
+	// (e and p,q) public keys before connecting to prevent MitM
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// pubKeyP, pubKeyQ - Public keys generated from the RSACrypt class.  See the Encryption sample
+	// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *pubKeyP, char *pubKeyQ, char *privKeyE, char *privKeyN)=0;
 
 	// Description
 	// Must be called while offline
@@ -92,13 +91,13 @@
 
 	// Description:
 	// Returns the password set by SetIncomingPassword in a BitStream
-	BitStream *GetIncomingPassword(void);
+	RakNet::BitStream *GetIncomingPassword(void);
 
 	// Description:
 	// Call this to connect to the specified host (ip or domain name) and server port.
 	// Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client.  Calling both acts as a true peer.
 	// This is a non-blocking connection.  You know the connection is successful when IsConnected() returns true
-	// or receive gets a packet with the type identifier ID_ENUMERATION_REPLY.  If the connection is not
+	// or receive gets a packet with the type identifier ID_CONNECTION_ACCEPTED.  If the connection is not
 	// successful, such as rejected connection or no response then neither of these things will happen.
 	// Requires that you first call Initialize
 	//
@@ -114,7 +113,11 @@
 
 	// Description:
 	// Stops the network threads and close all connections.  Multiple calls are ok.
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// Description:
 	// Returns true if the network threads are running
@@ -138,14 +141,14 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// - Packets are only ordered relative to other packets on the same stream
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// Returns:
 	// False if we are not connected to the specified recipient.  True otherwise
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
-	virtual bool Send(BitStream* bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream * bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Description:
 	// Gets a packet from the incoming packet queue. Use DeallocatePacket to deallocate the packet after you are done with it.
@@ -200,13 +203,13 @@
 	// bitStream: The bitstream to send
 	// priority: What priority level to send on.
 	// reliability: How reliability to send this data
-	// orderingStream: When using ordered or sequenced packets, what stream to order these on.
+	// orderingChannel: When using ordered or sequenced packets, what channel to order these on.
 	// broadcast - Send this packet to everyone.
 	// playerId: Who to send this packet to, or in the case of broadcasting who not to send it to.  Use UNASSIGNED_PLAYER_ID to specify none
 	// broadcast: True to send this packet to all connected systems.  If true, then playerId specifies who not to send the packet to.
 	// shiftTimestamp: True to treat the first 4 bytes as a timestamp and make it system relative on arrival (Same as ID_TIMESTAMP for a packet enumeration type)
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// --------------------------------------------------------------------------------------------
 	// Player Management Functions
@@ -217,7 +220,9 @@
 	// Parameters:
 	// target: Which connection to close
 	// sendDisconnectionNotification: True to send ID_DISCONNECTION_NOTIFICATION to the recipient.  False to close it silently.
-	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification)=0;
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notification probably won't arrive
+	virtual void CloseConnection(PlayerID target, bool sendDisconnectionNotification, unsigned long blockDuration)=0;
 
 	// Description:
 	// Given a playerID, returns an index from 0 to the maximum number of players allowed - 1.
@@ -290,9 +295,10 @@
 	// The sender and recipient must already be started via a successful call to Initialize
 	//
 	// Parameters:
-	// host: Either a dotted IP address or a domain name
+	// host: Either a dotted IP address or a domain name.  Can be 255.255.255.255 for LAN broadcast.
 	// remotePort: Which port to connect to on the remote machine.
-	virtual void Ping(char* host, unsigned short remotePort)=0;
+	// onlyReplyOnAcceptingConnections: Only request a reply if the remote system is accepting connections
+	virtual void Ping(char* host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections)=0;
 
 	// Description:
 	// Returns the average of all ping times read for a specified target
@@ -316,7 +322,7 @@
 	virtual int GetLowestPing(PlayerID target) const=0;
 
 	// Description:
-	// Ping the remote systems every so often.  This is on by default
+	// Ping the remote systems every so often.  This is off by default
 	// This will work anytime
 	//
 	// Parameters:
@@ -375,7 +381,7 @@
 	//
 	// Returns:
 	// The data passed to SetRemoteStaticData stored as a bitstream
-	virtual BitStream* GetRemoteStaticData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetRemoteStaticData(PlayerID playerId)=0;
 
 	// Description:
 	// All systems have a block of data associated with them, for user use.  This block of data can be used to easily
@@ -396,6 +402,13 @@
 	// target: Who to send your static data to.  Specify UNASSIGNED_PLAYER_ID to broadcast to all
 	virtual void SendStaticData(PlayerID target)=0;
 
+	// Description:
+	// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	virtual void SetOfflinePingResponse(char *data, const unsigned long length)=0;
+
 	// --------------------------------------------------------------------------------------------
 	// Network Functions - Functions dealing with the network in general
 	// --------------------------------------------------------------------------------------------
@@ -456,9 +469,34 @@
 	virtual const char* PlayerIDToDottedIP(PlayerID playerId) const=0;
 
 	// Description:
+	// Converts a dotted IP to a playerId
+	//
+	// Parameters:
+	// host: [input] Either a dotted IP address or a domain name
+	// remotePort: [input] Which port to connect to on the remote machine.
+	// playerId: [output] The result of this operation
+	virtual void IPToPlayerID(const char* host, unsigned short remotePort, PlayerID *playerId)=0;
+
+	// Description:
 	// Returns an IP address at index 0 to GetNumberOfAddresses-1
 	virtual const char* GetLocalIP(unsigned int index)=0;
 
+	// Description:
+	// Allow or disallow connection responses from any IP.  Normally this should be false, but may be necessary
+	// when connection to servers with multiple IP addresses.
+	//
+	// Parameters:
+	// allow - True to allow this behavior, false to not allow.  Defaults to false.  Value persists between connections
+	void AllowConnectionResponseIPMigration(bool allow);
+
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	virtual void AdvertiseSystem(char *host, unsigned short remotePort)=0;
+
 	// --------------------------------------------------------------------------------------------
 	// Compression Functions - Functions related to the compression layer
 	// --------------------------------------------------------------------------------------------
@@ -547,20 +585,16 @@
 	// Statistical Functions - Functions dealing with API performance
 	// --------------------------------------------------------------------------------------------
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void) const=0; // The average outgoing packetloss percentile
-	virtual unsigned long GetTransmittedPacketCount(void) const=0; // How many packets were sent
-	virtual unsigned long GetTransmittedFrameCount(void) const=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void) const=0; // How many packets were lost
-	virtual unsigned long GetReceivedPacketCount(void) const=0; // How many packets were received
-	virtual unsigned long GetBytesSent(void) const=0; // How many bytes have been sent.
-	virtual unsigned long GetBytesReceived(void) const=0; // How many bytes have been received.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void) const=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void) const=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void) const=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId) const=0; // Returns the time elapsed since this player connected
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/RakServer.cpp
===================================================================
--- trunk/source/libraries/raknet/RakServer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakServer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -28,9 +28,9 @@
 {
 }
 
-void RakServer::InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)
+void RakServer::InitializeSecurity(char *privKeyE, char *privKeyN)
 {
-	RakPeer::InitializeSecurity(numberOfBytes, RSAd, RSAe, RSAn);
+	RakPeer::InitializeSecurity(0,0, privKeyE, privKeyN);
 }
 
 void RakServer::DisableSecurity(void)
@@ -38,19 +38,17 @@
 	RakPeer::DisableSecurity();
 }
 
-bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)
+bool RakServer::Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)
 {
 	bool init;
 
-	if (highPriorityThreads)
-		init=RakPeer::Initialize(AllowedPlayers, port,1);
-	else
-		init=RakPeer::Initialize(AllowedPlayers, port,0);
+	RakPeer::Disconnect(30L);
 
+	init=RakPeer::Initialize(AllowedPlayers, port,threadSleepTimer);
 	RakPeer::SetMaximumIncomingConnections(AllowedPlayers);
 
 	// Random number seed
-	long time = getTime();
+	long time = RakNetGetTime();
 	seedMT(time);
 	seed=randomMT();
 	if (seed % 2 == 0) // Even
@@ -64,8 +62,15 @@
 
 void RakServer::SetPassword(char *_password)
 {
-	_password[19]=0; // Limit the password length
-	RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	if (_password)
+	{
+		_password[19]=0; // Limit the password length
+		RakPeer::SetIncomingPassword(_password, (int)strlen(_password)+1);
+	}
+	else
+	{
+		RakPeer::SetIncomingPassword(0, 0);
+	}
 }
 
 bool RakServer::HasPassword(void)
@@ -73,19 +78,19 @@
 	return GetIncomingPassword()->GetNumberOfBytesUsed() > 0;
 }
 
-void RakServer::Disconnect(void)
+void RakServer::Disconnect(unsigned long blockDuration)
 {
-	RakPeer::Disconnect();
+	RakPeer::Disconnect(blockDuration);
 }
 
-bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(data, length, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(data, length, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
-bool RakServer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)
+bool RakServer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)
 {
-	return RakPeer::Send(bitStream, priority, reliability, orderingStream, playerId, broadcast);
+	return RakPeer::Send(bitStream, priority, reliability, orderingChannel, playerId, broadcast);
 }
 
 Packet* RakServer::Receive(void)
@@ -95,7 +100,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() && occasionalPing)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time > broadcastPingsTime || (packet && packet->data[0]==ID_RECEIVED_STATIC_DATA))
 		{
 			if (time > broadcastPingsTime)
@@ -103,7 +108,7 @@
 
 			unsigned i, count;
 			RemoteSystemStruct *remoteSystem;
-			BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
+			RakNet::BitStream bitStream((sizeof(PlayerID) + sizeof(short)) * 32 + sizeof(unsigned char));
 			unsigned char typeId=ID_BROADCAST_PINGS;
 			bitStream.Write(typeId);
 			for (i=0, count=0; count < 32 && i < maximumNumberOfPeers; i++)
@@ -121,9 +126,9 @@
 			if (count>0) // If we wrote anything
 			{
 				if (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION) // If this was a new connection
-					Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false); // Send to the new connection
+					Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false); // Send to the new connection
 				else
-					Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
+					Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true); // Send to everyone
 			}
 		}
 	}
@@ -131,7 +136,7 @@
 	// This is just a regular time based update.  Nowhere else good to put it
 	if (RakPeer::IsActive() && synchronizedRandomInteger)
 	{
-		unsigned long time = getTime();
+		unsigned long time = RakNetGetTime();
 		if (time > nextSeedUpdate || (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION))
 		{
 			if (time > nextSeedUpdate)
@@ -144,39 +149,39 @@
 
 			SetRandomNumberSeedStruct s;
 			s.ts=ID_TIMESTAMP;
-			s.timeStamp=getTime();
+			s.timeStamp=RakNetGetTime();
 			s.typeId=ID_SET_RANDOM_NUMBER_SEED;
 			s.seed=seed;
 			s.nextSeed=nextSeed;
 
 			if (packet && packet->data[0]==ID_NEW_INCOMING_CONNECTION)
-				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 			else
-				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				Send((char*)&s, sizeof(SetRandomNumberSeedStruct),  SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 		}
 	}
 
 	if (packet)
-	{
+	{			
 		// Intercept specific client / server feature packets.  This will do an extra send and still pass on the data to the user
-		if (packet->data[0]==ID_RECEIVED_STATIC_DATA)
+		if (packet->data[0]==ID_REMOTE_STATIC_DATA)
 		{
 			if (relayStaticClientData)
 			{
 				// Relay static data to the other systems but the sender
-				BitStream bitStream(packet->length + sizeof(PlayerID));
-				unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+				RakNet::BitStream bitStream(packet->length + sizeof(PlayerID));
+				unsigned char typeId=ID_REMOTE_STATIC_DATA;
 				bitStream.Write(typeId);
 				bitStream.Write(packet->playerId.binaryAddress);
 				bitStream.Write(packet->playerId.port);
-				bitStream.Write(packet->data+sizeof(unsigned char), packet->length-sizeof(unsigned char));
-				Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
+				bitStream.Write((char*)packet->data+sizeof(unsigned char), packet->length-sizeof(unsigned char));
+				Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, UNASSIGNED_PLAYER_ID, true);
 			}			
 		}
 		else if (packet->data[0]==ID_DISCONNECTION_NOTIFICATION || packet->data[0]==ID_CONNECTION_LOST || packet->data[0]==ID_NEW_INCOMING_CONNECTION)
 		{
 			// Relay the disconnection
-			BitStream bitStream(packet->length + sizeof(PlayerID));
+			RakNet::BitStream bitStream(packet->length + sizeof(PlayerID));
 			unsigned char typeId;
 			if (packet->data[0]==ID_DISCONNECTION_NOTIFICATION)
 				typeId=ID_REMOTE_DISCONNECTION_NOTIFICATION;
@@ -187,7 +192,8 @@
 			bitStream.Write(typeId);
 			bitStream.Write(packet->playerId.binaryAddress);
 			bitStream.Write(packet->playerId.port);
-			Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, true);
+			bitStream.Write((unsigned short&)packet->playerIndex);
+			Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, true);
 
 			if (packet->data[0]==ID_NEW_INCOMING_CONNECTION)
 			{
@@ -201,19 +207,20 @@
 						bitStream.Write(typeId);
 						bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 						bitStream.Write(remoteSystemList[i].playerId.port);
+						bitStream.Write((unsigned short)i);
 						// One send to tell them of the connection
-						Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+						Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 
 						if (relayStaticClientData)
 						{
 							bitStream.Reset();
-							typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+							typeId=ID_REMOTE_STATIC_DATA;
 							bitStream.Write(typeId);
 							bitStream.Write(remoteSystemList[i].playerId.binaryAddress);
 							bitStream.Write(remoteSystemList[i].playerId.port);
 							bitStream.Write((char*)remoteSystemList[i].staticData.GetData(), remoteSystemList[i].staticData.GetNumberOfBytesUsed());
 							// Another send to tell them of the static data
-							Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, packet->playerId, false);
+							Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, packet->playerId, false);
 						}
 					}
 				}
@@ -226,7 +233,7 @@
 
 void RakServer::Kick(PlayerID playerId)
 {
-	RakPeer::CloseConnection(playerId, true);
+	RakPeer::CloseConnection(playerId, true, 0L);
 }
 
 void RakServer::DeallocatePacket(Packet *packet)
@@ -346,14 +353,14 @@
 	RakPeer::UnregisterAsRemoteProcedureCall(uniqueID);
 }
 
-bool RakServer::RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+		return RakPeer::RPC(uniqueID, data, bitLength, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
-bool RakServer::RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)
+bool RakServer::RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)
 {
-	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingStream, playerId, broadcast, shiftTimestamp);
+	return RakPeer::RPC(uniqueID, parameters, priority, reliability, orderingChannel, playerId, broadcast, shiftTimestamp);
 }
 
 /*
@@ -382,7 +389,7 @@
 	return RakPeer::GetDecompressionRatio();
 }
 
-BitStream* RakServer::GetStaticServerData(void)
+RakNet::BitStream * RakServer::GetStaticServerData(void)
 {
 	return RakPeer::GetRemoteStaticData(myPlayerId);
 }
@@ -402,8 +409,13 @@
 	RakPeer::SendStaticData(playerId);
 }
 
-BitStream* RakServer::GetStaticClientData(PlayerID playerId)
+void RakServer::SetOfflinePingResponse(char *data, const unsigned long length)
 {
+	RakPeer::SetOfflinePingResponse(data,length);
+}
+
+RakNet::BitStream * RakServer::GetStaticClientData(PlayerID playerId)
+{
 	return RakPeer::GetRemoteStaticData(playerId);
 }
 
@@ -420,13 +432,13 @@
 		return; // No such playerChangedId
 
     // Relay static data to the other systems but the sender
-	BitStream bitStream(remoteSystem->staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
-	unsigned char typeId=ID_RECEIVED_RELAYED_STATIC_DATA;
+	RakNet::BitStream bitStream(remoteSystem->staticData.GetNumberOfBytesUsed() + sizeof(PlayerID) + sizeof(unsigned char));
+	unsigned char typeId=ID_REMOTE_STATIC_DATA;
 	bitStream.Write(typeId);
 	bitStream.Write(playerChangedId.binaryAddress);
 	bitStream.Write(playerChangedId.port);
 	bitStream.Write((char*)remoteSystem->staticData.GetData(), remoteSystem->staticData.GetNumberOfBytesUsed());
-	Send(&bitStream, HIGH_PRIORITY, RELIABLE, 0, playerToSendToId, true);
+	Send(&bitStream, SYSTEM_PRIORITY, RELIABLE, 0, playerToSendToId, true);
 }
 
 unsigned int RakServer::GetNumberOfAddresses(void)
@@ -489,68 +501,12 @@
 	return RakPeer::GetMTUSize();
 }
 
-double RakServer::GetPacketlossPercentile(void)
+void RakServer::AdvertiseSystem(char *host, unsigned short remotePort)
 {
-	return RakPeer::GetPacketlossPercentile();
+	RakPeer::AdvertiseSystem(host, remotePort);
 }
-	
-unsigned long RakServer::GetTransmittedPacketCount(void)
-{
-	return RakPeer::GetTransmittedPacketCount();
-}
 
-unsigned long RakServer::GetTransmittedFrameCount(void)
+RakNetStatisticsStruct * const RakServer::GetStatistics(PlayerID playerId)
 {
-	return RakPeer::GetTransmittedFrameCount();
+	return RakPeer::GetStatistics(playerId);
 }
-
-unsigned long RakServer::GetLostPacketCount(void)
-{
-	return RakPeer::GetLostPacketCount();
-}
-
-unsigned long RakServer::GetReceivedPacketCount(void)
-{
-	return RakPeer::GetReceivedPacketCount();
-}
-
-unsigned long RakServer::GetBytesSent(void)
-{
-	return RakPeer::GetBytesSent();
-}
-
-unsigned long RakServer::GetBytesReceived(void)
-{
-	return RakPeer::GetBytesReceived();
-}
-
-unsigned long RakServer::GetUnacknowledgedSentPacketListSize(void)
-{
-	return RakPeer::GetUnacknowledgedSentPacketListSize();
-}
-
-unsigned long RakServer::GetBytesSentPerSecond(void) const
-{
-	return RakPeer::GetBytesSentPerSecond();
-}
-
-unsigned long RakServer::GetBytesReceivedPerSecond(void) const
-{
-	return RakPeer::GetBytesReceivedPerSecond();
-}
-
-unsigned long RakServer::GetMaximumWindowSize(void)
-{
-	return RakPeer::GetMaximumWindowSize();
-}
-
-unsigned long RakServer::GetPacketOutputBufferSize(void)
-{
-	return RakPeer::GetPacketOutputBufferSize();
-}
-
-unsigned long RakServer::GetConnectionTime(PlayerID playerId)
-{
-	return RakPeer::GetConnectionTime(playerId);
-}
-

Modified: trunk/source/libraries/raknet/RakServer.h
===================================================================
--- trunk/source/libraries/raknet/RakServer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakServer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -25,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port);
+	bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port);
 
 	// Description:
 	// Must be called while offline
@@ -43,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn);
+	// privateKeyE, privateKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	void InitializeSecurity(char *privateKeyE, char *privateKeyN);
 
 	// Description
 	// Must be called while offline
@@ -67,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	void Disconnect(void);
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	void Disconnect(unsigned long blockDuration);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast);
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast);
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -222,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
-	bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
+	bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp);
 
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
 	// This is already done in Multiplayer.cpp, so if you use the Multiplayer class it is handled for you.
@@ -260,7 +260,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	BitStream* GetStaticServerData(void);
+	RakNet::BitStream * GetStaticServerData(void);
 	void SetStaticServerData(char *data, const long length);
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -278,6 +278,13 @@
 	// The server must be active for this to have meaning
 	void SendStaticServerDataToClient(PlayerID playerId);
 
+	// Description:
+	// Sets the data to send with an (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	void SetOfflinePingResponse(char *data, const unsigned long length);
+
 	// Returns a pointer to an attached client's character name specified by the playerId
 	// Returns 0 if no such player is connected
 	// Note that you can modify the client data here.  Changes won't be reflected on clients unless you force them to
@@ -286,12 +293,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...);
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...);
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	BitStream* GetStaticClientData(PlayerID playerId);
+	RakNet::BitStream * GetStaticClientData(PlayerID playerId);
 	void SetStaticClientData(PlayerID playerId, char *data, const long length);
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,21 +389,25 @@
 	// Returns the current MTU size
 	int GetMTUSize(void) const;
 
-	// Network statistics.
-	double GetPacketlossPercentile(void); // The average outgoing packetloss percentile among all connected clients
-	unsigned long GetTransmittedPacketCount(void); // How many packets were sent among all connected clients
-	unsigned long GetTransmittedFrameCount(void); // How many frames were sent	
-	unsigned long GetLostPacketCount(void); // How many packets were lost among all connected clients
-	unsigned long GetReceivedPacketCount(void); // How many packets were received among all connected clients
-	unsigned long GetBytesSent(void); // How many bytes have been sent among all connected clients.
-	unsigned long GetBytesReceived(void); // How many bytes have been received among all connected clients.
-	unsigned long GetUnacknowledgedSentPacketListSize(void); // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	unsigned long GetBytesSentPerSecond(void) const;  // How many bytes were sent in the last histogram block.
-	unsigned long GetBytesReceivedPerSecond(void) const; // How many bytes were received in the last histogram block.
-	unsigned long GetMaximumWindowSize(void); // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	unsigned long GetPacketOutputBufferSize(void); // Returns the number of waiting packets on the send queue
-	unsigned long GetConnectionTime(PlayerID playerId); // Returns when this client connected or 0 if not connected
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	void AdvertiseSystem(char *host, unsigned short remotePort);
 
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	RakNetStatisticsStruct * const GetStatistics(PlayerID playerId);
+
 	private:
 
 	// Synchronized random integer

Modified: trunk/source/libraries/raknet/RakServerInterface.h
===================================================================
--- trunk/source/libraries/raknet/RakServerInterface.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/RakServerInterface.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -13,7 +13,8 @@
 #include "NetworkTypes.h"
 #include "PacketPriority.h"
 #include "RakPeerInterface.h"
-class BitStream;
+#include "BitStream.h"
+#include "RakNetStatistics.h"
 
 class RakServerInterface
 {
@@ -24,12 +25,11 @@
 	// Call this to initiate the server with the number of players you want to be allowed connected at once
 	// Current maximum number of allowed players is 65535
 	// connectionValidationInteger is for legacy purposes and is unused
-	// Set highPriorityThreads to true for a real-time responsive server.  Set it to false
-	// for games where high pings don't matter, or if the network engine slows down the game too much
+	// _threadSleepTimer: <0 for single threaded, >=0 for how many ms to Sleep each internal update cycle (recommended 30 for low performance, 0 for regular, -1 for high)
 	// Port is the port you want the server to read and write on
 	// Make sure this port is open for UDP
 	// Returns true on successful initiation, false otherwise
-	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, bool highPriorityThreads, unsigned short port)=0;
+	virtual bool Start(unsigned short AllowedPlayers, unsigned long connectionValidationInteger, int threadSleepTimer, unsigned short port)=0;
 
 	// Description:
 	// Must be called while offline
@@ -42,12 +42,9 @@
 	// for incoming connections.
 	//
 	// Parameters:
-	// numberOfBytes:  How many bytes to use for each of the RSA keys.  Minimum 24.
-	// RSAd - A pointer to the private key of length numberOfBytes.
-	// RSAe - A pointer to the public key of length numberOfBytes. relatively prime to (p-1)*(q-1)
-	// RSAn - A pointer to the public key of length numberOfBytes.  p*q
-	// If _d, _e, and _n are 0, then an RSA key will be generated of length numberOfBytes (very slow!)
-	virtual void InitializeSecurity(unsigned short numberOfBytes, char *RSAd, char *RSAe, char *RSAn)=0;
+	// privKeyE, privKeyN - A pointer to the private keys from the RSACrypt class.  See the Encryption sample
+	// If the private keys are 0, then a new key will be generated when this function is called
+	virtual void InitializeSecurity(char *privKeyE, char *privKeyN)=0;
 
 	// Description
 	// Must be called while offline
@@ -66,24 +63,28 @@
 	// since the server is stopped packet reliability is not enforced so the Kick network message may not actually
 	// arrive.  Those players will disconnect due to timeout. If you want to end the server more gracefully, you
 	// can manually Kick each player first. Does nothing if the server is not running to begin with
-	virtual void Disconnect(void)=0;
+	//
+	// Parameters:
+	// blockDuration: How long you should wait for all remaining packets to go out, per connected system
+	// If you set it to 0 then the disconnection notifications probably won't arrive
+	virtual void Disconnect(unsigned long blockDuration)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the data stream of length length to whichever playerId you specify.  Specify UNASSIGNED_PLAYER_ID for all players connected
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY, RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(char *data, const long length, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// This function only works while the server is active (Use the Start function).  Returns false on failure, true on success
 	// Send the bitstream to whichever playerId you specify.
 	// You can set the first byte to a packet identifier, however you will need to have TYPE_CHECKING undefined or the internal type checking
 	// will add extra data and make this not work.  If you want TYPE_CHECKING on, you will need to use BitStream::WriteBits to avoid the type checking.
 	// This interface will probably change to fix this in future versions.
-	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering stream
+	// If you aren't sure what to specify for priority and reliability, use HIGH_PRIORITY and RELIABLE, 0 for ordering channel
 	// Set broadcast to true to broadcast to all connected clients EXCEPT the one specified in the playerId field.
 	// To broadcast to everyone specify UNASSIGNED_PLAYER_ID for the playerId field.
-	virtual bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast)=0;
+	virtual bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast)=0;
 
 	// Call this to get a packet from the incoming packet queue.  Use DeallocatePacket to deallocate the packet after you are done with it.
 	// Check the Packet struct at the top of CoreNetworkStructures.h for the format of the struct
@@ -221,8 +222,8 @@
 	// If you want that function to return data you should call RPC from that system in the same way
 	// Returns true on a successful packet send (this does not indicate the recipient performed the call), false on failure
 	// The uniqueID must be composed of a string with only characters from a-z and is not case sensitive
-	virtual bool RPC(char* uniqueID, char *data, long bitLength, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
-	virtual bool RPC(char* uniqueID, BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingStream, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, char *data, unsigned long bitLength, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
+	virtual bool RPC(char* uniqueID, RakNet::BitStream *parameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, PlayerID playerId, bool broadcast, bool shiftTimestamp)=0;
 
 	// OBSOLETE - DONE AUTOMATICALLY
 	// Handles an RPC packet.  If you get a packet with the ID ID_RPC you should pass it to this function
@@ -260,7 +261,7 @@
 	// The data is entered as an array and stored and returned as a BitStream.
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
-	virtual BitStream* GetStaticServerData(void)=0;
+	virtual RakNet::BitStream * GetStaticServerData(void)=0;
 	virtual void SetStaticServerData(char *data, const long length)=0;
 
 	// This sets to true or false whether we want to support relaying of static client data to other connected clients.
@@ -278,6 +279,13 @@
 	// The server must be active for this to have meaning
 	virtual void SendStaticServerDataToClient(PlayerID playerId)=0;
 
+	// Description:
+	// Sets the data to send with an  (LAN server discovery) /(offline ping) response
+	// See the Ping sample project for how this is used.
+	// data: a block of data to store, or 0 for none
+	// length: The length of data in bytes, or 0 for none
+	virtual void SetOfflinePingResponse(char *data, const unsigned long length)=0;
+
 	// Returns a pointer to an attached client's character name specified by the playerId
 	// Returns 0 if no such player is connected
 	// Note that you can modify the client data here.  Changes won't be reflected on clients unless you force them to
@@ -286,12 +294,12 @@
 	// The data is entered as an array and stored and returned as a BitStream.  
 	// Everytime you call GetStaticServerData it resets the read pointer to the start of the bitstream.  To do multiple reads without reseting the pointer
 	// Maintain a pointer copy to the bitstream as in
-	// BitStream *copy = ...->GetStaticServerData(...)=0;
+	// RakNet::BitStream *copy = ...->GetStaticServerData(...)=0;
 	// To store a bitstream, use the GetData() and GetNumberOfBytesUsed() methods
 	// of the bitstream for the 2nd and 3rd parameters
 	// Note that the client may change at any time the
 	// data contents and/or its length!
-	virtual BitStream* GetStaticClientData(PlayerID playerId)=0;
+	virtual RakNet::BitStream * GetStaticClientData(PlayerID playerId)=0;
 	virtual void SetStaticClientData(PlayerID playerId, char *data, const long length)=0;
 
 	// This function is used to update the information on connected clients when the server effects a change
@@ -382,20 +390,24 @@
 	// Returns the current MTU size
 	virtual int GetMTUSize(void) const=0;
 
-	// Network statistics.
-	virtual double GetPacketlossPercentile(void)=0; // The average outgoing packetloss percentile among all connected clients
-	virtual unsigned long GetTransmittedPacketCount(void)=0; // How many packets were sent among all connected clients
-	virtual unsigned long GetTransmittedFrameCount(void)=0; // How many frames were sent	
-	virtual unsigned long GetLostPacketCount(void)=0; // How many packets were lost among all connected clients
-	virtual unsigned long GetReceivedPacketCount(void)=0; // How many packets were received among all connected clients
-	virtual unsigned long GetBytesSent(void)=0; // How many bytes have been sent among all connected clients.
-	virtual unsigned long GetBytesReceived(void)=0; // How many bytes have been received among all connected clients.
-	virtual unsigned long GetUnacknowledgedSentPacketListSize(void)=0; // How many reliable packets are waiting for remote acknowledgement.  This is a debugging statistic.
-	virtual unsigned long GetBytesSentPerSecond(void) const=0;  // How many bytes were sent in the last histogram block.
-	virtual unsigned long GetBytesReceivedPerSecond(void) const=0; // How many bytes were received in the last histogram block.
-	virtual unsigned long GetMaximumWindowSize(void)=0; // Returns the size of the flow control window, in bytes.  Smaller values correlate with higher throughput and less packetloss
-	virtual unsigned long GetPacketOutputBufferSize(void)=0; // Returns the number of waiting packets on the send queue
-	virtual unsigned long GetConnectionTime(PlayerID playerId)=0; // Returns when this client connected or 0 if not connected
+	// Description:
+	// Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system.
+	// This will tell the remote system our external IP outside the LAN, and can be used for NAT punch through
+	//
+	// host: Either a dotted IP address or a domain name
+	// remotePort: Which port to connect to on the remote machine.
+	virtual void AdvertiseSystem(char *host, unsigned short remotePort)=0;
+
+	// Description:
+	// Returns a structure containing a large set of network statistics for the specified system
+	// You can map this data to a string using the C style StatisticsToString function
+	//
+	// Parameters
+	// playerId: Which connected system to get statistics for
+	//
+	// Returns:
+	// 0 on can't find the specified system.  A pointer to a set of data otherwise.
+	virtual RakNetStatisticsStruct * const GetStatistics(PlayerID playerId)=0;
 };
 
 #endif

Modified: trunk/source/libraries/raknet/ReliabilityLayer.cpp
===================================================================
--- trunk/source/libraries/raknet/ReliabilityLayer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ReliabilityLayer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -11,6 +11,14 @@
 #include <assert.h>
 #include "GetTime.h"
 #include "SocketLayer.h"
+
+// alloca
+#ifdef _WIN32
+#include <malloc.h>
+#else
+#include <stdlib.h>
+#endif
+
 //#include "MemoryManager.h"
 
 // Defined in rand.cpp
@@ -19,9 +27,20 @@
 extern inline float frandomMT(void);
 
 static const int ACK_BIT_LENGTH=sizeof(PacketNumberType)*8+1;
-static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame
-static const int MINIMUM_WINDOW_SIZE=10; // how many packets can be sent unacknowledged before waiting for an ack
+static const int MAXIMUM_WINDOW_SIZE=(DEFAULT_MTU_SIZE-UDP_HEADER_SIZE)*8/ACK_BIT_LENGTH; // Sanity check - the most ack packets that could ever (usually) fit into a frame.
+static const int MINIMUM_WINDOW_SIZE=5; // how many packets can be sent unacknowledged before waiting for an ack
 
+#ifdef _INTERNET_SIMULATOR
+// Lag
+struct DataAndTime
+{
+	char data[2000];
+	int length;
+	unsigned long sendTime;
+};
+static BasicDataStructures::List<DataAndTime*> delayList;
+#endif
+
 //-------------------------------------------------------------------------------------------------------
 // Constructor
 //-------------------------------------------------------------------------------------------------------
@@ -31,6 +50,7 @@
 	#ifdef __USE_IO_COMPLETION_PORTS
 	readWriteSocket=INVALID_SOCKET;
 	#endif
+	freeThreadedMemoryOnNextUpdate=false;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -38,7 +58,7 @@
 //-------------------------------------------------------------------------------------------------------
 ReliabilityLayer::~ReliabilityLayer()
 {
-	FreeMemory();
+	FreeMemory(true); // Free all memory immediately
 	#ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket!=INVALID_SOCKET)
 		closesocket(readWriteSocket);
@@ -50,9 +70,8 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::Reset(void)
 {
-	FreeMemory();
+	FreeMemory(false); // False because Reset can be called by any thread
 	InitializeVariables();
-	encryptor.UnsetKey();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -100,10 +119,12 @@
 	memset(waitingForOrderedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(waitingForSequencedPacketWriteIndex, 0, NUMBER_OF_ORDERED_STREAMS);
 	memset(receivedPackets, 0, RECEIVED_PACKET_LOG_LENGTH * sizeof(unsigned long));
+	memset(&statistics, 0, sizeof(statistics));
+	statistics.connectionStartTime=RakNetGetTime();
 	splitPacketId=0L;
 	packetNumber=0;
-	lastPacketSendTime=retransmittedPackets=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
-	lostPacketResendDelay=1000L;
+//	lastPacketSendTime=retransmittedFrames=sentPackets=sentFrames=receivedPacketsCount=bytesSent=bytesReceived=0;
+	SetLostPacketResendDelay(1000L);
 	deadConnection=cheater=false;
 	lastAckTime=0;
 	blockWindowIncreaseUntilTime=0;
@@ -111,110 +132,143 @@
 	windowSize=MINIMUM_WINDOW_SIZE;
 	lossyWindowSize=MAXIMUM_WINDOW_SIZE+1; // Infinite
 	lastWindowIncreaseSizeTime=0;
-	lastPacketReceivedTime=0;
+//	lastPacketReceivedTime=0;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Frees all allocated memory
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::FreeMemory(void)
+void ReliabilityLayer::FreeMemory(bool freeAllImmediately)
 {
-	unsigned i,j;
+	if (freeAllImmediately)
+	{
+		FreeThreadedMemory();
+		FreeThreadSafeMemory();		
+	}
+	else
+	{
+		FreeThreadSafeMemory();
+		freeThreadedMemoryOnNextUpdate=true;
+	}
+	
+}
+void ReliabilityLayer::FreeThreadedMemory(void)
+{
+	unsigned i;
 	InternalPacket *internalPacket;
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-		for (i=0; i < splitPacketList.size(); i++)
-		{
-			delete [] splitPacketList[i]->data;
-			InternalPacketPool::Instance()->ReleasePointer(splitPacketList[i]);
-		}
-		splitPacketList.clear();
-		reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
-//	}
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	for (i=0; i < splitPacketList.size(); i++)
+	{
+		delete [] splitPacketList[i]->data;
+		InternalPacketPool::Instance()->ReleasePointer(splitPacketList[i]);
+	}
+	splitPacketList.clear();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-		for (i=0; i < NUMBER_OF_PRIORITIES; i++)
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+	while (outputQueue.size()>0)
+	{
+		internalPacket= outputQueue.pop();
+		delete [] internalPacket->data;
+		InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+	}
+	outputQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	}
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	for (i=0; i < orderingList.size(); i++)
+	{
+		if (orderingList[i])
 		{
-			for (j=0; j < sendQueue[i].size(); j++)
-			{
-				delete [] (sendQueue[i])[j]->data;
-				InternalPacketPool::Instance()->ReleasePointer((sendQueue[i])[j]);
-			}
-			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
-		}
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-//	}
+			BasicDataStructures::LinkedList<InternalPacket*>* theList = orderingList[i];
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-		for (i=0; i < orderingList.size(); i++)
-		{
-			if (orderingList[i])
+			if (theList)
 			{
-				BasicDataStructures::LinkedList<InternalPacket*>* theList = orderingList[i];
-
-				if (theList)
+				while (theList->size())
 				{
-					while (theList->size())
-					{
-						internalPacket = orderingList[i]->pop();
-						delete [] internalPacket->data;
-						InternalPacketPool::Instance()->ReleasePointer(internalPacket);
-					}
+					internalPacket = orderingList[i]->pop();
+					delete [] internalPacket->data;
+					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				}
 
-					delete theList;
-				}
+				delete theList;
 			}
 		}
-		orderingList.clear();
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-//	}
+	}
+	orderingList.clear();
+	//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while (acknowledgementQueue.size()>0)
-			InternalPacketPool::Instance()->ReleasePointer(acknowledgementQueue.pop());
-		acknowledgementQueue.clearAndForceAllocation(64);
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
-//	}
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	while (acknowledgementQueue.size()>0)
+		InternalPacketPool::Instance()->ReleasePointer(acknowledgementQueue.pop());
+	acknowledgementQueue.clearAndForceAllocation(64);
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//	}
 
-//	if (bytesSent > 0 || bytesReceived > 0)
-//	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-		while (outputQueue.size()>0)
+
+	//	if (bytesSent > 0 || bytesReceived > 0)
+	//	{
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	while (resendQueue.size())
+	{
+		// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
+		internalPacket= resendQueue.pop();
+		if (internalPacket)
 		{
-			internalPacket= outputQueue.pop();
 			delete [] internalPacket->data;
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 		}
-		outputQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
-//	}
+	}
+	resendQueue.clearAndForceAllocation(512);
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//	}
 
+	
+
+}
+void ReliabilityLayer::FreeThreadSafeMemory(void)
+{
+	unsigned i,j;
+//	InternalPacket *internalPacket;
+
 //	if (bytesSent > 0 || bytesReceived > 0)
 //	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-		while (resendQueue.size())
+		
+		for (i=0; i < NUMBER_OF_PRIORITIES; i++)
 		{
-			// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-			internalPacket= resendQueue.pop();
-			if (internalPacket)
+			j=0;
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
+			for (; j < sendQueue[i].size(); j++)
 			{
-				delete [] internalPacket->data;
-				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				delete [] (sendQueue[i])[j]->data;
+				InternalPacketPool::Instance()->ReleasePointer((sendQueue[i])[j]);
 			}
+			sendQueue[i].clearAndForceAllocation(512); // Preallocate the send lists so we don't do a bunch of reallocations unnecessarily
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 		}
-		resendQueue.clearAndForceAllocation(512);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		
 //	}
 
-	InternalPacketPool::Instance()->ClearPool();
+
+#ifdef _INTERNET_SIMULATOR
+	for (i=0; i < delayList.size(); i++)
+		delete delayList[i];
+	delayList.clear();
+#endif
+
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -238,48 +292,59 @@
 	bool pushedPacket;
 	int count;
 
-	bytesReceived+=length + UDP_HEADER_SIZE;
+//	bytesReceived+=length + UDP_HEADER_SIZE;
+	
+	
 
 	// decode this whole chunk if the decoder is defined.
 	if (encryptor.IsKeySet())
 	{
 		if (encryptor.Decrypt((unsigned char*)buffer, length, (unsigned char*)buffer, &length)==false)
+		{
+			statistics.bitsWithBadCRCReceived+=length*8;
+			statistics.packetsWithBadCRCRecieved++;
 			return false;
+		}
 	}
 
-	BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
+	statistics.bitsReceived+=length*8;
+	statistics.packetsReceived++;
 
-	time = lastPacketReceivedTime = getTime();
+	RakNet::BitStream socketData(buffer, length, false); // Convert the incoming data to a bitstream for easy parsing
 
+//	time = lastPacketReceivedTime = RakNetGetTime();
+	time=RakNetGetTime();
+
 	//printf("In HandleSocketReceiveFromConnectedPlayer %i bytes\n",length);
 	//for (int ass=0; ass < length && ass < 10; ass++)
 	//	printf("%i ", ((char*)(socketData.GetData()))[ass]);
 	//printf("\n\n");
 
 	// Parse the bitstream to create an internal packet
-	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&socketData);
+	InternalPacket* internalPacket = CreateInternalPacketFromBitStream(&socketData,time);
 
-
 	while (internalPacket)
 	{
 		if (internalPacket->isAcknowledgement)
 		{
+		//	printf("Got ack at %i\n", RakNetGetTime());
+
 			numberOfAcksInFrame++;
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 			if (resendQueue.size()==0)
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();				
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=0;  // Not resending anything so clear this var so we don't drop the connection on not getting any more acks
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 			else
 			{
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 				lastAckTime=time; // Just got an ack.  Record when we got it so we know the connection is alive
-				reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+				//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 			}
 
 			// SHOW - ack received
@@ -290,11 +355,11 @@
 		}
 		else
 		{
-			receivedPacketsCount++;
+//			receivedPacketsCount++;
 
 			if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
 			{
-				SendAcknowledgementPacket(internalPacket->packetNumber);
+				SendAcknowledgementPacket(internalPacket->packetNumber, time);
 			}
 
 			// If this packet number was recently used then it has already been received.
@@ -305,6 +370,8 @@
 			// then it must be a different packet
 			if (internalPacket->packetNumber >= RECEIVED_PACKET_LOG_LENGTH)
 			{
+				statistics.invalidMessagesReceived++;
+
 				delete [] internalPacket->data;
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 				#ifdef _DEBUG
@@ -312,36 +379,59 @@
 				#endif
 				return true;
 			}
+
+			// testing
+	//		if (internalPacket->reliability==UNRELIABLE)
+	//			printf("Got unreliable packet number %i\n", internalPacket->packetNumber);
+	//		else if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
+	//			printf("Got reliable packet number %i\n", internalPacket->packetNumber);
+
 			if (receivedPackets[internalPacket->packetNumber] > time - TIMEOUT_TIME) 
 				// I can receive RECEIVED_PACKET_LOG_LENGTH packets per TIMEOUT_TIME seconds before overrun on timestamps
 			{
 				// SHOW - duplicate packets
-				//printf("Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n",internalPacket->packetNumber);
+#ifdef _DEBUG
+				printf("Warning - got duplicate packet (%i).  Did RECEIVED_PACKET_LOG_LENGTH overrun?\n",internalPacket->packetNumber);
+				// testing
+#endif
 
+				statistics.duplicateMessagesReceived++;
+
 				// Duplicate packet
 				delete [] internalPacket->data;
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 				goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 			}
 
+
+			statistics.messagesReceived++;
+
 			// Record that this particular packet was received at this time
 			receivedPackets[internalPacket->packetNumber]=time;
 
+			// Keep on top of deleting old unreliable split packets so they don't clog the list.
+			if (internalPacket->splitPacketCount>0)
+				DeleteOldUnreliableSplitPackets(time);
+
 			if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==UNRELIABLE_SEQUENCED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket->orderingStream < NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
+#ifdef _DEBUG
+					printf("Got invalid packet\n");
+#endif
 					delete [] internalPacket->data;
 					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (IsOlderOrderedPacket(internalPacket->orderingIndex, waitingForSequencedPacketReadIndex[internalPacket->orderingStream])==false)
+				if (IsOlderOrderedPacket(internalPacket->orderingIndex, waitingForSequencedPacketReadIndex[internalPacket->orderingChannel])==false)
 				{
+					statistics.sequencedMessagesInOrder++;
 
 					// Check for older packets in the output list.  Delete any found
 					// UPDATE:
@@ -351,12 +441,12 @@
 					// don't need the older ones because the odds are they will still arrive in order
 					/*
 					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket->orderingStream, outputQueue);
+					DeleteSequencedPacketsInList(internalPacket->orderingChannel, outputQueue);
 					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 					// Check for older packets in the split packet list.  Delete any found
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
-					DeleteSequencedPacketsInList(internalPacket->orderingStream, splitPacketList, internalPacket->splitPacketId);
+					DeleteSequencedPacketsInList(internalPacket->orderingChannel, splitPacketList, internalPacket->splitPacketId);
 					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 */
 					// Is this a split packet?
@@ -368,43 +458,42 @@
 						assert(internalPacket->splitPacketIndex < internalPacket->splitPacketCount);
 						assert(internalPacket->dataBitLength < MAXIMUM_MTU_SIZE*8);
 
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 						// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 						for (unsigned cnt=0; cnt < splitPacketList.size(); cnt++)
 							assert (!(splitPacketList[cnt]->splitPacketIndex==internalPacket->splitPacketIndex && splitPacketList[cnt]->splitPacketId==splitPacketId));
 						int splitPacketListSize = splitPacketList.size()+1;
-						reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+						//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						#endif
 
 						// Check for a rebuilt packet
 						InsertIntoSplitPacketList(internalPacket);
 
 						// Sequenced
-						internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId);
+						internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId,time);
 
 						if (internalPacket)
 						{
 #ifdef _DEBUG
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize-internalPacket->splitPacketCount );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 							// Update our index to the newest packet
-							waitingForSequencedPacketReadIndex[internalPacket->orderingStream]=internalPacket->orderingIndex+1;
+							waitingForSequencedPacketReadIndex[internalPacket->orderingChannel]=internalPacket->orderingIndex+1;
 
 							// If there is a rebuilt packet, add it to the output queue
-							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 							outputQueue.push(internalPacket);
-							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//							reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 							internalPacket=0;
 						}
 #ifdef _DEBUG
 						else
 						{
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 							assert(splitPacketList.size() == splitPacketListSize );
-							reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+							//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 						}
 #endif
 						// else don't have all the parts yet
@@ -412,18 +501,19 @@
 					else
 					{
 						// Update our index to the newest packet
-						waitingForSequencedPacketReadIndex[internalPacket->orderingStream]=internalPacket->orderingIndex+1;
+						waitingForSequencedPacketReadIndex[internalPacket->orderingChannel]=internalPacket->orderingIndex+1;
 
 						// Not a split packet. Add the packet to the output queue
-						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
-
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 						outputQueue.push(internalPacket);
-						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//						reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 						internalPacket=0;
 					}
 				}
 				else
 				{
+					statistics.sequencedMessagesOutOfOrder++;
+					
 					// Older sequenced packet.  Discard it
 					delete [] internalPacket->data;
 					InternalPacketPool::Instance()->ReleasePointer(internalPacket);
@@ -445,26 +535,26 @@
 
 				// Check for a rebuilt packet
 				if (internalPacket->reliability!=RELIABLE_ORDERED)
-					internalPacket->orderingStream=255; // Use 255 to designate not sequenced and not ordered
+					internalPacket->orderingChannel=255; // Use 255 to designate not sequenced and not ordered
 
 #ifdef _DEBUG
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 				// Make sure this is not a duplicate insertion.  If this assert hits then splitPacketId overflowed into existing waiting split packets (i.e. more than rangeof(splitPacketId) waiting) 
 				for (unsigned cnt=0; cnt < splitPacketList.size(); cnt++)
 					assert (!(splitPacketList[cnt]->splitPacketIndex==internalPacket->splitPacketIndex && splitPacketList[cnt]->splitPacketId==internalPacket->splitPacketId));
 				int splitPacketListSize = splitPacketList.size()+1;
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 #endif
 				InsertIntoSplitPacketList(internalPacket);
 
-				internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId);
+				internalPacket = BuildPacketFromSplitPacketList(internalPacket->splitPacketId,time);
 
 				if (internalPacket==0)
 				{
 					#ifdef _DEBUG
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 					#endif
 
 					// Don't have all the parts yet
@@ -473,9 +563,9 @@
 				#ifdef _DEBUG
 				else
 				{
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 					assert(splitPacketList.size() == splitPacketListSize-internalPacket->splitPacketCount );
-					reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				}
 				#endif
 				// else continue down to handle RELIABLE_ORDERED
@@ -484,9 +574,9 @@
 			if (internalPacket->reliability==RELIABLE_ORDERED)
 			{
 				#ifdef _DEBUG
-				assert(internalPacket->orderingStream < NUMBER_OF_ORDERED_STREAMS);
+				assert(internalPacket->orderingChannel < NUMBER_OF_ORDERED_STREAMS);
 				#endif
-				if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)
+				if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
 				{
 					// Invalid packet
 					delete [] internalPacket->data;
@@ -494,27 +584,29 @@
 					goto CONTINUE_SOCKET_DATA_PARSE_LOOP;
 				}
 
-				if (waitingForOrderedPacketReadIndex[internalPacket->orderingStream]==internalPacket->orderingIndex)
+				if (waitingForOrderedPacketReadIndex[internalPacket->orderingChannel]==internalPacket->orderingIndex)
 				{
 					// Get the list to hold ordered packets for this stream
 					BasicDataStructures::LinkedList<InternalPacket*> *orderingListAtOrderingStream;
-					unsigned char orderingStreamCopy=internalPacket->orderingStream;
+					unsigned char orderingChannelCopy=internalPacket->orderingChannel;
 
+					statistics.orderedMessagesInOrder++;
+
 					// Push the packet for the user to read
-					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 					outputQueue.push(internalPacket);
-					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//					reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 					internalPacket=0; // Don't reference this any longer since other threads access it
 
 					// Wait for the next ordered packet in sequence
-					waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+					waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
-					reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingStreamCopy);
+					//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+					orderingListAtOrderingStream = GetOrderingListAtOrderingStream(orderingChannelCopy);
 
 					if (orderingListAtOrderingStream!=0)
 					{
-						// There is a list for this ordering stream that may contain waiting packets.  Pop them in order
+						// There is a list for this ordering channel that may contain waiting packets.  Pop them in order
 
 						// Scan the list and pop packets that were delayed due to ordering in order
 						while (orderingListAtOrderingStream->size()>0)
@@ -524,18 +616,18 @@
 							pushedPacket=false;
 							while (count!=0)
 							{
-								if (orderingListAtOrderingStream->peek()->orderingIndex == waitingForOrderedPacketReadIndex[orderingStreamCopy])
+								if (orderingListAtOrderingStream->peek()->orderingIndex == waitingForOrderedPacketReadIndex[orderingChannelCopy])
 								{
 									// A packet was waiting, so output it in order.
 									// This is already mutexed above
 
 									// Push the packet for the user to read
-									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 									outputQueue.push(orderingListAtOrderingStream->pop());
-									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//									reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 									// Wait for the next ordered packet in sequence
-									waitingForOrderedPacketReadIndex[orderingStreamCopy]++; // This wraps at 255
+									waitingForOrderedPacketReadIndex[orderingChannelCopy]++; // This wraps at 255
 
 									pushedPacket=true;
 
@@ -553,12 +645,14 @@
 						}
 
 					}
-					reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+					//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 
 					internalPacket=0;
 				}
 				else
 				{
+					statistics.orderedMessagesOutOfOrder++;
+
 					// This is a newer ordered packet than we are waiting for.  Store it for future use
 					AddToOrderingList(internalPacket);
 				}
@@ -567,13 +661,13 @@
 			}
 
 			// Nothing special about this packet.  Add it to the output queue
-			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 			outputQueue.push(internalPacket); 
-			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//			reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 			// Output queue fill rate test
 //			if (outputQueue.size()%50==0)
-//				printf("outputQueue.size()=%i Time=%i\n", outputQueue.size(), getTime());
+//				printf("outputQueue.size()=%i Time=%i\n", outputQueue.size(), RakNetGetTime());
 
 			internalPacket=0;
 		}
@@ -581,12 +675,15 @@
 		// Used for a goto to jump to the next packet immediately
 		CONTINUE_SOCKET_DATA_PARSE_LOOP:
 		// Parse the bitstream to create an internal packet
-		internalPacket = CreateInternalPacketFromBitStream(&socketData);
+		internalPacket = CreateInternalPacketFromBitStream(&socketData,time);
 	}
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-	if (numberOfAcksInFrame>=windowSize && sendQueue[HIGH_PRIORITY].size()>0)
+
+	// numberOfAcksInFrame>=windowSize is almost never true
+	if (numberOfAcksInFrame>=windowSize && (sendQueue[SYSTEM_PRIORITY].size()>0 || sendQueue[HIGH_PRIORITY].size()>0 || sendQueue[MEDIUM_PRIORITY].size()>0))
 	{
+
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 		if (windowSize < lossyWindowSize || time - lastWindowIncreaseSizeTime > lostPacketResendDelay*2) // Increases the window size slowly, testing for packetloss
 		{
 			// If we get a frame which clears out the resend queue after handling one or more acks, and we have packets waiting to go out,
@@ -607,8 +704,8 @@
 			if (windowSize==MAXIMUM_WINDOW_SIZE || windowSize - lossyWindowSize > 5)
 				lossyWindowSize++;
 		}
+	//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 	}
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return true;
 }
@@ -620,14 +717,14 @@
 {
 	InternalPacket* internalPacket;
 
-	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[outputQueue_MUTEX].Lock();
 	if (outputQueue.size()>0)
 	{
-//		#ifdef _DEBUG
-//		assert(bitStream->GetNumberOfBitsUsed()==0);
-//		#endif
+		//		#ifdef _DEBUG
+		//		assert(bitStream->GetNumberOfBitsUsed()==0);
+		//		#endif
 		internalPacket = outputQueue.pop();
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 
 		//printf("In Receive %i bytes\n",(internalPacket->dataBitLength-1)/8+1);
 		//for (int ass=0; ass < (internalPacket->dataBitLength-1)/8+1 && ass < 10; ass++)
@@ -644,9 +741,10 @@
 	}
 	else
 	{
-		reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
+	//	reliabilityLayerMutexes[outputQueue_MUTEX].Unlock();
 		return 0;
 	}
+	
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -654,14 +752,14 @@
 // bitStream contains the data to send
 // priority is what priority to send the data at
 // reliability is what reliability to use
-// ordering stream is from 0 to 255 and specifies what stream to use
+// ordering channel is from 0 to 255 and specifies what stream to use
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize)
+bool ReliabilityLayer::Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize)
 {
 	#ifdef _DEBUG
 	assert(!(reliability > RELIABLE_SEQUENCED || reliability < 0));
 	assert(!(priority > NUMBER_OF_PRIORITIES || priority < 0));
-	assert(!(orderingStream < 0 || orderingStream >= NUMBER_OF_ORDERED_STREAMS));
+	assert(!(orderingChannel < 0 || orderingChannel >= NUMBER_OF_ORDERED_STREAMS));
 	assert(bitStream->GetNumberOfBytesUsed()>0);
 	#endif
 
@@ -677,8 +775,8 @@
 	if (priority > NUMBER_OF_PRIORITIES || priority < 0)
 		priority = HIGH_PRIORITY;
 
-	if (orderingStream >= NUMBER_OF_ORDERED_STREAMS)
-		orderingStream=0;
+	if (orderingChannel >= NUMBER_OF_ORDERED_STREAMS)
+		orderingChannel=0;
 
 	if (bitStream->GetNumberOfBytesUsed()==0)
 	{
@@ -694,7 +792,7 @@
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket->creationTime=getTime();
+	internalPacket->creationTime=RakNetGetTime();
 	if (makeDataCopy)
 	{
 		internalPacket->data = new char [bitStream->GetNumberOfBytesUsed()];
@@ -722,13 +820,9 @@
 
 	// If a split packet, we might have to upgrade the reliability
 	if (splitPacket)
-	{
-		// Split packets must be sent reliably.  Otherwise not all the parts might arrive
-		if (internalPacket->reliability==UNRELIABLE)
-			internalPacket->reliability=RELIABLE;
-		else if (internalPacket->reliability==UNRELIABLE_SEQUENCED)
-			internalPacket->reliability=RELIABLE_SEQUENCED;
-	}
+		statistics.numberOfSplitMessages++;
+	else
+		statistics.numberOfUnsplitMessages++;
 
 	// Increment the cyclical receivedPacketsIndex for use by the next packet.
 	// This variable is used as the identifier of the packet on the remote machine.
@@ -742,13 +836,13 @@
 	if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==UNRELIABLE_SEQUENCED)
 	{
 		// Assign the sequence stream and index
-		internalPacket->orderingStream=orderingStream;
+		internalPacket->orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Lock();
-		internalPacket->orderingIndex=waitingForSequencedPacketWriteIndex[orderingStream]++;
+		internalPacket->orderingIndex=waitingForSequencedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForSequencedPacketWriteIndex_MUTEX].Unlock();
 
-		// This packet supercedes all other sequenced packets on the same ordering stream
-		// Delete all packets in all send lists that are sequenced and on the same ordering stream
+		// This packet supercedes all other sequenced packets on the same ordering channel
+		// Delete all packets in all send lists that are sequenced and on the same ordering channel
 		// UPDATE:
 		// Disabled.  We don't have enough info to consistently do this.  Sometimes newer data does supercede
 		// older data such as with constantly declining health, but not in all cases.
@@ -758,17 +852,17 @@
 		for (int i=0; i < NUMBER_OF_PRIORITIES; i++)
 		{
 			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-			DeleteSequencedPacketsInList(orderingStream, sendQueue[i]);
+			DeleteSequencedPacketsInList(orderingChannel, sendQueue[i]);
 			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
 		}
 		*/
 	}
 	else if (internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// Assign the ordering stream and index
-		internalPacket->orderingStream=orderingStream;
+		// Assign the ordering channel and index
+		internalPacket->orderingChannel=orderingChannel;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Lock();
-		internalPacket->orderingIndex=waitingForOrderedPacketWriteIndex[orderingStream]++;
+		internalPacket->orderingIndex=waitingForOrderedPacketWriteIndex[orderingChannel]++;
 		reliabilityLayerMutexes[waitingForOrderedPacketWriteIndex_MUTEX].Unlock();
 	}
 
@@ -779,9 +873,9 @@
 		return true;
 	}
 	
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Lock();
     sendQueue[internalPacket->priority].push(internalPacket);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Unlock();
 
 	return true;
 }
@@ -789,27 +883,35 @@
 //-------------------------------------------------------------------------------------------------------
 // Run this once per game cycle.  Handles internal lists and actually does the send
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize)
+void ReliabilityLayer::Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time)
 {
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 		return;
 #endif
-//	unsigned resendQueueSize;
+	//	unsigned resendQueueSize;
 	bool reliableDataSent;
 	unsigned long lastAck;
 
+	if (freeThreadedMemoryOnNextUpdate)
+	{
+		freeThreadedMemoryOnNextUpdate=false;
+		FreeThreadedMemory();
+	}
+
 	// Accuracy isn't important on this value, and since this is called so often the mutex is sometimes causing deadlock problems.
 	// So it is presently disabled
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //	resendQueueSize=resendQueue.size();
 //	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	lastAck=lastAckTime;
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+//	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
-	if (resendQueue.size()>0 && lastAck && getTime() - lastAck > TIMEOUT_TIME)
+	// Due to thread vagarities and the way I store the time to avoid slow calls to RakNetGetTime
+	// time may be less than lastAck
+	if (resendQueue.size()>0 && time > lastAck && lastAck && time - lastAck > TIMEOUT_TIME)
 	{
 		// SHOW - dead connection
 		// printf("The connection has been lost.\n");
@@ -818,7 +920,7 @@
 		return;
 	}
 
-	//if (outputWindowFullTime && getTime() > TIMEOUT_TIME + outputWindowFullTime)
+	//if (outputWindowFullTime && RakNetGetTime() > TIMEOUT_TIME + outputWindowFullTime)
 	//{
 	//	// We've waited a long time with no data from the other system.  Assume the connection is lost
 	//	deadConnection=true;
@@ -827,29 +929,60 @@
 
 	// Not a frame but a packet actually.
 	// However, in a sense it is a frame because we are filling multiple logical packets into one datagram
-	if (IsFrameReady())
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+
+	// Keep sending to available bandwidth
+	while (IsFrameReady(time))
 	{
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Lock();
+		updateBitStream.Reset();
+		GenerateFrame(&updateBitStream, MTUSize, &reliableDataSent,time);
+		if (updateBitStream.GetNumberOfBitsUsed()>0)
+		{
+#ifndef _INTERNET_SIMULATOR
+			SendBitStream(s, playerId, &updateBitStream);
+#else
+			// Delay the send to simulate lag
+			DataAndTime *dt;
+			dt=new DataAndTime;
+			memcpy(dt->data, updateBitStream.GetData(), updateBitStream.GetNumberOfBytesUsed());
+			dt->length=updateBitStream.GetNumberOfBytesUsed();
+			dt->sendTime=time+100+(randomMT()%100);
+			delayList.insert(dt);
+#endif
+		}
+		else
+			break;
+	}
+	
 
-		do
+#ifdef _INTERNET_SIMULATOR
+	// Do any lagged sends
+	unsigned i=0;
+	while (i < delayList.size())
+	{
+		if (delayList[i]->sendTime<time)
 		{
 			updateBitStream.Reset();
-			GenerateFrame(&updateBitStream, MTUSize, &reliableDataSent);
-			if (updateBitStream.GetNumberOfBitsUsed()>0)
-			{
-				SendBitStream(s, playerId, &updateBitStream);
-			}
+			updateBitStream.Write(delayList[i]->data, delayList[i]->length);
+			// Send it now
+			SendBitStream(s, playerId, &updateBitStream);
 
-		} while (updateBitStream.GetNumberOfBitsUsed()>0 && IsFrameReady());
+			delete delayList[i];
+			delayList[i]=delayList[delayList.size()-1];
+			delayList.del();
+		}
+		else
+			i++;
+	}
+#endif
 
-		reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
-	}
+	//reliabilityLayerMutexes[updateBitStream_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Writes a bitstream to the socket
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream)
+void ReliabilityLayer::SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream)
 {
  // SHOW - showing reliable flow
 //	if (bitStream->GetNumberOfBytesUsed()>50)
@@ -857,15 +990,19 @@
 
 	int oldLength, length;
 
-	sentFrames++;
+//	sentFrames++;
 
 #ifdef _INTERNET_SIMULATOR
+
+	/*
 	// packetloss
-	if (randomMT() %100 <=10)
+	if (windowSize>MINIMUM_WINDOW_SIZE && frandomMT() <= (float)(windowSize-MINIMUM_WINDOW_SIZE)/(float)(MAXIMUM_WINDOW_SIZE-MINIMUM_WINDOW_SIZE))
 	{
-		lastPacketSendTime=getTime();
+		// printf("Frame %i lost\n", sentFrames);
+		lastPacketSendTime=RakNetGetTime();
 		return;
 	}
+	*/
 #endif
 
 
@@ -874,64 +1011,68 @@
 	{
 		length = bitStream->GetNumberOfBytesUsed();
 		oldLength = length;
+
 		encryptor.Encrypt((unsigned char*)bitStream->GetData(), length, (unsigned char*)bitStream->GetData(), &length);
+		statistics.encryptionBitsSent=(length-oldLength)*8;
 
-		if (encryptor.IsKeySet())
-			bytesSent+=length - oldLength;
+		// TODO - put back in
+		assert((length % 16 )== 0);
 	}
 	else
 	{
 		length = bitStream->GetNumberOfBytesUsed();
 	}
 
-
 #ifdef __USE_IO_COMPLETION_PORTS
 	if (readWriteSocket==INVALID_SOCKET)
 	{
-		assert(0);
-		return;
+		assert(0);	return;
 	}
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
 	SocketLayer::Instance()->Write(readWriteSocket, (const char*)bitStream->GetData(), length);
 #else
-    SocketLayer::Instance()->SendTo(s, (char*)bitStream->GetData(), length, playerId);
-#endif
+	statistics.packetsSent++;
+	statistics.totalBitsSent+=length*8;
+	//printf("total bits=%i length=%i\n", BITS_TO_BYTES(statistics.totalBitsSent), length);
+    SocketLayer::Instance()->SendTo(s, (char*)bitStream->GetData(), length, playerId.binaryAddress, playerId.port);
+#endif // __USE_IO_COMPLETION_PORTS
 
-	lastPacketSendTime=getTime();
+//	lastPacketSendTime=time;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Returns true if we can or should send a frame.  False if we should not
 //-------------------------------------------------------------------------------------------------------
-bool ReliabilityLayer::IsFrameReady(void)
+bool ReliabilityLayer::IsFrameReady(unsigned long time)
 {
 	if (IsSendThrottled()==false)
 		return true;
 
-	unsigned long time = getTime();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-
 	// Any acknowledgement packets waiting?  We will send these even if the send is throttled.
 	// Otherwise the throttle may never end
-	if (acknowledgementQueue.size()>0 &&
-		(acknowledgementQueue.size() >= MINIMUM_WINDOW_SIZE ||
-		acknowledgementQueue.peek()->nextActionTime < time))
+	if (acknowledgementQueue.size() >= MINIMUM_WINDOW_SIZE
+		// Try not waiting to send acks - will take more bandwidth but maybe less packetloss
+		// || acknowledgementQueue.peek()->nextActionTime < time
+		)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 		return true;
 	}
 	
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 	// Does the oldest packet need to be resent?  If so, send it.
 	// Otherwise the throttle may never end
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	if (resendQueue.size()>0 && resendQueue.peek() && resendQueue.peek()->nextActionTime < time)
 	{
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 		return true;
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 	// Send is throttled.  Don't send.
 	return false;
@@ -940,13 +1081,13 @@
 //-------------------------------------------------------------------------------------------------------
 // Generates a frame (coalesced packets)
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent)
+
+void ReliabilityLayer::GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time)
 {
 	InternalPacket *internalPacket;
 	int maxDataBitSize;
 	int reliableBits=0;
 	int nextPacketBitLength;
-	unsigned long time;
 	unsigned i;
 	bool isReliable,onlySendUnreliable;
 	bool acknowledgementPacketsSent;
@@ -959,11 +1100,11 @@
 
 	acknowledgementPacketsSent=false;
 
-	time = getTime();
 	*reliableDataSent=false;
+	
 
 	// Packet acknowledgements always go out first if they are overdue or if there are a lot of them
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Lock();
 	if (acknowledgementQueue.size()>0 &&
 		(acknowledgementQueue.size() >=MINIMUM_WINDOW_SIZE ||
@@ -971,110 +1112,114 @@
 	{
 		do
 		{
-
 			//	reliabilityLayerMutexes[remoteFramesAwaitingAck_MUTEX].Unlock();
 			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
 			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+			statistics.acknowlegementsSent++;
+			statistics.acknowlegementBitsSent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			acknowledgementPacketsSent=true;
 
 			// Delete the acknowledgement
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			if (	output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
+			if (output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
 			{
-
 				// SHOW - show ack
-		//		printf("Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+				//printf("Sending FULL ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
+				statistics.packetsContainingOnlyAcknowlegements++;
 				goto END_OF_GENERATE_FRAME;
 			}
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 		} while(acknowledgementQueue.size() > 0);
 	}
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
+	
+
 	// SHOW - show ack
 	//if (output->GetNumberOfBitsUsed()>0)
-		//printf("Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), getTime(),acknowledgementQueue.size());
+	//	printf("Sending ack (%i) at time %i. acknowledgementQueue.size()=%i\n", output->GetNumberOfBytesUsed(), RakNetGetTime(),acknowledgementQueue.size());
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	// The resend Queue can have NULL pointer holes.  This is so we can deallocate blocks without having to compress the array
-	while (resendQueue.size() > 0 && (resendQueue.peek()==0 || resendQueue.peek()->nextActionTime < time))
+	while (resendQueue.size() > 0)
 	{
-		// Copy the first packet out of the resend list
-		internalPacket = resendQueue.pop();
-
-		if (internalPacket==0)
+		if (resendQueue.peek()==0)
+		{
+			resendQueue.pop();
 			continue; // This was a hole
+		}
 
-		reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+		if (resendQueue.peek()->nextActionTime < time)
+		{
+			internalPacket = resendQueue.pop();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			// Testing
+			//printf("Resending %i. queue size = %i\n", internalPacket->packetNumber, resendQueue.size());
 
-		nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
+			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
 
-		if (	output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
-		{
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			if (output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
+			{
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				resendQueue.pushAtHead(internalPacket); // Not enough room to use this packet after all!
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
-			if (anyPacketsLost)
-			{
-				// The window size will decrease everytime we have to retransmit a frame
-				reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-				if (--windowSize < MINIMUM_WINDOW_SIZE)
-					windowSize=MINIMUM_WINDOW_SIZE;
-				reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-				lossyWindowSize=windowSize;
-				lastWindowIncreaseSizeTime=time;  // This will block the window size from increasing immediately
-				// SHOW - windowing
-				//printf("Frame lost.  New window size = %i.  Lossy window size = %i\n", windowSize, lossyWindowSize);
+				if (anyPacketsLost)
+				{
+					UpdatePacketloss(time);
+				}
+
+				goto END_OF_GENERATE_FRAME;
 			}
 
-			goto END_OF_GENERATE_FRAME;
-		}
+#ifdef _DEBUG
+			assert(internalPacket->priority>=0);
+			assert(internalPacket->reliability>=0);
+#endif
 
-		#ifdef _DEBUG
-		assert(internalPacket->priority>=0);
-		assert(internalPacket->reliability>=0);
-		#endif
+			// SHOW - show resends
+			//printf("Resending packet. resendQueue.size()=%i. Data=%s\n",resendQueue.size(), internalPacket->data);
 
-		// SHOW - show resends
-		//printf("Resending packet. resendQueue.size()=%i. Data=%s\n",resendQueue.size(), internalPacket->data);
+			// Write to the output bitstream
+//			sentPackets++;
+			statistics.messageResends++;
+			statistics.messageDataBitsResent+=internalPacket->dataBitLength;
 
-		// Write to the output bitstream
-		sentPackets++;
-		WriteToBitStreamFromInternalPacket(output, internalPacket);
-		*reliableDataSent=true;
+			statistics.messagesTotalBitsResent+=WriteToBitStreamFromInternalPacket(output, internalPacket);
+			*reliableDataSent=true;
 
-		// Update packetloss
-		UpdatePacketloss();
-		anyPacketsLost=true;
+			//		if (output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH > maxDataBitSize)
+			//			printf("Frame full of just acks and resends at time %i.\n", RakNetGetTime());
 
-		reliableBits+=internalPacket->dataBitLength;
-		internalPacket->nextActionTime = time + lostPacketResendDelay;
+			statistics.packetsContainingOnlyAcknowlegementsAndResends++;
 
-		// Put the packet back into the resend list at the correct spot
-		InsertPacketIntoResendQueue(internalPacket);
-		reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			anyPacketsLost=true;
+			internalPacket->nextActionTime = time + lostPacketResendDelay;
+
+			// Put the packet back into the resend list at the correct spot
+			InsertPacketIntoResendQueue(internalPacket, time);
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+
+		}
+		else
+		{
+			break;
+		}
 	}
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
+	
+
 	if (anyPacketsLost)
 	{
-		// The window size will decrease everytime we have to retransmit a frame
-		reliabilityLayerMutexes[windowSize_MUTEX].Lock();
-		if (--windowSize < MINIMUM_WINDOW_SIZE)
-			windowSize=MINIMUM_WINDOW_SIZE;
-		reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-		lossyWindowSize=windowSize;
-		lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
-		// SHOW - windowing
-		//printf("Frame lost.  New window size = %i.  Lossy window size = %i\n", windowSize, lossyWindowSize);
+		// Update packetloss
+		UpdatePacketloss(time);
 	}
 
 	onlySendUnreliable=false;
@@ -1085,18 +1230,27 @@
 	// From highest to lowest priority, fill up the output bitstream from the send lists
 	for (i=0; i < NUMBER_OF_PRIORITIES; i++)
 	{
-		reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	//	if (i==LOW_PRIORITY && sendQueue[LOW_PRIORITY].size() > 0 && (sendQueue[LOW_PRIORITY].size()%100)==0)
+	//	{
+	//		printf("%i\n", sendQueue[LOW_PRIORITY].size());
+	//	}
+
+		// Not mutexed - may give a wrong value if another thread is inserting something but it's ok
+		// Because we can avoid a slow mutex call a lot of the time
+		if (sendQueue[i].size()==0)
+			continue;
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		while (sendQueue[i].size())
 		{
 			internalPacket = sendQueue[i].pop();
-			reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 			nextPacketBitLength = GetBitStreamHeaderLength(internalPacket) + internalPacket->dataBitLength;
 
-			if (	output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
+			if (output->GetNumberOfBitsUsed() + nextPacketBitLength > maxDataBitSize)
 			{
 				// This output won't fit.
-				reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+				reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 				sendQueue[i].pushAtHead(internalPacket); // Push this back at the head so it is the next thing to go out
 				break;
 			}
@@ -1107,14 +1261,17 @@
 				isReliable=false;
 
 			// Write to the output bitstream
-			sentPackets++;
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+//			sentPackets++;
+			statistics.messagesSent[i]++;
+			statistics.messageDataBitsSent[i]+=internalPacket->dataBitLength;
+			statistics.messageTotalBitsSent[i]+=WriteToBitStreamFromInternalPacket(output, internalPacket);
 			if (isReliable)
 			{
 				// Reliable packets are saved to resend later
 				reliableBits+=internalPacket->dataBitLength;
 				internalPacket->nextActionTime = time + lostPacketResendDelay;
-				InsertPacketIntoResendQueue(internalPacket);
+				//printf("Resending at %i\n", internalPacket->nextActionTime);
+				InsertPacketIntoResendQueue(internalPacket, time);
 
 				*reliableDataSent=true;
 			}
@@ -1125,44 +1282,48 @@
 				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 			}
 
-			reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+			reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Lock();
 		}
 
-		reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+		reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+i].Unlock();
 
 	}
 
 	// Optimization - if we sent data but didn't send an acknowledgement packet previously then send them now
 	if (acknowledgementPacketsSent==false && output->GetNumberOfBitsUsed()>0)
 	{
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		while(output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH < maxDataBitSize && acknowledgementQueue.size() > 0)
+		if (acknowledgementQueue.size() > 0)
 		{
-			internalPacket = acknowledgementQueue.pop();
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			while(output->GetNumberOfBitsUsed() + ACK_BIT_LENGTH < maxDataBitSize && acknowledgementQueue.size() > 0)
+			{
+				internalPacket = acknowledgementQueue.pop();
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 
-			// Write the acknowledgement to the output bitstream
-			WriteToBitStreamFromInternalPacket(output, internalPacket);
+				// Write the acknowledgement to the output bitstream
+				WriteToBitStreamFromInternalPacket(output, internalPacket);
 
-			// Delete the acknowledgement
-			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
+				// Delete the acknowledgement
+				InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
-		} 
+				//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+			} 
 
-		reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+		}
 	}
 
 END_OF_GENERATE_FRAME:
+;
 
-
-	if (output->GetNumberOfBitsUsed()>0)
-	{
+//	if (output->GetNumberOfBitsUsed()>0)
+//	{
 		// Update the throttle with the header
-		bytesSent+=output->GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
-	}
+//		bytesSent+=output->GetNumberOfBytesUsed() + UDP_HEADER_SIZE;
+	//}
 }
 
+
 //-------------------------------------------------------------------------------------------------------
 // This will return true if we should not send at this time
 //-------------------------------------------------------------------------------------------------------
@@ -1170,9 +1331,9 @@
 {
 	int win;
 
-	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Lock();
 	win = windowSize;
-	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+//	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
 
 	return (int)resendQueue.size() >=win;
 }
@@ -1180,9 +1341,9 @@
 //-------------------------------------------------------------------------------------------------------
 // We lost a packet
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::UpdatePacketloss(void)
+void ReliabilityLayer::UpdatePacketloss(unsigned long time)
 {
-//	unsigned long time = getTime();
+//	unsigned long time = RakNetGetTime();
 	/*
 	maximumWindowSize = (unsigned int)((double)maximumWindowSize * DECREASE_THROUGHPUT_DELTA);
 	if (maximumWindowSize < MINIMUM_THROUGHPUT)
@@ -1197,7 +1358,18 @@
 
 
 //	reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
-	retransmittedPackets++;
+//	retransmittedFrames++;
+
+	// The window size will decrease everytime we have to retransmit a frame
+	//reliabilityLayerMutexes[windowSize_MUTEX].Lock();
+	if (--windowSize < MINIMUM_WINDOW_SIZE)
+		windowSize=MINIMUM_WINDOW_SIZE;
+	//reliabilityLayerMutexes[windowSize_MUTEX].Unlock();
+	lossyWindowSize=windowSize;
+	lastWindowIncreaseSizeTime=time; // This will block the window size from increasing immediately
+	// SHOW - windowing
+//	if (resendQueue.size()>0)
+//		printf("Frame lost.  New window size = %i.  Lossy window size = %i. Time=%i. Next send time=%i\n", windowSize, lossyWindowSize, RakNetGetTime(),resendQueue.peek()->nextActionTime);
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1207,46 +1379,52 @@
 {
 	InternalPacket *internalPacket;
 	PacketReliability reliability; // What type of reliability algorithm to use with this packet
-	unsigned char orderingStream; // What ordering stream this packet is on, if the reliability type uses ordering streams
-	unsigned char orderingIndex; // The ID used as identification for ordering streams
+	unsigned char orderingChannel; // What ordering channel this packet is on, if the reliability type uses ordering channels
+	unsigned char orderingIndex; // The ID used as identification for ordering channels
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+//	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 
 	for (unsigned i=0; i < resendQueue.size(); i ++)
 	{
 		if (resendQueue[i] && packetNumber==resendQueue[i]->packetNumber)
 		{
+			// Found what we wanted to ack
+			statistics.acknowlegementsReceived++;
+
 			if (i==0)
 				internalPacket=resendQueue.pop();
 			else
 			{
+				
 				// Generate a hole
 				internalPacket = resendQueue[i];
+				// testing
+			//	printf("Removing packet %i from resend\n", internalPacket->packetNumber);
 				resendQueue[i]=0;
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 
 			// Save some of the data of the packet
 			reliability=internalPacket->reliability;
-			orderingStream=internalPacket->orderingStream;
+			orderingChannel=internalPacket->orderingChannel;
 			orderingIndex=internalPacket->orderingIndex;
 
 			// Delete the packet
 			delete [] internalPacket->data;
 			InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering stream.
+			// If the deleted packet was reliable sequenced, also delete all older reliable sequenced resends on the same ordering channel.
 			// This is because we no longer need to send these.
 			if (reliability==RELIABLE_SEQUENCED)
 			{
 				unsigned j=0;
 
-				reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+				//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 				while (j < resendQueue.size())
 				{
 					internalPacket = resendQueue[j];
-					if (internalPacket && internalPacket->reliability==RELIABLE_SEQUENCED && internalPacket->orderingStream==orderingStream && IsOlderOrderedPacket(internalPacket->orderingIndex, orderingIndex))
+					if (internalPacket && internalPacket->reliability==RELIABLE_SEQUENCED && internalPacket->orderingChannel==orderingChannel && IsOlderOrderedPacket(internalPacket->orderingIndex, orderingIndex))
 					{
 						// Delete the packet
 						delete [] internalPacket->data;
@@ -1256,21 +1434,24 @@
 
 					j++;
 				}
-				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+//				reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 			}
 
-			reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-			break;
+			//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
+			return;
 		}
 	}
 
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+
+	// Didn't find what we wanted to ack
+	statistics.duplicateAcknowlegementsReceived++;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Acknowledge receipt of the packet with the specified packetNumber
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber)
+void ReliabilityLayer::SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time)
 {
 	InternalPacket *internalPacket;
 
@@ -1303,16 +1484,16 @@
 	internalPacket->packetNumber=packetNumber;
 	internalPacket->isAcknowledgement=true;
 
-	internalPacket->creationTime = getTime();
+	internalPacket->creationTime = time;
 	// We send this acknowledgement no later than 1/4 the time the remote 
 	//machine would send the original packet again
 	// DEBUG
-	internalPacket->nextActionTime = internalPacket->creationTime + lostPacketResendDelay/4;
+	internalPacket->nextActionTime = internalPacket->creationTime + (lostPacketResendDelay>>2);
 	//internalPacket->nextActionTime = internalPacket->creationTime;
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Lock();
 	acknowledgementQueue.push(internalPacket);
-//	printf("<Server>Adding ack at time %i. acknowledgementQueue.size=%i\n",getTime(), acknowledgementQueue.size());
-	reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
+//	printf("<Server>Adding ack at time %i. acknowledgementQueue.size=%i\n",RakNetGetTime(), acknowledgementQueue.size());
+	//reliabilityLayerMutexes[acknowledgementQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1338,11 +1519,11 @@
 	//bitStream->WriteBits((unsigned char*)&(internalPacket->reliability), 3, true);
 	bitLength+=3;
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		//bitStream->WriteBits((unsigned char*)&(internalPacket->orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		//bitStream->WriteBits((unsigned char*)&(internalPacket->orderingChannel), 5, true);
 		// -- bitLength+=5;
 
 		// ordering index is one byte
@@ -1381,14 +1562,22 @@
 //-------------------------------------------------------------------------------------------------------
 // Parse an internalPacket and create a bitstream to represent this data
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket)
+int ReliabilityLayer::WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket)
 {
 	#ifdef _DEBUG
 	assert(bitStream && internalPacket);
 	#endif
 
-	bitStream->AlignWriteToByteBoundary();
+	int start=bitStream->GetNumberOfBitsUsed();
 
+// testing
+//	if (internalPacket->reliability==UNRELIABLE)
+//		printf("Sending unreliable packet %i\n", internalPacket->packetNumber);
+//	else if (internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED || internalPacket->reliability==RELIABLE)
+//		printf("Sending reliable packet number %i\n", internalPacket->packetNumber);
+
+	//bitStream->AlignWriteToByteBoundary();
+
 	// Write the packet number (2 bytes)
 	bitStream->Write(internalPacket->packetNumber);
 
@@ -1396,7 +1585,9 @@
 	bitStream->Write(internalPacket->isAcknowledgement);
 	// Acknowledgement packets have no more data than the packetnumber and whether it is an acknowledgement
 	if (internalPacket->isAcknowledgement)
-		return;
+	{
+		return bitStream->GetNumberOfBitsUsed()-start;
+	}
 
 	#ifdef _DEBUG
 	assert(internalPacket->dataBitLength>0);
@@ -1406,11 +1597,11 @@
 	unsigned char reliability = (unsigned char)internalPacket->reliability;
 	bitStream->WriteBits((unsigned char*)(&(reliability)), 3, true);
 
-	// If the reliability requires an ordering stream and ordering index, we Write those.
+	// If the reliability requires an ordering channel and ordering index, we Write those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStream->WriteBits((unsigned char*)&(internalPacket->orderingStream), 5, true);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStream->WriteBits((unsigned char*)&(internalPacket->orderingChannel), 5, true);
 
 		// ordering index is one byte
 		bitStream->Write(internalPacket->orderingIndex);
@@ -1433,30 +1624,35 @@
 	#endif
 	unsigned short length = (unsigned short) internalPacket->dataBitLength; // Ignore the 2 high bytes for WriteBits
 
-	bitStream->Write(length);
+	bitStream->WriteCompressed(length);
 
 	// Write the actual data.
 	bitStream->WriteAlignedBytes((unsigned char*)internalPacket->data, BITS_TO_BYTES(internalPacket->dataBitLength));
+	//bitStream->WriteBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
+
+	return bitStream->GetNumberOfBitsUsed()-start;
 }
 
 //-------------------------------------------------------------------------------------------------------
 // Parse a bitstream and create an internal packet to represent this data
 //-------------------------------------------------------------------------------------------------------
-InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(BitStream *bitStream)
+InternalPacket* ReliabilityLayer::CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time)
 {
-	if (bitStream->GetNumberOfUnreadBits() < 8)
+	bool bitStreamSucceeded;
+	InternalPacket* internalPacket;
+
+	if (bitStream->GetNumberOfUnreadBits() < sizeof(internalPacket->packetNumber)*8)
 		return 0; // leftover bits
-
-	bool bitStreamSucceeded;
-	InternalPacket* internalPacket = InternalPacketPool::Instance()->GetPointer();
+	
+	internalPacket = InternalPacketPool::Instance()->GetPointer();
 #ifdef _DEBUG
 	// Remove boundschecker accessing undefined memory error
 	memset(internalPacket, 255, sizeof(InternalPacket));
 #endif
 
-	internalPacket->creationTime=getTime();
+	internalPacket->creationTime=time;
 
-	bitStream->AlignReadToByteBoundary();
+	//bitStream->AlignReadToByteBoundary();
 
 	// Read the packet number (2 bytes)
 	bitStreamSucceeded = bitStream->Read(internalPacket->packetNumber);
@@ -1484,11 +1680,11 @@
 #endif
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 
-	// If the reliability requires an ordering stream and ordering index, we read those.
+	// If the reliability requires an ordering channel and ordering index, we read those.
 	if (internalPacket->reliability==UNRELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_SEQUENCED || internalPacket->reliability==RELIABLE_ORDERED)
 	{
-		// ordering stream encoded in 5 bits (from 0 to 31)
-		bitStreamSucceeded = bitStream->ReadBits((unsigned char*)&(internalPacket->orderingStream), 5);
+		// ordering channel encoded in 5 bits (from 0 to 31)
+		bitStreamSucceeded = bitStream->ReadBits((unsigned char*)&(internalPacket->orderingChannel), 5);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
 #endif
@@ -1511,7 +1707,7 @@
 	if (bitStreamSucceeded==false) {InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 	if (isSplitPacket)
 	{
-		// split packet indices are one byte (so one packet can be split up to 65535 times - maximum packet size would be about 500 * 65535)
+		// split packet indices are one byte (so one packet can be split ufp to 65535 times - maximum packet size would be about 500 * 65535)
 		bitStreamSucceeded = bitStream->Read(internalPacket->splitPacketId);
 #ifdef _DEBUG
 		assert(bitStreamSucceeded);
@@ -1538,7 +1734,7 @@
 
 	
 	unsigned short length;
-	bitStreamSucceeded = bitStream->Read(length);
+	bitStreamSucceeded = bitStream->ReadCompressed(length);
 	// Read into an unsigned short.  Otherwise the data would be offset too high by two bytes
 #ifdef _DEBUG
 	assert(bitStreamSucceeded);
@@ -1556,6 +1752,7 @@
 	internalPacket->data[BITS_TO_BYTES(internalPacket->dataBitLength)-1]=0;
 	// Read the data the packet holds
 	bitStreamSucceeded = bitStream->ReadAlignedBytes((unsigned char*)internalPacket->data, BITS_TO_BYTES(internalPacket->dataBitLength));
+	//bitStreamSucceeded = bitStream->ReadBits((unsigned char*)internalPacket->data, internalPacket->dataBitLength);
 	#ifdef _DEBUG
 	assert(bitStreamSucceeded);	if (bitStreamSucceeded==false) {delete [] internalPacket->data; InternalPacketPool::Instance()->ReleasePointer(internalPacket); return 0;}
 	#endif
@@ -1601,14 +1798,14 @@
 // Search the specified list for sequenced packets on the specified ordering 
 // stream, optionally skipping those with splitPacketId, and delete them
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId)
 {
 	unsigned i=0;
 
 	while (i < theList.size())
 	{
 		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&
-			theList[i]->orderingStream==orderingStream && (splitPacketId==-1 || theList[i]->splitPacketId!=splitPacketId))
+			theList[i]->orderingChannel==orderingChannel && (splitPacketId==-1 || theList[i]->splitPacketId!=splitPacketId))
 		{
 			InternalPacket *internalPacket = theList[i];
 			theList.del(i);
@@ -1624,7 +1821,7 @@
 // Search the specified list for sequenced packets with a value less than orderingIndex and delete them
 // Note - I added functionality so you can use the Queue as a list (in this case for searching) but it is less efficient to do so than a regular list
 //-------------------------------------------------------------------------------------------------------
-void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue<InternalPacket*>&theList)
+void  ReliabilityLayer::DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue<InternalPacket*>&theList)
 {
 	InternalPacket *internalPacket;
 	int listSize=theList.size();
@@ -1632,7 +1829,7 @@
 
 	while (i < listSize)
 	{
-		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&	theList[i]->orderingStream==orderingStream)
+		if ((theList[i]->reliability==RELIABLE_SEQUENCED || theList[i]->reliability==UNRELIABLE_SEQUENCED) &&	theList[i]->orderingChannel==orderingChannel)
 		{
 			internalPacket = theList[i];
 			theList.del(i);
@@ -1690,7 +1887,6 @@
 	if (encryptor.IsKeySet())
 		maxDataSize-=16; // Extra data for the encryptor
 
-
 	#ifdef _DEBUG
 	// Make sure we need to split the packet to begin with
 	assert(dataByteLength > maxDataSize - headerLength);
@@ -1705,8 +1901,11 @@
 	// Calculate how many packets we need to create
 	internalPacket->splitPacketCount = (unsigned short)((dataByteLength-1) / (maximumSendBlock) + 1);
 
+	statistics.totalSplits+=internalPacket->splitPacketCount;
+
 	// Optimization
-	internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];
+	// internalPacketArray = new InternalPacket*[internalPacket->splitPacketCount];
+	internalPacketArray = (InternalPacket**)alloca(sizeof(InternalPacket*)*internalPacket->splitPacketCount);
 	for (i=0; i < (int)internalPacket->splitPacketCount; i++)
 	{
 		internalPacketArray[i]=InternalPacketPool::Instance()->GetPointer();
@@ -1759,16 +1958,16 @@
 	splitPacketId++; // It's ok if this wraps to 0
 
 	// Copy all the new packets into the split packet list
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Lock();
 	for (i=0; i < (int)internalPacket->splitPacketCount; i++)
 		sendQueue[internalPacket->priority].push(internalPacketArray[i]);
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
+	reliabilityLayerMutexes[sendQueueSystemPriority_MUTEX+internalPacket->priority].Unlock();
 
 	// Delete the original
 	delete [] internalPacket->data;
 	InternalPacketPool::Instance()->ReleasePointer(internalPacket);
 
-	delete [] internalPacketArray;
+	//delete [] internalPacketArray;
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1776,9 +1975,9 @@
 //-------------------------------------------------------------------------------------------------------
 void ReliabilityLayer::InsertIntoSplitPacketList(InternalPacket * internalPacket)
 {
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	splitPacketList.insert(internalPacket);
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1786,7 +1985,7 @@
 //reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
 // Optimized version
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId)
+InternalPacket * ReliabilityLayer::BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time)
 {
 	int i,j,size;
 	// How much data all blocks but the last hold
@@ -1796,7 +1995,7 @@
 	int *indexList;
 	int indexListIndex;
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Lock();
 	size = splitPacketList.size();
 
 	for (i=0; i < size; i++)
@@ -1806,19 +2005,21 @@
 			// Is there enough elements in the list to have all the parts?
 			if (splitPacketList[i]->splitPacketCount > splitPacketList.size() - i)
 			{
-				if (splitPacketList.size() % 100 == 0)
-					printf("%i\n", splitPacketList.size());
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//			if (splitPacketList.size() % 100 == 0 || splitPacketList[i]->splitPacketCount-splitPacketList.size()<100)
+	//				printf("%i out of %i\n", splitPacketList.size(), splitPacketList[i]->splitPacketCount);
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 				return 0;
 			}
 
+	//		printf("%i out of %i\n", splitPacketList.size(), splitPacketList[i]->splitPacketCount);
 			// Keep track of the indices of the elements through our first scan so we don't have to rescan to find them
 			indexListIndex=0;
 
 			numParts=1;
 			bitlength=splitPacketList[i]->dataBitLength;
 
-			indexList = new int[splitPacketList[i]->splitPacketCount];
+			// indexList = new int[splitPacketList[i]->splitPacketCount];
+			indexList = (int*) alloca(sizeof(int)*splitPacketList[i]->splitPacketCount);
 			indexList[indexListIndex++]=i;
 
 			maxDataSize=BITS_TO_BYTES(splitPacketList[i]->dataBitLength);
@@ -1838,7 +2039,7 @@
 			if (numParts==splitPacketList[i]->splitPacketCount)
 			{
 				// All the parts are here
-				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0);
+				InternalPacket *internalPacket=CreateInternalPacketCopy(splitPacketList[i],0,0,time);
 				internalPacket->data=new char[BITS_TO_BYTES(bitlength)];
 #ifdef _DEBUG
 				internalPacket->splitPacketCount = splitPacketList[i]->splitPacketCount;
@@ -1898,28 +2099,74 @@
 					else
 						j++;
 
-				reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+				//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
-				delete [] indexList;
+			//	delete [] indexList;
 
 				return internalPacket;
 			}
 
-			delete [] indexList;
+		//	delete [] indexList;
 			break;
 		}
 	}
 
-	reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
+	//reliabilityLayerMutexes[splitPacketList_MUTEX].Unlock();
 
 	return 0;
 }
 
+// Delete any unreliable split packets that have long since expired
+void ReliabilityLayer::DeleteOldUnreliableSplitPackets(unsigned long time)
+{
+	unsigned size,i,orderingIndexToDelete;
+	unsigned long newestUnreliableSplitPacket;
+	bool found;
+	InternalPacket *temp;
+
+	// Scan through the list for split packets that were sent unreliably.
+	// If the newest unreliable split packet for a particular ID is more than 3000 ms old, then
+	// delete all of them of that id
+
+	size = splitPacketList.size();
+	newestUnreliableSplitPacket=0L;
+	found=false;
+
+	for (i=0; i < size; i++)
+	{
+		if ((splitPacketList[i]->reliability==UNRELIABLE || splitPacketList[i]->reliability==UNRELIABLE_SEQUENCED) &&
+			splitPacketList[i]->creationTime >= newestUnreliableSplitPacket)
+		{
+			orderingIndexToDelete=splitPacketList[i]->orderingIndex;
+			newestUnreliableSplitPacket=splitPacketList[i]->creationTime;
+			found=true;
+		}
+	}
+
+	if (found && time-newestUnreliableSplitPacket > 5000)
+	{
+		// Delete all split packets that use orderingIndexToDelete
+		i=0;
+		while (i < splitPacketList.size())
+		{
+			if (splitPacketList[i]->orderingIndex==orderingIndexToDelete)
+			{
+				temp=splitPacketList[i];
+				splitPacketList[i]=splitPacketList[splitPacketList.size()-1];
+				splitPacketList.del(); // Removes the last element
+				InternalPacketPool::Instance()->ReleasePointer(temp);
+			}
+			else
+				i++;
+		}
+	}
+}
+
 //-------------------------------------------------------------------------------------------------------
 // Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 // Does not copy any split data parameters as that information is always generated does not have any reason to be copied
 //-------------------------------------------------------------------------------------------------------
-InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength)
+InternalPacket * ReliabilityLayer::CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time)
 {
 	InternalPacket *copy = InternalPacketPool::Instance()->GetPointer();
 #ifdef _DEBUG
@@ -1936,11 +2183,11 @@
 		copy->data=0;
 
 	copy->dataBitLength=dataByteLength<<3;
-	copy->creationTime = getTime();
+	copy->creationTime = time;
 	copy->isAcknowledgement=original->isAcknowledgement;
 	copy->nextActionTime=0;
 	copy->orderingIndex=original->orderingIndex;
-	copy->orderingStream=original->orderingStream;
+	copy->orderingChannel=original->orderingChannel;
 	copy->packetNumber=original->packetNumber;
 	copy->priority=original->priority;
 	copy->reliability=original->reliability;
@@ -1952,12 +2199,12 @@
 // Get the specified ordering list
 // LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 //-------------------------------------------------------------------------------------------------------
-BasicDataStructures::LinkedList<InternalPacket*> *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingStream)
+BasicDataStructures::LinkedList<InternalPacket*> *ReliabilityLayer::GetOrderingListAtOrderingStream(unsigned char orderingChannel)
 {
-	if (orderingStream >= orderingList.size())
+	if (orderingChannel >= orderingList.size())
 		return 0;
 
-	return orderingList[orderingStream];
+	return orderingList[orderingChannel];
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -1966,37 +2213,37 @@
 void ReliabilityLayer::AddToOrderingList(InternalPacket * internalPacket)
 {
 	#ifdef _DEBUG
-	assert(internalPacket->orderingStream< NUMBER_OF_ORDERED_STREAMS);
+	assert(internalPacket->orderingChannel< NUMBER_OF_ORDERED_STREAMS);
 	#endif
-	if (internalPacket->orderingStream >= NUMBER_OF_ORDERED_STREAMS)	
+	if (internalPacket->orderingChannel >= NUMBER_OF_ORDERED_STREAMS)	
 		return;
 
-	reliabilityLayerMutexes[orderingList_MUTEX].Lock();
-	if (internalPacket->orderingStream >= orderingList.size() || orderingList[internalPacket->orderingStream]==0)
+	//reliabilityLayerMutexes[orderingList_MUTEX].Lock();
+	if (internalPacket->orderingChannel >= orderingList.size() || orderingList[internalPacket->orderingChannel]==0)
 	{
 		// Need a linked list in this index
-		orderingList.replace(new BasicDataStructures::LinkedList<InternalPacket*>, 0, internalPacket->orderingStream);
-		(orderingList[internalPacket->orderingStream])->add(internalPacket);
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		orderingList.replace(new BasicDataStructures::LinkedList<InternalPacket*>, 0, internalPacket->orderingChannel);
+		(orderingList[internalPacket->orderingChannel])->add(internalPacket);
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 		return;
 	}
 	else
 	{
 		// Have a linked list in this index
-		if (orderingList[internalPacket->orderingStream]->size()==0)
+		if (orderingList[internalPacket->orderingChannel]->size()==0)
 		{
 			// The linked list is empty
-			(orderingList[internalPacket->orderingStream])->add(internalPacket);
+			(orderingList[internalPacket->orderingChannel])->add(internalPacket);
 		}
 		else
 		{
 			BasicDataStructures::LinkedList<InternalPacket*> *theList;
-			theList = GetOrderingListAtOrderingStream(internalPacket->orderingStream);
+			theList = GetOrderingListAtOrderingStream(internalPacket->orderingChannel);
 			// Add this packet in no particular order
 			theList->beginning();
 			theList->insert(internalPacket);
 		}
-		reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
+		//reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
 	}
 }
 
@@ -2005,17 +2252,16 @@
 // THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 // reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket)
+void ReliabilityLayer::InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time)
 {
-	reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Lock();
 	if (lastAckTime==0 || resendQueue.size()==0)
-		lastAckTime=getTime(); // Start the timer for the ack of this packet if we aren't already waiting for an ack
-	reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
+		lastAckTime=time; // Start the timer for the ack of this packet if we aren't already waiting for an ack
+	//reliabilityLayerMutexes[lastAckTime_MUTEX].Unlock();
 
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
 	resendQueue.push(internalPacket);
-	reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
+	//reliabilityLayerMutexes[resendQueue_MUTEX].Unlock();
 }
 
 //-------------------------------------------------------------------------------------------------------
@@ -2031,36 +2277,30 @@
 //-------------------------------------------------------------------------------------------------------
 // How long to wait between packet resends
 //-------------------------------------------------------------------------------------------------------
-void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i) {if (i > 0) lostPacketResendDelay=i; if (lostPacketResendDelay<1000) lostPacketResendDelay=1000;}
+void ReliabilityLayer::SetLostPacketResendDelay(unsigned long i)
+{
+	if (i > 0) lostPacketResendDelay=i;
+	if (lostPacketResendDelay<150) // To avoid unnecessary packetloss, this value should be UPDATE_THREAD_UPDATE_TIME + UPDATE_THREAD_POLL_TIME at a minimum
+		lostPacketResendDelay=150;
+}
 
 //-------------------------------------------------------------------------------------------------------
 // Statistics
 //-------------------------------------------------------------------------------------------------------
-double ReliabilityLayer::GetPacketlossPercentile(void) const {if 
-(sentPackets>0) return (double)retransmittedPackets / (double)sentPackets; 
-else return 0.0;}
-unsigned long ReliabilityLayer::GetTransmittedPacketCount(void) const 
-{return sentPackets;}
-unsigned long ReliabilityLayer::GetTransmittedFrameCount(void) const 
-{return sentFrames;}
-unsigned long ReliabilityLayer::GetLostPacketCount(void) const {return 
-retransmittedPackets;}
-unsigned long ReliabilityLayer::GetReceivedPacketCount(void) const {return 
-receivedPacketsCount;}
-unsigned long ReliabilityLayer::GetBytesSent(void) const {return bytesSent;}
-unsigned long ReliabilityLayer::GetBytesReceived(void) const {return 
-bytesReceived;}
-unsigned long ReliabilityLayer::GetUnacknowledgedSentPacketListSize(void) 
-{return resendQueue.size();}
-unsigned long ReliabilityLayer::GetPacketOutputBufferSize(void)
+RakNetStatisticsStruct * const ReliabilityLayer::GetStatistics(void)
 {
-	int val=0; 
-	reliabilityLayerMutexes[sendQueue_MUTEX].Lock();
-	for (int count=0; count<NUMBER_OF_PRIORITIES; count++)
-		val+= sendQueue[count].size();
-	reliabilityLayerMutexes[sendQueue_MUTEX].Unlock();
-	return val;
+	int i;
+	for (i=0; i < NUMBER_OF_PRIORITIES; i++)
+	{
+		statistics.messageSendBuffer[i]=sendQueue[i].size();
+	}
+
+	statistics.acknowlegementsPending=acknowledgementQueue.size();
+	statistics.messagesWaitingForReassembly=splitPacketList.size();
+	statistics.internalOutputQueueSize=outputQueue.size();
+	statistics.windowSize=windowSize;
+	statistics.lossySize=lossyWindowSize==MAXIMUM_WINDOW_SIZE+1 ? 0 : lossyWindowSize;
+	statistics.messagesOnResendQueue=resendQueue.size();
+
+	return &statistics;
 }
-unsigned long ReliabilityLayer::GetMaximumWindowSize(void) const {return windowSize;}
-unsigned long ReliabilityLayer::GetLastPacketReceivedTime(void) const {return lastPacketReceivedTime;}
-

Modified: trunk/source/libraries/raknet/ReliabilityLayer.h
===================================================================
--- trunk/source/libraries/raknet/ReliabilityLayer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/ReliabilityLayer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -21,23 +21,24 @@
 #include "InternalPacket.h"
 #include "InternalPacketPool.h"
 #include "DataBlockEncryptor.h"
+#include "RakNetStatistics.h"
 
 #define UDP_HEADER_SIZE 28
 #define NUMBER_OF_ORDERED_STREAMS 32 // 2^5
 
-const unsigned long TIMEOUT_TIME = 20000; // If no response to a reliable packet for this long kill the connection
+const unsigned long TIMEOUT_TIME = 10000; // If no response to a reliable packet for this long kill the connection
 // -----------------------------------------------------------------------------------------------------------------
 // If you change MAX_AVERAGE_PACKETS_PER_SECOND or TIMEOUT_TIME,
 // you must make sure RECEIVED_PACKET_LOG_LENGTH < the range of PacketNumberType (held in InternalPacket.h)
 // -----------------------------------------------------------------------------------------------------------------
  // *** Pay attention to the value of RECEIVED_PACKET_LOG_LENGTH when changing this! ***
-const int MAX_AVERAGE_PACKETS_PER_SECOND=400;
+const int MAX_AVERAGE_PACKETS_PER_SECOND=6553; // 6553.5 is the maximum for an unsigned short
  
 // *** This value must be less than the range of PacketNumberType. PacketNumberType is in InternalPacket.h  ***
 const int RECEIVED_PACKET_LOG_LENGTH=(TIMEOUT_TIME/1000)*MAX_AVERAGE_PACKETS_PER_SECOND;
 // -----------------------------------------------------------------------------------------------------------------
 
-class BitStream;
+#include "BitStream.h"
 
 class ReliabilityLayer
 {
@@ -48,18 +49,23 @@
 	// Destructor
 	~ReliabilityLayer();
 
-	// Resets the layer for reuse
+	// Resets the layer for reuse.
+	// Callable from multiple threads
 	void Reset(void);
 
 	// Sets up encryption
+	// Callable from multiple threads
 	void SetEncryptionKey(const unsigned char *key);
 
 	// Assign a socket for the reliability layer to use for writing
+	// Callable from multiple threads
 	void SetSocket(SOCKET s);
 
 	// Get the socket held by the reliability layer
+	// Callable from multiple threads
 	SOCKET GetSocket(void);
 
+	// Must be called by the same thread as update
 	// Packets are read directly from the socket layer and skip the reliability layer  because unconnected players do not use the reliability layer
 	// This function takes packet data after a player has been confirmed as connected.  The game should not use that data directly
 	// because some data is used internally, such as packet acknowledgement and split packets
@@ -67,17 +73,20 @@
 	bool HandleSocketReceiveFromConnectedPlayer(char *buffer, int length);
 
 	// This gets an end-user packet already parsed out. Returns number of BITS put into the buffer
+	// Callable from multiple threads
 	int Receive(char**data);
 
 	// Puts data on the send queue
 	// bitStream contains the data to send
 	// priority is what priority to send the data at
 	// reliability is what reliability to use
-	// ordering stream is from 0 to 31 and specifies what stream to use
-	bool Send(BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingStream, bool makeDataCopy, int MTUSize);
+	// ordering channel is from 0 to 31 and specifies what stream to use
+	// Callable from multiple threads
+	bool Send(RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, unsigned char orderingChannel, bool makeDataCopy, int MTUSize);
 
 	// Run this once per game cycle.  Handles internal lists and actually does the send
-	void Update(SOCKET s, PlayerID playerId, int MTUSize);
+	// Must be called by the same thread as HandleSocketReceiveFromConnectedPlayer
+	void Update(SOCKET s, PlayerID playerId, int MTUSize, unsigned long time);
 
 	// If Read returns -1 and this returns true then a modified packet was detected
 	bool IsCheater(void) const;
@@ -89,44 +98,36 @@
 	void SetLostPacketResendDelay(unsigned long i);
 
 	// Statistics
-	double GetPacketlossPercentile(void) const;
-	unsigned long GetTransmittedPacketCount(void) const;
-	unsigned long GetTransmittedFrameCount(void) const;
-	unsigned long GetLostPacketCount(void) const;
-	unsigned long GetReceivedPacketCount(void) const;
-	unsigned long GetBytesSent(void) const;
-	unsigned long GetBytesReceived(void) const;
-	unsigned long GetUnacknowledgedSentPacketListSize(void);
-	unsigned long GetPacketOutputBufferSize(void);
-	unsigned long GetMaximumWindowSize(void) const;
-	unsigned long GetLastPacketReceivedTime(void) const;
+	RakNetStatisticsStruct * const GetStatistics(void);
+
 private:
 	// Returns true if we can or should send a frame.  False if we should not
-	bool IsFrameReady(void);
+	bool IsFrameReady(unsigned long time);
 
 	// Generates a frame (coalesced packets)
-	void GenerateFrame(BitStream *output, int MTUSize, bool *reliableDataSent);
+	void GenerateFrame(RakNet::BitStream *output, int MTUSize, bool *reliableDataSent,unsigned long time);
 
 	// Writes a bitstream to the socket
-	void SendBitStream(SOCKET s, PlayerID playerId, BitStream *bitStream);
+	void SendBitStream(SOCKET s, PlayerID playerId, RakNet::BitStream *bitStream);
 
 	// Parse an internalPacket and create a bitstream to represent this data
-	void WriteToBitStreamFromInternalPacket(BitStream *bitStream, const InternalPacket *const internalPacket);
+	// Returns number of bits used
+	int WriteToBitStreamFromInternalPacket(RakNet::BitStream *bitStream, const InternalPacket *const internalPacket);
 
 	// Parse a bitstream and create an internal packet to represent this data
-	InternalPacket* CreateInternalPacketFromBitStream(BitStream *bitStream);
+	InternalPacket* CreateInternalPacketFromBitStream(RakNet::BitStream *bitStream, unsigned long time);
 
 	// Does what the function name says
 	void RemovePacketFromResendQueueAndDeleteOlderReliableSequenced(PacketNumberType packetNumber);
 
 	// Acknowledge receipt of the packet with the specified packetNumber
-	void SendAcknowledgementPacket(PacketNumberType packetNumber);
+	void SendAcknowledgementPacket(PacketNumberType packetNumber, unsigned long time);
 
 	// This will return true if we should not send at this time
 	bool IsSendThrottled(void);
 
 	// We lost a packet
-	void UpdatePacketloss(void);
+	void UpdatePacketloss(unsigned long time);
 
 	// Parse an internalPacket and figure out how many header bits would be written.  Returns that number
 	int GetBitStreamHeaderLength(const InternalPacket *const internalPacket);
@@ -137,10 +138,10 @@
 	// Check the SHA1 code
 	bool CheckSHA1(char code[SHA1_LENGTH], unsigned char * const buffer, unsigned long nbytes);
 
-	// Search the specified list for sequenced packets on the specified ordering stream, optionally skipping those with splitPacketId, and delete them
-	void  DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId=-1);
+	// Search the specified list for sequenced packets on the specified ordering channel, optionally skipping those with splitPacketId, and delete them
+	void  DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::List<InternalPacket*>&theList, int splitPacketId=-1);
 	// Search the specified list for sequenced packets with a value less than orderingIndex and delete them
-	void DeleteSequencedPacketsInList(unsigned char orderingStream, BasicDataStructures::Queue<InternalPacket*>&theList);
+	void DeleteSequencedPacketsInList(unsigned char orderingChannel, BasicDataStructures::Queue<InternalPacket*>&theList);
 
 	// Returns true if newPacketOrderingIndex is older than the waitingForPacketOrderingIndex
 	bool IsOlderOrderedPacket(unsigned char newPacketOrderingIndex, unsigned char waitingForPacketOrderingIndex);
@@ -152,15 +153,18 @@
 	void InsertIntoSplitPacketList(InternalPacket * internalPacket);
 
 	// Take all split chunks with the specified splitPacketId and try to reconstruct a packet.  If we can, allocate and return it.  Otherwise return 0
-	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId);
+	InternalPacket * BuildPacketFromSplitPacketList(unsigned long splitPacketId,unsigned long time);
 
+	// Delete any unreliable split packets that have long since expired
+	void DeleteOldUnreliableSplitPackets(unsigned long time);
+
 	// Creates a copy of the specified internal packet with data copied from the original starting at dataByteOffset for dataByteLength bytes.
 	// Does not copy any split data parameters as that information is always generated does not have any reason to be copied
-	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength);
+	InternalPacket * CreateInternalPacketCopy(InternalPacket *original, int dataByteOffset, int dataByteLength, unsigned long time);
 
 	// Get the specified ordering list
 	// LOCK THIS WHOLE BLOCK WITH reliabilityLayerMutexes[orderingList_MUTEX].Unlock();
-	BasicDataStructures::LinkedList<InternalPacket*> *GetOrderingListAtOrderingStream(unsigned char orderingStream);
+	BasicDataStructures::LinkedList<InternalPacket*> *GetOrderingListAtOrderingStream(unsigned char orderingChannel);
 
 	// Add the internal packet to the ordering list in order based on order index
 	void AddToOrderingList(InternalPacket * internalPacket);
@@ -168,10 +172,12 @@
 	// Inserts a packet into the resend list in order
 	// THIS WHOLE FUNCTION SHOULD BE LOCKED WITH
 	// reliabilityLayerMutexes[resendQueue_MUTEX].Lock();
-	void InsertPacketIntoResendQueue(InternalPacket *internalPacket);
+	void InsertPacketIntoResendQueue(InternalPacket *internalPacket, unsigned long time);
 
-	// Frees all allocated memory
-	void FreeMemory(void);
+	// Memory handling
+	void FreeMemory(bool freeAllImmediately);
+	void FreeThreadedMemory(void);
+	void FreeThreadSafeMemory(void);
 	
 	// Initialize the variables
 	void InitializeVariables(void);
@@ -179,16 +185,19 @@
 	// STUFF TO MUTEX HERE
 	enum
 	{
-		splitPacketList_MUTEX,
-		sendQueue_MUTEX,
-		resendQueue_MUTEX,
-		orderingList_MUTEX,
-		acknowledgementQueue_MUTEX,
-		outputQueue_MUTEX,
+		// splitPacketList_MUTEX, // We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		sendQueueSystemPriority_MUTEX,
+		sendQueueHighPriority_MUTEX,
+		sendQueueMediumPriority_MUTEX,
+		sendQueueLowPriority_MUTEX,
+		//resendQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//orderingList_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//acknowledgementQueue_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		// outputQueue_MUTEX,// We don't have to mutex this as long as Recieve and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		packetNumber_MUTEX,
-		windowSize_MUTEX,
-		lastAckTime_MUTEX,
-		updateBitStream_MUTEX,
+		// windowSize_MUTEX, // Causes long delays for some reason
+		//lastAckTime_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
+		//updateBitStream_MUTEX,// We don't have to mutex this as long as Update and HandleSocketReceiveFromConnectedPlayer are called by the same thread
 		waitingForOrderedPacketWriteIndex_MUTEX,
 		waitingForSequencedPacketWriteIndex_MUTEX,
 		NUMBER_OF_RELIABILITY_LAYER_MUTEXES
@@ -202,7 +211,7 @@
 	PacketNumberType packetNumber;
 	//unsigned long windowSize;
 	unsigned long lastAckTime;
-	BitStream updateBitStream;
+	RakNet::BitStream updateBitStream;
 	unsigned char waitingForOrderedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS], waitingForSequencedPacketWriteIndex[NUMBER_OF_ORDERED_STREAMS];
 	// Used for flow control (changed to regular TCP sliding window)
 	//	unsigned long maximumWindowSize, bytesSentSinceAck;
@@ -211,11 +220,12 @@
 	// STUFF TO NOT MUTEX HERE (called from non-conflicting threads, or value is not important)
 	unsigned char waitingForOrderedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS],waitingForSequencedPacketReadIndex[NUMBER_OF_ORDERED_STREAMS];
 	bool deadConnection, cheater;
-	unsigned long lastPacketSendTime,retransmittedPackets, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
+//	unsigned long lastPacketSendTime,retransmittedFrames, sentPackets, sentFrames, receivedPacketsCount, bytesSent, bytesReceived,lastPacketReceivedTime;
 	unsigned long lostPacketResendDelay;
 	unsigned long splitPacketId;
 	unsigned long receivedPackets[RECEIVED_PACKET_LOG_LENGTH];
 	unsigned long blockWindowIncreaseUntilTime;
+	RakNetStatisticsStruct statistics;
 
 	// Windowing algorithm:
 	// Start at a minimum size
@@ -231,6 +241,8 @@
 	#ifdef __USE_IO_COMPLETION_PORTS
 	SOCKET readWriteSocket;
 	#endif
+
+	bool freeThreadedMemoryOnNextUpdate; // This variable is so that free memory can be called by only the update thread so we don't have to mutex things so much
 };
 
 #endif

Modified: trunk/source/libraries/raknet/SHA1.h
===================================================================
--- trunk/source/libraries/raknet/SHA1.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SHA1.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -21,11 +21,8 @@
 #include <stdio.h> // Needed for file access
 #include <memory.h> // Needed for memset and memcpy
 #include <string.h> // Needed for strcat and strcpy
+#include "Types.h"
 
-#ifdef _WINDOWS
-#define LITTLE_ENDIAN
-#endif
-
 #define MAX_FILE_READ_BUFFER 8000
 #define SHA1_LENGTH 20
 
@@ -33,7 +30,7 @@
 {
 public:
 	// Rotate x bits to the left
-	#define ROL32(value, bits) (((value)<<(bits))|((value)>>(32-(bits))))
+//	#define ROL32(value, bits) (((value)<<(bits))|((value)>>(32-(bits))))
 
 	#ifdef LITTLE_ENDIAN
 		#define SHABLK0(i) (block->l[i] = (ROL32(block->l[i],24) & 0xFF00FF00) \

Modified: trunk/source/libraries/raknet/SimpleMutex.cpp
===================================================================
--- trunk/source/libraries/raknet/SimpleMutex.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SimpleMutex.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -14,8 +14,9 @@
 SimpleMutex::SimpleMutex()
 {
 #ifdef _WIN32
-	hMutex = CreateMutex(NULL, FALSE, 0);
-	assert(hMutex);
+//	hMutex = CreateMutex(NULL, FALSE, 0);
+//	assert(hMutex);
+	InitializeCriticalSection(&criticalSection);
 #else
 	int error = pthread_mutex_init(&hMutex, 0);
 	assert(error==0);
@@ -25,7 +26,8 @@
 SimpleMutex::~SimpleMutex()
 {
 #ifdef _WIN32
-	CloseHandle(hMutex);
+//	CloseHandle(hMutex);
+	DeleteCriticalSection(&criticalSection);
 #else
 	pthread_mutex_destroy(&hMutex);
 #endif
@@ -40,6 +42,7 @@
 void SimpleMutex::Lock(void)
 {
 	#ifdef _WIN32
+	/*
 	DWORD d = WaitForSingleObject(hMutex, INFINITE);
 	#ifdef _DEBUG
 	if (d==WAIT_FAILED)
@@ -67,7 +70,9 @@
 	}
 
 	assert(d==WAIT_OBJECT_0);
-	#endif
+	*/
+	EnterCriticalSection(&criticalSection);
+
 	#else
 	int error = pthread_mutex_lock(&hMutex);
 	assert(error==0);
@@ -77,7 +82,8 @@
 void SimpleMutex::Unlock(void)
 {
 #ifdef _WIN32
-	ReleaseMutex(hMutex);
+//	ReleaseMutex(hMutex);
+	LeaveCriticalSection(&criticalSection);
 #else
 	int error = pthread_mutex_unlock(&hMutex);
 	assert(error==0);

Modified: trunk/source/libraries/raknet/SimpleMutex.h
===================================================================
--- trunk/source/libraries/raknet/SimpleMutex.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SimpleMutex.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -26,7 +26,8 @@
 	void Unlock(void);
 private:
 	#ifdef _WIN32
-	HANDLE hMutex;
+	//HANDLE hMutex;
+	CRITICAL_SECTION criticalSection; // Docs say this is faster than a mutex for single process access
 	#else
 	pthread_mutex_t hMutex;
 	#endif

Modified: trunk/source/libraries/raknet/SocketLayer.cpp
===================================================================
--- trunk/source/libraries/raknet/SocketLayer.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SocketLayer.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -17,6 +17,7 @@
 #else
 #include <string.h> // memcpy
 #include <unistd.h>
+#include <fcntl.h>
 #endif
 
 #include "ExtendedOverlappedPool.h"
@@ -75,14 +76,14 @@
 	}
 }
 
-SOCKET SocketLayer::Connect(SOCKET writeSocket, PlayerID playerId)
+SOCKET SocketLayer::Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port)
 {
 	assert(writeSocket!=INVALID_SOCKET);
 	sockaddr_in connectSocketAddress;
 
 	connectSocketAddress.sin_family = AF_INET;
-	connectSocketAddress.sin_port = htons(playerId.port);
-	connectSocketAddress.sin_addr.s_addr = playerId.binaryAddress;
+	connectSocketAddress.sin_port = htons(port);
+	connectSocketAddress.sin_addr.s_addr = binaryAddress;
 
 	if (connect(writeSocket, (struct sockaddr *)&connectSocketAddress, sizeof(struct sockaddr)) != 0)
 	{
@@ -147,6 +148,38 @@
 		#endif
 	}
 
+	//Set non-blocking
+#ifdef _WIN32
+	unsigned long nonblocking = 1;
+	if (ioctlsocket(listenSocket, FIONBIO, &nonblocking)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#else
+	if (fcntl(listenSocket, F_SETFL, O_NONBLOCK)!=0)
+	{
+		assert(0);
+		return INVALID_SOCKET;
+	}
+#endif
+
+	// Set broadcast capable
+	if ( setsockopt(listenSocket, SOL_SOCKET, SO_BROADCAST,(char *)&sock_opt, sizeof(sock_opt)) == -1)
+	{
+#if defined(_WIN32) && defined(_DEBUG)
+		DWORD dwIOError = GetLastError();
+		LPVOID messageBuffer;
+		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 	  FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
+			NULL, dwIOError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),// Default language
+			(LPTSTR) &messageBuffer, 0, NULL); 
+		// something has gone wrong here... 
+		printf("setsockopt(SO_BROADCAST) failed:Error code - %d\n%s",dwIOError, messageBuffer ); 
+		//Free the buffer. 
+		LocalFree(messageBuffer ); 
+#endif
+	}
+
 	// Listen on our designated Port#
 	listenerSocketAddress.sin_port = htons(port);
 
@@ -209,7 +242,7 @@
 }
 
 // Start an asynchronous read using the specified socket.
-bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer *rakPeer)
+bool SocketLayer::AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer *rakPeer)
 {
 	#ifdef __USE_IO_COMPLETION_PORTS
 	assert(readSocket!=INVALID_SOCKET);
@@ -219,7 +252,8 @@
 
 	ExtendedOverlappedStruct* eos = ExtendedOverlappedPool::Instance()->GetPointer();
 	memset(&(eos->overlapped), 0, sizeof(OVERLAPPED));
-	eos->playerId=playerId;
+	eos->binaryAddress=binaryAddress;
+	eos->port=port;
 	eos->rakPeer=rakPeer;
 	eos->length=MAXIMUM_MTU_SIZE;
 
@@ -239,13 +273,8 @@
 	return true;
 }
 
-int SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer)
+bool SocketLayer::RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode)
 {
-	if (s==INVALID_SOCKET)
-	{
-		return SOCKET_ERROR;
-	}
-
 	int len;
 	char data[MAXIMUM_MTU_SIZE];
 	sockaddr_in sa;
@@ -260,6 +289,12 @@
 	sa.sin_addr.s_addr=0;
 #endif
 
+	if (s==INVALID_SOCKET)
+	{
+		*errorCode=SOCKET_ERROR;
+		return false;
+	}
+
 	len = recvfrom(s, data, MAXIMUM_MTU_SIZE, 0, (sockaddr*)&sa, (socklen_t*)&len2);
 
 //	if (len>0)
@@ -269,9 +304,10 @@
 	{
 #ifdef _DEBUG
 		printf("Error: recvfrom returned 0 on a connectionless blocking call\non port %i.  This is a bug with Zone Alarm.  Please turn off Zone Alarm.\n",ntohs(sa.sin_port));
-#endif
 		assert(0);
-		return 0;
+#endif		
+		*errorCode=SOCKET_ERROR;
+		return false;
 	}
 
 	if (len!=SOCKET_ERROR)
@@ -282,13 +318,20 @@
 		//	strcpy(ip, "127.0.0.1");
         ProcessNetworkPacket(sa.sin_addr.s_addr, portnum,data, len, rakPeer);
 
-		return 0;
+		return true;
 	}
 	else
 	{
 
-#if defined(_WIN32)
+		*errorCode=0;
+
+#if defined(_WIN32) && defined(_DEBUG)
 		DWORD dwIOError = WSAGetLastError();
+		
+		if (dwIOError == WSAEWOULDBLOCK)
+		{
+			return false;
+		}
 
 		if (dwIOError==WSAECONNRESET)
 		{
@@ -296,7 +339,8 @@
 			printf("A previous send operation resulted in an ICMP Port Unreachable message.\n");
 			#endif
 
-			return dwIOError;
+			*errorCode=dwIOError;
+			return false;
 		}
 		else
 		{
@@ -319,10 +363,10 @@
 #endif
 	}
 
-	return 0;
+	return false;
 }
 
-int SocketLayer::SendTo(SOCKET s, char *data, int length, PlayerID playerId)
+int SocketLayer::SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port)
 {
 	if (s==INVALID_SOCKET)
 	{
@@ -331,8 +375,8 @@
 
 	int len;
 	sockaddr_in sa;
-	sa.sin_port = htons(playerId.port);
-	sa.sin_addr.s_addr = playerId.binaryAddress;
+	sa.sin_port = htons(port);
+	sa.sin_addr.s_addr = binaryAddress;
 	sa.sin_family = AF_INET;
 	do {
 		len = sendto(s, data, length, 0, (const sockaddr*)&sa, sizeof(struct sockaddr_in));
@@ -374,10 +418,9 @@
 
 int SocketLayer::SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port)
 {
-	PlayerID temp;
-	temp.binaryAddress=inet_addr(ip);
-	temp.port=port;
-	return SendTo(s,data,length,temp);
+	unsigned long binaryAddress;
+	binaryAddress=inet_addr(ip);
+	return SendTo(s,data,length,binaryAddress,port);
 }
 
 void SocketLayer::GetMyIP(char ipList[10][16])

Modified: trunk/source/libraries/raknet/SocketLayer.h
===================================================================
--- trunk/source/libraries/raknet/SocketLayer.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/SocketLayer.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -37,21 +37,20 @@
 	SocketLayer();
 	~SocketLayer();
 	static inline SocketLayer* Instance() {return &I;}
-	SOCKET Connect(SOCKET writeSocket, PlayerID playerId);
+	SOCKET Connect(SOCKET writeSocket, unsigned long binaryAddress, unsigned short port);
 	SOCKET CreateBoundSocket(unsigned short port, bool blockingSocket); // Creates a socket to listen for incoming connections on the specified port
 	const char* DomainNameToIP(const char *domainName);
 	#ifdef __USE_IO_COMPLETION_PORTS
 	void AssociateSocketWithCompletionPort(SOCKET socket, ClientContextStruct* completionKey);
 #endif
 	// Start an asynchronous read using the specified socket.  The callback will use the specified PlayerID (associated with this socket) and call either the client or the server callback (one or the other should be 0)
-	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, PlayerID playerId, RakPeer* rakPeer);
+	bool AssociateSocketWithCompletionPortAndRead(SOCKET readSocket, unsigned long binaryAddress, unsigned short port, RakPeer* rakPeer);
 	void Write(SOCKET writeSocket, const char* data, int length);
-	// Given a listen socket and an event object triggered when a new connection occurs, return the new socket of the new connection along with the IP and port of the caller
-	// Returns the error code on failure, 0 on success
-	int RecvFrom(SOCKET s, RakPeer *rakPeer);
+	// Returns true if you successfully read data
+	bool RecvFrom(SOCKET s, RakPeer *rakPeer, int *errorCode);
 	void GetMyIP(char ipList[10][16]);
 	int SendTo(SOCKET s, char *data, int length, char ip[16], unsigned short port);
-	int SendTo(SOCKET s, char *data, int length, PlayerID playerId);
+	int SendTo(SOCKET s, char *data, int length, unsigned long binaryAddress, unsigned short port);
 	
 	private:
 	static bool socketLayerStarted;

Modified: trunk/source/libraries/raknet/StringCompressor.cpp
===================================================================
--- trunk/source/libraries/raknet/StringCompressor.cpp	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/StringCompressor.cpp	2004-11-28 17:15:55 UTC (rev 101)
@@ -3,10 +3,12 @@
 #include "BitStream.h"
 #include <assert.h>
 #include <string.h>
+#include <memory.h>
 
 StringCompressor StringCompressor::instance;
 
-unsigned long englishCharacterFrequencies[] =
+// Generated from various chat logs on the internet.
+unsigned long englishCharacterFrequencies[256] =
 {
 0,
 0,
@@ -18,9 +20,10 @@
 0,
 0,
 0,
-5655,
+722,
 0,
 0,
+2,
 0,
 0,
 0,
@@ -39,101 +42,101 @@
 0,
 0,
 0,
+11084,
+58,
+63,
+1,
 0,
-64995,
-2,
-515,
-3,
-3,
-5,
-13,
-125,
-289,
-294,
+31,
 0,
+317,
+64,
+64,
+44,
 0,
-1968,
-558,
-4849,
-91,
-244,
-795,
-459,
-323,
-379,
-210,
-155,
-138,
-280,
-590,
-150,
-46,
-4,
-3,
-4,
+695,
+62,
+980,
+266,
 69,
-28,
-595,
-161,
-950,
-364,
-430,
-326,
-221,
-308,
-712,
-189,
+67,
 56,
-181,
-318,
-426,
-256,
-676,
+7,
+73,
+3,
 14,
-458,
-1247,
-853,
-253,
-105,
-297,
-53,
-81,
 2,
-235,
-0,
-235,
-0,
+69,
+1,
+167,
+9,
+1,
 2,
+25,
+94,
 0,
-11400,
-2156,
-6665,
-5543,
-19692,
-3186,
-2759,
-5614,
-12742,
+195,
+139,
+34,
+96,
+48,
+103,
+56,
+125,
+653,
+21,
+5,
+23,
+64,
+85,
+44,
+34,
+7,
+92,
+76,
+147,
+12,
+14,
 57,
-1191,
-6009,
-4271,
-11288,
-13376,
-3619,
-106,
-10492,
-12069,
-14885,
-5462,
-1664,
-1850,
-265,
-3591,
-169,
+15,
+39,
+15,
+1,
+1,
+1,
+2,
+3,
 0,
+3611,
+845,
+1077,
+1884,
+5870,
+841,
+1057,
+2501,
+3212,
+164,
+531,
+2019,
+1330,
+3056,
+4037,
+848,
+47,
+2586,
+2919,
+4771,
+1707,
+535,
+1106,
+152,
+1243,
+100,
 0,
+2,
 0,
+10,
 0,
 0,
 0,
@@ -262,12 +265,12 @@
 0,
 0,
 0,
-0,
 0
 };
 
 StringCompressor::StringCompressor()
 {
+	huffmanEncodingTree=0;
 }
 
 void StringCompressor::GenerateHuffmanEncodingTree(void)
@@ -275,18 +278,41 @@
 	huffmanEncodingTree = new HuffmanEncodingTree;
 	huffmanEncodingTree->GenerateFromFrequencyTable(englishCharacterFrequencies);
 }
+void StringCompressor::GenerateTreeFromStrings(unsigned char *input, unsigned inputLength)
+{
+	unsigned index;
+	unsigned long frequencyTable[256];
+
+	if (inputLength==0)
+		return;
+
+	// Zero out the frequency table
+	memset(frequencyTable, 0, sizeof(frequencyTable));
+
+	// Generate the frequency table from the strings
+	for (index=0; index < inputLength; index++);
+		frequencyTable[input[index]]++;
+
+	// Delete the old tree, if there is done
+	if (huffmanEncodingTree)
+		delete huffmanEncodingTree;
+
+	// Build the tree
+	huffmanEncodingTree = new HuffmanEncodingTree;
+	huffmanEncodingTree->GenerateFromFrequencyTable(frequencyTable);
+}
 StringCompressor::~StringCompressor()
 {
 	if (huffmanEncodingTree)
 		delete huffmanEncodingTree;
 }
 
-void StringCompressor::EncodeString(char *input, int maxCharsToWrite, BitStream *output)
+void StringCompressor::EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output)
 {
 	if (input==0)
 		return;
 
-	BitStream encodedBitStream;
+	RakNet::BitStream encodedBitStream;
 	unsigned short stringBitLength;
 	int charsToWrite;
 
@@ -300,12 +326,12 @@
 
 	huffmanEncodingTree->EncodeArray((unsigned char*) input, charsToWrite, &encodedBitStream);
 
-	stringBitLength = encodedBitStream.GetNumberOfBitsUsed();
+	stringBitLength = (unsigned short)encodedBitStream.GetNumberOfBitsUsed();
 	output->WriteCompressed(stringBitLength);
 	output->WriteBits(encodedBitStream.GetData(), stringBitLength);
 }
 
-void StringCompressor::DecodeString(char *output, int maxCharsToWrite, BitStream *input)
+bool StringCompressor::DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input)
 {
 	unsigned short stringBitLength;
 	int bytesInStream;
@@ -315,14 +341,18 @@
 
 	output[0]=0;
 
-	
 	if (input->ReadCompressed(stringBitLength)==false)
-		return;
+		return false;
 
+	if (input->GetNumberOfUnreadBits() < stringBitLength)
+		return false;
+
 	bytesInStream=huffmanEncodingTree->DecodeArray(input, stringBitLength, maxCharsToWrite, (unsigned char*) output);
 	if (bytesInStream < maxCharsToWrite)
 		output[bytesInStream]=0;
 	else
 		output[maxCharsToWrite-1]=0;
+
+	return true;
 }
 

Modified: trunk/source/libraries/raknet/StringCompressor.h
===================================================================
--- trunk/source/libraries/raknet/StringCompressor.h	2004-11-28 11:51:35 UTC (rev 100)
+++ trunk/source/libraries/raknet/StringCompressor.h	2004-11-28 17:15:55 UTC (rev 101)
@@ -3,8 +3,8 @@
 #ifndef __STRING_COMPRESSOR_H
 #define __STRING_COMPRESSOR_H
 
+#include "BitStream.h"
 class HuffmanEncodingTree;
-class BitStream;
 
 class StringCompressor
 {
@@ -14,12 +14,17 @@
 	// static function because only static functions can access static members
 	static inline StringCompressor* Instance() {return &instance;}
 
+	// Given an array of strings, such as a chat log, generate the optimal encoding tree for it.
+	// This function is optional and if it is not called a default tree will be used instead.
+	void GenerateTreeFromStrings(unsigned char *input, unsigned inputLength);
+
 	// Writes input to output, compressed.  Takes care of the null terminator for you
-	void EncodeString(char *input, int maxCharsToWrite, BitStream *output);
+	void EncodeString(char *input, int maxCharsToWrite, RakNet::BitStream *output);
 
 	// Writes input to output, uncompressed.  Takes care of the null terminator for you.
 	// maxCharsToWrite should be the allocated size of output
-	void DecodeString(char *output, int maxCharsToWrite, BitStream *input);
+	bool DecodeString(char *output, int maxCharsToWrite, RakNet::BitStream *input);
+
 private:
 	void GenerateHuffmanEncodingTree(void);
 	StringCompressor();



From yurand at sheep.berlios.de  Sun Nov 28 18:18:26 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 28 Nov 2004 18:18:26 +0100
Subject: [Tw-light-svn] r102 - trunk/source/libraries/raknet
Message-ID: <200411281718.iASHIQlQ014943@sheep.berlios.de>

Author: yurand
Date: 2004-11-28 18:18:25 +0100 (Sun, 28 Nov 2004)
New Revision: 102

Added:
   trunk/source/libraries/raknet/BigTypes.h
   trunk/source/libraries/raknet/RSACrypt.h
   trunk/source/libraries/raknet/RakNetStatistics.cpp
   trunk/source/libraries/raknet/RakNetStatistics.h
   trunk/source/libraries/raknet/Types.h
Log:
Updating RakNet sources


Added: trunk/source/libraries/raknet/BigTypes.h
===================================================================
--- trunk/source/libraries/raknet/BigTypes.h	2004-11-28 17:15:55 UTC (rev 101)
+++ trunk/source/libraries/raknet/BigTypes.h	2004-11-28 17:18:25 UTC (rev 102)
@@ -0,0 +1,1609 @@
+/*
+	(128)2^7-bit to (32768)2^14-bit signed 2's complement & unsigned extended arithmetic
+
+	catid(cat02e at fsu.edu)
+
+	7/30/2004	Fixed VS6 compat
+	7/28/2004	Fixed macros so they can be used outside of the big namespace
+				Now using pre-processor definitions from types.h for inline assembly
+	7/26/2004	Removed a lot of assembly, made add/sub assembly optional
+	7/25/2004	Merged the wrapper class Int<T> from older code
+	7/24/2004	Replaced trivial assembly code with std:: functions
+				Refined some assembly code with Art of Assembly chapter 9
+				Added binary ops
+	7/23/2004	Finished assembly coding
+				Removed Int<T> class, for now
+				Added old C++ code back in with USEASSEMBLY
+	7/22/2004	Signed arithmetic (needed for ext. Euclidean algo)
+				Cleaned up coding style
+				Began rewriting parts in assembly
+	7/21/2004	Began writing
+
+	Tabs: 4 spaces
+	Dist: public
+*/
+
+#ifndef BIGTYPES_H
+#define BIGTYPES_H
+
+#include "Types.h"
+
+//#define BIG_USES_STRINGS /* undefining this means you cannot convert bigs to strings or from strings */
+
+#ifdef BIG_USES_STRINGS
+#	include <string>
+#endif
+
+namespace big
+{
+	using namespace cat;
+
+	//// basic definitions ////
+
+	// word size
+	typedef u32 word; // assembly implementation is for 32-bit word size
+	const u32 WORDBITS = sizeof(word) * 8;
+	const u32 HALFWORDBITS = sizeof(word) * 8 / 2;
+	const word WORDHIGHBIT = (word)1 << (WORDBITS - 1);
+	const word WORDALLBITS = (word)0 - 1;
+	const word WORDLOBITS = ((word)1 << HALFWORDBITS) - 1;
+	const word WORDHIBITS = WORDALLBITS ^ WORDLOBITS;
+#define BIGHIGHBIT(n) ((n)[sizeof(n) / sizeof(big::word) - 1] & WORDHIGHBIT)
+
+	// template operator parameter modes
+#define BIGONETYPE template<class T> /* supports only one class */
+#define BIGTWOTYPES template<class T, class Bigger> /* sizeof Bigger >= sizeof T */
+#define BIGSMALLTYPE template<class Smaller> /* sizeof self >= sizeof Smaller */
+
+
+	//// big types ////
+
+#define BIGWORDCOUNT_FROMBITCOUNT(bits) ((bits) / 8 / sizeof(big::word))
+#define BIGWORDCOUNT(T) (sizeof(T) / sizeof(big::word))
+#define BIGBITCOUNT(T) (sizeof(T) * 8)
+
+	// low words -- [0] < [1] < [2] < [3] -- high words
+	typedef word u128[BIGWORDCOUNT_FROMBITCOUNT(128)];
+	typedef word u256[BIGWORDCOUNT_FROMBITCOUNT(256)];
+	typedef word u512[BIGWORDCOUNT_FROMBITCOUNT(512)];
+	typedef word u1024[BIGWORDCOUNT_FROMBITCOUNT(1024)];
+	typedef word u2048[BIGWORDCOUNT_FROMBITCOUNT(2048)];
+	typedef word u4096[BIGWORDCOUNT_FROMBITCOUNT(4096)];
+	typedef word u8192[BIGWORDCOUNT_FROMBITCOUNT(8192)];
+	typedef word u16384[BIGWORDCOUNT_FROMBITCOUNT(16384)];
+	typedef word u32768[BIGWORDCOUNT_FROMBITCOUNT(32768)];
+
+	// use these macros to create temporary variables when
+	// those variables are to be twice/half the size of another
+	// variable of varying size.
+#define BIGDOUBLESIZE(T, var_name) big::word (var_name)[BIGWORDCOUNT(T) * 2] /* WARNING: invalid w/ u32768 */
+#define BIGHALFSIZE(T, var_name) big::word (var_name)[BIGWORDCOUNT(T) / 2] /* WARNING: invalid w/ u128 */
+
+
+	//// library summary ////
+
+	// assignment
+	BIGONETYPE INLINE void zero(T &n); // n = 0
+	BIGONETYPE INLINE void usetw(T &a, word b); // a = b, zero-extend
+	BIGONETYPE INLINE void ssetw(T &a, word b); // a = b, sign-extend
+	BIGONETYPE INLINE void set(T &a, T &b); // a = b
+	BIGTWOTYPES INLINE void usetlow(Bigger &a, T &b); // a_low = b (zero-extend)
+	BIGTWOTYPES INLINE void ssetlow(Bigger &a, T &b); // a_low = b (sign-extend)
+	BIGTWOTYPES INLINE void sethigh(Bigger &a, T &b); // a_high = b
+	BIGTWOTYPES INLINE void takelow(T &a, Bigger &b); // a = b_low
+	BIGTWOTYPES INLINE void takehigh(T &a, Bigger &b); // a = b_high
+
+	// comparison
+	BIGONETYPE bool ugreater(T &a, T &b); // a > b (unsigned)
+	BIGONETYPE bool ugreaterOrEqual(T &a, T &b); // a >= b (unsigned)
+	BIGONETYPE bool sgreater(T &a, T &b); // a > b (signed)
+	BIGONETYPE bool sgreaterOrEqual(T &a, T &b); // a >= b (signed)
+	BIGONETYPE INLINE bool equal(T &a, T &b); // a == b
+	BIGONETYPE INLINE bool isZero(T &n); // a == 0
+
+	// binary
+	BIGONETYPE void bAND(T &a, T &b); // a &= b
+	BIGONETYPE void bOR(T &a, T &b); // a |= b
+	BIGONETYPE void bXOR(T &a, T &b); // a ^= b
+	BIGONETYPE void bNOT(T &n); // n = ~n
+
+	// shifting
+	BIGONETYPE void shiftLeft1(T &n); // n <<= 1
+	BIGONETYPE void shiftLeft(T &n, u32 s); // n <<= s (s <= WORDBITS)
+	BIGONETYPE void ushiftRight1(T &n); // n >>= 1 (unsigned)
+	BIGONETYPE void ushiftRight(T &n, u32 s); // n >>= s (unsigned) (s <= WORDBITS)
+	BIGONETYPE void sshiftRight1(T &n); // n >>= 1 (signed)
+	BIGONETYPE void sshiftRight(T &n, u32 s); // n >>= s (signed) (s <= WORDBITS)
+
+	// addition/subtraction
+	BIGONETYPE void add(T &a, T &b); // a += b
+	BIGONETYPE void increment(T &n); // ++n
+	BIGONETYPE void subtract(T &a, T &b); // a -= b
+	BIGONETYPE void decrement(T &n); // --n
+
+	// negation
+	BIGONETYPE void negate(T &n); // n = -n
+
+	// multiplication
+	BIGONETYPE void usquare(T &a); // a *= a, signed
+	BIGTWOTYPES void umultiply(T &a, T &b, Bigger &m); // m = a * b (&a != &b != &m), unsigned
+	BIGTWOTYPES void umultiply(Bigger &a, T &b); // a *= b (&a != &b), unsigned
+	BIGONETYPE void ssquare(T &a); // a *= a, signed
+	BIGTWOTYPES void smultiply(T &a, T &b, Bigger &m); // m = a * b (&a != &b != &m), signed
+	BIGTWOTYPES void smultiply(Bigger &a, T &b); // a *= b (&a != &b), signed
+
+	// division/remainder
+	BIGONETYPE void udivide(T &a, T &b, T &q, T &r); // {q, r} = a / b (&q != &r), unsigned
+	BIGONETYPE void umodulo(T &a, T &b, T &r); // r = a Mod b, unsigned
+	BIGONETYPE void sdivide(T &a, T &b, T &q, T &r); // {q, r} = a / b (&q != &r), signed
+	BIGONETYPE void smodulo(T &a, T &b, T &r); // r = a Mod b, signed
+
+#ifdef BIG_USES_STRINGS
+	// converting to/from strings
+	BIGONETYPE std::string toString(T &n, bool sign, u16 radix); // n -> string
+	BIGONETYPE void fromString(std::string s, T &n, bool sign, u16 radix); // s -> n
+#endif
+
+
+	//////// wrapper class ////////
+
+#define BIGINTFAST INLINE Int<T> & /* operation is done to self, returns itself */
+#define BIGINTSLOW Int<T> /* new object is created and returned */
+
+	BIGONETYPE class Int
+	{
+	protected:
+		T raw;
+
+	public:
+		operator T &(); // automatic casting to T: you may use BigInt classes as parameters to the functions
+
+	public:
+		Int();
+		Int(word n);
+#ifdef BIG_USES_STRINGS
+		Int(std::string &s);
+#endif
+		Int(T &n);
+
+	public:
+		BIGINTFAST zero();
+		BIGINTFAST operator=(word n);
+		BIGINTFAST operator=(T &n);
+
+	public:
+		BIGINTFAST operator<<=(u32 s);
+		BIGINTSLOW operator<<(u32 s);
+		BIGINTFAST operator>>=(u32 s);
+		BIGINTSLOW operator>>(u32 s);
+
+	public:
+		BIGINTFAST operator+=(T &n);
+		BIGINTSLOW operator+(T &n);
+		BIGINTFAST operator-=(T &n);
+		BIGINTSLOW operator-(T &n);
+		BIGINTFAST operator++(); // prefix
+		BIGINTSLOW operator++(int); // postfix
+		BIGINTFAST operator--(); // prefix
+		BIGINTSLOW operator--(int); // postfix
+
+	public:
+		BIGINTSLOW operator-(int); // negation
+
+	public:
+		BIGSMALLTYPE BIGINTFAST operator*=(Smaller &n)
+		{
+			smultiply(raw, n);
+			return *this;
+		}
+		BIGINTSLOW operator*(T &n);
+		BIGINTFAST square();
+
+	public:
+		BIGINTFAST operator/=(T &n);
+		BIGINTSLOW operator/(T &n);
+		BIGINTFAST operator%=(T &n);
+		BIGINTSLOW operator%(T &n);
+
+	public:
+		/* fast */ bool operator>(T &n);
+		/* fast */ bool operator>=(T &n);
+		/* fast */ bool operator<(T &n);
+		/* fast */ bool operator<=(T &n);
+		/* fast */ bool operator==(T &n);
+		/* fast */ bool operator!=(T &n);
+		/* fast */ bool operator!();
+
+	public:
+#ifdef BIG_USES_STRINGS
+		/* fast */ std::string str();
+		BIGINTFAST operator=(std::string &s);
+		BIGINTFAST operator=(const char *s);
+#endif
+	};
+
+
+	//////// assignment ////////
+
+	// n = 0
+	BIGONETYPE INLINE void zero(T &n)
+	{
+		memset(n, 0, sizeof(T));
+	}
+
+	// a = b, zero-extend
+	BIGONETYPE INLINE void usetw(T &a, word b)
+	{
+		a[0] = b;
+		memset(a + 1, 0, sizeof(T) - sizeof(word));
+	}
+
+	// a = b, sign-extend
+	BIGONETYPE INLINE void ssetw(T &a, word b)
+	{
+		a[0] = b;
+		memset(a + 1, (b & WORDHIGHBIT) ? WORDALLBITS : 0, sizeof(T) - sizeof(word));
+	}
+
+	// a = b
+	BIGONETYPE INLINE void set(T &a, T &b)
+	{
+		memcpy(a, b, sizeof(T));
+	}
+
+	// a_low = b (zero-extend)
+	BIGTWOTYPES INLINE void usetlow(Bigger &a, T &b)
+	{
+		memcpy(a, b, sizeof(T));
+		memset(a + BIGWORDCOUNT(T), 0, sizeof(Bigger) - sizeof(T));
+	}
+
+	// a_low = b (sign-extend)
+	BIGTWOTYPES INLINE void ssetlow(Bigger &a, T &b)
+	{
+		memcpy(a, b, sizeof(T));
+		memset(a + BIGWORDCOUNT(T), BIGHIGHBIT(b) ? WORDALLBITS : 0, sizeof(Bigger) - sizeof(T));
+	}
+
+	// a_high = b
+	BIGTWOTYPES INLINE void sethigh(Bigger &a, T &b)
+	{
+		memcpy(a + BIGWORDCOUNT(Bigger) - BIGWORDCOUNT(T), b, sizeof(T));
+		memset(a, 0, sizeof(Bigger) - sizeof(T));
+	}
+
+	// a = b_low
+	BIGTWOTYPES INLINE void takelow(T &a, Bigger &b)
+	{
+		memcpy(a, b, sizeof(T));
+	}
+
+	// a = b_high
+	BIGTWOTYPES INLINE void takehigh(T &a, Bigger &b)
+	{
+		memcpy(a, b + BIGWORDCOUNT(Bigger) - BIGWORDCOUNT(T), sizeof(T));
+	}
+
+
+	//////// comparison ////////
+
+	// a > b
+	BIGONETYPE bool ugreater(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return true;
+			if (a[ii] < b[ii]) return false;
+		}
+
+		return false;
+	}
+
+	// a >= b
+	BIGONETYPE bool ugreaterOrEqual(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return true;
+			if (a[ii] < b[ii]) return false;
+		}
+
+		return true;
+	}
+
+	// a > b
+	BIGONETYPE bool sgreater(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return BIGHIGHBIT(a) == 0;
+			if (a[ii] < b[ii]) return BIGHIGHBIT(b) != 0;
+		}
+		return false;
+	}
+
+	// a >= b
+	BIGONETYPE bool sgreaterOrEqual(T &a, T &b)
+	{
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			if (a[ii] > b[ii]) return BIGHIGHBIT(a) == 0;
+			if (a[ii] < b[ii]) return BIGHIGHBIT(b) != 0;
+		}
+		return true;
+	}
+
+	// a == b
+	BIGONETYPE INLINE bool equal(T &a, T &b)
+	{
+		return memcmp(a, b, sizeof(T)) == 0;
+	}
+
+	// a == 0
+	BIGONETYPE INLINE bool isZero(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			if (n[ii]) return false;
+		return true;
+	}
+
+
+	//////// binary ////////
+
+	// a &= b
+	BIGONETYPE void bAND(T &a, T &b)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			a[ii] &= b[ii];
+	}
+
+	// a |= b
+	BIGONETYPE void bOR(T &a, T &b)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			a[ii] |= b[ii];
+	}
+
+	// a ^= b
+	BIGONETYPE void bXOR(T &a, T &b)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			a[ii] ^= b[ii];
+	}
+
+	// n = ~n
+	BIGONETYPE void bNOT(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			n[ii] = ~n[ii];
+	}
+
+
+	//////// shifting ////////
+
+	// n <<= 1
+	BIGONETYPE void shiftLeft1(T &n)
+	{
+		register word w_i, carry = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			w_i = n[ii];
+
+			n[ii] = (w_i << 1) | carry;
+			carry = w_i >> (WORDBITS - 1);
+		}
+	}
+
+	// n <<= s (s <= WORDBITS)
+	BIGONETYPE void shiftLeft(T &n, u32 s)
+	{
+		register s32 ii;
+		register u32 bases = s / WORDBITS;
+		u32 bits = s % WORDBITS;
+
+		// move whole bases first
+		if (bases)
+		{
+			// shift bases
+			for (ii = BIGWORDCOUNT(T) - 1 - bases; ii >= 0; --ii)
+				n[ii + bases] = n[ii];
+
+			// clear the original locii of those bases
+			memset(n, 0, bases * sizeof(word));
+		}
+
+		if (bits)
+		{
+			register word w_i, carry = 0;
+
+			for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			{
+				w_i = n[ii];
+
+				n[ii] = (w_i << bits) | carry;
+				carry = w_i >> (WORDBITS - bits);
+			}
+		}
+	}
+
+	// n >>= 1 (unsigned)
+	BIGONETYPE void ushiftRight1(T &n)
+	{
+		register word w_i, carry = 0;
+
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			w_i = n[ii];
+
+			n[ii] = carry | (w_i >> 1);
+			carry = w_i << (WORDBITS - 1);
+		}
+	}
+
+	// n >>= s (unsigned) (s <= WORDBITS)
+	BIGONETYPE void ushiftRight(T &n, u32 s)
+	{
+		register s32 ii;
+		register u32 bases = s / WORDBITS;
+		register u32 bits = s % WORDBITS;
+
+		// move whole bases first
+		if (bases)
+		{
+			// shift bases
+			for (ii = bases; ii < BIGWORDCOUNT(T); ++ii)
+				n[ii - bases] = n[ii];
+
+			// clear the original locii of those bases
+			memset(n + BIGWORDCOUNT(T) - bases, 0, bases * sizeof(word));
+		}
+
+		if (bits)
+		{
+			register word w_i, carry = 0;
+
+			for (ii = BIGWORDCOUNT(T) - 1 - bases; ii >= 0; --ii)
+			{
+				w_i = n[ii];
+
+				n[ii] = carry | (w_i >> bits);
+				carry = w_i << (WORDBITS - bits);
+			}
+		}
+	}
+
+	// n >>= 1 (signed)
+	BIGONETYPE void sshiftRight1(T &n)
+	{
+		register word w_i, carry = BIGHIGHBIT(n) ? 1 : 0;
+
+		for (s32 ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			w_i = n[ii];
+
+			n[ii] = carry | (w_i >> 1);
+			carry = w_i << (WORDBITS - 1);
+		}
+	}
+
+	// n >>= s (signed) (s <= WORDBITS)
+	BIGONETYPE void sshiftRight(T &n, u32 s)
+	{
+		register s32 ii;
+		register u32 bases = s / WORDBITS;
+		register u32 bits = s % WORDBITS;
+
+		word filler = BIGHIGHBIT(n) ? WORDALLBITS : 0;
+
+		// move whole bases first
+		if (bases)
+		{
+			// shift bases
+			for (ii = bases; ii < BIGWORDCOUNT(T); ++ii)
+				n[ii - bases] = n[ii];
+
+			// clear the original locii of those bases
+			memset(n + BIGWORDCOUNT(T) - bases, filler, bases * sizeof(word));
+		}
+
+		if (bits)
+		{
+			register word w_i, carry = filler << (WORDBITS - bits);
+
+			for (ii = BIGWORDCOUNT(T) - 1 - bases; ii >= 0; --ii)
+			{
+				w_i = n[ii];
+
+				n[ii] = carry | (w_i >> bits);
+				carry = w_i << (WORDBITS - bits);
+			}
+		}
+	}
+
+
+	//////// addition/subtraction ////////
+
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+	void BorlandAdd(void *a, void *b, u32 c)
+	{
+		ASSEMBLY_BLOCK // BorlandC, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, c
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			add [edi], eax		// and now we can use ADD instead of ADC on the first addition
+			mov eax, [esi + 4]
+			adc [edi + 4], eax
+			mov eax, [esi + 8]
+			adc [edi + 8], eax
+			mov eax, [esi + 12]
+			adc [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			adc [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			adc [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			adc [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			adc [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+	}
+#endif
+
+	// a += b
+	BIGONETYPE void add(T &a, T &b)
+	{
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		BorlandAdd(a, b, qc1);
+
+#elif defined(ASSEMBLY_INTEL_SYNTAX)
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, qc1
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			add [edi], eax		// and now we can use ADD instead of ADC on the first addition
+			mov eax, [esi + 4]
+			adc [edi + 4], eax
+			mov eax, [esi + 8]
+			adc [edi + 8], eax
+			mov eax, [esi + 12]
+			adc [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			adc [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			adc [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			adc [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			adc [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+#else
+		register word carry = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word a_i = a[ii];
+			word b_i = b[ii];
+			a[ii] += b_i + carry;
+
+			carry = ((a_i & (WORDALLBITS >> 1)) + (b_i & (WORDALLBITS >> 1)) + carry) >> (WORDBITS - 1);
+			carry += (a_i >> (WORDBITS - 1)) + (b_i >> (WORDBITS - 1));
+			carry >>= 1;
+		}
+#endif
+	}
+
+	// ++n
+	BIGONETYPE void increment(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			if (++n[ii]) break;
+	}
+
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+	void BorlandSubtract(void *a, void *b, u32 c)
+	{
+		ASSEMBLY_BLOCK // BorlandC, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, c
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			add [edi], eax		// and now we can use ADD instead of ADC on the first addition
+			mov eax, [esi + 4]
+			adc [edi + 4], eax
+			mov eax, [esi + 8]
+			adc [edi + 8], eax
+			mov eax, [esi + 12]
+			adc [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			adc [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			adc [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			adc [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			adc [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+	}
+#endif
+
+	// a -= b
+	BIGONETYPE void subtract(T &a, T &b)
+	{
+#if defined(NO_TEMPLATE_INLINE_ASSEMBLY) && defined(ASSEMBLY_INTEL_SYNTAX)
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		BorlandSubtract(a, b, qc1);
+
+#elif defined(ASSEMBLY_INTEL_SYNTAX)
+
+		const u32 qc1 = BIGWORDCOUNT(T) / 4 - 1;
+
+		ASSEMBLY_BLOCK // VS.NET, x86, 32-bit words
+		{
+			mov esi, b
+			mov edi, a
+			mov ecx, qc1
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi]
+			xor edx, edx		// edx used later to index later words >= 4
+			sub [edi], eax		// first subtraction doesn't need to borrow
+			mov eax, [esi + 4]
+			sbb [edi + 4], eax
+			mov eax, [esi + 8]
+			sbb [edi + 8], eax
+			mov eax, [esi + 12]
+			sbb [edi + 12], eax
+
+			jecxz done_already
+
+next_word:	inc edx
+			inc edx
+
+			// unrolled loop since word count is a multiple of 4 >= 4
+			mov eax, [esi + edx * 8]
+			sbb [edi + edx * 8], eax
+			mov eax, [esi + edx * 8 + 4]
+			sbb [edi + edx * 8 + 4], eax
+			mov eax, [esi + edx * 8 + 8]
+			sbb [edi + edx * 8 + 8], eax
+			mov eax, [esi + edx * 8 + 12]
+			sbb [edi + edx * 8 + 12], eax
+
+			loop next_word
+done_already:
+		}
+#else
+		register word borrow = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word a_i = a[ii];
+			word b_i = b[ii];
+			a[ii] -= b_i + borrow;
+
+			borrow = ((a_i & (WORDALLBITS >> 1)) - (b_i & (WORDALLBITS >> 1)) - borrow) >> (WORDBITS - 1);
+			borrow += (b_i >> (WORDBITS - 1)) - (a_i >> (WORDBITS - 1));
+			++borrow;
+			borrow >>= 1;
+		}
+#endif
+	}
+
+	// --n
+	BIGONETYPE void decrement(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			if (n[ii]--) break;
+	}
+
+
+	//////// negation ////////
+
+	// n = -n
+	BIGONETYPE void negate(T &n)
+	{
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+			n[ii] = ~n[ii];
+
+		increment(n);
+	}
+
+
+	//////// multiplication ////////
+
+	// a *= a, unsigned
+	BIGONETYPE void usquare(T &a)
+	{
+		T a0, a1;
+
+		set(a0, a);
+		set(a1, a);
+		zero(a);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = a0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a1, shifts);
+						shifts = 0;
+					}
+
+					add(a, a1);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// m = a * b (&a != &b != &m), unsigned
+	BIGTWOTYPES void umultiply(T &a0, T &b0, Bigger &m)
+	{
+		Bigger a;
+		usetlow(a, a0);
+
+		zero(m);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(m, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// a *= b (&a != &b), unsigned
+	BIGTWOTYPES void umultiply(Bigger &a0, T &b0)
+	{
+		Bigger a;
+		set(a, a0);
+
+		zero(a0);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(a0, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// a *= a, signed
+	BIGONETYPE void ssquare(T &a)
+	{
+		T a0, a1;
+
+		if (BIGHIGHBIT(a))
+			negate(a);
+
+		set(a0, a);
+		set(a1, a);
+		zero(a);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = a0[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a1, shifts);
+						shifts = 0;
+					}
+
+					add(a, a1);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+	}
+
+	// m = a * b (&a != &b != &m), signed
+	BIGTWOTYPES void smultiply(T &a0, T &b0, Bigger &m)
+	{
+		Bigger a;
+		ssetlow(a, a0);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(a);
+
+		T b;
+		set(b, b0);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		zero(m);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(m, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+
+		if (sign_a ^ sign_b)
+			negate(m);
+	}
+
+	// a *= b (&a != &b), signed
+	BIGTWOTYPES void smultiply(Bigger &a0, T &b0)
+	{
+		Bigger a;
+		ssetlow(a, a0);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(a);
+
+		T b;
+		set(b, b0);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		zero(a0);
+
+		u32 shifts = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word w_i = b[ii];
+
+			u16 ctr = WORDBITS;
+
+			while (w_i)
+			{
+				if (w_i & 1)
+				{
+					if (shifts)
+					{
+						shiftLeft(a, shifts);
+						shifts = 0;
+					}
+
+					add(a0, a);
+				}
+
+				w_i >>= 1;
+				++shifts;
+				--ctr;
+			}
+
+			shifts += ctr;
+		}
+
+		if (sign_a ^ sign_b)
+			negate(a0);
+	}
+
+
+	//////// division/remainder ////////
+
+	// {q, r} = a / b (&q != &r), unsigned
+	BIGONETYPE void udivide(T &a, T &b0, T &q, T &r)
+	{
+		T b;
+
+		set(b, b0);
+		set(r, a);
+		zero(q);
+
+		u32 shifts = 1;
+
+		// sort of: shift b left until b > r, then shift back one
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		u32 qshifts = 0;
+
+		while (shifts--)
+		{
+			++qshifts;
+
+			if (!ugreater(b, r))
+			{
+				subtract(r, b);
+
+				shiftLeft(q, qshifts);
+				qshifts = 0;
+
+				q[0] |= 1;
+			}
+
+			ushiftRight1(b);
+		}
+
+		shiftLeft(q, qshifts);
+	}
+
+	// r = a Mod b, unsigned
+	BIGONETYPE void umodulo(T &a, T &b0, T &r)
+	{
+		T b;
+		u32 shifts = 1;
+
+		set(b, b0);
+		set(r, a);
+
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		while (shifts--)
+		{
+			if (!ugreater(b, r))
+				subtract(r, b);
+
+			ushiftRight1(b);
+		}
+	}
+
+	// {q, r} = a / b (&q != &r), signed
+	BIGONETYPE void sdivide(T &a, T &b0, T &q, T &r)
+	{
+		T b;
+
+		set(b, b0);
+		set(r, a);
+		zero(q);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(r);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		u32 shifts = 1;
+
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		u32 qshifts = 0;
+
+		while (shifts--)
+		{
+			++qshifts;
+
+			if (!ugreater(b, r))
+			{
+				subtract(r, b);
+
+				shiftLeft(q, qshifts);
+				qshifts = 0;
+
+				q[0] |= 1;
+			}
+
+			ushiftRight1(b);
+		}
+
+		shiftLeft(q, qshifts);
+
+		if (sign_a ^ sign_b) negate(q);
+
+		if (sign_a) negate(r);
+	}
+
+	// r = a Mod b, signed
+	BIGONETYPE void smodulo(T &a, T &b0, T &r)
+	{
+		T b;
+		u32 shifts = 1;
+
+		set(b, b0);
+		set(r, a);
+
+		word sign_a = BIGHIGHBIT(a);
+		if (sign_a) negate(r);
+
+		word sign_b = BIGHIGHBIT(b);
+		if (sign_b) negate(b);
+
+		if (!BIGHIGHBIT(b) && ugreater(r, b))
+		{
+			s32 ii, jj;
+
+			// shift by words if possible
+			for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+				if (r[ii]) break;
+			for (jj = ii; jj >= 0; --jj)
+				if (b[jj]) break;
+
+			if (ii != jj)
+			{
+				shifts = (ii - jj) * WORDBITS;
+				shiftLeft(b, shifts);
+				++shifts;
+			}
+
+			while (!BIGHIGHBIT(b) && ugreater(r, b))
+			{
+				shiftLeft1(b);
+
+				++shifts;
+			}
+
+			while (ugreater(b, r))
+			{
+				ushiftRight1(b);
+
+				--shifts;
+			}
+		}
+		else if (ugreater(b, r))
+		{
+			ushiftRight1(b);
+
+			--shifts;
+		}
+
+		while (shifts--)
+		{
+			if (!ugreater(b, r))
+				subtract(r, b);
+
+			ushiftRight1(b);
+		}
+
+		if (sign_a) negate(r);
+	}
+
+
+	//////// converting to/from strings ////////
+
+#ifdef BIG_USES_STRINGS
+
+	// n -> string
+	BIGONETYPE std::string toString(T &n0, bool sign = true, u16 radix = 10)
+	{
+		T n, base, r;
+		std::string s;
+
+		set(n, n0);
+		usetw(base, radix);
+
+		word sign_n = 0;
+		if (sign && (sign_n = BIGHIGHBIT(n)))
+			negate(n);
+
+		do // always allow first iteration for zero
+		{
+			// {q, r} = n / base
+			udivide(n, base, n, r);
+
+			char ch = (char)r[0];
+
+			if (ch >= 10)
+				ch += 'a' - 10;
+			else
+				ch += '0';
+
+			// insert character
+			s = ch + s;
+		} while (!isZero(n));
+
+		if (sign_n) s = '-' + s;
+
+		return s;
+	}
+
+	// s -> n, signed
+	BIGONETYPE void fromString(std::string s, T &n, bool sign = true, u16 radix = 10)
+	{
+		T acc, base, temp;
+
+		usetw(acc, 1);
+		usetw(base, radix);
+		zero(n);
+
+		u32 len = (u32)s.length();
+		const char *citer = s.c_str() + len;
+
+		while (len--)
+		{
+			char ch = *(--citer);
+
+			if (IS_ALPHA(ch)) // assumes alpha characters only up to radix
+				ch = TO_LOWER(ch) - 'a' + 10;
+			else if (sign && ch == '-') // '-' should be first character
+			{
+				negate(n);
+				break;
+			}
+			else // assumes it's alphanumeric/-
+				ch -= '0';
+
+			usetw(temp, ch);
+
+			umultiply(temp, acc);
+
+			add(n, temp);
+
+			umultiply(acc, base);
+		}
+	}
+
+#endif // BIG_USES_STRINGS
+
+
+	//////// class wrapper ////////
+
+	BIGONETYPE INLINE Int<T>::Int()
+	{
+		big::zero(raw);
+	}
+
+	BIGONETYPE INLINE Int<T>::Int(word n)
+	{
+		ssetw(raw, n);
+	}
+
+#ifdef BIG_USES_STRINGS
+
+	BIGONETYPE INLINE Int<T>::Int(std::string &s)
+	{
+		fromString(s, raw);
+	}
+
+#endif
+
+	BIGONETYPE INLINE Int<T>::Int(T &n)
+	{
+		set(raw, n);
+	}
+
+	BIGONETYPE INLINE Int<T>::operator T &()
+	{
+		return raw;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::zero()
+	{
+		big::zero(raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(word n)
+	{
+		ssetw(raw, n);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(T &n)
+	{
+		set(raw, n);
+		return *this;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::operator<<=(u32 s)
+	{
+		shiftLeft(raw, s);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator<<(u32 s)
+	{
+		Int<T> temp(raw);
+		return temp <<= s;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator>>=(u32 s)
+	{
+		shiftRight(raw, s);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator>>(u32 s)
+	{
+		Int<T> temp(raw);
+		return temp >>= s;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::operator+=(T &n)
+	{
+		add(raw, n);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator+(T &n)
+	{
+		Int<T> temp(raw);
+		return temp += n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator-=(T &n)
+	{
+		subtract(raw, n);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator-(T &n)
+	{
+		Int<T> temp(raw);
+		return temp -= n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator++() // prefix
+	{
+		increment(raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator++(int) // postfix
+	{
+		Int<T> temp(raw);
+		increment(raw);
+		return temp;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator--() // prefix
+	{
+		decrement(raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator--(int) // postfix
+	{
+		Int<T> temp(raw);
+		decrement(raw);
+		return temp;
+	}
+
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator-(int) // negation
+	{
+		Int<T> temp(raw);
+		negate(temp);
+		return temp;
+	}
+
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator*(T &n)
+	{
+		Int<T> temp(raw);
+		return temp *= n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::square()
+	{
+		square(raw);
+		return *this;
+	}
+
+
+	BIGONETYPE BIGINTFAST Int<T>::operator/=(T &n)
+	{
+		T discard;
+		divide(raw, n, raw, discard);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator/(T &n)
+	{
+		Int<T> temp(raw);
+		return temp /= n;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator%=(T &n)
+	{
+		modulus(raw, n, raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTSLOW Int<T>::operator%(T &n)
+	{
+		Int<T> temp(raw);
+		return temp %= n;
+	}
+
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator>(T &n)
+	{
+		return sgreater(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator>=(T &n)
+	{
+		return sgreaterOrEqual(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator<(T &n)
+	{
+		return !sgreaterOrEqual(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator<=(T &n)
+	{
+		return !sgreater(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator==(T &n)
+	{
+		return equal(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator!=(T &n)
+	{
+		return !equal(raw, n);
+	}
+
+	BIGONETYPE INLINE /* fast */ bool Int<T>::operator!()
+	{
+		return isZero(raw);
+	}
+
+#ifdef BIG_USES_STRINGS
+
+	BIGONETYPE INLINE /* fast */ std::string Int<T>::str()
+	{
+		return toString(raw);
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(std::string &s)
+	{
+		fromString(s, raw);
+		return *this;
+	}
+
+	BIGONETYPE BIGINTFAST Int<T>::operator=(const char *s)
+	{
+		fromString(std::string(s), raw);
+		return *this;
+	}
+
+#endif // BIG_USES_STRINGS
+}
+
+#endif // BIGTYPES_H
+
+
+

Added: trunk/source/libraries/raknet/RSACrypt.h
===================================================================
--- trunk/source/libraries/raknet/RSACrypt.h	2004-11-28 17:15:55 UTC (rev 101)
+++ trunk/source/libraries/raknet/RSACrypt.h	2004-11-28 17:18:25 UTC (rev 102)
@@ -0,0 +1,1095 @@
+/*
+	Performant RSA en/decryption with 256-bit to 16384-bit modulus
+
+	catid(cat02e at fsu.edu)
+
+	7/30/2004	Fixed VS6 compat
+	7/26/2004	Now internally generates private keys
+				simpleModExp() is faster for encryption than MontyModExp
+				CRT-MontyModExp is faster for decryption than CRT-SimpleModExp
+	7/25/2004	Implemented Montgomery modular exponentation
+				Implemented CRT modular exponentation optimization
+	7/21/2004	Did some pre-lim coding
+
+	Best performance on my 1.8 GHz P4 (mobile):
+		1024-bit generate key : 30 seconds
+		1024-bit set private key : 100 ms (pre-compute this step)
+		1024-bit encryption : 200 usec
+		1024-bit decryption : 400 ms
+
+	TODO
+		There's a bug in MonModExp() that restricts us to k-1 bits
+
+	Tabs: 4 spaces
+	Dist: public
+*/
+
+#ifndef RSACRYPT_H
+#define RSACRYPT_H
+
+#define RSASUPPORTGENPRIME
+
+// Can't go under 256 or you'll need to disable the USEASSEMBLY macro in bigtypes.h
+// That's because the assembly assumes at least 128-bit data to work on
+// #define RSA_BIT_SIZE big::u512
+#define RSA_BIT_SIZE big::u256
+
+#include "BigTypes.h"
+#include "Rand.h"	//Giblet - added missing include for randomMT()
+
+namespace big
+{
+	using namespace cat;
+
+	// r = x^y Mod n (fast for small y)
+	BIGONETYPE void simpleModExp(T &x0, T &y0, T &n0, T &r0)
+	{
+		BIGDOUBLESIZE(T, x);
+		BIGDOUBLESIZE(T, y);
+		BIGDOUBLESIZE(T, n);
+		BIGDOUBLESIZE(T, r);
+
+		usetlow(x, x0);
+		usetlow(y, y0);
+		usetlow(n, n0);
+		usetw(r, 1);
+
+		umodulo(x, n, x);
+
+		u32 squares = 0;
+
+		for (u32 ii = 0; ii < BIGWORDCOUNT(T); ++ii)
+		{
+			word y_i = y[ii];
+
+			u32 ctr = WORDBITS;
+
+			while (y_i)
+			{
+				if (y_i & 1)
+				{
+					if (squares) do
+					{
+						usquare(x);
+						umodulo(x, n, x);
+					} while (--squares);
+
+					umultiply(r, x, r);
+					umodulo(r, n, r);
+				}
+
+				y_i >>= 1;
+				++squares;
+				--ctr;
+			}
+
+			squares += ctr;
+		}
+
+		takelow(r0, r);
+	}
+
+	// computes Rn = 2^k (mod n), n < 2^k
+	BIGONETYPE void rModn(T &n, T &Rn)
+	{
+		BIGDOUBLESIZE(T, dR);
+		BIGDOUBLESIZE(T, dn);
+		BIGDOUBLESIZE(T, dRn);
+		T one;
+
+		// dR = 2^k
+		usetw(one, 1);
+		sethigh(dR, one);
+
+		// Rn = 2^k (mod n)
+		usetlow(dn, n);
+		umodulo(dR, dn, dRn);
+		takelow(Rn, dRn);
+	}
+
+	// computes c = GCD(a, b)
+	BIGONETYPE void GCD(T &a0, T &b0, T &c)
+	{
+		T a;
+
+		umodulo(a0, b0, c);
+
+		if (isZero(c))
+		{
+			set(c, b0);
+			return;
+		}
+
+		umodulo(b0, c, a);
+
+		if (isZero(a))
+			return;
+
+		while (true)
+		{
+			umodulo(c, a, c);
+
+			if (isZero(c))
+			{
+				set(c, a);
+				return;
+			}
+
+			umodulo(a, c, a);
+
+			if (isZero(a))
+				return;
+		}
+	}
+
+	// directly computes x = c - a * b (mod n) > 0, c < n
+	BIGONETYPE void SubMulMod(T &a, T &b, T &c, T &n, T &x)
+	{
+		BIGDOUBLESIZE(T, da);
+		BIGDOUBLESIZE(T, dn);
+		T y;
+
+		// y = a b (mod n)
+		usetlow(da, a);
+		umultiply(da, b);
+		usetlow(dn, n);
+		umodulo(da, dn, da);
+		takelow(y, da);
+
+		// x = (c - y) (mod n) > 0
+		set(x, c);
+		if (ugreater(c, y))
+		{
+			subtract(x, y);
+		}
+		else
+		{
+			subtract(x, y);
+			add(x, n);
+		}
+	}
+
+	/*
+		directly compute  a' s.t. a' a - b' b = 1
+
+		b = b0 = n0
+		rp = a'
+		a = 2^k
+		a > b > 0
+		GCD(a, b) = 1 (b odd)
+
+		Trying to keep everything positive
+	*/
+	BIGONETYPE void computeRinverse(T &n0, T &rp)
+	{
+		T x0, x1, x2, a, b, q;
+
+		//x[0] = 1
+		usetw(x0, 1);
+
+		// a = 2^k (mod b0)
+		rModn(n0, a);
+
+		// {q, b} = b0 / a
+		udivide(n0, a, q, b);
+
+		// if b = 0, return x[0]
+		if (isZero(b))
+		{
+			set(rp, x0);
+			return;
+		}
+
+		// x[1] = -q (mod b0) = b0 - q, q <= b0
+		set(x1, n0);
+		subtract(x1, q);
+
+		// {q, a} = a / b
+		udivide(a, b, q, a);
+
+		// if a = 0, return x[1]
+		if (isZero(a))
+		{
+			set(rp, x1);
+			return;
+		}
+
+		while (true)
+		{
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[2]
+			if (isZero(b))
+			{
+				set(rp, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[0]
+			if (isZero(a))
+			{
+				set(rp, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[1]
+			if (isZero(b))
+			{
+				set(rp, x1);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[2]
+			if (isZero(a))
+			{
+				set(rp, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[0]
+			if (isZero(b))
+			{
+				set(rp, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[1]
+			if (isZero(a))
+			{
+				set(rp, x1);
+				return;
+			}
+		}
+	}
+/*	BIGONETYPE void computeRinverse2(T &_n0, T &_rp)
+	{
+		//T x0, x1, x2, a, b, q;
+		BIGDOUBLESIZE(T, x0);
+		BIGDOUBLESIZE(T, x1);
+		BIGDOUBLESIZE(T, x2);
+		BIGDOUBLESIZE(T, a);
+		BIGDOUBLESIZE(T, b);
+		BIGDOUBLESIZE(T, q);
+		BIGDOUBLESIZE(T, n0);
+		BIGDOUBLESIZE(T, rp);
+
+		usetlow(n0, _n0);
+		usetlow(rp, _rp);
+
+std::string old;
+		//x[0] = 1
+		usetw(x0, 1);
+
+		T _a;
+		// a = 2^k (mod b0)
+		rModn(_n0, _a);
+RECORD("TEST") << "a=" << toString(a, false) << " = 2^k (mod " << toString(n0, false) << ")";
+		usetlow(a, _a);
+
+		// {q, b} = b0 / a
+		udivide(n0, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b, false) << "} = n0=" << toString(n0, false) << " / a=" << toString(a, false);
+
+		// if b = 0, return x[0]
+		if (isZero(b))
+		{
+RECORD("TEST") << "b == 0, Returning x[0]";
+			set(rp, x0);
+			takelow(_rp, rp);
+			return;
+		}
+
+		// x[1] = -q (mod b0)
+		negate(q);
+		smodulo(q, n0, x1);
+		if (BIGHIGHBIT(x1))
+			add(x1, n0); // q > 0
+RECORD("TEST") << "x1=" << toString(x1, false) << " = q=" << toString(q, false) << " (mod n0=" << toString(n0, false) << ")";
+
+		// {q, a} = a / b
+old = toString(a, false);
+		udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+		// if a = 0, return x[1]
+		if (isZero(a))
+		{
+RECORD("TEST") << "a == 0, Returning x[1]";
+			set(rp, x1);
+			takelow(_rp, rp);
+			return;
+		}
+
+RECORD("TEST") << "Entering loop...";
+		while (true)
+		{
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, b} = b / a
+old = toString(b);
+			udivide(b, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b) << "} = b=" << old << " / a=" << toString(a, false);
+
+			// if b = 0, return x[2]
+			if (isZero(b))
+			{
+RECORD("TEST") << "b == 0, Returning x[2]";
+				set(rp, x2);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, a} = a / b
+old = toString(a, false);
+			udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+			// if a = 0, return x[0]
+			if (isZero(a))
+			{
+RECORD("TEST") << "a == 0, Returning x[0]";
+				set(rp, x0);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, b} = b / a
+old = toString(b);
+			udivide(b, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b) << "} = b=" << old << " / a=" << toString(a, false);
+
+			// if b = 0, return x[1]
+			if (isZero(b))
+			{
+RECORD("TEST") << "b == 0, Returning x[1]";
+				set(rp, x1);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(q, x1, x0, n0, x2);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, a} = a / b
+old = toString(a, false);
+			udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+			// if a = 0, return x[2]
+			if (isZero(a))
+			{
+RECORD("TEST") << "a == 0, Returning x[2]";
+				set(rp, x2);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(q, x2, x1, n0, x0);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, b} = b / a
+old = toString(b);
+			udivide(b, a, q, b);
+RECORD("TEST") << "{q=" << toString(q, false) << ", b=" << toString(b) << "} = b=" << old << " / a=" << toString(a, false);
+
+			// if b = 0, return x[0]
+			if (isZero(b))
+			{
+RECORD("TEST") << "b == 0, Returning x[0]";
+				set(rp, x0);
+				takelow(_rp, rp);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(q, x0, x2, n0, x1);
+RECORD("TEST") << "x[0] = " << toString(x0, false);
+RECORD("TEST") << "x[1] = " << toString(x1, false);
+RECORD("TEST") << "x[2] = " << toString(x2, false);
+
+			// {q, a} = a / b
+old = toString(a, false);
+			udivide(a, b, q, a);
+RECORD("TEST") << "{q=" << toString(q, false) << ", a=" << toString(a, false) << "} = a=" << old << " / b=" << toString(b);
+
+			// if a = 0, return x[1]
+			if (isZero(a))
+			{
+RECORD("TEST") << "a == 0, Returning x[1]";
+				set(rp, x1);
+				takelow(_rp, rp);
+				return;
+			}
+		}
+	}
+*/
+	// directly compute a^-1 s.t. a^-1 a (mod b) = 1, a < b, GCD(a, b)
+	BIGONETYPE void computeModularInverse(T &a0, T &b0, T &ap)
+	{
+		T x0, x1, x2;
+		T a, b, q;
+
+		// x[2] = 1
+		usetw(x2, 1);
+
+		// {q, b} = b0 / a0
+		udivide(b0, a0, q, b);
+
+		// x[0] = -q (mod b0) = b0 - q, q <= b0
+		set(x0, b0);
+		subtract(x0, q);
+
+		set(a, a0);
+
+		while (true)
+		{
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[0]
+			if (isZero(a))
+			{
+				set(ap, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(x0, q, x2, b0, x1);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[1]
+			if (isZero(b))
+			{
+				set(ap, x1);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(x1, q, x0, b0, x2);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[2]
+			if (isZero(a))
+			{
+				set(ap, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(x2, q, x1, b0, x0);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[0]
+			if (isZero(b))
+			{
+				set(ap, x0);
+				return;
+			}
+
+			// x[1] = x[2] - x[0] * q (mod b0)
+			SubMulMod(x0, q, x2, b0, x1);
+
+			// {q, a} = a / b
+			udivide(a, b, q, a);
+
+			// if a = 0, return x[1]
+			if (isZero(a))
+			{
+				set(ap, x1);
+				return;
+			}
+
+			// x[2] = x[0] - x[1] * q (mod b0)
+			SubMulMod(x1, q, x0, b0, x2);
+
+			// {q, b} = b / a
+			udivide(b, a, q, b);
+
+			// if b = 0, return x[2]
+			if (isZero(b))
+			{
+				set(ap, x2);
+				return;
+			}
+
+			// x[0] = x[1] - x[2] * q (mod b0)
+			SubMulMod(x2, q, x1, b0, x0);
+		}
+	}
+
+	// indirectly computes  n' s.t. 1 = r' r - n' n = GCD(r, n)
+	BIGONETYPE void computeNRinverse(T &n0, T &np)
+	{
+		BIGDOUBLESIZE(T, r);
+		BIGDOUBLESIZE(T, n);
+
+		// r' = (1 + n' n) / r
+		computeRinverse(n0, np);
+
+		// n' = (r' r - 1) / n
+		sethigh(r, np); // special case of r = 2^k
+		decrement(r);
+		usetlow(n, n0);
+		udivide(r, n, n, r);
+		takelow(np, n);
+	}
+/*
+	// indirectly computes  n' s.t. 1 = r' r - n' n = GCD(r, n)
+	BIGONETYPE void computeNRinverse2(T &n0, T &np)
+	{
+		BIGDOUBLESIZE(T, r);
+		BIGDOUBLESIZE(T, n);
+
+		// r' = (1 + n' n) / r
+		computeRinverse2(n0, np);
+
+		// n' = (r' r - 1) / n
+		sethigh(r, np); // special case of r = 2^k
+		decrement(r);
+		usetlow(n, n0);
+		udivide(r, n, n, r);
+		takelow(np, n);
+	}
+*/
+	// Montgomery product u = a * b (mod n)
+	BIGONETYPE void MonPro(T &ap, T &bp, T &n, T &np, T &u_out)
+	{
+		BIGDOUBLESIZE(T, t);
+		BIGDOUBLESIZE(T, u);
+		T m;
+
+		// t = a' b'
+		umultiply(ap, bp, t);
+
+		// m = (low half of t)*np (mod r)
+		takelow(m, t);
+		umultiply(m, np);
+
+		// u = (t + m*n), u_out = u / r = high half of u
+		umultiply(m, n, u);
+		add(u, t);
+		takehigh(u_out, u);
+
+		// if u >= n, return u - n, else u
+		if (ugreaterOrEqual(u_out, n))
+			subtract(u_out, n);
+	}
+
+	// indirectly calculates x = M^e (mod n)
+	BIGONETYPE void MonModExp(T &x, T &M, T &e, T &n, T &np, T &xp0)
+	{
+		// x' = xp0
+		set(x, xp0);
+
+		// find M' = M r (mod n)
+		BIGDOUBLESIZE(T, dM);
+		BIGDOUBLESIZE(T, dn);
+		T Mp;
+		sethigh(dM, M); // dM = M r
+		usetlow(dn, n);
+		umodulo(dM, dn, dM); // dM = dM (mod n)
+		takelow(Mp, dM); // M' = M r (mod n)
+
+		/*
+			i may be wrong, but it seems to me that the squaring
+			results in a constant until we hit the first set bit
+			this could save a lot of time, but it needs to be proven
+		*/
+
+		s32 ii, bc;
+		word e_i;
+
+		// for i = k - 1 down to 0 do
+		for (ii = BIGWORDCOUNT(T) - 1; ii >= 0; --ii)
+		{
+			e_i = e[ii];
+			bc = WORDBITS;
+
+			while (bc--)
+			{
+				// if e_i = 1, x = MonPro(M', x')
+				if (e_i & WORDHIGHBIT)
+					goto start_squaring;
+
+				e_i <<= 1;
+			}
+		}
+
+		for (; ii >= 0; --ii)
+		{
+			e_i = e[ii];
+			bc = WORDBITS;
+
+			while (bc--)
+			{
+				// x' = MonPro(x', x')
+				MonPro(x, x, n, np, x);
+
+				// if e_i = 1, x = MonPro(M', x')
+				if (e_i & WORDHIGHBIT)
+				{
+start_squaring:
+					MonPro(Mp, x, n, np, x);
+				}
+
+				e_i <<= 1;
+			}
+		}
+
+		// x = MonPro(x', 1)
+		T one;
+		usetw(one, 1);
+		MonPro(x, one, n, np, x);
+	}
+
+	// indirectly calculates x = C ^ d (mod n) using the Chinese Remainder Thm
+	BIGTWOTYPES void CRTModExp(Bigger &x, Bigger &C, Bigger &d, T &p, T &q, T &pInverse, T &pnp, T &pxp, T &qnp, T &qxp)
+	{
+		// d1 = d mod (p - 1)
+		Bigger dd1;
+		T d1;
+		usetlow(dd1, p);
+		decrement(dd1);
+		umodulo(d, dd1, dd1);
+		takelow(d1, dd1);
+
+		// M1 = C1^d1 (mod p)
+		Bigger dp, dC1;
+		T M1, C1;
+		usetlow(dp, p);
+		umodulo(C, dp, dC1);
+		takelow(C1, dC1);
+		simpleModExp(C1, d1, p, M1);
+		//MonModExp(M1, C1, d1, p, pnp, pxp);
+
+		// d2 = d mod (q - 1)
+		Bigger dd2;
+		T d2;
+		usetlow(dd2, q);
+		decrement(dd2);
+		umodulo(d, dd2, dd2);
+		takelow(d2, dd2);
+
+		// M2 = C2^d2 (mod q)
+		Bigger dq, dC2;
+		T M2, C2;
+		usetlow(dq, q);
+		umodulo(C, dq, dC2);
+		takelow(C2, dC2);
+		simpleModExp(C2, d2, q, M2);
+		//MonModExp(M2, C2, d2, q, qnp, qxp);
+
+		// x = M1 + p * ((M2 - M1)(p^-1 mod q) mod q)
+
+		if (ugreater(M2, M1))
+		{
+			subtract(M2, M1);
+		}
+		else
+		{
+			subtract(M2, M1);
+			add(M2, q);
+		}
+
+		// x = M1 + p * (( M2 )(p^-1 mod q) mod q)
+
+		umultiply(M2, pInverse, x);
+
+		// x = M1 + p * (( x ) mod q)
+
+		umodulo(x, dq, x);
+
+		// x = M1 + p * ( x )
+
+		umultiply(x, dp);
+
+		// x = M1 + ( x )
+
+		Bigger dM1;
+		usetlow(dM1, M1);
+
+		// x = ( dM1 ) + ( x )
+
+		add(x, dM1);
+	}
+
+	// generates a suitable public exponent s.t. 4 < e << phi, GCD(e, phi) = 1
+	BIGONETYPE void computePublicExponent(T &phi, T &e)
+	{
+		T r, one, two;
+		usetw(one, 1);
+		usetw(two, 2);
+		usetw(e, 65537 - 2);
+
+		if (ugreater(e, phi))
+			usetw(e, 5 - 2);
+
+		do
+		{
+			add(e, two);
+
+			GCD(phi, e, r);
+		} while (!equal(r, one));
+	}
+
+	// directly computes private exponent
+	BIGONETYPE void computePrivateExponent(T &e, T &phi, T &d)
+	{
+		// d = e^-1 (mod phi), 1 < e << phi
+		computeModularInverse(e, phi, d);
+	}
+
+#ifdef RSASUPPORTGENPRIME
+
+	static const u16 PRIME_TABLE[256] = {
+		   3,         5,         7,        11,        13,        17,        19,        23,
+		  29,        31,        37,        41,        43,        47,        53,        59,
+		  61,        67,        71,        73,        79,        83,        89,        97,
+		 101,       103,       107,       109,       113,       127,       131,       137,
+		 139,       149,       151,       157,       163,       167,       173,       179,
+		 181,       191,       193,       197,       199,       211,       223,       227,
+		 229,       233,       239,       241,       251,       257,       263,       269,
+		 271,       277,       281,       283,       293,       307,       311,       313,
+		 317,       331,       337,       347,       349,       353,       359,       367,
+		 373,       379,       383,       389,       397,       401,       409,       419,
+		 421,       431,       433,       439,       443,       449,       457,       461,
+		 463,       467,       479,       487,       491,       499,       503,       509,
+		 521,       523,       541,       547,       557,       563,       569,       571,
+		 577,       587,       593,       599,       601,       607,       613,       617,
+		 619,       631,       641,       643,       647,       653,       659,       661,
+		 673,       677,       683,       691,       701,       709,       719,       727,
+		 733,       739,       743,       751,       757,       761,       769,       773,
+		 787,       797,       809,       811,       821,       823,       827,       829,
+		 839,       853,       857,       859,       863,       877,       881,       883,
+		 887,       907,       911,       919,       929,       937,       941,       947,
+		 953,       967,       971,       977,       983,       991,       997,      1009,
+		1013,      1019,      1021,      1031,      1033,      1039,      1049,      1051,
+		1061,      1063,      1069,      1087,      1091,      1093,      1097,      1103,
+		1109,      1117,      1123,      1129,      1151,      1153,      1163,      1171,
+		1181,      1187,      1193,      1201,      1213,      1217,      1223,      1229,
+		1231,      1237,      1249,      1259,      1277,      1279,      1283,      1289,
+		1291,      1297,      1301,      1303,      1307,      1319,      1321,      1327,
+		1361,      1367,      1373,      1381,      1399,      1409,      1423,      1427,
+		1429,      1433,      1439,      1447,      1451,      1453,      1459,      1471,
+		1481,      1483,      1487,      1489,      1493,      1499,      1511,      1523,
+		1531,      1543,      1549,      1553,      1559,      1567,      1571,      1579,
+		1583,      1597,      1601,      1607,      1609,      1613,      1619,      1621
+	};
+
+	/*
+		modified Rabin-Miller primality test (added small primes)
+
+		When picking a value for insurance, note that the probability of failure
+		of the test to detect a composite number is at most 4^(-insurance), so:
+		insurance	max. probability of failure
+		3			1.56%
+		4			0.39%
+		5			0.098% <-- default
+		6			0.024%
+		...
+	*/
+	BIGONETYPE bool RabinMillerPrimalityTest(T &n, u32 insurance)
+	{
+		// check divisibility by small primes <= 1621 (speeds up computation)
+		T temp;
+		for (u32 ii = 0; ii < 256; ++ii)
+		{
+			usetw(temp, PRIME_TABLE[ii++]);
+
+			umodulo(n, temp, temp);
+
+			if (isZero(temp))
+				return false;
+		}
+
+		// n1 = n - 1
+		T n1;
+		set(n1, n);
+		decrement(n1);
+
+		// write r 2^s = n - 1, r is odd
+		T r;
+		u32 s = 0;
+		set(r, n1);
+		while (!(r[0] & 1))
+		{
+			ushiftRight1(r);
+			++s;
+		}
+
+		// one = 1
+		T one;
+		usetw(one, 1);
+
+		// cache n -> dn
+		BIGDOUBLESIZE(T, dy);
+		BIGDOUBLESIZE(T, dn);
+		usetlow(dn, n);
+
+		while (insurance--)
+		{
+		// choose random integer a s.t. 1 < a < n - 1
+			T a;
+			int index;
+			for (index=0; index < sizeof(a)/sizeof(a[0]); index++)
+				a[index]=randomMT();
+			umodulo(a, n1, a);
+
+			// compute y = a ^ r (mod n)
+			T y;
+			simpleModExp(a, r, n, y);
+
+			if (!equal(y, one) && !equal(y, n1))
+			{
+				u32 j = s;
+				while ((j-- > 1) && !equal(y, n1))
+				{
+					umultiply(y, y, dy);
+					umodulo(dy, dn, dy);
+					takelow(y, dy);
+
+					if (equal(y, one)) return false;
+				}
+
+				if (!equal(y, n1)) return false;
+			}
+		}
+
+		return true;
+	}
+
+	// generates a strong pseudo-prime
+	BIGONETYPE void generateStrongPseudoPrime(T &n)
+	{
+		do {
+			int index;
+			for (index=0; index < sizeof(n)/sizeof(n[0]); index++)
+				n[index]=randomMT();
+			n[BIGWORDCOUNT(T) - 1] |= WORDHIGHBIT;
+			//n[BIGWORDCOUNT(T) - 1] &= ~WORDHIGHBIT; n[BIGWORDCOUNT(T) - 1] |= WORDHIGHBIT >> 1;
+			n[0] |= 1;
+		} while (!RabinMillerPrimalityTest(n, 5));
+	}
+
+#endif // RSASUPPORTGENPRIME
+
+
+	//////// RSACrypt class ////////
+
+	BIGONETYPE class RSACrypt
+	{
+		// public key
+		T e, n;
+		T np, xp;
+
+		// private key
+		bool factorsAvailable;
+		T d, phi;
+		BIGHALFSIZE(T, p);
+		BIGHALFSIZE(T, pnp);
+		BIGHALFSIZE(T, pxp);
+		BIGHALFSIZE(T, q);
+		BIGHALFSIZE(T, qnp);
+		BIGHALFSIZE(T, qxp);
+		BIGHALFSIZE(T, pInverse);
+
+	public:
+		RSACrypt()
+		{
+			reset();
+		}
+		~RSACrypt()
+		{
+			reset();
+		}
+
+	public:
+		void reset()
+		{
+			zero(d);
+			zero(p);
+			zero(q);
+			zero(pInverse);
+			factorsAvailable = false;
+		}
+
+#ifdef RSASUPPORTGENPRIME
+
+		void generateKeys()
+		{
+			BIGHALFSIZE(T, p0);
+			BIGHALFSIZE(T, q0);
+
+			generateStrongPseudoPrime(p0);
+			generateStrongPseudoPrime(q0);
+
+			setPrivateKey(p0, q0);
+		}
+
+#endif // RSASUPPORTGENPRIME
+
+		BIGSMALLTYPE void setPrivateKey(Smaller &c_p, Smaller &c_q)
+		{
+			factorsAvailable = true;
+
+			// re-order factors s.t. q > p
+			if (ugreater(c_p, c_q))
+			{
+				set(q, c_p);
+				set(p, c_q);
+			}
+			else
+			{
+				set(p, c_p);
+				set(q, c_q);
+			}
+
+			// phi = (p - 1)(q - 1)
+			BIGHALFSIZE(T, p1);
+			BIGHALFSIZE(T, q1);
+			set(p1, p);
+			decrement(p1);
+			set(q1, q);
+			decrement(q1);
+			umultiply(p1, q1, phi);
+
+			// compute e
+			computePublicExponent(phi, e);
+
+			// compute d
+			computePrivateExponent(e, phi, d);
+
+			// compute p^-1 mod q
+			computeModularInverse(p, q, pInverse);
+
+			// compute n = pq
+			umultiply(p, q, n);
+
+			// find n'
+			computeNRinverse(n, np);
+
+			// x' = 1*r (mod n)
+			rModn(n, xp);
+
+			// find pn'
+			computeNRinverse(p, pnp);
+//			computeNRinverse2(p, pnp);
+
+			// px' = 1*r (mod p)
+			rModn(p, pxp);
+
+			// find qn'
+			computeNRinverse(q, qnp);
+
+			// qx' = 1*r (mod q)
+			rModn(q, qxp);
+		}
+		void setPublicKey(u32 c_e, T &c_n)
+		{
+			reset(); // in case we knew a private key
+
+			usetw(e, c_e);
+			set(n, c_n);
+
+			// find n'
+			computeNRinverse(n, np);
+
+			// x' = 1*r (mod n)
+			rModn(n, xp);
+		}
+
+	public:
+		void getPublicKey(u32 &c_e, T &c_n)
+		{
+			c_e = e[0];
+			set(c_n, n);
+		}
+		BIGSMALLTYPE void getPrivateKey(Smaller &c_p, Smaller &c_q)
+		{
+			set(c_p, p);
+			set(c_q, q);
+		}
+
+	public:
+		void encrypt(T &M, T &x)
+		{
+			if (factorsAvailable)
+				CRTModExp(x, M, e, p, q, pInverse, pnp, pxp, qnp, qxp);
+			else
+				simpleModExp(M, e, n, x);
+		}
+
+		void decrypt(T &C, T &x)
+		{
+			if (factorsAvailable)
+				CRTModExp(x, C, d, p, q, pInverse, pnp, pxp, qnp, qxp);
+		}
+	};
+}
+
+#endif // RSACRYPT_H
+
+
+

Added: trunk/source/libraries/raknet/RakNetStatistics.cpp
===================================================================
--- trunk/source/libraries/raknet/RakNetStatistics.cpp	2004-11-28 17:15:55 UTC (rev 101)
+++ trunk/source/libraries/raknet/RakNetStatistics.cpp	2004-11-28 17:18:25 UTC (rev 102)
@@ -0,0 +1,135 @@
+#include "RakNetStatistics.h"
+#include <stdio.h> // sprintf
+#include "BitStream.h" // BITS_TO_BYTES
+
+// Verbosity level currently supports 0 (low), 1 (medium), 2 (high)
+// Buffer must be hold enough to hold the output string.  See the source to get an idea of how many bytes will be output
+void StatisticsToString(RakNetStatisticsStruct *s, char *buffer, int verbosityLevel)
+{
+	if (s==0)
+	{
+		sprintf(buffer, "stats is a NULL pointer in statsToString\n");
+		return;
+	}
+
+	if (verbosityLevel==0)
+	{
+		// Verbosity level 0
+		sprintf(buffer,
+"Total bytes sent: %u\n\
+Total bytes received: %u\n\
+Packetloss: %.1f%%\n",
+			BITS_TO_BYTES(s->totalBitsSent),
+			BITS_TO_BYTES(s->bitsReceived+s->bitsWithBadCRCReceived),
+			100.0f*(float)s->messagesTotalBitsResent/(float)s->totalBitsSent);
+	}
+	else if (verbosityLevel==1)
+	{
+		// Verbosity level 1
+		
+		sprintf(buffer,
+"Messages in Send buffer: %u\n\
+Messages sent: %u\n\
+Bytes sent: %u\n\
+Acks sent: %u\n\
+Acks in send buffer: %u\n\
+Messages waiting for ack: %u\n\
+Messages resent: %u\n\
+Bytes resent: %u\n\
+Packetloss: %.1f%%\n\
+Messages recieved: %u\n\
+Bytes recieved: %u\n\
+Acks recieved: %u\n\
+Duplicate acks recieved: %u\n\
+Window size: %u\n",
+			s->messageSendBuffer[SYSTEM_PRIORITY]+s->messageSendBuffer[HIGH_PRIORITY]+s->messageSendBuffer[MEDIUM_PRIORITY]+s->messageSendBuffer[LOW_PRIORITY],
+			s->messagesSent[SYSTEM_PRIORITY]+s->messagesSent[HIGH_PRIORITY]+s->messagesSent[MEDIUM_PRIORITY]+s->messagesSent[LOW_PRIORITY],
+			BITS_TO_BYTES(s->totalBitsSent),
+			s->acknowlegementsSent,
+			s->acknowlegementsPending,
+			s->messagesOnResendQueue,
+			s->messageResends,
+			BITS_TO_BYTES(s->messagesTotalBitsResent),
+			100.0f*(float)s->messagesTotalBitsResent/(float)s->totalBitsSent,
+			s->duplicateMessagesReceived+s->invalidMessagesReceived+s->messagesReceived,
+			BITS_TO_BYTES(s->bitsReceived+s->bitsWithBadCRCReceived),
+			s->acknowlegementsReceived,
+			s->duplicateAcknowlegementsReceived,
+			s->windowSize);
+	}
+	else
+	{
+		// Verbosity level 2.
+		sprintf(buffer,
+"Bytes sent:\t\t\t\t%u\n\
+Messages in send buffer:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Messages sent:\t\t\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Message data bytes sent:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Message header bytes sent:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Message total bytes sent:\t\tSP:%u HP:%u MP:%u LP:%u\n\
+Bytes received:\t\t\t\tTtl:%u Good:%u Bad:%u\n\
+Packets received:\t\t\tTtl:%u Good:%u Bad:%u\n\
+Acks received:\t\t\t\tTtl:%u Good:%u Dup:%u\n\
+Messages received:\t\t\tTotal:%u Valid:%u Invalid:%u Dup:%u\n\
+Packetloss:\t\t\t\t%.1f%%\n\
+Packets sent:\t\t\t\t%u\n\
+Acks sent:\t\t\t\t%u\n\
+Acks in send buffer:\t\t\t%u\n\
+Messages waiting for ack:\t\t%u\n\
+Ack bytes sent:\t\t\t\t%u\n\
+Sent packets containing only acks:\t%u\n\
+Sent packets w/only acks and resends:\t%u\n\
+Reliable messages resent:\t\t%u\n\
+Reliable message data bytes resent:\t%u\n\
+Reliable message header bytes resent:\t%u\n\
+Reliable message total bytes resent:\t%u\n\
+Number of messages split:\t\t%u\n\
+Number of messages unsplit:\t\t%u\n\
+Message splits performed:\t\t%u\n\
+Additional encryption bytes:\t\t%u\n\
+Sequenced messages out of order:\t%u\n\
+Sequenced messages in order:\t\t%u\n\
+Ordered messages out of order:\t\t%u\n\
+Ordered messages in of order:\t\t%u\n\
+Split messages waiting for reassembly:\t%u\n\
+Messages in internal output queue:\t%u\n\
+Window size:\t\t\t\t%u\n\
+Lossy window size\t\t\t%u\n\
+Connection start time:\t\t\t%u\n",
+			BITS_TO_BYTES(s->totalBitsSent),
+			s->messageSendBuffer[SYSTEM_PRIORITY],s->messageSendBuffer[HIGH_PRIORITY], s->messageSendBuffer[MEDIUM_PRIORITY],s->messageSendBuffer[LOW_PRIORITY],
+			s->messagesSent[SYSTEM_PRIORITY], s->messagesSent[HIGH_PRIORITY], s->messagesSent[MEDIUM_PRIORITY],s->messagesSent[LOW_PRIORITY],
+			BITS_TO_BYTES(s->messageDataBitsSent[SYSTEM_PRIORITY]),BITS_TO_BYTES(s->messageDataBitsSent[HIGH_PRIORITY]), BITS_TO_BYTES(s->messageDataBitsSent[MEDIUM_PRIORITY]),BITS_TO_BYTES(s->messageDataBitsSent[LOW_PRIORITY]),
+			BITS_TO_BYTES(s->messageTotalBitsSent[SYSTEM_PRIORITY]-s->messageDataBitsSent[SYSTEM_PRIORITY]),BITS_TO_BYTES(s->messageTotalBitsSent[HIGH_PRIORITY]-s->messageDataBitsSent[HIGH_PRIORITY]), BITS_TO_BYTES(s->messageTotalBitsSent[MEDIUM_PRIORITY]-s->messageDataBitsSent[MEDIUM_PRIORITY]),BITS_TO_BYTES(s->messageTotalBitsSent[LOW_PRIORITY]-s->messageDataBitsSent[LOW_PRIORITY]),
+			BITS_TO_BYTES(s->messageTotalBitsSent[SYSTEM_PRIORITY]), BITS_TO_BYTES(s->messageTotalBitsSent[HIGH_PRIORITY]), BITS_TO_BYTES(s->messageTotalBitsSent[MEDIUM_PRIORITY]),BITS_TO_BYTES(s->messageTotalBitsSent[LOW_PRIORITY]),
+			BITS_TO_BYTES(s->bitsReceived+s->bitsWithBadCRCReceived),BITS_TO_BYTES(s->bitsReceived),BITS_TO_BYTES(s->bitsWithBadCRCReceived),
+			s->packetsReceived+s->packetsWithBadCRCRecieved,s->packetsReceived,s->packetsWithBadCRCRecieved,
+			s->acknowlegementsReceived+s->duplicateAcknowlegementsReceived, s->acknowlegementsReceived,s->duplicateAcknowlegementsReceived,
+			s->messagesReceived+s->invalidMessagesReceived+s->duplicateMessagesReceived, s->messagesReceived, s->invalidMessagesReceived, s->duplicateMessagesReceived,
+			100.0f*(float)s->messagesTotalBitsResent/(float)s->totalBitsSent,
+			s->packetsSent,
+			s->acknowlegementsSent,
+			s->acknowlegementsPending,
+			s->messagesOnResendQueue,
+			BITS_TO_BYTES(s->acknowlegementBitsSent),
+			s->packetsContainingOnlyAcknowlegements,
+			s->packetsContainingOnlyAcknowlegementsAndResends,
+			s->messageResends,
+			BITS_TO_BYTES(s->messageDataBitsResent),
+			BITS_TO_BYTES(s->messagesTotalBitsResent-s->messageDataBitsResent),
+			BITS_TO_BYTES(s->messagesTotalBitsResent),
+			s->numberOfSplitMessages,
+			s->numberOfUnsplitMessages,
+			s->totalSplits,
+			BITS_TO_BYTES(s->encryptionBitsSent),
+			s->sequencedMessagesOutOfOrder,
+			s->sequencedMessagesInOrder,
+			s->orderedMessagesOutOfOrder,
+			s->orderedMessagesInOrder,
+			s->messagesWaitingForReassembly,
+			s->internalOutputQueueSize,
+			s->windowSize,
+			s->lossySize,
+			s->connectionStartTime);
+	}
+}

Added: trunk/source/libraries/raknet/RakNetStatistics.h
===================================================================
--- trunk/source/libraries/raknet/RakNetStatistics.h	2004-11-28 17:15:55 UTC (rev 101)
+++ trunk/source/libraries/raknet/RakNetStatistics.h	2004-11-28 17:18:25 UTC (rev 102)
@@ -0,0 +1,97 @@
+#ifndef __RAK_NET_STATISTICS_H
+#define __RAK_NET_STATISTICS_H
+
+#include "PacketPriority.h"
+
+struct RakNetStatisticsStruct
+{
+	//		Number of Messages in the send Buffer (high, medium, low priority)
+	unsigned messageSendBuffer[NUMBER_OF_PRIORITIES];
+	//		Number of messages sent (high, medium, low priority)
+	unsigned messagesSent[NUMBER_OF_PRIORITIES];
+	//		Number of data bits used for user messages
+	unsigned messageDataBitsSent[NUMBER_OF_PRIORITIES];
+	//		Number of total bits used for user messages, including headers
+	unsigned messageTotalBitsSent[NUMBER_OF_PRIORITIES];
+
+	//		Number of packets sent containing only acknowledgements
+	unsigned packetsContainingOnlyAcknowlegements;
+	//		Number of acknowledgements sent
+	unsigned acknowlegementsSent;
+	//		Number of acknowledgements waiting to be sent
+	unsigned acknowlegementsPending;
+	//		Number of acknowledgements bits sent
+	unsigned acknowlegementBitsSent;
+
+	//		Number of packets containing only acknowledgements and resends
+	unsigned packetsContainingOnlyAcknowlegementsAndResends;
+
+	//		Number of messages resent
+	unsigned messageResends;
+	//		Number of bits resent of actual data
+	unsigned messageDataBitsResent;
+	//		Total number of bits resent, including headers
+	unsigned messagesTotalBitsResent;
+	//		Number of messages waiting for ack
+	unsigned messagesOnResendQueue;
+
+	//		Number of messages not split for sending
+	unsigned numberOfUnsplitMessages;
+	//		Number of messages split for sending
+	unsigned numberOfSplitMessages;
+	//		Total number of splits done for sending
+	unsigned totalSplits;
+
+	//		Total packets sent
+	unsigned packetsSent;
+
+	//		Number of bits added by encryption
+	unsigned encryptionBitsSent;
+	//		total bits sent
+	unsigned totalBitsSent;
+
+	//		Number of sequenced messages arrived out of order
+	unsigned sequencedMessagesOutOfOrder;
+	//		Number of sequenced messages arrived in order
+	unsigned sequencedMessagesInOrder;
+
+	//		Number of ordered messages arrived out of order
+	unsigned orderedMessagesOutOfOrder;
+	//		Number of ordered messages arrived in order
+	unsigned orderedMessagesInOrder;
+
+	//		Packets with a good CRC received
+	unsigned packetsReceived;
+	//		Packets with a bad CRC received
+	unsigned packetsWithBadCRCRecieved;
+	//		Bits with a good CRC received
+	unsigned bitsReceived;
+	//		Bits with a bad CRC received
+	unsigned bitsWithBadCRCReceived;
+	//		Number of acknowledgement messages received for packets we are resending
+	unsigned acknowlegementsReceived;
+	//		Number of acknowledgement messages received for packets we are not resending
+	unsigned duplicateAcknowlegementsReceived;
+	//		Number of data messages (anything other than an ack) received that are valid and not duplicate
+	unsigned messagesReceived;
+	//		Number of data messages (anything other than an ack) received that are invalid
+	unsigned invalidMessagesReceived;
+	//		Number of data messages (anything other than an ack) received that are duplicate
+	unsigned duplicateMessagesReceived;
+	//		Number of messages waiting for reassembly
+	unsigned messagesWaitingForReassembly;
+	//		Number of messages in reliability output queue
+	unsigned internalOutputQueueSize;
+	//		Current window size
+	unsigned windowSize;
+	//		lossy window size
+	unsigned lossySize;
+	//		connection start time
+	unsigned long connectionStartTime;
+};
+
+
+// Verbosity level currently supports 0 (low), 1 (medium), 2 (high)
+void StatisticsToString(RakNetStatisticsStruct *s, char *buffer, int verbosityLevel);
+
+#endif

Added: trunk/source/libraries/raknet/Types.h
===================================================================
--- trunk/source/libraries/raknet/Types.h	2004-11-28 17:15:55 UTC (rev 101)
+++ trunk/source/libraries/raknet/Types.h	2004-11-28 17:18:25 UTC (rev 102)
@@ -0,0 +1,486 @@
+/*
+	Fundamental tools & types
+
+	Catid(cat02e at fsu.edu)
+
+	8/9/2004	Added SINGLE/ARRAY_RELEASE
+	8/5/2004	Added COMPILER_ preprocessors
+				class NoCopies
+	8/1/2004	Removed mask stuff
+	7/29/2004	Added swapLE, swapBE, getLE, getBE
+	7/28/2004	Automatic and AutoArray now compile in dev-c++
+				Added pre-processor conditions to support other compilers
+				Removed GETWORD and GETDWORD
+	7/15/2004	Now using COM_RELEASE throughout CatGL3
+	6/22/2004	Removed triple and pair
+	6/12/2004	AutoDeallocate -> Automatic, AutoArray
+	6/9/2004	OBJCLR
+	5/2/2004	class AutoDeallocate
+	5/1/2004	IS_POWER_OF_2, next_highest_power_of_2
+	4/30/2004	Merged character manip macros
+	2/23/2004	CEIL*
+				Removed MEMCOPY32 and MEMCLEAR32,
+				memcpy and memset are now faster
+				MAKE_MASK
+	2/10/2004	LITTLE_ENDIAN
+				COUNT1BITS32
+				AT_LEAST_2_BITS
+				LEAST_SIGNIFICANT_BIT
+	X-mas/2003	[u/s]int?? -> [u/s]??
+	7/3/2003	Added template triple, point->pair
+	6/15/2003	Added template rect, point
+	3/30/2003	Added RO?8, RO?16 and ?int64
+				Added MEMCOPY32 and MEMCLEAR32
+	3/12/2003	Added GETWORD and GETDWORD
+	1/16/2003	Formalized this library.
+
+	Tabs: 4 spaces
+	Dist: public
+*/
+
+#ifndef TYPES_H
+#define TYPES_H
+
+namespace cat
+{
+////// Compilers //////
+
+/*
+	Things to consider for each compiler:
+
+	BIG_ENDIAN / LITTLE_ENDIAN
+	MULTITHREADED
+	DEBUG
+	HASINT64
+	Basic types {u8-u64, s8-s64, f32, f64}
+	WIN32
+	ASSEMBLY_INTEL_SYNTAX / ASSEMBLY_ATT_SYNTAX, ASSEMBLY_BLOCK
+	INLINE
+	NO_TEMPLATE_INLINE_ASSEMBLY
+	Fixes
+
+	Set depending which compiler is being used:
+
+	COMPILER_MSVC
+	COMPILER_GCC
+	COMPILER_BORLANDC
+*/
+
+
+//// endian-ness (ignoring NUXI) ////
+
+#if defined(__sparc) || defined(__sparc__) || defined(__powerpc__) || \
+	defined(__ppc__) || defined(__hppa) || defined(_MIPSEB) || defined(_POWER) || \
+	defined(_M_PPC) || defined(_M_MPPC) || defined(_M_MRX000) || \
+	defined(__POWERPC) || defined(m68k) || defined(powerpc) || \
+	defined(sel) || defined(pyr) || defined(mc68000) || defined(is68k) || \
+	defined(tahoe) || defined(ibm032) || defined(ibm370) || defined(MIPSEB) || \
+	defined(__convex__) || defined(DGUX) || defined(hppa) || defined(apollo) || \
+	defined(_CRAY) || defined(__hp9000) || defined(__hp9000s300) || defined(_AIX) || \
+	defined(__AIX) || defined(__pyr__) || defined(hp9000s700) || defined(_IBMR2)
+
+#	define BIG_ENDIAN
+
+#elif defined(__i386__) || defined(i386) || defined(intel) || defined(_M_IX86) || \
+	  defined(__alpha__) || defined(__alpha) || defined(__ia64) || defined(__ia64__) || \
+	  defined(_M_ALPHA) || defined(ns32000) || defined(__ns32000__) || defined(sequent) || \
+	  defined(MIPSEL) || defined(_MIPSEL) || defined(sun386) || defined(__sun386__)
+
+#	define LITTLE_ENDIAN
+
+#else
+
+#	error "I can't tell what endian-ness to use for your architecture."
+
+#endif
+
+
+//// compiler-specific ////
+
+#if defined(__COMO__) // Comeau C++
+
+#	error "Comeau C++ : I don't know your compiler"
+
+#elif defined(__DMC__) // Digital Mars C++
+
+#	error "Digital Mars C++ : I don't know your compiler"
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC) // Intel
+
+#	error "Intel : I don't know your compiler"
+
+#elif defined(__GNUC__) // GNU C++
+
+#define COMPILER_GCC
+
+#	if defined(_MT)
+#		define MULTITHREADED
+#	endif
+
+#	if defined(_DEBUG)
+#		define DEBUG
+#	endif
+
+#	define INLINE inline
+#	define HASINT64
+
+#	define ASSEMBLY_ATT_SYNTAX
+#	define ASSEMBLY_BLOCK asm
+
+#elif defined(__DJGPP__) // DJGPP
+
+#	error "DJGPP : I don't know your compiler"
+
+#	define ASSEMBLY_ATT_SYNTAX
+
+#elif defined(__WATCOMC__) // WatcomC
+
+#	error "WatcomC : I don't know your compiler"
+
+#elif defined(__KCC) // Kai C++
+
+#	error "Kai C++ : I don't know your compiler"
+
+#elif defined(__sgi) // SGI MIPSpro C++
+
+#	error "SGI MIPSpro C++ : I don't know your compiler"
+
+#elif defined(__SUNPRO_CC) // Sun Workshop Compiler C++
+
+#	error "Sun Workshop Compiler C++ : I don't know your compiler"
+
+#elif defined(__HP_aCC) // HP aCC
+
+#	error "HP aCC : I don't know your compiler"
+
+#elif defined(__DECCXX) // Compaq Tru64 Unix cxx
+
+#	error "Compaq Tru64 Unix cxx : I don't know your compiler"
+
+#elif defined(__ghs) // Greenhills C++
+
+#	error "Greenhills C++ : I don't know your compiler"
+
+#elif defined(__BORLANDC__) // Borland
+
+#	if (__BORLANDC__ >= 0x561)
+#		define HASINT64
+#	endif
+
+#define COMPILER_BORLANDC
+
+#	if defined(__MT__)
+#		define MULTITHREADED
+#	endif
+
+#	if defined(__DEBUG)
+#		define DEBUG
+#	endif
+
+#	define INLINE inline
+#	define ASSEMBLY_INTEL_SYNTAX
+#	define ASSEMBLY_BLOCK _asm
+#	define NO_TEMPLATE_INLINE_ASSEMBLY
+
+#elif defined(__MWERKS__) // Metrowerks CodeWarrior
+
+#	error "Metrowerks CodeWarrior : I don't know your compiler"
+
+#elif defined(__MRC__) || defined(__SC__) // MPW MrCpp or SCpp
+
+#	error "MPW MrCpp or SCpp : I don't know your compiler"
+
+#elif defined(__IBMCPP__) // IBM Visual Age
+
+#	error "IBM Visual Age : I don't know your compiler"
+
+#elif defined(_MSC_VER) // Microsoft VC++
+	// must be last because many other compilers define this also
+
+#define COMPILER_MSVC
+
+#	if (_MSC_VER >= 1200) /* 1200 == VC++ 6.0 */
+#		define HASINT64
+#		define INLINE __forceinline
+#	endif
+
+#	if defined(_MT)
+#		define MULTITHREADED
+#	endif
+
+#	if defined(__DEBUG)
+#		define DEBUG
+#	endif
+
+#	define BASIC_TYPES_ALREADY_DEFINED
+	typedef unsigned __int8		u8;
+	typedef signed __int8		s8;
+	typedef unsigned __int16	u16;
+	typedef signed __int16		s16;
+	typedef unsigned __int32	u32;
+	typedef signed __int32		s32;
+	typedef float				f32;
+	typedef double				f64;
+#	if defined(HASINT64)
+		typedef unsigned __int64	u64;
+		typedef signed __int64		s64;
+#	endif
+
+#	define ASSEMBLY_INTEL_SYNTAX
+#	define ASSEMBLY_BLOCK __asm
+
+#	if (_MSC_VER <= 1200)
+#		pragma warning(disable : 4786) // truncation to 255 chars
+#	endif
+
+#else
+
+#	error "Unknown : I don't know your compiler"
+
+#endif // compilers
+
+
+	// Generic basic types
+#if !defined(BASIC_TYPES_ALREADY_DEFINED)
+	typedef unsigned char		u8;
+	typedef signed char			s8;
+	typedef unsigned short		u16;
+	typedef signed short		s16;
+	typedef unsigned int		u32;
+	typedef signed int			s32;
+	typedef float				f32;
+	typedef double				f64;
+#	if defined(HASINT64)
+	typedef unsigned long long	u64;
+	typedef signed long long	s64;
+#	endif
+#endif
+
+	// Fixed-point types
+	typedef s32 sfp22_10; // hi-Siiiiiiiiiiiiiiiiiiiii-lo | hi-ffffffffff-lo
+	typedef u32 ufp22_10; // hi-iiiiiiiiiiiiiiiiiiiiii-lo | hi-ffffffffff-lo
+	typedef s32 sfp16_16; // hi-Siiiiiiiiiiiiiii-lo | hi-ffffffffffffffff-lo
+	typedef u32 ufp16_16; // hi-iiiiiiiiiiiiiiii-lo | hi-ffffffffffffffff-lo
+
+/*
+	COMmy macros
+*/
+
+#define COM_RELEASE(ref) if (ref) { (ref)->Release(); (ref) = 0; }
+#define SINGLE_RELEASE(ref) if (ref) { delete (ref); (ref) = 0; }
+#define ARRAY_RELEASE(ref) if (ref) { delete [](ref); (ref) = 0; }
+
+	template<class T> class rect
+	{
+	public:
+		rect() : x(0), y(0), w(0), h(0) {}
+		rect(T xx, T yy, T ww, T hh) : x(xx), y(yy), w(ww), h(hh) {}
+
+		T x, y, w, h;
+	};
+
+	template<class T> class AutoArray
+	{
+		T *ptr;
+
+	public:
+		AutoArray(T *c_ptr)
+		{
+			ptr = c_ptr;
+		}
+		~AutoArray()
+		{
+			ARRAY_RELEASE(ptr);
+		}
+
+		INLINE void cancel()
+		{
+			ptr = 0;
+		}
+	};
+
+	template<class T> class Automatic
+	{
+		T *ptr;
+
+	public:
+		Automatic(T *c_ptr)
+		{
+			ptr = c_ptr;
+		}
+		~Automatic()
+		{
+			SINGLE_RELEASE(ptr);
+		}
+
+		INLINE void cancel()
+		{
+			ptr = 0;
+		}
+	};
+
+	// Derive from NoCopies to disallow copies of derived class
+	class NoCopies
+	{
+	protected:
+		NoCopies() {}
+		~NoCopies() {}
+
+	private:
+		NoCopies(const NoCopies &cp);
+		NoCopies &operator=(const NoCopies &cp);
+	};
+
+
+	// Byte-order swapping
+#define BOSWAP32(n) ( ((n) << 24) | (((n) & 0x00ff0000) >> 8) | (((n) & 0x0000ff00) << 8) | ((n) >> 24) ) /* only works for u32 */
+#define BOSWAP16(n) ( ((n) << 8) | ((n) >> 8) ) /* only works for u16 */
+
+#ifdef LITTLE_ENDIAN
+#	define swapLE(n)
+#	define getLE(n) (n)
+	INLINE void swapBE(u32 &n) { n = BOSWAP32(n); }
+	INLINE void swapBE(u16 &n) { n = BOSWAP16(n); }
+	INLINE u32 getBE(u32 n) { return BOSWAP32(n); }
+	INLINE u16 getBE(u16 n) { return BOSWAP16(n); }
+	INLINE void swapBE(s32 &n) { n = BOSWAP32((u32)n); }
+	INLINE void swapBE(s16 &n) { n = BOSWAP16((u16)n); }
+	INLINE s32 getBE(s32 n) { return BOSWAP32((u32)n); }
+	INLINE s16 getBE(s16 n) { return BOSWAP16((u16)n); }
+#else
+#	define swapBE(n)
+#	define getBE(n) (n)
+	INLINE void swapLE(u32 &n) { n = BOSWAP32(n); }
+	INLINE void swapLE(u16 &n) { n = BOSWAP16(n); }
+	INLINE u32 getLE(u32 n) { return BOSWAP32(n); }
+	INLINE u16 getLE(u16 n) { return BOSWAP16(n); }
+	INLINE void swapLE(s32 &n) { n = BOSWAP32((u32)n); }
+	INLINE void swapLE(s16 &n) { n = BOSWAP16((u16)n); }
+	INLINE s32 getLE(s32 n) { return BOSWAP32((u32)n); }
+	INLINE s16 getLE(s16 n) { return BOSWAP16((u16)n); }
+#endif
+
+} // namespace cat
+
+
+// Rotation
+#define ROL8(n, r)  ( ((n) << (r)) | ((n) >> ( 8 - (r))) ) /* only works for u8 */
+#define ROR8(n, r)  ( ((n) >> (r)) | ((n) << ( 8 - (r))) ) /* only works for u8 */
+#define ROL16(n, r) ( ((n) << (r)) | ((n) >> (16 - (r))) ) /* only works for u16 */
+#define ROR16(n, r) ( ((n) >> (r)) | ((n) << (16 - (r))) ) /* only works for u16 */
+#define ROL32(n, r) ( ((n) << (r)) | ((n) >> (32 - (r))) ) /* only works for u32 */
+#define ROR32(n, r) ( ((n) >> (r)) | ((n) << (32 - (r))) ) /* only works for u32 */
+
+/*
+	Add memory that is allocated on a 32-bit boundary
+	and has at least one block.
+*/
+#define MEMADD32(ptr, len, val) { \
+	register u32 *__data = (u32*)(ptr); /* pointer to data to clear */ \
+	register s32 __length = (len); /* number of 32-bit blocks */ \
+\
+	switch (__length % 8) \
+	{ \
+	case 0:	do {	*__data++ += (val); \
+	case 7:			*__data++ += (val); \
+	case 6:			*__data++ += (val); \
+	case 5:			*__data++ += (val); \
+	case 4:			*__data++ += (val); \
+	case 3:			*__data++ += (val); \
+	case 2:			*__data++ += (val); \
+	case 1:			*__data++ += (val); \
+					__length -= 8; \
+			} while(__length > 0); \
+	} \
+}
+
+/*
+	Safe null-terminated string -> char buffer copy
+*/
+#define STRNCPY(dest, src, size) { \
+	strncpy(dest, src, size); \
+	dest[size-1] = 0; \
+}
+
+/*
+	Because memory clearing is a frequent operation
+*/
+#define MEMCLR(dest, size) memset(dest, 0, size)
+
+// Works for arrays, also
+#define OBJCLR(object) memset(&(object), 0, sizeof(object))
+
+/*
+	Fast binary method of counting bits
+
+	MIT Hackmem from X11
+
+	Only works for 32-bit integers
+*/
+#define _C1B_INTERMED(n) ( (n) - (((n) >> 1) & 033333333333) - (((n) >> 2) & 011111111111) )
+#define COUNT1BITS32(n) ( ((_C1B_INTERMED(n) + (_C1B_INTERMED(n) >> 3)) & 030707070707) % 63 )
+
+/*
+	Consider N an ordered set of 1/0 values.
+
+	LESSTHAN2BITS(n) := there are less than 2 bits in set N
+
+	Proof:
+
+	(N - 1) will clear the least significant of the bits in N.
+
+	Three cases exist concerning (N-1):
+
+	N contains 0 bits
+		An intersection with N would be trivially null.
+	N contains 1 bit
+		The least only existing bit was cleared,
+			thus an intersection with the original
+			set WOULD be null.
+	N contains more than 1 bit
+		A more significant bit remains in the set,
+			thus an intersection with the original
+			set WOULD NOT be null.
+*/
+#define AT_LEAST_2_BITS(n) ( (n) & ((n) - 1) )
+
+#define LEAST_SIGNIFICANT_BIT(n) ( (n) & -(n) )
+
+#define IS_POWER_OF_2(n) ( n && !AT_LEAST_2_BITS(n) )
+
+INLINE cat::u32 next_highest_power_of_2(cat::u32 n)
+{
+	if (IS_POWER_OF_2(n)) return n;
+
+	cat::u16 b = 2;
+
+	while (n >>= 1) b <<= 1;
+
+	return b;
+}
+
+/*
+	CEIL*
+
+	Bump 'n' to the next unit of 'width'.
+*/
+#define CEIL_UNIT(n, width) ( ( (n) + (width) - 1 ) / (width) )
+#define CEIL(n, width) ( CEIL_UNIT(n, width) * (width) )
+
+/*
+	Quick character manipulation
+*/
+#define IS_ALPHA(ch) ( (((u8)(ch) & 0xc0) == 0x40) && ((((u8)(ch) - 1) & 0x1f) <= 0x19) )
+
+#define IS_NUM(ch) ( ((u8)(ch) - 0x30) < 10 )
+
+#define IS_ALPHANUM(ch) ( IS_ALPHA(ch) || IS_NUM(ch) )
+
+#define TO_LOWER(ch) (char)( (ch) | 0x20 ) /* must be upper/lower-case alpha */
+#define TO_UPPER(ch) (char)( (ch) & (~0x20) ) /* must be upper/lower-case alpha */
+
+
+#endif // TYPES_H
+
+
+



From youbastrd at sheep.berlios.de  Mon Nov 29 02:02:22 2004
From: youbastrd at sheep.berlios.de (Paul Forest at BerliOS)
Date: Mon, 29 Nov 2004 02:02:22 +0100
Subject: [Tw-light-svn] r103 - trunk/source
Message-ID: <200411290102.iAT12M1F016094@sheep.berlios.de>

Author: youbastrd
Date: 2004-11-29 02:02:07 +0100 (Mon, 29 Nov 2004)
New Revision: 103

Modified:
   trunk/source/scp.cpp
   trunk/source/scp.h
Log:
(Issue 33) adding command-line argument to specify server to connect to (in client mode), max clients (in server mode), and client listening port (in client mode).  Parameters are parsed and saved, but not used yet (will be implemented in mp-branch-2).  These are the "long" commandline formats.  TODO: add short formats; make use of these in mp-branch-2.

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-11-28 17:18:25 UTC (rev 102)
+++ trunk/source/scp.cpp	2004-11-29 01:02:07 UTC (rev 103)
@@ -60,6 +60,21 @@
 #include "melee/mfleet.h"
 
 
+///the server port to connect to in client mode.  
+unsigned serverPort = DEFAULT_SERVER_PORT;
+///the server address to connect to in client mode.
+std::string serverAddress(DEFAULT_SERVER_ADDRESS);
+
+///the maximum number of clients that can join in server mode.  Any additional
+///clients that try to join up won't be able to.  Only meaningful in server mode.
+unsigned serverMaxClients = DEFAULT_SERVER_MAX_CLIENTS;
+
+///the default port for a client to listen on.  Normally, with one client per
+///machine, you don't have to specify this.  But to run multiple clients on a
+///single machine, you should specify a unique port for each client on the same
+///machine.  Only meaningful in client mode.
+unsigned clientPort = DEFAULT_CLIENT_PORT;
+
 /// Get SVN revision number from version file (this function work if user does not have subversion)
 std::string GetSVNVersion()
 {
@@ -645,6 +660,49 @@
 	    log_debug("command-line argument -noidle\n");
 	    _no_idle = 1;
 	  }
+	else if (strstr(argv[i], COMMAND_LINE_SERVER_LONG) && (argc > i + 0)) {
+		if (strlen(argv[i]) > strlen(COMMAND_LINE_SERVER_LONG)) {
+			// users can use two formats for the address: an alphanumeric name, like
+			// "localhost", or a dotted ip address, like a.b.c.d .  Further, users
+			// can specify the port here as well, by adding a colon and the number to 
+			// the end of the address.  
+			const char * addressStart = strstr(argv[i], COMMAND_LINE_SERVER_LONG) + strlen(COMMAND_LINE_SERVER_LONG);
+			const char * addressEnd = strstr(addressStart, ":");
+			
+			// user has added a colon, indicating the port.  The port starts at addressEnd
+			// and goes to the end of argv[i]
+			if (addressEnd && strlen(addressEnd) > 1) { 
+				// this is +1 to skip the ":"
+				serverPort = atoi(addressEnd+1);
+			}
+			serverAddress.clear();
+			serverAddress.append(addressStart, addressEnd-addressStart);
+			
+			log_debug("commandline specified server as : host=[%s], port=[%u]\n", serverAddress.c_str(), serverPort);
+		}
+      }
+	else if (strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) && (argc > i + 0)) {
+		// this is the maximum number of computers that can connect to this program instance. 
+		// Used in server mode only, no effect otherwise.
+		if (strlen(argv[i]) > strlen(COMMAND_LINE_MAX_CLIENTS_LONG)) {
+			const char * portStart = strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) + strlen(COMMAND_LINE_MAX_CLIENTS_LONG);
+			if (strlen(portStart) > 1) {
+				serverMaxClients = atoi(portStart);
+			}
+			log_debug("commandline specified max clients as: serverMaxClients=[%u]\n", serverMaxClients);
+		}
+	}
+	else if (strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) && (argc > i + 0)) {
+		// this specifies the port this client will listen on.
+		// Used in client mode only, no effect otherwise.
+		if (strlen(argv[i]) > strlen(COMMAND_LINE_CLIENT_PORT_LONG)) {
+			const char * clientportStart = strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) + strlen(COMMAND_LINE_CLIENT_PORT_LONG);
+			if (strlen(clientportStart) > 1) {
+				clientPort = atoi(clientportStart);
+			}
+			log_debug("commandline specified client port as : port=[%u]\n", clientPort);
+		}
+	}
 	else if (!strcmp(argv[i], "-play") && (argc > i + 2)) 
 	  {
 	    log_debug("command-line argument -play\n");

Modified: trunk/source/scp.h
===================================================================
--- trunk/source/scp.h	2004-11-28 17:18:25 UTC (rev 102)
+++ trunk/source/scp.h	2004-11-29 01:02:07 UTC (rev 103)
@@ -56,6 +56,37 @@
 extern std::string menuDisabled;
 extern std::string menuSpecial;
 
+#define COMMAND_LINE_SERVER_LONG "--server="
+#define COMMAND_LINE_MAX_CLIENTS_LONG "--max-clients="
+#define COMMAND_LINE_CLIENT_PORT_LONG "--client-port="
+	
+///The default server address to connect to as a client.  Only meaningful
+///in client mode.
+#define DEFAULT_SERVER_ADDRESS "localhost"
+///The default server port to connect to as a client.  Only meaningful 
+///in client mode.
+#define DEFAULT_SERVER_PORT 15515
+
+///the server address to connect to in client mode.
+extern std::string serverAddress;
+///the server port to connect to in client mode.  
+extern unsigned serverPort;
+
+///the default maximum number of clients that can connect in server mode.
+#define DEFAULT_SERVER_MAX_CLIENTS 15
+///the maximum number of clients that can join in server mode.  Any additional
+///clients that try to join up won't be able to.  Only meaningful in server mode.
+extern unsigned serverMaxClients;
+
+///the default port for a client to listen on.  Normally, with one client per
+///machine, you don't have to specify this.  But to run multiple clients on a
+///single machine, you should specify a unique port for each client on the same
+///machine.  
+#define DEFAULT_CLIENT_PORT 15516
+///the port to listen to in client mode.  Only meaningful in client mode.
+extern unsigned clientPort;
+
+
 extern int MAX_TEAMS;
 
 /*! This is the title music file name */



From yurand at sheep.berlios.de  Mon Nov 29 05:52:02 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Mon, 29 Nov 2004 05:52:02 +0100
Subject: [Tw-light-svn] r104 - in trunk: . mingw-libs/include mingw-libs/include/cppunit mingw-libs/include/cppunit/config mingw-libs/include/cppunit/extensions mingw-libs/include/cppunit/plugin mingw-libs/include/cppunit/portability mingw-libs/include/cppunit/tools mingw-libs/include/cppunit/ui mingw-libs/include/cppunit/ui/mfc mingw-libs/include/cppunit/ui/qt mingw-libs/include/cppunit/ui/text mingw-libs/lib source source/games source/tests
Message-ID: <200411290452.iAT4q2CL023248@sheep.berlios.de>

Author: yurand
Date: 2004-11-29 05:51:59 +0100 (Mon, 29 Nov 2004)
New Revision: 104

Added:
   trunk/mingw-libs/include/cppunit/
   trunk/mingw-libs/include/cppunit/AdditionalMessage.h
   trunk/mingw-libs/include/cppunit/Asserter.h
   trunk/mingw-libs/include/cppunit/BriefTestProgressListener.h
   trunk/mingw-libs/include/cppunit/CompilerOutputter.h
   trunk/mingw-libs/include/cppunit/Exception.h
   trunk/mingw-libs/include/cppunit/Makefile
   trunk/mingw-libs/include/cppunit/Makefile.am
   trunk/mingw-libs/include/cppunit/Makefile.in
   trunk/mingw-libs/include/cppunit/Message.h
   trunk/mingw-libs/include/cppunit/Outputter.h
   trunk/mingw-libs/include/cppunit/Portability.h
   trunk/mingw-libs/include/cppunit/Protector.h
   trunk/mingw-libs/include/cppunit/SourceLine.h
   trunk/mingw-libs/include/cppunit/SynchronizedObject.h
   trunk/mingw-libs/include/cppunit/Test.h
   trunk/mingw-libs/include/cppunit/TestAssert.h
   trunk/mingw-libs/include/cppunit/TestCaller.h
   trunk/mingw-libs/include/cppunit/TestCase.h
   trunk/mingw-libs/include/cppunit/TestComposite.h
   trunk/mingw-libs/include/cppunit/TestFailure.h
   trunk/mingw-libs/include/cppunit/TestFixture.h
   trunk/mingw-libs/include/cppunit/TestLeaf.h
   trunk/mingw-libs/include/cppunit/TestListener.h
   trunk/mingw-libs/include/cppunit/TestPath.h
   trunk/mingw-libs/include/cppunit/TestResult.h
   trunk/mingw-libs/include/cppunit/TestResultCollector.h
   trunk/mingw-libs/include/cppunit/TestRunner.h
   trunk/mingw-libs/include/cppunit/TestSuccessListener.h
   trunk/mingw-libs/include/cppunit/TestSuite.h
   trunk/mingw-libs/include/cppunit/TextOutputter.h
   trunk/mingw-libs/include/cppunit/TextTestProgressListener.h
   trunk/mingw-libs/include/cppunit/TextTestResult.h
   trunk/mingw-libs/include/cppunit/TextTestRunner.h
   trunk/mingw-libs/include/cppunit/XmlOutputter.h
   trunk/mingw-libs/include/cppunit/XmlOutputterHook.h
   trunk/mingw-libs/include/cppunit/config-auto.h
   trunk/mingw-libs/include/cppunit/config/
   trunk/mingw-libs/include/cppunit/config/CppUnitApi.h
   trunk/mingw-libs/include/cppunit/config/Makefile
   trunk/mingw-libs/include/cppunit/config/Makefile.am
   trunk/mingw-libs/include/cppunit/config/Makefile.in
   trunk/mingw-libs/include/cppunit/config/SelectDllLoader.h
   trunk/mingw-libs/include/cppunit/config/config-bcb5.h
   trunk/mingw-libs/include/cppunit/config/config-mac.h
   trunk/mingw-libs/include/cppunit/config/config-msvc6.h
   trunk/mingw-libs/include/cppunit/extensions/
   trunk/mingw-libs/include/cppunit/extensions/AutoRegisterSuite.h
   trunk/mingw-libs/include/cppunit/extensions/ExceptionTestCaseDecorator.h
   trunk/mingw-libs/include/cppunit/extensions/HelperMacros.h
   trunk/mingw-libs/include/cppunit/extensions/Makefile
   trunk/mingw-libs/include/cppunit/extensions/Makefile.am
   trunk/mingw-libs/include/cppunit/extensions/Makefile.in
   trunk/mingw-libs/include/cppunit/extensions/Orthodox.h
   trunk/mingw-libs/include/cppunit/extensions/RepeatedTest.h
   trunk/mingw-libs/include/cppunit/extensions/TestCaseDecorator.h
   trunk/mingw-libs/include/cppunit/extensions/TestDecorator.h
   trunk/mingw-libs/include/cppunit/extensions/TestFactory.h
   trunk/mingw-libs/include/cppunit/extensions/TestFactoryRegistry.h
   trunk/mingw-libs/include/cppunit/extensions/TestFixtureFactory.h
   trunk/mingw-libs/include/cppunit/extensions/TestNamer.h
   trunk/mingw-libs/include/cppunit/extensions/TestSetUp.h
   trunk/mingw-libs/include/cppunit/extensions/TestSuiteBuilderContext.h
   trunk/mingw-libs/include/cppunit/extensions/TestSuiteFactory.h
   trunk/mingw-libs/include/cppunit/extensions/TypeInfoHelper.h
   trunk/mingw-libs/include/cppunit/plugin/
   trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManager.h
   trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManagerException.h
   trunk/mingw-libs/include/cppunit/plugin/Makefile
   trunk/mingw-libs/include/cppunit/plugin/Makefile.am
   trunk/mingw-libs/include/cppunit/plugin/Makefile.in
   trunk/mingw-libs/include/cppunit/plugin/PlugInManager.h
   trunk/mingw-libs/include/cppunit/plugin/PlugInParameters.h
   trunk/mingw-libs/include/cppunit/plugin/TestPlugIn.h
   trunk/mingw-libs/include/cppunit/plugin/TestPlugInDefaultImpl.h
   trunk/mingw-libs/include/cppunit/portability/
   trunk/mingw-libs/include/cppunit/portability/CppUnitDeque.h
   trunk/mingw-libs/include/cppunit/portability/CppUnitMap.h
   trunk/mingw-libs/include/cppunit/portability/CppUnitSet.h
   trunk/mingw-libs/include/cppunit/portability/CppUnitStack.h
   trunk/mingw-libs/include/cppunit/portability/CppUnitVector.h
   trunk/mingw-libs/include/cppunit/portability/Makefile
   trunk/mingw-libs/include/cppunit/portability/Makefile.am
   trunk/mingw-libs/include/cppunit/portability/Makefile.in
   trunk/mingw-libs/include/cppunit/tools/
   trunk/mingw-libs/include/cppunit/tools/Algorithm.h
   trunk/mingw-libs/include/cppunit/tools/Makefile
   trunk/mingw-libs/include/cppunit/tools/Makefile.am
   trunk/mingw-libs/include/cppunit/tools/Makefile.in
   trunk/mingw-libs/include/cppunit/tools/StringTools.h
   trunk/mingw-libs/include/cppunit/tools/XmlDocument.h
   trunk/mingw-libs/include/cppunit/tools/XmlElement.h
   trunk/mingw-libs/include/cppunit/ui/
   trunk/mingw-libs/include/cppunit/ui/Makefile
   trunk/mingw-libs/include/cppunit/ui/Makefile.am
   trunk/mingw-libs/include/cppunit/ui/Makefile.in
   trunk/mingw-libs/include/cppunit/ui/mfc/
   trunk/mingw-libs/include/cppunit/ui/mfc/Makefile
   trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.am
   trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.in
   trunk/mingw-libs/include/cppunit/ui/mfc/MfcTestRunner.h
   trunk/mingw-libs/include/cppunit/ui/mfc/TestRunner.h
   trunk/mingw-libs/include/cppunit/ui/qt/
   trunk/mingw-libs/include/cppunit/ui/qt/Config.h
   trunk/mingw-libs/include/cppunit/ui/qt/Makefile
   trunk/mingw-libs/include/cppunit/ui/qt/Makefile.am
   trunk/mingw-libs/include/cppunit/ui/qt/Makefile.in
   trunk/mingw-libs/include/cppunit/ui/qt/QtTestRunner.h
   trunk/mingw-libs/include/cppunit/ui/qt/TestRunner.h
   trunk/mingw-libs/include/cppunit/ui/text/
   trunk/mingw-libs/include/cppunit/ui/text/Makefile
   trunk/mingw-libs/include/cppunit/ui/text/Makefile.am
   trunk/mingw-libs/include/cppunit/ui/text/Makefile.in
   trunk/mingw-libs/include/cppunit/ui/text/TestRunner.h
   trunk/mingw-libs/include/cppunit/ui/text/TextTestRunner.h
   trunk/mingw-libs/lib/libcppunit.a
   trunk/source/games/gadventure.h
   trunk/source/tests/testmain.h
Removed:
   trunk/tests.lst
Modified:
   trunk/makefile
   trunk/source/scp.cpp
   trunk/source/scp.h
   trunk/source/tests/testdatapath.cpp
   trunk/source/tests/testmain.cpp
   trunk/sources.lst
Log:
Adding cppunit framework. Active in debug configuration


Modified: trunk/makefile
===================================================================
--- trunk/makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -3,21 +3,23 @@
 #                          {xmingw=1}                                          #
 #                          {win32=1}                                           #
 #                          {DATAPATH=PATH}                                     #
-#                          {EXECPATH=PATH}				       #
-#                          {TEST=1}                                            #
+#                          {EXECPATH=PATH}                                     #
+#                          {TEST=1}        				       #
 #                                                                              #
 # Define win32=1    when compiling with Mingw32 gcc compiler for windows       #
 # Define debug=1    when you want to build debug version of TimeWarp           #
 # Define xmingw=1   when compiling  win32 binary with Mingw gcc crosscompiler  #
 # Define DATAPATH   to specify where datafile stored (*nix version only)       #
 # Define EXECPATH   to specify where executable should be placed               #
-# Define TEST       to compile tests, you need cppunit library for it          #
+# Define TEST=1     to run unit test after compilation (require cppunit        #
+#                   library). Default for debug configuration                  #
 #                                                                              #
-# Running just make builds the release version of TimeWarp for *nix            #
+# Running just make builds the release version of TW-Light for *nix            #
 # (Linux, FreeBSD, ...)                                                        #
 #                                                                              #
-# The game depends on Allegro (4.0.x), SDL, SDL_mixer with ogg support         # 
-# libraries, so you need to install them before running.                       #
+# The game depends on Allegro (4.0.x), SDL, SDL_mixer with ogg support,        # 
+# libraries, so you need to install them before running. cppunit 1.10.*        #
+# required for TEST=1 configuration                                            #
 #                                                                              #
 ################################################################################
 
@@ -74,9 +76,10 @@
         source/other source/ships source/sc1ships source/sc2ships \
         source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
-        source/libraries/raknet source/libraries/lua source/libraries/lua/lib
+        source/libraries/raknet \
+        source/libraries/lua source/libraries/lua/lib 
 
-#FILELIST= ${shell find source -type f "(" -name "*.c" -o -name "*.cpp" ")"}
+#FILELIST := ${shell find source -type f "(" -name "*.c" -o -name "*.cpp" ")"}
 FILELIST= ${shell cat sources.lst}
 
 BASE_NAMES = $(basename $(notdir $(FILELIST)))
@@ -88,21 +91,19 @@
 
 #################################################################################################################
 ifndef win32
-ARCH = $(shell echo `arch`)
-ifeq ($(ARCH),ppc)
-ARCH    = powerpc
+	ARCH := $(shell echo `arch`)
+	ifeq ($(ARCH),ppc)
+		ARCH    = powerpc
 endif
 else
-ARCH = i586
+	ARCH := i586
 endif
 
-
-#FILELIST = source /s.cpp
-
 ifdef debug
 	CFLAGS += -g -DDEBUGMODE
 	OBJDIR := ${addsuffix -debug,$(OBJDIR)}
-	NAME := ${addsuffix -debug,$(NAME)}
+	NAME   := ${addsuffix -debug,$(NAME)}
+	TEST=1
 else
 	CFLAGS += -Os -mcpu=$(ARCH) -s
 endif
@@ -111,36 +112,37 @@
 	OBJDIR := ${addsuffix -win32,$(OBJDIR)}
 	NAME := ${addsuffix .exe,$(NAME)}
 	CFLAGS += -DWIN32 -I mingw-libs/include -I mingw-libs/include/SDL 
-	LIBS += -L mingw-libs/lib -lalleg -lwinmm -lws2_32 -lSDL -lSDLmain
+	LIBS += -L mingw-libs/lib -lalleg -lwinmm -lws2_32 -lSDL -lSDLmain 
 else
 	TIMESTAMP = ${shell LC_TIME="POSIX" date +%c}
 	EXPDIR=tw-light-$(PRODUCTVERSION)r$(SVNVERSION)
 	CFLAGS += -DLINUX
-	INCLUDES = ${shell allegro-config --cflags} ${shell sdl-config --cflags} 
+	INCLUDES := ${shell allegro-config --cflags} ${shell sdl-config --cflags} 
 	CFLAGS += $(INCLUDES)
-	LIBS += ${shell allegro-config --libs} -pthread ${shell sdl-config --libs}
+	LIBS_CONFIG := ${shell allegro-config --libs} -pthread ${shell sdl-config --libs} 
+	LIBS += $(LIBS_CONFIG)
 endif
 
 CFLAGS += -I./source -I./source/libraries -I./source/libraries/lua
 
 ifdef TEST
-CFLAGS += -DTEST ${shell cppunit-config --cflags }
-LIBS += ${shell cppunit-config --libs }
+
+ifdef win32
+	CPPUNIT_LIBS := -lcppunit
+else
+	CPPUNIT_LIBS := ${shell cppunit-config --libs }
+	CPPUNIT_INCLUDE := ${shell cppunit-config --cflags }
 endif
 
-#CFLAGS += ${addprefix -I./, $(VPATH)}
+CFLAGS += -DTW_CPPUNIT_TESTS $(CPPUNIT_INCLUDE)
+LIBS   += $(CPPUNIT_LIBS)
+endif
 
 LIBS += -lSDL_mixer
-#-llualib -llua
 
 OBJS = $(addprefix $(OBJDIR)/,$(POBJS))
 DEPS = $(addprefix $(OBJDIR)/,$(PDEPS))
 
-TEST_OBJDIR = objt
-TEST_OBJS = $(addprefix $(TEST_OBJDIR)/,$(TEST_POBJS))
-TEST_DEPS = $(addprefix $(TEST_OBJDIR)/,$(TEST_PDEPS))
-
-
 ifdef win32
 ifndef debug
 SUBSYSTEM=-Wl,--subsystem=windows
@@ -161,6 +163,7 @@
 
 $(NAME): $(OBJDIR) $(OBJS)
 	$(LD) $(CFLAGS) $(SUBSYSTEM) -o $@ $(OBJDIR)/*.o $(LIBS) 
+	./$(NAME) -test
 
 $(OBJDIR)/%.o: %.cpp
 	$(CX) -MMD $(CFLAGS) -c $< -o $@
@@ -171,13 +174,6 @@
 $(OBJDIR)/winicon.o: tw-light.rc tw-light.ico
 	$(RC) tw-light.rc -o $(OBJDIR)/winicon.o
 
-
-test: $(TEST_OBJDIR) $(TEST_OBJS) testrunner
-	./testrunner
-
-$(TEST_OBJDIR):
-	mkdir $(TEST_OBJDIR)
-
 clean:
 	$(RM) $(OBJDIR)/*.o
 	$(RM) $(OBJDIR)/*.d

Added: trunk/mingw-libs/include/cppunit/AdditionalMessage.h
===================================================================
--- trunk/mingw-libs/include/cppunit/AdditionalMessage.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/AdditionalMessage.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,76 @@
+#ifndef CPPUNIT_ADDITIONALMESSAGE_H
+#define CPPUNIT_ADDITIONALMESSAGE_H
+
+#include <cppunit/Message.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief An additional Message for assertions.
+ * \ingroup CreatingNewAssertions
+ *
+ * Provides a implicit constructor that takes a single string. This allow this
+ * class to be used as the message arguments in macros.
+ *
+ * The constructed object is either a Message with a single detail string if
+ * a string was passed to the macro, or a copy of the Message passed to the macro.
+ *
+ * Here is an example of usage:
+ * \code
+ * 
+ *   void checkStringEquals( const std::string &expected,
+ *                          const std::string &actual,
+ *                           const CppUnit::SourceLine &sourceLine,
+ *                           const CppUnit::AdditionalMessage &message );
+ *  
+ *   #define XTLUT_ASSERT_STRING_EQUAL_MESSAGE( expected, actual, message )  \
+ *     ::XtlUt::Impl::checkStringEquals( ::Xtl::toString(expected),        \
+ *                                       ::Xtl::toString(actual),          \
+ *                                       CPPUNIT_SOURCELINE(),             \
+ *                                       message )
+ * \endcode
+ *
+ * In the previous example, the user can specify a simple string for \a message,
+ * or a complex Message object.
+ *
+ * \see Message
+ */
+class CPPUNIT_API AdditionalMessage : public Message
+{
+public:
+  typedef Message SuperClass;
+
+  /// Constructs an empty Message.
+  AdditionalMessage();
+
+  /*! \brief Constructs a Message with the specified detail string.
+   * \param detail1 Detail string of the message. If empty, then it is not added.
+   */
+  AdditionalMessage( const std::string &detail1 );
+
+  /*! \brief Constructs a Message with the specified detail string.
+   * \param detail1 Detail string of the message. If empty, then it is not added.
+   */
+  AdditionalMessage( const char *detail1 );
+
+  /*! \brief Constructs a copy of the specified message.
+   * \param other Message to copy.
+   */
+  AdditionalMessage( const Message &other );
+
+  /*! \brief Assignment operator.
+   * \param other Message to copy.
+   * \return Reference on this object.
+   */
+  AdditionalMessage &operator =( const Message &other );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+
+
+#endif  // CPPUNIT_ADDITIONALMESSAGE_H

Added: trunk/mingw-libs/include/cppunit/Asserter.h
===================================================================
--- trunk/mingw-libs/include/cppunit/Asserter.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Asserter.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,143 @@
+#ifndef CPPUNIT_ASSERTER_H
+#define CPPUNIT_ASSERTER_H
+
+#include <cppunit/AdditionalMessage.h>
+#include <cppunit/SourceLine.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Message;
+
+
+/*! \brief A set of functions to help writing assertion macros.
+ * \ingroup CreatingNewAssertions
+ *
+ * Here is an example of assertion, a simplified version of the
+ * actual assertion implemented in examples/cppunittest/XmlUniformiser.h:
+ * \code
+ * #include <cppunit/SourceLine.h>
+ * #include <cppunit/TestAssert.h>
+ * 
+ * void 
+ * checkXmlEqual( std::string expectedXml,
+ *                std::string actualXml,
+ *                CppUnit::SourceLine sourceLine )
+ * {
+ *   std::string expected = XmlUniformiser( expectedXml ).stripped();
+ *   std::string actual = XmlUniformiser( actualXml ).stripped();
+ * 
+ *   if ( expected == actual )
+ *     return;
+ * 
+ *   ::CppUnit::Asserter::failNotEqual( expected,
+ *                                      actual,
+ *                                      sourceLine );
+ * }
+ * 
+ * /// Asserts that two XML strings are equivalent.
+ * #define CPPUNITTEST_ASSERT_XML_EQUAL( expected, actual ) \
+ *     checkXmlEqual( expected, actual,                     \
+ *                    CPPUNIT_SOURCELINE() )
+ * \endcode
+ */
+struct Asserter
+{
+  /*! \brief Throws a Exception with the specified message and location.
+   */
+  static void CPPUNIT_API fail( const Message &message, 
+                                const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \deprecated Use fail( Message, SourceLine ) instead.
+   */
+  static void CPPUNIT_API fail( std::string message, 
+                                const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param message Message explaining the assertion failiure.
+   * \param sourceLine Location of the assertion.
+   */
+  static void CPPUNIT_API failIf( bool shouldFail, 
+                                  const Message &message, 
+                                  const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \deprecated Use failIf( bool, Message, SourceLine ) instead.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param message Message explaining the assertion failiure.
+   * \param sourceLine Location of the assertion.
+   */
+  static void CPPUNIT_API failIf( bool shouldFail, 
+                                  std::string message, 
+                                  const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Returns a expected value string for a message.
+   * Typically used to create 'not equal' message, or to check that a message
+   * contains the expected content when writing unit tests for your custom 
+   * assertions.
+   *
+   * \param expectedValue String that represents the expected value.
+   * \return \a expectedValue prefixed with "Expected: ".
+   * \see makeActual().
+   */
+  static std::string CPPUNIT_API makeExpected( const std::string &expectedValue );
+
+  /*! \brief Returns an actual value string for a message.
+   * Typically used to create 'not equal' message, or to check that a message
+   * contains the expected content when writing unit tests for your custom 
+   * assertions.
+   *
+   * \param actualValue String that represents the actual value.
+   * \return \a actualValue prefixed with "Actual  : ".
+   * \see makeExpected().
+   */
+  static std::string CPPUNIT_API makeActual( const std::string &actualValue );
+
+  static Message CPPUNIT_API makeNotEqualMessage( const std::string &expectedValue,
+                                                  const std::string &actualValue,
+                                                  const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                                  const std::string &shortDescription = "equality assertion failed");
+
+  /*! \brief Throws an Exception with the specified message and location.
+   * \param expected Text describing the expected value.
+   * \param actual Text describing the actual value.
+   * \param sourceLine Location of the assertion.
+   * \param additionalMessage Additional message. Usually used to report
+   *                          what are the differences between the expected and actual value.
+   * \param shortDescription Short description for the failure message.
+   */
+  static void CPPUNIT_API failNotEqual( std::string expected, 
+                                        std::string actual, 
+                                        const SourceLine &sourceLine,
+                                        const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                        std::string shortDescription = "equality assertion failed" );
+
+  /*! \brief Throws an Exception with the specified message and location.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param expected Text describing the expected value.
+   * \param actual Text describing the actual value.
+   * \param sourceLine Location of the assertion.
+   * \param additionalMessage Additional message. Usually used to report
+   *                          where the "difference" is located.
+   * \param shortDescription Short description for the failure message.
+   */
+  static void CPPUNIT_API failNotEqualIf( bool shouldFail,
+                                          std::string expected, 
+                                          std::string actual, 
+                                          const SourceLine &sourceLine,
+                                          const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                          std::string shortDescription = "equality assertion failed" );
+
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_ASSERTER_H

Added: trunk/mingw-libs/include/cppunit/BriefTestProgressListener.h
===================================================================
--- trunk/mingw-libs/include/cppunit/BriefTestProgressListener.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/BriefTestProgressListener.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,43 @@
+#ifndef CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
+#define CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
+
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief TestListener that prints the name of each test before running it.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API BriefTestProgressListener : public TestListener
+{
+public:
+  /*! Constructs a BriefTestProgressListener object.
+   */
+  BriefTestProgressListener();
+
+  /// Destructor.
+  virtual ~BriefTestProgressListener();
+
+  void startTest( Test *test );
+
+  void addFailure( const TestFailure &failure );
+
+  void endTest( Test *test );
+
+private:
+  /// Prevents the use of the copy constructor.
+  BriefTestProgressListener( const BriefTestProgressListener &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const BriefTestProgressListener &copy );
+
+private:
+  bool m_lastTestFailed;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_BRIEFTESTPROGRESSLISTENER_H

Added: trunk/mingw-libs/include/cppunit/CompilerOutputter.h
===================================================================
--- trunk/mingw-libs/include/cppunit/CompilerOutputter.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/CompilerOutputter.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,146 @@
+#ifndef CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
+#define CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Outputter.h>
+#include <iostream>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class Test;
+class TestFailure;
+class TestResultCollector;
+
+/*! 
+ * \brief Outputs a TestResultCollector in a compiler compatible format.
+ * \ingroup WritingTestResult
+ *
+ * Printing the test results in a compiler compatible format (assertion
+ * location has the same format as compiler error), allow you to use your
+ * IDE to jump to the assertion failure. Location format can be customized (see
+ * setLocationFormat() ).
+ *
+ * For example, when running the test in a post-build with VC++, if an assertion
+ * fails, you can jump to the assertion by pressing F4 (jump to next error).
+ *
+ * Heres is an example of usage (from examples/cppunittest/CppUnitTestMain.cpp):
+ * \code
+ * int main( int argc, char* argv[] ) {
+ *   // if command line contains "-selftest" then this is the post build check
+ *   // => the output must be in the compiler error format.
+ *   bool selfTest = (argc > 1)  &&  
+ *                   (std::string("-selftest") == argv[1]);
+ *
+ *   CppUnit::TextUi::TestRunner runner;
+ *   runner.addTest( CppUnitTest::suite() );   // Add the top suite to the test runner
+ * 
+ *  if ( selfTest )
+ *   { // Change the default outputter to a compiler error format outputter
+ *     // The test runner owns the new outputter.
+ *     runner.setOutputter( new CppUnit::CompilerOutputter( &runner.result(),
+ *                                                          std::cerr ) );
+ *   }
+ * 
+ *  // Run the test and don't wait a key if post build check.
+ *   bool wasSuccessful = runner.run( "", !selfTest );
+ * 
+ *   // Return error code 1 if the one of test failed.
+ *   return wasSuccessful ? 0 : 1;
+ * }
+ * \endcode
+ */
+class CPPUNIT_API CompilerOutputter : public Outputter
+{
+public:
+  /*! \brief Constructs a CompilerOutputter object.
+   * \param result Result of the test run.
+   * \param stream Stream used to output test result.
+   * \param locationFormat Error location format used by your compiler. Default
+   *                       to \c CPPUNIT_COMPILER_LOCATION_FORMAT which is defined
+   *                       in the configuration file. See setLocationFormat() for detail.
+   * \see setLocationFormat().
+   */
+  CompilerOutputter( TestResultCollector *result,
+                     std::ostream &stream,
+                     const std::string &locationFormat = CPPUNIT_COMPILER_LOCATION_FORMAT );
+
+  /// Destructor.
+  virtual ~CompilerOutputter();
+
+  /*! \brief Sets the error location format.
+   * 
+   * Indicates the format used to report location of failed assertion. This format should
+   * match the one used by your compiler.
+   *
+   * The location format is a string in which the occurence of the following character
+   * sequence are replaced:
+   *
+   * - "%l" => replaced by the line number
+   * - "%p" => replaced by the full path name of the file ("G:\prg\vc\cppunit\MyTest.cpp")
+   * - "%f" => replaced by the base name of the file ("MyTest.cpp")
+   *
+   * Some examples:
+   *
+   * - VC++ error location format: "%p(%l):" => produce "G:\prg\MyTest.cpp(43):"
+   * - GCC error location format: "%f:%l:" => produce "MyTest.cpp(43):"
+   * 
+   * Thoses are the two compilers currently <em>supported</em> (gcc format is used if
+   * VC++ is not detected). If you want your compiler to be automatically supported by
+   * CppUnit, send a mail to the mailing list (preferred), or submit a feature request
+   * that indicates how to detect your compiler with the preprocessor (#ifdef...) and
+   * your compiler location format.
+   */
+  void setLocationFormat( const std::string &locationFormat );
+
+  /*! \brief Creates an instance of an outputter that matches your current compiler.
+   * \deprecated This class is specialized through parameterization instead of subclassing...
+   *             Use CompilerOutputter::CompilerOutputter instead.
+   */
+  static CompilerOutputter *defaultOutputter( TestResultCollector *result,
+                                              std::ostream &stream );
+
+  void write();
+
+  void setNoWrap();
+
+  void setWrapColumn( int wrapColumn );
+
+  int wrapColumn() const;
+
+  virtual void printSuccess();
+  virtual void printFailureReport();
+  virtual void printFailuresList();
+  virtual void printStatistics();
+  virtual void printFailureDetail( TestFailure *failure );
+  virtual void printFailureLocation( SourceLine sourceLine );
+  virtual void printFailureType( TestFailure *failure );
+  virtual void printFailedTestName( TestFailure *failure );
+  virtual void printFailureMessage( TestFailure *failure );
+
+private:
+  /// Prevents the use of the copy constructor.
+  CompilerOutputter( const CompilerOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const CompilerOutputter &copy );
+
+  virtual bool processLocationFormatCommand( char command, 
+                                             const SourceLine &sourceLine );
+
+  virtual std::string extractBaseName( const std::string &fileName ) const;
+
+private:
+  TestResultCollector *m_result;
+  std::ostream &m_stream;
+  std::string m_locationFormat;
+  int m_wrapColumn;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H

Added: trunk/mingw-libs/include/cppunit/Exception.h
===================================================================
--- trunk/mingw-libs/include/cppunit/Exception.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Exception.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,90 @@
+#ifndef CPPUNIT_EXCEPTION_H
+#define CPPUNIT_EXCEPTION_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Message.h>
+#include <cppunit/SourceLine.h>
+#include <exception>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Exceptions thrown by failed assertions.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * Exception is an exception that serves
+ * descriptive strings through its what() method
+ */
+class CPPUNIT_API Exception : public std::exception
+{
+public:
+  /*! \brief Constructs the exception with the specified message and source location.
+   * \param message Message associated to the exception.
+   * \param sourceLine Source location related to the exception.
+   */
+  Exception( const Message &message = Message(), 
+             const SourceLine &sourceLine = SourceLine() );
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+  /*!
+   * \deprecated Use other constructor instead.
+   */
+  Exception( std::string  message, 
+	     long lineNumber, 
+	     std::string fileName );
+#endif
+
+  /*! \brief Constructs a copy of an exception.
+   * \param other Exception to copy.
+   */
+  Exception( const Exception &other );
+
+  /// Destructs the exception
+  virtual ~Exception() throw();
+
+  /// Performs an assignment
+  Exception &operator =( const Exception &other );
+
+  /// Returns descriptive message
+  const char *what() const throw();
+
+  /// Location where the error occured
+  SourceLine sourceLine() const;
+
+  /// Message related to the exception.
+  Message message() const;
+
+  /// Set the message.
+  void setMessage( const Message &message );
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+  /// The line on which the error occurred
+  long lineNumber() const;
+
+  /// The file in which the error occurred
+  std::string fileName() const;
+
+  static const std::string UNKNOWNFILENAME;
+  static const long UNKNOWNLINENUMBER;
+#endif
+
+  /// Clones the exception.
+  virtual Exception *clone() const;
+
+protected:
+  // VC++ does not recognize call to parent class when prefixed
+  // with a namespace. This is a workaround.
+  typedef std::exception SuperClass;
+
+  Message m_message;
+  SourceLine m_sourceLine;
+  std::string m_whatMessage;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXCEPTION_H
+

Added: trunk/mingw-libs/include/cppunit/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,516 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+SUBDIRS = extensions ui plugin config tools portability
+
+DISTCLEANFILES = config-auto.h
+
+libcppunitincludedir = $(includedir)/cppunit
+libcppunitinclude_HEADERS = \
+	config-auto.h \
+  AdditionalMessage.h \
+	Asserter.h \
+	BriefTestProgressListener.h \
+	CompilerOutputter.h \
+	Exception.h \
+	Message.h \
+	Outputter.h \
+	Portability.h \
+	Protector.h \
+	SourceLine.h \
+	SynchronizedObject.h \
+	Test.h \
+	TestAssert.h \
+	TestCase.h \
+	TestCaller.h \
+	TestComposite.h \
+	TestFailure.h \
+	TestFixture.h \
+	TestLeaf.h \
+	TestPath.h \
+	TestResult.h \
+	TestResultCollector.h \
+	TestRunner.h \
+	TestSuccessListener.h \
+	TestSuite.h \
+	TextOutputter.h \
+	TextTestProgressListener.h \
+	TextTestResult.h \
+	TextTestRunner.h \
+	TestListener.h \
+	XmlOutputter.h \
+	XmlOutputterHook.h
+
+subdir = include/cppunit
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+
+RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
+	ps-recursive install-info-recursive uninstall-info-recursive \
+	all-recursive install-data-recursive install-exec-recursive \
+	installdirs-recursive install-recursive uninstall-recursive \
+	check-recursive installcheck-recursive
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+DIST_SUBDIRS = $(SUBDIRS)
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if (etags --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	else \
+	  include_option=--include; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$(top_distdir)" \
+	        distdir=../$(distdir)/$$subdir \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	$(MAKE) $(AM_MAKEFLAGS) \
+	  top_distdir="$(top_distdir)" distdir="$(distdir)" \
+	  dist-hook
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(HEADERS)
+installdirs: installdirs-recursive
+installdirs-am:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
+	clean-generic clean-libtool clean-recursive ctags \
+	ctags-recursive distclean distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-data install-data-am install-data-recursive \
+	install-exec install-exec-am install-exec-recursive \
+	install-info install-info-am install-info-recursive \
+	install-libcppunitincludeHEADERS install-man install-recursive \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am installdirs-recursive maintainer-clean \
+	maintainer-clean-generic maintainer-clean-recursive mostlyclean \
+	mostlyclean-generic mostlyclean-libtool mostlyclean-recursive \
+	pdf pdf-am pdf-recursive ps ps-am ps-recursive tags \
+	tags-recursive uninstall uninstall-am uninstall-info-am \
+	uninstall-info-recursive uninstall-libcppunitincludeHEADERS \
+	uninstall-recursive
+
+
+dist-hook:
+	rm -f $(distdir)/config-auto.h
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,42 @@
+SUBDIRS = extensions ui plugin config tools portability
+
+DISTCLEANFILES = config-auto.h
+
+libcppunitincludedir = $(includedir)/cppunit
+libcppunitinclude_HEADERS =  \
+	config-auto.h \
+  AdditionalMessage.h \
+	Asserter.h \
+	BriefTestProgressListener.h \
+	CompilerOutputter.h \
+	Exception.h \
+	Message.h \
+	Outputter.h \
+	Portability.h \
+	Protector.h \
+	SourceLine.h \
+	SynchronizedObject.h \
+	Test.h \
+	TestAssert.h \
+	TestCase.h \
+	TestCaller.h \
+	TestComposite.h \
+	TestFailure.h \
+	TestFixture.h \
+	TestLeaf.h \
+	TestPath.h \
+	TestResult.h \
+	TestResultCollector.h \
+	TestRunner.h \
+	TestSuccessListener.h \
+	TestSuite.h \
+	TextOutputter.h \
+	TextTestProgressListener.h \
+	TextTestResult.h \
+	TextTestRunner.h \
+	TestListener.h \
+	XmlOutputter.h \
+	XmlOutputterHook.h
+
+dist-hook:
+	rm -f $(distdir)/config-auto.h

Added: trunk/mingw-libs/include/cppunit/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,516 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+SUBDIRS = extensions ui plugin config tools portability
+
+DISTCLEANFILES = config-auto.h
+
+libcppunitincludedir = $(includedir)/cppunit
+libcppunitinclude_HEADERS = \
+	config-auto.h \
+  AdditionalMessage.h \
+	Asserter.h \
+	BriefTestProgressListener.h \
+	CompilerOutputter.h \
+	Exception.h \
+	Message.h \
+	Outputter.h \
+	Portability.h \
+	Protector.h \
+	SourceLine.h \
+	SynchronizedObject.h \
+	Test.h \
+	TestAssert.h \
+	TestCase.h \
+	TestCaller.h \
+	TestComposite.h \
+	TestFailure.h \
+	TestFixture.h \
+	TestLeaf.h \
+	TestPath.h \
+	TestResult.h \
+	TestResultCollector.h \
+	TestRunner.h \
+	TestSuccessListener.h \
+	TestSuite.h \
+	TextOutputter.h \
+	TextTestProgressListener.h \
+	TextTestResult.h \
+	TextTestRunner.h \
+	TestListener.h \
+	XmlOutputter.h \
+	XmlOutputterHook.h
+
+subdir = include/cppunit
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+
+RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
+	ps-recursive install-info-recursive uninstall-info-recursive \
+	all-recursive install-data-recursive install-exec-recursive \
+	installdirs-recursive install-recursive uninstall-recursive \
+	check-recursive installcheck-recursive
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+DIST_SUBDIRS = $(SUBDIRS)
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if (etags --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	else \
+	  include_option=--include; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$(top_distdir)" \
+	        distdir=../$(distdir)/$$subdir \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	$(MAKE) $(AM_MAKEFLAGS) \
+	  top_distdir="$(top_distdir)" distdir="$(distdir)" \
+	  dist-hook
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(HEADERS)
+installdirs: installdirs-recursive
+installdirs-am:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
+	clean-generic clean-libtool clean-recursive ctags \
+	ctags-recursive distclean distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-data install-data-am install-data-recursive \
+	install-exec install-exec-am install-exec-recursive \
+	install-info install-info-am install-info-recursive \
+	install-libcppunitincludeHEADERS install-man install-recursive \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am installdirs-recursive maintainer-clean \
+	maintainer-clean-generic maintainer-clean-recursive mostlyclean \
+	mostlyclean-generic mostlyclean-libtool mostlyclean-recursive \
+	pdf pdf-am pdf-recursive ps ps-am ps-recursive tags \
+	tags-recursive uninstall uninstall-am uninstall-info-am \
+	uninstall-info-recursive uninstall-libcppunitincludeHEADERS \
+	uninstall-recursive
+
+
+dist-hook:
+	rm -f $(distdir)/config-auto.h
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/Message.h
===================================================================
--- trunk/mingw-libs/include/cppunit/Message.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Message.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,152 @@
+#ifndef CPPUNIT_MESSAGE_H
+#define CPPUNIT_MESSAGE_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<std::string>;
+#endif
+
+/*! \brief Message associated to an Exception.
+ * \ingroup CreatingNewAssertions
+ *  A message is composed of two items:
+ *  - a short description (~20/30 characters)
+ *  - a list of detail strings
+ *
+ *  The short description is used to indicate how the detail strings should be
+ *  interpreted. It usually indicates the failure types, such as
+ *  "assertion failed", "forced failure", "unexpected exception caught",
+ *  "equality assertion failed"... It should not contains new line character (\n).
+ *
+ *  Detail strings are used to provide more information about the failure. It
+ *  can contains the asserted expression, the expected and actual values in an
+ *  equality assertion, some addional messages... Detail strings can contains
+ *  new line characters (\n).
+ */
+class CPPUNIT_API Message
+{
+public:
+  Message();
+
+  explicit Message( const std::string &shortDescription );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1 );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1,
+           const std::string &detail2 );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1,
+           const std::string &detail2,
+           const std::string &detail3 );
+
+  /*! \brief Returns the short description.
+   * \return Short description.
+   */
+  const std::string &shortDescription() const;
+
+  /*! \brief Returns the number of detail string.
+   * \return Number of detail string.
+   */
+  int detailCount() const;
+
+  /*! \brief Returns the detail at the specified index.
+   * \param index Zero based index of the detail string to return.
+   * \returns Detail string at the specified index.
+   * \exception std::invalid_argument if \a index < 0 or index >= detailCount().
+   */
+  std::string detailAt( int index ) const;
+
+  /*! \brief Returns a string that represents a list of the detail strings.
+   *
+   * Example:
+   * \code
+   * Message message( "not equal", "Expected: 3", "Actual: 7" );
+   * std::string details = message.details();
+   * // details contains:
+   * // "- Expected: 3\n- Actual: 7\n"  \endcode
+   *
+   * \return A string that is a concatenation of all the detail strings. Each detail
+   *         string is prefixed with '- ' and suffixed with '\n' before being
+   *         concatenated to the other.
+   */
+  std::string details() const;
+
+  /*! \brief Removes all detail strings.
+   */
+  void clearDetails();
+
+  /*! \brief Adds a single detail string.
+   * \param detail Detail string to add.
+   */
+  void addDetail( const std::string &detail );
+
+  /*! \brief Adds two detail strings.
+   * \param detail1 Detail string to add.
+   * \param detail2 Detail string to add.
+   */
+  void addDetail( const std::string &detail1,
+                  const std::string &detail2 );
+
+  /*! \brief Adds three detail strings.
+   * \param detail1 Detail string to add.
+   * \param detail2 Detail string to add.
+   * \param detail3 Detail string to add.
+   */
+  void addDetail( const std::string &detail1,
+                  const std::string &detail2,
+                  const std::string &detail3 );
+
+  /*! \brief Adds the detail strings of the specified message.
+   * \param message All the detail strings of this message are added to this one.
+   */
+  void addDetail( const Message &message );
+
+  /*! \brief Sets the short description.
+   * \param shortDescription New short description.
+   */
+  void setShortDescription( const std::string &shortDescription );
+
+  /*! \brief Tests if a message is identical to another one.
+   * \param other Message this message is compared to.
+   * \return \c true if the two message are identical, \c false otherwise.
+   */
+  bool operator ==( const Message &other ) const;
+
+
+  /*! \brief Tests if a message is different from another one.
+   * \param other Message this message is compared to.
+   * \return \c true if the two message are not identical, \c false otherwise.
+   */
+  bool operator !=( const Message &other ) const;
+
+private:
+  std::string m_shortDescription;
+
+  typedef CppUnitDeque<std::string> Details;
+  Details m_details;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_MESSAGE_H

Added: trunk/mingw-libs/include/cppunit/Outputter.h
===================================================================
--- trunk/mingw-libs/include/cppunit/Outputter.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Outputter.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,26 @@
+#ifndef CPPUNIT_OUTPUTTER_H
+#define CPPUNIT_OUTPUTTER_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Abstract outputter to print test result summary.
+ * \ingroup WritingTestResult
+ */
+class CPPUNIT_API Outputter
+{
+public:
+  /// Destructor.
+  virtual ~Outputter() {}
+
+  virtual void write() =0;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_OUTPUTTER_H

Added: trunk/mingw-libs/include/cppunit/Portability.h
===================================================================
--- trunk/mingw-libs/include/cppunit/Portability.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Portability.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,213 @@
+#ifndef CPPUNIT_PORTABILITY_H
+#define CPPUNIT_PORTABILITY_H
+
+#if defined(_WIN32) && !defined(WIN32)
+# define WIN32 1
+#endif
+
+/* include platform specific config */
+#if defined(__BORLANDC__)
+#    include <cppunit/config/config-bcb5.h>
+#elif defined (_MSC_VER)
+#    include <cppunit/config/config-msvc6.h>
+#else
+#    include <cppunit/config-auto.h>
+#endif
+
+// Version number of package
+#ifndef CPPUNIT_VERSION 
+#define CPPUNIT_VERSION  "1.10.2"
+#endif
+ 
+#include <cppunit/config/CppUnitApi.h>    // define CPPUNIT_API & CPPUNIT_NEED_DLL_DECL
+#include <cppunit/config/SelectDllLoader.h>
+
+
+/* Options that the library user may switch on or off.
+ * If the user has not done so, we chose default values.
+ */
+
+
+/* Define to 1 if you wish to have the old-style macros
+   assert(), assertEqual(), assertDoublesEqual(), and assertLongsEqual() */
+#if !defined(CPPUNIT_ENABLE_NAKED_ASSERT)
+# define CPPUNIT_ENABLE_NAKED_ASSERT          0
+#endif
+
+/* Define to 1 if you wish to have the old-style CU_TEST family
+   of macros. */
+#if !defined(CPPUNIT_ENABLE_CU_TEST_MACROS)
+# define CPPUNIT_ENABLE_CU_TEST_MACROS        0
+#endif
+
+/* Define to 1 if the preprocessor expands (#foo) to "foo" (quotes incl.) 
+   I don't think there is any C preprocess that does NOT support this! */
+#if !defined(CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION)
+# define CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION   1
+#endif
+
+/* Assumes that STL and CppUnit are in global space if the compiler does not
+   support namespace. */
+#if !defined(CPPUNIT_HAVE_NAMESPACES)
+# if !defined(CPPUNIT_NO_NAMESPACE)
+#  define CPPUNIT_NO_NAMESPACE 1
+# endif // !defined(CPPUNIT_NO_NAMESPACE)
+# if !defined(CPPUNIT_NO_STD_NAMESPACE)
+#  define CPPUNIT_NO_STD_NAMESPACE 1
+# endif // !defined(CPPUNIT_NO_STD_NAMESPACE)
+#endif // !defined(CPPUNIT_HAVE_NAMESPACES)
+
+/* Define CPPUNIT_STD_NEED_ALLOCATOR to 1 if you need to specify
+ * the allocator you used when instantiating STL container. Typically
+ * used for compilers that do not support template default parameter.
+ * CPPUNIT_STD_ALLOCATOR will be used as the allocator. Default is
+ * std::allocator. On some compilers, you may need to change this to
+ * std::allocator<T>.
+ */
+#if CPPUNIT_STD_NEED_ALLOCATOR
+# if !defined(CPPUNIT_STD_ALLOCATOR)
+#  define CPPUNIT_STD_ALLOCATOR std::allocator
+# endif // !defined(CPPUNIT_STD_ALLOCATOR)
+#endif // defined(CPPUNIT_STD_NEED_ALLOCATOR)
+
+
+// Compiler error location format for CompilerOutputter
+// If not define, assumes that it's gcc
+// See class CompilerOutputter for format.
+#if !defined(CPPUNIT_COMPILER_LOCATION_FORMAT)
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%f:%l:"
+#endif
+
+// If CPPUNIT_HAVE_CPP_CAST is defined, then c++ style cast will be used,
+// otherwise, C style cast are used.
+#if defined( CPPUNIT_HAVE_CPP_CAST )
+# define CPPUNIT_CONST_CAST( TargetType, pointer ) \
+    const_cast<TargetType>( pointer )
+
+# define CPPUNIT_STATIC_CAST( TargetType, pointer ) \
+    static_cast<TargetType>( pointer )
+#else // defined( CPPUNIT_HAVE_CPP_CAST )
+# define CPPUNIT_CONST_CAST( TargetType, pointer ) \
+    ((TargetType)( pointer ))
+# define CPPUNIT_STATIC_CAST( TargetType, pointer ) \
+    ((TargetType)( pointer ))
+#endif // defined( CPPUNIT_HAVE_CPP_CAST )
+
+// If CPPUNIT_NO_STD_NAMESPACE is defined then STL are in the global space.
+// => Define macro 'std' to nothing
+#if defined(CPPUNIT_NO_STD_NAMESPACE)
+# undef std
+# define std
+#endif  // defined(CPPUNIT_NO_STD_NAMESPACE)
+
+// If CPPUNIT_NO_NAMESPACE is defined, then put CppUnit classes in the
+// global namespace: the compiler does not support namespace.
+#if defined(CPPUNIT_NO_NAMESPACE)
+# define CPPUNIT_NS_BEGIN
+# define CPPUNIT_NS_END
+# define CPPUNIT_NS
+#else   // defined(CPPUNIT_NO_NAMESPACE)
+# define CPPUNIT_NS_BEGIN namespace CppUnit {
+# define CPPUNIT_NS_END }
+# define CPPUNIT_NS CppUnit
+#endif  // defined(CPPUNIT_NO_NAMESPACE)
+
+/*! Stringize a symbol.
+ * 
+ * Use this macro to convert a preprocessor symbol to a string.
+ *
+ * Example of usage:
+ * \code
+ * #define CPPUNIT_PLUGIN_EXPORTED_NAME cppunitTestPlugIn
+ * const char *name = CPPUNIT_STRINGIZE( CPPUNIT_PLUGIN_EXPORTED_NAME );
+ * \endcode
+ */
+#define CPPUNIT_STRINGIZE( symbol ) _CPPUNIT_DO_STRINGIZE( symbol )
+
+/// \internal
+#define _CPPUNIT_DO_STRINGIZE( symbol ) #symbol
+
+/*! Joins to symbol after expanding them into string.
+ *
+ * Use this macro to join two symbols. Example of usage:
+ *
+ * \code
+ * #define MAKE_UNIQUE_NAME(prefix) CPPUNIT_JOIN( prefix, __LINE__ )
+ * \endcode
+ *
+ * The macro defined in the example concatenate a given prefix with the line number
+ * to obtain a 'unique' identifier.
+ *
+ * \internal From boost documentation:
+ * The following piece of macro magic joins the two 
+ * arguments together, even when one of the arguments is
+ * itself a macro (see 16.3.1 in C++ standard).  The key
+ * is that macro expansion of macro arguments does not
+ * occur in CPPUNIT_JOIN2 but does in CPPUNIT_JOIN.
+ */
+#define CPPUNIT_JOIN( symbol1, symbol2 ) _CPPUNIT_DO_JOIN( symbol1, symbol2 )
+
+/// \internal
+#define _CPPUNIT_DO_JOIN( symbol1, symbol2 ) _CPPUNIT_DO_JOIN2( symbol1, symbol2 )
+
+/// \internal
+#define _CPPUNIT_DO_JOIN2( symbol1, symbol2 ) symbol1##symbol2
+
+/*! Adds the line number to the specified string to create a unique identifier.
+ * \param prefix Prefix added to the line number to create a unique identifier.
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION for an example of usage.
+ */
+#define CPPUNIT_MAKE_UNIQUE_NAME( prefix ) CPPUNIT_JOIN( prefix, __LINE__ )
+
+/*! Defines wrap colunm for %CppUnit. Used by CompilerOuputter.
+ */
+#if !defined(CPPUNIT_WRAP_COLUMN)
+# define CPPUNIT_WRAP_COLUMN 79
+#endif
+
+
+/* perform portability hacks */
+
+
+/* Define CPPUNIT_SSTREAM as a stream with a "std::string str()"
+ * method.
+ */
+#if CPPUNIT_HAVE_SSTREAM
+# include <sstream>
+    CPPUNIT_NS_BEGIN
+
+    typedef std::ostringstream OStringStream;
+
+    CPPUNIT_NS_END
+#elif CPPUNIT_HAVE_CLASS_STRSTREAM
+# include <string>
+# if CPPUNIT_HAVE_STRSTREAM
+#   include <strstream>
+# else // CPPUNIT_HAVE_STRSTREAM
+#  include <strstream.h>
+# endif // CPPUNIT_HAVE_CLASS_STRSTREAM
+
+    CPPUNIT_NS_BEGIN
+
+      class OStringStream : public std::ostrstream 
+      {
+      public:
+          std::string str()
+          {
+//            (*this) << '\0';
+//            std::string msg(std::ostrstream::str());
+//            std::ostrstream::freeze(false);
+//            return msg;
+// Alternative implementation that don't rely on freeze which is not
+// available on some platforms:
+            return std::string( std::ostrstream::str(), pcount() );
+          }
+      };
+
+    CPPUNIT_NS_END
+#else // CPPUNIT_HAVE_CLASS_STRSTREAM
+#   error Cannot define CppUnit::OStringStream.
+#endif // CPPUNIT_HAVE_SSTREAM
+
+
+#endif // CPPUNIT_PORTABILITY_H

Added: trunk/mingw-libs/include/cppunit/Protector.h
===================================================================
--- trunk/mingw-libs/include/cppunit/Protector.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Protector.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,94 @@
+#ifndef CPPUNIT_PROTECTOR_H
+#define CPPUNIT_PROTECTOR_H
+
+#include <cppunit/SourceLine.h>
+
+CPPUNIT_NS_BEGIN
+
+class Exception;
+class Message;
+class ProtectorContext;
+class TestResult;
+
+
+class CPPUNIT_API Functor
+{
+public:
+  virtual ~Functor();
+
+  virtual bool operator()() const =0;
+};
+
+
+/*! \brief Protects one or more test case run.
+ *
+ * Protector are used to globably 'decorate' a test case. The most common
+ * usage of Protector is to catch exception that do not subclass std::exception,
+ * such as MFC CException class or Rogue Wave RWXMsg class, and capture the
+ * message associated to the exception. In fact, CppUnit capture message from
+ * Exception and std::exception using a Protector.
+ *
+ * Protector are chained. When you add a Protector using 
+ * TestResult::pushProtector(), your protector is in fact passed as a Functor
+ * to the first protector of the chain.
+ *
+ * TestCase protects call to setUp(), runTest() and tearDown() by calling
+ * TestResult::protect().
+ *
+ * Because the protector chain is handled by TestResult, a protector can be
+ * active for a single test, or a complete test run.
+ *
+ * Here are some possible usages:
+ * - run all test case in a separate thread and assumes the test failed if it
+ *   did not finish in a given time (infinite loop work around)
+ * - performance tracing : time only the runTest() time.
+ * \sa TestResult, TestCase, TestListener.
+ */
+class CPPUNIT_API Protector
+{
+public:
+  virtual ~Protector();
+  
+  virtual bool protect( const Functor &functor,
+                        const ProtectorContext &context ) =0;
+
+protected:
+  void reportError( const ProtectorContext &context,
+                    const Exception &error ) const;
+
+  void reportError( const ProtectorContext &context,
+                    const Message &message,
+                    const SourceLine &sourceLine = SourceLine() ) const;
+
+  void reportFailure( const ProtectorContext &context,
+                      const Exception &failure ) const;
+
+  Message actualMessage( const Message &message,
+                         const ProtectorContext &context ) const;
+};
+
+
+/*! \brief Scoped protector push to TestResult.
+ *
+ * Adds the specified Protector to the specified TestResult for the object
+ * life-time.
+ */
+class CPPUNIT_API ProtectorGuard
+{
+public:
+  /// Pushes the specified protector.
+  ProtectorGuard( TestResult *result,
+                  Protector *protector );
+
+  /// Pops the protector.
+  ~ProtectorGuard();
+
+private:
+  TestResult *m_result;
+};
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_PROTECTOR_H
+

Added: trunk/mingw-libs/include/cppunit/SourceLine.h
===================================================================
--- trunk/mingw-libs/include/cppunit/SourceLine.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/SourceLine.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,58 @@
+#ifndef CPPUNIT_SOURCELINE_H
+#define CPPUNIT_SOURCELINE_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+/*! \brief Constructs a SourceLine object initialized with the location where the macro is expanded.
+ * \ingroup CreatingNewAssertions
+ * \relates CppUnit::SourceLine
+ * Used to write your own assertion macros.
+ * \see Asserter for example of usage.
+ */
+#define CPPUNIT_SOURCELINE() CPPUNIT_NS::SourceLine( __FILE__, __LINE__ )
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Represents a source line location.
+ * \ingroup CreatingNewAssertions
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * Used to capture the failure location in assertion.
+ * 
+ * Use the CPPUNIT_SOURCELINE() macro to construct that object. Typically used when
+ * writing an assertion macro in association with Asserter.
+ *
+ * \see Asserter.
+ */
+class CPPUNIT_API SourceLine
+{
+public:
+  SourceLine();
+
+  SourceLine( const std::string &fileName,
+              int lineNumber );
+
+  /// Destructor.
+  virtual ~SourceLine();
+
+  bool isValid() const;
+
+  int lineNumber() const;
+
+  std::string fileName() const;
+
+  bool operator ==( const SourceLine &other ) const;
+  bool operator !=( const SourceLine &other ) const;
+
+private:
+  std::string m_fileName;
+  int m_lineNumber;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_SOURCELINE_H

Added: trunk/mingw-libs/include/cppunit/SynchronizedObject.h
===================================================================
--- trunk/mingw-libs/include/cppunit/SynchronizedObject.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/SynchronizedObject.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,80 @@
+#ifndef CPPUNIT_SYNCHRONIZEDOBJECT_H
+#define CPPUNIT_SYNCHRONIZEDOBJECT_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Base class for synchronized object.
+ *
+ * Synchronized object are object which members are used concurrently by mutiple
+ * threads.
+ *
+ * This class define the class SynchronizationObject which must be subclassed
+ * to implement an actual lock.
+ *
+ * Each instance of this class holds a pointer on a lock object.
+ *
+ * See src/msvc6/MfcSynchronizedObject.h for an example.
+ */
+class CPPUNIT_API SynchronizedObject
+{
+public:
+  /*! \brief Abstract synchronization object (mutex)
+   */
+  class SynchronizationObject
+  {
+    public:
+      SynchronizationObject() {}
+      virtual ~SynchronizationObject() {}
+
+      virtual void lock() {}
+      virtual void unlock() {}
+  };
+
+  /*! Constructs a SynchronizedObject object.
+   */
+  SynchronizedObject( SynchronizationObject *syncObject =0 );
+
+  /// Destructor.
+  virtual ~SynchronizedObject();
+
+protected:
+  /*! \brief Locks a synchronization object in the current scope.
+   */
+  class ExclusiveZone
+  {
+    SynchronizationObject *m_syncObject;
+
+  public:
+    ExclusiveZone( SynchronizationObject *syncObject ) 
+        : m_syncObject( syncObject ) 
+    { 
+      m_syncObject->lock(); 
+    }
+
+    ~ExclusiveZone() 
+    { 
+      m_syncObject->unlock (); 
+    }
+  };
+
+  virtual void setSynchronizationObject( SynchronizationObject *syncObject );
+
+protected:
+  SynchronizationObject *m_syncObject;
+
+private:
+  /// Prevents the use of the copy constructor.
+  SynchronizedObject( const SynchronizedObject &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const SynchronizedObject &copy );
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_SYNCHRONIZEDOBJECT_H

Added: trunk/mingw-libs/include/cppunit/Test.h
===================================================================
--- trunk/mingw-libs/include/cppunit/Test.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/Test.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,117 @@
+#ifndef CPPUNIT_TEST_H
+#define CPPUNIT_TEST_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+class TestPath;
+
+/*! \brief Base class for all test objects.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * All test objects should be a subclass of Test.  Some test objects,
+ * TestCase for example, represent one individual test.  Other test
+ * objects, such as TestSuite, are comprised of several tests.  
+ *
+ * When a Test is run, the result is collected by a TestResult object.
+ *
+ * \see TestCase
+ * \see TestSuite
+ */
+class CPPUNIT_API Test
+{
+public:
+  virtual ~Test() {};
+
+  /*! \brief Run the test, collecting results.
+   */
+  virtual void run( TestResult *result ) =0;
+
+  /*! \brief Return the number of test cases invoked by run().
+   *
+   * The base unit of testing is the class TestCase.  This
+   * method returns the number of TestCase objects invoked by
+   * the run() method.
+   */
+  virtual int countTestCases () const =0;
+
+  /*! \brief Returns the number of direct child of the test.
+   */
+  virtual int getChildTestCount() const =0;
+
+  /*! \brief Returns the child test of the specified index.
+   *
+   * This method test if the index is valid, then call doGetChildTestAt() if 
+   * the index is valid. Otherwise std::out_of_range exception is thrown.
+   *
+   * You should override doGetChildTestAt() method.
+   * 
+   * \param index Zero based index of the child test to return.
+   * \return Pointer on the test. Never \c NULL.
+   * \exception std::out_of_range is \a index is < 0 or >= getChildTestCount().
+   */
+  virtual Test *getChildTestAt( int index ) const;
+
+  /*! \brief Returns the test name.
+   * 
+   * Each test has a name.  This name may be used to find the
+   * test in a suite or registry of tests.
+   */
+  virtual std::string getName () const =0;
+
+  /*! \brief Finds the test with the specified name and its parents test.
+   * \param testName Name of the test to find.
+   * \param testPath If the test is found, then all the tests traversed to access
+   *                 \a test are added to \a testPath, including \c this and \a test.
+   * \return \c true if a test with the specified name is found, \c false otherwise.
+   */
+  virtual bool findTestPath( const std::string &testName,
+                             TestPath &testPath ) const;
+
+  /*! \brief Finds the specified test and its parents test.
+   * \param test Test to find.
+   * \param testPath If the test is found, then all the tests traversed to access
+   *                 \a test are added to \a testPath, including \c this and \a test.
+   * \return \c true if the specified test is found, \c false otherwise.
+   */
+  virtual bool findTestPath( const Test *test,
+                             TestPath &testPath ) const;
+
+  /*! \brief Finds the test with the specified name in the hierarchy.
+   * \param testName Name of the test to find.
+   * \return Pointer on the first test found that is named \a testName. Never \c NULL.
+   * \exception std::invalid_argument if no test named \a testName is found.
+   */
+  virtual Test *findTest( const std::string &testName ) const;
+
+  /*! \brief Resolved the specified test path with this test acting as 'root'.
+   * \param testPath Test path string to resolve.
+   * \return Resolved TestPath. 
+   * \exception std::invalid_argument if \a testPath could not be resolved.
+   * \see TestPath.
+   */
+  virtual TestPath resolveTestPath( const std::string &testPath ) const;
+
+protected:
+  /*! Throws an exception if the specified index is invalid.
+   * \param index Zero base index of a child test.
+   * \exception std::out_of_range is \a index is < 0 or >= getChildTestCount().
+   */
+  virtual void checkIsValidIndex( int index ) const;
+
+  /*! \brief Returns the child test of the specified valid index.
+   * \param index Zero based valid index of the child test to return.
+   * \return Pointer on the test. Never \c NULL.
+   */
+  virtual Test *doGetChildTestAt( int index ) const =0;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TEST_H
+

Added: trunk/mingw-libs/include/cppunit/TestAssert.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestAssert.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestAssert.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,289 @@
+#ifndef CPPUNIT_TESTASSERT_H
+#define CPPUNIT_TESTASSERT_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/Asserter.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Traits used by CPPUNIT_ASSERT_EQUAL().
+ *
+ * Here is an example of specialization of that traits:
+ *
+ * \code
+ * template<>
+ * struct assertion_traits<std::string>   // specialization for the std::string type
+ * {
+ *   static bool equal( const std::string& x, const std::string& y )
+ *   {
+ *     return x == y;
+ *   }
+ * 
+ *   static std::string toString( const std::string& x )
+ *   {
+ *     std::string text = '"' + x + '"';    // adds quote around the string to see whitespace
+ *     OStringStream ost;
+ *     ost << text;
+ *     return ost.str();
+ *   }
+ * };
+ * \endcode
+ */
+template <class T>
+struct assertion_traits 
+{  
+    static bool equal( const T& x, const T& y )
+    {
+        return x == y;
+    }
+
+    static std::string toString( const T& x )
+    {
+        OStringStream ost;
+        ost << x;
+        return ost.str();
+    }
+};
+
+
+/*! \brief (Implementation) Asserts that two objects of the same type are equals.
+ * Use CPPUNIT_ASSERT_EQUAL instead of this function.
+ * \sa assertion_traits, Asserter::failNotEqual().
+ */
+template <class T>
+void assertEquals( const T& expected,
+                   const T& actual,
+                   SourceLine sourceLine,
+                   const std::string &message )
+{
+  if ( !assertion_traits<T>::equal(expected,actual) ) // lazy toString conversion...
+  {
+    Asserter::failNotEqual( assertion_traits<T>::toString(expected),
+                            assertion_traits<T>::toString(actual),
+                            sourceLine,
+                            message );
+  }
+}
+
+/*! \brief (Implementation) Asserts that two double are equals given a tolerance.
+ * Use CPPUNIT_ASSERT_DOUBLES_EQUAL instead of this function.
+ * \sa Asserter::failNotEqual().
+ */
+void CPPUNIT_API assertDoubleEquals( double expected,
+                                     double actual,
+                                     double delta,
+                                     SourceLine sourceLine );
+
+
+/* A set of macros which allow us to get the line number
+ * and file name at the point of an error.
+ * Just goes to show that preprocessors do have some
+ * redeeming qualities.
+ */
+#if CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION
+/** Assertions that a condition is \c true.
+ * \ingroup Assertions
+ */
+#define CPPUNIT_ASSERT(condition)                                                 \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \
+                                 CPPUNIT_NS::Message( "assertion failed",         \
+                                                      "Expression: " #condition), \
+                                 CPPUNIT_SOURCELINE() ) )
+#else
+#define CPPUNIT_ASSERT(condition)                                            \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                              \
+                                  CPPUNIT_NS::Message( "assertion failed" ), \
+                                  CPPUNIT_SOURCELINE() ) )
+#endif
+
+/** Assertion with a user specified message.
+ * \ingroup Assertions
+ * \param message Message reported in diagnostic if \a condition evaluates
+ *                to \c false.
+ * \param condition If this condition evaluates to \c false then the
+ *                  test failed.
+ */
+#define CPPUNIT_ASSERT_MESSAGE(message,condition)          \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),            \
+                                  (message),               \
+                                  CPPUNIT_SOURCELINE() ) )
+
+/** Fails with the specified message.
+ * \ingroup Assertions
+ * \param message Message reported in diagnostic.
+ */
+#define CPPUNIT_FAIL( message )                                         \
+  ( CPPUNIT_NS::Asserter::fail( CPPUNIT_NS::Message( "forced failure",  \
+                                                     message ),         \
+                                CPPUNIT_SOURCELINE() ) )
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+/// Generalized macro for primitive value comparisons
+#define CPPUNIT_ASSERT_EQUAL(expected,actual)                     \
+  ( CPPUNIT_NS::assertEquals( (expected),             \
+                              (actual),               \
+                              __LINE__, __FILE__ ) )
+#else
+/** Asserts that two values are equals.
+ * \ingroup Assertions
+ *
+ * Equality and string representation can be defined with
+ * an appropriate CppUnit::assertion_traits class.
+ *
+ * A diagnostic is printed if actual and expected values disagree.
+ *
+ * Requirement for \a expected and \a actual parameters:
+ * - They are exactly of the same type
+ * - They are serializable into a std::strstream using operator <<.
+ * - They can be compared using operator ==. 
+ *
+ * The last two requirements (serialization and comparison) can be
+ * removed by specializing the CppUnit::assertion_traits.
+ */
+#define CPPUNIT_ASSERT_EQUAL(expected,actual)          \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_SOURCELINE(),    \
+                              "" ) )
+
+/** Asserts that two values are equals, provides additional messafe on failure.
+ * \ingroup Assertions
+ *
+ * Equality and string representation can be defined with
+ * an appropriate assertion_traits class.
+ *
+ * A diagnostic is printed if actual and expected values disagree.
+ * The message is printed in addition to the expected and actual value
+ * to provide additional information.
+ *
+ * Requirement for \a expected and \a actual parameters:
+ * - They are exactly of the same type
+ * - They are serializable into a std::strstream using operator <<.
+ * - They can be compared using operator ==. 
+ *
+ * The last two requirements (serialization and comparison) can be
+ * removed by specializing the CppUnit::assertion_traits.
+ */
+#define CPPUNIT_ASSERT_EQUAL_MESSAGE(message,expected,actual)      \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_SOURCELINE(),    \
+                              (message) ) )
+#endif
+
+/*! \brief Macro for primitive value comparisons
+ * \ingroup Assertions
+ */
+#define CPPUNIT_ASSERT_DOUBLES_EQUAL(expected,actual,delta)        \
+  ( CPPUNIT_NS::assertDoubleEquals( (expected),        \
+                                    (actual),          \
+                                    (delta),           \
+                                    CPPUNIT_SOURCELINE() ) )
+
+
+/** Asserts that the given expression throws an exception of the specified type.
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *  CPPUNIT_ASSERT_THROW( v.at( 50 ), std::out_of_range );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_THROW( expression, ExceptionType )          \
+   do {                                                             \
+      bool cpputExceptionThrown_ = false;                           \
+      try {                                                         \
+         expression;                                                \
+      } catch ( const ExceptionType & ) {                           \
+         cpputExceptionThrown_ = true;                              \
+      }                                                             \
+                                                                    \
+      if ( cpputExceptionThrown_ )                                  \
+         break;                                                     \
+                                                                    \
+      CPPUNIT_NS::Asserter::fail(                                   \
+                     "Expected exception: " #ExceptionType          \
+                     " not thrown.",                                \
+                     CPPUNIT_SOURCELINE() );                        \
+   } while ( false )
+
+
+// implementation detail
+#if CPPUNIT_USE_TYPEINFO_NAME
+#define CPPUNIT_EXTRACT_EXCEPTION_TYPE_( exception, no_rtti_message ) \
+   CPPUNIT_NS::TypeInfoHelper::getClassName( typeid(exception) )
+#else
+#define CPPUNIT_EXTRACT_EXCEPTION_TYPE_( exception, no_rtti_message ) \
+   std::string( no_rtti_message )
+#endif // CPPUNIT_USE_TYPEINFO_NAME
+
+/** Asserts that the given expression does not throw any exceptions.
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *   v.push_back( 10 );
+ *  CPPUNIT_ASSERT_NO_THROW( v.at( 0 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_NO_THROW( expression )                             \
+   try {                                                                   \
+      expression;                                                          \
+   } catch ( const std::exception &e ) {                                   \
+      CPPUNIT_NS::Message message( "Unexpected exception caught" );        \
+      message.addDetail( "Type: " +                                        \
+                   CPPUNIT_EXTRACT_EXCEPTION_TYPE_( e,                     \
+                                       "std::exception or derived" ) );    \
+      message.addDetail( std::string("What: ") + e.what() );               \
+      CPPUNIT_NS::Asserter::fail( message,                                 \
+                                  CPPUNIT_SOURCELINE() );                  \
+   } catch ( ... ) {                                                       \
+      CPPUNIT_NS::Asserter::fail( "Unexpected exception caught",           \
+                                  CPPUNIT_SOURCELINE() );                  \
+   }
+
+/** Asserts that an assertion fail.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_FAIL( CPPUNIT_ASSERT( 1 == 2 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_FAIL( assertion )                 \
+   CPPUNIT_ASSERT_THROW( assertion, CPPUNIT_NS::Exception )
+
+
+/** Asserts that an assertion pass.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_PASS( CPPUNIT_ASSERT( 1 == 1 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_PASS( assertion )                 \
+   CPPUNIT_ASSERT_NO_THROW( assertion )
+
+
+
+
+// Backwards compatibility
+
+#if CPPUNIT_ENABLE_NAKED_ASSERT
+
+#undef assert
+#define assert(c)                 CPPUNIT_ASSERT(c)
+#define assertEqual(e,a)          CPPUNIT_ASSERT_EQUAL(e,a)
+#define assertDoublesEqual(e,a,d) CPPUNIT_ASSERT_DOUBLES_EQUAL(e,a,d)
+#define assertLongsEqual(e,a)     CPPUNIT_ASSERT_EQUAL(e,a)
+
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTASSERT_H

Added: trunk/mingw-libs/include/cppunit/TestCaller.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestCaller.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestCaller.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,204 @@
+#ifndef CPPUNIT_TESTCALLER_H    // -*- C++ -*-
+#define CPPUNIT_TESTCALLER_H
+
+#include <cppunit/Exception.h>
+#include <cppunit/TestCase.h>
+
+
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  include <cppunit/extensions/TypeInfoHelper.h>
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+#if 0
+/*! \brief Marker class indicating that no exception is expected by TestCaller.
+ * This class is an implementation detail. You should never use this class directly.
+ */
+class CPPUNIT_API NoExceptionExpected
+{
+private:
+  //! Prevent class instantiation.
+  NoExceptionExpected();
+};
+
+
+/*! \brief (Implementation) Traits used by TestCaller to expect an exception.
+ *
+ * This class is an implementation detail. You should never use this class directly.
+ */
+template<class ExceptionType>
+struct ExpectedExceptionTraits
+{
+  static void expectedException()
+  {
+#if CPPUNIT_USE_TYPEINFO_NAME
+    throw Exception( Message(
+                         "expected exception not thrown",
+                         "Expected exception type: " + 
+                           TypeInfoHelper::getClassName( typeid( ExceptionType ) ) ) );
+#else
+    throw Exception( "expected exception not thrown" );
+#endif
+  }
+};
+
+
+/*! \brief (Implementation) Traits specialization used by TestCaller to 
+ * expect no exception.
+ *
+ * This class is an implementation detail. You should never use this class directly.
+ */
+template<>
+struct ExpectedExceptionTraits<NoExceptionExpected>
+{
+  static void expectedException()
+  {
+  }
+};
+
+
+#endif
+
+//*** FIXME: rework this when class Fixture is implemented. ***//
+
+
+/*! \brief Generate a test case from a fixture method.
+ * \ingroup WritingTestFixture
+ *
+ * A test caller provides access to a test case method 
+ * on a test fixture class.  Test callers are useful when 
+ * you want to run an individual test or add it to a 
+ * suite.
+ * Test Callers invoke only one Test (i.e. test method) on one 
+ * Fixture of a TestFixture.
+ * 
+ * Here is an example:
+ * \code
+ * class MathTest : public CppUnit::TestFixture {
+ *         ...
+ *     public:
+ *         void         setUp();
+ *         void         tearDown();
+ *
+ *         void         testAdd();
+ *         void         testSubtract();
+ * };
+ *
+ * CppUnit::Test *MathTest::suite() {
+ *     CppUnit::TestSuite *suite = new CppUnit::TestSuite;
+ *
+ *     suite->addTest( new CppUnit::TestCaller<MathTest>( "testAdd", testAdd ) );
+ *     return suite;
+ * }
+ * \endcode
+ *
+ * You can use a TestCaller to bind any test method on a TestFixture
+ * class, as long as it accepts void and returns void.
+ * 
+ * \see TestCase
+ */
+
+template <class Fixture>
+class TestCaller : public TestCase
+{ 
+  typedef void (Fixture::*TestMethod)();
+    
+public:
+  /*!
+   * Constructor for TestCaller. This constructor builds a new Fixture
+   * instance owned by the TestCaller.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   */
+  TestCaller( std::string name, TestMethod test ) :
+	    TestCase( name ), 
+	    m_ownFixture( true ),
+	    m_fixture( new Fixture() ),
+	    m_test( test )
+  {
+  }
+
+  /*!
+   * Constructor for TestCaller. 
+   * This constructor does not create a new Fixture instance but accepts
+   * an existing one as parameter. The TestCaller will not own the
+   * Fixture object.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   * \param fixture the Fixture to invoke the test method on.
+   */
+  TestCaller(std::string name, TestMethod test, Fixture& fixture) :
+	    TestCase( name ), 
+	    m_ownFixture( false ),
+	    m_fixture( &fixture ),
+	    m_test( test )
+  {
+  }
+    
+  /*!
+   * Constructor for TestCaller. 
+   * This constructor does not create a new Fixture instance but accepts
+   * an existing one as parameter. The TestCaller will own the
+   * Fixture object and delete it in its destructor.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   * \param fixture the Fixture to invoke the test method on.
+   */
+  TestCaller(std::string name, TestMethod test, Fixture* fixture) :
+	    TestCase( name ), 
+	    m_ownFixture( true ),
+	    m_fixture( fixture ),
+	    m_test( test )
+  {
+  }
+    
+  ~TestCaller() 
+  {
+    if (m_ownFixture)
+      delete m_fixture;
+  }
+
+  void runTest()
+  { 
+//	  try {
+	    (m_fixture->*m_test)();
+//	  }
+//	  catch ( ExpectedException & ) {
+//	    return;
+//	  }
+
+//  	ExpectedExceptionTraits<ExpectedException>::expectedException();
+  }  
+
+  void setUp()
+  { 
+  	m_fixture->setUp (); 
+  }
+
+  void tearDown()
+  { 
+	  m_fixture->tearDown (); 
+  }
+
+  std::string toString() const
+  { 
+  	return "TestCaller " + getName(); 
+  }
+
+private: 
+  TestCaller( const TestCaller &other ); 
+  TestCaller &operator =( const TestCaller &other );
+
+private:
+  bool m_ownFixture;
+  Fixture *m_fixture;
+  TestMethod m_test;
+};
+
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCALLER_H

Added: trunk/mingw-libs/include/cppunit/TestCase.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestCase.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestCase.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,55 @@
+#ifndef CPPUNIT_TESTCASE_H
+#define CPPUNIT_TESTCASE_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/TestLeaf.h>
+#include <cppunit/TestAssert.h>
+#include <cppunit/TestFixture.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+
+
+/*! \brief A single test object.
+ *
+ * This class is used to implement a simple test case: define a subclass
+ * that overrides the runTest method.
+ *
+ * You don't usually need to use that class, but TestFixture and TestCaller instead.
+ *
+ * You are expected to subclass TestCase is you need to write a class similiar
+ * to TestCaller.
+ */
+class CPPUNIT_API TestCase : public TestLeaf,
+                             public TestFixture
+{
+public:
+
+    TestCase( const std::string &name );
+
+    TestCase();
+
+    ~TestCase();
+    
+    virtual void run(TestResult *result);
+
+    std::string getName() const;
+
+    //! FIXME: this should probably be pure virtual.
+    virtual void runTest();
+    
+private:
+    TestCase( const TestCase &other ); 
+    TestCase &operator=( const TestCase &other ); 
+    
+private:
+    const std::string m_name;
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCASE_H 

Added: trunk/mingw-libs/include/cppunit/TestComposite.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestComposite.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestComposite.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,45 @@
+#ifndef CPPUNIT_TESTCOMPSITE_H    // -*- C++ -*-
+#define CPPUNIT_TESTCOMPSITE_H
+
+#include <cppunit/Test.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief A Composite of Tests.
+ *
+ * Base class for all test composites. Subclass this class if you need to implement
+ * a custom TestSuite.
+ * 
+ * \see Test, TestSuite.
+ */
+class CPPUNIT_API TestComposite : public Test
+{
+public:
+  TestComposite( const std::string &name = "" );
+
+  ~TestComposite();
+
+  void run( TestResult *result );
+
+  int countTestCases() const;
+  
+  std::string getName() const;
+
+private:
+  TestComposite( const TestComposite &other );
+  TestComposite &operator =( const TestComposite &other ); 
+
+  virtual void doStartSuite( TestResult *controller );
+  virtual void doRunChildTests( TestResult *controller );
+  virtual void doEndSuite( TestResult *controller );
+
+private:
+  const std::string m_name;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCOMPSITE_H

Added: trunk/mingw-libs/include/cppunit/TestFailure.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestFailure.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestFailure.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,58 @@
+#ifndef CPPUNIT_TESTFAILURE_H    // -*- C++ -*-
+#define CPPUNIT_TESTFAILURE_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class Test;
+
+
+/*! \brief Record of a failed Test execution.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * A TestFailure collects a failed test together with
+ * the caught exception.
+ *
+ * TestFailure assumes lifetime control for any exception
+ * passed to it.
+ */
+class CPPUNIT_API TestFailure 
+{
+public:
+  TestFailure( Test *failedTest,
+               Exception *thrownException,
+               bool isError );
+
+  virtual ~TestFailure ();
+
+  virtual Test *failedTest() const;
+
+  virtual Exception *thrownException() const;
+
+  virtual SourceLine sourceLine() const;
+
+  virtual bool isError() const;
+
+  virtual std::string failedTestName() const;
+
+  virtual TestFailure *clone() const;
+
+protected:
+  Test *m_failedTest;
+  Exception *m_thrownException;
+  bool m_isError;
+
+private: 
+  TestFailure( const TestFailure &other ); 
+  TestFailure &operator =( const TestFailure& other ); 
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTFAILURE_H

Added: trunk/mingw-libs/include/cppunit/TestFixture.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestFixture.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestFixture.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,99 @@
+#ifndef CPPUNIT_TESTFIXTURE_H    // -*- C++ -*-
+#define CPPUNIT_TESTFIXTURE_H
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Wraps a test case with setUp and tearDown methods.
+ * \ingroup WritingTestFixture
+ *
+ * A TestFixture is used to provide a common environment for a set
+ * of test cases.
+ *
+ * To define a test fixture, do the following:
+ * - implement a subclass of TestCase 
+ * - the fixture is defined by instance variables 
+ * - initialize the fixture state by overriding setUp
+ *   (i.e. construct the instance variables of the fixture)
+ * - clean-up after a test by overriding tearDown.
+ *
+ * Each test runs in its own fixture so there
+ * can be no side effects among test runs.
+ * Here is an example:
+ * 
+ * \code
+ * class MathTest : public CppUnit::TestFixture {
+ * protected:
+ *   int m_value1, m_value2;
+ *
+ * public:
+ *   MathTest() {}
+ *
+ *   void setUp () {
+ *     m_value1 = 2;
+ *     m_value2 = 3;
+ *   }
+ * }
+ * \endcode
+ *
+ * For each test implement a method which interacts
+ * with the fixture. Verify the expected results with assertions specified
+ * by calling CPPUNIT_ASSERT on the expression you want to test:
+ * 
+ * \code
+ * public: 
+ *   void testAdd () {
+ *     int result = m_value1 + m_value2;
+ *     CPPUNIT_ASSERT( result == 5 );
+ *   }
+ * \endcode
+ * 
+ * Once the methods are defined you can run them. To do this, use
+ * a TestCaller.
+ *
+ * \code
+ * CppUnit::Test *test = new CppUnit::TestCaller<MathTest>( "testAdd", 
+ *                                                          &MathTest::testAdd );
+ * test->run();
+ * \endcode
+ *
+ *
+ * The tests to be run can be collected into a TestSuite. 
+ * 
+ * \code
+ * public: 
+ *   static CppUnit::TestSuite *MathTest::suite () {
+ *      CppUnit::TestSuite *suiteOfTests = new CppUnit::TestSuite;
+ *      suiteOfTests->addTest(new CppUnit::TestCaller<MathTest>(
+ *                              "testAdd", &MathTest::testAdd));
+ *      suiteOfTests->addTest(new CppUnit::TestCaller<MathTest>(
+ *                              "testDivideByZero", &MathTest::testDivideByZero));
+ *      return suiteOfTests;
+ *  }
+ * \endcode
+ * 
+ * A set of macros have been created for convenience. They are located in HelperMacros.h.
+ *
+ * \see TestResult, TestSuite, TestCaller,
+ * \see CPPUNIT_TEST_SUB_SUITE, CPPUNIT_TEST, CPPUNIT_TEST_SUITE_END, 
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_EXCEPTION, CPPUNIT_TEST_FAIL.
+ */
+class CPPUNIT_API TestFixture
+{
+public:
+  virtual ~TestFixture() {};
+
+  //! \brief Set up context before running a test.
+  virtual void setUp() {};
+
+  //! Clean up after the test run.
+  virtual void tearDown() {};
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif

Added: trunk/mingw-libs/include/cppunit/TestLeaf.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestLeaf.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestLeaf.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,44 @@
+#ifndef CPPUNIT_TESTLEAF_H
+#define CPPUNIT_TESTLEAF_H
+
+#include <cppunit/Test.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief A single test object.
+ *
+ * Base class for single test case: a test that doesn't have any children.
+ *
+ */
+class CPPUNIT_API TestLeaf: public Test
+{
+public:
+  /*! Returns 1 as the default number of test cases invoked by run().
+   * 
+   * You may override this method when many test cases are invoked (RepeatedTest
+   * for example).
+   * 
+   * \return 1.
+   * \see Test::countTestCases().
+   */
+  int countTestCases() const;
+
+  /*! Returns the number of child of this test case: 0.
+   *
+   * You should never override this method: a TestLeaf as no children by definition.
+   *
+   * \return 0.
+   */
+  int getChildTestCount() const;
+
+  /*! Always throws std::out_of_range.
+   * \see Test::doGetChildTestAt().
+   */
+  Test *doGetChildTestAt( int index ) const;
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTLEAF_H

Added: trunk/mingw-libs/include/cppunit/TestListener.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestListener.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestListener.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,148 @@
+#ifndef CPPUNIT_TESTLISTENER_H    // -*- C++ -*-
+#define CPPUNIT_TESTLISTENER_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class Test;
+class TestFailure;
+class TestResult;
+
+
+/*! \brief Listener for test progress and result.
+ * \ingroup TrackingTestExecution
+ *
+ * Implementing the Observer pattern a TestListener may be registered
+ * to a TestResult to obtain information on the testing progress. Use
+ * specialized sub classes of TestListener for text output
+ * (TextTestProgressListener). Do not use the Listener for the test
+ * result output, use a subclass of Outputter instead.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ *
+ * Here is an example to track test time:
+ *
+ *
+ * \code
+ * #include <cppunit/TestListener.h>
+ * #include <cppunit/Test.h>
+ * #include <time.h>    // for clock()
+ *
+ * class TimingListener : public CppUnit::TestListener
+ * {
+ * public:
+ *   void startTest( CppUnit::Test *test )
+ *   {
+ *     _chronometer.start();
+ *   }
+ *  
+ *   void endTest( CppUnit::Test *test )
+ *   {
+ *     _chronometer.end();
+ *     addTest( test, _chronometer.elapsedTime() );
+ *   }
+ *
+ *   // ... (interface to add/read test timing result)
+ *
+ * private:
+ *   Clock _chronometer;
+ * };
+ * \endcode
+ *   
+ * And another example that track failure/success at test suite level and captures
+ * the TestPath of each suite:
+ * \code
+ * class SuiteTracker : public CppUnit::TestListener
+ * {
+ * public:
+ *   void startSuite( CppUnit::Test *suite )
+ *   {
+ *     m_currentPath.add( suite );
+ *   }
+ *   
+ *   void addFailure( const TestFailure &failure )
+ *   {
+ *     m_suiteFailure.top() = false;
+ *   }
+ * 
+ *   void endSuite( CppUnit::Test *suite )
+ *   {
+ *     m_suiteStatus.insert( std::make_pair( suite, m_suiteFailure.top() ) );
+ *     m_suitePaths.insert( std::make_pair( suite, m_currentPath ) );
+ *
+ *     m_currentPath.up();
+ *     m_suiteFailure.pop();
+ *   }
+ *
+ * private:
+ *   std::stack<bool> m_suiteFailure;
+ *   CppUnit::TestPath m_currentPath;
+ *   std::map<CppUnit::Test *, bool> m_suiteStatus;
+ *   std::map<CppUnit::Test *, CppUnit::TestPath> m_suitePaths;
+ * };
+ * \endcode
+ *
+ * \see TestResult
+ */
+class CPPUNIT_API TestListener
+{
+public:
+  virtual ~TestListener() {}
+  
+  /// Called when just before a TestCase is run.
+  virtual void startTest( Test *test ) {}
+
+  /*! \brief Called when a failure occurs while running a test.
+   * \see TestFailure.
+   * \warning \a failure is a temporary object that is destroyed after the 
+   *          method call. Use TestFailure::clone() to create a duplicate.
+   */
+  virtual void addFailure( const TestFailure &failure ) {}
+
+  /// Called just after a TestCase was run (even if a failure occured).
+  virtual void endTest( Test *test ) {}
+
+  /*! \brief Called by a TestComposite just before running its child tests.
+   */
+  virtual void startSuite( Test *suite ) {}
+
+  /*! \brief Called by a TestComposite after running its child tests.
+   */
+  virtual void endSuite( Test *suite ) {}
+
+  /*! \brief Called by a TestRunner before running the test.
+   * 
+   * You can use this to do some global initialisation. A listener
+   * could also use to output a 'prolog' to the test run.
+   *
+   * \param test Test that is going to be run.
+   * \param eventManager Event manager used for the test run.
+   */
+  virtual void startTestRun( Test *test, 
+                             TestResult *eventManager ) {}
+
+  /*! \brief Called by a TestRunner after running the test.
+   *
+   * TextTestProgressListener use this to emit a line break. You can also use this
+   * to do some global uninitialisation.
+   *
+   * \param test Test that was run.
+   * \param eventManager Event manager used for the test run.
+   */
+  virtual void endTestRun( Test *test, 
+                           TestResult *eventManager ) {}
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTLISTENER_H
+
+

Added: trunk/mingw-libs/include/cppunit/TestPath.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestPath.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestPath.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,210 @@
+#ifndef CPPUNIT_TESTPATH_H
+#define CPPUNIT_TESTPATH_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<Test *>;
+#endif
+
+
+/*! \brief A List of Test representing a path to access a Test.
+ * \ingroup ExecutingTest
+ *
+ * The path can be converted to a string and resolved from a string with toString()
+ * and TestPath( Test *root, const std::string &pathAsString ).
+ *
+ * Pointed tests are not owned by the class.
+ *
+ * \see Test::resolvedTestPath()
+ */
+class CPPUNIT_API TestPath
+{
+public:
+  /*! \brief Constructs an invalid path.
+   * 
+   * The path is invalid until a test is added with add().
+   */
+  TestPath();
+
+  /*! \brief Constructs a valid path.
+   *
+   * \param root Test to add.
+   */
+  TestPath( Test *root );
+
+  /*! \brief Constructs a path using a slice of another path.
+   * \param otherPath Path the test are copied from.
+   * \param indexFirst Zero based index of the first test to copy. Adjusted to be in valid
+   *                   range. \a count is adjusted with \a indexFirst.
+   * \param count Number of tests to copy. If < 0 then all test starting from index
+   *              \a indexFirst are copied.
+   */
+  TestPath( const TestPath &otherPath, 
+            int indexFirst, 
+            int count = -1 );
+
+  /*! \brief Resolves a path from a string returned by toString().
+   *
+   * If \a pathAsString is an absolute path (begins with '/'), then the first test name
+   * of the path must be the name of \a searchRoot. Otherwise, \a pathAsString is a 
+   * relative path, and the first test found using Test::findTest() matching the first
+   * test name is used as root. An empty string resolve to a path containing 
+   * \a searchRoot.
+   *
+   * The resolved path is always valid.
+   *
+   * \param searchRoot Test used to resolve the path.
+   * \param pathAsString String that contains the path as a string created by toString().
+   * \exception std::invalid_argument if one of the test names can not be resolved.
+   * \see toString().
+   */
+  TestPath( Test *searchRoot, 
+            const std::string &pathAsString );
+
+  /*! \brief Copy constructor.
+   * \param other Object to copy.
+   */
+  TestPath( const TestPath &other );
+
+  virtual ~TestPath();
+
+  /*! \brief Tests if the path contains at least one test.
+   * \return \c true if the path contains at least one test, otherwise returns \c false.
+   */
+  virtual bool isValid() const;
+
+  /*! \brief Adds a test to the path.
+   * \param test Pointer on the test to add. Must not be \c NULL.
+   */
+  virtual void add( Test *test );
+
+  /*! \brief Adds all the tests of the specified path.
+   * \param path Path that contains the test to add.
+   */
+  virtual void add( const TestPath &path );
+
+  /*! \brief Inserts a test at the specified index.
+   * \param test Pointer on the test to insert. Must not be \c NULL.
+   * \param index Zero based index indicating where the test is inserted.
+   * \exception std::out_of_range is \a index < 0 or \a index > getTestCount().
+   */
+  virtual void insert( Test *test, int index );
+
+  /*! \brief Inserts all the tests at the specified path at a given index.
+   * \param path Path that contains the test to insert.
+   * \param index Zero based index indicating where the tests are inserted.
+   * \exception std::out_of_range is \a index < 0 or \a index > getTestCount(), and
+   *            \a path is valid.
+   */
+  virtual void insert( const TestPath &path, int index );
+
+  /*! \brief Removes all the test from the path.
+   *
+   * The path becomes invalid after this call.
+   */
+  virtual void removeTests();
+
+  /*! \brief Removes the test at the specified index of the path.
+   * \param index Zero based index of the test to remove.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  virtual void removeTest( int index );
+
+  /*! \brief Removes the last test.
+   * \exception std::out_of_range is the path is invalid.
+   * \see isValid().
+   */
+  virtual void up();
+
+  /*! \brief Returns the number of tests in the path.
+   * \return Number of tests in the path.
+   */
+  virtual int getTestCount() const;
+
+  /*! \brief Returns the test of the specified index.
+   * \param index Zero based index of the test to return.
+   * \return Pointer on the test at index \a index. Never \c NULL.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  virtual Test *getTestAt( int index ) const;
+
+  /*! \brief Get the last test of the path.
+   * \return Pointer on the last test (test at the bottom of the hierarchy). Never \c NULL.
+   * \exception std::out_of_range if the path is not valid ( isValid() returns \c false ).
+   */
+  virtual Test *getChildTest() const;
+
+  /*! \brief Returns the path as a string.
+   *
+   * For example, if a path is composed of three tests named "All Tests", "Math" and
+   * "Math::testAdd", toString() will return:
+   *
+   * "All Tests/Math/Math::testAdd".
+   * 
+   * \return A string composed of the test names separated with a '/'. It is a relative
+   *         path.
+   */
+  virtual std::string toString() const;
+
+  /*! \brief Assignment operator.
+   * \param other Object to copy.
+   * \return This object.
+   */
+  TestPath &operator =( const TestPath &other );
+
+protected:
+  /*! \brief Checks that the specified test index is within valid range.
+   * \param index Zero based index to check.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  void checkIndexValid( int index ) const;
+
+  /// A list of test names.
+  typedef CppUnitDeque<std::string> PathTestNames;
+
+  /*! \brief Splits a path string into its test name components.
+   * \param pathAsString Path string created with toString().
+   * \param testNames Test name components are added to that container.
+   * \return \c true if the path is relative (does not begin with '/'), \c false
+   *         if it is absolute (begin with '/').
+   */
+  bool splitPathString( const std::string &pathAsString,
+                        PathTestNames &testNames );
+
+  /*! \brief Finds the actual root of a path string and get the path string name components.
+   * \param searchRoot Test used as root if the path string is absolute, or to search
+   *                   the root test if the path string is relative.
+   * \param pathAsString Path string. May be absolute or relative.
+   * \param testNames Test name components are added to that container.
+   * \return Pointer on the resolved root test. Never \c NULL.
+   * \exception std::invalid_argument if either the root name can not be resolved or if
+   *            pathAsString contains no name components.
+   */
+  Test *findActualRoot( Test *searchRoot,
+                        const std::string &pathAsString,
+                        PathTestNames &testNames );
+
+protected:
+  typedef CppUnitDeque<Test *> Tests;
+  Tests m_tests;
+
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTPATH_H
+

Added: trunk/mingw-libs/include/cppunit/TestResult.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestResult.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestResult.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,155 @@
+#ifndef CPPUNIT_TESTRESULT_H
+#define CPPUNIT_TESTRESULT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/SynchronizedObject.h>
+#include <cppunit/portability/CppUnitDeque.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class Functor;
+class Protector;
+class ProtectorChain;
+class Test;
+class TestFailure;
+class TestListener;
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<TestListener *>;
+#endif
+
+/*! \brief Manages TestListener.
+ * \ingroup TrackingTestExecution
+ *
+ * A single instance of this class is used when running the test. It is usually
+ * created by the test runner (TestRunner).
+ *
+ * This class shouldn't have to be inherited from. Use a TestListener
+ * or one of its subclasses to be informed of the ongoing tests.
+ * Use a Outputter to receive a test summary once it has finished
+ *
+ * TestResult supplies a template method 'setSynchronizationObject()'
+ * so that subclasses can provide mutual exclusion in the face of multiple
+ * threads.  This can be useful when tests execute in one thread and
+ * they fill a subclass of TestResult which effects change in another 
+ * thread.  To have mutual exclusion, override setSynchronizationObject()
+ * and make sure that you create an instance of ExclusiveZone at the 
+ * beginning of each method.
+ *
+ * \see Test, TestListener, TestResultCollector, Outputter.
+ */
+class CPPUNIT_API TestResult : protected SynchronizedObject
+{
+public:
+  /// Construct a TestResult
+  TestResult( SynchronizationObject *syncObject = 0 );
+
+  /// Destroys a test result
+  virtual ~TestResult();
+
+  virtual void addListener( TestListener *listener );
+
+  virtual void removeListener( TestListener *listener );
+
+  /// Resets the stop flag.
+  virtual void reset();
+  
+  /// Stop testing
+  virtual void stop();
+
+  /// Returns whether testing should be stopped
+  virtual bool shouldStop() const;
+
+  /// Informs TestListener that a test will be started.
+  virtual void startTest( Test *test );
+
+  /*! \brief Adds an error to the list of errors. 
+   *  The passed in exception
+   *  caused the error
+   */
+  virtual void addError( Test *test, Exception *e );
+
+  /*! \brief Adds a failure to the list of failures. The passed in exception
+   * caused the failure.
+   */
+  virtual void addFailure( Test *test, Exception *e );
+
+  /// Informs TestListener that a test was completed.
+  virtual void endTest( Test *test );
+
+  /// Informs TestListener that a test suite will be started.
+  virtual void startSuite( Test *test );
+
+  /// Informs TestListener that a test suite was completed.
+  virtual void endSuite( Test *test );
+
+  /*! \brief Run the specified test.
+   * 
+   * Calls startTestRun(), test->run(this), and finally endTestRun().
+   */
+  virtual void runTest( Test *test );
+
+  /*! \brief Protects a call to the specified functor.
+   *
+   * See Protector to understand how protector works. A default protector is
+   * always present. It captures CppUnit::Exception, std::exception and
+   * any other exceptions, retrieving as much as possible information about
+   * the exception as possible.
+   *
+   * Additional Protector can be added to the chain to support other exception
+   * types using pushProtector() and popProtector().
+   *
+   * \param functor Functor to call (typically a call to setUp(), runTest() or
+   *                tearDown().
+   * \param test Test the functor is associated to (used for failure reporting).
+   * \param shortDescription Short description override for the failure message.
+   */
+  virtual bool protect( const Functor &functor,
+                        Test *test,
+                        const std::string &shortDescription = std::string("") );
+
+  /// Adds the specified protector to the protector chain.
+  virtual void pushProtector( Protector *protector );
+
+  /// Removes the last protector from the protector chain.
+  virtual void popProtector();
+
+protected:
+  /*! \brief Called to add a failure to the list of failures.
+   */
+  void addFailure( const TestFailure &failure );
+
+  virtual void startTestRun( Test *test );
+  virtual void endTestRun( Test *test );
+  
+protected:
+  typedef CppUnitDeque<TestListener *> TestListeners;
+  TestListeners m_listeners;
+  ProtectorChain *m_protectorChain;
+  bool m_stop;
+
+private: 
+  TestResult( const TestResult &other );
+  TestResult &operator =( const TestResult &other );
+};
+
+
+CPPUNIT_NS_END
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_TESTRESULT_H
+
+

Added: trunk/mingw-libs/include/cppunit/TestResultCollector.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestResultCollector.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestResultCollector.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,85 @@
+#ifndef CPPUNIT_TESTRESULTCOLLECTOR_H
+#define CPPUNIT_TESTRESULTCOLLECTOR_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 4660 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/TestSuccessListener.h>
+#include <cppunit/portability/CppUnitDeque.h>
+
+
+CPPUNIT_NS_BEGIN
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<TestFailure *>;
+//  template class CPPUNIT_API std::deque<Test *>;
+#endif
+
+
+/*! \brief Collects test result.
+ * \ingroup WritingTestResult
+ * \ingroup BrowsingCollectedTestResult
+ * 
+ * A TestResultCollector is a TestListener which collects the results of executing 
+ * a test case. It is an instance of the Collecting Parameter pattern.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ * \see TestListener, TestFailure.
+ */
+class CPPUNIT_API TestResultCollector : public TestSuccessListener
+{
+public:
+  typedef CppUnitDeque<TestFailure *> TestFailures;
+  typedef CppUnitDeque<Test *> Tests;
+
+
+  /*! Constructs a TestResultCollector object.
+   */
+  TestResultCollector( SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestResultCollector();
+
+  void startTest( Test *test );
+  void addFailure( const TestFailure &failure );
+
+  virtual void reset();
+
+  virtual int runTests() const;
+  virtual int testErrors() const;
+  virtual int testFailures() const;
+  virtual int testFailuresTotal() const;
+
+  virtual const TestFailures& failures() const;
+  virtual const Tests &tests() const;
+
+protected:
+  Tests m_tests;
+  TestFailures m_failures;
+  int m_testErrors;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TestResultCollector( const TestResultCollector &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TestResultCollector &copy );
+};
+
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_TESTRESULTCOLLECTOR_H

Added: trunk/mingw-libs/include/cppunit/TestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,135 @@
+#ifndef CPPUNIT_TESTRUNNER_H
+#define CPPUNIT_TESTRUNNER_H
+
+#include <cppunit/TestSuite.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+
+/*! \brief Generic test runner.
+ * \ingroup ExecutingTest
+ *
+ * The TestRunner assumes ownership of all added tests: you can not add test
+ * or suite that are local variable since they can't be deleted.
+ *
+ * Example of usage:
+ * \code
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ * #include <cppunit/CompilerOutputter.h>
+ * #include <cppunit/TestResult.h>
+ * #include <cppunit/TestResultCollector.h>
+ * #include <cppunit/TestRunner.h>
+ * #include <cppunit/TextTestProgressListener.h>
+ * 
+ * 
+ * int 
+ * main( int argc, char* argv[] )
+ * {
+ *   std::string testPath = (argc > 1) ? std::string(argv[1]) : "";
+ * 
+ *   // Create the event manager and test controller
+ *   CppUnit::TestResult controller;
+ * 
+ *   // Add a listener that colllects test result
+ *   CppUnit::TestResultCollector result;
+ *   controller.addListener( &result );        
+ * 
+ *   // Add a listener that print dots as test run.
+ *   CppUnit::TextTestProgressListener progress;
+ *   controller.addListener( &progress );      
+ * 
+ *   // Add the top suite to the test runner
+ *   CppUnit::TestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );   
+ *   try
+ *   {
+ *     std::cout << "Running "  <<  testPath;
+ *     runner.run( controller, testPath );
+ * 
+ *     std::cerr << std::endl;
+ * 
+ *     // Print test in a compiler compatible format.
+ *     CppUnit::CompilerOutputter outputter( &result, std::cerr );
+ *     outputter.write();                      
+ *   }
+ *   catch ( std::invalid_argument &e )  // Test path not resolved
+ *   {
+ *     std::cerr  <<  std::endl  
+ *                <<  "ERROR: "  <<  e.what()
+ *                << std::endl;
+ *     return 0;
+ *   }
+ * 
+ *   return result.wasSuccessful() ? 0 : 1;
+ * }
+ * \endcode
+ */
+class CPPUNIT_API TestRunner
+{
+public:
+  /*! \brief Constructs a TestRunner object.
+   */
+  TestRunner(  );
+
+  /// Destructor.
+  virtual ~TestRunner();
+
+  /*! \brief Adds the specified test.
+   * \param test Test to add. The TestRunner takes ownership of the test.
+   */
+  virtual void addTest( Test *test );
+
+  /*! \brief Runs a test using the specified controller.
+   * \param controller Event manager and controller used for testing
+   * \param testPath Test path string. See Test::resolveTestPath() for detail.
+   * \exception std::invalid_argument if no test matching \a testPath is found.
+   *                                  see TestPath::TestPath( Test*, const std::string &)
+   *                                  for detail.
+   */
+  virtual void run( TestResult &controller,
+                    const std::string &testPath = "" );
+
+protected:
+  /*! \brief (INTERNAL) Mutating test suite.
+   */
+  class CPPUNIT_API WrappingSuite : public TestSuite
+  {
+  public:
+    WrappingSuite( const std::string &name = "All Tests" );
+
+    int getChildTestCount() const;
+
+    std::string getName() const;
+
+    void run( TestResult *result );
+
+  protected:
+    Test *doGetChildTestAt( int index ) const;
+
+    bool hasOnlyOneTest() const;
+
+    Test *getUniqueChildTest() const;
+  };
+
+protected:
+  WrappingSuite *m_suite;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TestRunner( const TestRunner &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TestRunner &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTRUNNER_H

Added: trunk/mingw-libs/include/cppunit/TestSuccessListener.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestSuccessListener.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestSuccessListener.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,39 @@
+#ifndef CPPUNIT_TESTSUCCESSLISTENER_H
+#define CPPUNIT_TESTSUCCESSLISTENER_H
+
+#include <cppunit/SynchronizedObject.h>
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief TestListener that checks if any test case failed.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API TestSuccessListener : public TestListener,
+                                        public SynchronizedObject
+{
+public:
+  /*! Constructs a TestSuccessListener object.
+   */
+  TestSuccessListener( SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestSuccessListener();
+
+  virtual void reset();
+
+  void addFailure( const TestFailure &failure );
+
+  /// Returns whether the entire test was successful or not.
+  virtual bool wasSuccessful() const;
+
+private:
+  bool m_success;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTSUCCESSLISTENER_H

Added: trunk/mingw-libs/include/cppunit/TestSuite.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TestSuite.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TestSuite.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,80 @@
+#ifndef CPPUNIT_TESTSUITE_H    // -*- C++ -*-
+#define CPPUNIT_TESTSUITE_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/TestComposite.h>
+#include <cppunit/portability/CppUnitVector.h>
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::vector<Test *>;
+#endif
+
+
+/*! \brief A Composite of Tests.
+ * \ingroup CreatingTestSuite
+ *
+ * It runs a collection of test cases. Here is an example.
+ * \code
+ * CppUnit::TestSuite *suite= new CppUnit::TestSuite();
+ * suite->addTest(new CppUnit::TestCaller<MathTest> (
+ *                  "testAdd", testAdd));
+ * suite->addTest(new CppUnit::TestCaller<MathTest> (
+ *                  "testDivideByZero", testDivideByZero));
+ * \endcode
+ * Note that \link TestSuite TestSuites assume lifetime
+ * control for any tests added to them.
+ *
+ * TestSuites do not register themselves in the TestRegistry.
+ * \see Test 
+ * \see TestCaller
+ */
+class CPPUNIT_API TestSuite : public TestComposite
+{
+public:
+  /*! Constructs a test suite with the specified name.
+   */
+  TestSuite( std::string name = "" );
+
+  ~TestSuite();
+
+  /*! Adds the specified test to the suite.
+   * \param test Test to add. Must not be \c NULL.
+    */
+  void addTest( Test *test );
+
+  /*! Returns the list of the tests (DEPRECATED).
+   * \deprecated Use getChildTestCount() & getChildTestAt() of the 
+   *             TestComposite interface instead.
+   * \return Reference on a vector that contains the tests of the suite.
+   */
+  const CppUnitVector<Test *> &getTests() const;
+
+  /*! Destroys all the tests of the suite.
+   */
+  virtual void deleteContents();
+
+  int getChildTestCount() const;
+
+  Test *doGetChildTestAt( int index ) const;
+
+private:
+  CppUnitVector<Test *> m_tests;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_TESTSUITE_H

Added: trunk/mingw-libs/include/cppunit/TextOutputter.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TextOutputter.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TextOutputter.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,59 @@
+#ifndef CPPUNIT_TEXTOUTPUTTER_H
+#define CPPUNIT_TEXTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Outputter.h>
+#include <iostream>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class TestResultCollector;
+class TestFailure;
+
+
+/*! \brief Prints a TestResultCollector to a text stream.
+ * \ingroup WritingTestResult
+ */
+class CPPUNIT_API TextOutputter : public Outputter
+{
+public:
+  TextOutputter( TestResultCollector *result,
+                 std::ostream &stream );
+
+  /// Destructor.
+  virtual ~TextOutputter();
+
+  void write();
+  virtual void printFailures();
+  virtual void printHeader();
+
+  virtual void printFailure( TestFailure *failure,
+                             int failureNumber );
+  virtual void printFailureListMark( int failureNumber );
+  virtual void printFailureTestName( TestFailure *failure );
+  virtual void printFailureType( TestFailure *failure );
+  virtual void printFailureLocation( SourceLine sourceLine );
+  virtual void printFailureDetail( Exception *thrownException );
+  virtual void printFailureWarning();
+  virtual void printStatistics();
+
+protected:
+  TestResultCollector *m_result;
+  std::ostream &m_stream;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TextOutputter( const TextOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TextOutputter &copy );
+};
+
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TEXTOUTPUTTER_H

Added: trunk/mingw-libs/include/cppunit/TextTestProgressListener.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TextTestProgressListener.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TextTestProgressListener.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,44 @@
+#ifndef CPPUNIT_TEXTTESTPROGRESSLISTENER_H
+#define CPPUNIT_TEXTTESTPROGRESSLISTENER_H
+
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! 
+ * \brief TestListener that show the status of each TestCase test result.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API TextTestProgressListener : public TestListener
+{
+public:
+  /*! Constructs a TextTestProgressListener object.
+   */
+  TextTestProgressListener();
+
+  /// Destructor.
+  virtual ~TextTestProgressListener();
+
+  void startTest( Test *test );
+
+  void addFailure( const TestFailure &failure );
+
+  void endTestRun( Test *test, 
+                   TestResult *eventManager );
+
+private:
+  /// Prevents the use of the copy constructor.
+  TextTestProgressListener( const TextTestProgressListener &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TextTestProgressListener &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TEXTTESTPROGRESSLISTENER_H

Added: trunk/mingw-libs/include/cppunit/TextTestResult.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TextTestResult.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TextTestResult.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,39 @@
+#ifndef CPPUNIT_TEXTTESTRESULT_H
+#define CPPUNIT_TEXTTESTRESULT_H
+
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <iostream>
+
+CPPUNIT_NS_BEGIN
+
+
+class SourceLine;
+class Exception;
+class Test;
+
+/*! \brief Holds printable test result (DEPRECATED).
+ * \ingroup TrackingTestExecution
+ * 
+ * deprecated Use class TextTestProgressListener and TextOutputter instead.
+ */
+class CPPUNIT_API TextTestResult : public TestResult,
+                                   public TestResultCollector
+{
+public:
+  TextTestResult();
+
+  virtual void addFailure( const TestFailure &failure );
+  virtual void startTest( Test *test );
+  virtual void print( std::ostream &stream );
+};
+
+/** insertion operator for easy output */
+CPPUNIT_API std::ostream &operator <<( std::ostream &stream, 
+                                       TextTestResult &result );
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TEXTTESTRESULT_H
+
+

Added: trunk/mingw-libs/include/cppunit/TextTestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/TextTestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/TextTestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,6 @@
+#ifndef CPPUNIT_TEXTTESTRUNNER_H
+#define CPPUNIT_TEXTTESTRUNNER_H
+
+#include <cppunit/ui/text/TextTestRunner.h>
+
+#endif  // CPPUNIT_TEXTTESTRUNNER_H

Added: trunk/mingw-libs/include/cppunit/XmlOutputter.h
===================================================================
--- trunk/mingw-libs/include/cppunit/XmlOutputter.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/XmlOutputter.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,158 @@
+#ifndef CPPUNIT_XMLTESTRESULTOUTPUTTER_H
+#define CPPUNIT_XMLTESTRESULTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/Outputter.h>
+#include <cppunit/portability/CppUnitDeque.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <iostream>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFailure;
+class TestResultCollector;
+class XmlDocument;
+class XmlElement;
+class XmlOutputterHook;
+
+
+/*! \brief Outputs a TestResultCollector in XML format.
+ * \ingroup WritingTestResult
+ *
+ * Save the test result as a XML stream. 
+ *
+ * Additional datas can be added to the XML document using XmlOutputterHook. 
+ * Hook are not owned by the XmlOutputter. They should be valid until 
+ * destruction of the XmlOutputter. They can be removed with removeHook().
+ *
+ * \see XmlDocument, XmlElement, XmlOutputterHook.
+ */
+class CPPUNIT_API XmlOutputter : public Outputter
+{
+public:
+  /*! \brief Constructs a XmlOutputter object.
+   * \param result Result of the test run.
+   * \param stream Stream used to output the XML output.
+   * \param encoding Encoding used in the XML file (default is Latin-1). 
+   */
+  XmlOutputter( TestResultCollector *result,
+                std::ostream &stream,
+                std::string encoding = std::string("ISO-8859-1") );
+
+  /// Destructor.
+  virtual ~XmlOutputter();
+
+  /*! \brief Adds the specified hook to the outputter.
+   * \param hook Hook to add. Must not be \c NULL.
+   */
+  virtual void addHook( XmlOutputterHook *hook );
+
+  /*! \brief Removes the specified hook from the outputter.
+   * \param hook Hook to remove.
+   */
+  virtual void removeHook( XmlOutputterHook *hook );
+
+  /*! \brief Writes the specified result as an XML document to the stream.
+   *
+   * Refer to examples/cppunittest/XmlOutputterTest.cpp for example
+   * of use and XML document structure.
+   */
+  virtual void write();
+
+  /*! \brief Sets the XSL style sheet used.
+   *
+   * \param styleSheet Name of the style sheet used. If empty, then no style sheet
+   *                   is used (default).
+   */
+  virtual void setStyleSheet( const std::string &styleSheet );
+
+
+  typedef CppUnitMap<Test *,TestFailure*, std::less<Test*> > FailedTests;
+
+  /*! \brief Sets the root element and adds its children.
+   *
+   * Set the root element of the XML Document and add its child elements.
+   *
+   * For all hooks, call beginDocument() just after creating the root element (it
+   * is empty at this time), and endDocument() once all the datas have been added
+   * to the root element.
+   */
+  virtual void setRootNode();
+
+  virtual void addFailedTests( FailedTests &failedTests,
+                               XmlElement *rootNode );
+
+  virtual void addSuccessfulTests( FailedTests &failedTests,
+                                   XmlElement *rootNode );
+
+  /*! \brief Adds the statics element to the root node.
+   * 
+   * Creates a new element containing statistics data and adds it to the root element.
+   * Then, for all hooks, call statisticsAdded().
+   * \param rootNode Root element.
+   */
+  virtual void addStatistics( XmlElement *rootNode );
+
+  /*! \brief Adds a failed test to the failed tests node.
+   * Creates a new element containing datas about the failed test, and adds it to 
+   * the failed tests element.
+   * Then, for all hooks, call failTestAdded().
+   */
+  virtual void addFailedTest( Test *test,
+                              TestFailure *failure,
+                              int testNumber,
+                              XmlElement *testsNode );
+
+  virtual void addFailureLocation( TestFailure *failure,
+                                   XmlElement *testElement );
+
+
+  /*! \brief Adds a successful test to the successful tests node.
+   * Creates a new element containing datas about the successful test, and adds it to 
+   * the successful tests element.
+   * Then, for all hooks, call successfulTestAdded().
+   */
+  virtual void addSuccessfulTest( Test *test, 
+                                  int testNumber,
+                                  XmlElement *testsNode );
+protected:
+  virtual void fillFailedTestsMap( FailedTests &failedTests );
+
+protected:
+  typedef CppUnitDeque<XmlOutputterHook *> Hooks;
+
+  TestResultCollector *m_result;
+  std::ostream &m_stream;
+  std::string m_encoding;
+  std::string m_styleSheet;
+  XmlDocument *m_xml;
+  Hooks m_hooks;
+
+private:
+  /// Prevents the use of the copy constructor.
+  XmlOutputter( const XmlOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const XmlOutputter &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_XMLTESTRESULTOUTPUTTER_H

Added: trunk/mingw-libs/include/cppunit/XmlOutputterHook.h
===================================================================
--- trunk/mingw-libs/include/cppunit/XmlOutputterHook.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/XmlOutputterHook.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,161 @@
+#ifndef CPPUNIT_XMLOUTPUTTERHOOK_H
+#define CPPUNIT_XMLOUTPUTTERHOOK_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFailure;
+class XmlDocument;
+class XmlElement;
+
+
+
+/*! \brief Hook to customize Xml output.
+ *
+ * XmlOutputterHook can be passed to XmlOutputter to customize the XmlDocument.
+ *
+ * Common customizations are:
+ * - adding some datas to successfull or failed test with
+ *   failTestAdded() and successfulTestAdded(),
+ * - adding some statistics with statisticsAdded(),
+ * - adding other datas with beginDocument() or endDocument().
+ *
+ * See examples/ClockerPlugIn which makes use of most the hook.
+ *
+ * Another simple example of an outputter hook is shown below. It may be  
+ * used to add some meta information to your result files. In the example,
+ * the author name as well as the project name and test creation date is
+ * added to the head of the xml file.
+ *
+ * In order to make this information stored within the xml file, the virtual 
+ * member function beginDocument() is overriden where a new 
+ * XmlElement object is created.
+ *
+ * This element is simply added to the root node of the document which
+ * makes the information automatically being stored when the xml file
+ * is written.
+ *
+ * \code
+ * #include <cppunit/XmlOutputterHook.h>
+ * #include <cppunit/XmlElement.h>
+ * #include <cppunit/tools/StringTools.h>
+ * 
+ * ...
+ * 
+ * class MyXmlOutputterHook : public CppUnit::XmlOutputterHook
+ * {
+ * public:
+ *   MyXmlOutputterHook(const std::string projectName,
+ *                      const std::string author)
+ *   {
+ *      m_projectName = projectName;
+ *      m_author      = author;
+ *   };
+ * 
+ *   virtual ~MyXmlOutputterHook()
+ *   {
+ *   };
+ * 
+ *   void beginDocument(CppUnit::XmlDocument* document)
+ *   {
+ *     if (!document)
+ *       return;
+ *
+ *     // dump current time
+ *     std::string szDate          = CppUnit::StringTools::toString( (int)time(0) );
+ *     CppUnit::XmlElement* metaEl = new CppUnit::XmlElement("SuiteInfo", 
+ *                                                           "");
+ *
+ *     metaEl->addElement( new CppUnit::XmlElement("Author", m_author) );
+ *     metaEl->addElement( new CppUnit::XmlElement("Project", m_projectName) );
+ *     metaEl->addElement( new CppUnit::XmlElement("Date", szDate ) );
+ *    
+ *     document->rootElement().addElement(metaEl);
+ *   };
+ * private:
+ *   std::string m_projectName;
+ *   std::string m_author;
+ * }; 
+ * \endcode
+ *
+ * Within your application's main code, you need to snap the hook 
+ * object into your xml outputter object like shown below:
+ *
+ * \code
+ * CppUnit::TextUi::TestRunner runner;
+ * std::ofstream outputFile("testResults.xml");
+ * 
+ * CppUnit::XmlOutputter* outputter = new CppUnit::XmlOutputter( &runner.result(),
+ *                                                               outputFile );    
+ * MyXmlOutputterHook hook("myProject", "meAuthor");
+ * outputter->addHook(&hook);
+ * runner.setOutputter(outputter);    
+ * runner.addTest( VectorFixture::suite() );   
+ * runner.run();
+ * outputFile.close();
+ * \endcode
+ *
+ * This results into the following output:
+ *
+ * \code
+ * <TestRun>
+ *   <suiteInfo>
+ *     <author>meAuthor</author>
+ *     <project>myProject</project>
+ *     <date>1028143912</date>
+ *   </suiteInfo>
+ *   <FailedTests>
+ *    ...
+ * \endcode
+ *
+ * \see XmlOutputter, CppUnitTestPlugIn.
+ */
+class CPPUNIT_API XmlOutputterHook
+{
+public:
+  /*! Called before any elements is added to the root element.
+   * \param document XML Document being created.
+   */
+  virtual void beginDocument( XmlDocument *document );
+
+  /*! Called after adding all elements to the root element.
+   * \param document XML Document being created.
+   */
+  virtual void endDocument( XmlDocument *document );
+
+  /*! Called after adding a fail test element.
+   * \param document XML Document being created.
+   * \param testElement <FailedTest> element.
+   * \param test Test that failed.
+   * \param failure Test failure data.
+   */
+  virtual void failTestAdded( XmlDocument *document,
+                              XmlElement *testElement,
+                              Test *test,
+                              TestFailure *failure );
+
+  /*! Called after adding a successful test element.
+   * \param document XML Document being created.
+   * \param testElement <Test> element.
+   * \param test Test that was successful.
+   */
+  virtual void successfulTestAdded( XmlDocument *document,
+                                    XmlElement *testElement,
+                                    Test *test );
+
+  /*! Called after adding the statistic element.
+   * \param document XML Document being created.
+   * \param statisticsElement <Statistics> element.
+   */
+  virtual void statisticsAdded( XmlDocument *document,
+                                XmlElement *statisticsElement );
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_XMLOUTPUTTERHOOK_H

Added: trunk/mingw-libs/include/cppunit/config/CppUnitApi.h
===================================================================
--- trunk/mingw-libs/include/cppunit/config/CppUnitApi.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/CppUnitApi.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,33 @@
+#ifndef CPPUNIT_CONFIG_CPPUNITAPI
+#define CPPUNIT_CONFIG_CPPUNITAPI
+
+#undef CPPUNIT_API
+
+#ifdef WIN32
+
+// define CPPUNIT_DLL_BUILD when building CppUnit dll.
+#ifdef CPPUNIT_BUILD_DLL
+#define CPPUNIT_API __declspec(dllexport)
+#endif
+
+// define CPPUNIT_DLL when linking to CppUnit dll.
+#ifdef CPPUNIT_DLL
+#define CPPUNIT_API __declspec(dllimport)
+#endif
+
+#ifdef CPPUNIT_API
+#undef CPPUNIT_NEED_DLL_DECL
+#define CPPUNIT_NEED_DLL_DECL 1
+#endif
+
+#endif
+
+
+#ifndef CPPUNIT_API
+#define CPPUNIT_API
+#undef CPPUNIT_NEED_DLL_DECL
+#define CPPUNIT_NEED_DLL_DECL 0
+#endif
+
+ 
+#endif  // CPPUNIT_CONFIG_CPPUNITAPI

Added: trunk/mingw-libs/include/cppunit/config/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/config/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,379 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/config/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/config
+
+libcppunitinclude_HEADERS = \
+	config-bcb5.h \
+	config-mac.h \
+	config-msvc6.h \
+	SelectDllLoader.h \
+	CppUnitApi.h
+
+subdir = include/cppunit/config
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/config/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/config/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/config/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,8 @@
+libcppunitincludedir = $(includedir)/cppunit/config
+
+libcppunitinclude_HEADERS = \
+	config-bcb5.h \
+	config-mac.h \
+	config-msvc6.h \
+	SelectDllLoader.h \
+	CppUnitApi.h

Added: trunk/mingw-libs/include/cppunit/config/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/config/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,379 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/config
+
+libcppunitinclude_HEADERS = \
+	config-bcb5.h \
+	config-mac.h \
+	config-msvc6.h \
+	SelectDllLoader.h \
+	CppUnitApi.h
+
+subdir = include/cppunit/config
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/config/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/config/SelectDllLoader.h
===================================================================
--- trunk/mingw-libs/include/cppunit/config/SelectDllLoader.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/SelectDllLoader.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,76 @@
+#ifndef CPPUNIT_CONFIG_SELECTDLLLOADER_H
+#define CPPUNIT_CONFIG_SELECTDLLLOADER_H
+
+/*! \file
+ * Selects DynamicLibraryManager implementation.
+ *
+ * Don't include this file directly. Include Portability.h instead.
+ */
+
+/*!
+ * \def CPPUNIT_NO_TESTPLUGIN
+ * \brief If defined, then plug-in related classes and functions will not be compiled.
+ * 
+ * \internal
+ * CPPUNIT_HAVE_WIN32_DLL_LOADER
+ * If defined, Win32 implementation of DynamicLibraryManager will be used.
+ * 
+ * CPPUNIT_HAVE_BEOS_DLL_LOADER
+ * If defined, BeOs implementation of DynamicLibraryManager will be used.
+ * 
+ * CPPUNIT_HAVE_UNIX_DLL_LOADER
+ * If defined, Unix implementation (dlfcn.h) of DynamicLibraryManager will be used.
+ */
+
+/*!
+ * \def CPPUNIT_PLUGIN_EXPORT
+ * \ingroup WritingTestPlugIn
+ * \brief A macro to export a function from a dynamic library
+ *
+ * This macro export the C function following it from a dynamic library. 
+ * Exporting the function makes it accessible to the DynamicLibraryManager.
+ *
+ * Example of usage:
+ * \code
+ * #include <cppunit/include/plugin/TestPlugIn.h>
+ *
+ * CPPUNIT_PLUGIN_EXPORT CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void)
+ * {
+ *   ...
+ *   return &myPlugInInterface;
+ * }
+ * \endcode
+ */
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+// Is WIN32 platform ?
+#if defined(WIN32)
+#define CPPUNIT_HAVE_WIN32_DLL_LOADER 1
+#undef CPPUNIT_PLUGIN_EXPORT
+#define CPPUNIT_PLUGIN_EXPORT extern "C" __declspec(dllexport)
+
+// Is BeOS platform ?
+#elif defined(__BEOS__)
+#define CPPUNIT_HAVE_BEOS_DLL_LOADER 1
+
+// Is Unix platform and have shl_load() (hp-ux)
+#elif defined(CPPUNIT_HAVE_SHL_LOAD)
+#define CPPUNIT_HAVE_UNIX_SHL_LOADER 1
+
+// Is Unix platform and have include <dlfcn.h>
+#elif defined(CPPUNIT_HAVE_LIBDL)
+#define CPPUNIT_HAVE_UNIX_DLL_LOADER 1
+
+// Otherwise, disable support for DllLoader
+#else
+#define CPPUNIT_NO_TESTPLUGIN 1
+#endif
+
+#if !defined(CPPUNIT_PLUGIN_EXPORT)
+#define CPPUNIT_PLUGIN_EXPORT extern "C"
+#endif // !defined(CPPUNIT_PLUGIN_EXPORT)
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif // CPPUNIT_CONFIG_SELECTDLLLOADER_H

Added: trunk/mingw-libs/include/cppunit/config/config-bcb5.h
===================================================================
--- trunk/mingw-libs/include/cppunit/config/config-bcb5.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/config-bcb5.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,47 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_BCB5_H
+#define _INCLUDE_CPPUNIT_CONFIG_BCB5_H 1
+
+#define HAVE_CMATH 1
+ 
+/* include/cppunit/config-bcb5.h. Manually adapted from 
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifndef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#define CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST  0
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  1 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+ 
+/* _INCLUDE_CPPUNIT_CONFIG_BCB5_H */
+#endif

Added: trunk/mingw-libs/include/cppunit/config/config-mac.h
===================================================================
--- trunk/mingw-libs/include/cppunit/config/config-mac.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/config-mac.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,58 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_MAC_H
+#define _INCLUDE_CPPUNIT_CONFIG_MAC_H 1
+
+/* MacOS X should be installed using the configure script.
+   This file is for other macs.
+
+   It is not integrated into <cppunit/Portability.h> because we don't
+   know a suitable preprocessor symbol that will distinguish MacOS X
+   from other MacOS versions.  Email us if you know the answer.
+*/
+ 
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* define if the library defines strstream */
+#ifndef CPPUNIT_HAVE_CLASS_STRSTREAM 
+#define CPPUNIT_HAVE_CLASS_STRSTREAM  1 
+#endif
+
+/* Define if you have the <cmath> header file. */
+#ifdef CPPUNIT_HAVE_CMATH 
+#undef CPPUNIT_HAVE_CMATH
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  1 
+#endif
+
+/* define if the compiler has stringstream */
+#ifndef CPPUNIT_HAVE_SSTREAM 
+#define CPPUNIT_HAVE_SSTREAM  1 
+#endif
+
+/* Define if you have the <strstream> header file. */
+#ifndef CPPUNIT_HAVE_STRSTREAM 
+#define CPPUNIT_HAVE_STRSTREAM  1 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+/* _INCLUDE_CPPUNIT_CONFIG_MAC_H */
+#endif

Added: trunk/mingw-libs/include/cppunit/config/config-msvc6.h
===================================================================
--- trunk/mingw-libs/include/cppunit/config/config-msvc6.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config/config-msvc6.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,70 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_MSVC6_H
+#define _INCLUDE_CPPUNIT_CONFIG_MSVC6_H 1
+
+#if _MSC_VER > 1000     // VC++
+#pragma warning( disable : 4786 )   // disable warning debug symbol > 255...
+#endif // _MSC_VER > 1000
+
+#define HAVE_CMATH 1
+ 
+/* include/cppunit/config-msvc6.h. Manually adapted from 
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST 
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H 
+#undef CPPUNIT_HAVE_DLFCN_H 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  1 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+
+
+// Compiler error location format for CompilerOutputter
+// See class CompilerOutputter for format.
+#undef CPPUNIT_COMPILER_LOCATION_FORMAT
+#if _MSC_VER >= 1300    // VS 7.0
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l) : error : "
+#else
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l):"
+#endif
+
+// Uncomment to turn on STL wrapping => use this to test compilation. 
+// This will make CppUnit subclass std::vector & co to provide default
+// parameter.
+/*#define CPPUNIT_STD_NEED_ALLOCATOR 1
+#define CPPUNIT_STD_ALLOCATOR std::allocator<T>
+//#define CPPUNIT_NO_NAMESPACE 1
+*/
+
+
+/* _INCLUDE_CPPUNIT_CONFIG_MSVC6_H */
+#endif

Added: trunk/mingw-libs/include/cppunit/config-auto.h
===================================================================
--- trunk/mingw-libs/include/cppunit/config-auto.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/config-auto.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,152 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_AUTO_H
+#define _INCLUDE_CPPUNIT_CONFIG_AUTO_H 1
+ 
+/* include/cppunit/config-auto.h. Generated automatically at end of configure. */
+/* config/config.h.  Generated by configure.  */
+/* config/config.h.in.  Generated from configure.in by autoheader.  */
+
+/* define if library uses std::string::compare(string,pos,n) */
+/* #undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST */
+
+/* define if the library defines strstream */
+#ifndef CPPUNIT_HAVE_CLASS_STRSTREAM 
+#define CPPUNIT_HAVE_CLASS_STRSTREAM  1 
+#endif
+
+/* Define to 1 if you have the <cmath> header file. */
+#ifndef CPPUNIT_HAVE_CMATH 
+#define CPPUNIT_HAVE_CMATH  1 
+#endif
+
+/* Define if you have the GNU dld library. */
+/* #undef CPPUNIT_HAVE_DLD */
+
+/* Define to 1 if you have the `dlerror' function. */
+/* #undef CPPUNIT_HAVE_DLERROR */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+/* #undef CPPUNIT_HAVE_DLFCN_H */
+
+/* define if the compiler supports GCC C++ ABI name demangling */
+#ifndef CPPUNIT_HAVE_GCC_ABI_DEMANGLE 
+#define CPPUNIT_HAVE_GCC_ABI_DEMANGLE  1 
+#endif
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#ifndef CPPUNIT_HAVE_INTTYPES_H 
+#define CPPUNIT_HAVE_INTTYPES_H  1 
+#endif
+
+/* Define if you have the libdl library or equivalent. */
+/* #undef CPPUNIT_HAVE_LIBDL */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#ifndef CPPUNIT_HAVE_MEMORY_H 
+#define CPPUNIT_HAVE_MEMORY_H  1 
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES 
+#define CPPUNIT_HAVE_NAMESPACES  1 
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI 
+#define CPPUNIT_HAVE_RTTI  1 
+#endif
+
+/* Define if you have the shl_load function. */
+/* #undef CPPUNIT_HAVE_SHL_LOAD */
+
+/* define if the compiler has stringstream */
+#ifndef CPPUNIT_HAVE_SSTREAM 
+#define CPPUNIT_HAVE_SSTREAM  1 
+#endif
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#ifndef CPPUNIT_HAVE_STDINT_H 
+#define CPPUNIT_HAVE_STDINT_H  1 
+#endif
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#ifndef CPPUNIT_HAVE_STDLIB_H 
+#define CPPUNIT_HAVE_STDLIB_H  1 
+#endif
+
+/* Define to 1 if you have the <strings.h> header file. */
+#ifndef CPPUNIT_HAVE_STRINGS_H 
+#define CPPUNIT_HAVE_STRINGS_H  1 
+#endif
+
+/* Define to 1 if you have the <string.h> header file. */
+#ifndef CPPUNIT_HAVE_STRING_H 
+#define CPPUNIT_HAVE_STRING_H  1 
+#endif
+
+/* Define to 1 if you have the <strstream> header file. */
+#ifndef CPPUNIT_HAVE_STRSTREAM 
+#define CPPUNIT_HAVE_STRSTREAM  1 
+#endif
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#ifndef CPPUNIT_HAVE_SYS_STAT_H 
+#define CPPUNIT_HAVE_SYS_STAT_H  1 
+#endif
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#ifndef CPPUNIT_HAVE_SYS_TYPES_H 
+#define CPPUNIT_HAVE_SYS_TYPES_H  1 
+#endif
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#ifndef CPPUNIT_HAVE_UNISTD_H 
+#define CPPUNIT_HAVE_UNISTD_H  1 
+#endif
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE 
+#define CPPUNIT_PACKAGE  "cppunit" 
+#endif
+
+/* Define to the address where bug reports for this package should be sent. */
+#ifndef CPPUNIT_PACKAGE_BUGREPORT 
+#define CPPUNIT_PACKAGE_BUGREPORT  "" 
+#endif
+
+/* Define to the full name of this package. */
+#ifndef CPPUNIT_PACKAGE_NAME 
+#define CPPUNIT_PACKAGE_NAME  "" 
+#endif
+
+/* Define to the full name and version of this package. */
+#ifndef CPPUNIT_PACKAGE_STRING 
+#define CPPUNIT_PACKAGE_STRING  "" 
+#endif
+
+/* Define to the one symbol short name of this package. */
+#ifndef CPPUNIT_PACKAGE_TARNAME 
+#define CPPUNIT_PACKAGE_TARNAME  "" 
+#endif
+
+/* Define to the version of this package. */
+#ifndef CPPUNIT_PACKAGE_VERSION 
+#define CPPUNIT_PACKAGE_VERSION  "" 
+#endif
+
+/* Define to 1 if you have the ANSI C header files. */
+#ifndef CPPUNIT_STDC_HEADERS 
+#define CPPUNIT_STDC_HEADERS  1 
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME 
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI 
+#endif
+
+/* Version number of package */
+#ifndef CPPUNIT_VERSION 
+#define CPPUNIT_VERSION  "1.10.2" 
+#endif
+ 
+/* _INCLUDE_CPPUNIT_CONFIG_AUTO_H */
+#endif

Added: trunk/mingw-libs/include/cppunit/extensions/AutoRegisterSuite.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/AutoRegisterSuite.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/AutoRegisterSuite.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,83 @@
+#ifndef CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
+#define CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
+
+#include <cppunit/extensions/TestSuiteFactory.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief (Implementation) Automatically register the test suite of the specified type.
+ *
+ * You should not use this class directly. Instead, use the following macros:
+ * - CPPUNIT_TEST_SUITE_REGISTRATION()
+ * - CPPUNIT_TEST_SUITE_NAMED_REGISTRATION()
+ *
+ * This object will register the test returned by TestCaseType::suite()
+ * when constructed to the test registry.
+ *
+ * This object is intented to be used as a static variable.
+ *
+ *
+ * \param TestCaseType Type of the test case which suite is registered.
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ * \see CppUnit::TestFactoryRegistry.
+ */
+template<class TestCaseType>
+class AutoRegisterSuite
+{
+public:
+  /** Auto-register the suite factory in the global registry.
+   */
+  AutoRegisterSuite()
+      : m_registry( &TestFactoryRegistry::getRegistry() )
+  {
+    m_registry->registerFactory( &m_factory );
+  }
+
+  /** Auto-register the suite factory in the specified registry.
+   * \param name Name of the registry.
+   */
+  AutoRegisterSuite( const std::string &name )
+      : m_registry( &TestFactoryRegistry::getRegistry( name ) )
+  {
+    m_registry->registerFactory( &m_factory );
+  }
+
+  ~AutoRegisterSuite()
+  {
+    if ( TestFactoryRegistry::isValid() )
+      m_registry->unregisterFactory( &m_factory );
+  }
+
+private:
+  TestFactoryRegistry *m_registry;
+  TestSuiteFactory<TestCaseType> m_factory;
+};
+
+
+/*! \brief (Implementation) Automatically adds a registry into another registry.
+ *
+ * Don't use this class. Use the macros CPPUNIT_REGISTRY_ADD() and
+ * CPPUNIT_REGISTRY_ADD_TO_DEFAULT() instead.
+ */
+class AutoRegisterRegistry
+{
+public:
+  AutoRegisterRegistry( const std::string &which,
+                        const std::string &to )
+  {
+    TestFactoryRegistry::getRegistry( to ).addRegistry( which );
+  }
+
+  AutoRegisterRegistry( const std::string &which )
+  {
+    TestFactoryRegistry::getRegistry().addRegistry( which );
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H

Added: trunk/mingw-libs/include/cppunit/extensions/ExceptionTestCaseDecorator.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/ExceptionTestCaseDecorator.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/ExceptionTestCaseDecorator.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,104 @@
+#ifndef CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+#define CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/extensions/TestCaseDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Expected exception test case decorator.
+ *
+ * A decorator used to assert that a specific test case should throw an
+ * exception of a given type.
+ *
+ * You should use this class only if you need to check the exception object
+ * state (that a specific cause is set for example). If you don't need to
+ * do that, you might consider using CPPUNIT_TEST_EXCEPTION() instead.
+ *
+ * Intended use is to subclass and override checkException(). Example:
+ *
+ * \code
+ *
+ * class NetworkErrorTestCaseDecorator : 
+ *           public ExceptionTestCaseDecorator<NetworkError>
+ * {
+ * public:
+ *   NetworkErrorTestCaseDecorator( NetworkError::Cause expectedCause )
+ *       : m_expectedCause( expectedCause )
+ *   {
+ *   }
+ * private:
+ *   void checkException( ExpectedExceptionType &e )
+ *   {
+ *     CPPUNIT_ASSERT_EQUAL( m_expectedCause, e.getCause() );
+ *   }
+ *
+ *   NetworkError::Cause m_expectedCause;
+ * };
+ * \endcode
+ *
+ */ 
+template<class ExpectedException>
+class ExceptionTestCaseDecorator : public TestCaseDecorator
+{
+public:
+  typedef ExpectedException ExpectedExceptionType;
+
+  /*! \brief Decorates the specified test.
+   * \param test TestCase to decorate. Assumes ownership of the test.
+   */
+  ExceptionTestCaseDecorator( TestCase *test )
+      : TestCaseDecorator( test )
+  {
+  }
+
+  /*! \brief Checks that the expected exception is thrown by the decorated test.
+   * is thrown.
+   *
+   * Calls the decorated test runTest() and checks that an exception of
+   * type ExpectedException is thrown. Call checkException() passing the
+   * exception that was caught so that some assertions can be made if
+   * needed.
+   */
+  void runTest()
+  {
+    try
+    {
+      TestCaseDecorator::runTest();
+    }
+    catch ( ExpectedExceptionType &e )
+    {
+      checkException( e );
+      return;
+    }
+
+    // Moved outside the try{} statement to handle the case where the
+    // expected exception type is Exception (expecting assertion failure).
+#if CPPUNIT_USE_TYPEINFO_NAME
+      throw Exception( Message(
+                         "expected exception not thrown",
+                         "Expected exception type: " + 
+                           TypeInfoHelper::getClassName( 
+                               typeid( ExpectedExceptionType ) ) ) );
+#else
+      throw Exception( Message("expected exception not thrown") );
+#endif
+  }
+
+private:
+  /*! \brief Called when the exception is caught.
+   *
+   * Should be overriden to check the exception.
+   */
+  virtual void checkException( ExpectedExceptionType &e )
+  {
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+

Added: trunk/mingw-libs/include/cppunit/extensions/HelperMacros.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/HelperMacros.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/HelperMacros.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,541 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file HelperMacros.h
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/04/15
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_EXTENSIONS_HELPERMACROS_H
+#define CPPUNIT_EXTENSIONS_HELPERMACROS_H
+
+#include <cppunit/TestCaller.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/extensions/AutoRegisterSuite.h>
+#include <cppunit/extensions/ExceptionTestCaseDecorator.h>
+#include <cppunit/extensions/TestFixtureFactory.h>
+#include <cppunit/extensions/TestNamer.h>
+#include <cppunit/extensions/TestSuiteBuilderContext.h>
+#include <memory>
+
+
+/*! \addtogroup WritingTestFixture Writing test fixture
+ */
+/** @{
+ */
+
+
+/** \file
+ * Macros intended to ease the definition of test suites.
+ *
+ * The macros
+ * CPPUNIT_TEST_SUITE(), CPPUNIT_TEST(), and CPPUNIT_TEST_SUITE_END()
+ * are designed to facilitate easy creation of a test suite.
+ * For example,
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST( testEquality );
+ *   CPPUNIT_TEST( testSetName );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testEquality();
+ *   void testSetName();
+ * };
+ * \endcode
+ * 
+ * The effect of these macros is to define two methods in the
+ * class MyTest.  The first method is an auxiliary function
+ * named registerTests that you will not need to call directly.
+ * The second function
+ * \code static CppUnit::TestSuite *suite()\endcode
+ * returns a pointer to the suite of tests defined by the CPPUNIT_TEST()
+ * macros.  
+ *
+ * Rather than invoking suite() directly,
+ * the macro CPPUNIT_TEST_SUITE_REGISTRATION() is
+ * used to create a static variable that automatically
+ * registers its test suite in a global registry.
+ * The registry yields a Test instance containing all the
+ * registered suites.
+ * \code
+ * CPPUNIT_TEST_SUITE_REGISTRATION( MyTest );
+ * CppUnit::Test* tp =
+ *   CppUnit::TestFactoryRegistry::getRegistry().makeTest();
+ * \endcode
+ * 
+ * The test suite macros can even be used with templated test classes.
+ * For example:
+ *
+ * \code
+ * template<typename CharType>
+ * class StringTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( StringTest );
+ *   CPPUNIT_TEST( testAppend );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:  
+ *   ...
+ * };
+ * \endcode
+ *
+ * You need to add in an implementation file:
+ *
+ * \code
+ * CPPUNIT_TEST_SUITE_REGISTRATION( StringTest<char> );
+ * CPPUNIT_TEST_SUITE_REGISTRATION( StringTest<wchar_t> );
+ * \endcode
+ */
+
+
+/*! \brief Begin test suite
+ *
+ * This macro starts the declaration of a new test suite.
+ * Use CPPUNIT_TEST_SUB_SUITE() instead, if you wish to include the
+ * test suite of the parent class.
+ *
+ * \param ATestFixtureType Type of the test case class. This type \b MUST
+ *                         be derived from TestFixture.
+ * \see CPPUNIT_TEST_SUB_SUITE, CPPUNIT_TEST, CPPUNIT_TEST_SUITE_END, 
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_EXCEPTION, CPPUNIT_TEST_FAIL.
+ */
+#define CPPUNIT_TEST_SUITE( ATestFixtureType )                              \
+  public:                                                                   \
+    typedef ATestFixtureType TestFixtureType;                               \
+                                                                            \
+  private:                                                                  \
+    static const CPPUNIT_NS::TestNamer &getTestNamer__()                    \
+    {                                                                       \
+      static CPPUNIT_TESTNAMER_DECL( testNamer, ATestFixtureType );         \
+      return testNamer;                                                     \
+    }                                                                       \
+                                                                            \
+  public:                                                                   \
+    typedef CPPUNIT_NS::TestSuiteBuilderContext<TestFixtureType>            \
+                TestSuiteBuilderContextType;                                \
+                                                                            \
+    static void                                                             \
+    addTestsToSuite( CPPUNIT_NS::TestSuiteBuilderContextBase &baseContext ) \
+    {                                                                       \
+      TestSuiteBuilderContextType context( baseContext )
+
+
+/*! \brief Begin test suite (includes parent suite)
+ * 
+ * This macro may only be used in a class whose parent class
+ * defines a test suite using CPPUNIT_TEST_SUITE() or CPPUNIT_TEST_SUB_SUITE().
+ *
+ * This macro begins the declaration of a test suite, in the same
+ * manner as CPPUNIT_TEST_SUITE().  In addition, the test suite of the
+ * parent is automatically inserted in the test suite being
+ * defined.
+ * 
+ * Here is an example:
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class MySubTest : public MyTest {
+ *   CPPUNIT_TEST_SUB_SUITE( MySubTest, MyTest );
+ *   CPPUNIT_TEST( testAdd );
+ *   CPPUNIT_TEST( testSub );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testAdd();
+ *   void testSub();
+ * };
+ * \endcode
+ *
+ * \param ATestFixtureType Type of the test case class. This type \b MUST
+ *                         be derived from TestFixture.
+ * \param ASuperClass   Type of the parent class.
+ * \see CPPUNIT_TEST_SUITE.
+ */
+#define CPPUNIT_TEST_SUB_SUITE( ATestFixtureType, ASuperClass )  \
+  public:                                                        \
+    typedef ASuperClass ParentTestFixtureType;                   \
+  private:                                                       \
+    CPPUNIT_TEST_SUITE( ATestFixtureType );                      \
+      ParentTestFixtureType::addTestsToSuite( baseContext )
+
+
+/*! \brief End declaration of the test suite.
+ *
+ * After this macro, member access is set to "private".
+ *
+ * \see  CPPUNIT_TEST_SUITE.
+ * \see  CPPUNIT_TEST_SUITE_REGISTRATION.
+ */
+#define CPPUNIT_TEST_SUITE_END()                                               \
+    }                                                                          \
+                                                                               \
+    static CPPUNIT_NS::TestSuite *suite()                                      \
+    {                                                                          \
+      const CPPUNIT_NS::TestNamer &namer = getTestNamer__();                   \
+      std::auto_ptr<CPPUNIT_NS::TestSuite> suite(                              \
+             new CPPUNIT_NS::TestSuite( namer.getFixtureName() ));             \
+      CPPUNIT_NS::ConcretTestFixtureFactory<TestFixtureType> factory;          \
+      CPPUNIT_NS::TestSuiteBuilderContextBase context( *suite.get(),           \
+                                                       namer,                  \
+                                                       factory );              \
+      TestFixtureType::addTestsToSuite( context );                             \
+      return suite.release();                                                  \
+    }                                                                          \
+  private: /* dummy typedef so that the macro can still end with ';'*/         \
+    typedef int CppUnitDummyTypedefForSemiColonEnding__
+
+/*! \brief End declaration of an abstract test suite.
+ *
+ * Use this macro to indicate that the %TestFixture is abstract. No
+ * static suite() method will be declared. 
+ *
+ * After this macro, member access is set to "private".
+ *
+ * Here is an example of usage:
+ *
+ * The abstract test fixture:
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class AbstractDocument;
+ * class AbstractDocumentTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( AbstractDocumentTest );
+ *   CPPUNIT_TEST( testInsertText );
+ *   CPPUNIT_TEST_SUITE_END_ABSTRACT();
+ * public:
+ *   void testInsertText();
+ * 
+ *   void setUp()
+ *   {
+ *     m_document = makeDocument();
+ *   }
+ *
+ *   void tearDown()
+ *   {
+ *     delete m_document;
+ *   }
+ * protected:
+ *   virtual AbstractDocument *makeDocument() =0;
+ *
+ *   AbstractDocument *m_document;
+ * };\endcode
+ *
+ * The concret test fixture:
+ * \code
+ * class RichTextDocumentTest : public AbstractDocumentTest {
+ *   CPPUNIT_TEST_SUB_SUITE( RichTextDocumentTest, AbstractDocumentTest );
+ *   CPPUNIT_TEST( testInsertFormatedText );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testInsertFormatedText();
+ * protected:
+ *   AbstractDocument *makeDocument()
+ *   {
+ *     return new RichTextDocument();
+ *   }
+ * };\endcode
+ *
+ * \see  CPPUNIT_TEST_SUB_SUITE.
+ * \see  CPPUNIT_TEST_SUITE_REGISTRATION.
+ */
+#define CPPUNIT_TEST_SUITE_END_ABSTRACT()                                      \
+    }                                                                          \
+  private: /* dummy typedef so that the macro can still end with ';'*/         \
+    typedef int CppUnitDummyTypedefForSemiColonEnding__
+
+
+/*! \brief Add a test to the suite (for custom test macro).
+ *
+ * The specified test will be added to the test suite being declared. This macro
+ * is intended for \e advanced usage, to extend %CppUnit by creating new macro such
+ * as CPPUNIT_TEST_EXCEPTION()...
+ *
+ * Between macro CPPUNIT_TEST_SUITE() and CPPUNIT_TEST_SUITE_END(), you can assume
+ * that the following variables can be used:
+ * \code
+ * typedef TestSuiteBuilder<TestFixtureType> TestSuiteBuilderType;
+ * TestSuiteBuilderType &context;
+ * \endcode
+ *
+ * \c context can be used to name test case, create new test fixture instance,
+ * or add test case to the test fixture suite.
+ *
+ * Below is an example that show how to use this macro to create new macro to add
+ * test to the fixture suite. The macro below show how you would add a new type
+ * of test case which fails if the execution last more than a given time limit.
+ * It relies on an imaginary TimeOutTestCaller class which has an interface similar
+ * to TestCaller.
+ * 
+ * \code
+ * #define CPPUNITEX_TEST_TIMELIMIT( testMethod, timeLimit )            \
+ *      CPPUNIT_TEST_SUITE_ADD_TEST( (new TimeOutTestCaller<TestFixtureType>(  \
+ *                  namer.getTestNameFor( #testMethod ),                \
+ *                  &TestFixtureType::testMethod,                   \
+ *                  factory.makeFixture(),                              \
+ *                  timeLimit ) ) )
+ *   
+ * class PerformanceTest : CppUnit::TestFixture
+ * {
+ * public:
+ *   CPPUNIT_TEST_SUITE( PerformanceTest );
+ *   CPPUNITEX_TEST_TIMELIMIT( testSortReverseOrder, 5.0 );
+ *   CPPUNIT_TEST_SUITE_END();
+ *
+ *   void testSortReverseOrder();
+ * };
+ * \endcode
+ *
+ * \param test Test to add to the suite. Must be a subclass of Test. The test name
+ *             should have been obtained using TestNamer::getTestNameFor().
+ */
+#define CPPUNIT_TEST_SUITE_ADD_TEST( test ) \
+      context.addTest( test )
+
+/*! \brief Add a method to the suite.
+ * \param testMethod Name of the method of the test case to add to the
+ *                   suite. The signature of the method must be of
+ *                   type: void testMethod();
+ * \see  CPPUNIT_TEST_SUITE.
+ */
+#define CPPUNIT_TEST( testMethod )                        \
+    CPPUNIT_TEST_SUITE_ADD_TEST(                           \
+        ( new CPPUNIT_NS::TestCaller<TestFixtureType>(    \
+                  context.getTestNameFor( #testMethod),   \
+                  &TestFixtureType::testMethod,           \
+                  context.makeFixture() ) ) )
+
+/*! \brief Add a test which fail if the specified exception is not caught.
+ *
+ * Example:
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * #include <vector>
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST_EXCEPTION( testVectorAtThrow, std::invalid_argument );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testVectorAtThrow()
+ *   {
+ *     std::vector<int> v;
+ *     v.at( 1 );     // must throw exception std::invalid_argument
+ *   }
+ * };
+ * \endcode
+ *
+ * \param testMethod Name of the method of the test case to add to the suite.
+ * \param ExceptionType Type of the exception that must be thrown by the test 
+ *                      method.
+ * \deprecated Use the assertion macro CPPUNIT_ASSERT_THROW instead.
+ */
+#define CPPUNIT_TEST_EXCEPTION( testMethod, ExceptionType )          \
+  CPPUNIT_TEST_SUITE_ADD_TEST(                                        \
+      (new CPPUNIT_NS::ExceptionTestCaseDecorator< ExceptionType >(  \
+          new CPPUNIT_NS::TestCaller< TestFixtureType >(             \
+                               context.getTestNameFor( #testMethod ),  \
+                               &TestFixtureType::testMethod,         \
+                               context.makeFixture() ) ) ) )
+
+/*! \brief Adds a test case which is excepted to fail.
+ *
+ * The added test case expect an assertion to fail. You usually used that type
+ * of test case when testing custom assertion macros.
+ *
+ * \code
+ * CPPUNIT_TEST_FAIL( testAssertFalseFail );
+ * 
+ * void testAssertFalseFail()
+ * {
+ *   CPPUNIT_ASSERT( false );
+ * }
+ * \endcode
+ * \see CreatingNewAssertions.
+ * \deprecated Use the assertion macro CPPUNIT_ASSERT_ASSERTION_FAIL instead.
+ */
+#define CPPUNIT_TEST_FAIL( testMethod ) \
+              CPPUNIT_TEST_EXCEPTION( testMethod, CPPUNIT_NS::Exception )
+
+/*! \brief Adds some custom test cases.
+ *
+ * Use this to add one or more test cases to the fixture suite. The specified
+ * method is called with a context parameter that can be used to name, 
+ * instantiate fixture, and add instantiated test case to the fixture suite.
+ * The specified method must have the following signature:
+ * \code
+ * static void aMethodName( TestSuiteBuilderContextType &context );
+ * \endcode
+ *
+ * \c TestSuiteBuilderContextType is typedef to 
+ * TestSuiteBuilderContext<TestFixtureType> declared by CPPUNIT_TEST_SUITE().
+ *
+ * Here is an example that add two custom tests:
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ *
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS( addTimeOutTests );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   static void addTimeOutTests( TestSuiteBuilderContextType &context )
+ *   {
+ *     context.addTest( new TimeOutTestCaller( context.getTestNameFor( "test1" ) ),
+ *                                             &MyTest::test1,
+ *                                             context.makeFixture(),
+ *                                             5.0 );
+ *     context.addTest( new TimeOutTestCaller( context.getTestNameFor( "test2" ) ),
+ *                                             &MyTest::test2,
+ *                                             context.makeFixture(),
+ *                                             5.0 );
+ *   }
+ *
+ *   void test1()
+ *   {
+ *     // Do some test that may never end...
+ *   }
+ *
+ *   void test2()
+ *   {
+ *     // Do some test that may never end...
+ *   }
+ * };
+ * \endcode
+ * @param testAdderMethod Name of the method called to add the test cases.
+ */
+#define CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS( testAdderMethod ) \
+      testAdderMethod( context )
+
+/*! \brief Adds a property to the test suite builder context.
+ * \param APropertyKey   Key of the property to add.
+ * \param APropertyValue Value for the added property.
+ * Example:
+ * \code
+ * CPPUNIT_TEST_SUITE_PROPERTY("XmlFileName", "paraTest.xml"); \endcode
+ */
+#define CPPUNIT_TEST_SUITE_PROPERTY( APropertyKey, APropertyValue ) \
+    context.addProperty( std::string(APropertyKey),                 \
+                         std::string(APropertyValue) )
+
+/** @}
+ */
+
+
+/*! Adds the specified fixture suite to the unnamed registry.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro declares a static variable whose construction
+ * causes a test suite factory to be inserted in a global registry
+ * of such factories.  The registry is available by calling
+ * the static function CppUnit::TestFactoryRegistry::getRegistry().
+ * 
+ * \param ATestFixtureType Type of the test case class.
+ * \warning This macro should be used only once per line of code (the line
+ *          number is used to name a hidden static variable).
+ * \see CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT
+ * \see CPPUNIT_REGISTRY_ADD
+ * \see CPPUNIT_TEST_SUITE, CppUnit::AutoRegisterSuite, 
+ *      CppUnit::TestFactoryRegistry.
+ */
+#define CPPUNIT_TEST_SUITE_REGISTRATION( ATestFixtureType )      \
+  static CPPUNIT_NS::AutoRegisterSuite< ATestFixtureType >       \
+             CPPUNIT_MAKE_UNIQUE_NAME(autoRegisterRegistry__ )
+
+
+/** Adds the specified fixture suite to the specified registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro declares a static variable whose construction
+ * causes a test suite factory to be inserted in the global registry
+ * suite of the specified name. The registry is available by calling
+ * the static function CppUnit::TestFactoryRegistry::getRegistry().
+ * 
+ * For the suite name, use a string returned by a static function rather
+ * than a hardcoded string. That way, you can know what are the name of
+ * named registry and you don't risk mistyping the registry name.
+ *
+ * \code
+ * // MySuites.h
+ * namespace MySuites {
+ *   std::string math() { 
+ *     return "Math";
+ *   }
+ * }
+ *
+ * // ComplexNumberTest.cpp
+ * #include "MySuites.h"
+ * 
+ * CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ComplexNumberTest, MySuites::math() );
+ * \endcode
+ *
+ * \param ATestFixtureType Type of the test case class.
+ * \param suiteName Name of the global registry suite the test suite is 
+ *                  registered into.
+ * \warning This macro should be used only once per line of code (the line
+ *          number is used to name a hidden static variable).
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT
+ * \see CPPUNIT_REGISTRY_ADD
+ * \see CPPUNIT_TEST_SUITE, CppUnit::AutoRegisterSuite, 
+ *      CppUnit::TestFactoryRegistry..
+ */
+#define CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ATestFixtureType, suiteName ) \
+  static CPPUNIT_NS::AutoRegisterSuite< ATestFixtureType >                   \
+             CPPUNIT_MAKE_UNIQUE_NAME(autoRegisterRegistry__ )(suiteName)
+
+/*! Adds that the specified registry suite to another registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * Use this macros to automatically create test registry suite hierarchy. For example,
+ * if you want to create the following hierarchy:
+ * - Math
+ *   - IntegerMath
+ *   - FloatMath
+ *     - FastFloat
+ *     - StandardFloat
+ * 
+ * You can do this automatically with:
+ * \code
+ * CPPUNIT_REGISTRY_ADD( "FastFloat", "FloatMath" );
+ * CPPUNIT_REGISTRY_ADD( "IntegerMath", "Math" );
+ * CPPUNIT_REGISTRY_ADD( "FloatMath", "Math" );
+ * CPPUNIT_REGISTRY_ADD( "StandardFloat", "FloatMath" );
+ * \endcode
+ *
+ * There is no specific order of declaration. Think of it as declaring links.
+ *
+ * You register the test in each suite using CPPUNIT_TEST_SUITE_NAMED_REGISTRATION.
+ *
+ * \param which Name of the registry suite to add to the registry suite named \a to.
+ * \param to Name of the registry suite \a which is added to.
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION.
+ */
+#define CPPUNIT_REGISTRY_ADD( which, to )                                     \
+  static CPPUNIT_NS::AutoRegisterRegistry                                     \
+             CPPUNIT_MAKE_UNIQUE_NAME( autoRegisterRegistry__ )( which, to )
+
+/*! Adds that the specified registry suite to the default registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro is just like CPPUNIT_REGISTRY_ADD except the specified registry
+ * suite is added to the default suite (root suite).
+ *
+ * \param which Name of the registry suite to add to the default registry suite.
+ * \see CPPUNIT_REGISTRY_ADD.
+ */
+#define CPPUNIT_REGISTRY_ADD_TO_DEFAULT( which )                         \
+  static CPPUNIT_NS::AutoRegisterRegistry                                \
+             CPPUNIT_MAKE_UNIQUE_NAME( autoRegisterRegistry__ )( which )
+
+// Backwards compatibility
+// (Not tested!)
+
+#if CPPUNIT_ENABLE_CU_TEST_MACROS
+
+#define CU_TEST_SUITE(tc) CPPUNIT_TEST_SUITE(tc)
+#define CU_TEST_SUB_SUITE(tc,sc) CPPUNIT_TEST_SUB_SUITE(tc,sc)
+#define CU_TEST(tm) CPPUNIT_TEST(tm)
+#define CU_TEST_SUITE_END() CPPUNIT_TEST_SUITE_END()
+#define CU_TEST_SUITE_REGISTRATION(tc) CPPUNIT_TEST_SUITE_REGISTRATION(tc)
+
+#endif
+
+
+#endif  // CPPUNIT_EXTENSIONS_HELPERMACROS_H

Added: trunk/mingw-libs/include/cppunit/extensions/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,389 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/extensions/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/extensions
+
+libcppunitinclude_HEADERS = \
+	TestFactory.h \
+	AutoRegisterSuite.h \
+	HelperMacros.h \
+	Orthodox.h \
+	RepeatedTest.h \
+	ExceptionTestCaseDecorator.h \
+	TestCaseDecorator.h \
+	TestDecorator.h \
+	TestFactoryRegistry.h \
+	TestFixtureFactory.h \
+	TestNamer.h \
+	TestSetUp.h \
+	TestSuiteBuilderContext.h \
+	TestSuiteFactory.h \
+	TypeInfoHelper.h
+
+subdir = include/cppunit/extensions
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/extensions/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/extensions/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,19 @@
+libcppunitincludedir = $(includedir)/cppunit/extensions
+
+libcppunitinclude_HEADERS = \
+	TestFactory.h \
+	AutoRegisterSuite.h \
+	HelperMacros.h \
+	Orthodox.h \
+	RepeatedTest.h \
+	ExceptionTestCaseDecorator.h \
+	TestCaseDecorator.h \
+	TestDecorator.h \
+	TestFactoryRegistry.h \
+	TestFixtureFactory.h \
+	TestNamer.h \
+	TestSetUp.h \
+	TestSuiteBuilderContext.h \
+	TestSuiteFactory.h \
+	TypeInfoHelper.h
+

Added: trunk/mingw-libs/include/cppunit/extensions/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,389 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/extensions
+
+libcppunitinclude_HEADERS = \
+	TestFactory.h \
+	AutoRegisterSuite.h \
+	HelperMacros.h \
+	Orthodox.h \
+	RepeatedTest.h \
+	ExceptionTestCaseDecorator.h \
+	TestCaseDecorator.h \
+	TestDecorator.h \
+	TestFactoryRegistry.h \
+	TestFixtureFactory.h \
+	TestNamer.h \
+	TestSetUp.h \
+	TestSuiteBuilderContext.h \
+	TestSuiteFactory.h \
+	TypeInfoHelper.h
+
+subdir = include/cppunit/extensions
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/extensions/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/extensions/Orthodox.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/Orthodox.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/Orthodox.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,95 @@
+#ifndef CPPUNIT_EXTENSIONS_ORTHODOX_H
+#define CPPUNIT_EXTENSIONS_ORTHODOX_H
+
+#include <cppunit/TestCase.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*
+ * Orthodox performs a simple set of tests on an arbitary
+ * class to make sure that it supports at least the
+ * following operations:
+ *
+ *      default construction    - constructor
+ *      equality/inequality     - operator== && operator!=
+ *      assignment              - operator=
+ *      negation                - operator!
+ *      safe passage            - copy construction
+ *
+ * If operations for each of these are not declared
+ * the template will not instantiate.  If it does 
+ * instantiate, tests are performed to make sure
+ * that the operations have correct semantics.
+ *      
+ * Adding an orthodox test to a suite is very 
+ * easy: 
+ * 
+ * public: Test *suite ()  {
+ *     TestSuite *suiteOfTests = new TestSuite;
+ *     suiteOfTests->addTest (new ComplexNumberTest ("testAdd");
+ *     suiteOfTests->addTest (new TestCaller<Orthodox<Complex> > ());
+ *     return suiteOfTests;
+ *  }
+ *
+ * Templated test cases be very useful when you are want to
+ * make sure that a group of classes have the same form.
+ *
+ * see TestSuite
+ */
+
+
+template <class ClassUnderTest> class Orthodox : public TestCase
+{
+public:
+                    Orthodox () : TestCase ("Orthodox") {}
+
+protected:
+    ClassUnderTest  call (ClassUnderTest object);
+    void            runTest ();
+
+
+};
+
+
+// Run an orthodoxy test
+template <class ClassUnderTest> void Orthodox<ClassUnderTest>::runTest ()
+{
+    // make sure we have a default constructor
+    ClassUnderTest   a, b, c;
+
+    // make sure we have an equality operator
+    CPPUNIT_ASSERT (a == b);
+
+    // check the inverse
+    b.operator= (a.operator! ());
+    CPPUNIT_ASSERT (a != b);
+
+    // double inversion
+    b = !!a;
+    CPPUNIT_ASSERT (a == b);
+
+    // invert again
+    b = !a;
+
+    // check calls
+    c = a;
+    CPPUNIT_ASSERT (c == call (a));
+
+    c = b;
+    CPPUNIT_ASSERT (c == call (b));
+
+}
+
+
+// Exercise a call
+template <class ClassUnderTest> 
+ClassUnderTest Orthodox<ClassUnderTest>::call (ClassUnderTest object)
+{
+    return object;
+}
+
+
+CPPUNIT_NS_END
+
+#endif

Added: trunk/mingw-libs/include/cppunit/extensions/RepeatedTest.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/RepeatedTest.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/RepeatedTest.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,43 @@
+#ifndef CPPUNIT_EXTENSIONS_REPEATEDTEST_H
+#define CPPUNIT_EXTENSIONS_REPEATEDTEST_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+
+/*! \brief Decorator that runs a test repeatedly.
+ *
+ * Does not assume ownership of the test it decorates
+ */
+class CPPUNIT_API RepeatedTest : public TestDecorator 
+{
+public:
+  RepeatedTest( Test *test, 
+                int timesRepeat ) : 
+      TestDecorator( test ), 
+      m_timesRepeat(timesRepeat) 
+  {
+  }
+
+  void run( TestResult *result );
+
+  int countTestCases() const;
+
+private:
+  RepeatedTest( const RepeatedTest & );
+  void operator=( const RepeatedTest & );
+
+  const int m_timesRepeat;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXTENSIONS_REPEATEDTEST_H

Added: trunk/mingw-libs/include/cppunit/extensions/TestCaseDecorator.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestCaseDecorator.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestCaseDecorator.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,40 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTCASEDECORATOR_H
+#define CPPUNIT_EXTENSIONS_TESTCASEDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/TestCase.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief  Decorator for Test cases.
+ *
+ * TestCaseDecorator provides an alternate means to extend functionality
+ * of a test class without subclassing the test.  Instead, one can
+ * subclass the decorater and use it to wrap the test class.
+ *
+ * Does not assume ownership of the test it decorates
+ */ 
+class CPPUNIT_API TestCaseDecorator : public TestCase
+{
+public:
+  TestCaseDecorator( TestCase *test );
+  ~TestCaseDecorator();
+
+  std::string getName() const;
+
+  void setUp();
+
+  void tearDown();
+
+  void runTest();
+
+protected:
+  TestCase *m_test;
+};
+
+
+CPPUNIT_NS_END
+
+#endif
+

Added: trunk/mingw-libs/include/cppunit/extensions/TestDecorator.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestDecorator.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestDecorator.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,49 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTDECORATOR_H
+#define CPPUNIT_EXTENSIONS_TESTDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Test.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+
+
+/*! \brief  Decorator for Tests.
+ *
+ * TestDecorator provides an alternate means to extend functionality
+ * of a test class without subclassing the test.  Instead, one can
+ * subclass the decorater and use it to wrap the test class.
+ *
+ * Does not assume ownership of the test it decorates
+ */ 
+class CPPUNIT_API TestDecorator : public Test
+{
+public:
+  TestDecorator( Test *test );
+  ~TestDecorator();
+
+  int countTestCases() const;
+
+  std::string getName() const;
+
+  void run( TestResult *result );
+
+  int getChildTestCount() const;
+
+protected:
+  Test *doGetChildTestAt( int index ) const;
+
+  Test *m_test;
+
+private:
+  TestDecorator( const TestDecorator &);
+  void operator =( const TestDecorator & );
+};
+
+
+CPPUNIT_NS_END
+
+#endif
+

Added: trunk/mingw-libs/include/cppunit/extensions/TestFactory.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestFactory.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestFactory.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTFACTORY_H
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+
+/*! \brief Abstract Test factory.
+ */
+class CPPUNIT_API TestFactory 
+{
+public:
+  virtual ~TestFactory() {}
+
+  /*! Makes a new test.
+   * \return A new Test.
+   */
+  virtual Test* makeTest() = 0;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_TESTFACTORY_H

Added: trunk/mingw-libs/include/cppunit/extensions/TestFactoryRegistry.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestFactoryRegistry.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestFactoryRegistry.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,182 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
+#define CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251)  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitSet.h>
+#include <cppunit/extensions/TestFactory.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestSuite;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::set<TestFactory *>;
+#endif
+
+
+/*! \brief Registry for TestFactory.
+ * \ingroup CreatingTestSuite
+ *
+ * Notes that the registry \b DON'T assumes lifetime control for any registered tests
+ * anymore.
+ *
+ * The <em>default</em> registry is the registry returned by getRegistry() with the 
+ * default name parameter value.
+ *
+ * To register tests, use the macros:
+ * - CPPUNIT_TEST_SUITE_REGISTRATION(): to add tests in the default registry.
+ * - CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(): to add tests in a named registry.
+ *
+ * Example 1: retreiving a suite that contains all the test registered with
+ * CPPUNIT_TEST_SUITE_REGISTRATION().
+ * \code
+ * CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
+ * CppUnit::TestSuite *suite = registry.makeTest();
+ * \endcode
+ *
+ * Example 2: retreiving a suite that contains all the test registered with
+ * \link CPPUNIT_TEST_SUITE_NAMED_REGISTRATION() CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Math" )\endlink.
+ * \code
+ * CppUnit::TestFactoryRegistry &mathRegistry = CppUnit::TestFactoryRegistry::getRegistry( "Math" );
+ * CppUnit::TestSuite *mathSuite = mathRegistry.makeTest();
+ * \endcode
+ *
+ * Example 3: creating a test suite hierarchy composed of unnamed registration and
+ * named registration:
+ * - All Tests
+ *   - tests registered with CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Graph" )
+ *   - tests registered with CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Math" )
+ *   - tests registered with CPPUNIT_TEST_SUITE_REGISTRATION
+ *
+ * \code
+ * CppUnit::TestSuite *rootSuite = new CppUnit::TestSuite( "All tests" );
+ * rootSuite->addTest( CppUnit::TestFactoryRegistry::getRegistry( "Graph" ).makeTest() );
+ * rootSuite->addTest( CppUnit::TestFactoryRegistry::getRegistry( "Math" ).makeTest() );
+ * CppUnit::TestFactoryRegistry::getRegistry().addTestToSuite( rootSuite );
+ * \endcode
+ *
+ * The same result can be obtained with:
+ * \code
+ * CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
+ * registry.addRegistry( "Graph" );
+ * registry.addRegistry( "Math" );
+ * CppUnit::TestSuite *suite = registry.makeTest();
+ * \endcode
+ *
+ * Since a TestFactoryRegistry is a TestFactory, the named registries can be 
+ * registered in the unnamed registry, creating the hierarchy links.
+ *
+ * \see TestSuiteFactory, AutoRegisterSuite
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ */
+class CPPUNIT_API TestFactoryRegistry : public TestFactory
+{
+public:
+  /** Constructs the registry with the specified name.
+   * \param name Name of the registry. It is the name of TestSuite returned by
+   *             makeTest().
+   */
+  TestFactoryRegistry( std::string name );
+
+  /// Destructor.
+  virtual ~TestFactoryRegistry();
+
+  /** Returns a new TestSuite that contains the registered test.
+   * \return A new TestSuite which contains all the test added using 
+   * registerFactory(TestFactory *).
+   */
+  virtual Test *makeTest();
+
+  /** Returns a named registry.
+   *
+   * If the \a name is left to its default value, then the registry that is returned is
+   * the one used by CPPUNIT_TEST_SUITE_REGISTRATION(): the 'top' level registry.
+   *
+   * \param name Name of the registry to return.
+   * \return Registry. If the registry does not exist, it is created with the
+   *         specified name.
+   */
+  static TestFactoryRegistry &getRegistry( const std::string &name = "All Tests" );
+
+  /** Adds the registered tests to the specified suite.
+   * \param suite Suite the tests are added to.
+   */
+  void addTestToSuite( TestSuite *suite );
+
+  /** Adds the specified TestFactory to the registry.
+   *
+   * \param factory Factory to register. 
+   */
+  void registerFactory( TestFactory *factory );
+
+  /*! Removes the specified TestFactory from the registry.
+   * 
+   * The specified factory is not destroyed.
+   * \param factory Factory to remove from the registry.
+   * \todo Address case when trying to remove a TestRegistryFactory.
+   */
+  void unregisterFactory( TestFactory *factory );
+
+  /*! Adds a registry to the registry.
+   * 
+   * Convenience method to help create test hierarchy. See TestFactoryRegistry detail
+   * for examples of use. Calling this method is equivalent to:
+   * \code
+   * this->registerFactory( TestFactoryRegistry::getRegistry( name ) );
+   * \endcode
+   *
+   * \param name Name of the registry to add.
+   */
+  void addRegistry( const std::string &name );
+
+  /*! Tests if the registry is valid.
+   *
+   * This method should be used when unregistering test factory on static variable 
+   * destruction to ensure that the registry has not been already destroyed (in 
+   * that case there is no need to unregister the test factory).
+   *
+   * You should not concern yourself with this method unless you are writing a class
+   * like AutoRegisterSuite.
+   *
+   * \return \c true if the specified registry has not been destroyed, 
+   *         otherwise returns \c false.
+   * \see AutoRegisterSuite.
+   */
+  static bool isValid();
+
+  /** Adds the specified TestFactory with a specific name (DEPRECATED).
+   * \param name Name associated to the factory.
+   * \param factory Factory to register. 
+   * \deprecated Use registerFactory( TestFactory *) instead.
+   */
+  void registerFactory( const std::string &name,
+                        TestFactory *factory );
+
+private:
+  TestFactoryRegistry( const TestFactoryRegistry &copy );
+  void operator =( const TestFactoryRegistry &copy );
+
+private:
+  typedef CppUnitSet<TestFactory *, std::less<TestFactory*> > Factories;
+  Factories m_factories;
+
+  std::string m_name;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H

Added: trunk/mingw-libs/include/cppunit/extensions/TestFixtureFactory.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestFixtureFactory.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestFixtureFactory.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,48 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class TestFixture;
+
+/*! \brief Abstract TestFixture factory (Implementation).
+ *
+ * Implementation detail. Use by HelperMacros to handle TestFixture hierarchy.
+ */
+class TestFixtureFactory
+{
+public:
+  //! Creates a new TestFixture instance.
+  virtual TestFixture *makeFixture() =0;
+};
+
+
+/*! \brief Concret TestFixture factory (Implementation).
+ *
+ * Implementation detail. Use by HelperMacros to handle TestFixture hierarchy.
+ */
+template<class TestFixtureType>
+class ConcretTestFixtureFactory : public CPPUNIT_NS::TestFixtureFactory
+{
+  /*! \brief Returns a new TestFixture instance.
+   * \return A new fixture instance. The fixture instance is returned by
+   *         the TestFixtureFactory passed on construction. The actual type 
+   *         is that of the fixture on which the static method suite() 
+   *         was called.
+   */
+  TestFixture *makeFixture()
+  {
+    return new TestFixtureType();
+  }
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+

Added: trunk/mingw-libs/include/cppunit/extensions/TestNamer.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestNamer.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestNamer.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,89 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTNAMER_H
+#define CPPUNIT_EXTENSIONS_TESTNAMER_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+#if CPPUNIT_HAVE_RTTI
+#  include <typeinfo>
+#endif
+
+
+
+/*! \def CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )
+ * \brief Declares a TestNamer.
+ *
+ * Declares a TestNamer for the specified type, using RTTI if enabled, otherwise
+ * using macro string expansion.
+ *
+ * RTTI is used if CPPUNIT_USE_TYPEINFO_NAME is defined and not null.
+ *
+ * \code
+ * void someMethod() 
+ * {
+ *   CPPUNIT_TESTNAMER_DECL( namer, AFixtureType );
+ *   std::string fixtureName = namer.getFixtureName();
+ *   ...
+ * \endcode
+ *
+ * \relates TestNamer
+ * \see TestNamer
+ */
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  define CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )       \
+              CPPUNIT_NS::TestNamer variableName( typeid(FixtureType) )
+#else
+#  define CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )       \
+              CPPUNIT_NS::TestNamer variableName( std::string(#FixtureType) )
+#endif
+
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Names a test or a fixture suite.
+ *
+ * TestNamer is usually instantiated using CPPUNIT_TESTNAMER_DECL.
+ *
+ */
+class CPPUNIT_API TestNamer
+{
+public:
+#if CPPUNIT_HAVE_RTTI
+  /*! \brief Constructs a namer using the fixture's type-info.
+   * \param typeInfo Type-info of the fixture type. Use to name the fixture suite.
+   */
+  TestNamer( const std::type_info &typeInfo );
+#endif
+
+  /*! \brief Constructs a namer using the specified fixture name.
+   * \param fixtureName Name of the fixture suite. Usually extracted using a macro.
+   */
+  TestNamer( const std::string &fixtureName );
+
+  virtual ~TestNamer();
+
+  /*! \brief Returns the name of the fixture.
+   * \return Name of the fixture.
+   */
+  virtual std::string getFixtureName() const;
+
+  /*! \brief Returns the name of the test for the specified method.
+   * \param testMethodName Name of the method that implements a test.
+   * \return A string that is the concatenation of the test fixture name 
+   *         (returned by getFixtureName()) and\a testMethodName, 
+   *         separated using '::'. This provides a fairly unique name for a given
+   *         test.
+   */
+  virtual std::string getTestNameFor( const std::string &testMethodName ) const;
+
+protected:
+  std::string m_fixtureName;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_TESTNAMER_H
+

Added: trunk/mingw-libs/include/cppunit/extensions/TestSetUp.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestSetUp.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestSetUp.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,34 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTSETUP_H
+#define CPPUNIT_EXTENSIONS_TESTSETUP_H
+
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+/*! \brief Decorates a test by providing a specific setUp() and tearDown().
+ */
+class CPPUNIT_API TestSetUp : public TestDecorator 
+{
+public:
+  TestSetUp( Test *test );
+
+  void run( TestResult *result );
+
+protected:
+  virtual void setUp();
+  virtual void tearDown();
+
+private:
+  TestSetUp( const TestSetUp & );
+  void operator =( const TestSetUp & );
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_TESTSETUP_H
+

Added: trunk/mingw-libs/include/cppunit/extensions/TestSuiteBuilderContext.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestSuiteBuilderContext.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestSuiteBuilderContext.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,131 @@
+#ifndef CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+#define CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <string>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+class TestSuite;
+class TestFixture;
+class TestFixtureFactory;
+class TestNamer;
+
+/*! \brief Context used when creating test suite in HelperMacros.
+ *
+ * Base class for all context used when creating test suite. The
+ * actual context type during test suite creation is TestSuiteBuilderContext.
+ *
+ * \sa CPPUNIT_TEST_SUITE, CPPUNIT_TEST_SUITE_ADD_TEST, 
+ *     CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS.
+ */
+class CPPUNIT_API TestSuiteBuilderContextBase
+{
+public:
+  /*! \brief Constructs a new context.
+   *
+   * You should not use this. The context is created in 
+   * CPPUNIT_TEST_SUITE().
+   */
+  TestSuiteBuilderContextBase( TestSuite &suite,
+                               const TestNamer &namer,
+                               TestFixtureFactory &factory );
+
+  virtual ~TestSuiteBuilderContextBase();
+
+  /*! \brief Adds a test to the fixture suite.
+   *
+   * \param test Test to add to the fixture suite. Must not be \c NULL.
+   */
+  void addTest( Test *test );
+
+  /*! \brief Returns the fixture name.
+   * \return Fixture name. It is the name used to name the fixture
+   *         suite.
+   */
+  std::string getFixtureName() const;
+
+  /*! \brief Returns the name of the test for the specified method.
+   *
+   * \param testMethodName Name of the method that implements a test.
+   * \return A string that is the concatenation of the test fixture name 
+   *         (returned by getFixtureName()) and\a testMethodName, 
+   *         separated using '::'. This provides a fairly unique name for a given
+   *         test.
+   */
+  std::string getTestNameFor( const std::string &testMethodName ) const;
+
+  /*! \brief Adds property pair.
+   * \param key   PropertyKey string to add.
+   * \param value PropertyValue string to add.
+   */
+  void addProperty( const std::string &key, 
+                    const std::string &value );
+  
+  /*! \brief Returns property value assigned to param key.
+   * \param key PropertyKey string.
+   */
+  const std::string getStringProperty( const std::string &key ) const;
+
+protected:
+  TestFixture *makeTestFixture() const;
+
+  // Notes: we use a vector here instead of a map to work-around the
+  // shared std::map in dll bug in VC6.
+  // See http://www.dinkumware.com/vc_fixes.html for detail.
+  typedef std::pair<std::string,std::string> Property;
+  typedef CppUnitVector<Property> Properties;
+
+  TestSuite &m_suite;
+  const TestNamer &m_namer;
+  TestFixtureFactory &m_factory;
+
+private:
+  Properties m_properties;
+};
+
+
+/*! \brief Type-sage context used when creating test suite in HelperMacros.
+ * 
+ * \sa TestSuiteBuilderContextBase.
+ */
+template<class Fixture>
+class TestSuiteBuilderContext : public TestSuiteBuilderContextBase
+{
+public:
+  typedef Fixture FixtureType;
+
+  TestSuiteBuilderContext( TestSuiteBuilderContextBase &contextBase )
+      : TestSuiteBuilderContextBase( contextBase )
+  {
+  }
+
+  /*! \brief Returns a new TestFixture instance.
+   * \return A new fixture instance. The fixture instance is returned by
+   *         the TestFixtureFactory passed on construction. The actual type 
+   *         is that of the fixture on which the static method suite() 
+   *         was called.
+   */
+  FixtureType *makeFixture() const
+  {
+    return CPPUNIT_STATIC_CAST( FixtureType *, 
+                                TestSuiteBuilderContextBase::makeTestFixture() );
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+

Added: trunk/mingw-libs/include/cppunit/extensions/TestSuiteFactory.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TestSuiteFactory.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TestSuiteFactory.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
+
+#include <cppunit/extensions/TestFactory.h>
+
+CPPUNIT_NS_BEGIN
+
+
+  class Test;
+
+  /*! \brief TestFactory for TestFixture that implements a static suite() method.
+   * \see AutoRegisterSuite.
+   */
+  template<class TestCaseType>
+  class TestSuiteFactory : public TestFactory
+  {
+  public:
+    virtual Test *makeTest()
+    {
+      return TestCaseType::suite();
+    }
+  };
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H

Added: trunk/mingw-libs/include/cppunit/extensions/TypeInfoHelper.h
===================================================================
--- trunk/mingw-libs/include/cppunit/extensions/TypeInfoHelper.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/extensions/TypeInfoHelper.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,32 @@
+#ifndef CPPUNIT_TYPEINFOHELPER_H
+#define CPPUNIT_TYPEINFOHELPER_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_HAVE_RTTI
+
+#include <typeinfo>
+
+CPPUNIT_NS_BEGIN
+
+
+  /**! \brief Helper to use type_info.
+   */
+  class CPPUNIT_API TypeInfoHelper
+  {
+  public:
+    /*! \brief Get the class name of the specified type_info.
+     * \param info Info which the class name is extracted from.
+     * \return The string returned by type_info::name() without
+     *         the "class" prefix. If the name is not prefixed
+     *         by "class", it is returned as this.
+     */
+    static std::string getClassName( const std::type_info &info );
+  };
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_HAVE_RTTI
+
+#endif  // CPPUNIT_TYPEINFOHELPER_H

Added: trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManager.h
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManager.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManager.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,120 @@
+#ifndef CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
+#define CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Manages dynamic libraries.
+ *
+ * The Dynamic Library Manager provides a platform independent way to work with
+ * dynamic library. It load a specific dynamic library, and can returns specific
+ * symbol exported by the dynamic library.
+ *
+ * If an error occurs, a DynamicLibraryManagerException is thrown.
+ *
+ * \internal Implementation of the OS independent methods is in 
+ * DynamicLibraryManager.cpp.
+ *
+ * \internal Porting to a new platform:
+ * - Adds platform detection in config/SelectDllLoader.h. Should define a specific
+ *   macro for that platform of the form: CPPUNIT_HAVE_XYZ_DLL_LOADER, where
+ *   XYZ is the platform.
+ * - Makes a copy of UnixDynamicLibraryManager.cpp and named it after the platform.
+ * - Updated the 'guard' in your file (CPPUNIT_HAVE_XYZ_DLL_LOADER) so that it is
+ *   only processed if the matching platform has been detected.
+ * - Change the implementation of methods doLoadLibrary(), doReleaseLibrary(), 
+ *   doFindSymbol() in your copy. Those methods usually maps directly to OS calls.
+ * - Adds the file to the project.
+ */
+class DynamicLibraryManager
+{
+public:
+  typedef void *Symbol;
+  typedef void *LibraryHandle;
+
+  /*! \brief Loads the specified library.
+   * \param libraryFileName Name of the library to load.
+   * \exception DynamicLibraryManagerException if a failure occurs while loading
+   *            the library (fail to found or load the library).
+   */
+  DynamicLibraryManager( const std::string &libraryFileName );
+
+  /// Releases the loaded library..
+  ~DynamicLibraryManager();
+
+  /*! \brief Returns a pointer on the specified symbol exported by the library.
+   * \param symbol Name of the symbol exported by the library.
+   * \return Pointer on the symbol. Should be casted to the actual type. Never \c NULL.
+   * \exception DynamicLibraryManagerException if the symbol is not found.
+   */
+  Symbol findSymbol( const std::string &symbol );
+
+private:
+  /*! Loads the specified library.
+   * \param libraryName Name of the library to load.
+   * \exception DynamicLibraryManagerException if a failure occurs while loading
+   *            the library (fail to found or load the library).
+   */
+  void loadLibrary( const std::string &libraryName );
+
+  /*! Releases the loaded library.
+   * 
+   * \warning Must NOT throw any exceptions (called from destructor).
+   */
+  void releaseLibrary();
+
+  /*! Loads the specified library.
+   * 
+   * May throw any exceptions (indicates failure).
+   * \param libraryName Name of the library to load.
+   * \return Handle of the loaded library. \c NULL indicates failure.
+   */
+  LibraryHandle doLoadLibrary( const std::string &libraryName );
+
+  /*! Releases the loaded library.
+   *
+   * The handle of the library to free is in \c m_libraryHandle. It is never
+   * \c NULL.
+   * \warning Must NOT throw any exceptions (called from destructor).
+   */
+  void doReleaseLibrary();
+
+  /*! Returns a pointer on the specified symbol exported by the library.
+   * 
+   * May throw any exceptions (indicates failure).
+   * \param symbol Name of the symbol exported by the library.
+   * \return Pointer on the symbol. \c NULL indicates failure.
+   */
+  Symbol doFindSymbol( const std::string &symbol );
+
+  /*! Returns detailed information about doLoadLibrary() failure.
+   *
+   * Called just after a failed call to doLoadLibrary() to get extra
+   * error information.
+   *
+   * \return Detailed information about the failure of the call to
+   *         doLoadLibrary() that just failed.
+   */
+  std::string getLastErrorDetail() const;
+
+  /// Prevents the use of the copy constructor.
+  DynamicLibraryManager( const DynamicLibraryManager &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const DynamicLibraryManager &copy );
+
+private:
+  LibraryHandle m_libraryHandle;
+  std::string m_libraryName;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif  // CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H

Added: trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManagerException.h
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManagerException.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/DynamicLibraryManagerException.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,53 @@
+#ifndef CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
+#define CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+#include <stdexcept>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Exception thrown by DynamicLibraryManager when a failure occurs.
+ *
+ * Use getCause() to know what function caused the failure.
+ *
+ */
+class DynamicLibraryManagerException : public std::runtime_error
+{
+public:
+  enum Cause
+  {
+    /// Failed to load the dynamic library
+    loadingFailed =0,
+    /// Symbol not found in the dynamic library
+    symbolNotFound
+  };
+
+  /// Failed to load the dynamic library or Symbol not found in the dynamic library.
+  DynamicLibraryManagerException( const std::string &libraryName,
+                                  const std::string &errorDetail,
+                                  Cause cause );
+
+  ~DynamicLibraryManagerException() throw()
+  {
+  }
+
+  Cause getCause() const;
+
+  const char *what() const throw();
+
+private:
+  std::string m_message;
+  Cause m_cause;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif  // CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H

Added: trunk/mingw-libs/include/cppunit/plugin/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,380 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/plugin/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/plugin
+
+libcppunitinclude_HEADERS = \
+	DynamicLibraryManager.h \
+	DynamicLibraryManagerException.h \
+	TestPlugIn.h \
+	TestPlugInDefaultImpl.h \
+	PlugInManager.h \
+	PlugInParameters.h
+
+subdir = include/cppunit/plugin
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/plugin/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/plugin/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,9 @@
+libcppunitincludedir = $(includedir)/cppunit/plugin
+
+libcppunitinclude_HEADERS = \
+	DynamicLibraryManager.h \
+	DynamicLibraryManagerException.h \
+	TestPlugIn.h \
+	TestPlugInDefaultImpl.h \
+	PlugInManager.h \
+	PlugInParameters.h

Added: trunk/mingw-libs/include/cppunit/plugin/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,380 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/plugin
+
+libcppunitinclude_HEADERS = \
+	DynamicLibraryManager.h \
+	DynamicLibraryManagerException.h \
+	TestPlugIn.h \
+	TestPlugInDefaultImpl.h \
+	PlugInManager.h \
+	PlugInParameters.h
+
+subdir = include/cppunit/plugin
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/plugin/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/plugin/PlugInManager.h
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/PlugInManager.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/PlugInManager.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,113 @@
+#ifndef CPPUNIT_PLUGIN_PLUGINMANAGER_H
+#define CPPUNIT_PLUGIN_PLUGINMANAGER_H
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/plugin/PlugInParameters.h>
+struct CppUnitTestPlugIn;
+
+CPPUNIT_NS_BEGIN
+
+
+class DynamicLibraryManager;
+class TestResult;
+class XmlOutputter;
+
+
+/*! \brief Manges TestPlugIn.
+ */
+class CPPUNIT_API PlugInManager
+{
+public:
+  /*! Constructs a PlugInManager object.
+   */
+  PlugInManager();
+
+  /// Destructor.
+  virtual ~PlugInManager();
+
+  /*! \brief Loads the specified plug-in.
+   *
+   * After being loaded, the CppUnitTestPlugIn::initialize() is called.
+   *
+   * \param libraryFileName Name of the file that contains the TestPlugIn.
+   * \param parameters List of string passed to the plug-in.
+   * \return Pointer on the DynamicLibraryManager associated to the library.
+   *         Valid until the library is unloaded. Never \c NULL.
+   * \exception DynamicLibraryManager is thrown if an error occurs during loading.
+   */
+  void load( const std::string &libraryFileName,
+             const PlugInParameters &parameters = PlugInParameters() );
+
+  /*! \brief Unloads the specified plug-in.
+   * \param libraryFileName Name of the file that contains the TestPlugIn passed
+   *                        to a previous call to load().
+   */
+  void unload( const std::string &libraryFileName );
+
+  /*! \brief Gives a chance to each loaded plug-in to register TestListener.
+   *
+   * For each plug-in, call CppUnitTestPlugIn::addListener().
+   */
+  void addListener( TestResult *eventManager );
+
+  /*! \brief Gives a chance to each loaded plug-in to unregister TestListener.
+   * For each plug-in, call CppUnitTestPlugIn::removeListener().
+   */
+  void removeListener( TestResult *eventManager );
+
+  /*! \brief Provides a way for the plug-in to register some XmlOutputterHook.
+   */
+  void addXmlOutputterHooks( XmlOutputter *outputter );
+
+  /*! \brief Called when the XmlOutputter is destroyed.
+   * 
+   * Can be used to free some resources allocated by addXmlOutputterHooks().
+   */
+  void removeXmlOutputterHooks();
+
+protected:
+  /*! \brief (INTERNAL) Information about a specific plug-in.
+   */
+  struct PlugInInfo
+  {
+    std::string m_fileName;
+    DynamicLibraryManager *m_manager;
+    CppUnitTestPlugIn *m_interface;
+  };
+
+  /*! Unloads the specified plug-in.
+   * \param plugIn Information about the plug-in.
+   */
+  void unload( PlugInInfo &plugIn );
+
+private:
+  /// Prevents the use of the copy constructor.
+  PlugInManager( const PlugInManager &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const PlugInManager &copy );
+
+private:
+  typedef CppUnitDeque<PlugInInfo> PlugIns;
+  PlugIns m_plugIns;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif  // CPPUNIT_PLUGIN_PLUGINMANAGER_H

Added: trunk/mingw-libs/include/cppunit/plugin/PlugInParameters.h
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/PlugInParameters.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/PlugInParameters.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,36 @@
+#ifndef CPPUNIT_PLUGIN_PARAMETERS
+#define CPPUNIT_PLUGIN_PARAMETERS
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Test plug-ins parameters.
+ */
+class CPPUNIT_API PlugInParameters
+{
+public:
+  /// Constructs plug-in parameters from the specified command-line.
+  PlugInParameters( const std::string &commandLine = "" );
+
+  virtual ~PlugInParameters();
+
+  /// Returns the command line that was passed on construction.
+  std::string getCommandLine() const;
+
+private:
+  std::string m_commandLine;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif // CPPUNIT_PLUGIN_PARAMETERS

Added: trunk/mingw-libs/include/cppunit/plugin/TestPlugIn.h
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/TestPlugIn.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/TestPlugIn.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,198 @@
+#ifndef CPPUNIT_PLUGIN_TESTPLUGIN
+#define CPPUNIT_PLUGIN_TESTPLUGIN
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/plugin/PlugInParameters.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFactoryRegistry;
+class TestResult;
+class XmlOutputter;
+
+CPPUNIT_NS_END
+
+/*! \file
+ */
+
+
+/*! \brief Test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * This class define the interface implemented by test plug-in. A pointer to that
+ * interface is returned by the function exported by the test plug-in.
+ *
+ * Plug-in are loaded/unloaded by PlugInManager. When a plug-in is loaded, 
+ * initialize() is called. Before unloading the plug-in, the PlugInManager
+ * call uninitialize().
+ *
+ * addListener() and removeListener() are called respectively before and after
+ * the test run.
+ *
+ * addXmlOutputterHooks() and removeXmlOutputterHooks() are called respectively
+ * before and after writing the XML output using a XmlOutputter.
+ *
+ * \see CPPUNIT_PLUGIN_IMPLEMENT, CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL
+ * \see CppUnit::TestPlugInDefaultImpl, CppUnit::XmlOutputter.
+ */
+struct CppUnitTestPlugIn
+{
+  /*! \brief Called just after loading the dynamic library. 
+   *
+   * Override this method to add additional suite to the registry, though this
+   * is preferably done using the macros (CPPUNIT_TEST_SUITE_REGISTRATION...).
+   * If you are creating a custom listener to extends the plug-in runner,
+   * you can use this to configure the listener using the \a parameters.
+   *
+   * You could also use the parameters to specify some global parameter, such
+   * as test datas location, database name...
+   *
+   * N.B.: Parameters interface is not define yet, and the plug-in runner does
+   * not yet support plug-in parameter.
+   */
+  virtual void initialize( CPPUNIT_NS::TestFactoryRegistry *registry,
+                           const CPPUNIT_NS::PlugInParameters &parameters ) =0;
+
+  /*! \brief Gives a chance to the plug-in to register TestListener.
+   * 
+   * Override this method to add a TestListener for the test run. This is useful
+   * if you are writing a custom TestListener, but also if you need to
+   * setUp some global resource: listen to TestListener::startTestRun(), 
+   * and TestListener::endTestRun().
+   */
+  virtual void addListener( CPPUNIT_NS::TestResult *eventManager ) =0;
+
+  /*! \brief Gives a chance to the plug-in to remove its registered TestListener.
+   *
+   * Override this method to remove a TestListener that has been added.
+   */
+  virtual void removeListener( CPPUNIT_NS::TestResult *eventManager ) =0;
+
+  /*! \brief Provides a way for the plug-in to register some XmlOutputterHook.
+   */
+  virtual void addXmlOutputterHooks( CPPUNIT_NS::XmlOutputter *outputter ) =0;
+
+  /*! \brief Called when the XmlOutputter is destroyed.
+   * 
+   * Can be used to free some resources allocated by addXmlOutputterHooks().
+   */
+  virtual void removeXmlOutputterHooks() = 0;
+
+  /*! \brief Called just before unloading the dynamic library.
+   * 
+   * Override this method to unregister test factory added in initialize().
+   * This is necessary to keep the TestFactoryRegistry 'clean'. When
+   * the plug-in is unloaded from memory, the TestFactoryRegistry will hold
+   * reference on test that are no longer available if they are not 
+   * unregistered.
+   */
+  virtual void uninitialize( CPPUNIT_NS::TestFactoryRegistry *registry ) =0;
+};
+
+
+
+/*! \brief Name of the function exported by a test plug-in.
+ * \ingroup WritingTestPlugIn
+ *
+ * The signature of the exported function is:
+ * \code
+ * CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void);
+ * \endif
+ */
+#define CPPUNIT_PLUGIN_EXPORTED_NAME cppunitTestPlugIn
+
+/*! \brief Type of the function exported by a plug-in.
+ * \ingroup WritingTestPlugIn
+ */
+typedef CppUnitTestPlugIn *(*TestPlugInSignature)();
+
+
+/*! \brief Implements the function exported by the test plug-in
+ * \ingroup WritingTestPlugIn
+ */
+#define CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL( TestPlugInInterfaceType )       \
+  CPPUNIT_PLUGIN_EXPORT CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void)  \
+  {                                                                            \
+    static TestPlugInInterfaceType plugIn;                                     \
+    return &plugIn;                                                            \
+  }                                                                            \
+  typedef char __CppUnitPlugInExportFunctionDummyTypeDef  // dummy typedef so it can end with ';'
+
+
+// Note: This include should remain after definition of CppUnitTestPlugIn
+#include <cppunit/plugin/TestPlugInDefaultImpl.h>
+
+
+/*! \def CPPUNIT_PLUGIN_IMPLEMENT_MAIN()
+ * \brief Implements the 'main' function for the plug-in.
+ *
+ * This macros implements the main() function for dynamic library.
+ * For example, WIN32 requires a DllMain function, while some Unix 
+ * requires a main() function. This macros takes care of the implementation.
+ */
+
+// Win32
+#if defined(CPPUNIT_HAVE_WIN32_DLL_LOADER)
+#if !defined(APIENTRY)
+#define WIN32_LEAN_AND_MEAN 
+#define NOGDI
+#define NOUSER
+#define NOKERNEL
+#define NOSOUND
+#define NOMINMAX
+#define BLENDFUNCTION void    // for mingw & gcc
+#include <windows.h>
+#endif
+#define CPPUNIT_PLUGIN_IMPLEMENT_MAIN()               \
+  BOOL APIENTRY DllMain( HANDLE hModule,              \
+                         DWORD  ul_reason_for_call,   \
+                         LPVOID lpReserved )          \
+  {                                                   \
+      return TRUE;                                    \
+  }                                                   \
+  typedef char __CppUnitPlugInImplementMainDummyTypeDef
+
+// Unix
+#elif defined(CPPUNIT_HAVE_UNIX_DLL_LOADER) || defined(CPPUNIT_HAVE_UNIX_SHL_LOADER)
+#define CPPUNIT_PLUGIN_IMPLEMENT_MAIN()               \
+  int main( int argc, char *argv[] )                  \
+  {                                                   \
+    return 0;                                         \
+  }                                                   \
+  typedef char __CppUnitPlugInImplementMainDummyTypeDef
+
+
+// Other
+#else     // other platforms don't require anything specifics
+#endif
+
+
+
+/*! \brief Implements and exports the test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * This macro exports the test plug-in function using the subclass, 
+ * and implements the 'main' function for the plug-in using 
+ * CPPUNIT_PLUGIN_IMPLEMENT_MAIN().
+ *
+ * When using this macro, CppUnit must be linked as a DLL (shared library).
+ * Otherwise, tests registered to the TestFactoryRegistry in the DLL will 
+ * not be visible to the DllPlugInTester.
+ *
+ * \see CppUnitTestPlugIn
+ * \see CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL(), CPPUNIT_PLUGIN_IMPLEMENT_MAIN().
+ */
+#define CPPUNIT_PLUGIN_IMPLEMENT()                                          \
+  CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL( CPPUNIT_NS::TestPlugInDefaultImpl );  \
+  CPPUNIT_PLUGIN_IMPLEMENT_MAIN()
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif // CPPUNIT_PLUGIN_TESTPLUGIN

Added: trunk/mingw-libs/include/cppunit/plugin/TestPlugInDefaultImpl.h
===================================================================
--- trunk/mingw-libs/include/cppunit/plugin/TestPlugInDefaultImpl.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/plugin/TestPlugInDefaultImpl.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,52 @@
+#ifndef CPPUNIT_PLUGIN_TESTPLUGINADAPTER
+#define CPPUNIT_PLUGIN_TESTPLUGINADAPTER
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/plugin/TestPlugIn.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestSuite;
+
+
+/*! \brief Default implementation of test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * Override getSuiteName() to specify the suite name. Default is "All Tests".
+ *
+ * CppUnitTestPlugIn::::getTestSuite() returns a suite that contains
+ * all the test registered to the default test factory registry 
+ * ( TestFactoryRegistry::getRegistry() ).
+ *
+ */
+class CPPUNIT_API TestPlugInDefaultImpl : public CppUnitTestPlugIn
+{
+public:
+  TestPlugInDefaultImpl();
+
+  virtual ~TestPlugInDefaultImpl();
+
+  void initialize( TestFactoryRegistry *registry,
+                   const PlugInParameters &parameters );
+
+  void addListener( TestResult *eventManager );
+
+  void removeListener( TestResult *eventManager );
+
+  void addXmlOutputterHooks( XmlOutputter *outputter );
+
+  void removeXmlOutputterHooks();
+
+  void uninitialize( TestFactoryRegistry *registry );
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif // CPPUNIT_PLUGIN_TESTPLUGINADAPTER

Added: trunk/mingw-libs/include/cppunit/portability/CppUnitDeque.h
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/CppUnitDeque.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/CppUnitDeque.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,25 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+#define CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <deque>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitDeque : public std::deque<T,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitDeque std::deque
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+

Added: trunk/mingw-libs/include/cppunit/portability/CppUnitMap.h
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/CppUnitMap.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/CppUnitMap.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,29 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITMAP_H
+#define CPPUNIT_PORTABILITY_CPPUNITMAP_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <functional>
+#include <map>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class Key, class T>
+class CppUnitMap : public std::map<Key
+                                  ,T
+                                  ,std::less<Key>
+                                  ,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitMap std::map
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITMAP_H
+

Added: trunk/mingw-libs/include/cppunit/portability/CppUnitSet.h
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/CppUnitSet.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/CppUnitSet.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,28 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITSET_H
+#define CPPUNIT_PORTABILITY_CPPUNITSET_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <functional>
+#include <set>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitSet : public std::set<T
+                                  ,std::less<T>
+                                  ,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitSet std::set
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITSET_H
+

Added: trunk/mingw-libs/include/cppunit/portability/CppUnitStack.h
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/CppUnitStack.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/CppUnitStack.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,26 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITSTACK_H
+#define CPPUNIT_PORTABILITY_CPPUNITSTACK_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <deque>
+#include <stack>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitStack : public std::stack<T
+                                      ,std::deque<T,CPPUNIT_STD_ALLOCATOR> >
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitStack std::stack
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITSTACK_H
\ No newline at end of file

Added: trunk/mingw-libs/include/cppunit/portability/CppUnitVector.h
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/CppUnitVector.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/CppUnitVector.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,25 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+#define CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+
+// The technic used is similar to the wrapper of STLPort.
+ 
+#include <cppunit/Portability.h>
+#include <vector>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitVector : public std::vector<T,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitVector std::vector
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+

Added: trunk/mingw-libs/include/cppunit/portability/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,379 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/portability/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/portability
+
+libcppunitinclude_HEADERS = \
+	CppUnitDeque.h \
+	CppUnitMap.h \
+	CppUnitSet.h \
+	CppUnitStack.h \
+	CppUnitVector.h
+
+subdir = include/cppunit/portability
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/portability/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/portability/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,8 @@
+libcppunitincludedir = $(includedir)/cppunit/portability
+
+libcppunitinclude_HEADERS = \
+	CppUnitDeque.h \
+	CppUnitMap.h \
+	CppUnitSet.h \
+	CppUnitStack.h \
+	CppUnitVector.h

Added: trunk/mingw-libs/include/cppunit/portability/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/portability/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/portability/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,379 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/portability
+
+libcppunitinclude_HEADERS = \
+	CppUnitDeque.h \
+	CppUnitMap.h \
+	CppUnitSet.h \
+	CppUnitStack.h \
+	CppUnitVector.h
+
+subdir = include/cppunit/portability
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/portability/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/tools/Algorithm.h
===================================================================
--- trunk/mingw-libs/include/cppunit/tools/Algorithm.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/tools/Algorithm.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,23 @@
+#ifndef CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
+#define CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+template<class SequenceType, class ValueType>
+void
+removeFromSequence( SequenceType &sequence, 
+                    const ValueType &valueToRemove )
+{
+   for ( unsigned int index =0; index < sequence.size(); ++index )
+   {
+      if ( sequence[ index ] == valueToRemove )
+         sequence.erase( sequence.begin() + index );
+   }
+}
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED

Added: trunk/mingw-libs/include/cppunit/tools/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/tools/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/tools/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,378 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/tools/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/tools
+
+libcppunitinclude_HEADERS = \
+	Algorithm.h		\
+	StringTools.h \
+	XmlElement.h \
+	XmlDocument.h
+
+subdir = include/cppunit/tools
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/tools/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/tools/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/tools/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/tools/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,7 @@
+libcppunitincludedir = $(includedir)/cppunit/tools
+
+libcppunitinclude_HEADERS = \
+	Algorithm.h		\
+	StringTools.h \
+	XmlElement.h \
+	XmlDocument.h
\ No newline at end of file

Added: trunk/mingw-libs/include/cppunit/tools/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/tools/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/tools/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,378 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/tools
+
+libcppunitinclude_HEADERS = \
+	Algorithm.h		\
+	StringTools.h \
+	XmlElement.h \
+	XmlDocument.h
+
+subdir = include/cppunit/tools
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/tools/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/tools/StringTools.h
===================================================================
--- trunk/mingw-libs/include/cppunit/tools/StringTools.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/tools/StringTools.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,34 @@
+#ifndef CPPUNIT_TOOLS_STRINGTOOLS_H
+#define CPPUNIT_TOOLS_STRINGTOOLS_H
+
+#include <cppunit/Portability.h>
+#include <string>
+#include <cppunit/portability/CppUnitVector.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Tool functions to manipulate string.
+ */
+struct StringTools
+{
+
+  typedef CppUnitVector<std::string> Strings;
+
+  static std::string CPPUNIT_API toString( int value );
+
+  static std::string CPPUNIT_API toString( double value );
+
+  static Strings CPPUNIT_API split( const std::string &text, 
+                                    char separator );
+
+  static std::string CPPUNIT_API wrap( const std::string &text,
+                                       int wrapColumn = CPPUNIT_WRAP_COLUMN );
+
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TOOLS_STRINGTOOLS_H

Added: trunk/mingw-libs/include/cppunit/tools/XmlDocument.h
===================================================================
--- trunk/mingw-libs/include/cppunit/tools/XmlDocument.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/tools/XmlDocument.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,71 @@
+#ifndef CPPUNIT_TOOLS_XMLDOCUMENT_H
+#define CPPUNIT_TOOLS_XMLDOCUMENT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class XmlElement;
+
+
+/*! \brief A XML Document.
+ *
+ * A XmlDocument represents a XML file. It holds a pointer on the root XmlElement
+ * of the document. It also holds the encoding and style sheet used.
+ */
+class CPPUNIT_API XmlDocument
+{
+public:
+  /*! \brief Constructs a XmlDocument object.
+   * \param encoding Encoding used in the XML file (default is Latin-1, ISO-8859-1 ). 
+   * \param styleSheet Name of the XSL style sheet file used. If empty then no
+   *                   style sheet will be specified in the output.
+   */
+  XmlDocument( const std::string &encoding = "",
+               const std::string &styleSheet = "" );
+
+  /// Destructor.
+  virtual ~XmlDocument();
+
+  std::string encoding() const;
+  void setEncoding( const std::string &encoding = "" );
+  
+  std::string styleSheet() const;
+  void setStyleSheet( const std::string &styleSheet = "" );
+
+  void setRootElement( XmlElement *rootElement );
+  XmlElement &rootElement() const;
+
+  std::string toString() const;
+
+private:
+  /// Prevents the use of the copy constructor.
+  XmlDocument( const XmlDocument &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const XmlDocument &copy );
+
+protected:
+  std::string m_encoding;
+  std::string m_styleSheet;
+  XmlElement *m_rootElement;
+};
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TOOLS_XMLDOCUMENT_H

Added: trunk/mingw-libs/include/cppunit/tools/XmlElement.h
===================================================================
--- trunk/mingw-libs/include/cppunit/tools/XmlElement.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/tools/XmlElement.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,149 @@
+#ifndef CPPUNIT_TOOLS_XMLELEMENT_H
+#define CPPUNIT_TOOLS_XMLELEMENT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class XmlElement;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<XmlElement *>;
+#endif
+
+
+/*! \brief A XML Element.
+ * 
+ * A XML element has:
+ * - a name, specified on construction,
+ * - a content, specified on construction (may be empty),
+ * - zero or more attributes, added with addAttribute(),
+ * - zero or more child elements, added with addElement().
+ */
+class CPPUNIT_API XmlElement
+{
+public:
+  /*! \brief Constructs an element with the specified name and string content.
+   * \param elementName Name of the element. Must not be empty.
+   * \param content Content of the element.
+   */
+  XmlElement( std::string elementName,
+              std::string content ="" );
+
+  /*! \brief Constructs an element with the specified name and numeric content.
+   * \param elementName Name of the element. Must not be empty.
+   * \param numericContent Content of the element.
+   */
+  XmlElement( std::string elementName,
+              int numericContent );
+
+  /*! \brief Destructs the element and its child elements.
+   */
+  virtual ~XmlElement();
+
+  /*! \brief Returns the name of the element.
+   * \return Name of the element.
+   */
+  std::string name() const;
+
+  /*! \brief Returns the content of the element.
+   * \return Content of the element.
+   */
+  std::string content() const;
+
+  /*! \brief Sets the name of the element.
+   * \param name New name for the element.
+   */
+  void setName( const std::string &name );
+
+  /*! \brief Sets the content of the element.
+   * \param content New content for the element.
+   */
+  void setContent( const std::string &content );
+
+  /*! \overload void setContent( const std::string &content )
+   */
+  void setContent( int numericContent );
+
+  /*! \brief Adds an attribute with the specified string value.
+   * \param attributeName Name of the attribute. Must not be an empty.
+   * \param value Value of the attribute.
+   */
+  void addAttribute( std::string attributeName,
+                     std::string value );
+
+  /*! \brief Adds an attribute with the specified numeric value.
+   * \param attributeName Name of the attribute. Must not be empty.
+   * \param numericValue Numeric value of the attribute.
+   */
+  void addAttribute( std::string attributeName,
+                     int numericValue );
+
+  /*! \brief Adds a child element to the element.
+   * \param element Child element to add. Must not be \c NULL.
+   */
+  void addElement( XmlElement *element );
+
+  /*! \brief Returns the number of child elements.
+   * \return Number of child elements (element added with addElement()).
+   */
+  int elementCount() const;
+
+  /*! \brief Returns the child element at the specified index.
+   * \param index Zero based index of the element to return.
+   * \returns Element at the specified index. Never \c NULL.
+   * \exception std::invalid_argument if \a index < 0 or index >= elementCount().
+   */
+  XmlElement *elementAt( int index ) const;
+
+  /*! \brief Returns the first child element with the specified name.
+   * \param name Name of the child element to return.
+   * \return First child element found which is named \a name.
+   * \exception std::invalid_argument if there is no child element with the specified
+   *            name.
+   */
+  XmlElement *elementFor( const std::string &name ) const;
+
+  /*! \brief Returns a XML string that represents the element.
+   * \param indent String of spaces representing the amount of 'indent'.
+   * \return XML string that represents the element, its attributes and its
+   *         child elements.
+   */
+  std::string toString( const std::string &indent = "" ) const;
+
+private:
+  typedef std::pair<std::string,std::string> Attribute;
+
+  std::string attributesAsString() const;
+  std::string escape( std::string value ) const;
+
+private:
+  std::string m_name;
+  std::string m_content;
+
+  typedef CppUnitDeque<Attribute> Attributes;
+  Attributes m_attributes;
+
+  typedef CppUnitDeque<XmlElement *> Elements;
+  Elements m_elements;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_TOOLS_XMLELEMENT_H

Added: trunk/mingw-libs/include/cppunit/ui/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,448 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/ui/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+SUBDIRS = text mfc qt
+subdir = include/cppunit/ui
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+
+RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
+	ps-recursive install-info-recursive uninstall-info-recursive \
+	all-recursive install-data-recursive install-exec-recursive \
+	installdirs-recursive install-recursive uninstall-recursive \
+	check-recursive installcheck-recursive
+DIST_COMMON = Makefile.am Makefile.in
+DIST_SUBDIRS = $(SUBDIRS)
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if (etags --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	else \
+	  include_option=--include; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$(top_distdir)" \
+	        distdir=../$(distdir)/$$subdir \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
+	clean-generic clean-libtool clean-recursive ctags \
+	ctags-recursive distclean distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-data install-data-am install-data-recursive \
+	install-exec install-exec-am install-exec-recursive \
+	install-info install-info-am install-info-recursive install-man \
+	install-recursive install-strip installcheck installcheck-am \
+	installdirs installdirs-am installdirs-recursive \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-generic \
+	mostlyclean-libtool mostlyclean-recursive pdf pdf-am \
+	pdf-recursive ps ps-am ps-recursive tags tags-recursive \
+	uninstall uninstall-am uninstall-info-am \
+	uninstall-info-recursive uninstall-recursive
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1 @@
+SUBDIRS = text mfc qt

Added: trunk/mingw-libs/include/cppunit/ui/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,448 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+SUBDIRS = text mfc qt
+subdir = include/cppunit/ui
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+
+RECURSIVE_TARGETS = info-recursive dvi-recursive pdf-recursive \
+	ps-recursive install-info-recursive uninstall-info-recursive \
+	all-recursive install-data-recursive install-exec-recursive \
+	installdirs-recursive install-recursive uninstall-recursive \
+	check-recursive installcheck-recursive
+DIST_COMMON = Makefile.am Makefile.in
+DIST_SUBDIRS = $(SUBDIRS)
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if (etags --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	else \
+	  include_option=--include; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$(top_distdir)" \
+	        distdir=../$(distdir)/$$subdir \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
+	clean-generic clean-libtool clean-recursive ctags \
+	ctags-recursive distclean distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-data install-data-am install-data-recursive \
+	install-exec install-exec-am install-exec-recursive \
+	install-info install-info-am install-info-recursive install-man \
+	install-recursive install-strip installcheck installcheck-am \
+	installdirs installdirs-am installdirs-recursive \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-generic \
+	mostlyclean-libtool mostlyclean-recursive pdf pdf-am \
+	pdf-recursive ps ps-am ps-recursive tags tags-recursive \
+	uninstall uninstall-am uninstall-info-am \
+	uninstall-info-recursive uninstall-recursive
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/mfc/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/mfc/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/mfc/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,376 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/ui/mfc/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/ui/mfc
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  MfcTestRunner.h
+
+subdir = include/cppunit/ui/mfc
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/mfc/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,5 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/mfc
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  MfcTestRunner.h

Added: trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/mfc/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,376 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/ui/mfc
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  MfcTestRunner.h
+
+subdir = include/cppunit/ui/mfc
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/mfc/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/mfc/MfcTestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/mfc/MfcTestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/mfc/MfcTestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,76 @@
+#ifndef CPPUNITUI_MFC_MFCTESTRUNNER_H
+#define CPPUNITUI_MFC_MFCTESTRUNNER_H
+
+#if _MSC_VER >= 1000
+#pragma once
+#endif // _MSC_VER >= 1000
+
+#include <cppunit/Portability.h>
+#include <cppunit/portability/CppUnitVector.h>
+
+/* Refer to MSDN documentation to know how to write and use MFC extension DLL:
+   mk:@MSITStore:h:\DevStudio\MSDN\98VSa\1036\vcmfc.chm::/html/_mfcnotes_tn033.htm#_mfcnotes_how_to_write_an_mfc_extension_dll
+   
+   This can be found in the index with "mfc extension"
+   The basic:
+   Using:
+   - your application must use MFC DLL
+   - memory allocation is done using the same heap
+   - you must define the symbol _AFX_DLL
+
+   Building:
+   - you must define the symbol _AFX_DLL and _AFX_EXT
+   - export class using AFX_EXT_CLASS
+ */
+
+CPPUNIT_NS_BEGIN
+
+  class Test;
+  class TestSuite;
+
+
+/*! \brief MFC test runner.
+ * \ingroup ExecutingTest
+ *
+ * Use this to launch the MFC TestRunner. Usually called from you CWinApp subclass:
+ *
+ * \code
+ * #include <cppunit/ui/mfc/MfcTestRunner.h>
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ *
+ * void 
+ * CHostAppApp::RunUnitTests()
+ * {
+ *   CppUnit::MfcTestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );
+ *
+ *   runner.run();    
+ * }
+ * \endcode
+ * \see CppUnit::TextTestRunner, CppUnit::TestFactoryRegistry.
+ */
+class AFX_EXT_CLASS MfcTestRunner
+{
+public:
+  MfcTestRunner();
+  virtual ~MfcTestRunner();
+
+  void run();
+
+  void addTest( Test *test );
+
+  void addTests( const CppUnitVector<Test *> &tests );
+
+protected:
+  Test *getRootTest();
+
+  TestSuite *m_suite;
+
+  typedef CppUnitVector<Test *> Tests;
+  Tests m_tests;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNITUI_MFC_MFCTESTRUNNER_H
\ No newline at end of file

Added: trunk/mingw-libs/include/cppunit/ui/mfc/TestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/mfc/TestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/mfc/TestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,21 @@
+#ifndef CPPUNITUI_MFC_TESTRUNNER_H
+#define CPPUNITUI_MFC_TESTRUNNER_H
+
+#include <cppunit/ui/mfc/MfcTestRunner.h>
+
+CPPUNIT_NS_BEGIN
+
+#if defined(CPPUNIT_HAVE_NAMESPACES)
+namespace MfcUi
+{
+  /*! Mfc TestRunner (DEPRECATED).
+   * \deprecated Use CppUnit::MfcTestRunner instead.
+   */
+  typedef CPPUNIT_NS::MfcTestRunner TestRunner;
+}
+#endif // defined(CPPUNIT_HAVE_NAMESPACES)
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNITUI_MFC_TESTRUNNER_H

Added: trunk/mingw-libs/include/cppunit/ui/qt/Config.h
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/qt/Config.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/qt/Config.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,21 @@
+#ifndef CPPUNIT_QTUI_CONFIG_H
+#define CPPUNIT_QTUI_CONFIG_H
+
+/*! Macro to export symbol to DLL with VC++.
+ *
+ * - QTTESTRUNNER_DLL_BUILD must be defined when building the DLL.
+ * - QTTESTRUNNER_DLL must be defined if linking against the DLL.
+ * - If none of the above are defined then you are building or linking against
+ *   the static library.
+ */
+
+#if defined( QTTESTRUNNER_DLL_BUILD )
+#  define QTTESTRUNNER_API __declspec(dllexport)
+#elif defined ( QTTESTRUNNER_DLL )
+#  define QTTESTRUNNER_API __declspec(dllimport)
+#else
+#  define QTTESTRUNNER_API
+#endif
+
+
+#endif // CPPUNIT_QTUI_CONFIG_H
\ No newline at end of file

Added: trunk/mingw-libs/include/cppunit/ui/qt/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/qt/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/qt/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,377 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/ui/qt/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/ui/qt
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+	QtTestRunner.h \
+	Config.h
+
+subdir = include/cppunit/ui/qt
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/qt/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/qt/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/qt/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/qt/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,6 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/qt
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+	QtTestRunner.h \
+	Config.h

Added: trunk/mingw-libs/include/cppunit/ui/qt/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/qt/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/qt/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,377 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/ui/qt
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+	QtTestRunner.h \
+	Config.h
+
+subdir = include/cppunit/ui/qt
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/qt/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/qt/QtTestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/qt/QtTestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/qt/QtTestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,85 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file TestRunner.h for class TestRunner
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/09/19
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_QTUI_QTTESTRUNNER_H
+#define CPPUNIT_QTUI_QTTESTRUNNER_H
+
+#include <cppunit/portability/CppUnitVector.h>
+#include "Config.h"
+
+CPPUNIT_NS_BEGIN
+
+
+  class Test;
+  class TestSuite;
+
+
+/*! 
+ * \brief QT test runner.
+ * \ingroup ExecutingTest
+ *
+ * Here is an example of usage:
+ * \code
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ * #include <cppunit/ui/qt/TestRunner.h>
+ *
+ * [...]
+ *
+ * void 
+ * QDepWindow::runTests()
+ * {
+ *   CppUnit::QtUi::TestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );
+ *   runner.run( true );
+ * }
+ * \endcode
+ *
+ */
+class QTTESTRUNNER_API QtTestRunner
+{
+public:
+  /*! Constructs a TestRunner object.
+   */
+  QtTestRunner();
+
+  /*! Destructor.
+   */
+  virtual ~QtTestRunner();
+
+  void run( bool autoRun =false );
+
+  void addTest( Test *test );
+
+private:
+  /// Prevents the use of the copy constructor.
+  QtTestRunner( const QtTestRunner &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const QtTestRunner &copy );
+
+  Test *getRootTest();
+
+private:
+  typedef CppUnitVector<Test *> Tests;
+  Tests *_tests;
+
+  TestSuite *_suite;
+};
+
+
+#if CPPUNIT_HAVE_NAMESPACES
+  namespace QtUi
+  {
+    /*! Qt TestRunner (DEPRECATED).
+     * \deprecated Use CppUnit::QtTestRunner instead.
+     */
+    typedef CPPUNIT_NS::QtTestRunner TestRunner;
+  }
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_QTUI_QTTESTRUNNER_H

Added: trunk/mingw-libs/include/cppunit/ui/qt/TestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/qt/TestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/qt/TestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,11 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file TestRunner.h for class TestRunner
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/09/19
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_QTUI_TESTRUNNER_H
+#define CPPUNIT_QTUI_TESTRUNNER_H
+
+#include <cppunit/ui/qt/QtTestRunner.h>
+
+#endif  // CPPUNIT_QTUI_TESTRUNNER_H

Added: trunk/mingw-libs/include/cppunit/ui/text/Makefile
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/text/Makefile	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/text/Makefile	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,376 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# include/cppunit/ui/text/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../../../..
+
+pkgdatadir = $(datadir)/cppunit
+pkglibdir = $(libdir)/cppunit
+pkgincludedir = $(includedir)/cppunit
+top_builddir = ../../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = i686-pc-mingw32
+ACLOCAL = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run aclocal-1.7
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run tar
+AR = ar
+AUTOCONF = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run automake-1.7
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2
+CPP = gcc -E
+CPPFLAGS = 
+CPPUNIT_BINARY_AGE = 0
+CPPUNIT_INTERFACE_AGE = 0
+CPPUNIT_MAJOR_VERSION = 1
+CPPUNIT_MICRO_VERSION = 2
+CPPUNIT_MINOR_VERSION = 10
+CPPUNIT_VERSION = 1.10.2
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DOC_FALSE = 
+DOC_TRUE = #
+DOT = 
+DOXYGEN = 
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = .exe
+F77 = g77
+FFLAGS = -g -O2
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBADD_DL = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool
+LN_S = ln -s
+LTLIBOBJS = 
+LT_AGE = 0
+LT_CURRENT = 2
+LT_RELEASE = 1.10
+LT_REVISION = 0
+MAKEINFO = ${SHELL} /home/Yura/cppunit-1.10.2/config/missing --run makeinfo
+OBJEXT = o
+PACKAGE = cppunit
+PACKAGE_BUGREPORT = 
+PACKAGE_NAME = 
+PACKAGE_STRING = 
+PACKAGE_TARNAME = 
+PACKAGE_VERSION = 
+PATH_SEPARATOR = :
+RANLIB = ranlib
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 1.10.2
+ac_ct_AR = ar
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_F77 = g77
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+bindir = ${exec_prefix}/bin
+build = i686-pc-mingw32
+build_alias = 
+build_cpu = i686
+build_os = mingw32
+build_vendor = pc
+datadir = ${prefix}/share
+enable_dot = no
+enable_html_docs = yes
+enable_latex_docs = no
+exec_prefix = ${prefix}
+host = i686-pc-mingw32
+host_alias = 
+host_cpu = i686
+host_os = mingw32
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/Yura/cppunit-1.10.2/config/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target_alias = 
+libcppunitincludedir = $(includedir)/cppunit/ui/text
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  TextTestRunner.h
+
+subdir = include/cppunit/ui/text
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/text/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/text/Makefile.am
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/text/Makefile.am	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/text/Makefile.am	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,5 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/text
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  TextTestRunner.h

Added: trunk/mingw-libs/include/cppunit/ui/text/Makefile.in
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/text/Makefile.in	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/text/Makefile.in	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,376 @@
+# Makefile.in generated by automake 1.7.6 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../../..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOC_FALSE = @DOC_FALSE@
+DOC_TRUE = @DOC_TRUE@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+libcppunitincludedir = $(includedir)/cppunit/ui/text
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  TextTestRunner.h
+
+subdir = include/cppunit/ui/text
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/config/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+HEADERS = $(libcppunitinclude_HEADERS)
+
+DIST_COMMON = $(libcppunitinclude_HEADERS) Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/text/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  $(libcppunitincludeHEADERS_INSTALL) $$d$$p $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	  rm -f $(DESTDIR)$(libcppunitincludedir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ../../../..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(libcppunitincludedir)
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-libcppunitincludeHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libcppunitincludeHEADERS install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am \
+	uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: trunk/mingw-libs/include/cppunit/ui/text/TestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/text/TestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/text/TestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,24 @@
+#ifndef CPPUNIT_UI_TEXT_TESTRUNNER_H
+#define CPPUNIT_UI_TEXT_TESTRUNNER_H
+
+#include <cppunit/ui/text/TextTestRunner.h>
+
+
+#if defined(CPPUNIT_HAVE_NAMESPACES)
+
+CPPUNIT_NS_BEGIN
+namespace TextUi
+{
+
+  /*! Text TestRunner (DEPRECATED).
+   * \deprecated Use TextTestRunner instead.
+   */
+  typedef TextTestRunner TestRunner;
+
+}
+CPPUNIT_NS_END
+
+#endif // defined(CPPUNIT_HAVE_NAMESPACES)
+
+
+#endif  // CPPUNIT_UI_TEXT_TESTRUNNER_H

Added: trunk/mingw-libs/include/cppunit/ui/text/TextTestRunner.h
===================================================================
--- trunk/mingw-libs/include/cppunit/ui/text/TextTestRunner.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/mingw-libs/include/cppunit/ui/text/TextTestRunner.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,93 @@
+#ifndef CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
+#define CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
+
+
+#include <cppunit/Portability.h>
+#include <string>
+#include <cppunit/TestRunner.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Outputter;
+class Test;
+class TestSuite;
+class TextOutputter;
+class TestResult;
+class TestResultCollector;
+
+
+
+/*!
+ * \brief A text mode test runner.
+ * \ingroup WritingTestResult
+ * \ingroup ExecutingTest
+ *
+ * The test runner manage the life cycle of the added tests.
+ *
+ * The test runner can run only one of the added tests or all the tests. 
+ *
+ * TestRunner prints out a trace as the tests are executed followed by a
+ * summary at the end. The trace and summary print are optional.
+ *
+ * Here is an example of use:
+ *
+ * \code
+ * CppUnit::TextTestRunner runner;
+ * runner.addTest( ExampleTestCase::suite() );
+ * runner.run( "", true );    // Run all tests and wait
+ * \endcode
+ *
+ * The trace is printed using a TextTestProgressListener. The summary is printed
+ * using a TextOutputter. 
+ *
+ * You can specify an alternate Outputter at construction
+ * or later with setOutputter(). 
+ *
+ * After construction, you can register additional TestListener to eventManager(),
+ * for a custom progress trace, for example.
+ *
+ * \code
+ * CppUnit::TextTestRunner runner;
+ * runner.addTest( ExampleTestCase::suite() );
+ * runner.setOutputter( CppUnit::CompilerOutputter::defaultOutputter( 
+ *                          &runner.result(),
+ *                          std::cerr ) );
+ * MyCustomProgressTestListener progress;
+ * runner.eventManager().addListener( &progress );
+ * runner.run( "", true );    // Run all tests and wait
+ * \endcode
+ *
+ * \see CompilerOutputter, XmlOutputter, TextOutputter.
+ */
+class CPPUNIT_API TextTestRunner : public CPPUNIT_NS::TestRunner
+{
+public:
+  TextTestRunner( Outputter *outputter =NULL );
+
+  virtual ~TextTestRunner();
+
+  bool run( std::string testPath ="",
+            bool doWait = false,
+            bool doPrintResult = true,
+            bool doPrintProgress = true );
+
+  void setOutputter( Outputter *outputter );
+
+  TestResultCollector &result() const;
+
+  TestResult &eventManager() const;
+
+protected:
+  virtual void wait( bool doWait );
+  virtual void printResult( bool doPrintResult );
+
+  TestResultCollector *m_result;
+  TestResult *m_eventManager;
+  Outputter *m_outputter;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H

Added: trunk/mingw-libs/lib/libcppunit.a
===================================================================
(Binary files differ)


Property changes on: trunk/mingw-libs/lib/libcppunit.a
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/source/games/gadventure.h
===================================================================
--- trunk/source/games/gadventure.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/source/games/gadventure.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,49 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+
+#include <stdio.h>   //standard io libary (needed for sprintf)
+#include <allegro.h> //allegro library header
+
+#include "melee.h"          //used by all TW source files.  well, mostly. 
+#include "melee/mgame.h"    //Game stuff
+#include "melee/mcbodies.h" //asteroids & planets
+#include "melee/mship.h"    //ships
+#include "melee/mshot.h"   //shots, missiles, lasers
+#include "melee/mlog.h"     //networking / demo recording / demo playback
+#include "melee/mcontrol.h" //controllers & AIs
+#include "melee/mview.h"    //Views & messages
+#include "melee/mshppan.h"  //ship panels...
+
+#include "melee/mitems.h"  //ship panels...
+#include "melee/manim.h"  //ship panels...
+#include "scp.h"
+#include "other/dialogs.h"
+
+
+/// TW Legacies Adventure Game 
+///
+
+class LegaciesGame : public Game 
+{
+public:
+  /// save game in XML format;
+  std::string Save();
+  /// load game
+  int Load(std::string);
+};
+
+

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/source/scp.cpp	2004-11-29 04:51:59 UTC (rev 104)
@@ -34,6 +34,8 @@
 #include "other/twconfig.h"
 #include "other/dialogs.h"
 
+#include "tests/testmain.h"
+
 #ifdef ALLEGRO_MSVC
 #pragma warning (disable:4786)
 #endif
@@ -536,24 +538,29 @@
 
 int tw_main(int argc, char *argv[]);
 
-#ifndef UNITTEST
 int main(int argc, char *argv[]) {
 	int r;
 	r = tw_main(argc, argv);
 	return r;
 }
 END_OF_MAIN();
-#endif
 
 int tw_main(int argc, char *argv[]) 
 { 
   STACKTRACE;
+
 #ifdef WIN32
   char szPath[MAX_PATH];
   GetModuleFileName(NULL, szPath, sizeof(szPath));
   if (strrchr(szPath, '\\')) *strrchr(szPath, '\\') = '\0';
   SetCurrentDirectory(szPath);
 #endif
+
+  if(argc==2&&!strcmp(argv[1],"-test"))
+      {
+	return RunTests();
+      }
+  
   int i;
   int auto_port = -1;
   const char *auto_play = NULL, *auto_param = NULL;

Modified: trunk/source/scp.h
===================================================================
--- trunk/source/scp.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/source/scp.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -26,9 +26,6 @@
 #include <string>
 class VideoWindow;
 
-/// \brief run tests
-bool RunTests();
-
 std::string tw_version();
 
 void change_teams();

Modified: trunk/source/tests/testdatapath.cpp
===================================================================
--- trunk/source/tests/testdatapath.cpp	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/source/tests/testdatapath.cpp	2004-11-29 04:51:59 UTC (rev 104)
@@ -1,6 +1,21 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
 
-#ifdef TEST
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
 
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifdef TW_CPPUNIT_TESTS
+
 #include <cppunit/ui/text/TestRunner.h>
 #include <cppunit/extensions/HelperMacros.h>
 
@@ -15,6 +30,7 @@
   
   void testAdd()
   {
+    CPPUNIT_ASSERT_MESSAGE("Important Message", 1);
     CPPUNIT_ASSERT(1);
   }
   void tearDown()
@@ -27,4 +43,6 @@
 
 };
 CPPUNIT_TEST_SUITE_REGISTRATION( DataPathTest );
+
 #endif
+

Modified: trunk/source/tests/testmain.cpp
===================================================================
--- trunk/source/tests/testmain.cpp	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/source/tests/testmain.cpp	2004-11-29 04:51:59 UTC (rev 104)
@@ -1,18 +1,43 @@
-#ifdef TEST
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifdef TW_CPPUNIT_TESTS
+
+#include <cppunit/CompilerOutputter.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
 #include <cppunit/ui/text/TestRunner.h>
-#include <cppunit/extensions/HelperMacros.h>
-#endif
 
-#include <allegro.h>
 
 bool RunTests()
 {
-  bool wasSucessful = false;
-#ifdef TEST
+  // Get the top level suite from the registry
+  CppUnit::Test *suite = CppUnit::TestFactoryRegistry::getRegistry().makeTest();
+
+  // Adds the test to the list of test to run
   CppUnit::TextUi::TestRunner runner;
-  CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
-  runner.addTest( registry.makeTest() );
-  wasSucessful = runner.run( "", false );
+  runner.addTest( suite );
+  
+  // Change the default outputter to a compiler error format outputter
+  runner.setOutputter( new CppUnit::CompilerOutputter( &runner.result(),
+                                                       std::cerr ) );
+  // Run the tests.
+  bool wasSucessful = runner.run();
+  
+  // Return error code 1 if the one of test failed.
+  return wasSucessful ? 0 : 1;
+}
+
 #endif
-  return !wasSucessful;
-}

Added: trunk/source/tests/testmain.h
===================================================================
--- trunk/source/tests/testmain.h	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/source/tests/testmain.h	2004-11-29 04:51:59 UTC (rev 104)
@@ -0,0 +1,30 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef __TW_TESTMAIN_H__
+#define __TW_TESTMAIN_H__
+
+/// Run all unit tests
+int RunTests()
+#ifndef TW_CPPUNIT_TESTS
+{
+  return 0;
+}
+#endif
+;
+
+#endif
+

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/sources.lst	2004-11-29 04:51:59 UTC (rev 104)
@@ -120,6 +120,7 @@
 source/libraries/agup/abitmap.c
 source/libraries/raknet/AES128.cpp
 source/libraries/raknet/PacketPool.cpp
+source/libraries/raknet/RakNetStatistics.cpp
 source/libraries/raknet/ExtendedOverlappedPool.cpp
 source/libraries/raknet/RakServer.cpp
 source/libraries/raknet/RPCNode.cpp

Deleted: trunk/tests.lst
===================================================================
--- trunk/tests.lst	2004-11-29 01:02:07 UTC (rev 103)
+++ trunk/tests.lst	2004-11-29 04:51:59 UTC (rev 104)
@@ -1,2 +0,0 @@
-tests/testmain.cpp
-tests/testdatapath.cpp



From yurand at sheep.berlios.de  Mon Nov 29 06:15:44 2004
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Mon, 29 Nov 2004 06:15:44 +0100
Subject: [Tw-light-svn] r105 - trunk/source
Message-ID: <200411290515.iAT5FiXv025752@sheep.berlios.de>

Author: yurand
Date: 2004-11-29 06:15:42 +0100 (Mon, 29 Nov 2004)
New Revision: 105

Modified:
   trunk/source/scp.cpp
Log:
Just little formating


Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2004-11-29 04:51:59 UTC (rev 104)
+++ trunk/source/scp.cpp	2004-11-29 05:15:42 UTC (rev 105)
@@ -667,49 +667,58 @@
 	    log_debug("command-line argument -noidle\n");
 	    _no_idle = 1;
 	  }
-	else if (strstr(argv[i], COMMAND_LINE_SERVER_LONG) && (argc > i + 0)) {
-		if (strlen(argv[i]) > strlen(COMMAND_LINE_SERVER_LONG)) {
-			// users can use two formats for the address: an alphanumeric name, like
-			// "localhost", or a dotted ip address, like a.b.c.d .  Further, users
-			// can specify the port here as well, by adding a colon and the number to 
-			// the end of the address.  
-			const char * addressStart = strstr(argv[i], COMMAND_LINE_SERVER_LONG) + strlen(COMMAND_LINE_SERVER_LONG);
-			const char * addressEnd = strstr(addressStart, ":");
+	else if (strstr(argv[i], COMMAND_LINE_SERVER_LONG)) 
+	  {
+	    if (strlen(argv[i]) > strlen(COMMAND_LINE_SERVER_LONG)) 
+	      {
+		// users can use two formats for the address: an alphanumeric name, like
+		// "localhost", or a dotted ip address, like a.b.c.d .  Further, users
+		// can specify the port here as well, by adding a colon and the number to 
+		// the end of the address.  
+		const char * addressStart = strstr(argv[i], COMMAND_LINE_SERVER_LONG) + strlen(COMMAND_LINE_SERVER_LONG);
+		const char * addressEnd = strstr(addressStart, ":");
+		
+		// user has added a colon, indicating the port.  The port starts at addressEnd
+		// and goes to the end of argv[i]
+		if (addressEnd && strlen(addressEnd) > 1) 
+		  { 
+		    // this is +1 to skip the ":"
+		    serverPort = atoi(addressEnd+1);
+		  }
+		serverAddress.clear();
+		serverAddress.append(addressStart, addressEnd-addressStart);
 			
-			// user has added a colon, indicating the port.  The port starts at addressEnd
-			// and goes to the end of argv[i]
-			if (addressEnd && strlen(addressEnd) > 1) { 
-				// this is +1 to skip the ":"
-				serverPort = atoi(addressEnd+1);
-			}
-			serverAddress.clear();
-			serverAddress.append(addressStart, addressEnd-addressStart);
-			
-			log_debug("commandline specified server as : host=[%s], port=[%u]\n", serverAddress.c_str(), serverPort);
-		}
-      }
-	else if (strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) && (argc > i + 0)) {
-		// this is the maximum number of computers that can connect to this program instance. 
-		// Used in server mode only, no effect otherwise.
-		if (strlen(argv[i]) > strlen(COMMAND_LINE_MAX_CLIENTS_LONG)) {
-			const char * portStart = strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) + strlen(COMMAND_LINE_MAX_CLIENTS_LONG);
-			if (strlen(portStart) > 1) {
-				serverMaxClients = atoi(portStart);
-			}
-			log_debug("commandline specified max clients as: serverMaxClients=[%u]\n", serverMaxClients);
-		}
-	}
-	else if (strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) && (argc > i + 0)) {
-		// this specifies the port this client will listen on.
-		// Used in client mode only, no effect otherwise.
-		if (strlen(argv[i]) > strlen(COMMAND_LINE_CLIENT_PORT_LONG)) {
-			const char * clientportStart = strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) + strlen(COMMAND_LINE_CLIENT_PORT_LONG);
-			if (strlen(clientportStart) > 1) {
-				clientPort = atoi(clientportStart);
-			}
-			log_debug("commandline specified client port as : port=[%u]\n", clientPort);
-		}
-	}
+		log_debug("commandline specified server as : host=[%s], port=[%u]\n", serverAddress.c_str(), serverPort);
+	      }
+	  }
+	else if (strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG)) 
+	  {
+	    // this is the maximum number of computers that can connect to this program instance. 
+	    // Used in server mode only, no effect otherwise.
+	    if (strlen(argv[i]) > strlen(COMMAND_LINE_MAX_CLIENTS_LONG)) 
+	      {
+		const char * portStart = strstr(argv[i], COMMAND_LINE_MAX_CLIENTS_LONG) + strlen(COMMAND_LINE_MAX_CLIENTS_LONG);
+		if (strlen(portStart) > 1) 
+		  {
+		    serverMaxClients = atoi(portStart);
+		  }
+		log_debug("commandline specified max clients as: serverMaxClients=[%u]\n", serverMaxClients);
+	      }
+	  }
+	else if (strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) && (argc > i + 0)) 
+	  {
+	    // this specifies the port this client will listen on.
+	    // Used in client mode only, no effect otherwise.
+	    if (strlen(argv[i]) > strlen(COMMAND_LINE_CLIENT_PORT_LONG)) 
+	      {
+		const char * clientportStart = strstr(argv[i], COMMAND_LINE_CLIENT_PORT_LONG) + strlen(COMMAND_LINE_CLIENT_PORT_LONG);
+		if (strlen(clientportStart) > 1) 
+		  {
+		    clientPort = atoi(clientportStart);
+		  }
+		log_debug("commandline specified client port as : port=[%u]\n", clientPort);
+	      }
+	  }
 	else if (!strcmp(argv[i], "-play") && (argc > i + 2)) 
 	  {
 	    log_debug("command-line argument -play\n");



