<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r171 - in trunk: . msvc-libs msvc-libs/include msvc-libs/include/SDL msvc-libs/include/allegro msvc-libs/include/allegro/inline msvc-libs/include/allegro/internal msvc-libs/include/allegro/platform msvc-libs/include/boost msvc-libs/include/boost/config msvc-libs/include/boost/config/abi msvc-libs/include/boost/config/compiler msvc-libs/include/boost/config/platform msvc-libs/include/boost/config/stdlib msvc-libs/include/boost/detail msvc-libs/lib source/games source/generated source/libraries/agup source/melee source/python
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2005-July/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r171%20-%20in%20trunk%3A%20.%20msvc-libs%20msvc-libs/include%20msvc-libs/include/SDL%20msvc-libs/include/allegro%20msvc-libs/include/allegro/inline%20msvc-libs/include/allegro/internal%20msvc-libs/include/allegro/platform%20msvc-libs/include/boost%20msvc-libs/include/boost/config%20msvc-libs/include/boost/config/abi%20msvc-libs/include/boost/config/compiler%20msvc-libs/include/boost/config/platform%20msvc-libs/include/boost/config/stdlib%20msvc-libs/include/boost/detail%20msvc-libs/lib%20source/games%20source/generated%20source/libraries/agup%20source/melee%20source/python&In-Reply-To=%3C200507241751.j6OHpP3c011880%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000116.html">
   <LINK REL="Next"  HREF="000118.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r171 - in trunk: . msvc-libs msvc-libs/include msvc-libs/include/SDL msvc-libs/include/allegro msvc-libs/include/allegro/inline msvc-libs/include/allegro/internal msvc-libs/include/allegro/platform msvc-libs/include/boost msvc-libs/include/boost/config msvc-libs/include/boost/config/abi msvc-libs/include/boost/config/compiler msvc-libs/include/boost/config/platform msvc-libs/include/boost/config/stdlib msvc-libs/include/boost/detail msvc-libs/lib source/games source/generated source/libraries/agup source/melee source/python</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r171%20-%20in%20trunk%3A%20.%20msvc-libs%20msvc-libs/include%20msvc-libs/include/SDL%20msvc-libs/include/allegro%20msvc-libs/include/allegro/inline%20msvc-libs/include/allegro/internal%20msvc-libs/include/allegro/platform%20msvc-libs/include/boost%20msvc-libs/include/boost/config%20msvc-libs/include/boost/config/abi%20msvc-libs/include/boost/config/compiler%20msvc-libs/include/boost/config/platform%20msvc-libs/include/boost/config/stdlib%20msvc-libs/include/boost/detail%20msvc-libs/lib%20source/games%20source/generated%20source/libraries/agup%20source/melee%20source/python&In-Reply-To=%3C200507241751.j6OHpP3c011880%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r171 - in trunk: . msvc-libs msvc-libs/include msvc-libs/include/SDL msvc-libs/include/allegro msvc-libs/include/allegro/inline msvc-libs/include/allegro/internal msvc-libs/include/allegro/platform msvc-libs/include/boost msvc-libs/include/boost/config msvc-libs/include/boost/config/abi msvc-libs/include/boost/config/compiler msvc-libs/include/boost/config/platform msvc-libs/include/boost/config/stdlib msvc-libs/include/boost/detail msvc-libs/lib source/games source/generated source/libraries/agup source/melee source/python">yurand at berlios.de
       </A><BR>
    <I>Sun Jul 24 19:51:25 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000116.html">[Tw-light-svn] r170 - in trunk: . source source/ais source/melee source/other
</A></li>
        <LI>Next message: <A HREF="000118.html">[Tw-light-svn] r172 - in trunk: . source/games source/melee
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#117">[ date ]</a>
              <a href="thread.html#117">[ thread ]</a>
              <a href="subject.html#117">[ subject ]</a>
              <a href="author.html#117">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2005-07-24 19:51:13 +0200 (Sun, 24 Jul 2005)
New Revision: 171

Added:
   trunk/SConstruct
   trunk/msvc-libs/
   trunk/msvc-libs/include/
   trunk/msvc-libs/include/Python.h
   trunk/msvc-libs/include/SDL/
   trunk/msvc-libs/include/SDL/SDL.h
   trunk/msvc-libs/include/SDL/SDL_active.h
   trunk/msvc-libs/include/SDL/SDL_audio.h
   trunk/msvc-libs/include/SDL/SDL_byteorder.h
   trunk/msvc-libs/include/SDL/SDL_cdrom.h
   trunk/msvc-libs/include/SDL/SDL_copying.h
   trunk/msvc-libs/include/SDL/SDL_cpuinfo.h
   trunk/msvc-libs/include/SDL/SDL_endian.h
   trunk/msvc-libs/include/SDL/SDL_error.h
   trunk/msvc-libs/include/SDL/SDL_events.h
   trunk/msvc-libs/include/SDL/SDL_getenv.h
   trunk/msvc-libs/include/SDL/SDL_joystick.h
   trunk/msvc-libs/include/SDL/SDL_keyboard.h
   trunk/msvc-libs/include/SDL/SDL_keysym.h
   trunk/msvc-libs/include/SDL/SDL_loadso.h
   trunk/msvc-libs/include/SDL/SDL_main.h
   trunk/msvc-libs/include/SDL/SDL_mouse.h
   trunk/msvc-libs/include/SDL/SDL_mutex.h
   trunk/msvc-libs/include/SDL/SDL_name.h
   trunk/msvc-libs/include/SDL/SDL_opengl.h
   trunk/msvc-libs/include/SDL/SDL_quit.h
   trunk/msvc-libs/include/SDL/SDL_rwops.h
   trunk/msvc-libs/include/SDL/SDL_syswm.h
   trunk/msvc-libs/include/SDL/SDL_thread.h
   trunk/msvc-libs/include/SDL/SDL_timer.h
   trunk/msvc-libs/include/SDL/SDL_types.h
   trunk/msvc-libs/include/SDL/SDL_version.h
   trunk/msvc-libs/include/SDL/SDL_video.h
   trunk/msvc-libs/include/SDL/begin_code.h
   trunk/msvc-libs/include/SDL/close_code.h
   trunk/msvc-libs/include/SDL_mixer.h
   trunk/msvc-libs/include/abstract.h
   trunk/msvc-libs/include/allegro.h
   trunk/msvc-libs/include/allegro/
   trunk/msvc-libs/include/allegro/3d.h
   trunk/msvc-libs/include/allegro/3dmaths.h
   trunk/msvc-libs/include/allegro/alcompat.h
   trunk/msvc-libs/include/allegro/alinline.h
   trunk/msvc-libs/include/allegro/base.h
   trunk/msvc-libs/include/allegro/color.h
   trunk/msvc-libs/include/allegro/compiled.h
   trunk/msvc-libs/include/allegro/config.h
   trunk/msvc-libs/include/allegro/datafile.h
   trunk/msvc-libs/include/allegro/debug.h
   trunk/msvc-libs/include/allegro/digi.h
   trunk/msvc-libs/include/allegro/draw.h
   trunk/msvc-libs/include/allegro/file.h
   trunk/msvc-libs/include/allegro/fix.h
   trunk/msvc-libs/include/allegro/fixed.h
   trunk/msvc-libs/include/allegro/fli.h
   trunk/msvc-libs/include/allegro/fmaths.h
   trunk/msvc-libs/include/allegro/gfx.h
   trunk/msvc-libs/include/allegro/gui.h
   trunk/msvc-libs/include/allegro/inline/
   trunk/msvc-libs/include/allegro/inline/3dmaths.inl
   trunk/msvc-libs/include/allegro/inline/asm.inl
   trunk/msvc-libs/include/allegro/inline/color.inl
   trunk/msvc-libs/include/allegro/inline/draw.inl
   trunk/msvc-libs/include/allegro/inline/file.inl
   trunk/msvc-libs/include/allegro/inline/fix.inl
   trunk/msvc-libs/include/allegro/inline/fmaths.inl
   trunk/msvc-libs/include/allegro/inline/gfx.inl
   trunk/msvc-libs/include/allegro/inline/gui.inl
   trunk/msvc-libs/include/allegro/inline/matrix.inl
   trunk/msvc-libs/include/allegro/inline/rle.inl
   trunk/msvc-libs/include/allegro/inline/system.inl
   trunk/msvc-libs/include/allegro/internal/
   trunk/msvc-libs/include/allegro/internal/aintern.h
   trunk/msvc-libs/include/allegro/internal/aintvga.h
   trunk/msvc-libs/include/allegro/internal/alconfig.h
   trunk/msvc-libs/include/allegro/joystick.h
   trunk/msvc-libs/include/allegro/keyboard.h
   trunk/msvc-libs/include/allegro/matrix.h
   trunk/msvc-libs/include/allegro/midi.h
   trunk/msvc-libs/include/allegro/mouse.h
   trunk/msvc-libs/include/allegro/palette.h
   trunk/msvc-libs/include/allegro/platform/
   trunk/msvc-libs/include/allegro/platform/aintbeos.h
   trunk/msvc-libs/include/allegro/platform/aintdos.h
   trunk/msvc-libs/include/allegro/platform/aintlnx.h
   trunk/msvc-libs/include/allegro/platform/aintmac.h
   trunk/msvc-libs/include/allegro/platform/aintqnx.h
   trunk/msvc-libs/include/allegro/platform/aintunix.h
   trunk/msvc-libs/include/allegro/platform/aintwin.h
   trunk/msvc-libs/include/allegro/platform/al386gcc.h
   trunk/msvc-libs/include/allegro/platform/al386vc.h
   trunk/msvc-libs/include/allegro/platform/al386wat.h
   trunk/msvc-libs/include/allegro/platform/albcc32.h
   trunk/msvc-libs/include/allegro/platform/albecfg.h
   trunk/msvc-libs/include/allegro/platform/albeos.h
   trunk/msvc-libs/include/allegro/platform/aldjgpp.h
   trunk/msvc-libs/include/allegro/platform/aldos.h
   trunk/msvc-libs/include/allegro/platform/almac.h
   trunk/msvc-libs/include/allegro/platform/almaccfg.h
   trunk/msvc-libs/include/allegro/platform/almngw32.h
   trunk/msvc-libs/include/allegro/platform/almsvc.h
   trunk/msvc-libs/include/allegro/platform/alplatf.h
   trunk/msvc-libs/include/allegro/platform/alqnx.h
   trunk/msvc-libs/include/allegro/platform/alqnxcfg.h
   trunk/msvc-libs/include/allegro/platform/alucfg.h
   trunk/msvc-libs/include/allegro/platform/alunix.h
   trunk/msvc-libs/include/allegro/platform/alunixac.hin
   trunk/msvc-libs/include/allegro/platform/alwatcom.h
   trunk/msvc-libs/include/allegro/platform/alwin.h
   trunk/msvc-libs/include/allegro/platform/macdef.h
   trunk/msvc-libs/include/allegro/quat.h
   trunk/msvc-libs/include/allegro/rle.h
   trunk/msvc-libs/include/allegro/sound.h
   trunk/msvc-libs/include/allegro/stream.h
   trunk/msvc-libs/include/allegro/system.h
   trunk/msvc-libs/include/allegro/text.h
   trunk/msvc-libs/include/allegro/timer.h
   trunk/msvc-libs/include/allegro/unicode.h
   trunk/msvc-libs/include/bitset.h
   trunk/msvc-libs/include/boolobject.h
   trunk/msvc-libs/include/boost/
   trunk/msvc-libs/include/boost/assert.hpp
   trunk/msvc-libs/include/boost/checked_delete.hpp
   trunk/msvc-libs/include/boost/config.hpp
   trunk/msvc-libs/include/boost/config/
   trunk/msvc-libs/include/boost/config/abi/
   trunk/msvc-libs/include/boost/config/abi/borland_prefix.hpp
   trunk/msvc-libs/include/boost/config/abi/borland_suffix.hpp
   trunk/msvc-libs/include/boost/config/abi/msvc_prefix.hpp
   trunk/msvc-libs/include/boost/config/abi/msvc_suffix.hpp
   trunk/msvc-libs/include/boost/config/abi_prefix.hpp
   trunk/msvc-libs/include/boost/config/abi_suffix.hpp
   trunk/msvc-libs/include/boost/config/auto_link.hpp
   trunk/msvc-libs/include/boost/config/compiler/
   trunk/msvc-libs/include/boost/config/compiler/borland.hpp
   trunk/msvc-libs/include/boost/config/compiler/comeau.hpp
   trunk/msvc-libs/include/boost/config/compiler/common_edg.hpp
   trunk/msvc-libs/include/boost/config/compiler/compaq_cxx.hpp
   trunk/msvc-libs/include/boost/config/compiler/digitalmars.hpp
   trunk/msvc-libs/include/boost/config/compiler/gcc.hpp
   trunk/msvc-libs/include/boost/config/compiler/greenhills.hpp
   trunk/msvc-libs/include/boost/config/compiler/hp_acc.hpp
   trunk/msvc-libs/include/boost/config/compiler/intel.hpp
   trunk/msvc-libs/include/boost/config/compiler/kai.hpp
   trunk/msvc-libs/include/boost/config/compiler/metrowerks.hpp
   trunk/msvc-libs/include/boost/config/compiler/mpw.hpp
   trunk/msvc-libs/include/boost/config/compiler/sgi_mipspro.hpp
   trunk/msvc-libs/include/boost/config/compiler/sunpro_cc.hpp
   trunk/msvc-libs/include/boost/config/compiler/vacpp.hpp
   trunk/msvc-libs/include/boost/config/compiler/visualc.hpp
   trunk/msvc-libs/include/boost/config/platform/
   trunk/msvc-libs/include/boost/config/platform/aix.hpp
   trunk/msvc-libs/include/boost/config/platform/amigaos.hpp
   trunk/msvc-libs/include/boost/config/platform/beos.hpp
   trunk/msvc-libs/include/boost/config/platform/bsd.hpp
   trunk/msvc-libs/include/boost/config/platform/cygwin.hpp
   trunk/msvc-libs/include/boost/config/platform/hpux.hpp
   trunk/msvc-libs/include/boost/config/platform/irix.hpp
   trunk/msvc-libs/include/boost/config/platform/linux.hpp
   trunk/msvc-libs/include/boost/config/platform/macos.hpp
   trunk/msvc-libs/include/boost/config/platform/solaris.hpp
   trunk/msvc-libs/include/boost/config/platform/win32.hpp
   trunk/msvc-libs/include/boost/config/posix_features.hpp
   trunk/msvc-libs/include/boost/config/requires_threads.hpp
   trunk/msvc-libs/include/boost/config/select_compiler_config.hpp
   trunk/msvc-libs/include/boost/config/select_platform_config.hpp
   trunk/msvc-libs/include/boost/config/select_stdlib_config.hpp
   trunk/msvc-libs/include/boost/config/stdlib/
   trunk/msvc-libs/include/boost/config/stdlib/dinkumware.hpp
   trunk/msvc-libs/include/boost/config/stdlib/libcomo.hpp
   trunk/msvc-libs/include/boost/config/stdlib/libstdcpp3.hpp
   trunk/msvc-libs/include/boost/config/stdlib/modena.hpp
   trunk/msvc-libs/include/boost/config/stdlib/msl.hpp
   trunk/msvc-libs/include/boost/config/stdlib/roguewave.hpp
   trunk/msvc-libs/include/boost/config/stdlib/sgi.hpp
   trunk/msvc-libs/include/boost/config/stdlib/stlport.hpp
   trunk/msvc-libs/include/boost/config/stdlib/vacpp.hpp
   trunk/msvc-libs/include/boost/config/suffix.hpp
   trunk/msvc-libs/include/boost/config/user.hpp
   trunk/msvc-libs/include/boost/detail/
   trunk/msvc-libs/include/boost/detail/lightweight_mutex.hpp
   trunk/msvc-libs/include/boost/detail/lwm_win32.hpp
   trunk/msvc-libs/include/boost/detail/lwm_win32_cs.hpp
   trunk/msvc-libs/include/boost/detail/lwm_win32_nt.hpp
   trunk/msvc-libs/include/boost/detail/shared_count.hpp
   trunk/msvc-libs/include/boost/detail/workaround.hpp
   trunk/msvc-libs/include/boost/non_type.hpp
   trunk/msvc-libs/include/boost/scoped_array.hpp
   trunk/msvc-libs/include/boost/scoped_ptr.hpp
   trunk/msvc-libs/include/boost/shared_array.hpp
   trunk/msvc-libs/include/boost/shared_container_iterator.hpp
   trunk/msvc-libs/include/boost/shared_ptr.hpp
   trunk/msvc-libs/include/boost/smart_ptr.hpp
   trunk/msvc-libs/include/boost/throw_exception.hpp
   trunk/msvc-libs/include/boost/type.hpp
   trunk/msvc-libs/include/boost/weak_ptr.hpp
   trunk/msvc-libs/include/bufferobject.h
   trunk/msvc-libs/include/cStringIO.h
   trunk/msvc-libs/include/cellobject.h
   trunk/msvc-libs/include/ceval.h
   trunk/msvc-libs/include/classobject.h
   trunk/msvc-libs/include/cobject.h
   trunk/msvc-libs/include/codecs.h
   trunk/msvc-libs/include/compile.h
   trunk/msvc-libs/include/complexobject.h
   trunk/msvc-libs/include/datetime.h
   trunk/msvc-libs/include/descrobject.h
   trunk/msvc-libs/include/dictobject.h
   trunk/msvc-libs/include/enumobject.h
   trunk/msvc-libs/include/errcode.h
   trunk/msvc-libs/include/eval.h
   trunk/msvc-libs/include/fileobject.h
   trunk/msvc-libs/include/floatobject.h
   trunk/msvc-libs/include/frameobject.h
   trunk/msvc-libs/include/funcobject.h
   trunk/msvc-libs/include/genobject.h
   trunk/msvc-libs/include/graminit.h
   trunk/msvc-libs/include/grammar.h
   trunk/msvc-libs/include/import.h
   trunk/msvc-libs/include/intobject.h
   trunk/msvc-libs/include/intrcheck.h
   trunk/msvc-libs/include/iterobject.h
   trunk/msvc-libs/include/listobject.h
   trunk/msvc-libs/include/longintrepr.h
   trunk/msvc-libs/include/longobject.h
   trunk/msvc-libs/include/marshal.h
   trunk/msvc-libs/include/metagrammar.h
   trunk/msvc-libs/include/methodobject.h
   trunk/msvc-libs/include/modsupport.h
   trunk/msvc-libs/include/moduleobject.h
   trunk/msvc-libs/include/node.h
   trunk/msvc-libs/include/object.h
   trunk/msvc-libs/include/objimpl.h
   trunk/msvc-libs/include/opcode.h
   trunk/msvc-libs/include/osdefs.h
   trunk/msvc-libs/include/parsetok.h
   trunk/msvc-libs/include/patchlevel.h
   trunk/msvc-libs/include/pgen.h
   trunk/msvc-libs/include/pgenheaders.h
   trunk/msvc-libs/include/py_curses.h
   trunk/msvc-libs/include/pyconfig.h
   trunk/msvc-libs/include/pydebug.h
   trunk/msvc-libs/include/pyerrors.h
   trunk/msvc-libs/include/pyfpe.h
   trunk/msvc-libs/include/pygetopt.h
   trunk/msvc-libs/include/pymactoolbox.h
   trunk/msvc-libs/include/pymem.h
   trunk/msvc-libs/include/pyport.h
   trunk/msvc-libs/include/pystate.h
   trunk/msvc-libs/include/pystrtod.h
   trunk/msvc-libs/include/pythonrun.h
   trunk/msvc-libs/include/pythread.h
   trunk/msvc-libs/include/rangeobject.h
   trunk/msvc-libs/include/setobject.h
   trunk/msvc-libs/include/sliceobject.h
   trunk/msvc-libs/include/stringobject.h
   trunk/msvc-libs/include/structmember.h
   trunk/msvc-libs/include/structseq.h
   trunk/msvc-libs/include/symtable.h
   trunk/msvc-libs/include/sysmodule.h
   trunk/msvc-libs/include/timefuncs.h
   trunk/msvc-libs/include/token.h
   trunk/msvc-libs/include/traceback.h
   trunk/msvc-libs/include/tupleobject.h
   trunk/msvc-libs/include/ucnhash.h
   trunk/msvc-libs/include/unicodeobject.h
   trunk/msvc-libs/include/weakrefobject.h
   trunk/msvc-libs/include/winalleg.h
   trunk/msvc-libs/include/zconf.h
   trunk/msvc-libs/include/zlib.h
   trunk/msvc-libs/lib/
   trunk/msvc-libs/lib/SDL.lib
   trunk/msvc-libs/lib/SDL_mixer.lib
   trunk/msvc-libs/lib/SDLmain.lib
   trunk/msvc-libs/lib/aldat.lib
   trunk/msvc-libs/lib/alld.lib
   trunk/msvc-libs/lib/alld_s.lib
   trunk/msvc-libs/lib/alleg.lib
   trunk/msvc-libs/lib/alleg_s.lib
   trunk/msvc-libs/lib/allp.lib
   trunk/msvc-libs/lib/allp_s.lib
   trunk/msvc-libs/lib/python24.lib
   trunk/msvc-libs/lib/z.lib
Modified:
   trunk/makefile
   trunk/source/games/ggob.cpp
   trunk/source/generated/tml_wrap.cpp
   trunk/source/libraries/agup/abitmap.c
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mgame.cpp
   trunk/source/python/fileops.cpp
   trunk/source/python/game.cpp
   trunk/sources.lst
Log:
Added MSVC 7.1 support.


Added: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/SConstruct	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,262 @@
+import os
+
+PRODUCTVERSION = &quot;0.3&quot;
+
+def GetSVNVersion(x,y):
+  global SVNVERSION
+  SVNVERSION = y.strip()
+
+twsource = Split(&quot;&quot;&quot;
+  source/python/game.i
+  source/ais/c_input.cpp
+  source/ais/c_other.cpp
+  source/ais/c_wussie.cpp
+  source/doxygen.cpp
+  source/frame.cpp
+  source/games/gamehierarchy.cpp
+  source/games/gdefender.cpp
+  source/games/gflmelee.cpp
+  source/games/ggob.cpp
+  source/gui.cpp
+  source/input.cpp
+  source/libraries/agup/aalg.c
+  source/libraries/agup/aase.c
+  source/libraries/agup/abeos.c
+  source/libraries/agup/abitmap.c
+  source/libraries/agup/agtk.c
+  source/libraries/agup/agup.c
+  source/libraries/agup/ans.c
+  source/libraries/agup/aphoton.c
+  source/libraries/agup/awin95.c
+  source/libraries/jpgalleg/decode.c
+  source/libraries/jpgalleg/encode.c
+  source/libraries/jpgalleg/io.c
+  source/libraries/jpgalleg/jpgalleg.c
+  source/melee/manim.cpp
+  source/melee/mcbodies.cpp
+  source/melee/mcontrol.cpp
+  source/melee/mfleet.cpp
+  source/melee/mframe.cpp
+  source/melee/mgame.cpp
+  source/melee/mhelpers.cpp
+  source/melee/mitems.cpp
+  source/melee/mlog.cpp
+  source/melee/mmain.cpp
+  source/melee/mmath.cpp
+  source/melee/mnet1.cpp
+  source/melee/moptions.cpp
+  source/melee/mship.cpp
+  source/melee/mshot.cpp
+  source/melee/mshpdata.cpp
+  source/melee/mshppan.cpp
+  source/melee/msprite.cpp
+  source/melee/mtarget.cpp
+  source/melee/mview.cpp
+  source/melee/WarpOutTrail.cpp
+  source/other/configrw.cpp
+  source/other/dialogs.cpp
+  source/other/fontmorph.cpp
+  source/other/gup.cpp
+  source/other/nullphas.cpp
+  source/other/objanim.cpp
+  source/other/orbit.cpp
+  source/other/planet3d.cpp
+  source/other/radar.cpp
+  source/other/shippart.cpp
+  source/other/starmap.cpp
+  source/other/twconfig.cpp
+  source/other/vbodies.cpp
+  source/other/vtarget.cpp
+  source/python/fileops.cpp
+  source/python/game.cpp
+  source/python/python_class.cpp
+  source/sc1ships/shpandgu.cpp
+  source/sc1ships/shparisk.cpp
+  source/sc1ships/shpchebr.cpp
+  source/sc1ships/shpearcr.cpp
+  source/sc1ships/shpilwav.cpp
+  source/sc1ships/shpkzedr.cpp
+  source/sc1ships/shpmmrxf.cpp
+  source/sc1ships/shpmycpo.cpp
+  source/sc1ships/shpshosc.cpp
+  source/sc1ships/shpspael.cpp
+  source/sc1ships/shpsyrpe.cpp
+  source/sc1ships/shpumgdr.cpp
+  source/sc1ships/shpvuxin.cpp
+  source/sc1ships/shpyehte.cpp
+  source/sc2ships/shpchmav.cpp
+  source/sc2ships/shpdruma.cpp
+  source/sc2ships/shpkohma.cpp
+  source/sc2ships/shpmeltr.cpp
+  source/sc2ships/shporzne.cpp
+  source/sc2ships/shppkufu.cpp
+  source/sc2ships/shpslypr.cpp
+  source/sc2ships/shpsupbl.cpp
+  source/sc2ships/shpthrto.cpp
+  source/sc2ships/shputwju.cpp
+  source/sc2ships/shpzfpst.cpp
+  source/scp.cpp
+  source/ships/shpaktgu.cpp
+  source/ships/shpalabc.cpp
+  source/ships/shpbahbu.cpp
+  source/ships/shpbipka.cpp
+  source/ships/shpbogce.cpp
+  source/ships/shpchoex.cpp
+  source/ships/shpconca.cpp
+  source/ships/shpconho.cpp
+  source/ships/shpdragr.cpp
+  source/ships/shpearc3.cpp
+  source/ships/shpforsh.cpp
+  source/ships/shpgarty.cpp
+  source/ships/shpilwsp.cpp
+  source/ships/shpkahbo.cpp
+  source/ships/shprogsq.cpp
+  source/ships/shpsamat.cpp
+  source/ships/shpstaba.cpp
+  source/ships/shptauar.cpp
+  source/ships/shptauda.cpp
+  source/ships/shptaume.cpp
+  source/ships/shptausl.cpp
+  source/ships/shptaust.cpp
+  source/ships/shptauto.cpp
+  source/ships/shpwolmi.cpp
+  source/ships/shpyusra.cpp
+  source/ships/shpzeksh.cpp
+  source/tests/gameconfigtest.cpp
+  source/tests/testdatapath.cpp
+  source/tests/testmain.cpp
+  source/tml/eventmanager.cpp
+  source/tml/gameaction.cpp
+  source/tml/gameconfig.cpp
+  source/tml/gamedialog.cpp
+  source/tml/gameevent.cpp
+  source/util/aarot.c
+  source/util/aastr.c
+  source/util/aautil.c
+  source/util/base.cpp
+  source/util/endian.cpp
+  source/util/errors.cpp
+  source/util/errors_c.c
+  source/util/get_time.c
+  source/util/history.cpp
+  source/util/net_tcp.cpp
+  source/util/pmask.c
+  source/util/random.cpp
+  source/util/round.c
+  source/util/sound.cpp
+  source/util/types.cpp
+  source/util/vector2.cpp
+&quot;&quot;&quot;)
+
+twheaders = Split(&quot;&quot;&quot;
+source/util/aastr.h
+source/util/aautil.h
+source/ais.h
+source/util/base.h
+source/other/configrw.h
+source/other/dialogs.h
+source/util/endian.h
+source/util/errors.h
+source/tml/eventmanager.h
+source/python/fileops.h
+source/other/fontmorph.h
+source/frame.h
+source/python/game.h
+source/tml/gameaction.h
+source/tml/gameconfig.h
+source/tests/gameconfigtest.h
+source/tml/gamedialog.h
+source/tml/gameevent.h
+source/games/gamehierarchy.h
+source/util/get_time.h
+source/games/gflmelee.h
+source/games/ggob.h
+source/gui.h
+source/other/gup.h
+source/util/history.h
+source/id.h
+source/input.h
+source/melee/manim.h
+source/melee/mcbodies.h
+source/melee/mcontrol.h
+source/melee.h
+source/melee/mfleet.h
+source/melee/mframe.h
+source/melee/mgame.h
+source/melee/mhelpers.h
+source/melee/mitems.h
+source/melee/mlog.h
+source/melee/mmain.h
+source/melee/mnet1.h
+source/melee/moptions.h
+source/melee/mship.h
+source/melee/mshot.h
+source/melee/mshppan.h
+source/melee/mtarget.h
+source/melee/mview.h
+source/util/net_tcp.h
+source/other/nullphas.h
+source/other/objanim.h
+source/other/orbit.h
+source/other/planet3d.h
+source/util/pmask.h
+source/python/python_class.h
+source/other/radar.h
+source/util/random.h
+source/util/round.h
+source/sc1ships.h
+source/sc2ships.h
+source/scp.h
+source/ship.h
+source/other/shippart.h
+source/ships/shpilwsp.h
+source/util/sound.h
+source/other/starmap.h
+source/tests/testmain.h
+source/other/twconfig.h
+source/python/types.h
+source/util/types.h
+source/other/vbodies.h
+source/util/vector2.h
+source/other/vtarget.h
+source/melee/WarpOutTrail.h
+&quot;&quot;&quot;)
+
+#####################################################################################
+SConsignFile()
+SetOption('implicit_cache', 1)
+SetOption('max_drift', 1)
+
+#ENV = {'PATH' : os.environ['PATH']},tools=['mingw','swig']
+
+if str(Platform()) == &quot;win32&quot;:
+    env = Environment()
+    if env[&quot;CC&quot;] == &quot;cl&quot;:
+        env['PDB'] = 'tw-light.pdb'
+        env.AppendENVPath('PATH', os.environ['PATH'])
+        env.Append(CPPPATH=[&quot;#msvc-libs/include&quot;,&quot;msvc-libs/include/SDL&quot;])
+        env.Append(LIBPATH=[&quot;#msvc-libs/lib&quot;])
+        env.Append(CPPFLAGS=['/GX','/MD']) 
+    else:
+        env.Append(CPPPATH=[&quot;#mingw-libs/include&quot;,&quot;mingw-libs/include/SDL&quot;])
+        env.Append(LIBPATH=[&quot;#mingw-libs/lib&quot;])
+else:
+    env = Environment()
+
+env.ParseConfig(&quot;svnversion .&quot;, GetSVNVersion )
+
+env.Append(SWIGFLAGS=['-c++','-python'])
+env.Append(CPPDEFINES=['DATAFILE_PATH=\\&quot;gamedata\\&quot;'])
+env.Append(CPPDEFINES=['TW_MAJOR_VERSION=\\&quot;' + PRODUCTVERSION + '\\&quot;', 
+                       'TW_SVNVERSION=\\&quot;' + SVNVERSION+ '\\&quot;'])
+
+env.Append(LIBS =  [&quot;alleg&quot;, &quot;winmm&quot;, &quot;ws2_32&quot;, &quot;SDL&quot;,&quot;SDLmain&quot;,&quot;SDL_mixer&quot;,&quot;python24&quot;,&quot;z&quot;])
+env.Append(CPPPATH=[&quot;#source&quot;])
+
+tw = env.Program(&quot;tw-light&quot;, twsource)
+
+env.MSVSProject(target = 'TW-Light' + env['MSVSPROJECTSUFFIX'],
+                          srcs = twsource + twheaders,
+                          buildtarget = tw,
+                          variant = 'Debug')
+

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/makefile	2005-07-24 17:51:13 UTC (rev 171)
@@ -68,6 +68,8 @@
 endif
 endif
 
+SWIG = swig
+
 CFLAGS += -I./sources -I./source/libraries
 
 ifdef DATAPATH
@@ -80,7 +82,7 @@
 VPATH = tests source source/libraries/agup source/ais source/games \
         source/melee source/tml source/tests \
         source/other source/ships source/sc1ships source/sc2ships \
-        source/util source/libraries/alogg \
+        source/util \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
         source/libraries/raknet source/python source/generated 
 
@@ -172,7 +174,7 @@
 
 
 source/generated/tml_wrap.cpp: source/python/game.i source/tml/gameaction.h source/util/sound.h source/tml/gameconfig.h source/tml/gamedialog.h source/tml/eventmanager.h
-	swig -c++ -python -o source/generated/tml_wrap.cpp source/python/game.i
+	$(SWIG) -c++ -python -o source/generated/tml_wrap.cpp source/python/game.i
 	cp source/generated/tml.py $(DATAPATH)/python/
 
 

Added: trunk/msvc-libs/include/Python.h
===================================================================
--- trunk/msvc-libs/include/Python.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/Python.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,171 @@
+#ifndef Py_PYTHON_H
+#define Py_PYTHON_H
+/* Since this is a &quot;meta-include&quot; file, no #ifdef __cplusplus / extern &quot;C&quot; { */
+
+/* Include nearly all Python header files */
+
+#include &quot;patchlevel.h&quot;
+#include &quot;pyconfig.h&quot;
+
+/* Cyclic gc is always enabled, starting with release 2.3a1.  Supply the
+ * old symbol for the benefit of extension modules written before then
+ * that may be conditionalizing on it.  The core doesn't use it anymore.
+ */
+#ifndef WITH_CYCLE_GC
+#define WITH_CYCLE_GC 1
+#endif
+
+#include &lt;limits.h&gt;
+
+#ifndef UCHAR_MAX
+#error &quot;Something's broken.  UCHAR_MAX should be defined in limits.h.&quot;
+#endif
+
+#if UCHAR_MAX != 255
+#error &quot;Python's source code assumes C's unsigned char is an 8-bit type.&quot;
+#endif
+
+#if defined(__sgi) &amp;&amp; defined(WITH_THREAD) &amp;&amp; !defined(_SGI_MP_SOURCE)
+#define _SGI_MP_SOURCE
+#endif
+
+#include &lt;stdio.h&gt;
+#ifndef NULL
+#   error &quot;Python.h requires that stdio.h define NULL.&quot;
+#endif
+
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdlib.h&gt;
+#ifdef HAVE_UNISTD_H
+#include &lt;unistd.h&gt;
+#endif
+
+/* For uintptr_t, intptr_t */
+#ifdef HAVE_STDDEF_H
+#include &lt;stddef.h&gt;
+#endif
+
+/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
+ * compiler command line when building Python in release mode; else
+ * assert() calls won't be removed.
+ */
+#include &lt;assert.h&gt;
+
+#include &quot;pyport.h&quot;
+
+/* pyconfig.h or pyport.h may or may not define DL_IMPORT */
+#ifndef DL_IMPORT	/* declarations for DLL import/export */
+#define DL_IMPORT(RTYPE) RTYPE
+#endif
+#ifndef DL_EXPORT	/* declarations for DLL import/export */
+#define DL_EXPORT(RTYPE) RTYPE
+#endif
+
+/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.
+ *  PYMALLOC_DEBUG is in error if pymalloc is not in use.
+ */
+#if defined(Py_DEBUG) &amp;&amp; defined(WITH_PYMALLOC) &amp;&amp; !defined(PYMALLOC_DEBUG)
+#define PYMALLOC_DEBUG
+#endif
+#if defined(PYMALLOC_DEBUG) &amp;&amp; !defined(WITH_PYMALLOC)
+#error &quot;PYMALLOC_DEBUG requires WITH_PYMALLOC&quot;
+#endif
+#include &quot;pymem.h&quot;
+
+#include &quot;object.h&quot;
+#include &quot;objimpl.h&quot;
+
+#include &quot;pydebug.h&quot;
+
+#include &quot;unicodeobject.h&quot;
+#include &quot;intobject.h&quot;
+#include &quot;boolobject.h&quot;
+#include &quot;longobject.h&quot;
+#include &quot;floatobject.h&quot;
+#ifndef WITHOUT_COMPLEX
+#include &quot;complexobject.h&quot;
+#endif
+#include &quot;rangeobject.h&quot;
+#include &quot;stringobject.h&quot;
+#include &quot;bufferobject.h&quot;
+#include &quot;tupleobject.h&quot;
+#include &quot;listobject.h&quot;
+#include &quot;dictobject.h&quot;
+#include &quot;enumobject.h&quot;
+#include &quot;setobject.h&quot;
+#include &quot;methodobject.h&quot;
+#include &quot;moduleobject.h&quot;
+#include &quot;funcobject.h&quot;
+#include &quot;classobject.h&quot;
+#include &quot;fileobject.h&quot;
+#include &quot;cobject.h&quot;
+#include &quot;traceback.h&quot;
+#include &quot;sliceobject.h&quot;
+#include &quot;cellobject.h&quot;
+#include &quot;iterobject.h&quot;
+#include &quot;genobject.h&quot;
+#include &quot;descrobject.h&quot;
+#include &quot;weakrefobject.h&quot;
+
+#include &quot;codecs.h&quot;
+#include &quot;pyerrors.h&quot;
+
+#include &quot;pystate.h&quot;
+
+#include &quot;modsupport.h&quot;
+#include &quot;pythonrun.h&quot;
+#include &quot;ceval.h&quot;
+#include &quot;sysmodule.h&quot;
+#include &quot;intrcheck.h&quot;
+#include &quot;import.h&quot;
+
+#include &quot;abstract.h&quot;
+
+#include &quot;compile.h&quot;
+#include &quot;eval.h&quot;
+
+#include &quot;pystrtod.h&quot;
+
+/* _Py_Mangle is defined in compile.c */
+PyAPI_FUNC(int) _Py_Mangle(char *p, char *name, \
+				 char *buffer, size_t maxlen);
+
+/* PyArg_GetInt is deprecated and should not be used, use PyArg_Parse(). */
+#define PyArg_GetInt(v, a)	PyArg_Parse((v), &quot;i&quot;, (a))
+
+/* PyArg_NoArgs should not be necessary.
+   Set ml_flags in the PyMethodDef to METH_NOARGS. */
+#define PyArg_NoArgs(v)		PyArg_Parse(v, &quot;&quot;)
+
+/* Convert a possibly signed character to a nonnegative int */
+/* XXX This assumes characters are 8 bits wide */
+#ifdef __CHAR_UNSIGNED__
+#define Py_CHARMASK(c)		(c)
+#else
+#define Py_CHARMASK(c)		((c) &amp; 0xff)
+#endif
+
+#include &quot;pyfpe.h&quot;
+
+/* These definitions must match corresponding definitions in graminit.h.
+   There's code in compile.c that checks that they are the same. */
+#define Py_single_input 256
+#define Py_file_input 257
+#define Py_eval_input 258
+
+#ifdef HAVE_PTH
+/* GNU pth user-space thread support */
+#include &lt;pth.h&gt;
+#endif
+
+/* Define macros for inline documentation. */
+#define PyDoc_VAR(name) static char name[]
+#define PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)
+#ifdef WITH_DOC_STRINGS
+#define PyDoc_STR(str) str
+#else
+#define PyDoc_STR(str) &quot;&quot;
+#endif
+
+#endif /* !Py_PYTHON_H */

Added: trunk/msvc-libs/include/SDL/SDL.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,97 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL.h,v 1.8 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+
+/* Main include header for the SDL library */
+
+#ifndef _SDL_H
+#define _SDL_H
+
+#include &quot;SDL_main.h&quot;
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_getenv.h&quot;
+#include &quot;SDL_error.h&quot;
+#include &quot;SDL_rwops.h&quot;
+#include &quot;SDL_timer.h&quot;
+#include &quot;SDL_audio.h&quot;
+#include &quot;SDL_cdrom.h&quot;
+#include &quot;SDL_joystick.h&quot;
+#include &quot;SDL_events.h&quot;
+#include &quot;SDL_video.h&quot;
+#include &quot;SDL_byteorder.h&quot;
+#include &quot;SDL_version.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* As of version 0.5, SDL is loaded dynamically into the application */
+
+/* These are the flags which may be passed to SDL_Init() -- you should
+   specify the subsystems which you will be using in your application.
+*/
+#define	SDL_INIT_TIMER		0x00000001
+#define SDL_INIT_AUDIO		0x00000010
+#define SDL_INIT_VIDEO		0x00000020
+#define SDL_INIT_CDROM		0x00000100
+#define SDL_INIT_JOYSTICK	0x00000200
+#define SDL_INIT_NOPARACHUTE	0x00100000	/* Don't catch fatal signals */
+#define SDL_INIT_EVENTTHREAD	0x01000000	/* Not supported on all OS's */
+#define SDL_INIT_EVERYTHING	0x0000FFFF
+
+/* This function loads the SDL dynamically linked library and initializes 
+ * the subsystems specified by 'flags' (and those satisfying dependencies)
+ * Unless the SDL_INIT_NOPARACHUTE flag is set, it will install cleanup
+ * signal handlers for some commonly ignored fatal signals (like SIGSEGV)
+ */
+extern DECLSPEC int SDLCALL SDL_Init(Uint32 flags);
+
+/* This function initializes specific SDL subsystems */
+extern DECLSPEC int SDLCALL SDL_InitSubSystem(Uint32 flags);
+
+/* This function cleans up specific SDL subsystems */
+extern DECLSPEC void SDLCALL SDL_QuitSubSystem(Uint32 flags);
+
+/* This function returns mask of the specified subsystems which have
+   been initialized.
+   If 'flags' is 0, it returns a mask of all initialized subsystems.
+*/
+extern DECLSPEC Uint32 SDLCALL SDL_WasInit(Uint32 flags);
+
+/* This function cleans up all initialized subsystems and unloads the
+ * dynamically linked library.  You should call it upon all exit conditions.
+ */
+extern DECLSPEC void SDLCALL SDL_Quit(void);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_H */

Added: trunk/msvc-libs/include/SDL/SDL_active.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_active.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_active.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,60 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_active.h,v 1.6 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+
+/* Include file for SDL application focus event handling */
+
+#ifndef _SDL_active_h
+#define _SDL_active_h
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* The available application states */
+#define SDL_APPMOUSEFOCUS	0x01		/* The app has mouse coverage */
+#define SDL_APPINPUTFOCUS	0x02		/* The app has input focus */
+#define SDL_APPACTIVE		0x04		/* The application is active */
+
+/* Function prototypes */
+/* 
+ * This function returns the current state of the application, which is a
+ * bitwise combination of SDL_APPMOUSEFOCUS, SDL_APPINPUTFOCUS, and
+ * SDL_APPACTIVE.  If SDL_APPACTIVE is set, then the user is able to
+ * see your application, otherwise it has been iconified or disabled.
+ */
+extern DECLSPEC Uint8 SDLCALL SDL_GetAppState(void);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_active_h */

Added: trunk/msvc-libs/include/SDL/SDL_audio.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_audio.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_audio.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,259 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_audio.h,v 1.9 2004/08/20 18:57:01 slouken Exp $&quot;;
+#endif
+
+/* Access to the raw audio mixing buffer for the SDL library */
+
+#ifndef _SDL_audio_h
+#define _SDL_audio_h
+
+#include &lt;stdio.h&gt;
+
+#include &quot;SDL_main.h&quot;
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_error.h&quot;
+#include &quot;SDL_rwops.h&quot;
+#include &quot;SDL_byteorder.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* The calculated values in this structure are calculated by SDL_OpenAudio() */
+typedef struct SDL_AudioSpec {
+	int freq;		/* DSP frequency -- samples per second */
+	Uint16 format;		/* Audio data format */
+	Uint8  channels;	/* Number of channels: 1 mono, 2 stereo */
+	Uint8  silence;		/* Audio buffer silence value (calculated) */
+	Uint16 samples;		/* Audio buffer size in samples (power of 2) */
+	Uint16 padding;		/* Necessary for some compile environments */
+	Uint32 size;		/* Audio buffer size in bytes (calculated) */
+	/* This function is called when the audio device needs more data.
+	   'stream' is a pointer to the audio data buffer
+	   'len' is the length of that buffer in bytes.
+	   Once the callback returns, the buffer will no longer be valid.
+	   Stereo samples are stored in a LRLRLR ordering.
+	*/
+	void (SDLCALL *callback)(void *userdata, Uint8 *stream, int len);
+	void  *userdata;
+} SDL_AudioSpec;
+
+/* Audio format flags (defaults to LSB byte order) */
+#define AUDIO_U8	0x0008	/* Unsigned 8-bit samples */
+#define AUDIO_S8	0x8008	/* Signed 8-bit samples */
+#define AUDIO_U16LSB	0x0010	/* Unsigned 16-bit samples */
+#define AUDIO_S16LSB	0x8010	/* Signed 16-bit samples */
+#define AUDIO_U16MSB	0x1010	/* As above, but big-endian byte order */
+#define AUDIO_S16MSB	0x9010	/* As above, but big-endian byte order */
+#define AUDIO_U16	AUDIO_U16LSB
+#define AUDIO_S16	AUDIO_S16LSB
+
+/* Native audio byte ordering */
+#if SDL_BYTEORDER == SDL_LIL_ENDIAN
+#define AUDIO_U16SYS	AUDIO_U16LSB
+#define AUDIO_S16SYS	AUDIO_S16LSB
+#else
+#define AUDIO_U16SYS	AUDIO_U16MSB
+#define AUDIO_S16SYS	AUDIO_S16MSB
+#endif
+
+
+/* A structure to hold a set of audio conversion filters and buffers */
+typedef struct SDL_AudioCVT {
+	int needed;			/* Set to 1 if conversion possible */
+	Uint16 src_format;		/* Source audio format */
+	Uint16 dst_format;		/* Target audio format */
+	double rate_incr;		/* Rate conversion increment */
+	Uint8 *buf;			/* Buffer to hold entire audio data */
+	int    len;			/* Length of original audio buffer */
+	int    len_cvt;			/* Length of converted audio buffer */
+	int    len_mult;		/* buffer must be len*len_mult big */
+	double len_ratio; 	/* Given len, final size is len*len_ratio */
+	void (SDLCALL *filters[10])(struct SDL_AudioCVT *cvt, Uint16 format);
+	int filter_index;		/* Current audio conversion function */
+} SDL_AudioCVT;
+
+
+/* Function prototypes */
+
+/* These functions are used internally, and should not be used unless you
+ * have a specific need to specify the audio driver you want to use.
+ * You should normally use SDL_Init() or SDL_InitSubSystem().
+ */
+extern DECLSPEC int SDLCALL SDL_AudioInit(const char *driver_name);
+extern DECLSPEC void SDLCALL SDL_AudioQuit(void);
+
+/* This function fills the given character buffer with the name of the
+ * current audio driver, and returns a pointer to it if the audio driver has
+ * been initialized.  It returns NULL if no driver has been initialized.
+ */
+extern DECLSPEC char * SDLCALL SDL_AudioDriverName(char *namebuf, int maxlen);
+
+/*
+ * This function opens the audio device with the desired parameters, and
+ * returns 0 if successful, placing the actual hardware parameters in the
+ * structure pointed to by 'obtained'.  If 'obtained' is NULL, the audio
+ * data passed to the callback function will be guaranteed to be in the
+ * requested format, and will be automatically converted to the hardware
+ * audio format if necessary.  This function returns -1 if it failed 
+ * to open the audio device, or couldn't set up the audio thread.
+ *
+ * When filling in the desired audio spec structure,
+ *  'desired-&gt;freq' should be the desired audio frequency in samples-per-second.
+ *  'desired-&gt;format' should be the desired audio format.
+ *  'desired-&gt;samples' is the desired size of the audio buffer, in samples.
+ *     This number should be a power of two, and may be adjusted by the audio
+ *     driver to a value more suitable for the hardware.  Good values seem to
+ *     range between 512 and 8096 inclusive, depending on the application and
+ *     CPU speed.  Smaller values yield faster response time, but can lead
+ *     to underflow if the application is doing heavy processing and cannot
+ *     fill the audio buffer in time.  A stereo sample consists of both right
+ *     and left channels in LR ordering.
+ *     Note that the number of samples is directly related to time by the
+ *     following formula:  ms = (samples*1000)/freq
+ *  'desired-&gt;size' is the size in bytes of the audio buffer, and is
+ *     calculated by SDL_OpenAudio().
+ *  'desired-&gt;silence' is the value used to set the buffer to silence,
+ *     and is calculated by SDL_OpenAudio().
+ *  'desired-&gt;callback' should be set to a function that will be called
+ *     when the audio device is ready for more data.  It is passed a pointer
+ *     to the audio buffer, and the length in bytes of the audio buffer.
+ *     This function usually runs in a separate thread, and so you should
+ *     protect data structures that it accesses by calling SDL_LockAudio()
+ *     and SDL_UnlockAudio() in your code.
+ *  'desired-&gt;userdata' is passed as the first parameter to your callback
+ *     function.
+ *
+ * The audio device starts out playing silence when it's opened, and should
+ * be enabled for playing by calling SDL_PauseAudio(0) when you are ready
+ * for your audio callback function to be called.  Since the audio driver
+ * may modify the requested size of the audio buffer, you should allocate
+ * any local mixing buffers after you open the audio device.
+ */
+extern DECLSPEC int SDLCALL SDL_OpenAudio(SDL_AudioSpec *desired, SDL_AudioSpec *obtained);
+
+/*
+ * Get the current audio state:
+ */
+typedef enum {
+	SDL_AUDIO_STOPPED = 0,
+	SDL_AUDIO_PLAYING,
+	SDL_AUDIO_PAUSED
+} SDL_audiostatus;
+extern DECLSPEC SDL_audiostatus SDLCALL SDL_GetAudioStatus(void);
+
+/*
+ * This function pauses and unpauses the audio callback processing.
+ * It should be called with a parameter of 0 after opening the audio
+ * device to start playing sound.  This is so you can safely initialize
+ * data for your callback function after opening the audio device.
+ * Silence will be written to the audio device during the pause.
+ */
+extern DECLSPEC void SDLCALL SDL_PauseAudio(int pause_on);
+
+/*
+ * This function loads a WAVE from the data source, automatically freeing
+ * that source if 'freesrc' is non-zero.  For example, to load a WAVE file,
+ * you could do:
+ *	SDL_LoadWAV_RW(SDL_RWFromFile(&quot;sample.wav&quot;, &quot;rb&quot;), 1, ...);
+ *
+ * If this function succeeds, it returns the given SDL_AudioSpec,
+ * filled with the audio data format of the wave data, and sets
+ * 'audio_buf' to a malloc()'d buffer containing the audio data,
+ * and sets 'audio_len' to the length of that audio buffer, in bytes.
+ * You need to free the audio buffer with SDL_FreeWAV() when you are 
+ * done with it.
+ *
+ * This function returns NULL and sets the SDL error message if the 
+ * wave file cannot be opened, uses an unknown data format, or is 
+ * corrupt.  Currently raw and MS-ADPCM WAVE files are supported.
+ */
+extern DECLSPEC SDL_AudioSpec * SDLCALL SDL_LoadWAV_RW(SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len);
+
+/* Compatibility convenience function -- loads a WAV from a file */
+#define SDL_LoadWAV(file, spec, audio_buf, audio_len) \
+	SDL_LoadWAV_RW(SDL_RWFromFile(file, &quot;rb&quot;),1, spec,audio_buf,audio_len)
+
+/*
+ * This function frees data previously allocated with SDL_LoadWAV_RW()
+ */
+extern DECLSPEC void SDLCALL SDL_FreeWAV(Uint8 *audio_buf);
+
+/*
+ * This function takes a source format and rate and a destination format
+ * and rate, and initializes the 'cvt' structure with information needed
+ * by SDL_ConvertAudio() to convert a buffer of audio data from one format
+ * to the other.
+ * This function returns 0, or -1 if there was an error.
+ */
+extern DECLSPEC int SDLCALL SDL_BuildAudioCVT(SDL_AudioCVT *cvt,
+		Uint16 src_format, Uint8 src_channels, int src_rate,
+		Uint16 dst_format, Uint8 dst_channels, int dst_rate);
+
+/* Once you have initialized the 'cvt' structure using SDL_BuildAudioCVT(),
+ * created an audio buffer cvt-&gt;buf, and filled it with cvt-&gt;len bytes of
+ * audio data in the source format, this function will convert it in-place
+ * to the desired format.
+ * The data conversion may expand the size of the audio data, so the buffer
+ * cvt-&gt;buf should be allocated after the cvt structure is initialized by
+ * SDL_BuildAudioCVT(), and should be cvt-&gt;len*cvt-&gt;len_mult bytes long.
+ */
+extern DECLSPEC int SDLCALL SDL_ConvertAudio(SDL_AudioCVT *cvt);
+
+/*
+ * This takes two audio buffers of the playing audio format and mixes
+ * them, performing addition, volume adjustment, and overflow clipping.
+ * The volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME
+ * for full audio volume.  Note this does not change hardware volume.
+ * This is provided for convenience -- you can mix your own audio data.
+ */
+#define SDL_MIX_MAXVOLUME 128
+extern DECLSPEC void SDLCALL SDL_MixAudio(Uint8 *dst, const Uint8 *src, Uint32 len, int volume);
+
+/*
+ * The lock manipulated by these functions protects the callback function.
+ * During a LockAudio/UnlockAudio pair, you can be guaranteed that the
+ * callback function is not running.  Do not call these from the callback
+ * function or you will cause deadlock.
+ */
+extern DECLSPEC void SDLCALL SDL_LockAudio(void);
+extern DECLSPEC void SDLCALL SDL_UnlockAudio(void);
+
+/*
+ * This function shuts down audio processing and closes the audio device.
+ */
+extern DECLSPEC void SDLCALL SDL_CloseAudio(void);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_audio_h */

Added: trunk/msvc-libs/include/SDL/SDL_byteorder.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_byteorder.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_byteorder.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,55 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_byteorder.h,v 1.9 2004/11/12 22:09:17 slouken Exp $&quot;;
+#endif
+
+/* Macros for determining the byte-order of this platform */
+
+#ifndef _SDL_byteorder_h
+#define _SDL_byteorder_h
+
+/* The two types of endianness */
+#define SDL_LIL_ENDIAN	1234
+#define SDL_BIG_ENDIAN	4321
+
+/* Pardon the mess, I'm trying to determine the endianness of this host.
+   I'm doing it by preprocessor defines rather than some sort of configure
+   script so that application code can use this too.  The &quot;right&quot; way would
+   be to dynamically generate this file on install, but that's a lot of work.
+ */
+#if (defined(__i386__) || defined(__i386)) || \
+     defined(__ia64__) || defined(WIN32) || \
+    (defined(__alpha__) || defined(__alpha)) || \
+     defined(__arm__) || \
+    (defined(__mips__) &amp;&amp; defined(__MIPSEL__)) || \
+     defined(__SYMBIAN32__) || \
+     defined(__x86_64__) || \
+     defined(__LITTLE_ENDIAN__)
+#define SDL_BYTEORDER	SDL_LIL_ENDIAN
+#else
+#define SDL_BYTEORDER	SDL_BIG_ENDIAN
+#endif
+
+#endif /* _SDL_byteorder_h */

Added: trunk/msvc-libs/include/SDL/SDL_cdrom.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_cdrom.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_cdrom.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,175 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_cdrom.h,v 1.7 2004/07/18 22:57:40 slouken Exp $&quot;;
+#endif
+
+/* This is the CD-audio control API for Simple DirectMedia Layer */
+
+#ifndef _SDL_cdrom_h
+#define _SDL_cdrom_h
+
+#include &quot;SDL_types.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* In order to use these functions, SDL_Init() must have been called
+   with the SDL_INIT_CDROM flag.  This causes SDL to scan the system
+   for CD-ROM drives, and load appropriate drivers.
+*/
+
+/* The maximum number of CD-ROM tracks on a disk */
+#define SDL_MAX_TRACKS	99
+
+/* The types of CD-ROM track possible */
+#define SDL_AUDIO_TRACK	0x00
+#define SDL_DATA_TRACK	0x04
+
+/* The possible states which a CD-ROM drive can be in. */
+typedef enum {
+	CD_TRAYEMPTY,
+	CD_STOPPED,
+	CD_PLAYING,
+	CD_PAUSED,
+	CD_ERROR = -1
+} CDstatus;
+
+/* Given a status, returns true if there's a disk in the drive */
+#define CD_INDRIVE(status)	((int)status &gt; 0)
+
+typedef struct SDL_CDtrack {
+	Uint8 id;		/* Track number */
+	Uint8 type;		/* Data or audio track */
+	Uint16 unused;
+	Uint32 length;		/* Length, in frames, of this track */
+	Uint32 offset;		/* Offset, in frames, from start of disk */
+} SDL_CDtrack;
+
+/* This structure is only current as of the last call to SDL_CDStatus() */
+typedef struct SDL_CD {
+	int id;			/* Private drive identifier */
+	CDstatus status;	/* Current drive status */
+
+	/* The rest of this structure is only valid if there's a CD in drive */
+	int numtracks;		/* Number of tracks on disk */
+	int cur_track;		/* Current track position */
+	int cur_frame;		/* Current frame offset within current track */
+	SDL_CDtrack track[SDL_MAX_TRACKS+1];
+} SDL_CD;
+
+/* Conversion functions from frames to Minute/Second/Frames and vice versa */
+#define CD_FPS	75
+#define FRAMES_TO_MSF(f, M,S,F)	{					\
+	int value = f;							\
+	*(F) = value%CD_FPS;						\
+	value /= CD_FPS;						\
+	*(S) = value%60;						\
+	value /= 60;							\
+	*(M) = value;							\
+}
+#define MSF_TO_FRAMES(M, S, F)	((M)*60*CD_FPS+(S)*CD_FPS+(F))
+
+/* CD-audio API functions: */
+
+/* Returns the number of CD-ROM drives on the system, or -1 if
+   SDL_Init() has not been called with the SDL_INIT_CDROM flag.
+ */
+extern DECLSPEC int SDLCALL SDL_CDNumDrives(void);
+
+/* Returns a human-readable, system-dependent identifier for the CD-ROM.
+   Example:
+	&quot;/dev/cdrom&quot;
+	&quot;E:&quot;
+	&quot;/dev/disk/ide/1/master&quot;
+*/
+extern DECLSPEC const char * SDLCALL SDL_CDName(int drive);
+
+/* Opens a CD-ROM drive for access.  It returns a drive handle on success,
+   or NULL if the drive was invalid or busy.  This newly opened CD-ROM
+   becomes the default CD used when other CD functions are passed a NULL
+   CD-ROM handle.
+   Drives are numbered starting with 0.  Drive 0 is the system default CD-ROM.
+*/
+extern DECLSPEC SDL_CD * SDLCALL SDL_CDOpen(int drive);
+
+/* This function returns the current status of the given drive.
+   If the drive has a CD in it, the table of contents of the CD and current
+   play position of the CD will be stored in the SDL_CD structure.
+*/
+extern DECLSPEC CDstatus SDLCALL SDL_CDStatus(SDL_CD *cdrom);
+
+/* Play the given CD starting at 'start_track' and 'start_frame' for 'ntracks'
+   tracks and 'nframes' frames.  If both 'ntrack' and 'nframe' are 0, play 
+   until the end of the CD.  This function will skip data tracks.
+   This function should only be called after calling SDL_CDStatus() to 
+   get track information about the CD.
+   For example:
+	// Play entire CD:
+	if ( CD_INDRIVE(SDL_CDStatus(cdrom)) )
+		SDL_CDPlayTracks(cdrom, 0, 0, 0, 0);
+	// Play last track:
+	if ( CD_INDRIVE(SDL_CDStatus(cdrom)) ) {
+		SDL_CDPlayTracks(cdrom, cdrom-&gt;numtracks-1, 0, 0, 0);
+	}
+	// Play first and second track and 10 seconds of third track:
+	if ( CD_INDRIVE(SDL_CDStatus(cdrom)) )
+		SDL_CDPlayTracks(cdrom, 0, 0, 2, 10);
+
+   This function returns 0, or -1 if there was an error.
+*/
+extern DECLSPEC int SDLCALL SDL_CDPlayTracks(SDL_CD *cdrom,
+		int start_track, int start_frame, int ntracks, int nframes);
+
+/* Play the given CD starting at 'start' frame for 'length' frames.
+   It returns 0, or -1 if there was an error.
+*/
+extern DECLSPEC int SDLCALL SDL_CDPlay(SDL_CD *cdrom, int start, int length);
+
+/* Pause play -- returns 0, or -1 on error */
+extern DECLSPEC int SDLCALL SDL_CDPause(SDL_CD *cdrom);
+
+/* Resume play -- returns 0, or -1 on error */
+extern DECLSPEC int SDLCALL SDL_CDResume(SDL_CD *cdrom);
+
+/* Stop play -- returns 0, or -1 on error */
+extern DECLSPEC int SDLCALL SDL_CDStop(SDL_CD *cdrom);
+
+/* Eject CD-ROM -- returns 0, or -1 on error */
+extern DECLSPEC int SDLCALL SDL_CDEject(SDL_CD *cdrom);
+
+/* Closes the handle for the CD-ROM drive */
+extern DECLSPEC void SDLCALL SDL_CDClose(SDL_CD *cdrom);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_video_h */

Added: trunk/msvc-libs/include/SDL/SDL_copying.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_copying.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_copying.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,27 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_copying.h,v 1.5 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+

Added: trunk/msvc-libs/include/SDL/SDL_cpuinfo.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_cpuinfo.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_cpuinfo.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,78 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_cpuinfo.h,v 1.5 2004/01/24 05:47:18 slouken Exp $&quot;;
+#endif
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* CPU feature detection for SDL                                       */
+
+#ifndef _SDL_cpuinfo_h
+#define _SDL_cpuinfo_h
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This function returns true if the CPU has the RDTSC instruction
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_HasRDTSC();
+
+/* This function returns true if the CPU has MMX features
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_HasMMX();
+
+/* This function returns true if the CPU has MMX Ext. features
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_HasMMXExt();
+
+/* This function returns true if the CPU has 3DNow features
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_Has3DNow();
+
+/* This function returns true if the CPU has 3DNow! Ext. features
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_Has3DNowExt();
+
+/* This function returns true if the CPU has SSE features
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_HasSSE();
+
+/* This function returns true if the CPU has SSE2 features
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_HasSSE2();
+
+/* This function returns true if the CPU has AltiVec features
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_HasAltiVec();
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_cpuinfo_h */

Added: trunk/msvc-libs/include/SDL/SDL_endian.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_endian.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_endian.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,212 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_endian.h,v 1.11 2004/11/27 23:11:20 pmandin Exp $&quot;;
+#endif
+
+/* Functions for reading and writing endian-specific values */
+
+#ifndef _SDL_endian_h
+#define _SDL_endian_h
+
+/* These functions read and write data of the specified endianness, 
+   dynamically translating to the host machine endianness.
+
+   e.g.: If you want to read a 16 bit value on big-endian machine from
+         an open file containing little endian values, you would use:
+		value = SDL_ReadLE16(rp);
+         Note that the read/write functions use SDL_RWops pointers
+         instead of FILE pointers.  This allows you to read and write
+         endian values from large chunks of memory as well as files 
+         and other data sources.
+*/
+
+#include &lt;stdio.h&gt;
+
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_rwops.h&quot;
+#include &quot;SDL_byteorder.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Use inline functions for compilers that support them, and static
+   functions for those that do not.  Because these functions become
+   static for compilers that do not support inline functions, this
+   header should only be included in files that actually use them.
+*/
+#if defined(__GNUC__) &amp;&amp; defined(__i386__)
+static __inline__ Uint16 SDL_Swap16(Uint16 x)
+{
+	__asm__(&quot;xchgb %b0,%h0&quot; : &quot;=q&quot; (x) :  &quot;0&quot; (x));
+	return x;
+}
+#elif defined(__GNUC__) &amp;&amp; defined(__x86_64__)
+static __inline__ Uint16 SDL_Swap16(Uint16 x)
+{
+	__asm__(&quot;xchgb %b0,%h0&quot; : &quot;=q&quot; (x) :  &quot;0&quot; (x));
+	return x;
+}
+#elif defined(__GNUC__) &amp;&amp; (defined(__powerpc__) || defined(__ppc__))
+static __inline__ Uint16 SDL_Swap16(Uint16 x)
+{
+	Uint16 result;
+
+	__asm__(&quot;rlwimi %0,%2,8,16,23&quot; : &quot;=&amp;r&quot; (result) : &quot;0&quot; (x &gt;&gt; 8), &quot;r&quot; (x));
+	return result;
+}
+#elif defined(__GNUC__) &amp;&amp; defined(__M68000__)
+static __inline__ Uint16 SDL_Swap16(Uint16 x)
+{
+	__asm__(&quot;rorw #8,%0&quot; : &quot;=d&quot; (x) :  &quot;0&quot; (x) : &quot;cc&quot;);
+	return x;
+}
+#else
+static __inline__ Uint16 SDL_Swap16(Uint16 x) {
+	return((x&lt;&lt;8)|(x&gt;&gt;8));
+}
+#endif
+
+#if defined(__GNUC__) &amp;&amp; defined(__i386__)
+static __inline__ Uint32 SDL_Swap32(Uint32 x)
+{
+	__asm__(&quot;bswap %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
+	return x;
+}
+#elif defined(__GNUC__) &amp;&amp; defined(__x86_64__)
+static __inline__ Uint32 SDL_Swap32(Uint32 x)
+{
+	__asm__(&quot;bswapl %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
+	return x;
+}
+#elif defined(__GNUC__) &amp;&amp; (defined(__powerpc__) || defined(__ppc__))
+static __inline__ Uint32 SDL_Swap32(Uint32 x)
+{
+	Uint32 result;
+
+	__asm__(&quot;rlwimi %0,%2,24,16,23&quot; : &quot;=&amp;r&quot; (result) : &quot;0&quot; (x&gt;&gt;24), &quot;r&quot; (x));
+	__asm__(&quot;rlwimi %0,%2,8,8,15&quot;   : &quot;=&amp;r&quot; (result) : &quot;0&quot; (result),    &quot;r&quot; (x));
+	__asm__(&quot;rlwimi %0,%2,24,0,7&quot;   : &quot;=&amp;r&quot; (result) : &quot;0&quot; (result),    &quot;r&quot; (x));
+	return result;
+}
+#elif defined(__GNUC__) &amp;&amp; defined(__M68000__)
+static __inline__ Uint32 SDL_Swap32(Uint32 x)
+{
+	__asm__(&quot;rorw	#8,%0\n\tswap	%0\n\tror	#8,%0&quot; : &quot;=d&quot; (x) :  &quot;0&quot; (x) : &quot;cc&quot;);
+	return x;
+}
+#else
+static __inline__ Uint32 SDL_Swap32(Uint32 x) {
+	return((x&lt;&lt;24)|((x&lt;&lt;8)&amp;0x00FF0000)|((x&gt;&gt;8)&amp;0x0000FF00)|(x&gt;&gt;24));
+}
+#endif
+
+#ifdef SDL_HAS_64BIT_TYPE
+#if defined(__GNUC__) &amp;&amp; defined(__i386__)
+static __inline__ Uint64 SDL_Swap64(Uint64 x)
+{
+	union { 
+		struct { Uint32 a,b; } s;
+		Uint64 u;
+	} v;
+	v.u = x;
+	__asm__(&quot;bswapl %0 ; bswapl %1 ; xchgl %0,%1&quot; 
+	        : &quot;=r&quot; (v.s.a), &quot;=r&quot; (v.s.b) 
+	        : &quot;0&quot; (v.s.a), &quot;1&quot; (v.s.b)); 
+	return v.u;
+}
+#elif defined(__GNUC__) &amp;&amp; defined(__x86_64__)
+static __inline__ Uint64 SDL_Swap64(Uint64 x)
+{
+	__asm__(&quot;bswapq %0&quot; : &quot;=r&quot; (x) : &quot;0&quot; (x));
+	return x;
+}
+#else
+static __inline__ Uint64 SDL_Swap64(Uint64 x)
+{
+	Uint32 hi, lo;
+
+	/* Separate into high and low 32-bit values and swap them */
+	lo = (Uint32)(x&amp;0xFFFFFFFF);
+	x &gt;&gt;= 32;
+	hi = (Uint32)(x&amp;0xFFFFFFFF);
+	x = SDL_Swap32(lo);
+	x &lt;&lt;= 32;
+	x |= SDL_Swap32(hi);
+	return(x);
+}
+#endif
+#else
+/* This is mainly to keep compilers from complaining in SDL code.
+   If there is no real 64-bit datatype, then compilers will complain about
+   the fake 64-bit datatype that SDL provides when it compiles user code.
+*/
+#define SDL_Swap64(X)	(X)
+#endif /* SDL_HAS_64BIT_TYPE */
+
+
+/* Byteswap item from the specified endianness to the native endianness */
+#if SDL_BYTEORDER == SDL_LIL_ENDIAN
+#define SDL_SwapLE16(X)	(X)
+#define SDL_SwapLE32(X)	(X)
+#define SDL_SwapLE64(X)	(X)
+#define SDL_SwapBE16(X)	SDL_Swap16(X)
+#define SDL_SwapBE32(X)	SDL_Swap32(X)
+#define SDL_SwapBE64(X)	SDL_Swap64(X)
+#else
+#define SDL_SwapLE16(X)	SDL_Swap16(X)
+#define SDL_SwapLE32(X)	SDL_Swap32(X)
+#define SDL_SwapLE64(X)	SDL_Swap64(X)
+#define SDL_SwapBE16(X)	(X)
+#define SDL_SwapBE32(X)	(X)
+#define SDL_SwapBE64(X)	(X)
+#endif
+
+/* Read an item of the specified endianness and return in native format */
+extern DECLSPEC Uint16 SDLCALL SDL_ReadLE16(SDL_RWops *src);
+extern DECLSPEC Uint16 SDLCALL SDL_ReadBE16(SDL_RWops *src);
+extern DECLSPEC Uint32 SDLCALL SDL_ReadLE32(SDL_RWops *src);
+extern DECLSPEC Uint32 SDLCALL SDL_ReadBE32(SDL_RWops *src);
+extern DECLSPEC Uint64 SDLCALL SDL_ReadLE64(SDL_RWops *src);
+extern DECLSPEC Uint64 SDLCALL SDL_ReadBE64(SDL_RWops *src);
+
+/* Write an item of native format to the specified endianness */
+extern DECLSPEC int SDLCALL SDL_WriteLE16(SDL_RWops *dst, Uint16 value);
+extern DECLSPEC int SDLCALL SDL_WriteBE16(SDL_RWops *dst, Uint16 value);
+extern DECLSPEC int SDLCALL SDL_WriteLE32(SDL_RWops *dst, Uint32 value);
+extern DECLSPEC int SDLCALL SDL_WriteBE32(SDL_RWops *dst, Uint32 value);
+extern DECLSPEC int SDLCALL SDL_WriteLE64(SDL_RWops *dst, Uint64 value);
+extern DECLSPEC int SDLCALL SDL_WriteBE64(SDL_RWops *dst, Uint64 value);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_endian_h */

Added: trunk/msvc-libs/include/SDL/SDL_error.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_error.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_error.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,62 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_error.h,v 1.8 2004/11/15 23:30:07 slouken Exp $&quot;;
+#endif
+
+/* Simple error message routines for SDL */
+
+#ifndef _SDL_error_h
+#define _SDL_error_h
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Public functions */
+extern DECLSPEC void SDLCALL SDL_SetError(const char *fmt, ...);
+extern DECLSPEC char * SDLCALL SDL_GetError(void);
+extern DECLSPEC void SDLCALL SDL_ClearError(void);
+
+/* Private error message function - used internally */
+#define SDL_OutOfMemory()	SDL_Error(SDL_ENOMEM)
+typedef enum {
+	SDL_ENOMEM,
+	SDL_EFREAD,
+	SDL_EFWRITE,
+	SDL_EFSEEK,
+	SDL_LASTERROR
+} SDL_errorcode;
+extern DECLSPEC void SDLCALL SDL_Error(SDL_errorcode code);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_error_h */

Added: trunk/msvc-libs/include/SDL/SDL_events.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_events.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_events.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,334 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_events.h,v 1.11 2004/08/20 18:57:01 slouken Exp $&quot;;
+#endif
+
+/* Include file for SDL event handling */
+
+#ifndef _SDL_events_h
+#define _SDL_events_h
+
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_active.h&quot;
+#include &quot;SDL_keyboard.h&quot;
+#include &quot;SDL_mouse.h&quot;
+#include &quot;SDL_joystick.h&quot;
+#include &quot;SDL_quit.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Event enumerations */
+enum { SDL_NOEVENT = 0,			/* Unused (do not remove) */
+       SDL_ACTIVEEVENT,			/* Application loses/gains visibility */
+       SDL_KEYDOWN,			/* Keys pressed */
+       SDL_KEYUP,			/* Keys released */
+       SDL_MOUSEMOTION,			/* Mouse moved */
+       SDL_MOUSEBUTTONDOWN,		/* Mouse button pressed */
+       SDL_MOUSEBUTTONUP,		/* Mouse button released */
+       SDL_JOYAXISMOTION,		/* Joystick axis motion */
+       SDL_JOYBALLMOTION,		/* Joystick trackball motion */
+       SDL_JOYHATMOTION,		/* Joystick hat position change */
+       SDL_JOYBUTTONDOWN,		/* Joystick button pressed */
+       SDL_JOYBUTTONUP,			/* Joystick button released */
+       SDL_QUIT,			/* User-requested quit */
+       SDL_SYSWMEVENT,			/* System specific event */
+       SDL_EVENT_RESERVEDA,		/* Reserved for future use.. */
+       SDL_EVENT_RESERVEDB,		/* Reserved for future use.. */
+       SDL_VIDEORESIZE,			/* User resized video mode */
+       SDL_VIDEOEXPOSE,			/* Screen needs to be redrawn */
+       SDL_EVENT_RESERVED2,		/* Reserved for future use.. */
+       SDL_EVENT_RESERVED3,		/* Reserved for future use.. */
+       SDL_EVENT_RESERVED4,		/* Reserved for future use.. */
+       SDL_EVENT_RESERVED5,		/* Reserved for future use.. */
+       SDL_EVENT_RESERVED6,		/* Reserved for future use.. */
+       SDL_EVENT_RESERVED7,		/* Reserved for future use.. */
+       /* Events SDL_USEREVENT through SDL_MAXEVENTS-1 are for your use */
+       SDL_USEREVENT = 24,
+       /* This last event is only for bounding internal arrays
+	  It is the number of bits in the event mask datatype -- Uint32
+        */
+       SDL_NUMEVENTS = 32
+};
+
+/* Predefined event masks */
+#define SDL_EVENTMASK(X)	(1&lt;&lt;(X))
+enum {
+	SDL_ACTIVEEVENTMASK	= SDL_EVENTMASK(SDL_ACTIVEEVENT),
+	SDL_KEYDOWNMASK		= SDL_EVENTMASK(SDL_KEYDOWN),
+	SDL_KEYUPMASK		= SDL_EVENTMASK(SDL_KEYUP),
+	SDL_MOUSEMOTIONMASK	= SDL_EVENTMASK(SDL_MOUSEMOTION),
+	SDL_MOUSEBUTTONDOWNMASK	= SDL_EVENTMASK(SDL_MOUSEBUTTONDOWN),
+	SDL_MOUSEBUTTONUPMASK	= SDL_EVENTMASK(SDL_MOUSEBUTTONUP),
+	SDL_MOUSEEVENTMASK	= SDL_EVENTMASK(SDL_MOUSEMOTION)|
+	                          SDL_EVENTMASK(SDL_MOUSEBUTTONDOWN)|
+	                          SDL_EVENTMASK(SDL_MOUSEBUTTONUP),
+	SDL_JOYAXISMOTIONMASK	= SDL_EVENTMASK(SDL_JOYAXISMOTION),
+	SDL_JOYBALLMOTIONMASK	= SDL_EVENTMASK(SDL_JOYBALLMOTION),
+	SDL_JOYHATMOTIONMASK	= SDL_EVENTMASK(SDL_JOYHATMOTION),
+	SDL_JOYBUTTONDOWNMASK	= SDL_EVENTMASK(SDL_JOYBUTTONDOWN),
+	SDL_JOYBUTTONUPMASK	= SDL_EVENTMASK(SDL_JOYBUTTONUP),
+	SDL_JOYEVENTMASK	= SDL_EVENTMASK(SDL_JOYAXISMOTION)|
+	                          SDL_EVENTMASK(SDL_JOYBALLMOTION)|
+	                          SDL_EVENTMASK(SDL_JOYHATMOTION)|
+	                          SDL_EVENTMASK(SDL_JOYBUTTONDOWN)|
+	                          SDL_EVENTMASK(SDL_JOYBUTTONUP),
+	SDL_VIDEORESIZEMASK	= SDL_EVENTMASK(SDL_VIDEORESIZE),
+	SDL_VIDEOEXPOSEMASK	= SDL_EVENTMASK(SDL_VIDEOEXPOSE),
+	SDL_QUITMASK		= SDL_EVENTMASK(SDL_QUIT),
+	SDL_SYSWMEVENTMASK	= SDL_EVENTMASK(SDL_SYSWMEVENT)
+};
+#define SDL_ALLEVENTS		0xFFFFFFFF
+
+/* Application visibility event structure */
+typedef struct SDL_ActiveEvent {
+	Uint8 type;	/* SDL_ACTIVEEVENT */
+	Uint8 gain;	/* Whether given states were gained or lost (1/0) */
+	Uint8 state;	/* A mask of the focus states */
+} SDL_ActiveEvent;
+
+/* Keyboard event structure */
+typedef struct SDL_KeyboardEvent {
+	Uint8 type;	/* SDL_KEYDOWN or SDL_KEYUP */
+	Uint8 which;	/* The keyboard device index */
+	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
+	SDL_keysym keysym;
+} SDL_KeyboardEvent;
+
+/* Mouse motion event structure */
+typedef struct SDL_MouseMotionEvent {
+	Uint8 type;	/* SDL_MOUSEMOTION */
+	Uint8 which;	/* The mouse device index */
+	Uint8 state;	/* The current button state */
+	Uint16 x, y;	/* The X/Y coordinates of the mouse */
+	Sint16 xrel;	/* The relative motion in the X direction */
+	Sint16 yrel;	/* The relative motion in the Y direction */
+} SDL_MouseMotionEvent;
+
+/* Mouse button event structure */
+typedef struct SDL_MouseButtonEvent {
+	Uint8 type;	/* SDL_MOUSEBUTTONDOWN or SDL_MOUSEBUTTONUP */
+	Uint8 which;	/* The mouse device index */
+	Uint8 button;	/* The mouse button index */
+	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
+	Uint16 x, y;	/* The X/Y coordinates of the mouse at press time */
+} SDL_MouseButtonEvent;
+
+/* Joystick axis motion event structure */
+typedef struct SDL_JoyAxisEvent {
+	Uint8 type;	/* SDL_JOYAXISMOTION */
+	Uint8 which;	/* The joystick device index */
+	Uint8 axis;	/* The joystick axis index */
+	Sint16 value;	/* The axis value (range: -32768 to 32767) */
+} SDL_JoyAxisEvent;
+
+/* Joystick trackball motion event structure */
+typedef struct SDL_JoyBallEvent {
+	Uint8 type;	/* SDL_JOYBALLMOTION */
+	Uint8 which;	/* The joystick device index */
+	Uint8 ball;	/* The joystick trackball index */
+	Sint16 xrel;	/* The relative motion in the X direction */
+	Sint16 yrel;	/* The relative motion in the Y direction */
+} SDL_JoyBallEvent;
+
+/* Joystick hat position change event structure */
+typedef struct SDL_JoyHatEvent {
+	Uint8 type;	/* SDL_JOYHATMOTION */
+	Uint8 which;	/* The joystick device index */
+	Uint8 hat;	/* The joystick hat index */
+	Uint8 value;	/* The hat position value:
+			    SDL_HAT_LEFTUP   SDL_HAT_UP       SDL_HAT_RIGHTUP
+			    SDL_HAT_LEFT     SDL_HAT_CENTERED SDL_HAT_RIGHT
+			    SDL_HAT_LEFTDOWN SDL_HAT_DOWN     SDL_HAT_RIGHTDOWN
+			   Note that zero means the POV is centered.
+			*/
+} SDL_JoyHatEvent;
+
+/* Joystick button event structure */
+typedef struct SDL_JoyButtonEvent {
+	Uint8 type;	/* SDL_JOYBUTTONDOWN or SDL_JOYBUTTONUP */
+	Uint8 which;	/* The joystick device index */
+	Uint8 button;	/* The joystick button index */
+	Uint8 state;	/* SDL_PRESSED or SDL_RELEASED */
+} SDL_JoyButtonEvent;
+
+/* The &quot;window resized&quot; event
+   When you get this event, you are responsible for setting a new video
+   mode with the new width and height.
+ */
+typedef struct SDL_ResizeEvent {
+	Uint8 type;	/* SDL_VIDEORESIZE */
+	int w;		/* New width */
+	int h;		/* New height */
+} SDL_ResizeEvent;
+
+/* The &quot;screen redraw&quot; event */
+typedef struct SDL_ExposeEvent {
+	Uint8 type;	/* SDL_VIDEOEXPOSE */
+} SDL_ExposeEvent;
+
+/* The &quot;quit requested&quot; event */
+typedef struct SDL_QuitEvent {
+	Uint8 type;	/* SDL_QUIT */
+} SDL_QuitEvent;
+
+/* A user-defined event type */
+typedef struct SDL_UserEvent {
+	Uint8 type;	/* SDL_USEREVENT through SDL_NUMEVENTS-1 */
+	int code;	/* User defined event code */
+	void *data1;	/* User defined data pointer */
+	void *data2;	/* User defined data pointer */
+} SDL_UserEvent;
+
+/* If you want to use this event, you should include SDL_syswm.h */
+struct SDL_SysWMmsg;
+typedef struct SDL_SysWMmsg SDL_SysWMmsg;
+typedef struct SDL_SysWMEvent {
+	Uint8 type;
+	SDL_SysWMmsg *msg;
+} SDL_SysWMEvent;
+
+/* General event structure */
+typedef union {
+	Uint8 type;
+	SDL_ActiveEvent active;
+	SDL_KeyboardEvent key;
+	SDL_MouseMotionEvent motion;
+	SDL_MouseButtonEvent button;
+	SDL_JoyAxisEvent jaxis;
+	SDL_JoyBallEvent jball;
+	SDL_JoyHatEvent jhat;
+	SDL_JoyButtonEvent jbutton;
+	SDL_ResizeEvent resize;
+	SDL_ExposeEvent expose;
+	SDL_QuitEvent quit;
+	SDL_UserEvent user;
+	SDL_SysWMEvent syswm;
+} SDL_Event;
+
+
+/* Function prototypes */
+
+/* Pumps the event loop, gathering events from the input devices.
+   This function updates the event queue and internal input device state.
+   This should only be run in the thread that sets the video mode.
+*/
+extern DECLSPEC void SDLCALL SDL_PumpEvents(void);
+
+/* Checks the event queue for messages and optionally returns them.
+   If 'action' is SDL_ADDEVENT, up to 'numevents' events will be added to
+   the back of the event queue.
+   If 'action' is SDL_PEEKEVENT, up to 'numevents' events at the front
+   of the event queue, matching 'mask', will be returned and will not
+   be removed from the queue.
+   If 'action' is SDL_GETEVENT, up to 'numevents' events at the front 
+   of the event queue, matching 'mask', will be returned and will be
+   removed from the queue.
+   This function returns the number of events actually stored, or -1
+   if there was an error.  This function is thread-safe.
+*/
+typedef enum {
+	SDL_ADDEVENT,
+	SDL_PEEKEVENT,
+	SDL_GETEVENT
+} SDL_eventaction;
+/* */
+extern DECLSPEC int SDLCALL SDL_PeepEvents(SDL_Event *events, int numevents,
+				SDL_eventaction action, Uint32 mask);
+
+/* Polls for currently pending events, and returns 1 if there are any pending
+   events, or 0 if there are none available.  If 'event' is not NULL, the next
+   event is removed from the queue and stored in that area.
+ */
+extern DECLSPEC int SDLCALL SDL_PollEvent(SDL_Event *event);
+
+/* Waits indefinitely for the next available event, returning 1, or 0 if there
+   was an error while waiting for events.  If 'event' is not NULL, the next
+   event is removed from the queue and stored in that area.
+ */
+extern DECLSPEC int SDLCALL SDL_WaitEvent(SDL_Event *event);
+
+/* Add an event to the event queue.
+   This function returns 0 on success, or -1 if the event queue was full
+   or there was some other error.
+ */
+extern DECLSPEC int SDLCALL SDL_PushEvent(SDL_Event *event);
+
+/*
+  This function sets up a filter to process all events before they
+  change internal state and are posted to the internal event queue.
+
+  The filter is protypted as:
+*/
+typedef int (SDLCALL *SDL_EventFilter)(const SDL_Event *event);
+/*
+  If the filter returns 1, then the event will be added to the internal queue.
+  If it returns 0, then the event will be dropped from the queue, but the 
+  internal state will still be updated.  This allows selective filtering of
+  dynamically arriving events.
+
+  WARNING:  Be very careful of what you do in the event filter function, as 
+            it may run in a different thread!
+
+  There is one caveat when dealing with the SDL_QUITEVENT event type.  The
+  event filter is only called when the window manager desires to close the
+  application window.  If the event filter returns 1, then the window will
+  be closed, otherwise the window will remain open if possible.
+  If the quit event is generated by an interrupt signal, it will bypass the
+  internal queue and be delivered to the application at the next event poll.
+*/
+extern DECLSPEC void SDLCALL SDL_SetEventFilter(SDL_EventFilter filter);
+
+/*
+  Return the current event filter - can be used to &quot;chain&quot; filters.
+  If there is no event filter set, this function returns NULL.
+*/
+extern DECLSPEC SDL_EventFilter SDLCALL SDL_GetEventFilter(void);
+
+/*
+  This function allows you to set the state of processing certain events.
+  If 'state' is set to SDL_IGNORE, that event will be automatically dropped
+  from the event queue and will not event be filtered.
+  If 'state' is set to SDL_ENABLE, that event will be processed normally.
+  If 'state' is set to SDL_QUERY, SDL_EventState() will return the 
+  current processing state of the specified event.
+*/
+#define SDL_QUERY	-1
+#define SDL_IGNORE	 0
+#define SDL_DISABLE	 0
+#define SDL_ENABLE	 1
+extern DECLSPEC Uint8 SDLCALL SDL_EventState(Uint8 type, int state);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_events_h */

Added: trunk/msvc-libs/include/SDL/SDL_getenv.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_getenv.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_getenv.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,30 @@
+
+/* Not all environments have a working getenv()/putenv() */
+
+#if defined(macintosh) || defined(_WIN32_WCE)
+#define NEED_SDL_GETENV
+#endif
+
+#ifdef NEED_SDL_GETENV
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Put a variable of the form &quot;name=value&quot; into the environment */
+extern DECLSPEC int SDLCALL SDL_putenv(const char *variable);
+#define putenv(X)   SDL_putenv(X)
+
+/* Retrieve a variable named &quot;name&quot; from the environment */
+extern DECLSPEC char * SDLCALL SDL_getenv(const char *name);
+#define getenv(X)     SDL_getenv(X)
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* NEED_GETENV */

Added: trunk/msvc-libs/include/SDL/SDL_joystick.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_joystick.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_joystick.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,171 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_joystick.h,v 1.7 2004/07/18 19:05:06 slouken Exp $&quot;;
+#endif
+
+/* Include file for SDL joystick event handling */
+
+#ifndef _SDL_joystick_h
+#define _SDL_joystick_h
+
+#include &quot;SDL_types.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* In order to use these functions, SDL_Init() must have been called
+   with the SDL_INIT_JOYSTICK flag.  This causes SDL to scan the system
+   for joysticks, and load appropriate drivers.
+*/
+
+/* The joystick structure used to identify an SDL joystick */
+struct _SDL_Joystick;
+typedef struct _SDL_Joystick SDL_Joystick;
+
+
+/* Function prototypes */
+/*
+ * Count the number of joysticks attached to the system
+ */
+extern DECLSPEC int SDLCALL SDL_NumJoysticks(void);
+
+/*
+ * Get the implementation dependent name of a joystick.
+ * This can be called before any joysticks are opened.
+ * If no name can be found, this function returns NULL.
+ */
+extern DECLSPEC const char * SDLCALL SDL_JoystickName(int device_index);
+
+/*
+ * Open a joystick for use - the index passed as an argument refers to
+ * the N'th joystick on the system.  This index is the value which will
+ * identify this joystick in future joystick events.
+ *
+ * This function returns a joystick identifier, or NULL if an error occurred.
+ */
+extern DECLSPEC SDL_Joystick * SDLCALL SDL_JoystickOpen(int device_index);
+
+/*
+ * Returns 1 if the joystick has been opened, or 0 if it has not.
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickOpened(int device_index);
+
+/*
+ * Get the device index of an opened joystick.
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickIndex(SDL_Joystick *joystick);
+
+/*
+ * Get the number of general axis controls on a joystick
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickNumAxes(SDL_Joystick *joystick);
+
+/*
+ * Get the number of trackballs on a joystick
+ * Joystick trackballs have only relative motion events associated
+ * with them and their state cannot be polled.
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickNumBalls(SDL_Joystick *joystick);
+
+/*
+ * Get the number of POV hats on a joystick
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickNumHats(SDL_Joystick *joystick);
+
+/*
+ * Get the number of buttons on a joystick
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickNumButtons(SDL_Joystick *joystick);
+
+/*
+ * Update the current state of the open joysticks.
+ * This is called automatically by the event loop if any joystick
+ * events are enabled.
+ */
+extern DECLSPEC void SDLCALL SDL_JoystickUpdate(void);
+
+/*
+ * Enable/disable joystick event polling.
+ * If joystick events are disabled, you must call SDL_JoystickUpdate()
+ * yourself and check the state of the joystick when you want joystick
+ * information.
+ * The state can be one of SDL_QUERY, SDL_ENABLE or SDL_IGNORE.
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickEventState(int state);
+
+/*
+ * Get the current state of an axis control on a joystick
+ * The state is a value ranging from -32768 to 32767.
+ * The axis indices start at index 0.
+ */
+extern DECLSPEC Sint16 SDLCALL SDL_JoystickGetAxis(SDL_Joystick *joystick, int axis);
+
+/*
+ * Get the current state of a POV hat on a joystick
+ * The return value is one of the following positions:
+ */
+#define SDL_HAT_CENTERED	0x00
+#define SDL_HAT_UP		0x01
+#define SDL_HAT_RIGHT		0x02
+#define SDL_HAT_DOWN		0x04
+#define SDL_HAT_LEFT		0x08
+#define SDL_HAT_RIGHTUP		(SDL_HAT_RIGHT|SDL_HAT_UP)
+#define SDL_HAT_RIGHTDOWN	(SDL_HAT_RIGHT|SDL_HAT_DOWN)
+#define SDL_HAT_LEFTUP		(SDL_HAT_LEFT|SDL_HAT_UP)
+#define SDL_HAT_LEFTDOWN	(SDL_HAT_LEFT|SDL_HAT_DOWN)
+/*
+ * The hat indices start at index 0.
+ */
+extern DECLSPEC Uint8 SDLCALL SDL_JoystickGetHat(SDL_Joystick *joystick, int hat);
+
+/*
+ * Get the ball axis change since the last poll
+ * This returns 0, or -1 if you passed it invalid parameters.
+ * The ball indices start at index 0.
+ */
+extern DECLSPEC int SDLCALL SDL_JoystickGetBall(SDL_Joystick *joystick, int ball, int *dx, int *dy);
+
+/*
+ * Get the current state of a button on a joystick
+ * The button indices start at index 0.
+ */
+extern DECLSPEC Uint8 SDLCALL SDL_JoystickGetButton(SDL_Joystick *joystick, int button);
+
+/*
+ * Close a joystick previously opened with SDL_JoystickOpen()
+ */
+extern DECLSPEC void SDLCALL SDL_JoystickClose(SDL_Joystick *joystick);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_joystick_h */

Added: trunk/msvc-libs/include/SDL/SDL_keyboard.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_keyboard.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_keyboard.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,124 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_keyboard.h,v 1.7 2004/07/18 22:57:40 slouken Exp $&quot;;
+#endif
+
+/* Include file for SDL keyboard event handling */
+
+#ifndef _SDL_keyboard_h
+#define _SDL_keyboard_h
+
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_keysym.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Keysym structure
+   - The scancode is hardware dependent, and should not be used by general
+     applications.  If no hardware scancode is available, it will be 0.
+
+   - The 'unicode' translated character is only available when character
+     translation is enabled by the SDL_EnableUNICODE() API.  If non-zero,
+     this is a UNICODE character corresponding to the keypress.  If the
+     high 9 bits of the character are 0, then this maps to the equivalent
+     ASCII character:
+	char ch;
+	if ( (keysym.unicode &amp; 0xFF80) == 0 ) {
+		ch = keysym.unicode &amp; 0x7F;
+	} else {
+		An international character..
+	}
+ */
+typedef struct SDL_keysym {
+	Uint8 scancode;			/* hardware specific scancode */
+	SDLKey sym;			/* SDL virtual keysym */
+	SDLMod mod;			/* current key modifiers */
+	Uint16 unicode;			/* translated character */
+} SDL_keysym;
+
+/* This is the mask which refers to all hotkey bindings */
+#define SDL_ALL_HOTKEYS		0xFFFFFFFF
+
+/* Function prototypes */
+/*
+ * Enable/Disable UNICODE translation of keyboard input.
+ * This translation has some overhead, so translation defaults off.
+ * If 'enable' is 1, translation is enabled.
+ * If 'enable' is 0, translation is disabled.
+ * If 'enable' is -1, the translation state is not changed.
+ * It returns the previous state of keyboard translation.
+ */
+extern DECLSPEC int SDLCALL SDL_EnableUNICODE(int enable);
+
+/*
+ * Enable/Disable keyboard repeat.  Keyboard repeat defaults to off.
+ * 'delay' is the initial delay in ms between the time when a key is
+ * pressed, and keyboard repeat begins.
+ * 'interval' is the time in ms between keyboard repeat events.
+ */
+#define SDL_DEFAULT_REPEAT_DELAY	500
+#define SDL_DEFAULT_REPEAT_INTERVAL	30
+/*
+ * If 'delay' is set to 0, keyboard repeat is disabled.
+ */
+extern DECLSPEC int SDLCALL SDL_EnableKeyRepeat(int delay, int interval);
+
+/*
+ * Get a snapshot of the current state of the keyboard.
+ * Returns an array of keystates, indexed by the SDLK_* syms.
+ * Used:
+ * 	Uint8 *keystate = SDL_GetKeyState(NULL);
+ *	if ( keystate[SDLK_RETURN] ) ... &lt;RETURN&gt; is pressed.
+ */
+extern DECLSPEC Uint8 * SDLCALL SDL_GetKeyState(int *numkeys);
+
+/*
+ * Get the current key modifier state
+ */
+extern DECLSPEC SDLMod SDLCALL SDL_GetModState(void);
+
+/*
+ * Set the current key modifier state
+ * This does not change the keyboard state, only the key modifier flags.
+ */
+extern DECLSPEC void SDLCALL SDL_SetModState(SDLMod modstate);
+
+/*
+ * Get the name of an SDL virtual keysym
+ */
+extern DECLSPEC char * SDLCALL SDL_GetKeyName(SDLKey key);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_keyboard_h */

Added: trunk/msvc-libs/include/SDL/SDL_keysym.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_keysym.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_keysym.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,316 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_keysym.h,v 1.6 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+
+#ifndef _SDL_keysym_h
+#define _SDL_keysym_h
+
+/* What we really want is a mapping of every raw key on the keyboard.
+   To support international keyboards, we use the range 0xA1 - 0xFF
+   as international virtual keycodes.  We'll follow in the footsteps of X11...
+   The names of the keys
+ */
+ 
+typedef enum {
+	/* The keyboard syms have been cleverly chosen to map to ASCII */
+	SDLK_UNKNOWN		= 0,
+	SDLK_FIRST		= 0,
+	SDLK_BACKSPACE		= 8,
+	SDLK_TAB		= 9,
+	SDLK_CLEAR		= 12,
+	SDLK_RETURN		= 13,
+	SDLK_PAUSE		= 19,
+	SDLK_ESCAPE		= 27,
+	SDLK_SPACE		= 32,
+	SDLK_EXCLAIM		= 33,
+	SDLK_QUOTEDBL		= 34,
+	SDLK_HASH		= 35,
+	SDLK_DOLLAR		= 36,
+	SDLK_AMPERSAND		= 38,
+	SDLK_QUOTE		= 39,
+	SDLK_LEFTPAREN		= 40,
+	SDLK_RIGHTPAREN		= 41,
+	SDLK_ASTERISK		= 42,
+	SDLK_PLUS		= 43,
+	SDLK_COMMA		= 44,
+	SDLK_MINUS		= 45,
+	SDLK_PERIOD		= 46,
+	SDLK_SLASH		= 47,
+	SDLK_0			= 48,
+	SDLK_1			= 49,
+	SDLK_2			= 50,
+	SDLK_3			= 51,
+	SDLK_4			= 52,
+	SDLK_5			= 53,
+	SDLK_6			= 54,
+	SDLK_7			= 55,
+	SDLK_8			= 56,
+	SDLK_9			= 57,
+	SDLK_COLON		= 58,
+	SDLK_SEMICOLON		= 59,
+	SDLK_LESS		= 60,
+	SDLK_EQUALS		= 61,
+	SDLK_GREATER		= 62,
+	SDLK_QUESTION		= 63,
+	SDLK_AT			= 64,
+	/* 
+	   Skip uppercase letters
+	 */
+	SDLK_LEFTBRACKET	= 91,
+	SDLK_BACKSLASH		= 92,
+	SDLK_RIGHTBRACKET	= 93,
+	SDLK_CARET		= 94,
+	SDLK_UNDERSCORE		= 95,
+	SDLK_BACKQUOTE		= 96,
+	SDLK_a			= 97,
+	SDLK_b			= 98,
+	SDLK_c			= 99,
+	SDLK_d			= 100,
+	SDLK_e			= 101,
+	SDLK_f			= 102,
+	SDLK_g			= 103,
+	SDLK_h			= 104,
+	SDLK_i			= 105,
+	SDLK_j			= 106,
+	SDLK_k			= 107,
+	SDLK_l			= 108,
+	SDLK_m			= 109,
+	SDLK_n			= 110,
+	SDLK_o			= 111,
+	SDLK_p			= 112,
+	SDLK_q			= 113,
+	SDLK_r			= 114,
+	SDLK_s			= 115,
+	SDLK_t			= 116,
+	SDLK_u			= 117,
+	SDLK_v			= 118,
+	SDLK_w			= 119,
+	SDLK_x			= 120,
+	SDLK_y			= 121,
+	SDLK_z			= 122,
+	SDLK_DELETE		= 127,
+	/* End of ASCII mapped keysyms */
+
+	/* International keyboard syms */
+	SDLK_WORLD_0		= 160,		/* 0xA0 */
+	SDLK_WORLD_1		= 161,
+	SDLK_WORLD_2		= 162,
+	SDLK_WORLD_3		= 163,
+	SDLK_WORLD_4		= 164,
+	SDLK_WORLD_5		= 165,
+	SDLK_WORLD_6		= 166,
+	SDLK_WORLD_7		= 167,
+	SDLK_WORLD_8		= 168,
+	SDLK_WORLD_9		= 169,
+	SDLK_WORLD_10		= 170,
+	SDLK_WORLD_11		= 171,
+	SDLK_WORLD_12		= 172,
+	SDLK_WORLD_13		= 173,
+	SDLK_WORLD_14		= 174,
+	SDLK_WORLD_15		= 175,
+	SDLK_WORLD_16		= 176,
+	SDLK_WORLD_17		= 177,
+	SDLK_WORLD_18		= 178,
+	SDLK_WORLD_19		= 179,
+	SDLK_WORLD_20		= 180,
+	SDLK_WORLD_21		= 181,
+	SDLK_WORLD_22		= 182,
+	SDLK_WORLD_23		= 183,
+	SDLK_WORLD_24		= 184,
+	SDLK_WORLD_25		= 185,
+	SDLK_WORLD_26		= 186,
+	SDLK_WORLD_27		= 187,
+	SDLK_WORLD_28		= 188,
+	SDLK_WORLD_29		= 189,
+	SDLK_WORLD_30		= 190,
+	SDLK_WORLD_31		= 191,
+	SDLK_WORLD_32		= 192,
+	SDLK_WORLD_33		= 193,
+	SDLK_WORLD_34		= 194,
+	SDLK_WORLD_35		= 195,
+	SDLK_WORLD_36		= 196,
+	SDLK_WORLD_37		= 197,
+	SDLK_WORLD_38		= 198,
+	SDLK_WORLD_39		= 199,
+	SDLK_WORLD_40		= 200,
+	SDLK_WORLD_41		= 201,
+	SDLK_WORLD_42		= 202,
+	SDLK_WORLD_43		= 203,
+	SDLK_WORLD_44		= 204,
+	SDLK_WORLD_45		= 205,
+	SDLK_WORLD_46		= 206,
+	SDLK_WORLD_47		= 207,
+	SDLK_WORLD_48		= 208,
+	SDLK_WORLD_49		= 209,
+	SDLK_WORLD_50		= 210,
+	SDLK_WORLD_51		= 211,
+	SDLK_WORLD_52		= 212,
+	SDLK_WORLD_53		= 213,
+	SDLK_WORLD_54		= 214,
+	SDLK_WORLD_55		= 215,
+	SDLK_WORLD_56		= 216,
+	SDLK_WORLD_57		= 217,
+	SDLK_WORLD_58		= 218,
+	SDLK_WORLD_59		= 219,
+	SDLK_WORLD_60		= 220,
+	SDLK_WORLD_61		= 221,
+	SDLK_WORLD_62		= 222,
+	SDLK_WORLD_63		= 223,
+	SDLK_WORLD_64		= 224,
+	SDLK_WORLD_65		= 225,
+	SDLK_WORLD_66		= 226,
+	SDLK_WORLD_67		= 227,
+	SDLK_WORLD_68		= 228,
+	SDLK_WORLD_69		= 229,
+	SDLK_WORLD_70		= 230,
+	SDLK_WORLD_71		= 231,
+	SDLK_WORLD_72		= 232,
+	SDLK_WORLD_73		= 233,
+	SDLK_WORLD_74		= 234,
+	SDLK_WORLD_75		= 235,
+	SDLK_WORLD_76		= 236,
+	SDLK_WORLD_77		= 237,
+	SDLK_WORLD_78		= 238,
+	SDLK_WORLD_79		= 239,
+	SDLK_WORLD_80		= 240,
+	SDLK_WORLD_81		= 241,
+	SDLK_WORLD_82		= 242,
+	SDLK_WORLD_83		= 243,
+	SDLK_WORLD_84		= 244,
+	SDLK_WORLD_85		= 245,
+	SDLK_WORLD_86		= 246,
+	SDLK_WORLD_87		= 247,
+	SDLK_WORLD_88		= 248,
+	SDLK_WORLD_89		= 249,
+	SDLK_WORLD_90		= 250,
+	SDLK_WORLD_91		= 251,
+	SDLK_WORLD_92		= 252,
+	SDLK_WORLD_93		= 253,
+	SDLK_WORLD_94		= 254,
+	SDLK_WORLD_95		= 255,		/* 0xFF */
+
+	/* Numeric keypad */
+	SDLK_KP0		= 256,
+	SDLK_KP1		= 257,
+	SDLK_KP2		= 258,
+	SDLK_KP3		= 259,
+	SDLK_KP4		= 260,
+	SDLK_KP5		= 261,
+	SDLK_KP6		= 262,
+	SDLK_KP7		= 263,
+	SDLK_KP8		= 264,
+	SDLK_KP9		= 265,
+	SDLK_KP_PERIOD		= 266,
+	SDLK_KP_DIVIDE		= 267,
+	SDLK_KP_MULTIPLY	= 268,
+	SDLK_KP_MINUS		= 269,
+	SDLK_KP_PLUS		= 270,
+	SDLK_KP_ENTER		= 271,
+	SDLK_KP_EQUALS		= 272,
+
+	/* Arrows + Home/End pad */
+	SDLK_UP			= 273,
+	SDLK_DOWN		= 274,
+	SDLK_RIGHT		= 275,
+	SDLK_LEFT		= 276,
+	SDLK_INSERT		= 277,
+	SDLK_HOME		= 278,
+	SDLK_END		= 279,
+	SDLK_PAGEUP		= 280,
+	SDLK_PAGEDOWN		= 281,
+
+	/* Function keys */
+	SDLK_F1			= 282,
+	SDLK_F2			= 283,
+	SDLK_F3			= 284,
+	SDLK_F4			= 285,
+	SDLK_F5			= 286,
+	SDLK_F6			= 287,
+	SDLK_F7			= 288,
+	SDLK_F8			= 289,
+	SDLK_F9			= 290,
+	SDLK_F10		= 291,
+	SDLK_F11		= 292,
+	SDLK_F12		= 293,
+	SDLK_F13		= 294,
+	SDLK_F14		= 295,
+	SDLK_F15		= 296,
+
+	/* Key state modifier keys */
+	SDLK_NUMLOCK		= 300,
+	SDLK_CAPSLOCK		= 301,
+	SDLK_SCROLLOCK		= 302,
+	SDLK_RSHIFT		= 303,
+	SDLK_LSHIFT		= 304,
+	SDLK_RCTRL		= 305,
+	SDLK_LCTRL		= 306,
+	SDLK_RALT		= 307,
+	SDLK_LALT		= 308,
+	SDLK_RMETA		= 309,
+	SDLK_LMETA		= 310,
+	SDLK_LSUPER		= 311,		/* Left &quot;Windows&quot; key */
+	SDLK_RSUPER		= 312,		/* Right &quot;Windows&quot; key */
+	SDLK_MODE		= 313,		/* &quot;Alt Gr&quot; key */
+	SDLK_COMPOSE		= 314,		/* Multi-key compose key */
+
+	/* Miscellaneous function keys */
+	SDLK_HELP		= 315,
+	SDLK_PRINT		= 316,
+	SDLK_SYSREQ		= 317,
+	SDLK_BREAK		= 318,
+	SDLK_MENU		= 319,
+	SDLK_POWER		= 320,		/* Power Macintosh power key */
+	SDLK_EURO		= 321,		/* Some european keyboards */
+	SDLK_UNDO		= 322,		/* Atari keyboard has Undo */
+
+	/* Add any other keys here */
+
+	SDLK_LAST
+} SDLKey;
+
+/* Enumeration of valid key mods (possibly OR'd together) */
+typedef enum {
+	KMOD_NONE  = 0x0000,
+	KMOD_LSHIFT= 0x0001,
+	KMOD_RSHIFT= 0x0002,
+	KMOD_LCTRL = 0x0040,
+	KMOD_RCTRL = 0x0080,
+	KMOD_LALT  = 0x0100,
+	KMOD_RALT  = 0x0200,
+	KMOD_LMETA = 0x0400,
+	KMOD_RMETA = 0x0800,
+	KMOD_NUM   = 0x1000,
+	KMOD_CAPS  = 0x2000,
+	KMOD_MODE  = 0x4000,
+	KMOD_RESERVED = 0x8000
+} SDLMod;
+
+#define KMOD_CTRL	(KMOD_LCTRL|KMOD_RCTRL)
+#define KMOD_SHIFT	(KMOD_LSHIFT|KMOD_RSHIFT)
+#define KMOD_ALT	(KMOD_LALT|KMOD_RALT)
+#define KMOD_META	(KMOD_LMETA|KMOD_RMETA)
+
+#endif /* _SDL_keysym_h */

Added: trunk/msvc-libs/include/SDL/SDL_loadso.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_loadso.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_loadso.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,76 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_loadso.h,v 1.5 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* System dependent library loading routines                           */
+
+/* Some things to keep in mind:                                        
+   - These functions only work on C function names.  Other languages may
+     have name mangling and intrinsic language support that varies from
+     compiler to compiler.
+   - Make sure you declare your function pointers with the same calling
+     convention as the actual library function.  Your code will crash
+     mysteriously if you do not do this.
+   - Avoid namespace collisions.  If you load a symbol from the library,
+     it is not defined whether or not it goes into the global symbol
+     namespace for the application.  If it does and it conflicts with
+     symbols in your code or other shared libraries, you will not get
+     the results you expect. :)
+*/
+
+
+#ifndef _SDL_loadso_h
+#define _SDL_loadso_h
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This function dynamically loads a shared object and returns a pointer
+ * to the object handle (or NULL if there was an error).
+ * The 'sofile' parameter is a system dependent name of the object file.
+ */
+extern DECLSPEC void * SDLCALL SDL_LoadObject(const char *sofile);
+
+/* Given an object handle, this function looks up the address of the
+ * named function in the shared object and returns it.  This address
+ * is no longer valid after calling SDL_UnloadObject().
+ */
+extern DECLSPEC void * SDLCALL SDL_LoadFunction(void *handle, const char *name);
+
+/* Unload a shared object from memory */
+extern DECLSPEC void SDLCALL SDL_UnloadObject(void *handle);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_loadso_h */

Added: trunk/msvc-libs/include/SDL/SDL_main.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_main.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_main.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,101 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_main.h,v 1.12 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+
+#ifndef _SDL_main_h
+#define _SDL_main_h
+
+/* Redefine main() on Win32 and MacOS so that it is called by winmain.c */
+
+#if defined(WIN32) || defined(_WIN32) || \
+    (defined(__MWERKS__) &amp;&amp; !defined(__BEOS__)) || \
+    defined(macintosh) || defined(__APPLE__) || \
+    defined(__SYMBIAN32__) || defined(QWS)
+
+#ifdef __cplusplus
+#define C_LINKAGE	&quot;C&quot;
+#else
+#define C_LINKAGE
+#endif /* __cplusplus */
+
+/* The application's main() function must be called with C linkage,
+   and should be declared like this:
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+	int main(int argc, char *argv[])
+	{
+	}
+ */
+#define main	SDL_main
+
+/* The prototype for the application's main() function */
+extern C_LINKAGE int SDL_main(int argc, char *argv[]);
+
+
+/* From the SDL library code -- needed for registering the app on Win32 */
+#if defined(WIN32)
+#include &quot;SDL_types.h&quot;
+#include &quot;begin_code.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This should be called from your WinMain() function, if any */
+extern DECLSPEC void SDLCALL SDL_SetModuleHandle(void *hInst);
+/* This can also be called, but is no longer necessary */
+extern DECLSPEC int SDLCALL SDL_RegisterApp(char *name, Uint32 style, void *hInst);
+
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+#endif
+
+/* From the SDL library code -- needed for registering QuickDraw on MacOS */
+#if defined(macintosh)
+#include &quot;begin_code.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Forward declaration so we don't need to include QuickDraw.h */
+struct QDGlobals;
+
+/* This should be called from your main() function, if any */
+extern DECLSPEC void SDLCALL SDL_InitQuickDraw(struct QDGlobals *the_qd);
+
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+#endif
+
+#endif /* Need to redefine main()? */
+
+#endif /* _SDL_main_h */

Added: trunk/msvc-libs/include/SDL/SDL_mouse.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_mouse.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_mouse.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,140 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_mouse.h,v 1.8 2004/07/18 22:57:40 slouken Exp $&quot;;
+#endif
+
+/* Include file for SDL mouse event handling */
+
+#ifndef _SDL_mouse_h
+#define _SDL_mouse_h
+
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_video.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct WMcursor WMcursor;	/* Implementation dependent */
+typedef struct SDL_Cursor {
+	SDL_Rect area;			/* The area of the mouse cursor */
+	Sint16 hot_x, hot_y;		/* The &quot;tip&quot; of the cursor */
+	Uint8 *data;			/* B/W cursor data */
+	Uint8 *mask;			/* B/W cursor mask */
+	Uint8 *save[2];			/* Place to save cursor area */
+	WMcursor *wm_cursor;		/* Window-manager cursor */
+} SDL_Cursor;
+
+/* Function prototypes */
+/*
+ * Retrieve the current state of the mouse.
+ * The current button state is returned as a button bitmask, which can
+ * be tested using the SDL_BUTTON(X) macros, and x and y are set to the
+ * current mouse cursor position.  You can pass NULL for either x or y.
+ */
+extern DECLSPEC Uint8 SDLCALL SDL_GetMouseState(int *x, int *y);
+
+/*
+ * Retrieve the current state of the mouse.
+ * The current button state is returned as a button bitmask, which can
+ * be tested using the SDL_BUTTON(X) macros, and x and y are set to the
+ * mouse deltas since the last call to SDL_GetRelativeMouseState().
+ */
+extern DECLSPEC Uint8 SDLCALL SDL_GetRelativeMouseState(int *x, int *y);
+
+/*
+ * Set the position of the mouse cursor (generates a mouse motion event)
+ */
+extern DECLSPEC void SDLCALL SDL_WarpMouse(Uint16 x, Uint16 y);
+
+/*
+ * Create a cursor using the specified data and mask (in MSB format).
+ * The cursor width must be a multiple of 8 bits.
+ *
+ * The cursor is created in black and white according to the following:
+ * data  mask    resulting pixel on screen
+ *  0     1       White
+ *  1     1       Black
+ *  0     0       Transparent
+ *  1     0       Inverted color if possible, black if not.
+ *
+ * Cursors created with this function must be freed with SDL_FreeCursor().
+ */
+extern DECLSPEC SDL_Cursor * SDLCALL SDL_CreateCursor
+		(Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y);
+
+/*
+ * Set the currently active cursor to the specified one.
+ * If the cursor is currently visible, the change will be immediately 
+ * represented on the display.
+ */
+extern DECLSPEC void SDLCALL SDL_SetCursor(SDL_Cursor *cursor);
+
+/*
+ * Returns the currently active cursor.
+ */
+extern DECLSPEC SDL_Cursor * SDLCALL SDL_GetCursor(void);
+
+/*
+ * Deallocates a cursor created with SDL_CreateCursor().
+ */
+extern DECLSPEC void SDLCALL SDL_FreeCursor(SDL_Cursor *cursor);
+
+/*
+ * Toggle whether or not the cursor is shown on the screen.
+ * The cursor start off displayed, but can be turned off.
+ * SDL_ShowCursor() returns 1 if the cursor was being displayed
+ * before the call, or 0 if it was not.  You can query the current
+ * state by passing a 'toggle' value of -1.
+ */
+extern DECLSPEC int SDLCALL SDL_ShowCursor(int toggle);
+
+/* Used as a mask when testing buttons in buttonstate
+   Button 1:	Left mouse button
+   Button 2:	Middle mouse button
+   Button 3:	Right mouse button
+   Button 4:	Mouse wheel up	 (may also be a real button)
+   Button 5:	Mouse wheel down (may also be a real button)
+ */
+#define SDL_BUTTON(X)		(SDL_PRESSED&lt;&lt;(X-1))
+#define SDL_BUTTON_LEFT		1
+#define SDL_BUTTON_MIDDLE	2
+#define SDL_BUTTON_RIGHT	3
+#define SDL_BUTTON_WHEELUP	4
+#define SDL_BUTTON_WHEELDOWN	5
+#define SDL_BUTTON_LMASK	SDL_BUTTON(SDL_BUTTON_LEFT)
+#define SDL_BUTTON_MMASK	SDL_BUTTON(SDL_BUTTON_MIDDLE)
+#define SDL_BUTTON_RMASK	SDL_BUTTON(SDL_BUTTON_RIGHT)
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_mouse_h */

Added: trunk/msvc-libs/include/SDL/SDL_mutex.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_mutex.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_mutex.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,166 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_mutex.h,v 1.7 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+
+#ifndef _SDL_mutex_h
+#define _SDL_mutex_h
+
+/* Functions to provide thread synchronization primitives
+
+	These are independent of the other SDL routines.
+*/
+
+#include &quot;SDL_main.h&quot;
+#include &quot;SDL_types.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Synchronization functions which can time out return this value
+   if they time out.
+*/
+#define SDL_MUTEX_TIMEDOUT	1
+
+/* This is the timeout value which corresponds to never time out */
+#define SDL_MUTEX_MAXWAIT	(~(Uint32)0)
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* Mutex functions                                               */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* The SDL mutex structure, defined in SDL_mutex.c */
+struct SDL_mutex;
+typedef struct SDL_mutex SDL_mutex;
+
+/* Create a mutex, initialized unlocked */
+extern DECLSPEC SDL_mutex * SDLCALL SDL_CreateMutex(void);
+
+/* Lock the mutex  (Returns 0, or -1 on error) */
+#define SDL_LockMutex(m)	SDL_mutexP(m)
+extern DECLSPEC int SDLCALL SDL_mutexP(SDL_mutex *mutex);
+
+/* Unlock the mutex  (Returns 0, or -1 on error)
+   It is an error to unlock a mutex that has not been locked by
+   the current thread, and doing so results in undefined behavior.
+ */
+#define SDL_UnlockMutex(m)	SDL_mutexV(m)
+extern DECLSPEC int SDLCALL SDL_mutexV(SDL_mutex *mutex);
+
+/* Destroy a mutex */
+extern DECLSPEC void SDLCALL SDL_DestroyMutex(SDL_mutex *mutex);
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* Semaphore functions                                           */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* The SDL semaphore structure, defined in SDL_sem.c */
+struct SDL_semaphore;
+typedef struct SDL_semaphore SDL_sem;
+
+/* Create a semaphore, initialized with value, returns NULL on failure. */
+extern DECLSPEC SDL_sem * SDLCALL SDL_CreateSemaphore(Uint32 initial_value);
+
+/* Destroy a semaphore */
+extern DECLSPEC void SDLCALL SDL_DestroySemaphore(SDL_sem *sem);
+
+/* This function suspends the calling thread until the semaphore pointed 
+ * to by sem has a positive count. It then atomically decreases the semaphore
+ * count.
+ */
+extern DECLSPEC int SDLCALL SDL_SemWait(SDL_sem *sem);
+
+/* Non-blocking variant of SDL_SemWait(), returns 0 if the wait succeeds,
+   SDL_MUTEX_TIMEDOUT if the wait would block, and -1 on error.
+*/
+extern DECLSPEC int SDLCALL SDL_SemTryWait(SDL_sem *sem);
+
+/* Variant of SDL_SemWait() with a timeout in milliseconds, returns 0 if
+   the wait succeeds, SDL_MUTEX_TIMEDOUT if the wait does not succeed in
+   the allotted time, and -1 on error.
+   On some platforms this function is implemented by looping with a delay
+   of 1 ms, and so should be avoided if possible.
+*/
+extern DECLSPEC int SDLCALL SDL_SemWaitTimeout(SDL_sem *sem, Uint32 ms);
+
+/* Atomically increases the semaphore's count (not blocking), returns 0,
+   or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_SemPost(SDL_sem *sem);
+
+/* Returns the current count of the semaphore */
+extern DECLSPEC Uint32 SDLCALL SDL_SemValue(SDL_sem *sem);
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* Condition variable functions                                  */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* The SDL condition variable structure, defined in SDL_cond.c */
+struct SDL_cond;
+typedef struct SDL_cond SDL_cond;
+
+/* Create a condition variable */
+extern DECLSPEC SDL_cond * SDLCALL SDL_CreateCond(void);
+
+/* Destroy a condition variable */
+extern DECLSPEC void SDLCALL SDL_DestroyCond(SDL_cond *cond);
+
+/* Restart one of the threads that are waiting on the condition variable,
+   returns 0 or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_CondSignal(SDL_cond *cond);
+
+/* Restart all threads that are waiting on the condition variable,
+   returns 0 or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_CondBroadcast(SDL_cond *cond);
+
+/* Wait on the condition variable, unlocking the provided mutex.
+   The mutex must be locked before entering this function!
+   Returns 0 when it is signaled, or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_CondWait(SDL_cond *cond, SDL_mutex *mut);
+
+/* Waits for at most 'ms' milliseconds, and returns 0 if the condition
+   variable is signaled, SDL_MUTEX_TIMEDOUT if the condition is not
+   signaled in the allotted time, and -1 on error.
+   On some platforms this function is implemented by looping with a delay
+   of 1 ms, and so should be avoided if possible.
+*/
+extern DECLSPEC int SDLCALL SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_mutex_h */

Added: trunk/msvc-libs/include/SDL/SDL_name.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_name.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_name.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,11 @@
+
+#ifndef _SDLname_h_
+#define _SDLname_h_
+
+#if defined(__STDC__) || defined(__cplusplus)
+#define NeedFunctionPrototypes 1
+#endif
+
+#define SDL_NAME(X)	SDL_##X
+
+#endif /* _SDLname_h_ */

Added: trunk/msvc-libs/include/SDL/SDL_opengl.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_opengl.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_opengl.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,5968 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_opengl.h,v 1.10 2004/08/20 22:32:05 slouken Exp $&quot;;
+#endif
+
+/* This is a simple file to encapsulate the OpenGL API headers */
+
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#ifndef NOMINMAX
+#define NOMINMAX	/* Don't defined min() and max() */
+#endif
+#include &lt;windows.h&gt;
+#endif
+#ifndef NO_SDL_GLEXT
+#define __glext_h_  /* Don't let gl.h include glext.h */
+#endif
+#if defined(__APPLE__) &amp;&amp; defined(__MACH__)
+#include &lt;OpenGL/gl.h&gt;	/* Header File For The OpenGL Library */
+#include &lt;OpenGL/glu.h&gt;	/* Header File For The GLU Library */
+#else
+#include &lt;GL/gl.h&gt;	/* Header File For The OpenGL Library */
+#include &lt;GL/glu.h&gt;	/* Header File For The GLU Library */
+#endif
+#ifndef NO_SDL_GLEXT
+#undef __glext_h_
+#endif
+
+/* This file taken from &quot;GLext.h&quot; from the Jeff Molofee OpenGL tutorials.
+   It is included here because glext.h is not available on some systems.
+   If you don't want this version included, simply define &quot;NO_SDL_GLEXT&quot;
+ */
+#ifndef NO_SDL_GLEXT
+#if !defined(__glext_h_) &amp;&amp; !defined(GL_GLEXT_LEGACY)
+#define __glext_h_
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/*
+** License Applicability. Except to the extent portions of this file are
+** made subject to an alternative license as permitted in the SGI Free
+** Software License B, Version 1.1 (the &quot;License&quot;), the contents of this
+** file are subject only to the provisions of the License. You may not use
+** this file except in compliance with the License. You may obtain a copy
+** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
+** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
+** 
+** <A HREF="http://oss.sgi.com/projects/FreeB">http://oss.sgi.com/projects/FreeB</A>
+** 
+** Note that, as provided in the License, the Software is distributed on an
+** &quot;AS IS&quot; basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
+** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
+** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
+** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
+** 
+** Original Code. The Original Code is: OpenGL Sample Implementation,
+** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
+** Inc. The Original Code is Copyright (c) 1991-2002 Silicon Graphics, Inc.
+** Copyright in any portions created by third parties is as indicated
+** elsewhere herein. All Rights Reserved.
+** 
+** Additional Notice Provisions: This software was created using the
+** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
+** not been independently verified as being compliant with the OpenGL(R)
+** version 1.2.1 Specification.
+*/
+
+#if defined(_WIN32) &amp;&amp; !defined(APIENTRY) &amp;&amp; !defined(__CYGWIN__) &amp;&amp; !defined(__SCITECH_SNAP__)
+#define WIN32_LEAN_AND_MEAN 1
+#include &lt;windows.h&gt;
+#endif
+
+#ifndef APIENTRY
+#define APIENTRY
+#endif
+#ifndef APIENTRYP
+#define APIENTRYP APIENTRY *
+#endif
+#ifndef GLAPI
+#define GLAPI extern
+#endif
+
+/*************************************************************/
+
+/* Header file version number, required by OpenGL ABI for Linux */
+/* glext.h last updated 2003/1/12 */
+/* Current version at <A HREF="http://oss.sgi.com/projects/ogl-sample/registry/">http://oss.sgi.com/projects/ogl-sample/registry/</A> */
+#define GL_GLEXT_VERSION 21
+
+#ifndef GL_VERSION_1_2
+#define GL_UNSIGNED_BYTE_3_3_2            0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
+#define GL_UNSIGNED_INT_8_8_8_8           0x8035
+#define GL_UNSIGNED_INT_10_10_10_2        0x8036
+#define GL_RESCALE_NORMAL                 0x803A
+#define GL_TEXTURE_BINDING_3D             0x806A
+#define GL_PACK_SKIP_IMAGES               0x806B
+#define GL_PACK_IMAGE_HEIGHT              0x806C
+#define GL_UNPACK_SKIP_IMAGES             0x806D
+#define GL_UNPACK_IMAGE_HEIGHT            0x806E
+#define GL_TEXTURE_3D                     0x806F
+#define GL_PROXY_TEXTURE_3D               0x8070
+#define GL_TEXTURE_DEPTH                  0x8071
+#define GL_TEXTURE_WRAP_R                 0x8072
+#define GL_MAX_3D_TEXTURE_SIZE            0x8073
+#define GL_UNSIGNED_BYTE_2_3_3_REV        0x8362
+#define GL_UNSIGNED_SHORT_5_6_5           0x8363
+#define GL_UNSIGNED_SHORT_5_6_5_REV       0x8364
+#define GL_UNSIGNED_SHORT_4_4_4_4_REV     0x8365
+#define GL_UNSIGNED_SHORT_1_5_5_5_REV     0x8366
+#define GL_UNSIGNED_INT_8_8_8_8_REV       0x8367
+#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
+#define GL_BGR                            0x80E0
+#define GL_BGRA                           0x80E1
+#define GL_MAX_ELEMENTS_VERTICES          0x80E8
+#define GL_MAX_ELEMENTS_INDICES           0x80E9
+#define GL_CLAMP_TO_EDGE                  0x812F
+#define GL_TEXTURE_MIN_LOD                0x813A
+#define GL_TEXTURE_MAX_LOD                0x813B
+#define GL_TEXTURE_BASE_LEVEL             0x813C
+#define GL_TEXTURE_MAX_LEVEL              0x813D
+#define GL_LIGHT_MODEL_COLOR_CONTROL      0x81F8
+#define GL_SINGLE_COLOR                   0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR        0x81FA
+#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
+#define GL_SMOOTH_POINT_SIZE_GRANULARITY  0x0B13
+#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
+#define GL_SMOOTH_LINE_WIDTH_GRANULARITY  0x0B23
+#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
+#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
+#endif
+
+#ifndef GL_ARB_imaging
+#define GL_CONSTANT_COLOR                 0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
+#define GL_CONSTANT_ALPHA                 0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
+#define GL_BLEND_COLOR                    0x8005
+#define GL_FUNC_ADD                       0x8006
+#define GL_MIN                            0x8007
+#define GL_MAX                            0x8008
+#define GL_BLEND_EQUATION                 0x8009
+#define GL_FUNC_SUBTRACT                  0x800A
+#define GL_FUNC_REVERSE_SUBTRACT          0x800B
+#define GL_CONVOLUTION_1D                 0x8010
+#define GL_CONVOLUTION_2D                 0x8011
+#define GL_SEPARABLE_2D                   0x8012
+#define GL_CONVOLUTION_BORDER_MODE        0x8013
+#define GL_CONVOLUTION_FILTER_SCALE       0x8014
+#define GL_CONVOLUTION_FILTER_BIAS        0x8015
+#define GL_REDUCE                         0x8016
+#define GL_CONVOLUTION_FORMAT             0x8017
+#define GL_CONVOLUTION_WIDTH              0x8018
+#define GL_CONVOLUTION_HEIGHT             0x8019
+#define GL_MAX_CONVOLUTION_WIDTH          0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT         0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE     0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE   0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE    0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE   0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS      0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS    0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS     0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS    0x8023
+#define GL_HISTOGRAM                      0x8024
+#define GL_PROXY_HISTOGRAM                0x8025
+#define GL_HISTOGRAM_WIDTH                0x8026
+#define GL_HISTOGRAM_FORMAT               0x8027
+#define GL_HISTOGRAM_RED_SIZE             0x8028
+#define GL_HISTOGRAM_GREEN_SIZE           0x8029
+#define GL_HISTOGRAM_BLUE_SIZE            0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE           0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE       0x802C
+#define GL_HISTOGRAM_SINK                 0x802D
+#define GL_MINMAX                         0x802E
+#define GL_MINMAX_FORMAT                  0x802F
+#define GL_MINMAX_SINK                    0x8030
+#define GL_TABLE_TOO_LARGE                0x8031
+#define GL_COLOR_MATRIX                   0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH       0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH   0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE    0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE  0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE   0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE  0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS     0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS   0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS    0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS   0x80BB
+#define GL_COLOR_TABLE                    0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE   0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE  0x80D2
+#define GL_PROXY_COLOR_TABLE              0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE 0x80D5
+#define GL_COLOR_TABLE_SCALE              0x80D6
+#define GL_COLOR_TABLE_BIAS               0x80D7
+#define GL_COLOR_TABLE_FORMAT             0x80D8
+#define GL_COLOR_TABLE_WIDTH              0x80D9
+#define GL_COLOR_TABLE_RED_SIZE           0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE         0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE          0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE         0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE     0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE     0x80DF
+#define GL_CONSTANT_BORDER                0x8151
+#define GL_REPLICATE_BORDER               0x8153
+#define GL_CONVOLUTION_BORDER_COLOR       0x8154
+#endif
+
+#ifndef GL_VERSION_1_3
+#define GL_TEXTURE0                       0x84C0
+#define GL_TEXTURE1                       0x84C1
+#define GL_TEXTURE2                       0x84C2
+#define GL_TEXTURE3                       0x84C3
+#define GL_TEXTURE4                       0x84C4
+#define GL_TEXTURE5                       0x84C5
+#define GL_TEXTURE6                       0x84C6
+#define GL_TEXTURE7                       0x84C7
+#define GL_TEXTURE8                       0x84C8
+#define GL_TEXTURE9                       0x84C9
+#define GL_TEXTURE10                      0x84CA
+#define GL_TEXTURE11                      0x84CB
+#define GL_TEXTURE12                      0x84CC
+#define GL_TEXTURE13                      0x84CD
+#define GL_TEXTURE14                      0x84CE
+#define GL_TEXTURE15                      0x84CF
+#define GL_TEXTURE16                      0x84D0
+#define GL_TEXTURE17                      0x84D1
+#define GL_TEXTURE18                      0x84D2
+#define GL_TEXTURE19                      0x84D3
+#define GL_TEXTURE20                      0x84D4
+#define GL_TEXTURE21                      0x84D5
+#define GL_TEXTURE22                      0x84D6
+#define GL_TEXTURE23                      0x84D7
+#define GL_TEXTURE24                      0x84D8
+#define GL_TEXTURE25                      0x84D9
+#define GL_TEXTURE26                      0x84DA
+#define GL_TEXTURE27                      0x84DB
+#define GL_TEXTURE28                      0x84DC
+#define GL_TEXTURE29                      0x84DD
+#define GL_TEXTURE30                      0x84DE
+#define GL_TEXTURE31                      0x84DF
+#define GL_ACTIVE_TEXTURE                 0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE          0x84E1
+#define GL_MAX_TEXTURE_UNITS              0x84E2
+#define GL_TRANSPOSE_MODELVIEW_MATRIX     0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX    0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX       0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX         0x84E6
+#define GL_MULTISAMPLE                    0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
+#define GL_SAMPLE_COVERAGE                0x80A0
+#define GL_SAMPLE_BUFFERS                 0x80A8
+#define GL_SAMPLES                        0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
+#define GL_MULTISAMPLE_BIT                0x20000000
+#define GL_NORMAL_MAP                     0x8511
+#define GL_REFLECTION_MAP                 0x8512
+#define GL_TEXTURE_CUBE_MAP               0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
+#define GL_COMPRESSED_ALPHA               0x84E9
+#define GL_COMPRESSED_LUMINANCE           0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA     0x84EB
+#define GL_COMPRESSED_INTENSITY           0x84EC
+#define GL_COMPRESSED_RGB                 0x84ED
+#define GL_COMPRESSED_RGBA                0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT       0x84EF
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
+#define GL_TEXTURE_COMPRESSED             0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
+#define GL_CLAMP_TO_BORDER                0x812D
+#define GL_CLAMP_TO_BORDER_SGIS           0x812D
+#define GL_COMBINE                        0x8570
+#define GL_COMBINE_RGB                    0x8571
+#define GL_COMBINE_ALPHA                  0x8572
+#define GL_SOURCE0_RGB                    0x8580
+#define GL_SOURCE1_RGB                    0x8581
+#define GL_SOURCE2_RGB                    0x8582
+#define GL_SOURCE0_ALPHA                  0x8588
+#define GL_SOURCE1_ALPHA                  0x8589
+#define GL_SOURCE2_ALPHA                  0x858A
+#define GL_OPERAND0_RGB                   0x8590
+#define GL_OPERAND1_RGB                   0x8591
+#define GL_OPERAND2_RGB                   0x8592
+#define GL_OPERAND0_ALPHA                 0x8598
+#define GL_OPERAND1_ALPHA                 0x8599
+#define GL_OPERAND2_ALPHA                 0x859A
+#define GL_RGB_SCALE                      0x8573
+#define GL_ADD_SIGNED                     0x8574
+#define GL_INTERPOLATE                    0x8575
+#define GL_SUBTRACT                       0x84E7
+#define GL_CONSTANT                       0x8576
+#define GL_PRIMARY_COLOR                  0x8577
+#define GL_PREVIOUS                       0x8578
+#define GL_DOT3_RGB                       0x86AE
+#define GL_DOT3_RGBA                      0x86AF
+#endif
+
+#ifndef GL_VERSION_1_4
+#define GL_BLEND_DST_RGB                  0x80C8
+#define GL_BLEND_SRC_RGB                  0x80C9
+#define GL_BLEND_DST_ALPHA                0x80CA
+#define GL_BLEND_SRC_ALPHA                0x80CB
+#define GL_POINT_SIZE_MIN                 0x8126
+#define GL_POINT_SIZE_MAX                 0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
+#define GL_POINT_DISTANCE_ATTENUATION     0x8129
+#define GL_GENERATE_MIPMAP                0x8191
+#define GL_GENERATE_MIPMAP_HINT           0x8192
+#define GL_DEPTH_COMPONENT16              0x81A5
+#define GL_DEPTH_COMPONENT24              0x81A6
+#define GL_DEPTH_COMPONENT32              0x81A7
+#define GL_MIRRORED_REPEAT                0x8370
+#define GL_FOG_COORDINATE_SOURCE          0x8450
+#define GL_FOG_COORDINATE                 0x8451
+#define GL_FRAGMENT_DEPTH                 0x8452
+#define GL_CURRENT_FOG_COORDINATE         0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE      0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE    0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER   0x8456
+#define GL_FOG_COORDINATE_ARRAY           0x8457
+#define GL_COLOR_SUM                      0x8458
+#define GL_CURRENT_SECONDARY_COLOR        0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE     0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE     0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE   0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER  0x845D
+#define GL_SECONDARY_COLOR_ARRAY          0x845E
+#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
+#define GL_TEXTURE_FILTER_CONTROL         0x8500
+#define GL_TEXTURE_LOD_BIAS               0x8501
+#define GL_INCR_WRAP                      0x8507
+#define GL_DECR_WRAP                      0x8508
+#define GL_TEXTURE_DEPTH_SIZE             0x884A
+#define GL_DEPTH_TEXTURE_MODE             0x884B
+#define GL_TEXTURE_COMPARE_MODE           0x884C
+#define GL_TEXTURE_COMPARE_FUNC           0x884D
+#define GL_COMPARE_R_TO_TEXTURE           0x884E
+#endif
+
+#ifndef GL_VERSION_1_5
+#define GL_BUFFER_SIZE                    0x8764
+#define GL_BUFFER_USAGE                   0x8765
+#define GL_QUERY_COUNTER_BITS             0x8864
+#define GL_CURRENT_QUERY                  0x8865
+#define GL_QUERY_RESULT                   0x8866
+#define GL_QUERY_RESULT_AVAILABLE         0x8867
+#define GL_ARRAY_BUFFER                   0x8892
+#define GL_ELEMENT_ARRAY_BUFFER           0x8893
+#define GL_ARRAY_BUFFER_BINDING           0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING    0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING    0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING     0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING     0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING    0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
+#define GL_READ_ONLY                      0x88B8
+#define GL_WRITE_ONLY                     0x88B9
+#define GL_READ_WRITE                     0x88BA
+#define GL_BUFFER_ACCESS                  0x88BB
+#define GL_BUFFER_MAPPED                  0x88BC
+#define GL_BUFFER_MAP_POINTER             0x88BD
+#define GL_STREAM_DRAW                    0x88E0
+#define GL_STREAM_READ                    0x88E1
+#define GL_STREAM_COPY                    0x88E2
+#define GL_STATIC_DRAW                    0x88E4
+#define GL_STATIC_READ                    0x88E5
+#define GL_STATIC_COPY                    0x88E6
+#define GL_DYNAMIC_DRAW                   0x88E8
+#define GL_DYNAMIC_READ                   0x88E9
+#define GL_DYNAMIC_COPY                   0x88EA
+#define GL_SAMPLES_PASSED                 0x8914
+#define GL_FOG_COORD_SOURCE               GL_FOG_COORDINATE_SOURCE
+#define GL_FOG_COORD                      GL_FOG_COORDINATE
+#define GL_CURRENT_FOG_COORD              GL_CURRENT_FOG_COORDINATE
+#define GL_FOG_COORD_ARRAY_TYPE           GL_FOG_COORDINATE_ARRAY_TYPE
+#define GL_FOG_COORD_ARRAY_STRIDE         GL_FOG_COORDINATE_ARRAY_STRIDE
+#define GL_FOG_COORD_ARRAY_POINTER        GL_FOG_COORDINATE_ARRAY_POINTER
+#define GL_FOG_COORD_ARRAY                GL_FOG_COORDINATE_ARRAY
+#define GL_FOG_COORD_ARRAY_BUFFER_BINDING GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING
+#define GL_SRC0_RGB                       GL_SOURCE0_RGB
+#define GL_SRC1_RGB                       GL_SOURCE1_RGB
+#define GL_SRC2_RGB                       GL_SOURCE2_RGB
+#define GL_SRC0_ALPHA                     GL_SOURCE0_ALPHA
+#define GL_SRC1_ALPHA                     GL_SOURCE1_ALPHA
+#define GL_SRC2_ALPHA                     GL_SOURCE2_ALPHA
+#endif
+
+#ifndef GL_ARB_multitexture
+#define GL_TEXTURE0_ARB                   0x84C0
+#define GL_TEXTURE1_ARB                   0x84C1
+#define GL_TEXTURE2_ARB                   0x84C2
+#define GL_TEXTURE3_ARB                   0x84C3
+#define GL_TEXTURE4_ARB                   0x84C4
+#define GL_TEXTURE5_ARB                   0x84C5
+#define GL_TEXTURE6_ARB                   0x84C6
+#define GL_TEXTURE7_ARB                   0x84C7
+#define GL_TEXTURE8_ARB                   0x84C8
+#define GL_TEXTURE9_ARB                   0x84C9
+#define GL_TEXTURE10_ARB                  0x84CA
+#define GL_TEXTURE11_ARB                  0x84CB
+#define GL_TEXTURE12_ARB                  0x84CC
+#define GL_TEXTURE13_ARB                  0x84CD
+#define GL_TEXTURE14_ARB                  0x84CE
+#define GL_TEXTURE15_ARB                  0x84CF
+#define GL_TEXTURE16_ARB                  0x84D0
+#define GL_TEXTURE17_ARB                  0x84D1
+#define GL_TEXTURE18_ARB                  0x84D2
+#define GL_TEXTURE19_ARB                  0x84D3
+#define GL_TEXTURE20_ARB                  0x84D4
+#define GL_TEXTURE21_ARB                  0x84D5
+#define GL_TEXTURE22_ARB                  0x84D6
+#define GL_TEXTURE23_ARB                  0x84D7
+#define GL_TEXTURE24_ARB                  0x84D8
+#define GL_TEXTURE25_ARB                  0x84D9
+#define GL_TEXTURE26_ARB                  0x84DA
+#define GL_TEXTURE27_ARB                  0x84DB
+#define GL_TEXTURE28_ARB                  0x84DC
+#define GL_TEXTURE29_ARB                  0x84DD
+#define GL_TEXTURE30_ARB                  0x84DE
+#define GL_TEXTURE31_ARB                  0x84DF
+#define GL_ACTIVE_TEXTURE_ARB             0x84E0
+#define GL_CLIENT_ACTIVE_TEXTURE_ARB      0x84E1
+#define GL_MAX_TEXTURE_UNITS_ARB          0x84E2
+#endif
+
+#ifndef GL_ARB_transpose_matrix
+#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB 0x84E3
+#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB 0x84E4
+#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB   0x84E5
+#define GL_TRANSPOSE_COLOR_MATRIX_ARB     0x84E6
+#endif
+
+#ifndef GL_ARB_multisample
+#define GL_MULTISAMPLE_ARB                0x809D
+#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB   0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_ARB        0x809F
+#define GL_SAMPLE_COVERAGE_ARB            0x80A0
+#define GL_SAMPLE_BUFFERS_ARB             0x80A8
+#define GL_SAMPLES_ARB                    0x80A9
+#define GL_SAMPLE_COVERAGE_VALUE_ARB      0x80AA
+#define GL_SAMPLE_COVERAGE_INVERT_ARB     0x80AB
+#define GL_MULTISAMPLE_BIT_ARB            0x20000000
+#endif
+
+#ifndef GL_ARB_texture_env_add
+#endif
+
+#ifndef GL_ARB_texture_cube_map
+#define GL_NORMAL_MAP_ARB                 0x8511
+#define GL_REFLECTION_MAP_ARB             0x8512
+#define GL_TEXTURE_CUBE_MAP_ARB           0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_ARB   0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_ARB     0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB  0x851C
+#endif
+
+#ifndef GL_ARB_texture_compression
+#define GL_COMPRESSED_ALPHA_ARB           0x84E9
+#define GL_COMPRESSED_LUMINANCE_ARB       0x84EA
+#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB 0x84EB
+#define GL_COMPRESSED_INTENSITY_ARB       0x84EC
+#define GL_COMPRESSED_RGB_ARB             0x84ED
+#define GL_COMPRESSED_RGBA_ARB            0x84EE
+#define GL_TEXTURE_COMPRESSION_HINT_ARB   0x84EF
+#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB 0x86A0
+#define GL_TEXTURE_COMPRESSED_ARB         0x86A1
+#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
+#define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
+#endif
+
+#ifndef GL_ARB_texture_border_clamp
+#define GL_CLAMP_TO_BORDER_ARB            0x812D
+#endif
+
+#ifndef GL_ARB_point_parameters
+#define GL_POINT_SIZE_MIN_ARB             0x8126
+#define GL_POINT_SIZE_MAX_ARB             0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_ARB  0x8128
+#define GL_POINT_DISTANCE_ATTENUATION_ARB 0x8129
+#endif
+
+#ifndef GL_ARB_vertex_blend
+#define GL_MAX_VERTEX_UNITS_ARB           0x86A4
+#define GL_ACTIVE_VERTEX_UNITS_ARB        0x86A5
+#define GL_WEIGHT_SUM_UNITY_ARB           0x86A6
+#define GL_VERTEX_BLEND_ARB               0x86A7
+#define GL_CURRENT_WEIGHT_ARB             0x86A8
+#define GL_WEIGHT_ARRAY_TYPE_ARB          0x86A9
+#define GL_WEIGHT_ARRAY_STRIDE_ARB        0x86AA
+#define GL_WEIGHT_ARRAY_SIZE_ARB          0x86AB
+#define GL_WEIGHT_ARRAY_POINTER_ARB       0x86AC
+#define GL_WEIGHT_ARRAY_ARB               0x86AD
+#define GL_MODELVIEW0_ARB                 0x1700
+#define GL_MODELVIEW1_ARB                 0x850A
+#define GL_MODELVIEW2_ARB                 0x8722
+#define GL_MODELVIEW3_ARB                 0x8723
+#define GL_MODELVIEW4_ARB                 0x8724
+#define GL_MODELVIEW5_ARB                 0x8725
+#define GL_MODELVIEW6_ARB                 0x8726
+#define GL_MODELVIEW7_ARB                 0x8727
+#define GL_MODELVIEW8_ARB                 0x8728
+#define GL_MODELVIEW9_ARB                 0x8729
+#define GL_MODELVIEW10_ARB                0x872A
+#define GL_MODELVIEW11_ARB                0x872B
+#define GL_MODELVIEW12_ARB                0x872C
+#define GL_MODELVIEW13_ARB                0x872D
+#define GL_MODELVIEW14_ARB                0x872E
+#define GL_MODELVIEW15_ARB                0x872F
+#define GL_MODELVIEW16_ARB                0x8730
+#define GL_MODELVIEW17_ARB                0x8731
+#define GL_MODELVIEW18_ARB                0x8732
+#define GL_MODELVIEW19_ARB                0x8733
+#define GL_MODELVIEW20_ARB                0x8734
+#define GL_MODELVIEW21_ARB                0x8735
+#define GL_MODELVIEW22_ARB                0x8736
+#define GL_MODELVIEW23_ARB                0x8737
+#define GL_MODELVIEW24_ARB                0x8738
+#define GL_MODELVIEW25_ARB                0x8739
+#define GL_MODELVIEW26_ARB                0x873A
+#define GL_MODELVIEW27_ARB                0x873B
+#define GL_MODELVIEW28_ARB                0x873C
+#define GL_MODELVIEW29_ARB                0x873D
+#define GL_MODELVIEW30_ARB                0x873E
+#define GL_MODELVIEW31_ARB                0x873F
+#endif
+
+#ifndef GL_ARB_matrix_palette
+#define GL_MATRIX_PALETTE_ARB             0x8840
+#define GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB 0x8841
+#define GL_MAX_PALETTE_MATRICES_ARB       0x8842
+#define GL_CURRENT_PALETTE_MATRIX_ARB     0x8843
+#define GL_MATRIX_INDEX_ARRAY_ARB         0x8844
+#define GL_CURRENT_MATRIX_INDEX_ARB       0x8845
+#define GL_MATRIX_INDEX_ARRAY_SIZE_ARB    0x8846
+#define GL_MATRIX_INDEX_ARRAY_TYPE_ARB    0x8847
+#define GL_MATRIX_INDEX_ARRAY_STRIDE_ARB  0x8848
+#define GL_MATRIX_INDEX_ARRAY_POINTER_ARB 0x8849
+#endif
+
+#ifndef GL_ARB_texture_env_combine
+#define GL_COMBINE_ARB                    0x8570
+#define GL_COMBINE_RGB_ARB                0x8571
+#define GL_COMBINE_ALPHA_ARB              0x8572
+#define GL_SOURCE0_RGB_ARB                0x8580
+#define GL_SOURCE1_RGB_ARB                0x8581
+#define GL_SOURCE2_RGB_ARB                0x8582
+#define GL_SOURCE0_ALPHA_ARB              0x8588
+#define GL_SOURCE1_ALPHA_ARB              0x8589
+#define GL_SOURCE2_ALPHA_ARB              0x858A
+#define GL_OPERAND0_RGB_ARB               0x8590
+#define GL_OPERAND1_RGB_ARB               0x8591
+#define GL_OPERAND2_RGB_ARB               0x8592
+#define GL_OPERAND0_ALPHA_ARB             0x8598
+#define GL_OPERAND1_ALPHA_ARB             0x8599
+#define GL_OPERAND2_ALPHA_ARB             0x859A
+#define GL_RGB_SCALE_ARB                  0x8573
+#define GL_ADD_SIGNED_ARB                 0x8574
+#define GL_INTERPOLATE_ARB                0x8575
+#define GL_SUBTRACT_ARB                   0x84E7
+#define GL_CONSTANT_ARB                   0x8576
+#define GL_PRIMARY_COLOR_ARB              0x8577
+#define GL_PREVIOUS_ARB                   0x8578
+#endif
+
+#ifndef GL_ARB_texture_env_crossbar
+#endif
+
+#ifndef GL_ARB_texture_env_dot3
+#define GL_DOT3_RGB_ARB                   0x86AE
+#define GL_DOT3_RGBA_ARB                  0x86AF
+#endif
+
+#ifndef GL_ARB_texture_mirrored_repeat
+#define GL_MIRRORED_REPEAT_ARB            0x8370
+#endif
+
+#ifndef GL_ARB_depth_texture
+#define GL_DEPTH_COMPONENT16_ARB          0x81A5
+#define GL_DEPTH_COMPONENT24_ARB          0x81A6
+#define GL_DEPTH_COMPONENT32_ARB          0x81A7
+#define GL_TEXTURE_DEPTH_SIZE_ARB         0x884A
+#define GL_DEPTH_TEXTURE_MODE_ARB         0x884B
+#endif
+
+#ifndef GL_ARB_shadow
+#define GL_TEXTURE_COMPARE_MODE_ARB       0x884C
+#define GL_TEXTURE_COMPARE_FUNC_ARB       0x884D
+#define GL_COMPARE_R_TO_TEXTURE_ARB       0x884E
+#endif
+
+#ifndef GL_ARB_shadow_ambient
+#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
+#endif
+
+#ifndef GL_ARB_window_pos
+#endif
+
+#ifndef GL_ARB_vertex_program
+#define GL_COLOR_SUM_ARB                  0x8458
+#define GL_VERTEX_PROGRAM_ARB             0x8620
+#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB 0x8622
+#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB   0x8623
+#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB 0x8624
+#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB   0x8625
+#define GL_CURRENT_VERTEX_ATTRIB_ARB      0x8626
+#define GL_PROGRAM_LENGTH_ARB             0x8627
+#define GL_PROGRAM_STRING_ARB             0x8628
+#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB 0x862E
+#define GL_MAX_PROGRAM_MATRICES_ARB       0x862F
+#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB 0x8640
+#define GL_CURRENT_MATRIX_ARB             0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB  0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB    0x8643
+#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB 0x8645
+#define GL_PROGRAM_ERROR_POSITION_ARB     0x864B
+#define GL_PROGRAM_BINDING_ARB            0x8677
+#define GL_MAX_VERTEX_ATTRIBS_ARB         0x8869
+#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB 0x886A
+#define GL_PROGRAM_ERROR_STRING_ARB       0x8874
+#define GL_PROGRAM_FORMAT_ASCII_ARB       0x8875
+#define GL_PROGRAM_FORMAT_ARB             0x8876
+#define GL_PROGRAM_INSTRUCTIONS_ARB       0x88A0
+#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB   0x88A1
+#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A2
+#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB 0x88A3
+#define GL_PROGRAM_TEMPORARIES_ARB        0x88A4
+#define GL_MAX_PROGRAM_TEMPORARIES_ARB    0x88A5
+#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A6
+#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB 0x88A7
+#define GL_PROGRAM_PARAMETERS_ARB         0x88A8
+#define GL_MAX_PROGRAM_PARAMETERS_ARB     0x88A9
+#define GL_PROGRAM_NATIVE_PARAMETERS_ARB  0x88AA
+#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB 0x88AB
+#define GL_PROGRAM_ATTRIBS_ARB            0x88AC
+#define GL_MAX_PROGRAM_ATTRIBS_ARB        0x88AD
+#define GL_PROGRAM_NATIVE_ATTRIBS_ARB     0x88AE
+#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB 0x88AF
+#define GL_PROGRAM_ADDRESS_REGISTERS_ARB  0x88B0
+#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB 0x88B1
+#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B2
+#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB 0x88B3
+#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB 0x88B4
+#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB 0x88B5
+#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB 0x88B6
+#define GL_TRANSPOSE_CURRENT_MATRIX_ARB   0x88B7
+#define GL_MATRIX0_ARB                    0x88C0
+#define GL_MATRIX1_ARB                    0x88C1
+#define GL_MATRIX2_ARB                    0x88C2
+#define GL_MATRIX3_ARB                    0x88C3
+#define GL_MATRIX4_ARB                    0x88C4
+#define GL_MATRIX5_ARB                    0x88C5
+#define GL_MATRIX6_ARB                    0x88C6
+#define GL_MATRIX7_ARB                    0x88C7
+#define GL_MATRIX8_ARB                    0x88C8
+#define GL_MATRIX9_ARB                    0x88C9
+#define GL_MATRIX10_ARB                   0x88CA
+#define GL_MATRIX11_ARB                   0x88CB
+#define GL_MATRIX12_ARB                   0x88CC
+#define GL_MATRIX13_ARB                   0x88CD
+#define GL_MATRIX14_ARB                   0x88CE
+#define GL_MATRIX15_ARB                   0x88CF
+#define GL_MATRIX16_ARB                   0x88D0
+#define GL_MATRIX17_ARB                   0x88D1
+#define GL_MATRIX18_ARB                   0x88D2
+#define GL_MATRIX19_ARB                   0x88D3
+#define GL_MATRIX20_ARB                   0x88D4
+#define GL_MATRIX21_ARB                   0x88D5
+#define GL_MATRIX22_ARB                   0x88D6
+#define GL_MATRIX23_ARB                   0x88D7
+#define GL_MATRIX24_ARB                   0x88D8
+#define GL_MATRIX25_ARB                   0x88D9
+#define GL_MATRIX26_ARB                   0x88DA
+#define GL_MATRIX27_ARB                   0x88DB
+#define GL_MATRIX28_ARB                   0x88DC
+#define GL_MATRIX29_ARB                   0x88DD
+#define GL_MATRIX30_ARB                   0x88DE
+#define GL_MATRIX31_ARB                   0x88DF
+#endif
+
+#ifndef GL_ARB_fragment_program
+#define GL_FRAGMENT_PROGRAM_ARB           0x8804
+#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB   0x8805
+#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB   0x8806
+#define GL_PROGRAM_TEX_INDIRECTIONS_ARB   0x8807
+#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x8808
+#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x8809
+#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x880A
+#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB 0x880B
+#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB 0x880C
+#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB 0x880D
+#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB 0x880E
+#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB 0x880F
+#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB 0x8810
+#define GL_MAX_TEXTURE_COORDS_ARB         0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB    0x8872
+#endif
+
+#ifndef GL_ARB_vertex_buffer_object
+#define GL_BUFFER_SIZE_ARB                0x8764
+#define GL_BUFFER_USAGE_ARB               0x8765
+#define GL_ARRAY_BUFFER_ARB               0x8892
+#define GL_ELEMENT_ARRAY_BUFFER_ARB       0x8893
+#define GL_ARRAY_BUFFER_BINDING_ARB       0x8894
+#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
+#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
+#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
+#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
+#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
+#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
+#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
+#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
+#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
+#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
+#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
+#define GL_READ_ONLY_ARB                  0x88B8
+#define GL_WRITE_ONLY_ARB                 0x88B9
+#define GL_READ_WRITE_ARB                 0x88BA
+#define GL_BUFFER_ACCESS_ARB              0x88BB
+#define GL_BUFFER_MAPPED_ARB              0x88BC
+#define GL_BUFFER_MAP_POINTER_ARB         0x88BD
+#define GL_STREAM_DRAW_ARB                0x88E0
+#define GL_STREAM_READ_ARB                0x88E1
+#define GL_STREAM_COPY_ARB                0x88E2
+#define GL_STATIC_DRAW_ARB                0x88E4
+#define GL_STATIC_READ_ARB                0x88E5
+#define GL_STATIC_COPY_ARB                0x88E6
+#define GL_DYNAMIC_DRAW_ARB               0x88E8
+#define GL_DYNAMIC_READ_ARB               0x88E9
+#define GL_DYNAMIC_COPY_ARB               0x88EA
+#endif
+
+#ifndef GL_ARB_occlusion_query
+#define GL_QUERY_COUNTER_BITS_ARB         0x8864
+#define GL_CURRENT_QUERY_ARB              0x8865
+#define GL_QUERY_RESULT_ARB               0x8866
+#define GL_QUERY_RESULT_AVAILABLE_ARB     0x8867
+#define GL_SAMPLES_PASSED_ARB             0x8914
+#endif
+
+#ifndef GL_ARB_shader_objects
+#define GL_PROGRAM_OBJECT_ARB             0x8B40
+#define GL_SHADER_OBJECT_ARB              0x8B48
+#define GL_OBJECT_TYPE_ARB                0x8B4E
+#define GL_OBJECT_SUBTYPE_ARB             0x8B4F
+#define GL_FLOAT_VEC2_ARB                 0x8B50
+#define GL_FLOAT_VEC3_ARB                 0x8B51
+#define GL_FLOAT_VEC4_ARB                 0x8B52
+#define GL_INT_VEC2_ARB                   0x8B53
+#define GL_INT_VEC3_ARB                   0x8B54
+#define GL_INT_VEC4_ARB                   0x8B55
+#define GL_BOOL_ARB                       0x8B56
+#define GL_BOOL_VEC2_ARB                  0x8B57
+#define GL_BOOL_VEC3_ARB                  0x8B58
+#define GL_BOOL_VEC4_ARB                  0x8B59
+#define GL_FLOAT_MAT2_ARB                 0x8B5A
+#define GL_FLOAT_MAT3_ARB                 0x8B5B
+#define GL_FLOAT_MAT4_ARB                 0x8B5C
+#define GL_OBJECT_DELETE_STATUS_ARB       0x8B80
+#define GL_OBJECT_COMPILE_STATUS_ARB      0x8B81
+#define GL_OBJECT_LINK_STATUS_ARB         0x8B82
+#define GL_OBJECT_VALIDATE_STATUS_ARB     0x8B83
+#define GL_OBJECT_INFO_LOG_LENGTH_ARB     0x8B84
+#define GL_OBJECT_ATTACHED_OBJECTS_ARB    0x8B85
+#define GL_OBJECT_ACTIVE_UNIFORMS_ARB     0x8B86
+#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB 0x8B87
+#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB 0x8B88
+#endif
+
+#ifndef GL_ARB_vertex_shader
+#define GL_VERTEX_SHADER_ARB              0x8B31
+#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB 0x8B4A
+#define GL_MAX_VARYING_FLOATS_ARB         0x8B4B
+#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB 0x8B4C
+#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB 0x8B4D
+#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB   0x8B89
+#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB 0x8B8A
+#endif
+
+#ifndef GL_ARB_fragment_shader
+#define GL_FRAGMENT_SHADER_ARB            0x8B30
+#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB 0x8B49
+#endif
+
+#ifndef GL_ARB_shading_language_100
+#endif
+
+#ifndef GL_ARB_texture_non_power_of_two
+#endif
+
+#ifndef GL_ARB_point_sprite
+#define GL_POINT_SPRITE_ARB               0x8861
+#define GL_COORD_REPLACE_ARB              0x8862
+#endif
+
+#ifndef GL_EXT_abgr
+#define GL_ABGR_EXT                       0x8000
+#endif
+
+#ifndef GL_EXT_blend_color
+#define GL_CONSTANT_COLOR_EXT             0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR_EXT   0x8002
+#define GL_CONSTANT_ALPHA_EXT             0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT   0x8004
+#define GL_BLEND_COLOR_EXT                0x8005
+#endif
+
+#ifndef GL_EXT_polygon_offset
+#define GL_POLYGON_OFFSET_EXT             0x8037
+#define GL_POLYGON_OFFSET_FACTOR_EXT      0x8038
+#define GL_POLYGON_OFFSET_BIAS_EXT        0x8039
+#endif
+
+#ifndef GL_EXT_texture
+#define GL_ALPHA4_EXT                     0x803B
+#define GL_ALPHA8_EXT                     0x803C
+#define GL_ALPHA12_EXT                    0x803D
+#define GL_ALPHA16_EXT                    0x803E
+#define GL_LUMINANCE4_EXT                 0x803F
+#define GL_LUMINANCE8_EXT                 0x8040
+#define GL_LUMINANCE12_EXT                0x8041
+#define GL_LUMINANCE16_EXT                0x8042
+#define GL_LUMINANCE4_ALPHA4_EXT          0x8043
+#define GL_LUMINANCE6_ALPHA2_EXT          0x8044
+#define GL_LUMINANCE8_ALPHA8_EXT          0x8045
+#define GL_LUMINANCE12_ALPHA4_EXT         0x8046
+#define GL_LUMINANCE12_ALPHA12_EXT        0x8047
+#define GL_LUMINANCE16_ALPHA16_EXT        0x8048
+#define GL_INTENSITY_EXT                  0x8049
+#define GL_INTENSITY4_EXT                 0x804A
+#define GL_INTENSITY8_EXT                 0x804B
+#define GL_INTENSITY12_EXT                0x804C
+#define GL_INTENSITY16_EXT                0x804D
+#define GL_RGB2_EXT                       0x804E
+#define GL_RGB4_EXT                       0x804F
+#define GL_RGB5_EXT                       0x8050
+#define GL_RGB8_EXT                       0x8051
+#define GL_RGB10_EXT                      0x8052
+#define GL_RGB12_EXT                      0x8053
+#define GL_RGB16_EXT                      0x8054
+#define GL_RGBA2_EXT                      0x8055
+#define GL_RGBA4_EXT                      0x8056
+#define GL_RGB5_A1_EXT                    0x8057
+#define GL_RGBA8_EXT                      0x8058
+#define GL_RGB10_A2_EXT                   0x8059
+#define GL_RGBA12_EXT                     0x805A
+#define GL_RGBA16_EXT                     0x805B
+#define GL_TEXTURE_RED_SIZE_EXT           0x805C
+#define GL_TEXTURE_GREEN_SIZE_EXT         0x805D
+#define GL_TEXTURE_BLUE_SIZE_EXT          0x805E
+#define GL_TEXTURE_ALPHA_SIZE_EXT         0x805F
+#define GL_TEXTURE_LUMINANCE_SIZE_EXT     0x8060
+#define GL_TEXTURE_INTENSITY_SIZE_EXT     0x8061
+#define GL_REPLACE_EXT                    0x8062
+#define GL_PROXY_TEXTURE_1D_EXT           0x8063
+#define GL_PROXY_TEXTURE_2D_EXT           0x8064
+#define GL_TEXTURE_TOO_LARGE_EXT          0x8065
+#endif
+
+#ifndef GL_EXT_texture3D
+#define GL_PACK_SKIP_IMAGES_EXT           0x806B
+#define GL_PACK_IMAGE_HEIGHT_EXT          0x806C
+#define GL_UNPACK_SKIP_IMAGES_EXT         0x806D
+#define GL_UNPACK_IMAGE_HEIGHT_EXT        0x806E
+#define GL_TEXTURE_3D_EXT                 0x806F
+#define GL_PROXY_TEXTURE_3D_EXT           0x8070
+#define GL_TEXTURE_DEPTH_EXT              0x8071
+#define GL_TEXTURE_WRAP_R_EXT             0x8072
+#define GL_MAX_3D_TEXTURE_SIZE_EXT        0x8073
+#endif
+
+#ifndef GL_SGIS_texture_filter4
+#define GL_FILTER4_SGIS                   0x8146
+#define GL_TEXTURE_FILTER4_SIZE_SGIS      0x8147
+#endif
+
+#ifndef GL_EXT_subtexture
+#endif
+
+#ifndef GL_EXT_copy_texture
+#endif
+
+#ifndef GL_EXT_histogram
+#define GL_HISTOGRAM_EXT                  0x8024
+#define GL_PROXY_HISTOGRAM_EXT            0x8025
+#define GL_HISTOGRAM_WIDTH_EXT            0x8026
+#define GL_HISTOGRAM_FORMAT_EXT           0x8027
+#define GL_HISTOGRAM_RED_SIZE_EXT         0x8028
+#define GL_HISTOGRAM_GREEN_SIZE_EXT       0x8029
+#define GL_HISTOGRAM_BLUE_SIZE_EXT        0x802A
+#define GL_HISTOGRAM_ALPHA_SIZE_EXT       0x802B
+#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT   0x802C
+#define GL_HISTOGRAM_SINK_EXT             0x802D
+#define GL_MINMAX_EXT                     0x802E
+#define GL_MINMAX_FORMAT_EXT              0x802F
+#define GL_MINMAX_SINK_EXT                0x8030
+#define GL_TABLE_TOO_LARGE_EXT            0x8031
+#endif
+
+#ifndef GL_EXT_convolution
+#define GL_CONVOLUTION_1D_EXT             0x8010
+#define GL_CONVOLUTION_2D_EXT             0x8011
+#define GL_SEPARABLE_2D_EXT               0x8012
+#define GL_CONVOLUTION_BORDER_MODE_EXT    0x8013
+#define GL_CONVOLUTION_FILTER_SCALE_EXT   0x8014
+#define GL_CONVOLUTION_FILTER_BIAS_EXT    0x8015
+#define GL_REDUCE_EXT                     0x8016
+#define GL_CONVOLUTION_FORMAT_EXT         0x8017
+#define GL_CONVOLUTION_WIDTH_EXT          0x8018
+#define GL_CONVOLUTION_HEIGHT_EXT         0x8019
+#define GL_MAX_CONVOLUTION_WIDTH_EXT      0x801A
+#define GL_MAX_CONVOLUTION_HEIGHT_EXT     0x801B
+#define GL_POST_CONVOLUTION_RED_SCALE_EXT 0x801C
+#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT 0x801D
+#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT 0x801E
+#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT 0x801F
+#define GL_POST_CONVOLUTION_RED_BIAS_EXT  0x8020
+#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
+#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
+#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
+#endif
+
+#ifndef GL_SGI_color_matrix
+#define GL_COLOR_MATRIX_SGI               0x80B1
+#define GL_COLOR_MATRIX_STACK_DEPTH_SGI   0x80B2
+#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI 0x80B3
+#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI 0x80B4
+#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI 0x80B5
+#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI 0x80B6
+#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI 0x80B7
+#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI 0x80B8
+#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI 0x80B9
+#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI 0x80BA
+#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI 0x80BB
+#endif
+
+#ifndef GL_SGI_color_table
+#define GL_COLOR_TABLE_SGI                0x80D0
+#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D1
+#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D2
+#define GL_PROXY_COLOR_TABLE_SGI          0x80D3
+#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI 0x80D4
+#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI 0x80D5
+#define GL_COLOR_TABLE_SCALE_SGI          0x80D6
+#define GL_COLOR_TABLE_BIAS_SGI           0x80D7
+#define GL_COLOR_TABLE_FORMAT_SGI         0x80D8
+#define GL_COLOR_TABLE_WIDTH_SGI          0x80D9
+#define GL_COLOR_TABLE_RED_SIZE_SGI       0x80DA
+#define GL_COLOR_TABLE_GREEN_SIZE_SGI     0x80DB
+#define GL_COLOR_TABLE_BLUE_SIZE_SGI      0x80DC
+#define GL_COLOR_TABLE_ALPHA_SIZE_SGI     0x80DD
+#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI 0x80DE
+#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI 0x80DF
+#endif
+
+#ifndef GL_SGIS_pixel_texture
+#define GL_PIXEL_TEXTURE_SGIS             0x8353
+#define GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS 0x8354
+#define GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS 0x8355
+#define GL_PIXEL_GROUP_COLOR_SGIS         0x8356
+#endif
+
+#ifndef GL_SGIX_pixel_texture
+#define GL_PIXEL_TEX_GEN_SGIX             0x8139
+#define GL_PIXEL_TEX_GEN_MODE_SGIX        0x832B
+#endif
+
+#ifndef GL_SGIS_texture4D
+#define GL_PACK_SKIP_VOLUMES_SGIS         0x8130
+#define GL_PACK_IMAGE_DEPTH_SGIS          0x8131
+#define GL_UNPACK_SKIP_VOLUMES_SGIS       0x8132
+#define GL_UNPACK_IMAGE_DEPTH_SGIS        0x8133
+#define GL_TEXTURE_4D_SGIS                0x8134
+#define GL_PROXY_TEXTURE_4D_SGIS          0x8135
+#define GL_TEXTURE_4DSIZE_SGIS            0x8136
+#define GL_TEXTURE_WRAP_Q_SGIS            0x8137
+#define GL_MAX_4D_TEXTURE_SIZE_SGIS       0x8138
+#define GL_TEXTURE_4D_BINDING_SGIS        0x814F
+#endif
+
+#ifndef GL_SGI_texture_color_table
+#define GL_TEXTURE_COLOR_TABLE_SGI        0x80BC
+#define GL_PROXY_TEXTURE_COLOR_TABLE_SGI  0x80BD
+#endif
+
+#ifndef GL_EXT_cmyka
+#define GL_CMYK_EXT                       0x800C
+#define GL_CMYKA_EXT                      0x800D
+#define GL_PACK_CMYK_HINT_EXT             0x800E
+#define GL_UNPACK_CMYK_HINT_EXT           0x800F
+#endif
+
+#ifndef GL_EXT_texture_object
+#define GL_TEXTURE_PRIORITY_EXT           0x8066
+#define GL_TEXTURE_RESIDENT_EXT           0x8067
+#define GL_TEXTURE_1D_BINDING_EXT         0x8068
+#define GL_TEXTURE_2D_BINDING_EXT         0x8069
+#define GL_TEXTURE_3D_BINDING_EXT         0x806A
+#endif
+
+#ifndef GL_SGIS_detail_texture
+#define GL_DETAIL_TEXTURE_2D_SGIS         0x8095
+#define GL_DETAIL_TEXTURE_2D_BINDING_SGIS 0x8096
+#define GL_LINEAR_DETAIL_SGIS             0x8097
+#define GL_LINEAR_DETAIL_ALPHA_SGIS       0x8098
+#define GL_LINEAR_DETAIL_COLOR_SGIS       0x8099
+#define GL_DETAIL_TEXTURE_LEVEL_SGIS      0x809A
+#define GL_DETAIL_TEXTURE_MODE_SGIS       0x809B
+#define GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS 0x809C
+#endif
+
+#ifndef GL_SGIS_sharpen_texture
+#define GL_LINEAR_SHARPEN_SGIS            0x80AD
+#define GL_LINEAR_SHARPEN_ALPHA_SGIS      0x80AE
+#define GL_LINEAR_SHARPEN_COLOR_SGIS      0x80AF
+#define GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS 0x80B0
+#endif
+
+#ifndef GL_EXT_packed_pixels
+#define GL_UNSIGNED_BYTE_3_3_2_EXT        0x8032
+#define GL_UNSIGNED_SHORT_4_4_4_4_EXT     0x8033
+#define GL_UNSIGNED_SHORT_5_5_5_1_EXT     0x8034
+#define GL_UNSIGNED_INT_8_8_8_8_EXT       0x8035
+#define GL_UNSIGNED_INT_10_10_10_2_EXT    0x8036
+#endif
+
+#ifndef GL_SGIS_texture_lod
+#define GL_TEXTURE_MIN_LOD_SGIS           0x813A
+#define GL_TEXTURE_MAX_LOD_SGIS           0x813B
+#define GL_TEXTURE_BASE_LEVEL_SGIS        0x813C
+#define GL_TEXTURE_MAX_LEVEL_SGIS         0x813D
+#endif
+
+#ifndef GL_SGIS_multisample
+#define GL_MULTISAMPLE_SGIS               0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_SGIS      0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_SGIS       0x809F
+#define GL_SAMPLE_MASK_SGIS               0x80A0
+#define GL_1PASS_SGIS                     0x80A1
+#define GL_2PASS_0_SGIS                   0x80A2
+#define GL_2PASS_1_SGIS                   0x80A3
+#define GL_4PASS_0_SGIS                   0x80A4
+#define GL_4PASS_1_SGIS                   0x80A5
+#define GL_4PASS_2_SGIS                   0x80A6
+#define GL_4PASS_3_SGIS                   0x80A7
+#define GL_SAMPLE_BUFFERS_SGIS            0x80A8
+#define GL_SAMPLES_SGIS                   0x80A9
+#define GL_SAMPLE_MASK_VALUE_SGIS         0x80AA
+#define GL_SAMPLE_MASK_INVERT_SGIS        0x80AB
+#define GL_SAMPLE_PATTERN_SGIS            0x80AC
+#endif
+
+#ifndef GL_EXT_rescale_normal
+#define GL_RESCALE_NORMAL_EXT             0x803A
+#endif
+
+#ifndef GL_EXT_vertex_array
+#define GL_VERTEX_ARRAY_EXT               0x8074
+#define GL_NORMAL_ARRAY_EXT               0x8075
+#define GL_COLOR_ARRAY_EXT                0x8076
+#define GL_INDEX_ARRAY_EXT                0x8077
+#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
+#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
+#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
+#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
+#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
+#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
+#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
+#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
+#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
+#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
+#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
+#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
+#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
+#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
+#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
+#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
+#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
+#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
+#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
+#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
+#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
+#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
+#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
+#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
+#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
+#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
+#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
+#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
+#endif
+
+#ifndef GL_EXT_misc_attribute
+#endif
+
+#ifndef GL_SGIS_generate_mipmap
+#define GL_GENERATE_MIPMAP_SGIS           0x8191
+#define GL_GENERATE_MIPMAP_HINT_SGIS      0x8192
+#endif
+
+#ifndef GL_SGIX_clipmap
+#define GL_LINEAR_CLIPMAP_LINEAR_SGIX     0x8170
+#define GL_TEXTURE_CLIPMAP_CENTER_SGIX    0x8171
+#define GL_TEXTURE_CLIPMAP_FRAME_SGIX     0x8172
+#define GL_TEXTURE_CLIPMAP_OFFSET_SGIX    0x8173
+#define GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX 0x8174
+#define GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX 0x8175
+#define GL_TEXTURE_CLIPMAP_DEPTH_SGIX     0x8176
+#define GL_MAX_CLIPMAP_DEPTH_SGIX         0x8177
+#define GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX 0x8178
+#define GL_NEAREST_CLIPMAP_NEAREST_SGIX   0x844D
+#define GL_NEAREST_CLIPMAP_LINEAR_SGIX    0x844E
+#define GL_LINEAR_CLIPMAP_NEAREST_SGIX    0x844F
+#endif
+
+#ifndef GL_SGIX_shadow
+#define GL_TEXTURE_COMPARE_SGIX           0x819A
+#define GL_TEXTURE_COMPARE_OPERATOR_SGIX  0x819B
+#define GL_TEXTURE_LEQUAL_R_SGIX          0x819C
+#define GL_TEXTURE_GEQUAL_R_SGIX          0x819D
+#endif
+
+#ifndef GL_SGIS_texture_edge_clamp
+#define GL_CLAMP_TO_EDGE_SGIS             0x812F
+#endif
+
+#ifndef GL_EXT_blend_minmax
+#define GL_FUNC_ADD_EXT                   0x8006
+#define GL_MIN_EXT                        0x8007
+#define GL_MAX_EXT                        0x8008
+#define GL_BLEND_EQUATION_EXT             0x8009
+#endif
+
+#ifndef GL_EXT_blend_subtract
+#define GL_FUNC_SUBTRACT_EXT              0x800A
+#define GL_FUNC_REVERSE_SUBTRACT_EXT      0x800B
+#endif
+
+#ifndef GL_EXT_blend_logic_op
+#endif
+
+#ifndef GL_SGIX_interlace
+#define GL_INTERLACE_SGIX                 0x8094
+#endif
+
+#ifndef GL_SGIX_pixel_tiles
+#define GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX 0x813E
+#define GL_PIXEL_TILE_CACHE_INCREMENT_SGIX 0x813F
+#define GL_PIXEL_TILE_WIDTH_SGIX          0x8140
+#define GL_PIXEL_TILE_HEIGHT_SGIX         0x8141
+#define GL_PIXEL_TILE_GRID_WIDTH_SGIX     0x8142
+#define GL_PIXEL_TILE_GRID_HEIGHT_SGIX    0x8143
+#define GL_PIXEL_TILE_GRID_DEPTH_SGIX     0x8144
+#define GL_PIXEL_TILE_CACHE_SIZE_SGIX     0x8145
+#endif
+
+#ifndef GL_SGIS_texture_select
+#define GL_DUAL_ALPHA4_SGIS               0x8110
+#define GL_DUAL_ALPHA8_SGIS               0x8111
+#define GL_DUAL_ALPHA12_SGIS              0x8112
+#define GL_DUAL_ALPHA16_SGIS              0x8113
+#define GL_DUAL_LUMINANCE4_SGIS           0x8114
+#define GL_DUAL_LUMINANCE8_SGIS           0x8115
+#define GL_DUAL_LUMINANCE12_SGIS          0x8116
+#define GL_DUAL_LUMINANCE16_SGIS          0x8117
+#define GL_DUAL_INTENSITY4_SGIS           0x8118
+#define GL_DUAL_INTENSITY8_SGIS           0x8119
+#define GL_DUAL_INTENSITY12_SGIS          0x811A
+#define GL_DUAL_INTENSITY16_SGIS          0x811B
+#define GL_DUAL_LUMINANCE_ALPHA4_SGIS     0x811C
+#define GL_DUAL_LUMINANCE_ALPHA8_SGIS     0x811D
+#define GL_QUAD_ALPHA4_SGIS               0x811E
+#define GL_QUAD_ALPHA8_SGIS               0x811F
+#define GL_QUAD_LUMINANCE4_SGIS           0x8120
+#define GL_QUAD_LUMINANCE8_SGIS           0x8121
+#define GL_QUAD_INTENSITY4_SGIS           0x8122
+#define GL_QUAD_INTENSITY8_SGIS           0x8123
+#define GL_DUAL_TEXTURE_SELECT_SGIS       0x8124
+#define GL_QUAD_TEXTURE_SELECT_SGIS       0x8125
+#endif
+
+#ifndef GL_SGIX_sprite
+#define GL_SPRITE_SGIX                    0x8148
+#define GL_SPRITE_MODE_SGIX               0x8149
+#define GL_SPRITE_AXIS_SGIX               0x814A
+#define GL_SPRITE_TRANSLATION_SGIX        0x814B
+#define GL_SPRITE_AXIAL_SGIX              0x814C
+#define GL_SPRITE_OBJECT_ALIGNED_SGIX     0x814D
+#define GL_SPRITE_EYE_ALIGNED_SGIX        0x814E
+#endif
+
+#ifndef GL_SGIX_texture_multi_buffer
+#define GL_TEXTURE_MULTI_BUFFER_HINT_SGIX 0x812E
+#endif
+
+#ifndef GL_EXT_point_parameters
+#define GL_POINT_SIZE_MIN_EXT             0x8126
+#define GL_POINT_SIZE_MAX_EXT             0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_EXT  0x8128
+#define GL_DISTANCE_ATTENUATION_EXT       0x8129
+#endif
+
+#ifndef GL_SGIS_point_parameters
+#define GL_POINT_SIZE_MIN_SGIS            0x8126
+#define GL_POINT_SIZE_MAX_SGIS            0x8127
+#define GL_POINT_FADE_THRESHOLD_SIZE_SGIS 0x8128
+#define GL_DISTANCE_ATTENUATION_SGIS      0x8129
+#endif
+
+#ifndef GL_SGIX_instruments
+#define GL_INSTRUMENT_BUFFER_POINTER_SGIX 0x8180
+#define GL_INSTRUMENT_MEASUREMENTS_SGIX   0x8181
+#endif
+
+#ifndef GL_SGIX_texture_scale_bias
+#define GL_POST_TEXTURE_FILTER_BIAS_SGIX  0x8179
+#define GL_POST_TEXTURE_FILTER_SCALE_SGIX 0x817A
+#define GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX 0x817B
+#define GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX 0x817C
+#endif
+
+#ifndef GL_SGIX_framezoom
+#define GL_FRAMEZOOM_SGIX                 0x818B
+#define GL_FRAMEZOOM_FACTOR_SGIX          0x818C
+#define GL_MAX_FRAMEZOOM_FACTOR_SGIX      0x818D
+#endif
+
+#ifndef GL_SGIX_tag_sample_buffer
+#endif
+
+#ifndef GL_FfdMaskSGIX
+#define GL_TEXTURE_DEFORMATION_BIT_SGIX   0x00000001
+#define GL_GEOMETRY_DEFORMATION_BIT_SGIX  0x00000002
+#endif
+
+#ifndef GL_SGIX_polynomial_ffd
+#define GL_GEOMETRY_DEFORMATION_SGIX      0x8194
+#define GL_TEXTURE_DEFORMATION_SGIX       0x8195
+#define GL_DEFORMATIONS_MASK_SGIX         0x8196
+#define GL_MAX_DEFORMATION_ORDER_SGIX     0x8197
+#endif
+
+#ifndef GL_SGIX_reference_plane
+#define GL_REFERENCE_PLANE_SGIX           0x817D
+#define GL_REFERENCE_PLANE_EQUATION_SGIX  0x817E
+#endif
+
+#ifndef GL_SGIX_flush_raster
+#endif
+
+#ifndef GL_SGIX_depth_texture
+#define GL_DEPTH_COMPONENT16_SGIX         0x81A5
+#define GL_DEPTH_COMPONENT24_SGIX         0x81A6
+#define GL_DEPTH_COMPONENT32_SGIX         0x81A7
+#endif
+
+#ifndef GL_SGIS_fog_function
+#define GL_FOG_FUNC_SGIS                  0x812A
+#define GL_FOG_FUNC_POINTS_SGIS           0x812B
+#define GL_MAX_FOG_FUNC_POINTS_SGIS       0x812C
+#endif
+
+#ifndef GL_SGIX_fog_offset
+#define GL_FOG_OFFSET_SGIX                0x8198
+#define GL_FOG_OFFSET_VALUE_SGIX          0x8199
+#endif
+
+#ifndef GL_HP_image_transform
+#define GL_IMAGE_SCALE_X_HP               0x8155
+#define GL_IMAGE_SCALE_Y_HP               0x8156
+#define GL_IMAGE_TRANSLATE_X_HP           0x8157
+#define GL_IMAGE_TRANSLATE_Y_HP           0x8158
+#define GL_IMAGE_ROTATE_ANGLE_HP          0x8159
+#define GL_IMAGE_ROTATE_ORIGIN_X_HP       0x815A
+#define GL_IMAGE_ROTATE_ORIGIN_Y_HP       0x815B
+#define GL_IMAGE_MAG_FILTER_HP            0x815C
+#define GL_IMAGE_MIN_FILTER_HP            0x815D
+#define GL_IMAGE_CUBIC_WEIGHT_HP          0x815E
+#define GL_CUBIC_HP                       0x815F
+#define GL_AVERAGE_HP                     0x8160
+#define GL_IMAGE_TRANSFORM_2D_HP          0x8161
+#define GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP 0x8162
+#define GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP 0x8163
+#endif
+
+#ifndef GL_HP_convolution_border_modes
+#define GL_IGNORE_BORDER_HP               0x8150
+#define GL_CONSTANT_BORDER_HP             0x8151
+#define GL_REPLICATE_BORDER_HP            0x8153
+#define GL_CONVOLUTION_BORDER_COLOR_HP    0x8154
+#endif
+
+#ifndef GL_INGR_palette_buffer
+#endif
+
+#ifndef GL_SGIX_texture_add_env
+#define GL_TEXTURE_ENV_BIAS_SGIX          0x80BE
+#endif
+
+#ifndef GL_EXT_color_subtable
+#endif
+
+#ifndef GL_PGI_vertex_hints
+#define GL_VERTEX_DATA_HINT_PGI           0x1A22A
+#define GL_VERTEX_CONSISTENT_HINT_PGI     0x1A22B
+#define GL_MATERIAL_SIDE_HINT_PGI         0x1A22C
+#define GL_MAX_VERTEX_HINT_PGI            0x1A22D
+#define GL_COLOR3_BIT_PGI                 0x00010000
+#define GL_COLOR4_BIT_PGI                 0x00020000
+#define GL_EDGEFLAG_BIT_PGI               0x00040000
+#define GL_INDEX_BIT_PGI                  0x00080000
+#define GL_MAT_AMBIENT_BIT_PGI            0x00100000
+#define GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI 0x00200000
+#define GL_MAT_DIFFUSE_BIT_PGI            0x00400000
+#define GL_MAT_EMISSION_BIT_PGI           0x00800000
+#define GL_MAT_COLOR_INDEXES_BIT_PGI      0x01000000
+#define GL_MAT_SHININESS_BIT_PGI          0x02000000
+#define GL_MAT_SPECULAR_BIT_PGI           0x04000000
+#define GL_NORMAL_BIT_PGI                 0x08000000
+#define GL_TEXCOORD1_BIT_PGI              0x10000000
+#define GL_TEXCOORD2_BIT_PGI              0x20000000
+#define GL_TEXCOORD3_BIT_PGI              0x40000000
+#define GL_TEXCOORD4_BIT_PGI              0x80000000
+#define GL_VERTEX23_BIT_PGI               0x00000004
+#define GL_VERTEX4_BIT_PGI                0x00000008
+#endif
+
+#ifndef GL_PGI_misc_hints
+#define GL_PREFER_DOUBLEBUFFER_HINT_PGI   0x1A1F8
+#define GL_CONSERVE_MEMORY_HINT_PGI       0x1A1FD
+#define GL_RECLAIM_MEMORY_HINT_PGI        0x1A1FE
+#define GL_NATIVE_GRAPHICS_HANDLE_PGI     0x1A202
+#define GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI 0x1A203
+#define GL_NATIVE_GRAPHICS_END_HINT_PGI   0x1A204
+#define GL_ALWAYS_FAST_HINT_PGI           0x1A20C
+#define GL_ALWAYS_SOFT_HINT_PGI           0x1A20D
+#define GL_ALLOW_DRAW_OBJ_HINT_PGI        0x1A20E
+#define GL_ALLOW_DRAW_WIN_HINT_PGI        0x1A20F
+#define GL_ALLOW_DRAW_FRG_HINT_PGI        0x1A210
+#define GL_ALLOW_DRAW_MEM_HINT_PGI        0x1A211
+#define GL_STRICT_DEPTHFUNC_HINT_PGI      0x1A216
+#define GL_STRICT_LIGHTING_HINT_PGI       0x1A217
+#define GL_STRICT_SCISSOR_HINT_PGI        0x1A218
+#define GL_FULL_STIPPLE_HINT_PGI          0x1A219
+#define GL_CLIP_NEAR_HINT_PGI             0x1A220
+#define GL_CLIP_FAR_HINT_PGI              0x1A221
+#define GL_WIDE_LINE_HINT_PGI             0x1A222
+#define GL_BACK_NORMALS_HINT_PGI          0x1A223
+#endif
+
+#ifndef GL_EXT_paletted_texture
+#define GL_COLOR_INDEX1_EXT               0x80E2
+#define GL_COLOR_INDEX2_EXT               0x80E3
+#define GL_COLOR_INDEX4_EXT               0x80E4
+#define GL_COLOR_INDEX8_EXT               0x80E5
+#define GL_COLOR_INDEX12_EXT              0x80E6
+#define GL_COLOR_INDEX16_EXT              0x80E7
+#define GL_TEXTURE_INDEX_SIZE_EXT         0x80ED
+#endif
+
+#ifndef GL_EXT_clip_volume_hint
+#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT  0x80F0
+#endif
+
+#ifndef GL_SGIX_list_priority
+#define GL_LIST_PRIORITY_SGIX             0x8182
+#endif
+
+#ifndef GL_SGIX_ir_instrument1
+#define GL_IR_INSTRUMENT1_SGIX            0x817F
+#endif
+
+#ifndef GL_SGIX_calligraphic_fragment
+#define GL_CALLIGRAPHIC_FRAGMENT_SGIX     0x8183
+#endif
+
+#ifndef GL_SGIX_texture_lod_bias
+#define GL_TEXTURE_LOD_BIAS_S_SGIX        0x818E
+#define GL_TEXTURE_LOD_BIAS_T_SGIX        0x818F
+#define GL_TEXTURE_LOD_BIAS_R_SGIX        0x8190
+#endif
+
+#ifndef GL_SGIX_shadow_ambient
+#define GL_SHADOW_AMBIENT_SGIX            0x80BF
+#endif
+
+#ifndef GL_EXT_index_texture
+#endif
+
+#ifndef GL_EXT_index_material
+#define GL_INDEX_MATERIAL_EXT             0x81B8
+#define GL_INDEX_MATERIAL_PARAMETER_EXT   0x81B9
+#define GL_INDEX_MATERIAL_FACE_EXT        0x81BA
+#endif
+
+#ifndef GL_EXT_index_func
+#define GL_INDEX_TEST_EXT                 0x81B5
+#define GL_INDEX_TEST_FUNC_EXT            0x81B6
+#define GL_INDEX_TEST_REF_EXT             0x81B7
+#endif
+
+#ifndef GL_EXT_index_array_formats
+#define GL_IUI_V2F_EXT                    0x81AD
+#define GL_IUI_V3F_EXT                    0x81AE
+#define GL_IUI_N3F_V2F_EXT                0x81AF
+#define GL_IUI_N3F_V3F_EXT                0x81B0
+#define GL_T2F_IUI_V2F_EXT                0x81B1
+#define GL_T2F_IUI_V3F_EXT                0x81B2
+#define GL_T2F_IUI_N3F_V2F_EXT            0x81B3
+#define GL_T2F_IUI_N3F_V3F_EXT            0x81B4
+#endif
+
+#ifndef GL_EXT_compiled_vertex_array
+#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT   0x81A8
+#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT   0x81A9
+#endif
+
+#ifndef GL_EXT_cull_vertex
+#define GL_CULL_VERTEX_EXT                0x81AA
+#define GL_CULL_VERTEX_EYE_POSITION_EXT   0x81AB
+#define GL_CULL_VERTEX_OBJECT_POSITION_EXT 0x81AC
+#endif
+
+#ifndef GL_SGIX_ycrcb
+#define GL_YCRCB_422_SGIX                 0x81BB
+#define GL_YCRCB_444_SGIX                 0x81BC
+#endif
+
+#ifndef GL_SGIX_fragment_lighting
+#define GL_FRAGMENT_LIGHTING_SGIX         0x8400
+#define GL_FRAGMENT_COLOR_MATERIAL_SGIX   0x8401
+#define GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX 0x8402
+#define GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX 0x8403
+#define GL_MAX_FRAGMENT_LIGHTS_SGIX       0x8404
+#define GL_MAX_ACTIVE_LIGHTS_SGIX         0x8405
+#define GL_CURRENT_RASTER_NORMAL_SGIX     0x8406
+#define GL_LIGHT_ENV_MODE_SGIX            0x8407
+#define GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX 0x8408
+#define GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX 0x8409
+#define GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX 0x840A
+#define GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX 0x840B
+#define GL_FRAGMENT_LIGHT0_SGIX           0x840C
+#define GL_FRAGMENT_LIGHT1_SGIX           0x840D
+#define GL_FRAGMENT_LIGHT2_SGIX           0x840E
+#define GL_FRAGMENT_LIGHT3_SGIX           0x840F
+#define GL_FRAGMENT_LIGHT4_SGIX           0x8410
+#define GL_FRAGMENT_LIGHT5_SGIX           0x8411
+#define GL_FRAGMENT_LIGHT6_SGIX           0x8412
+#define GL_FRAGMENT_LIGHT7_SGIX           0x8413
+#endif
+
+#ifndef GL_IBM_rasterpos_clip
+#define GL_RASTER_POSITION_UNCLIPPED_IBM  0x19262
+#endif
+
+#ifndef GL_HP_texture_lighting
+#define GL_TEXTURE_LIGHTING_MODE_HP       0x8167
+#define GL_TEXTURE_POST_SPECULAR_HP       0x8168
+#define GL_TEXTURE_PRE_SPECULAR_HP        0x8169
+#endif
+
+#ifndef GL_EXT_draw_range_elements
+#define GL_MAX_ELEMENTS_VERTICES_EXT      0x80E8
+#define GL_MAX_ELEMENTS_INDICES_EXT       0x80E9
+#endif
+
+#ifndef GL_WIN_phong_shading
+#define GL_PHONG_WIN                      0x80EA
+#define GL_PHONG_HINT_WIN                 0x80EB
+#endif
+
+#ifndef GL_WIN_specular_fog
+#define GL_FOG_SPECULAR_TEXTURE_WIN       0x80EC
+#endif
+
+#ifndef GL_EXT_light_texture
+#define GL_FRAGMENT_MATERIAL_EXT          0x8349
+#define GL_FRAGMENT_NORMAL_EXT            0x834A
+#define GL_FRAGMENT_COLOR_EXT             0x834C
+#define GL_ATTENUATION_EXT                0x834D
+#define GL_SHADOW_ATTENUATION_EXT         0x834E
+#define GL_TEXTURE_APPLICATION_MODE_EXT   0x834F
+#define GL_TEXTURE_LIGHT_EXT              0x8350
+#define GL_TEXTURE_MATERIAL_FACE_EXT      0x8351
+#define GL_TEXTURE_MATERIAL_PARAMETER_EXT 0x8352
+/* reuse GL_FRAGMENT_DEPTH_EXT */
+#endif
+
+#ifndef GL_SGIX_blend_alpha_minmax
+#define GL_ALPHA_MIN_SGIX                 0x8320
+#define GL_ALPHA_MAX_SGIX                 0x8321
+#endif
+
+#ifndef GL_SGIX_impact_pixel_texture
+#define GL_PIXEL_TEX_GEN_Q_CEILING_SGIX   0x8184
+#define GL_PIXEL_TEX_GEN_Q_ROUND_SGIX     0x8185
+#define GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX     0x8186
+#define GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX 0x8187
+#define GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX 0x8188
+#define GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX    0x8189
+#define GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX    0x818A
+#endif
+
+#ifndef GL_EXT_bgra
+#define GL_BGR_EXT                        0x80E0
+#define GL_BGRA_EXT                       0x80E1
+#endif
+
+#ifndef GL_SGIX_async
+#define GL_ASYNC_MARKER_SGIX              0x8329
+#endif
+
+#ifndef GL_SGIX_async_pixel
+#define GL_ASYNC_TEX_IMAGE_SGIX           0x835C
+#define GL_ASYNC_DRAW_PIXELS_SGIX         0x835D
+#define GL_ASYNC_READ_PIXELS_SGIX         0x835E
+#define GL_MAX_ASYNC_TEX_IMAGE_SGIX       0x835F
+#define GL_MAX_ASYNC_DRAW_PIXELS_SGIX     0x8360
+#define GL_MAX_ASYNC_READ_PIXELS_SGIX     0x8361
+#endif
+
+#ifndef GL_SGIX_async_histogram
+#define GL_ASYNC_HISTOGRAM_SGIX           0x832C
+#define GL_MAX_ASYNC_HISTOGRAM_SGIX       0x832D
+#endif
+
+#ifndef GL_INTEL_texture_scissor
+#endif
+
+#ifndef GL_INTEL_parallel_arrays
+#define GL_PARALLEL_ARRAYS_INTEL          0x83F4
+#define GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL 0x83F5
+#define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
+#define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
+#define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
+#endif
+
+#ifndef GL_HP_occlusion_test
+#define GL_OCCLUSION_TEST_HP              0x8165
+#define GL_OCCLUSION_TEST_RESULT_HP       0x8166
+#endif
+
+#ifndef GL_EXT_pixel_transform
+#define GL_PIXEL_TRANSFORM_2D_EXT         0x8330
+#define GL_PIXEL_MAG_FILTER_EXT           0x8331
+#define GL_PIXEL_MIN_FILTER_EXT           0x8332
+#define GL_PIXEL_CUBIC_WEIGHT_EXT         0x8333
+#define GL_CUBIC_EXT                      0x8334
+#define GL_AVERAGE_EXT                    0x8335
+#define GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8336
+#define GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT 0x8337
+#define GL_PIXEL_TRANSFORM_2D_MATRIX_EXT  0x8338
+#endif
+
+#ifndef GL_EXT_pixel_transform_color_table
+#endif
+
+#ifndef GL_EXT_shared_texture_palette
+#define GL_SHARED_TEXTURE_PALETTE_EXT     0x81FB
+#endif
+
+#ifndef GL_EXT_separate_specular_color
+#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT  0x81F8
+#define GL_SINGLE_COLOR_EXT               0x81F9
+#define GL_SEPARATE_SPECULAR_COLOR_EXT    0x81FA
+#endif
+
+#ifndef GL_EXT_secondary_color
+#define GL_COLOR_SUM_EXT                  0x8458
+#define GL_CURRENT_SECONDARY_COLOR_EXT    0x8459
+#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT 0x845A
+#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT 0x845B
+#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT 0x845C
+#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT 0x845D
+#define GL_SECONDARY_COLOR_ARRAY_EXT      0x845E
+#endif
+
+#ifndef GL_EXT_texture_perturb_normal
+#define GL_PERTURB_EXT                    0x85AE
+#define GL_TEXTURE_NORMAL_EXT             0x85AF
+#endif
+
+#ifndef GL_EXT_multi_draw_arrays
+#endif
+
+#ifndef GL_EXT_fog_coord
+#define GL_FOG_COORDINATE_SOURCE_EXT      0x8450
+#define GL_FOG_COORDINATE_EXT             0x8451
+#define GL_FRAGMENT_DEPTH_EXT             0x8452
+#define GL_CURRENT_FOG_COORDINATE_EXT     0x8453
+#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT  0x8454
+#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT 0x8455
+#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT 0x8456
+#define GL_FOG_COORDINATE_ARRAY_EXT       0x8457
+#endif
+
+#ifndef GL_REND_screen_coordinates
+#define GL_SCREEN_COORDINATES_REND        0x8490
+#define GL_INVERTED_SCREEN_W_REND         0x8491
+#endif
+
+#ifndef GL_EXT_coordinate_frame
+#define GL_TANGENT_ARRAY_EXT              0x8439
+#define GL_BINORMAL_ARRAY_EXT             0x843A
+#define GL_CURRENT_TANGENT_EXT            0x843B
+#define GL_CURRENT_BINORMAL_EXT           0x843C
+#define GL_TANGENT_ARRAY_TYPE_EXT         0x843E
+#define GL_TANGENT_ARRAY_STRIDE_EXT       0x843F
+#define GL_BINORMAL_ARRAY_TYPE_EXT        0x8440
+#define GL_BINORMAL_ARRAY_STRIDE_EXT      0x8441
+#define GL_TANGENT_ARRAY_POINTER_EXT      0x8442
+#define GL_BINORMAL_ARRAY_POINTER_EXT     0x8443
+#define GL_MAP1_TANGENT_EXT               0x8444
+#define GL_MAP2_TANGENT_EXT               0x8445
+#define GL_MAP1_BINORMAL_EXT              0x8446
+#define GL_MAP2_BINORMAL_EXT              0x8447
+#endif
+
+#ifndef GL_EXT_texture_env_combine
+#define GL_COMBINE_EXT                    0x8570
+#define GL_COMBINE_RGB_EXT                0x8571
+#define GL_COMBINE_ALPHA_EXT              0x8572
+#define GL_RGB_SCALE_EXT                  0x8573
+#define GL_ADD_SIGNED_EXT                 0x8574
+#define GL_INTERPOLATE_EXT                0x8575
+#define GL_CONSTANT_EXT                   0x8576
+#define GL_PRIMARY_COLOR_EXT              0x8577
+#define GL_PREVIOUS_EXT                   0x8578
+#define GL_SOURCE0_RGB_EXT                0x8580
+#define GL_SOURCE1_RGB_EXT                0x8581
+#define GL_SOURCE2_RGB_EXT                0x8582
+#define GL_SOURCE0_ALPHA_EXT              0x8588
+#define GL_SOURCE1_ALPHA_EXT              0x8589
+#define GL_SOURCE2_ALPHA_EXT              0x858A
+#define GL_OPERAND0_RGB_EXT               0x8590
+#define GL_OPERAND1_RGB_EXT               0x8591
+#define GL_OPERAND2_RGB_EXT               0x8592
+#define GL_OPERAND0_ALPHA_EXT             0x8598
+#define GL_OPERAND1_ALPHA_EXT             0x8599
+#define GL_OPERAND2_ALPHA_EXT             0x859A
+#endif
+
+#ifndef GL_APPLE_specular_vector
+#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE 0x85B0
+#endif
+
+#ifndef GL_APPLE_transform_hint
+#define GL_TRANSFORM_HINT_APPLE           0x85B1
+#endif
+
+#ifndef GL_SGIX_fog_scale
+#define GL_FOG_SCALE_SGIX                 0x81FC
+#define GL_FOG_SCALE_VALUE_SGIX           0x81FD
+#endif
+
+#ifndef GL_SUNX_constant_data
+#define GL_UNPACK_CONSTANT_DATA_SUNX      0x81D5
+#define GL_TEXTURE_CONSTANT_DATA_SUNX     0x81D6
+#endif
+
+#ifndef GL_SUN_global_alpha
+#define GL_GLOBAL_ALPHA_SUN               0x81D9
+#define GL_GLOBAL_ALPHA_FACTOR_SUN        0x81DA
+#endif
+
+#ifndef GL_SUN_triangle_list
+#define GL_RESTART_SUN                    0x0001
+#define GL_REPLACE_MIDDLE_SUN             0x0002
+#define GL_REPLACE_OLDEST_SUN             0x0003
+#define GL_TRIANGLE_LIST_SUN              0x81D7
+#define GL_REPLACEMENT_CODE_SUN           0x81D8
+#define GL_REPLACEMENT_CODE_ARRAY_SUN     0x85C0
+#define GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN 0x85C1
+#define GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN 0x85C2
+#define GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN 0x85C3
+#define GL_R1UI_V3F_SUN                   0x85C4
+#define GL_R1UI_C4UB_V3F_SUN              0x85C5
+#define GL_R1UI_C3F_V3F_SUN               0x85C6
+#define GL_R1UI_N3F_V3F_SUN               0x85C7
+#define GL_R1UI_C4F_N3F_V3F_SUN           0x85C8
+#define GL_R1UI_T2F_V3F_SUN               0x85C9
+#define GL_R1UI_T2F_N3F_V3F_SUN           0x85CA
+#define GL_R1UI_T2F_C4F_N3F_V3F_SUN       0x85CB
+#endif
+
+#ifndef GL_SUN_vertex
+#endif
+
+#ifndef GL_EXT_blend_func_separate
+#define GL_BLEND_DST_RGB_EXT              0x80C8
+#define GL_BLEND_SRC_RGB_EXT              0x80C9
+#define GL_BLEND_DST_ALPHA_EXT            0x80CA
+#define GL_BLEND_SRC_ALPHA_EXT            0x80CB
+#endif
+
+#ifndef GL_INGR_color_clamp
+#define GL_RED_MIN_CLAMP_INGR             0x8560
+#define GL_GREEN_MIN_CLAMP_INGR           0x8561
+#define GL_BLUE_MIN_CLAMP_INGR            0x8562
+#define GL_ALPHA_MIN_CLAMP_INGR           0x8563
+#define GL_RED_MAX_CLAMP_INGR             0x8564
+#define GL_GREEN_MAX_CLAMP_INGR           0x8565
+#define GL_BLUE_MAX_CLAMP_INGR            0x8566
+#define GL_ALPHA_MAX_CLAMP_INGR           0x8567
+#endif
+
+#ifndef GL_INGR_interlace_read
+#define GL_INTERLACE_READ_INGR            0x8568
+#endif
+
+#ifndef GL_EXT_stencil_wrap
+#define GL_INCR_WRAP_EXT                  0x8507
+#define GL_DECR_WRAP_EXT                  0x8508
+#endif
+
+#ifndef GL_EXT_422_pixels
+#define GL_422_EXT                        0x80CC
+#define GL_422_REV_EXT                    0x80CD
+#define GL_422_AVERAGE_EXT                0x80CE
+#define GL_422_REV_AVERAGE_EXT            0x80CF
+#endif
+
+#ifndef GL_NV_texgen_reflection
+#define GL_NORMAL_MAP_NV                  0x8511
+#define GL_REFLECTION_MAP_NV              0x8512
+#endif
+
+#ifndef GL_EXT_texture_cube_map
+#define GL_NORMAL_MAP_EXT                 0x8511
+#define GL_REFLECTION_MAP_EXT             0x8512
+#define GL_TEXTURE_CUBE_MAP_EXT           0x8513
+#define GL_TEXTURE_BINDING_CUBE_MAP_EXT   0x8514
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT 0x8515
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT 0x8516
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT 0x8517
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT 0x8518
+#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT 0x8519
+#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT 0x851A
+#define GL_PROXY_TEXTURE_CUBE_MAP_EXT     0x851B
+#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT  0x851C
+#endif
+
+#ifndef GL_SUN_convolution_border_modes
+#define GL_WRAP_BORDER_SUN                0x81D4
+#endif
+
+#ifndef GL_EXT_texture_env_add
+#endif
+
+#ifndef GL_EXT_texture_lod_bias
+#define GL_MAX_TEXTURE_LOD_BIAS_EXT       0x84FD
+#define GL_TEXTURE_FILTER_CONTROL_EXT     0x8500
+#define GL_TEXTURE_LOD_BIAS_EXT           0x8501
+#endif
+
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_TEXTURE_MAX_ANISOTROPY_EXT     0x84FE
+#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
+#endif
+
+#ifndef GL_EXT_vertex_weighting
+#define GL_MODELVIEW0_STACK_DEPTH_EXT     GL_MODELVIEW_STACK_DEPTH
+#define GL_MODELVIEW1_STACK_DEPTH_EXT     0x8502
+#define GL_MODELVIEW0_MATRIX_EXT          GL_MODELVIEW_MATRIX
+#define GL_MODELVIEW1_MATRIX_EXT          0x8506
+#define GL_VERTEX_WEIGHTING_EXT           0x8509
+#define GL_MODELVIEW0_EXT                 GL_MODELVIEW
+#define GL_MODELVIEW1_EXT                 0x850A
+#define GL_CURRENT_VERTEX_WEIGHT_EXT      0x850B
+#define GL_VERTEX_WEIGHT_ARRAY_EXT        0x850C
+#define GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT   0x850D
+#define GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT   0x850E
+#define GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT 0x850F
+#define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
+#endif
+
+#ifndef GL_NV_light_max_exponent
+#define GL_MAX_SHININESS_NV               0x8504
+#define GL_MAX_SPOT_EXPONENT_NV           0x8505
+#endif
+
+#ifndef GL_NV_vertex_array_range
+#define GL_VERTEX_ARRAY_RANGE_NV          0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV   0x851E
+#define GL_VERTEX_ARRAY_RANGE_VALID_NV    0x851F
+#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
+#define GL_VERTEX_ARRAY_RANGE_POINTER_NV  0x8521
+#endif
+
+#ifndef GL_NV_register_combiners
+#define GL_REGISTER_COMBINERS_NV          0x8522
+#define GL_VARIABLE_A_NV                  0x8523
+#define GL_VARIABLE_B_NV                  0x8524
+#define GL_VARIABLE_C_NV                  0x8525
+#define GL_VARIABLE_D_NV                  0x8526
+#define GL_VARIABLE_E_NV                  0x8527
+#define GL_VARIABLE_F_NV                  0x8528
+#define GL_VARIABLE_G_NV                  0x8529
+#define GL_CONSTANT_COLOR0_NV             0x852A
+#define GL_CONSTANT_COLOR1_NV             0x852B
+#define GL_PRIMARY_COLOR_NV               0x852C
+#define GL_SECONDARY_COLOR_NV             0x852D
+#define GL_SPARE0_NV                      0x852E
+#define GL_SPARE1_NV                      0x852F
+#define GL_DISCARD_NV                     0x8530
+#define GL_E_TIMES_F_NV                   0x8531
+#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV 0x8532
+#define GL_UNSIGNED_IDENTITY_NV           0x8536
+#define GL_UNSIGNED_INVERT_NV             0x8537
+#define GL_EXPAND_NORMAL_NV               0x8538
+#define GL_EXPAND_NEGATE_NV               0x8539
+#define GL_HALF_BIAS_NORMAL_NV            0x853A
+#define GL_HALF_BIAS_NEGATE_NV            0x853B
+#define GL_SIGNED_IDENTITY_NV             0x853C
+#define GL_SIGNED_NEGATE_NV               0x853D
+#define GL_SCALE_BY_TWO_NV                0x853E
+#define GL_SCALE_BY_FOUR_NV               0x853F
+#define GL_SCALE_BY_ONE_HALF_NV           0x8540
+#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV   0x8541
+#define GL_COMBINER_INPUT_NV              0x8542
+#define GL_COMBINER_MAPPING_NV            0x8543
+#define GL_COMBINER_COMPONENT_USAGE_NV    0x8544
+#define GL_COMBINER_AB_DOT_PRODUCT_NV     0x8545
+#define GL_COMBINER_CD_DOT_PRODUCT_NV     0x8546
+#define GL_COMBINER_MUX_SUM_NV            0x8547
+#define GL_COMBINER_SCALE_NV              0x8548
+#define GL_COMBINER_BIAS_NV               0x8549
+#define GL_COMBINER_AB_OUTPUT_NV          0x854A
+#define GL_COMBINER_CD_OUTPUT_NV          0x854B
+#define GL_COMBINER_SUM_OUTPUT_NV         0x854C
+#define GL_MAX_GENERAL_COMBINERS_NV       0x854D
+#define GL_NUM_GENERAL_COMBINERS_NV       0x854E
+#define GL_COLOR_SUM_CLAMP_NV             0x854F
+#define GL_COMBINER0_NV                   0x8550
+#define GL_COMBINER1_NV                   0x8551
+#define GL_COMBINER2_NV                   0x8552
+#define GL_COMBINER3_NV                   0x8553
+#define GL_COMBINER4_NV                   0x8554
+#define GL_COMBINER5_NV                   0x8555
+#define GL_COMBINER6_NV                   0x8556
+#define GL_COMBINER7_NV                   0x8557
+/* reuse GL_TEXTURE0_ARB */
+/* reuse GL_TEXTURE1_ARB */
+/* reuse GL_ZERO */
+/* reuse GL_NONE */
+/* reuse GL_FOG */
+#endif
+
+#ifndef GL_NV_fog_distance
+#define GL_FOG_DISTANCE_MODE_NV           0x855A
+#define GL_EYE_RADIAL_NV                  0x855B
+#define GL_EYE_PLANE_ABSOLUTE_NV          0x855C
+/* reuse GL_EYE_PLANE */
+#endif
+
+#ifndef GL_NV_texgen_emboss
+#define GL_EMBOSS_LIGHT_NV                0x855D
+#define GL_EMBOSS_CONSTANT_NV             0x855E
+#define GL_EMBOSS_MAP_NV                  0x855F
+#endif
+
+#ifndef GL_NV_blend_square
+#endif
+
+#ifndef GL_NV_texture_env_combine4
+#define GL_COMBINE4_NV                    0x8503
+#define GL_SOURCE3_RGB_NV                 0x8583
+#define GL_SOURCE3_ALPHA_NV               0x858B
+#define GL_OPERAND3_RGB_NV                0x8593
+#define GL_OPERAND3_ALPHA_NV              0x859B
+#endif
+
+#ifndef GL_MESA_resize_buffers
+#endif
+
+#ifndef GL_MESA_window_pos
+#endif
+
+#ifndef GL_EXT_texture_compression_s3tc
+#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT   0x83F0
+#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  0x83F1
+#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  0x83F2
+#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  0x83F3
+#endif
+
+#ifndef GL_IBM_cull_vertex
+#define GL_CULL_VERTEX_IBM                103050
+#endif
+
+#ifndef GL_IBM_multimode_draw_arrays
+#endif
+
+#ifndef GL_IBM_vertex_array_lists
+#define GL_VERTEX_ARRAY_LIST_IBM          103070
+#define GL_NORMAL_ARRAY_LIST_IBM          103071
+#define GL_COLOR_ARRAY_LIST_IBM           103072
+#define GL_INDEX_ARRAY_LIST_IBM           103073
+#define GL_TEXTURE_COORD_ARRAY_LIST_IBM   103074
+#define GL_EDGE_FLAG_ARRAY_LIST_IBM       103075
+#define GL_FOG_COORDINATE_ARRAY_LIST_IBM  103076
+#define GL_SECONDARY_COLOR_ARRAY_LIST_IBM 103077
+#define GL_VERTEX_ARRAY_LIST_STRIDE_IBM   103080
+#define GL_NORMAL_ARRAY_LIST_STRIDE_IBM   103081
+#define GL_COLOR_ARRAY_LIST_STRIDE_IBM    103082
+#define GL_INDEX_ARRAY_LIST_STRIDE_IBM    103083
+#define GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM 103084
+#define GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM 103085
+#define GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM 103086
+#define GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM 103087
+#endif
+
+#ifndef GL_SGIX_subsample
+#define GL_PACK_SUBSAMPLE_RATE_SGIX       0x85A0
+#define GL_UNPACK_SUBSAMPLE_RATE_SGIX     0x85A1
+#define GL_PIXEL_SUBSAMPLE_4444_SGIX      0x85A2
+#define GL_PIXEL_SUBSAMPLE_2424_SGIX      0x85A3
+#define GL_PIXEL_SUBSAMPLE_4242_SGIX      0x85A4
+#endif
+
+#ifndef GL_SGIX_ycrcb_subsample
+#endif
+
+#ifndef GL_SGIX_ycrcba
+#define GL_YCRCB_SGIX                     0x8318
+#define GL_YCRCBA_SGIX                    0x8319
+#endif
+
+#ifndef GL_SGI_depth_pass_instrument
+#define GL_DEPTH_PASS_INSTRUMENT_SGIX     0x8310
+#define GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX 0x8311
+#define GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX 0x8312
+#endif
+
+#ifndef GL_3DFX_texture_compression_FXT1
+#define GL_COMPRESSED_RGB_FXT1_3DFX       0x86B0
+#define GL_COMPRESSED_RGBA_FXT1_3DFX      0x86B1
+#endif
+
+#ifndef GL_3DFX_multisample
+#define GL_MULTISAMPLE_3DFX               0x86B2
+#define GL_SAMPLE_BUFFERS_3DFX            0x86B3
+#define GL_SAMPLES_3DFX                   0x86B4
+#define GL_MULTISAMPLE_BIT_3DFX           0x20000000
+#endif
+
+#ifndef GL_3DFX_tbuffer
+#endif
+
+#ifndef GL_EXT_multisample
+#define GL_MULTISAMPLE_EXT                0x809D
+#define GL_SAMPLE_ALPHA_TO_MASK_EXT       0x809E
+#define GL_SAMPLE_ALPHA_TO_ONE_EXT        0x809F
+#define GL_SAMPLE_MASK_EXT                0x80A0
+#define GL_1PASS_EXT                      0x80A1
+#define GL_2PASS_0_EXT                    0x80A2
+#define GL_2PASS_1_EXT                    0x80A3
+#define GL_4PASS_0_EXT                    0x80A4
+#define GL_4PASS_1_EXT                    0x80A5
+#define GL_4PASS_2_EXT                    0x80A6
+#define GL_4PASS_3_EXT                    0x80A7
+#define GL_SAMPLE_BUFFERS_EXT             0x80A8
+#define GL_SAMPLES_EXT                    0x80A9
+#define GL_SAMPLE_MASK_VALUE_EXT          0x80AA
+#define GL_SAMPLE_MASK_INVERT_EXT         0x80AB
+#define GL_SAMPLE_PATTERN_EXT             0x80AC
+#define GL_MULTISAMPLE_BIT_EXT            0x20000000
+#endif
+
+#ifndef GL_SGIX_vertex_preclip
+#define GL_VERTEX_PRECLIP_SGIX            0x83EE
+#define GL_VERTEX_PRECLIP_HINT_SGIX       0x83EF
+#endif
+
+#ifndef GL_SGIX_convolution_accuracy
+#define GL_CONVOLUTION_HINT_SGIX          0x8316
+#endif
+
+#ifndef GL_SGIX_resample
+#define GL_PACK_RESAMPLE_SGIX             0x842C
+#define GL_UNPACK_RESAMPLE_SGIX           0x842D
+#define GL_RESAMPLE_REPLICATE_SGIX        0x842E
+#define GL_RESAMPLE_ZERO_FILL_SGIX        0x842F
+#define GL_RESAMPLE_DECIMATE_SGIX         0x8430
+#endif
+
+#ifndef GL_SGIS_point_line_texgen
+#define GL_EYE_DISTANCE_TO_POINT_SGIS     0x81F0
+#define GL_OBJECT_DISTANCE_TO_POINT_SGIS  0x81F1
+#define GL_EYE_DISTANCE_TO_LINE_SGIS      0x81F2
+#define GL_OBJECT_DISTANCE_TO_LINE_SGIS   0x81F3
+#define GL_EYE_POINT_SGIS                 0x81F4
+#define GL_OBJECT_POINT_SGIS              0x81F5
+#define GL_EYE_LINE_SGIS                  0x81F6
+#define GL_OBJECT_LINE_SGIS               0x81F7
+#endif
+
+#ifndef GL_SGIS_texture_color_mask
+#define GL_TEXTURE_COLOR_WRITEMASK_SGIS   0x81EF
+#endif
+
+#ifndef GL_EXT_texture_env_dot3
+#define GL_DOT3_RGB_EXT                   0x8740
+#define GL_DOT3_RGBA_EXT                  0x8741
+#endif
+
+#ifndef GL_ATI_texture_mirror_once
+#define GL_MIRROR_CLAMP_ATI               0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_ATI       0x8743
+#endif
+
+#ifndef GL_NV_fence
+#define GL_ALL_COMPLETED_NV               0x84F2
+#define GL_FENCE_STATUS_NV                0x84F3
+#define GL_FENCE_CONDITION_NV             0x84F4
+#endif
+
+#ifndef GL_IBM_texture_mirrored_repeat
+#define GL_MIRRORED_REPEAT_IBM            0x8370
+#endif
+
+#ifndef GL_NV_evaluators
+#define GL_EVAL_2D_NV                     0x86C0
+#define GL_EVAL_TRIANGULAR_2D_NV          0x86C1
+#define GL_MAP_TESSELLATION_NV            0x86C2
+#define GL_MAP_ATTRIB_U_ORDER_NV          0x86C3
+#define GL_MAP_ATTRIB_V_ORDER_NV          0x86C4
+#define GL_EVAL_FRACTIONAL_TESSELLATION_NV 0x86C5
+#define GL_EVAL_VERTEX_ATTRIB0_NV         0x86C6
+#define GL_EVAL_VERTEX_ATTRIB1_NV         0x86C7
+#define GL_EVAL_VERTEX_ATTRIB2_NV         0x86C8
+#define GL_EVAL_VERTEX_ATTRIB3_NV         0x86C9
+#define GL_EVAL_VERTEX_ATTRIB4_NV         0x86CA
+#define GL_EVAL_VERTEX_ATTRIB5_NV         0x86CB
+#define GL_EVAL_VERTEX_ATTRIB6_NV         0x86CC
+#define GL_EVAL_VERTEX_ATTRIB7_NV         0x86CD
+#define GL_EVAL_VERTEX_ATTRIB8_NV         0x86CE
+#define GL_EVAL_VERTEX_ATTRIB9_NV         0x86CF
+#define GL_EVAL_VERTEX_ATTRIB10_NV        0x86D0
+#define GL_EVAL_VERTEX_ATTRIB11_NV        0x86D1
+#define GL_EVAL_VERTEX_ATTRIB12_NV        0x86D2
+#define GL_EVAL_VERTEX_ATTRIB13_NV        0x86D3
+#define GL_EVAL_VERTEX_ATTRIB14_NV        0x86D4
+#define GL_EVAL_VERTEX_ATTRIB15_NV        0x86D5
+#define GL_MAX_MAP_TESSELLATION_NV        0x86D6
+#define GL_MAX_RATIONAL_EVAL_ORDER_NV     0x86D7
+#endif
+
+#ifndef GL_NV_packed_depth_stencil
+#define GL_DEPTH_STENCIL_NV               0x84F9
+#define GL_UNSIGNED_INT_24_8_NV           0x84FA
+#endif
+
+#ifndef GL_NV_register_combiners2
+#define GL_PER_STAGE_CONSTANTS_NV         0x8535
+#endif
+
+#ifndef GL_NV_texture_compression_vtc
+#endif
+
+#ifndef GL_NV_texture_rectangle
+#define GL_TEXTURE_RECTANGLE_NV           0x84F5
+#define GL_TEXTURE_BINDING_RECTANGLE_NV   0x84F6
+#define GL_PROXY_TEXTURE_RECTANGLE_NV     0x84F7
+#define GL_MAX_RECTANGLE_TEXTURE_SIZE_NV  0x84F8
+#endif
+
+#ifndef GL_NV_texture_shader
+#define GL_OFFSET_TEXTURE_RECTANGLE_NV    0x864C
+#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV 0x864D
+#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV 0x864E
+#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV 0x86D9
+#define GL_UNSIGNED_INT_S8_S8_8_8_NV      0x86DA
+#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV  0x86DB
+#define GL_DSDT_MAG_INTENSITY_NV          0x86DC
+#define GL_SHADER_CONSISTENT_NV           0x86DD
+#define GL_TEXTURE_SHADER_NV              0x86DE
+#define GL_SHADER_OPERATION_NV            0x86DF
+#define GL_CULL_MODES_NV                  0x86E0
+#define GL_OFFSET_TEXTURE_MATRIX_NV       0x86E1
+#define GL_OFFSET_TEXTURE_SCALE_NV        0x86E2
+#define GL_OFFSET_TEXTURE_BIAS_NV         0x86E3
+#define GL_OFFSET_TEXTURE_2D_MATRIX_NV    GL_OFFSET_TEXTURE_MATRIX_NV
+#define GL_OFFSET_TEXTURE_2D_SCALE_NV     GL_OFFSET_TEXTURE_SCALE_NV
+#define GL_OFFSET_TEXTURE_2D_BIAS_NV      GL_OFFSET_TEXTURE_BIAS_NV
+#define GL_PREVIOUS_TEXTURE_INPUT_NV      0x86E4
+#define GL_CONST_EYE_NV                   0x86E5
+#define GL_PASS_THROUGH_NV                0x86E6
+#define GL_CULL_FRAGMENT_NV               0x86E7
+#define GL_OFFSET_TEXTURE_2D_NV           0x86E8
+#define GL_DEPENDENT_AR_TEXTURE_2D_NV     0x86E9
+#define GL_DEPENDENT_GB_TEXTURE_2D_NV     0x86EA
+#define GL_DOT_PRODUCT_NV                 0x86EC
+#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV   0x86ED
+#define GL_DOT_PRODUCT_TEXTURE_2D_NV      0x86EE
+#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV 0x86F0
+#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV 0x86F1
+#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV 0x86F2
+#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV 0x86F3
+#define GL_HILO_NV                        0x86F4
+#define GL_DSDT_NV                        0x86F5
+#define GL_DSDT_MAG_NV                    0x86F6
+#define GL_DSDT_MAG_VIB_NV                0x86F7
+#define GL_HILO16_NV                      0x86F8
+#define GL_SIGNED_HILO_NV                 0x86F9
+#define GL_SIGNED_HILO16_NV               0x86FA
+#define GL_SIGNED_RGBA_NV                 0x86FB
+#define GL_SIGNED_RGBA8_NV                0x86FC
+#define GL_SIGNED_RGB_NV                  0x86FE
+#define GL_SIGNED_RGB8_NV                 0x86FF
+#define GL_SIGNED_LUMINANCE_NV            0x8701
+#define GL_SIGNED_LUMINANCE8_NV           0x8702
+#define GL_SIGNED_LUMINANCE_ALPHA_NV      0x8703
+#define GL_SIGNED_LUMINANCE8_ALPHA8_NV    0x8704
+#define GL_SIGNED_ALPHA_NV                0x8705
+#define GL_SIGNED_ALPHA8_NV               0x8706
+#define GL_SIGNED_INTENSITY_NV            0x8707
+#define GL_SIGNED_INTENSITY8_NV           0x8708
+#define GL_DSDT8_NV                       0x8709
+#define GL_DSDT8_MAG8_NV                  0x870A
+#define GL_DSDT8_MAG8_INTENSITY8_NV       0x870B
+#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV   0x870C
+#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV 0x870D
+#define GL_HI_SCALE_NV                    0x870E
+#define GL_LO_SCALE_NV                    0x870F
+#define GL_DS_SCALE_NV                    0x8710
+#define GL_DT_SCALE_NV                    0x8711
+#define GL_MAGNITUDE_SCALE_NV             0x8712
+#define GL_VIBRANCE_SCALE_NV              0x8713
+#define GL_HI_BIAS_NV                     0x8714
+#define GL_LO_BIAS_NV                     0x8715
+#define GL_DS_BIAS_NV                     0x8716
+#define GL_DT_BIAS_NV                     0x8717
+#define GL_MAGNITUDE_BIAS_NV              0x8718
+#define GL_VIBRANCE_BIAS_NV               0x8719
+#define GL_TEXTURE_BORDER_VALUES_NV       0x871A
+#define GL_TEXTURE_HI_SIZE_NV             0x871B
+#define GL_TEXTURE_LO_SIZE_NV             0x871C
+#define GL_TEXTURE_DS_SIZE_NV             0x871D
+#define GL_TEXTURE_DT_SIZE_NV             0x871E
+#define GL_TEXTURE_MAG_SIZE_NV            0x871F
+#endif
+
+#ifndef GL_NV_texture_shader2
+#define GL_DOT_PRODUCT_TEXTURE_3D_NV      0x86EF
+#endif
+
+#ifndef GL_NV_vertex_array_range2
+#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV 0x8533
+#endif
+
+#ifndef GL_NV_vertex_program
+#define GL_VERTEX_PROGRAM_NV              0x8620
+#define GL_VERTEX_STATE_PROGRAM_NV        0x8621
+#define GL_ATTRIB_ARRAY_SIZE_NV           0x8623
+#define GL_ATTRIB_ARRAY_STRIDE_NV         0x8624
+#define GL_ATTRIB_ARRAY_TYPE_NV           0x8625
+#define GL_CURRENT_ATTRIB_NV              0x8626
+#define GL_PROGRAM_LENGTH_NV              0x8627
+#define GL_PROGRAM_STRING_NV              0x8628
+#define GL_MODELVIEW_PROJECTION_NV        0x8629
+#define GL_IDENTITY_NV                    0x862A
+#define GL_INVERSE_NV                     0x862B
+#define GL_TRANSPOSE_NV                   0x862C
+#define GL_INVERSE_TRANSPOSE_NV           0x862D
+#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
+#define GL_MAX_TRACK_MATRICES_NV          0x862F
+#define GL_MATRIX0_NV                     0x8630
+#define GL_MATRIX1_NV                     0x8631
+#define GL_MATRIX2_NV                     0x8632
+#define GL_MATRIX3_NV                     0x8633
+#define GL_MATRIX4_NV                     0x8634
+#define GL_MATRIX5_NV                     0x8635
+#define GL_MATRIX6_NV                     0x8636
+#define GL_MATRIX7_NV                     0x8637
+#define GL_CURRENT_MATRIX_STACK_DEPTH_NV  0x8640
+#define GL_CURRENT_MATRIX_NV              0x8641
+#define GL_VERTEX_PROGRAM_POINT_SIZE_NV   0x8642
+#define GL_VERTEX_PROGRAM_TWO_SIDE_NV     0x8643
+#define GL_PROGRAM_PARAMETER_NV           0x8644
+#define GL_ATTRIB_ARRAY_POINTER_NV        0x8645
+#define GL_PROGRAM_TARGET_NV              0x8646
+#define GL_PROGRAM_RESIDENT_NV            0x8647
+#define GL_TRACK_MATRIX_NV                0x8648
+#define GL_TRACK_MATRIX_TRANSFORM_NV      0x8649
+#define GL_VERTEX_PROGRAM_BINDING_NV      0x864A
+#define GL_PROGRAM_ERROR_POSITION_NV      0x864B
+#define GL_VERTEX_ATTRIB_ARRAY0_NV        0x8650
+#define GL_VERTEX_ATTRIB_ARRAY1_NV        0x8651
+#define GL_VERTEX_ATTRIB_ARRAY2_NV        0x8652
+#define GL_VERTEX_ATTRIB_ARRAY3_NV        0x8653
+#define GL_VERTEX_ATTRIB_ARRAY4_NV        0x8654
+#define GL_VERTEX_ATTRIB_ARRAY5_NV        0x8655
+#define GL_VERTEX_ATTRIB_ARRAY6_NV        0x8656
+#define GL_VERTEX_ATTRIB_ARRAY7_NV        0x8657
+#define GL_VERTEX_ATTRIB_ARRAY8_NV        0x8658
+#define GL_VERTEX_ATTRIB_ARRAY9_NV        0x8659
+#define GL_VERTEX_ATTRIB_ARRAY10_NV       0x865A
+#define GL_VERTEX_ATTRIB_ARRAY11_NV       0x865B
+#define GL_VERTEX_ATTRIB_ARRAY12_NV       0x865C
+#define GL_VERTEX_ATTRIB_ARRAY13_NV       0x865D
+#define GL_VERTEX_ATTRIB_ARRAY14_NV       0x865E
+#define GL_VERTEX_ATTRIB_ARRAY15_NV       0x865F
+#define GL_MAP1_VERTEX_ATTRIB0_4_NV       0x8660
+#define GL_MAP1_VERTEX_ATTRIB1_4_NV       0x8661
+#define GL_MAP1_VERTEX_ATTRIB2_4_NV       0x8662
+#define GL_MAP1_VERTEX_ATTRIB3_4_NV       0x8663
+#define GL_MAP1_VERTEX_ATTRIB4_4_NV       0x8664
+#define GL_MAP1_VERTEX_ATTRIB5_4_NV       0x8665
+#define GL_MAP1_VERTEX_ATTRIB6_4_NV       0x8666
+#define GL_MAP1_VERTEX_ATTRIB7_4_NV       0x8667
+#define GL_MAP1_VERTEX_ATTRIB8_4_NV       0x8668
+#define GL_MAP1_VERTEX_ATTRIB9_4_NV       0x8669
+#define GL_MAP1_VERTEX_ATTRIB10_4_NV      0x866A
+#define GL_MAP1_VERTEX_ATTRIB11_4_NV      0x866B
+#define GL_MAP1_VERTEX_ATTRIB12_4_NV      0x866C
+#define GL_MAP1_VERTEX_ATTRIB13_4_NV      0x866D
+#define GL_MAP1_VERTEX_ATTRIB14_4_NV      0x866E
+#define GL_MAP1_VERTEX_ATTRIB15_4_NV      0x866F
+#define GL_MAP2_VERTEX_ATTRIB0_4_NV       0x8670
+#define GL_MAP2_VERTEX_ATTRIB1_4_NV       0x8671
+#define GL_MAP2_VERTEX_ATTRIB2_4_NV       0x8672
+#define GL_MAP2_VERTEX_ATTRIB3_4_NV       0x8673
+#define GL_MAP2_VERTEX_ATTRIB4_4_NV       0x8674
+#define GL_MAP2_VERTEX_ATTRIB5_4_NV       0x8675
+#define GL_MAP2_VERTEX_ATTRIB6_4_NV       0x8676
+#define GL_MAP2_VERTEX_ATTRIB7_4_NV       0x8677
+#define GL_MAP2_VERTEX_ATTRIB8_4_NV       0x8678
+#define GL_MAP2_VERTEX_ATTRIB9_4_NV       0x8679
+#define GL_MAP2_VERTEX_ATTRIB10_4_NV      0x867A
+#define GL_MAP2_VERTEX_ATTRIB11_4_NV      0x867B
+#define GL_MAP2_VERTEX_ATTRIB12_4_NV      0x867C
+#define GL_MAP2_VERTEX_ATTRIB13_4_NV      0x867D
+#define GL_MAP2_VERTEX_ATTRIB14_4_NV      0x867E
+#define GL_MAP2_VERTEX_ATTRIB15_4_NV      0x867F
+#endif
+
+#ifndef GL_SGIX_texture_coordinate_clamp
+#define GL_TEXTURE_MAX_CLAMP_S_SGIX       0x8369
+#define GL_TEXTURE_MAX_CLAMP_T_SGIX       0x836A
+#define GL_TEXTURE_MAX_CLAMP_R_SGIX       0x836B
+#endif
+
+#ifndef GL_SGIX_scalebias_hint
+#define GL_SCALEBIAS_HINT_SGIX            0x8322
+#endif
+
+#ifndef GL_OML_interlace
+#define GL_INTERLACE_OML                  0x8980
+#define GL_INTERLACE_READ_OML             0x8981
+#endif
+
+#ifndef GL_OML_subsample
+#define GL_FORMAT_SUBSAMPLE_24_24_OML     0x8982
+#define GL_FORMAT_SUBSAMPLE_244_244_OML   0x8983
+#endif
+
+#ifndef GL_OML_resample
+#define GL_PACK_RESAMPLE_OML              0x8984
+#define GL_UNPACK_RESAMPLE_OML            0x8985
+#define GL_RESAMPLE_REPLICATE_OML         0x8986
+#define GL_RESAMPLE_ZERO_FILL_OML         0x8987
+#define GL_RESAMPLE_AVERAGE_OML           0x8988
+#define GL_RESAMPLE_DECIMATE_OML          0x8989
+#endif
+
+#ifndef GL_NV_copy_depth_to_color
+#define GL_DEPTH_STENCIL_TO_RGBA_NV       0x886E
+#define GL_DEPTH_STENCIL_TO_BGRA_NV       0x886F
+#endif
+
+#ifndef GL_ATI_envmap_bumpmap
+#define GL_BUMP_ROT_MATRIX_ATI            0x8775
+#define GL_BUMP_ROT_MATRIX_SIZE_ATI       0x8776
+#define GL_BUMP_NUM_TEX_UNITS_ATI         0x8777
+#define GL_BUMP_TEX_UNITS_ATI             0x8778
+#define GL_DUDV_ATI                       0x8779
+#define GL_DU8DV8_ATI                     0x877A
+#define GL_BUMP_ENVMAP_ATI                0x877B
+#define GL_BUMP_TARGET_ATI                0x877C
+#endif
+
+#ifndef GL_ATI_fragment_shader
+#define GL_FRAGMENT_SHADER_ATI            0x8920
+#define GL_REG_0_ATI                      0x8921
+#define GL_REG_1_ATI                      0x8922
+#define GL_REG_2_ATI                      0x8923
+#define GL_REG_3_ATI                      0x8924
+#define GL_REG_4_ATI                      0x8925
+#define GL_REG_5_ATI                      0x8926
+#define GL_REG_6_ATI                      0x8927
+#define GL_REG_7_ATI                      0x8928
+#define GL_REG_8_ATI                      0x8929
+#define GL_REG_9_ATI                      0x892A
+#define GL_REG_10_ATI                     0x892B
+#define GL_REG_11_ATI                     0x892C
+#define GL_REG_12_ATI                     0x892D
+#define GL_REG_13_ATI                     0x892E
+#define GL_REG_14_ATI                     0x892F
+#define GL_REG_15_ATI                     0x8930
+#define GL_REG_16_ATI                     0x8931
+#define GL_REG_17_ATI                     0x8932
+#define GL_REG_18_ATI                     0x8933
+#define GL_REG_19_ATI                     0x8934
+#define GL_REG_20_ATI                     0x8935
+#define GL_REG_21_ATI                     0x8936
+#define GL_REG_22_ATI                     0x8937
+#define GL_REG_23_ATI                     0x8938
+#define GL_REG_24_ATI                     0x8939
+#define GL_REG_25_ATI                     0x893A
+#define GL_REG_26_ATI                     0x893B
+#define GL_REG_27_ATI                     0x893C
+#define GL_REG_28_ATI                     0x893D
+#define GL_REG_29_ATI                     0x893E
+#define GL_REG_30_ATI                     0x893F
+#define GL_REG_31_ATI                     0x8940
+#define GL_CON_0_ATI                      0x8941
+#define GL_CON_1_ATI                      0x8942
+#define GL_CON_2_ATI                      0x8943
+#define GL_CON_3_ATI                      0x8944
+#define GL_CON_4_ATI                      0x8945
+#define GL_CON_5_ATI                      0x8946
+#define GL_CON_6_ATI                      0x8947
+#define GL_CON_7_ATI                      0x8948
+#define GL_CON_8_ATI                      0x8949
+#define GL_CON_9_ATI                      0x894A
+#define GL_CON_10_ATI                     0x894B
+#define GL_CON_11_ATI                     0x894C
+#define GL_CON_12_ATI                     0x894D
+#define GL_CON_13_ATI                     0x894E
+#define GL_CON_14_ATI                     0x894F
+#define GL_CON_15_ATI                     0x8950
+#define GL_CON_16_ATI                     0x8951
+#define GL_CON_17_ATI                     0x8952
+#define GL_CON_18_ATI                     0x8953
+#define GL_CON_19_ATI                     0x8954
+#define GL_CON_20_ATI                     0x8955
+#define GL_CON_21_ATI                     0x8956
+#define GL_CON_22_ATI                     0x8957
+#define GL_CON_23_ATI                     0x8958
+#define GL_CON_24_ATI                     0x8959
+#define GL_CON_25_ATI                     0x895A
+#define GL_CON_26_ATI                     0x895B
+#define GL_CON_27_ATI                     0x895C
+#define GL_CON_28_ATI                     0x895D
+#define GL_CON_29_ATI                     0x895E
+#define GL_CON_30_ATI                     0x895F
+#define GL_CON_31_ATI                     0x8960
+#define GL_MOV_ATI                        0x8961
+#define GL_ADD_ATI                        0x8963
+#define GL_MUL_ATI                        0x8964
+#define GL_SUB_ATI                        0x8965
+#define GL_DOT3_ATI                       0x8966
+#define GL_DOT4_ATI                       0x8967
+#define GL_MAD_ATI                        0x8968
+#define GL_LERP_ATI                       0x8969
+#define GL_CND_ATI                        0x896A
+#define GL_CND0_ATI                       0x896B
+#define GL_DOT2_ADD_ATI                   0x896C
+#define GL_SECONDARY_INTERPOLATOR_ATI     0x896D
+#define GL_NUM_FRAGMENT_REGISTERS_ATI     0x896E
+#define GL_NUM_FRAGMENT_CONSTANTS_ATI     0x896F
+#define GL_NUM_PASSES_ATI                 0x8970
+#define GL_NUM_INSTRUCTIONS_PER_PASS_ATI  0x8971
+#define GL_NUM_INSTRUCTIONS_TOTAL_ATI     0x8972
+#define GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI 0x8973
+#define GL_NUM_LOOPBACK_COMPONENTS_ATI    0x8974
+#define GL_COLOR_ALPHA_PAIRING_ATI        0x8975
+#define GL_SWIZZLE_STR_ATI                0x8976
+#define GL_SWIZZLE_STQ_ATI                0x8977
+#define GL_SWIZZLE_STR_DR_ATI             0x8978
+#define GL_SWIZZLE_STQ_DQ_ATI             0x8979
+#define GL_SWIZZLE_STRQ_ATI               0x897A
+#define GL_SWIZZLE_STRQ_DQ_ATI            0x897B
+#define GL_RED_BIT_ATI                    0x00000001
+#define GL_GREEN_BIT_ATI                  0x00000002
+#define GL_BLUE_BIT_ATI                   0x00000004
+#define GL_2X_BIT_ATI                     0x00000001
+#define GL_4X_BIT_ATI                     0x00000002
+#define GL_8X_BIT_ATI                     0x00000004
+#define GL_HALF_BIT_ATI                   0x00000008
+#define GL_QUARTER_BIT_ATI                0x00000010
+#define GL_EIGHTH_BIT_ATI                 0x00000020
+#define GL_SATURATE_BIT_ATI               0x00000040
+#define GL_COMP_BIT_ATI                   0x00000002
+#define GL_NEGATE_BIT_ATI                 0x00000004
+#define GL_BIAS_BIT_ATI                   0x00000008
+#endif
+
+#ifndef GL_ATI_pn_triangles
+#define GL_PN_TRIANGLES_ATI               0x87F0
+#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F1
+#define GL_PN_TRIANGLES_POINT_MODE_ATI    0x87F2
+#define GL_PN_TRIANGLES_NORMAL_MODE_ATI   0x87F3
+#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI 0x87F4
+#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI 0x87F5
+#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI 0x87F6
+#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI 0x87F7
+#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI 0x87F8
+#endif
+
+#ifndef GL_ATI_vertex_array_object
+#define GL_STATIC_ATI                     0x8760
+#define GL_DYNAMIC_ATI                    0x8761
+#define GL_PRESERVE_ATI                   0x8762
+#define GL_DISCARD_ATI                    0x8763
+#define GL_OBJECT_BUFFER_SIZE_ATI         0x8764
+#define GL_OBJECT_BUFFER_USAGE_ATI        0x8765
+#define GL_ARRAY_OBJECT_BUFFER_ATI        0x8766
+#define GL_ARRAY_OBJECT_OFFSET_ATI        0x8767
+#endif
+
+#ifndef GL_EXT_vertex_shader
+#define GL_VERTEX_SHADER_EXT              0x8780
+#define GL_VERTEX_SHADER_BINDING_EXT      0x8781
+#define GL_OP_INDEX_EXT                   0x8782
+#define GL_OP_NEGATE_EXT                  0x8783
+#define GL_OP_DOT3_EXT                    0x8784
+#define GL_OP_DOT4_EXT                    0x8785
+#define GL_OP_MUL_EXT                     0x8786
+#define GL_OP_ADD_EXT                     0x8787
+#define GL_OP_MADD_EXT                    0x8788
+#define GL_OP_FRAC_EXT                    0x8789
+#define GL_OP_MAX_EXT                     0x878A
+#define GL_OP_MIN_EXT                     0x878B
+#define GL_OP_SET_GE_EXT                  0x878C
+#define GL_OP_SET_LT_EXT                  0x878D
+#define GL_OP_CLAMP_EXT                   0x878E
+#define GL_OP_FLOOR_EXT                   0x878F
+#define GL_OP_ROUND_EXT                   0x8790
+#define GL_OP_EXP_BASE_2_EXT              0x8791
+#define GL_OP_LOG_BASE_2_EXT              0x8792
+#define GL_OP_POWER_EXT                   0x8793
+#define GL_OP_RECIP_EXT                   0x8794
+#define GL_OP_RECIP_SQRT_EXT              0x8795
+#define GL_OP_SUB_EXT                     0x8796
+#define GL_OP_CROSS_PRODUCT_EXT           0x8797
+#define GL_OP_MULTIPLY_MATRIX_EXT         0x8798
+#define GL_OP_MOV_EXT                     0x8799
+#define GL_OUTPUT_VERTEX_EXT              0x879A
+#define GL_OUTPUT_COLOR0_EXT              0x879B
+#define GL_OUTPUT_COLOR1_EXT              0x879C
+#define GL_OUTPUT_TEXTURE_COORD0_EXT      0x879D
+#define GL_OUTPUT_TEXTURE_COORD1_EXT      0x879E
+#define GL_OUTPUT_TEXTURE_COORD2_EXT      0x879F
+#define GL_OUTPUT_TEXTURE_COORD3_EXT      0x87A0
+#define GL_OUTPUT_TEXTURE_COORD4_EXT      0x87A1
+#define GL_OUTPUT_TEXTURE_COORD5_EXT      0x87A2
+#define GL_OUTPUT_TEXTURE_COORD6_EXT      0x87A3
+#define GL_OUTPUT_TEXTURE_COORD7_EXT      0x87A4
+#define GL_OUTPUT_TEXTURE_COORD8_EXT      0x87A5
+#define GL_OUTPUT_TEXTURE_COORD9_EXT      0x87A6
+#define GL_OUTPUT_TEXTURE_COORD10_EXT     0x87A7
+#define GL_OUTPUT_TEXTURE_COORD11_EXT     0x87A8
+#define GL_OUTPUT_TEXTURE_COORD12_EXT     0x87A9
+#define GL_OUTPUT_TEXTURE_COORD13_EXT     0x87AA
+#define GL_OUTPUT_TEXTURE_COORD14_EXT     0x87AB
+#define GL_OUTPUT_TEXTURE_COORD15_EXT     0x87AC
+#define GL_OUTPUT_TEXTURE_COORD16_EXT     0x87AD
+#define GL_OUTPUT_TEXTURE_COORD17_EXT     0x87AE
+#define GL_OUTPUT_TEXTURE_COORD18_EXT     0x87AF
+#define GL_OUTPUT_TEXTURE_COORD19_EXT     0x87B0
+#define GL_OUTPUT_TEXTURE_COORD20_EXT     0x87B1
+#define GL_OUTPUT_TEXTURE_COORD21_EXT     0x87B2
+#define GL_OUTPUT_TEXTURE_COORD22_EXT     0x87B3
+#define GL_OUTPUT_TEXTURE_COORD23_EXT     0x87B4
+#define GL_OUTPUT_TEXTURE_COORD24_EXT     0x87B5
+#define GL_OUTPUT_TEXTURE_COORD25_EXT     0x87B6
+#define GL_OUTPUT_TEXTURE_COORD26_EXT     0x87B7
+#define GL_OUTPUT_TEXTURE_COORD27_EXT     0x87B8
+#define GL_OUTPUT_TEXTURE_COORD28_EXT     0x87B9
+#define GL_OUTPUT_TEXTURE_COORD29_EXT     0x87BA
+#define GL_OUTPUT_TEXTURE_COORD30_EXT     0x87BB
+#define GL_OUTPUT_TEXTURE_COORD31_EXT     0x87BC
+#define GL_OUTPUT_FOG_EXT                 0x87BD
+#define GL_SCALAR_EXT                     0x87BE
+#define GL_VECTOR_EXT                     0x87BF
+#define GL_MATRIX_EXT                     0x87C0
+#define GL_VARIANT_EXT                    0x87C1
+#define GL_INVARIANT_EXT                  0x87C2
+#define GL_LOCAL_CONSTANT_EXT             0x87C3
+#define GL_LOCAL_EXT                      0x87C4
+#define GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87C5
+#define GL_MAX_VERTEX_SHADER_VARIANTS_EXT 0x87C6
+#define GL_MAX_VERTEX_SHADER_INVARIANTS_EXT 0x87C7
+#define GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87C8
+#define GL_MAX_VERTEX_SHADER_LOCALS_EXT   0x87C9
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CA
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT 0x87CB
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87CC
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT 0x87CD
+#define GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT 0x87CE
+#define GL_VERTEX_SHADER_INSTRUCTIONS_EXT 0x87CF
+#define GL_VERTEX_SHADER_VARIANTS_EXT     0x87D0
+#define GL_VERTEX_SHADER_INVARIANTS_EXT   0x87D1
+#define GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT 0x87D2
+#define GL_VERTEX_SHADER_LOCALS_EXT       0x87D3
+#define GL_VERTEX_SHADER_OPTIMIZED_EXT    0x87D4
+#define GL_X_EXT                          0x87D5
+#define GL_Y_EXT                          0x87D6
+#define GL_Z_EXT                          0x87D7
+#define GL_W_EXT                          0x87D8
+#define GL_NEGATIVE_X_EXT                 0x87D9
+#define GL_NEGATIVE_Y_EXT                 0x87DA
+#define GL_NEGATIVE_Z_EXT                 0x87DB
+#define GL_NEGATIVE_W_EXT                 0x87DC
+#define GL_ZERO_EXT                       0x87DD
+#define GL_ONE_EXT                        0x87DE
+#define GL_NEGATIVE_ONE_EXT               0x87DF
+#define GL_NORMALIZED_RANGE_EXT           0x87E0
+#define GL_FULL_RANGE_EXT                 0x87E1
+#define GL_CURRENT_VERTEX_EXT             0x87E2
+#define GL_MVP_MATRIX_EXT                 0x87E3
+#define GL_VARIANT_VALUE_EXT              0x87E4
+#define GL_VARIANT_DATATYPE_EXT           0x87E5
+#define GL_VARIANT_ARRAY_STRIDE_EXT       0x87E6
+#define GL_VARIANT_ARRAY_TYPE_EXT         0x87E7
+#define GL_VARIANT_ARRAY_EXT              0x87E8
+#define GL_VARIANT_ARRAY_POINTER_EXT      0x87E9
+#define GL_INVARIANT_VALUE_EXT            0x87EA
+#define GL_INVARIANT_DATATYPE_EXT         0x87EB
+#define GL_LOCAL_CONSTANT_VALUE_EXT       0x87EC
+#define GL_LOCAL_CONSTANT_DATATYPE_EXT    0x87ED
+#endif
+
+#ifndef GL_ATI_vertex_streams
+#define GL_MAX_VERTEX_STREAMS_ATI         0x876B
+#define GL_VERTEX_STREAM0_ATI             0x876C
+#define GL_VERTEX_STREAM1_ATI             0x876D
+#define GL_VERTEX_STREAM2_ATI             0x876E
+#define GL_VERTEX_STREAM3_ATI             0x876F
+#define GL_VERTEX_STREAM4_ATI             0x8770
+#define GL_VERTEX_STREAM5_ATI             0x8771
+#define GL_VERTEX_STREAM6_ATI             0x8772
+#define GL_VERTEX_STREAM7_ATI             0x8773
+#define GL_VERTEX_SOURCE_ATI              0x8774
+#endif
+
+#ifndef GL_ATI_element_array
+#define GL_ELEMENT_ARRAY_ATI              0x8768
+#define GL_ELEMENT_ARRAY_TYPE_ATI         0x8769
+#define GL_ELEMENT_ARRAY_POINTER_ATI      0x876A
+#endif
+
+#ifndef GL_SUN_mesh_array
+#define GL_QUAD_MESH_SUN                  0x8614
+#define GL_TRIANGLE_MESH_SUN              0x8615
+#endif
+
+#ifndef GL_SUN_slice_accum
+#define GL_SLICE_ACCUM_SUN                0x85CC
+#endif
+
+#ifndef GL_NV_multisample_filter_hint
+#define GL_MULTISAMPLE_FILTER_HINT_NV     0x8534
+#endif
+
+#ifndef GL_NV_depth_clamp
+#define GL_DEPTH_CLAMP_NV                 0x864F
+#endif
+
+#ifndef GL_NV_occlusion_query
+#define GL_PIXEL_COUNTER_BITS_NV          0x8864
+#define GL_CURRENT_OCCLUSION_QUERY_ID_NV  0x8865
+#define GL_PIXEL_COUNT_NV                 0x8866
+#define GL_PIXEL_COUNT_AVAILABLE_NV       0x8867
+#endif
+
+#ifndef GL_NV_point_sprite
+#define GL_POINT_SPRITE_NV                0x8861
+#define GL_COORD_REPLACE_NV               0x8862
+#define GL_POINT_SPRITE_R_MODE_NV         0x8863
+#endif
+
+#ifndef GL_NV_texture_shader3
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV 0x8850
+#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV 0x8851
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8852
+#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV 0x8853
+#define GL_OFFSET_HILO_TEXTURE_2D_NV      0x8854
+#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV 0x8855
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV 0x8856
+#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV 0x8857
+#define GL_DEPENDENT_HILO_TEXTURE_2D_NV   0x8858
+#define GL_DEPENDENT_RGB_TEXTURE_3D_NV    0x8859
+#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV 0x885A
+#define GL_DOT_PRODUCT_PASS_THROUGH_NV    0x885B
+#define GL_DOT_PRODUCT_TEXTURE_1D_NV      0x885C
+#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV 0x885D
+#define GL_HILO8_NV                       0x885E
+#define GL_SIGNED_HILO8_NV                0x885F
+#define GL_FORCE_BLUE_TO_ONE_NV           0x8860
+#endif
+
+#ifndef GL_NV_vertex_program1_1
+#endif
+
+#ifndef GL_EXT_shadow_funcs
+#endif
+
+#ifndef GL_EXT_stencil_two_side
+#define GL_STENCIL_TEST_TWO_SIDE_EXT      0x8910
+#define GL_ACTIVE_STENCIL_FACE_EXT        0x8911
+#endif
+
+#ifndef GL_ATI_text_fragment_shader
+#define GL_TEXT_FRAGMENT_SHADER_ATI       0x8200
+#endif
+
+#ifndef GL_APPLE_client_storage
+#define GL_UNPACK_CLIENT_STORAGE_APPLE    0x85B2
+#endif
+
+#ifndef GL_APPLE_element_array
+#define GL_ELEMENT_ARRAY_APPLE            0x8768
+#define GL_ELEMENT_ARRAY_TYPE_APPLE       0x8769
+#define GL_ELEMENT_ARRAY_POINTER_APPLE    0x876A
+#endif
+
+#ifndef GL_APPLE_fence
+#define GL_DRAW_PIXELS_APPLE              0x8A0A
+#define GL_FENCE_APPLE                    0x8A0B
+#endif
+
+#ifndef GL_APPLE_vertex_array_object
+#define GL_VERTEX_ARRAY_BINDING_APPLE     0x85B5
+#endif
+
+#ifndef GL_APPLE_vertex_array_range
+#define GL_VERTEX_ARRAY_RANGE_APPLE       0x851D
+#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE 0x851E
+#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
+#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
+#define GL_STORAGE_CACHED_APPLE           0x85BE
+#define GL_STORAGE_SHARED_APPLE           0x85BF
+#endif
+
+#ifndef GL_APPLE_ycbcr_422
+#define GL_YCBCR_422_APPLE                0x85B9
+#define GL_UNSIGNED_SHORT_8_8_APPLE       0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_APPLE   0x85BB
+#endif
+
+#ifndef GL_S3_s3tc
+#define GL_RGB_S3TC                       0x83A0
+#define GL_RGB4_S3TC                      0x83A1
+#define GL_RGBA_S3TC                      0x83A2
+#define GL_RGBA4_S3TC                     0x83A3
+#endif
+
+#ifndef GL_ATI_draw_buffers
+#define GL_MAX_DRAW_BUFFERS_ATI           0x8824
+#define GL_DRAW_BUFFER0_ATI               0x8825
+#define GL_DRAW_BUFFER1_ATI               0x8826
+#define GL_DRAW_BUFFER2_ATI               0x8827
+#define GL_DRAW_BUFFER3_ATI               0x8828
+#define GL_DRAW_BUFFER4_ATI               0x8829
+#define GL_DRAW_BUFFER5_ATI               0x882A
+#define GL_DRAW_BUFFER6_ATI               0x882B
+#define GL_DRAW_BUFFER7_ATI               0x882C
+#define GL_DRAW_BUFFER8_ATI               0x882D
+#define GL_DRAW_BUFFER9_ATI               0x882E
+#define GL_DRAW_BUFFER10_ATI              0x882F
+#define GL_DRAW_BUFFER11_ATI              0x8830
+#define GL_DRAW_BUFFER12_ATI              0x8831
+#define GL_DRAW_BUFFER13_ATI              0x8832
+#define GL_DRAW_BUFFER14_ATI              0x8833
+#define GL_DRAW_BUFFER15_ATI              0x8834
+#endif
+
+#ifndef GL_ATI_texture_env_combine3
+#define GL_MODULATE_ADD_ATI               0x8744
+#define GL_MODULATE_SIGNED_ADD_ATI        0x8745
+#define GL_MODULATE_SUBTRACT_ATI          0x8746
+#endif
+
+#ifndef GL_ATI_texture_float
+#define GL_RGBA_FLOAT32_ATI               0x8814
+#define GL_RGB_FLOAT32_ATI                0x8815
+#define GL_ALPHA_FLOAT32_ATI              0x8816
+#define GL_INTENSITY_FLOAT32_ATI          0x8817
+#define GL_LUMINANCE_FLOAT32_ATI          0x8818
+#define GL_LUMINANCE_ALPHA_FLOAT32_ATI    0x8819
+#define GL_RGBA_FLOAT16_ATI               0x881A
+#define GL_RGB_FLOAT16_ATI                0x881B
+#define GL_ALPHA_FLOAT16_ATI              0x881C
+#define GL_INTENSITY_FLOAT16_ATI          0x881D
+#define GL_LUMINANCE_FLOAT16_ATI          0x881E
+#define GL_LUMINANCE_ALPHA_FLOAT16_ATI    0x881F
+#endif
+
+#ifndef GL_NV_float_buffer
+#define GL_FLOAT_R_NV                     0x8880
+#define GL_FLOAT_RG_NV                    0x8881
+#define GL_FLOAT_RGB_NV                   0x8882
+#define GL_FLOAT_RGBA_NV                  0x8883
+#define GL_FLOAT_R16_NV                   0x8884
+#define GL_FLOAT_R32_NV                   0x8885
+#define GL_FLOAT_RG16_NV                  0x8886
+#define GL_FLOAT_RG32_NV                  0x8887
+#define GL_FLOAT_RGB16_NV                 0x8888
+#define GL_FLOAT_RGB32_NV                 0x8889
+#define GL_FLOAT_RGBA16_NV                0x888A
+#define GL_FLOAT_RGBA32_NV                0x888B
+#define GL_TEXTURE_FLOAT_COMPONENTS_NV    0x888C
+#define GL_FLOAT_CLEAR_COLOR_VALUE_NV     0x888D
+#define GL_FLOAT_RGBA_MODE_NV             0x888E
+#endif
+
+#ifndef GL_NV_fragment_program
+#define GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV 0x8868
+#define GL_FRAGMENT_PROGRAM_NV            0x8870
+#define GL_MAX_TEXTURE_COORDS_NV          0x8871
+#define GL_MAX_TEXTURE_IMAGE_UNITS_NV     0x8872
+#define GL_FRAGMENT_PROGRAM_BINDING_NV    0x8873
+#define GL_PROGRAM_ERROR_STRING_NV        0x8874
+#endif
+
+#ifndef GL_NV_half_float
+#define GL_HALF_FLOAT_NV                  0x140B
+#endif
+
+#ifndef GL_NV_pixel_data_range
+#define GL_WRITE_PIXEL_DATA_RANGE_NV      0x8878
+#define GL_READ_PIXEL_DATA_RANGE_NV       0x8879
+#define GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV 0x887A
+#define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
+#define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
+#define GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
+#endif
+
+#ifndef GL_NV_primitive_restart
+#define GL_PRIMITIVE_RESTART_NV           0x8558
+#define GL_PRIMITIVE_RESTART_INDEX_NV     0x8559
+#endif
+
+#ifndef GL_NV_texture_expand_normal
+#define GL_TEXTURE_UNSIGNED_REMAP_MODE_NV 0x888F
+#endif
+
+#ifndef GL_NV_vertex_program2
+#endif
+
+#ifndef GL_ATI_map_object_buffer
+#endif
+
+#ifndef GL_ATI_separate_stencil
+#define GL_STENCIL_BACK_FUNC_ATI          0x8800
+#define GL_STENCIL_BACK_FAIL_ATI          0x8801
+#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI 0x8802
+#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI 0x8803
+#endif
+
+#ifndef GL_ATI_vertex_attrib_array_object
+#endif
+
+#ifndef GL_EXT_depth_bounds_test
+#define GL_DEPTH_BOUNDS_TEST_EXT          0x8890
+#define GL_DEPTH_BOUNDS_EXT               0x8891
+#endif
+
+#ifndef GL_EXT_texture_mirror_clamp
+#define GL_MIRROR_CLAMP_EXT               0x8742
+#define GL_MIRROR_CLAMP_TO_EDGE_EXT       0x8743
+#define GL_MIRROR_CLAMP_TO_BORDER_EXT     0x8912
+#endif
+
+#ifndef GL_EXT_blend_equation_separate
+#define GL_BLEND_EQUATION_RGB_EXT         GL_BLEND_EQUATION
+#define GL_BLEND_EQUATION_ALPHA_EXT       0x883D
+#endif
+
+#ifndef GL_MESA_pack_invert
+#define GL_PACK_INVERT_MESA               0x8758
+#endif
+
+#ifndef GL_MESA_ycbcr_texture
+#define GL_UNSIGNED_SHORT_8_8_MESA        0x85BA
+#define GL_UNSIGNED_SHORT_8_8_REV_MESA    0x85BB
+#define GL_YCBCR_MESA                     0x8757
+#endif
+
+
+/*************************************************************/
+
+#include &lt;stddef.h&gt;
+#ifndef GL_VERSION_1_5
+/* GL types for handling large vertex buffer objects */
+typedef ptrdiff_t GLintptr;
+typedef ptrdiff_t GLsizeiptr;
+#endif
+
+#ifndef GL_ARB_vertex_buffer_object
+/* GL types for handling large vertex buffer objects */
+typedef ptrdiff_t GLintptrARB;
+typedef ptrdiff_t GLsizeiptrARB;
+#endif
+
+#ifndef GL_ARB_shader_objects
+/* GL types for handling shader object handles and characters */
+typedef char GLcharARB;		/* native character */
+typedef unsigned int GLhandleARB;	/* shader object handle */
+#endif
+
+#ifndef GL_NV_half_float
+/* GL type for representing NVIDIA &quot;half&quot; floating point type in host memory */
+typedef unsigned short GLhalfNV;
+#endif
+
+#ifndef GL_VERSION_1_2
+#define GL_VERSION_1_2 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendColor (GLclampf, GLclampf, GLclampf, GLclampf);
+GLAPI void APIENTRY glBlendEquation (GLenum);
+GLAPI void APIENTRY glDrawRangeElements (GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *);
+GLAPI void APIENTRY glColorTable (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glColorTableParameterfv (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glColorTableParameteriv (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glCopyColorTable (GLenum, GLenum, GLint, GLint, GLsizei);
+GLAPI void APIENTRY glGetColorTable (GLenum, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetColorTableParameterfv (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetColorTableParameteriv (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glColorSubTable (GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glCopyColorSubTable (GLenum, GLsizei, GLint, GLint, GLsizei);
+GLAPI void APIENTRY glConvolutionFilter1D (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glConvolutionFilter2D (GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glConvolutionParameterf (GLenum, GLenum, GLfloat);
+GLAPI void APIENTRY glConvolutionParameterfv (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glConvolutionParameteri (GLenum, GLenum, GLint);
+GLAPI void APIENTRY glConvolutionParameteriv (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glCopyConvolutionFilter1D (GLenum, GLenum, GLint, GLint, GLsizei);
+GLAPI void APIENTRY glCopyConvolutionFilter2D (GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
+GLAPI void APIENTRY glGetConvolutionFilter (GLenum, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetConvolutionParameterfv (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetConvolutionParameteriv (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetSeparableFilter (GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
+GLAPI void APIENTRY glSeparableFilter2D (GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
+GLAPI void APIENTRY glGetHistogram (GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetHistogramParameterfv (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetHistogramParameteriv (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetMinmax (GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetMinmaxParameterfv (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetMinmaxParameteriv (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glHistogram (GLenum, GLsizei, GLenum, GLboolean);
+GLAPI void APIENTRY glMinmax (GLenum, GLenum, GLboolean);
+GLAPI void APIENTRY glResetHistogram (GLenum);
+GLAPI void APIENTRY glResetMinmax (GLenum);
+GLAPI void APIENTRY glTexImage3D (GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glTexSubImage3D (GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glCopyTexSubImage3D (GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
+typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+typedef void (APIENTRYP PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
+typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
+typedef void (APIENTRYP PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
+typedef void (APIENTRYP PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
+typedef void (APIENTRYP PFNGLRESETHISTOGRAMPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLRESETMINMAXPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+#endif
+
+#ifndef GL_VERSION_1_3
+#define GL_VERSION_1_3 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glActiveTexture (GLenum);
+GLAPI void APIENTRY glClientActiveTexture (GLenum);
+GLAPI void APIENTRY glMultiTexCoord1d (GLenum, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord1dv (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord1f (GLenum, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord1fv (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord1i (GLenum, GLint);
+GLAPI void APIENTRY glMultiTexCoord1iv (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord1s (GLenum, GLshort);
+GLAPI void APIENTRY glMultiTexCoord1sv (GLenum, const GLshort *);
+GLAPI void APIENTRY glMultiTexCoord2d (GLenum, GLdouble, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord2dv (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord2f (GLenum, GLfloat, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord2fv (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord2i (GLenum, GLint, GLint);
+GLAPI void APIENTRY glMultiTexCoord2iv (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord2s (GLenum, GLshort, GLshort);
+GLAPI void APIENTRY glMultiTexCoord2sv (GLenum, const GLshort *);
+GLAPI void APIENTRY glMultiTexCoord3d (GLenum, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord3dv (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord3f (GLenum, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord3fv (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord3i (GLenum, GLint, GLint, GLint);
+GLAPI void APIENTRY glMultiTexCoord3iv (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord3s (GLenum, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glMultiTexCoord3sv (GLenum, const GLshort *);
+GLAPI void APIENTRY glMultiTexCoord4d (GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord4dv (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord4f (GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord4fv (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord4i (GLenum, GLint, GLint, GLint, GLint);
+GLAPI void APIENTRY glMultiTexCoord4iv (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord4s (GLenum, GLshort, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glMultiTexCoord4sv (GLenum, const GLshort *);
+GLAPI void APIENTRY glLoadTransposeMatrixf (const GLfloat *);
+GLAPI void APIENTRY glLoadTransposeMatrixd (const GLdouble *);
+GLAPI void APIENTRY glMultTransposeMatrixf (const GLfloat *);
+GLAPI void APIENTRY glMultTransposeMatrixd (const GLdouble *);
+GLAPI void APIENTRY glSampleCoverage (GLclampf, GLboolean);
+GLAPI void APIENTRY glCompressedTexImage3D (GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexImage2D (GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexImage1D (GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexSubImage3D (GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexSubImage2D (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexSubImage1D (GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glGetCompressedTexImage (GLenum, GLint, GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLACTIVETEXTUREPROC) (GLenum texture);
+typedef void (APIENTRYP PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat *m);
+typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble *m);
+typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat *m);
+typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble *m);
+typedef void (APIENTRYP PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, GLvoid *img);
+#endif
+
+#ifndef GL_VERSION_1_4
+#define GL_VERSION_1_4 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendFuncSeparate (GLenum, GLenum, GLenum, GLenum);
+GLAPI void APIENTRY glFogCoordf (GLfloat);
+GLAPI void APIENTRY glFogCoordfv (const GLfloat *);
+GLAPI void APIENTRY glFogCoordd (GLdouble);
+GLAPI void APIENTRY glFogCoorddv (const GLdouble *);
+GLAPI void APIENTRY glFogCoordPointer (GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glMultiDrawArrays (GLenum, GLint *, GLsizei *, GLsizei);
+GLAPI void APIENTRY glMultiDrawElements (GLenum, const GLsizei *, GLenum, const GLvoid* *, GLsizei);
+GLAPI void APIENTRY glPointParameterf (GLenum, GLfloat);
+GLAPI void APIENTRY glPointParameterfv (GLenum, const GLfloat *);
+GLAPI void APIENTRY glPointParameteri (GLenum, GLint);
+GLAPI void APIENTRY glPointParameteriv (GLenum, const GLint *);
+GLAPI void APIENTRY glSecondaryColor3b (GLbyte, GLbyte, GLbyte);
+GLAPI void APIENTRY glSecondaryColor3bv (const GLbyte *);
+GLAPI void APIENTRY glSecondaryColor3d (GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glSecondaryColor3dv (const GLdouble *);
+GLAPI void APIENTRY glSecondaryColor3f (GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glSecondaryColor3fv (const GLfloat *);
+GLAPI void APIENTRY glSecondaryColor3i (GLint, GLint, GLint);
+GLAPI void APIENTRY glSecondaryColor3iv (const GLint *);
+GLAPI void APIENTRY glSecondaryColor3s (GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glSecondaryColor3sv (const GLshort *);
+GLAPI void APIENTRY glSecondaryColor3ub (GLubyte, GLubyte, GLubyte);
+GLAPI void APIENTRY glSecondaryColor3ubv (const GLubyte *);
+GLAPI void APIENTRY glSecondaryColor3ui (GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glSecondaryColor3uiv (const GLuint *);
+GLAPI void APIENTRY glSecondaryColor3us (GLushort, GLushort, GLushort);
+GLAPI void APIENTRY glSecondaryColor3usv (const GLushort *);
+GLAPI void APIENTRY glSecondaryColorPointer (GLint, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glWindowPos2d (GLdouble, GLdouble);
+GLAPI void APIENTRY glWindowPos2dv (const GLdouble *);
+GLAPI void APIENTRY glWindowPos2f (GLfloat, GLfloat);
+GLAPI void APIENTRY glWindowPos2fv (const GLfloat *);
+GLAPI void APIENTRY glWindowPos2i (GLint, GLint);
+GLAPI void APIENTRY glWindowPos2iv (const GLint *);
+GLAPI void APIENTRY glWindowPos2s (GLshort, GLshort);
+GLAPI void APIENTRY glWindowPos2sv (const GLshort *);
+GLAPI void APIENTRY glWindowPos3d (GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glWindowPos3dv (const GLdouble *);
+GLAPI void APIENTRY glWindowPos3f (GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glWindowPos3fv (const GLfloat *);
+GLAPI void APIENTRY glWindowPos3i (GLint, GLint, GLint);
+GLAPI void APIENTRY glWindowPos3iv (const GLint *);
+GLAPI void APIENTRY glWindowPos3s (GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glWindowPos3sv (const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+typedef void (APIENTRYP PFNGLFOGCOORDFPROC) (GLfloat coord);
+typedef void (APIENTRYP PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
+typedef void (APIENTRYP PFNGLFOGCOORDDPROC) (GLdouble coord);
+typedef void (APIENTRYP PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
+typedef void (APIENTRYP PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2DVPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2FVPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2IVPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2SVPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3DVPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3FVPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3IVPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3SVPROC) (const GLshort *v);
+#endif
+
+#ifndef GL_VERSION_1_5
+#define GL_VERSION_1_5 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGenQueries (GLsizei, GLuint *);
+GLAPI void APIENTRY glDeleteQueries (GLsizei, const GLuint *);
+GLAPI GLboolean APIENTRY glIsQuery (GLuint);
+GLAPI void APIENTRY glBeginQuery (GLenum, GLuint);
+GLAPI void APIENTRY glEndQuery (GLenum);
+GLAPI void APIENTRY glGetQueryiv (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetQueryObjectiv (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetQueryObjectuiv (GLuint, GLenum, GLuint *);
+GLAPI void APIENTRY glBindBuffer (GLenum, GLuint);
+GLAPI void APIENTRY glDeleteBuffers (GLsizei, const GLuint *);
+GLAPI void APIENTRY glGenBuffers (GLsizei, GLuint *);
+GLAPI GLboolean APIENTRY glIsBuffer (GLuint);
+GLAPI void APIENTRY glBufferData (GLenum, GLsizeiptr, const GLvoid *, GLenum);
+GLAPI void APIENTRY glBufferSubData (GLenum, GLintptr, GLsizeiptr, const GLvoid *);
+GLAPI void APIENTRY glGetBufferSubData (GLenum, GLintptr, GLsizeiptr, GLvoid *);
+GLAPI GLvoid* APIENTRY glMapBuffer (GLenum, GLenum);
+GLAPI GLboolean APIENTRY glUnmapBuffer (GLenum);
+GLAPI void APIENTRY glGetBufferParameteriv (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetBufferPointerv (GLenum, GLenum, GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
+typedef void (APIENTRYP PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
+typedef GLboolean (APIENTRYP PFNGLISQUERYPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
+typedef void (APIENTRYP PFNGLENDQUERYPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
+typedef void (APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
+typedef void (APIENTRYP PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
+typedef void (APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
+typedef GLboolean (APIENTRYP PFNGLISBUFFERPROC) (GLuint buffer);
+typedef void (APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
+typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
+typedef GLvoid* (APIENTRYP PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
+typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid* *params);
+#endif
+
+#ifndef GL_ARB_multitexture
+#define GL_ARB_multitexture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glActiveTextureARB (GLenum);
+GLAPI void APIENTRY glClientActiveTextureARB (GLenum);
+GLAPI void APIENTRY glMultiTexCoord1dARB (GLenum, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord1dvARB (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord1fARB (GLenum, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord1fvARB (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord1iARB (GLenum, GLint);
+GLAPI void APIENTRY glMultiTexCoord1ivARB (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord1sARB (GLenum, GLshort);
+GLAPI void APIENTRY glMultiTexCoord1svARB (GLenum, const GLshort *);
+GLAPI void APIENTRY glMultiTexCoord2dARB (GLenum, GLdouble, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord2dvARB (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord2fARB (GLenum, GLfloat, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord2fvARB (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord2iARB (GLenum, GLint, GLint);
+GLAPI void APIENTRY glMultiTexCoord2ivARB (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord2sARB (GLenum, GLshort, GLshort);
+GLAPI void APIENTRY glMultiTexCoord2svARB (GLenum, const GLshort *);
+GLAPI void APIENTRY glMultiTexCoord3dARB (GLenum, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord3dvARB (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord3fARB (GLenum, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord3fvARB (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord3iARB (GLenum, GLint, GLint, GLint);
+GLAPI void APIENTRY glMultiTexCoord3ivARB (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord3sARB (GLenum, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glMultiTexCoord3svARB (GLenum, const GLshort *);
+GLAPI void APIENTRY glMultiTexCoord4dARB (GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glMultiTexCoord4dvARB (GLenum, const GLdouble *);
+GLAPI void APIENTRY glMultiTexCoord4fARB (GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glMultiTexCoord4fvARB (GLenum, const GLfloat *);
+GLAPI void APIENTRY glMultiTexCoord4iARB (GLenum, GLint, GLint, GLint, GLint);
+GLAPI void APIENTRY glMultiTexCoord4ivARB (GLenum, const GLint *);
+GLAPI void APIENTRY glMultiTexCoord4sARB (GLenum, GLshort, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glMultiTexCoord4svARB (GLenum, const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
+typedef void (APIENTRYP PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
+#endif
+
+#ifndef GL_ARB_transpose_matrix
+#define GL_ARB_transpose_matrix 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glLoadTransposeMatrixfARB (const GLfloat *);
+GLAPI void APIENTRY glLoadTransposeMatrixdARB (const GLdouble *);
+GLAPI void APIENTRY glMultTransposeMatrixfARB (const GLfloat *);
+GLAPI void APIENTRY glMultTransposeMatrixdARB (const GLdouble *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
+typedef void (APIENTRYP PFNGLLOADTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);
+typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXFARBPROC) (const GLfloat *m);
+typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXDARBPROC) (const GLdouble *m);
+#endif
+
+#ifndef GL_ARB_multisample
+#define GL_ARB_multisample 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glSampleCoverageARB (GLclampf, GLboolean);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
+#endif
+
+#ifndef GL_ARB_texture_env_add
+#define GL_ARB_texture_env_add 1
+#endif
+
+#ifndef GL_ARB_texture_cube_map
+#define GL_ARB_texture_cube_map 1
+#endif
+
+#ifndef GL_ARB_texture_compression
+#define GL_ARB_texture_compression 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCompressedTexImage3DARB (GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexImage2DARB (GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexImage1DARB (GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexSubImage3DARB (GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexSubImage2DARB (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glCompressedTexSubImage1DARB (GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glGetCompressedTexImageARB (GLenum, GLint, GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
+typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint level, GLvoid *img);
+#endif
+
+#ifndef GL_ARB_texture_border_clamp
+#define GL_ARB_texture_border_clamp 1
+#endif
+
+#ifndef GL_ARB_point_parameters
+#define GL_ARB_point_parameters 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPointParameterfARB (GLenum, GLfloat);
+GLAPI void APIENTRY glPointParameterfvARB (GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_ARB_vertex_blend
+#define GL_ARB_vertex_blend 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glWeightbvARB (GLint, const GLbyte *);
+GLAPI void APIENTRY glWeightsvARB (GLint, const GLshort *);
+GLAPI void APIENTRY glWeightivARB (GLint, const GLint *);
+GLAPI void APIENTRY glWeightfvARB (GLint, const GLfloat *);
+GLAPI void APIENTRY glWeightdvARB (GLint, const GLdouble *);
+GLAPI void APIENTRY glWeightubvARB (GLint, const GLubyte *);
+GLAPI void APIENTRY glWeightusvARB (GLint, const GLushort *);
+GLAPI void APIENTRY glWeightuivARB (GLint, const GLuint *);
+GLAPI void APIENTRY glWeightPointerARB (GLint, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glVertexBlendARB (GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLWEIGHTBVARBPROC) (GLint size, const GLbyte *weights);
+typedef void (APIENTRYP PFNGLWEIGHTSVARBPROC) (GLint size, const GLshort *weights);
+typedef void (APIENTRYP PFNGLWEIGHTIVARBPROC) (GLint size, const GLint *weights);
+typedef void (APIENTRYP PFNGLWEIGHTFVARBPROC) (GLint size, const GLfloat *weights);
+typedef void (APIENTRYP PFNGLWEIGHTDVARBPROC) (GLint size, const GLdouble *weights);
+typedef void (APIENTRYP PFNGLWEIGHTUBVARBPROC) (GLint size, const GLubyte *weights);
+typedef void (APIENTRYP PFNGLWEIGHTUSVARBPROC) (GLint size, const GLushort *weights);
+typedef void (APIENTRYP PFNGLWEIGHTUIVARBPROC) (GLint size, const GLuint *weights);
+typedef void (APIENTRYP PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXBLENDARBPROC) (GLint count);
+#endif
+
+#ifndef GL_ARB_matrix_palette
+#define GL_ARB_matrix_palette 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCurrentPaletteMatrixARB (GLint);
+GLAPI void APIENTRY glMatrixIndexubvARB (GLint, const GLubyte *);
+GLAPI void APIENTRY glMatrixIndexusvARB (GLint, const GLushort *);
+GLAPI void APIENTRY glMatrixIndexuivARB (GLint, const GLuint *);
+GLAPI void APIENTRY glMatrixIndexPointerARB (GLint, GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
+typedef void (APIENTRYP PFNGLMATRIXINDEXUBVARBPROC) (GLint size, const GLubyte *indices);
+typedef void (APIENTRYP PFNGLMATRIXINDEXUSVARBPROC) (GLint size, const GLushort *indices);
+typedef void (APIENTRYP PFNGLMATRIXINDEXUIVARBPROC) (GLint size, const GLuint *indices);
+typedef void (APIENTRYP PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_ARB_texture_env_combine
+#define GL_ARB_texture_env_combine 1
+#endif
+
+#ifndef GL_ARB_texture_env_crossbar
+#define GL_ARB_texture_env_crossbar 1
+#endif
+
+#ifndef GL_ARB_texture_env_dot3
+#define GL_ARB_texture_env_dot3 1
+#endif
+
+#ifndef GL_ARB_texture_mirror_repeat
+#define GL_ARB_texture_mirror_repeat 1
+#endif
+
+#ifndef GL_ARB_depth_texture
+#define GL_ARB_depth_texture 1
+#endif
+
+#ifndef GL_ARB_shadow
+#define GL_ARB_shadow 1
+#endif
+
+#ifndef GL_ARB_shadow_ambient
+#define GL_ARB_shadow_ambient 1
+#endif
+
+#ifndef GL_ARB_window_pos
+#define GL_ARB_window_pos 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glWindowPos2dARB (GLdouble, GLdouble);
+GLAPI void APIENTRY glWindowPos2dvARB (const GLdouble *);
+GLAPI void APIENTRY glWindowPos2fARB (GLfloat, GLfloat);
+GLAPI void APIENTRY glWindowPos2fvARB (const GLfloat *);
+GLAPI void APIENTRY glWindowPos2iARB (GLint, GLint);
+GLAPI void APIENTRY glWindowPos2ivARB (const GLint *);
+GLAPI void APIENTRY glWindowPos2sARB (GLshort, GLshort);
+GLAPI void APIENTRY glWindowPos2svARB (const GLshort *);
+GLAPI void APIENTRY glWindowPos3dARB (GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glWindowPos3dvARB (const GLdouble *);
+GLAPI void APIENTRY glWindowPos3fARB (GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glWindowPos3fvARB (const GLfloat *);
+GLAPI void APIENTRY glWindowPos3iARB (GLint, GLint, GLint);
+GLAPI void APIENTRY glWindowPos3ivARB (const GLint *);
+GLAPI void APIENTRY glWindowPos3sARB (GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glWindowPos3svARB (const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2DVARBPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2FVARBPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2IVARBPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2SVARBPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3DVARBPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3FVARBPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3IVARBPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3SVARBPROC) (const GLshort *v);
+#endif
+
+#ifndef GL_ARB_vertex_program
+#define GL_ARB_vertex_program 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glVertexAttrib1dARB (GLuint, GLdouble);
+GLAPI void APIENTRY glVertexAttrib1dvARB (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib1fARB (GLuint, GLfloat);
+GLAPI void APIENTRY glVertexAttrib1fvARB (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib1sARB (GLuint, GLshort);
+GLAPI void APIENTRY glVertexAttrib1svARB (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib2dARB (GLuint, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexAttrib2dvARB (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib2fARB (GLuint, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexAttrib2fvARB (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib2sARB (GLuint, GLshort, GLshort);
+GLAPI void APIENTRY glVertexAttrib2svARB (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib3dARB (GLuint, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexAttrib3dvARB (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib3fARB (GLuint, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexAttrib3fvARB (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib3sARB (GLuint, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glVertexAttrib3svARB (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib4NbvARB (GLuint, const GLbyte *);
+GLAPI void APIENTRY glVertexAttrib4NivARB (GLuint, const GLint *);
+GLAPI void APIENTRY glVertexAttrib4NsvARB (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib4NubARB (GLuint, GLubyte, GLubyte, GLubyte, GLubyte);
+GLAPI void APIENTRY glVertexAttrib4NubvARB (GLuint, const GLubyte *);
+GLAPI void APIENTRY glVertexAttrib4NuivARB (GLuint, const GLuint *);
+GLAPI void APIENTRY glVertexAttrib4NusvARB (GLuint, const GLushort *);
+GLAPI void APIENTRY glVertexAttrib4bvARB (GLuint, const GLbyte *);
+GLAPI void APIENTRY glVertexAttrib4dARB (GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexAttrib4dvARB (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib4fARB (GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexAttrib4fvARB (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib4ivARB (GLuint, const GLint *);
+GLAPI void APIENTRY glVertexAttrib4sARB (GLuint, GLshort, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glVertexAttrib4svARB (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib4ubvARB (GLuint, const GLubyte *);
+GLAPI void APIENTRY glVertexAttrib4uivARB (GLuint, const GLuint *);
+GLAPI void APIENTRY glVertexAttrib4usvARB (GLuint, const GLushort *);
+GLAPI void APIENTRY glVertexAttribPointerARB (GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glEnableVertexAttribArrayARB (GLuint);
+GLAPI void APIENTRY glDisableVertexAttribArrayARB (GLuint);
+GLAPI void APIENTRY glProgramStringARB (GLenum, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glBindProgramARB (GLenum, GLuint);
+GLAPI void APIENTRY glDeleteProgramsARB (GLsizei, const GLuint *);
+GLAPI void APIENTRY glGenProgramsARB (GLsizei, GLuint *);
+GLAPI void APIENTRY glProgramEnvParameter4dARB (GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glProgramEnvParameter4dvARB (GLenum, GLuint, const GLdouble *);
+GLAPI void APIENTRY glProgramEnvParameter4fARB (GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glProgramEnvParameter4fvARB (GLenum, GLuint, const GLfloat *);
+GLAPI void APIENTRY glProgramLocalParameter4dARB (GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glProgramLocalParameter4dvARB (GLenum, GLuint, const GLdouble *);
+GLAPI void APIENTRY glProgramLocalParameter4fARB (GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glProgramLocalParameter4fvARB (GLenum, GLuint, const GLfloat *);
+GLAPI void APIENTRY glGetProgramEnvParameterdvARB (GLenum, GLuint, GLdouble *);
+GLAPI void APIENTRY glGetProgramEnvParameterfvARB (GLenum, GLuint, GLfloat *);
+GLAPI void APIENTRY glGetProgramLocalParameterdvARB (GLenum, GLuint, GLdouble *);
+GLAPI void APIENTRY glGetProgramLocalParameterfvARB (GLenum, GLuint, GLfloat *);
+GLAPI void APIENTRY glGetProgramivARB (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetProgramStringARB (GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetVertexAttribdvARB (GLuint, GLenum, GLdouble *);
+GLAPI void APIENTRY glGetVertexAttribfvARB (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetVertexAttribivARB (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetVertexAttribPointervARB (GLuint, GLenum, GLvoid* *);
+GLAPI GLboolean APIENTRY glIsProgramARB (GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
+typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
+typedef void (APIENTRYP PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
+typedef void (APIENTRYP PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
+typedef void (APIENTRYP PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint *programs);
+typedef void (APIENTRYP PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint *programs);
+typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
+typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
+typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble *params);
+typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
+typedef GLboolean (APIENTRYP PFNGLISPROGRAMARBPROC) (GLuint program);
+#endif
+
+#ifndef GL_ARB_fragment_program
+#define GL_ARB_fragment_program 1
+/* All ARB_fragment_program entry points are shared with ARB_vertex_program. */
+#endif
+
+#ifndef GL_ARB_vertex_buffer_object
+#define GL_ARB_vertex_buffer_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBindBufferARB (GLenum, GLuint);
+GLAPI void APIENTRY glDeleteBuffersARB (GLsizei, const GLuint *);
+GLAPI void APIENTRY glGenBuffersARB (GLsizei, GLuint *);
+GLAPI GLboolean APIENTRY glIsBufferARB (GLuint);
+GLAPI void APIENTRY glBufferDataARB (GLenum, GLsizeiptrARB, const GLvoid *, GLenum);
+GLAPI void APIENTRY glBufferSubDataARB (GLenum, GLintptrARB, GLsizeiptrARB, const GLvoid *);
+GLAPI void APIENTRY glGetBufferSubDataARB (GLenum, GLintptrARB, GLsizeiptrARB, GLvoid *);
+GLAPI GLvoid* APIENTRY glMapBufferARB (GLenum, GLenum);
+GLAPI GLboolean APIENTRY glUnmapBufferARB (GLenum);
+GLAPI void APIENTRY glGetBufferParameterivARB (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetBufferPointervARB (GLenum, GLenum, GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
+typedef void (APIENTRYP PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);
+typedef void (APIENTRYP PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);
+typedef GLboolean (APIENTRYP PFNGLISBUFFERARBPROC) (GLuint buffer);
+typedef void (APIENTRYP PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
+typedef void (APIENTRYP PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
+typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+typedef GLvoid* (APIENTRYP PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
+typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERARBPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid* *params);
+#endif
+
+#ifndef GL_ARB_occlusion_query
+#define GL_ARB_occlusion_query 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGenQueriesARB (GLsizei, GLuint *);
+GLAPI void APIENTRY glDeleteQueriesARB (GLsizei, const GLuint *);
+GLAPI GLboolean APIENTRY glIsQueryARB (GLuint);
+GLAPI void APIENTRY glBeginQueryARB (GLenum, GLuint);
+GLAPI void APIENTRY glEndQueryARB (GLenum);
+GLAPI void APIENTRY glGetQueryivARB (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetQueryObjectivARB (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetQueryObjectuivARB (GLuint, GLenum, GLuint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint *ids);
+typedef void (APIENTRYP PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint *ids);
+typedef GLboolean (APIENTRYP PFNGLISQUERYARBPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
+typedef void (APIENTRYP PFNGLENDQUERYARBPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint *params);
+#endif
+
+#ifndef GL_ARB_shader_objects
+#define GL_ARB_shader_objects 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDeleteObjectARB (GLhandleARB);
+GLAPI GLhandleARB APIENTRY glGetHandleARB (GLenum);
+GLAPI void APIENTRY glDetachObjectARB (GLhandleARB, GLhandleARB);
+GLAPI GLhandleARB APIENTRY glCreateShaderObjectARB (GLenum);
+GLAPI void APIENTRY glShaderSourceARB (GLhandleARB, GLsizei, const GLcharARB* *, const GLint *);
+GLAPI void APIENTRY glCompileShaderARB (GLhandleARB);
+GLAPI GLhandleARB APIENTRY glCreateProgramObjectARB (void);
+GLAPI void APIENTRY glAttachObjectARB (GLhandleARB, GLhandleARB);
+GLAPI void APIENTRY glLinkProgramARB (GLhandleARB);
+GLAPI void APIENTRY glUseProgramObjectARB (GLhandleARB);
+GLAPI void APIENTRY glValidateProgramARB (GLhandleARB);
+GLAPI void APIENTRY glUniform1fARB (GLint, GLfloat);
+GLAPI void APIENTRY glUniform2fARB (GLint, GLfloat, GLfloat);
+GLAPI void APIENTRY glUniform3fARB (GLint, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glUniform4fARB (GLint, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glUniform1iARB (GLint, GLint);
+GLAPI void APIENTRY glUniform2iARB (GLint, GLint, GLint);
+GLAPI void APIENTRY glUniform3iARB (GLint, GLint, GLint, GLint);
+GLAPI void APIENTRY glUniform4iARB (GLint, GLint, GLint, GLint, GLint);
+GLAPI void APIENTRY glUniform1fvARB (GLint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glUniform2fvARB (GLint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glUniform3fvARB (GLint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glUniform4fvARB (GLint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glUniform1ivARB (GLint, GLsizei, const GLint *);
+GLAPI void APIENTRY glUniform2ivARB (GLint, GLsizei, const GLint *);
+GLAPI void APIENTRY glUniform3ivARB (GLint, GLsizei, const GLint *);
+GLAPI void APIENTRY glUniform4ivARB (GLint, GLsizei, const GLint *);
+GLAPI void APIENTRY glUniformMatrix2fvARB (GLint, GLsizei, GLboolean, const GLfloat *);
+GLAPI void APIENTRY glUniformMatrix3fvARB (GLint, GLsizei, GLboolean, const GLfloat *);
+GLAPI void APIENTRY glUniformMatrix4fvARB (GLint, GLsizei, GLboolean, const GLfloat *);
+GLAPI void APIENTRY glGetObjectParameterfvARB (GLhandleARB, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetObjectParameterivARB (GLhandleARB, GLenum, GLint *);
+GLAPI void APIENTRY glGetInfoLogARB (GLhandleARB, GLsizei, GLsizei *, GLcharARB *);
+GLAPI void APIENTRY glGetAttachedObjectsARB (GLhandleARB, GLsizei, GLsizei *, GLhandleARB *);
+GLAPI GLint APIENTRY glGetUniformLocationARB (GLhandleARB, const GLcharARB *);
+GLAPI void APIENTRY glGetActiveUniformARB (GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *);
+GLAPI void APIENTRY glGetUniformfvARB (GLhandleARB, GLint, GLfloat *);
+GLAPI void APIENTRY glGetUniformivARB (GLhandleARB, GLint, GLint *);
+GLAPI void APIENTRY glGetShaderSourceARB (GLhandleARB, GLsizei, GLsizei *, GLcharARB *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
+typedef GLhandleARB (APIENTRYP PFNGLGETHANDLEARBPROC) (GLenum pname);
+typedef void (APIENTRYP PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
+typedef GLhandleARB (APIENTRYP PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
+typedef void (APIENTRYP PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB* *string, const GLint *length);
+typedef void (APIENTRYP PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
+typedef GLhandleARB (APIENTRYP PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
+typedef void (APIENTRYP PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
+typedef void (APIENTRYP PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
+typedef void (APIENTRYP PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
+typedef void (APIENTRYP PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
+typedef void (APIENTRYP PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
+typedef void (APIENTRYP PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
+typedef void (APIENTRYP PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
+typedef void (APIENTRYP PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
+typedef void (APIENTRYP PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
+typedef void (APIENTRYP PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
+typedef void (APIENTRYP PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
+typedef void (APIENTRYP PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
+typedef void (APIENTRYP PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
+typedef void (APIENTRYP PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
+typedef void (APIENTRYP PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
+typedef void (APIENTRYP PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat *value);
+typedef void (APIENTRYP PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint *value);
+typedef void (APIENTRYP PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint *value);
+typedef void (APIENTRYP PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint *value);
+typedef void (APIENTRYP PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint *value);
+typedef void (APIENTRYP PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+typedef void (APIENTRYP PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+typedef void (APIENTRYP PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
+typedef void (APIENTRYP PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
+typedef void (APIENTRYP PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
+typedef GLint (APIENTRYP PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
+typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+typedef void (APIENTRYP PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint *params);
+typedef void (APIENTRYP PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
+#endif
+
+#ifndef GL_ARB_vertex_shader
+#define GL_ARB_vertex_shader 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBindAttribLocationARB (GLhandleARB, GLuint, const GLcharARB *);
+GLAPI void APIENTRY glGetActiveAttribARB (GLhandleARB, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLcharARB *);
+GLAPI GLint APIENTRY glGetAttribLocationARB (GLhandleARB, const GLcharARB *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
+typedef void (APIENTRYP PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
+typedef GLint (APIENTRYP PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB *name);
+#endif
+
+#ifndef GL_ARB_fragment_shader
+#define GL_ARB_fragment_shader 1
+#endif
+
+#ifndef GL_ARB_shading_language_100
+#define GL_ARB_shading_language_100 1
+#endif
+
+#ifndef GL_ARB_texture_non_power_of_two
+#define GL_ARB_texture_non_power_of_two 1
+#endif
+
+#ifndef GL_ARB_point_sprite
+#define GL_ARB_point_sprite 1
+#endif
+
+#ifndef GL_EXT_abgr
+#define GL_EXT_abgr 1
+#endif
+
+#ifndef GL_EXT_blend_color
+#define GL_EXT_blend_color 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendColorEXT (GLclampf, GLclampf, GLclampf, GLclampf);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
+#endif
+
+#ifndef GL_EXT_polygon_offset
+#define GL_EXT_polygon_offset 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPolygonOffsetEXT (GLfloat, GLfloat);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
+#endif
+
+#ifndef GL_EXT_texture
+#define GL_EXT_texture 1
+#endif
+
+#ifndef GL_EXT_texture3D
+#define GL_EXT_texture3D 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTexImage3DEXT (GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glTexSubImage3DEXT (GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+#endif
+
+#ifndef GL_SGIS_texture_filter4
+#define GL_SGIS_texture_filter4 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGetTexFilterFuncSGIS (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glTexFilterFuncSGIS (GLenum, GLenum, GLsizei, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat *weights);
+typedef void (APIENTRYP PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat *weights);
+#endif
+
+#ifndef GL_EXT_subtexture
+#define GL_EXT_subtexture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTexSubImage1DEXT (GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glTexSubImage2DEXT (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+#endif
+
+#ifndef GL_EXT_copy_texture
+#define GL_EXT_copy_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCopyTexImage1DEXT (GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
+GLAPI void APIENTRY glCopyTexImage2DEXT (GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
+GLAPI void APIENTRY glCopyTexSubImage1DEXT (GLenum, GLint, GLint, GLint, GLint, GLsizei);
+GLAPI void APIENTRY glCopyTexSubImage2DEXT (GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+GLAPI void APIENTRY glCopyTexSubImage3DEXT (GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
+typedef void (APIENTRYP PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
+typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
+typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
+#endif
+
+#ifndef GL_EXT_histogram
+#define GL_EXT_histogram 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGetHistogramEXT (GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetHistogramParameterfvEXT (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetHistogramParameterivEXT (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetMinmaxEXT (GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetMinmaxParameterfvEXT (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetMinmaxParameterivEXT (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glHistogramEXT (GLenum, GLsizei, GLenum, GLboolean);
+GLAPI void APIENTRY glMinmaxEXT (GLenum, GLenum, GLboolean);
+GLAPI void APIENTRY glResetHistogramEXT (GLenum);
+GLAPI void APIENTRY glResetMinmaxEXT (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
+typedef void (APIENTRYP PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
+typedef void (APIENTRYP PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLRESETMINMAXEXTPROC) (GLenum target);
+#endif
+
+#ifndef GL_EXT_convolution
+#define GL_EXT_convolution 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glConvolutionFilter1DEXT (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glConvolutionFilter2DEXT (GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glConvolutionParameterfEXT (GLenum, GLenum, GLfloat);
+GLAPI void APIENTRY glConvolutionParameterfvEXT (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glConvolutionParameteriEXT (GLenum, GLenum, GLint);
+GLAPI void APIENTRY glConvolutionParameterivEXT (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glCopyConvolutionFilter1DEXT (GLenum, GLenum, GLint, GLint, GLsizei);
+GLAPI void APIENTRY glCopyConvolutionFilter2DEXT (GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
+GLAPI void APIENTRY glGetConvolutionFilterEXT (GLenum, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetConvolutionParameterfvEXT (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetConvolutionParameterivEXT (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetSeparableFilterEXT (GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
+GLAPI void APIENTRY glSeparableFilter2DEXT (GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat params);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint params);
+typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
+typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
+#endif
+
+#ifndef GL_EXT_color_matrix
+#define GL_EXT_color_matrix 1
+#endif
+
+#ifndef GL_SGI_color_table
+#define GL_SGI_color_table 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glColorTableSGI (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glColorTableParameterfvSGI (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glColorTableParameterivSGI (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glCopyColorTableSGI (GLenum, GLenum, GLint, GLint, GLsizei);
+GLAPI void APIENTRY glGetColorTableSGI (GLenum, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetColorTableParameterfvSGI (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetColorTableParameterivSGI (GLenum, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+typedef void (APIENTRYP PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_SGIX_pixel_texture
+#define GL_SGIX_pixel_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPixelTexGenSGIX (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
+#endif
+
+#ifndef GL_SGIS_pixel_texture
+#define GL_SGIS_pixel_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPixelTexGenParameteriSGIS (GLenum, GLint);
+GLAPI void APIENTRY glPixelTexGenParameterivSGIS (GLenum, const GLint *);
+GLAPI void APIENTRY glPixelTexGenParameterfSGIS (GLenum, GLfloat);
+GLAPI void APIENTRY glPixelTexGenParameterfvSGIS (GLenum, const GLfloat *);
+GLAPI void APIENTRY glGetPixelTexGenParameterivSGIS (GLenum, GLint *);
+GLAPI void APIENTRY glGetPixelTexGenParameterfvSGIS (GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERISGISPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLGETPIXELTEXGENPARAMETERIVSGISPROC) (GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETPIXELTEXGENPARAMETERFVSGISPROC) (GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_SGIS_texture4D
+#define GL_SGIS_texture4D 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTexImage4DSGIS (GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glTexSubImage4DSGIS (GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
+#endif
+
+#ifndef GL_SGI_texture_color_table
+#define GL_SGI_texture_color_table 1
+#endif
+
+#ifndef GL_EXT_cmyka
+#define GL_EXT_cmyka 1
+#endif
+
+#ifndef GL_EXT_texture_object
+#define GL_EXT_texture_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI GLboolean APIENTRY glAreTexturesResidentEXT (GLsizei, const GLuint *, GLboolean *);
+GLAPI void APIENTRY glBindTextureEXT (GLenum, GLuint);
+GLAPI void APIENTRY glDeleteTexturesEXT (GLsizei, const GLuint *);
+GLAPI void APIENTRY glGenTexturesEXT (GLsizei, GLuint *);
+GLAPI GLboolean APIENTRY glIsTextureEXT (GLuint);
+GLAPI void APIENTRY glPrioritizeTexturesEXT (GLsizei, const GLuint *, const GLclampf *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef GLboolean (APIENTRYP PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint *textures, GLboolean *residences);
+typedef void (APIENTRYP PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
+typedef void (APIENTRYP PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint *textures);
+typedef void (APIENTRYP PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint *textures);
+typedef GLboolean (APIENTRYP PFNGLISTEXTUREEXTPROC) (GLuint texture);
+typedef void (APIENTRYP PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint *textures, const GLclampf *priorities);
+#endif
+
+#ifndef GL_SGIS_detail_texture
+#define GL_SGIS_detail_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDetailTexFuncSGIS (GLenum, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glGetDetailTexFuncSGIS (GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
+typedef void (APIENTRYP PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
+#endif
+
+#ifndef GL_SGIS_sharpen_texture
+#define GL_SGIS_sharpen_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glSharpenTexFuncSGIS (GLenum, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glGetSharpenTexFuncSGIS (GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat *points);
+typedef void (APIENTRYP PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat *points);
+#endif
+
+#ifndef GL_EXT_packed_pixels
+#define GL_EXT_packed_pixels 1
+#endif
+
+#ifndef GL_SGIS_texture_lod
+#define GL_SGIS_texture_lod 1
+#endif
+
+#ifndef GL_SGIS_multisample
+#define GL_SGIS_multisample 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glSampleMaskSGIS (GLclampf, GLboolean);
+GLAPI void APIENTRY glSamplePatternSGIS (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
+typedef void (APIENTRYP PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
+#endif
+
+#ifndef GL_EXT_rescale_normal
+#define GL_EXT_rescale_normal 1
+#endif
+
+#ifndef GL_EXT_vertex_array
+#define GL_EXT_vertex_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glArrayElementEXT (GLint);
+GLAPI void APIENTRY glColorPointerEXT (GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glDrawArraysEXT (GLenum, GLint, GLsizei);
+GLAPI void APIENTRY glEdgeFlagPointerEXT (GLsizei, GLsizei, const GLboolean *);
+GLAPI void APIENTRY glGetPointervEXT (GLenum, GLvoid* *);
+GLAPI void APIENTRY glIndexPointerEXT (GLenum, GLsizei, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glNormalPointerEXT (GLenum, GLsizei, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glTexCoordPointerEXT (GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glVertexPointerEXT (GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLARRAYELEMENTEXTPROC) (GLint i);
+typedef void (APIENTRYP PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
+typedef void (APIENTRYP PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
+typedef void (APIENTRYP PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
+typedef void (APIENTRYP PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+#endif
+
+#ifndef GL_EXT_misc_attribute
+#define GL_EXT_misc_attribute 1
+#endif
+
+#ifndef GL_SGIS_generate_mipmap
+#define GL_SGIS_generate_mipmap 1
+#endif
+
+#ifndef GL_SGIX_clipmap
+#define GL_SGIX_clipmap 1
+#endif
+
+#ifndef GL_SGIX_shadow
+#define GL_SGIX_shadow 1
+#endif
+
+#ifndef GL_SGIS_texture_edge_clamp
+#define GL_SGIS_texture_edge_clamp 1
+#endif
+
+#ifndef GL_SGIS_texture_border_clamp
+#define GL_SGIS_texture_border_clamp 1
+#endif
+
+#ifndef GL_EXT_blend_minmax
+#define GL_EXT_blend_minmax 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendEquationEXT (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
+#endif
+
+#ifndef GL_EXT_blend_subtract
+#define GL_EXT_blend_subtract 1
+#endif
+
+#ifndef GL_EXT_blend_logic_op
+#define GL_EXT_blend_logic_op 1
+#endif
+
+#ifndef GL_SGIX_interlace
+#define GL_SGIX_interlace 1
+#endif
+
+#ifndef GL_SGIX_pixel_tiles
+#define GL_SGIX_pixel_tiles 1
+#endif
+
+#ifndef GL_SGIX_texture_select
+#define GL_SGIX_texture_select 1
+#endif
+
+#ifndef GL_SGIX_sprite
+#define GL_SGIX_sprite 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glSpriteParameterfSGIX (GLenum, GLfloat);
+GLAPI void APIENTRY glSpriteParameterfvSGIX (GLenum, const GLfloat *);
+GLAPI void APIENTRY glSpriteParameteriSGIX (GLenum, GLint);
+GLAPI void APIENTRY glSpriteParameterivSGIX (GLenum, const GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, const GLint *params);
+#endif
+
+#ifndef GL_SGIX_texture_multi_buffer
+#define GL_SGIX_texture_multi_buffer 1
+#endif
+
+#ifndef GL_EXT_point_parameters
+#define GL_EXT_point_parameters 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPointParameterfEXT (GLenum, GLfloat);
+GLAPI void APIENTRY glPointParameterfvEXT (GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_SGIS_point_parameters
+#define GL_SGIS_point_parameters 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPointParameterfSGIS (GLenum, GLfloat);
+GLAPI void APIENTRY glPointParameterfvSGIS (GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFSGISPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERFVSGISPROC) (GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_SGIX_instruments
+#define GL_SGIX_instruments 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI GLint APIENTRY glGetInstrumentsSGIX (void);
+GLAPI void APIENTRY glInstrumentsBufferSGIX (GLsizei, GLint *);
+GLAPI GLint APIENTRY glPollInstrumentsSGIX (GLint *);
+GLAPI void APIENTRY glReadInstrumentsSGIX (GLint);
+GLAPI void APIENTRY glStartInstrumentsSGIX (void);
+GLAPI void APIENTRY glStopInstrumentsSGIX (GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef GLint (APIENTRYP PFNGLGETINSTRUMENTSSGIXPROC) (void);
+typedef void (APIENTRYP PFNGLINSTRUMENTSBUFFERSGIXPROC) (GLsizei size, GLint *buffer);
+typedef GLint (APIENTRYP PFNGLPOLLINSTRUMENTSSGIXPROC) (GLint *marker_p);
+typedef void (APIENTRYP PFNGLREADINSTRUMENTSSGIXPROC) (GLint marker);
+typedef void (APIENTRYP PFNGLSTARTINSTRUMENTSSGIXPROC) (void);
+typedef void (APIENTRYP PFNGLSTOPINSTRUMENTSSGIXPROC) (GLint marker);
+#endif
+
+#ifndef GL_SGIX_texture_scale_bias
+#define GL_SGIX_texture_scale_bias 1
+#endif
+
+#ifndef GL_SGIX_framezoom
+#define GL_SGIX_framezoom 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glFrameZoomSGIX (GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLFRAMEZOOMSGIXPROC) (GLint factor);
+#endif
+
+#ifndef GL_SGIX_tag_sample_buffer
+#define GL_SGIX_tag_sample_buffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTagSampleBufferSGIX (void);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
+#endif
+
+#ifndef GL_SGIX_polynomial_ffd
+#define GL_SGIX_polynomial_ffd 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDeformationMap3dSGIX (GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
+GLAPI void APIENTRY glDeformationMap3fSGIX (GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
+GLAPI void APIENTRY glDeformSGIX (GLbitfield);
+GLAPI void APIENTRY glLoadIdentityDeformationMapSGIX (GLbitfield);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDEFORMATIONMAP3DSGIXPROC) (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points);
+typedef void (APIENTRYP PFNGLDEFORMATIONMAP3FSGIXPROC) (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points);
+typedef void (APIENTRYP PFNGLDEFORMSGIXPROC) (GLbitfield mask);
+typedef void (APIENTRYP PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);
+#endif
+
+#ifndef GL_SGIX_reference_plane
+#define GL_SGIX_reference_plane 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glReferencePlaneSGIX (const GLdouble *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLREFERENCEPLANESGIXPROC) (const GLdouble *equation);
+#endif
+
+#ifndef GL_SGIX_flush_raster
+#define GL_SGIX_flush_raster 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glFlushRasterSGIX (void);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLFLUSHRASTERSGIXPROC) (void);
+#endif
+
+#ifndef GL_SGIX_depth_texture
+#define GL_SGIX_depth_texture 1
+#endif
+
+#ifndef GL_SGIS_fog_function
+#define GL_SGIS_fog_function 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glFogFuncSGIS (GLsizei, const GLfloat *);
+GLAPI void APIENTRY glGetFogFuncSGIS (GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat *points);
+typedef void (APIENTRYP PFNGLGETFOGFUNCSGISPROC) (GLfloat *points);
+#endif
+
+#ifndef GL_SGIX_fog_offset
+#define GL_SGIX_fog_offset 1
+#endif
+
+#ifndef GL_HP_image_transform
+#define GL_HP_image_transform 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glImageTransformParameteriHP (GLenum, GLenum, GLint);
+GLAPI void APIENTRY glImageTransformParameterfHP (GLenum, GLenum, GLfloat);
+GLAPI void APIENTRY glImageTransformParameterivHP (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glImageTransformParameterfvHP (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glGetImageTransformParameterivHP (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetImageTransformParameterfvHP (GLenum, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_HP_convolution_border_modes
+#define GL_HP_convolution_border_modes 1
+#endif
+
+#ifndef GL_SGIX_texture_add_env
+#define GL_SGIX_texture_add_env 1
+#endif
+
+#ifndef GL_EXT_color_subtable
+#define GL_EXT_color_subtable 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glColorSubTableEXT (GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glCopyColorSubTableEXT (GLenum, GLsizei, GLint, GLint, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
+#endif
+
+#ifndef GL_PGI_vertex_hints
+#define GL_PGI_vertex_hints 1
+#endif
+
+#ifndef GL_PGI_misc_hints
+#define GL_PGI_misc_hints 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glHintPGI (GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLHINTPGIPROC) (GLenum target, GLint mode);
+#endif
+
+#ifndef GL_EXT_paletted_texture
+#define GL_EXT_paletted_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glColorTableEXT (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+GLAPI void APIENTRY glGetColorTableEXT (GLenum, GLenum, GLenum, GLvoid *);
+GLAPI void APIENTRY glGetColorTableParameterivEXT (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetColorTableParameterfvEXT (GLenum, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_EXT_clip_volume_hint
+#define GL_EXT_clip_volume_hint 1
+#endif
+
+#ifndef GL_SGIX_list_priority
+#define GL_SGIX_list_priority 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGetListParameterfvSGIX (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetListParameterivSGIX (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glListParameterfSGIX (GLuint, GLenum, GLfloat);
+GLAPI void APIENTRY glListParameterfvSGIX (GLuint, GLenum, const GLfloat *);
+GLAPI void APIENTRY glListParameteriSGIX (GLuint, GLenum, GLint);
+GLAPI void APIENTRY glListParameterivSGIX (GLuint, GLenum, const GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGETLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLLISTPARAMETERFSGIXPROC) (GLuint list, GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLLISTPARAMETERFVSGIXPROC) (GLuint list, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLLISTPARAMETERISGIXPROC) (GLuint list, GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLLISTPARAMETERIVSGIXPROC) (GLuint list, GLenum pname, const GLint *params);
+#endif
+
+#ifndef GL_SGIX_ir_instrument1
+#define GL_SGIX_ir_instrument1 1
+#endif
+
+#ifndef GL_SGIX_calligraphic_fragment
+#define GL_SGIX_calligraphic_fragment 1
+#endif
+
+#ifndef GL_SGIX_texture_lod_bias
+#define GL_SGIX_texture_lod_bias 1
+#endif
+
+#ifndef GL_SGIX_shadow_ambient
+#define GL_SGIX_shadow_ambient 1
+#endif
+
+#ifndef GL_EXT_index_texture
+#define GL_EXT_index_texture 1
+#endif
+
+#ifndef GL_EXT_index_material
+#define GL_EXT_index_material 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glIndexMaterialEXT (GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);
+#endif
+
+#ifndef GL_EXT_index_func
+#define GL_EXT_index_func 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glIndexFuncEXT (GLenum, GLclampf);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLINDEXFUNCEXTPROC) (GLenum func, GLclampf ref);
+#endif
+
+#ifndef GL_EXT_index_array_formats
+#define GL_EXT_index_array_formats 1
+#endif
+
+#ifndef GL_EXT_compiled_vertex_array
+#define GL_EXT_compiled_vertex_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glLockArraysEXT (GLint, GLsizei);
+GLAPI void APIENTRY glUnlockArraysEXT (void);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
+typedef void (APIENTRYP PFNGLUNLOCKARRAYSEXTPROC) (void);
+#endif
+
+#ifndef GL_EXT_cull_vertex
+#define GL_EXT_cull_vertex 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCullParameterdvEXT (GLenum, GLdouble *);
+GLAPI void APIENTRY glCullParameterfvEXT (GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble *params);
+typedef void (APIENTRYP PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_SGIX_ycrcb
+#define GL_SGIX_ycrcb 1
+#endif
+
+#ifndef GL_SGIX_fragment_lighting
+#define GL_SGIX_fragment_lighting 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glFragmentColorMaterialSGIX (GLenum, GLenum);
+GLAPI void APIENTRY glFragmentLightfSGIX (GLenum, GLenum, GLfloat);
+GLAPI void APIENTRY glFragmentLightfvSGIX (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glFragmentLightiSGIX (GLenum, GLenum, GLint);
+GLAPI void APIENTRY glFragmentLightivSGIX (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glFragmentLightModelfSGIX (GLenum, GLfloat);
+GLAPI void APIENTRY glFragmentLightModelfvSGIX (GLenum, const GLfloat *);
+GLAPI void APIENTRY glFragmentLightModeliSGIX (GLenum, GLint);
+GLAPI void APIENTRY glFragmentLightModelivSGIX (GLenum, const GLint *);
+GLAPI void APIENTRY glFragmentMaterialfSGIX (GLenum, GLenum, GLfloat);
+GLAPI void APIENTRY glFragmentMaterialfvSGIX (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glFragmentMaterialiSGIX (GLenum, GLenum, GLint);
+GLAPI void APIENTRY glFragmentMaterialivSGIX (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glGetFragmentLightfvSGIX (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetFragmentLightivSGIX (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetFragmentMaterialfvSGIX (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetFragmentMaterialivSGIX (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glLightEnviSGIX (GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLLIGHTENVISGIXPROC) (GLenum pname, GLint param);
+#endif
+
+#ifndef GL_IBM_rasterpos_clip
+#define GL_IBM_rasterpos_clip 1
+#endif
+
+#ifndef GL_HP_texture_lighting
+#define GL_HP_texture_lighting 1
+#endif
+
+#ifndef GL_EXT_draw_range_elements
+#define GL_EXT_draw_range_elements 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDrawRangeElementsEXT (GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+#endif
+
+#ifndef GL_WIN_phong_shading
+#define GL_WIN_phong_shading 1
+#endif
+
+#ifndef GL_WIN_specular_fog
+#define GL_WIN_specular_fog 1
+#endif
+
+#ifndef GL_EXT_light_texture
+#define GL_EXT_light_texture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glApplyTextureEXT (GLenum);
+GLAPI void APIENTRY glTextureLightEXT (GLenum);
+GLAPI void APIENTRY glTextureMaterialEXT (GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
+typedef void (APIENTRYP PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
+typedef void (APIENTRYP PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
+#endif
+
+#ifndef GL_SGIX_blend_alpha_minmax
+#define GL_SGIX_blend_alpha_minmax 1
+#endif
+
+#ifndef GL_EXT_bgra
+#define GL_EXT_bgra 1
+#endif
+
+#ifndef GL_SGIX_async
+#define GL_SGIX_async 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glAsyncMarkerSGIX (GLuint);
+GLAPI GLint APIENTRY glFinishAsyncSGIX (GLuint *);
+GLAPI GLint APIENTRY glPollAsyncSGIX (GLuint *);
+GLAPI GLuint APIENTRY glGenAsyncMarkersSGIX (GLsizei);
+GLAPI void APIENTRY glDeleteAsyncMarkersSGIX (GLuint, GLsizei);
+GLAPI GLboolean APIENTRY glIsAsyncMarkerSGIX (GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
+typedef GLint (APIENTRYP PFNGLFINISHASYNCSGIXPROC) (GLuint *markerp);
+typedef GLint (APIENTRYP PFNGLPOLLASYNCSGIXPROC) (GLuint *markerp);
+typedef GLuint (APIENTRYP PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
+typedef void (APIENTRYP PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
+typedef GLboolean (APIENTRYP PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
+#endif
+
+#ifndef GL_SGIX_async_pixel
+#define GL_SGIX_async_pixel 1
+#endif
+
+#ifndef GL_SGIX_async_histogram
+#define GL_SGIX_async_histogram 1
+#endif
+
+#ifndef GL_INTEL_parallel_arrays
+#define GL_INTEL_parallel_arrays 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glVertexPointervINTEL (GLint, GLenum, const GLvoid* *);
+GLAPI void APIENTRY glNormalPointervINTEL (GLenum, const GLvoid* *);
+GLAPI void APIENTRY glColorPointervINTEL (GLint, GLenum, const GLvoid* *);
+GLAPI void APIENTRY glTexCoordPointervINTEL (GLint, GLenum, const GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
+typedef void (APIENTRYP PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const GLvoid* *pointer);
+typedef void (APIENTRYP PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
+typedef void (APIENTRYP PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid* *pointer);
+#endif
+
+#ifndef GL_HP_occlusion_test
+#define GL_HP_occlusion_test 1
+#endif
+
+#ifndef GL_EXT_pixel_transform
+#define GL_EXT_pixel_transform 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPixelTransformParameteriEXT (GLenum, GLenum, GLint);
+GLAPI void APIENTRY glPixelTransformParameterfEXT (GLenum, GLenum, GLfloat);
+GLAPI void APIENTRY glPixelTransformParameterivEXT (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glPixelTransformParameterfvEXT (GLenum, GLenum, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
+#endif
+
+#ifndef GL_EXT_pixel_transform_color_table
+#define GL_EXT_pixel_transform_color_table 1
+#endif
+
+#ifndef GL_EXT_shared_texture_palette
+#define GL_EXT_shared_texture_palette 1
+#endif
+
+#ifndef GL_EXT_separate_specular_color
+#define GL_EXT_separate_specular_color 1
+#endif
+
+#ifndef GL_EXT_secondary_color
+#define GL_EXT_secondary_color 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glSecondaryColor3bEXT (GLbyte, GLbyte, GLbyte);
+GLAPI void APIENTRY glSecondaryColor3bvEXT (const GLbyte *);
+GLAPI void APIENTRY glSecondaryColor3dEXT (GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glSecondaryColor3dvEXT (const GLdouble *);
+GLAPI void APIENTRY glSecondaryColor3fEXT (GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glSecondaryColor3fvEXT (const GLfloat *);
+GLAPI void APIENTRY glSecondaryColor3iEXT (GLint, GLint, GLint);
+GLAPI void APIENTRY glSecondaryColor3ivEXT (const GLint *);
+GLAPI void APIENTRY glSecondaryColor3sEXT (GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glSecondaryColor3svEXT (const GLshort *);
+GLAPI void APIENTRY glSecondaryColor3ubEXT (GLubyte, GLubyte, GLubyte);
+GLAPI void APIENTRY glSecondaryColor3ubvEXT (const GLubyte *);
+GLAPI void APIENTRY glSecondaryColor3uiEXT (GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glSecondaryColor3uivEXT (const GLuint *);
+GLAPI void APIENTRY glSecondaryColor3usEXT (GLushort, GLushort, GLushort);
+GLAPI void APIENTRY glSecondaryColor3usvEXT (const GLushort *);
+GLAPI void APIENTRY glSecondaryColorPointerEXT (GLint, GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
+typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_EXT_texture_perturb_normal
+#define GL_EXT_texture_perturb_normal 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTextureNormalEXT (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
+#endif
+
+#ifndef GL_EXT_multi_draw_arrays
+#define GL_EXT_multi_draw_arrays 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glMultiDrawArraysEXT (GLenum, GLint *, GLsizei *, GLsizei);
+GLAPI void APIENTRY glMultiDrawElementsEXT (GLenum, const GLsizei *, GLenum, const GLvoid* *, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
+#endif
+
+#ifndef GL_EXT_fog_coord
+#define GL_EXT_fog_coord 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glFogCoordfEXT (GLfloat);
+GLAPI void APIENTRY glFogCoordfvEXT (const GLfloat *);
+GLAPI void APIENTRY glFogCoorddEXT (GLdouble);
+GLAPI void APIENTRY glFogCoorddvEXT (const GLdouble *);
+GLAPI void APIENTRY glFogCoordPointerEXT (GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
+typedef void (APIENTRYP PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
+typedef void (APIENTRYP PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
+typedef void (APIENTRYP PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
+typedef void (APIENTRYP PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_REND_screen_coordinates
+#define GL_REND_screen_coordinates 1
+#endif
+
+#ifndef GL_EXT_coordinate_frame
+#define GL_EXT_coordinate_frame 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTangent3bEXT (GLbyte, GLbyte, GLbyte);
+GLAPI void APIENTRY glTangent3bvEXT (const GLbyte *);
+GLAPI void APIENTRY glTangent3dEXT (GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glTangent3dvEXT (const GLdouble *);
+GLAPI void APIENTRY glTangent3fEXT (GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTangent3fvEXT (const GLfloat *);
+GLAPI void APIENTRY glTangent3iEXT (GLint, GLint, GLint);
+GLAPI void APIENTRY glTangent3ivEXT (const GLint *);
+GLAPI void APIENTRY glTangent3sEXT (GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glTangent3svEXT (const GLshort *);
+GLAPI void APIENTRY glBinormal3bEXT (GLbyte, GLbyte, GLbyte);
+GLAPI void APIENTRY glBinormal3bvEXT (const GLbyte *);
+GLAPI void APIENTRY glBinormal3dEXT (GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glBinormal3dvEXT (const GLdouble *);
+GLAPI void APIENTRY glBinormal3fEXT (GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glBinormal3fvEXT (const GLfloat *);
+GLAPI void APIENTRY glBinormal3iEXT (GLint, GLint, GLint);
+GLAPI void APIENTRY glBinormal3ivEXT (const GLint *);
+GLAPI void APIENTRY glBinormal3sEXT (GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glBinormal3svEXT (const GLshort *);
+GLAPI void APIENTRY glTangentPointerEXT (GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glBinormalPointerEXT (GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTANGENT3BEXTPROC) (GLbyte tx, GLbyte ty, GLbyte tz);
+typedef void (APIENTRYP PFNGLTANGENT3BVEXTPROC) (const GLbyte *v);
+typedef void (APIENTRYP PFNGLTANGENT3DEXTPROC) (GLdouble tx, GLdouble ty, GLdouble tz);
+typedef void (APIENTRYP PFNGLTANGENT3DVEXTPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLTANGENT3FEXTPROC) (GLfloat tx, GLfloat ty, GLfloat tz);
+typedef void (APIENTRYP PFNGLTANGENT3FVEXTPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLTANGENT3IEXTPROC) (GLint tx, GLint ty, GLint tz);
+typedef void (APIENTRYP PFNGLTANGENT3IVEXTPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLTANGENT3SEXTPROC) (GLshort tx, GLshort ty, GLshort tz);
+typedef void (APIENTRYP PFNGLTANGENT3SVEXTPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLBINORMAL3BEXTPROC) (GLbyte bx, GLbyte by, GLbyte bz);
+typedef void (APIENTRYP PFNGLBINORMAL3BVEXTPROC) (const GLbyte *v);
+typedef void (APIENTRYP PFNGLBINORMAL3DEXTPROC) (GLdouble bx, GLdouble by, GLdouble bz);
+typedef void (APIENTRYP PFNGLBINORMAL3DVEXTPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLBINORMAL3FEXTPROC) (GLfloat bx, GLfloat by, GLfloat bz);
+typedef void (APIENTRYP PFNGLBINORMAL3FVEXTPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLBINORMAL3IEXTPROC) (GLint bx, GLint by, GLint bz);
+typedef void (APIENTRYP PFNGLBINORMAL3IVEXTPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLBINORMAL3SEXTPROC) (GLshort bx, GLshort by, GLshort bz);
+typedef void (APIENTRYP PFNGLBINORMAL3SVEXTPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_EXT_texture_env_combine
+#define GL_EXT_texture_env_combine 1
+#endif
+
+#ifndef GL_APPLE_specular_vector
+#define GL_APPLE_specular_vector 1
+#endif
+
+#ifndef GL_APPLE_transform_hint
+#define GL_APPLE_transform_hint 1
+#endif
+
+#ifndef GL_SGIX_fog_scale
+#define GL_SGIX_fog_scale 1
+#endif
+
+#ifndef GL_SUNX_constant_data
+#define GL_SUNX_constant_data 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glFinishTextureSUNX (void);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLFINISHTEXTURESUNXPROC) (void);
+#endif
+
+#ifndef GL_SUN_global_alpha
+#define GL_SUN_global_alpha 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGlobalAlphaFactorbSUN (GLbyte);
+GLAPI void APIENTRY glGlobalAlphaFactorsSUN (GLshort);
+GLAPI void APIENTRY glGlobalAlphaFactoriSUN (GLint);
+GLAPI void APIENTRY glGlobalAlphaFactorfSUN (GLfloat);
+GLAPI void APIENTRY glGlobalAlphaFactordSUN (GLdouble);
+GLAPI void APIENTRY glGlobalAlphaFactorubSUN (GLubyte);
+GLAPI void APIENTRY glGlobalAlphaFactorusSUN (GLushort);
+GLAPI void APIENTRY glGlobalAlphaFactoruiSUN (GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
+typedef void (APIENTRYP PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
+#endif
+
+#ifndef GL_SUN_triangle_list
+#define GL_SUN_triangle_list 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glReplacementCodeuiSUN (GLuint);
+GLAPI void APIENTRY glReplacementCodeusSUN (GLushort);
+GLAPI void APIENTRY glReplacementCodeubSUN (GLubyte);
+GLAPI void APIENTRY glReplacementCodeuivSUN (const GLuint *);
+GLAPI void APIENTRY glReplacementCodeusvSUN (const GLushort *);
+GLAPI void APIENTRY glReplacementCodeubvSUN (const GLubyte *);
+GLAPI void APIENTRY glReplacementCodePointerSUN (GLenum, GLsizei, const GLvoid* *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint *code);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort *code);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte *code);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid* *pointer);
+#endif
+
+#ifndef GL_SUN_vertex
+#define GL_SUN_vertex 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glColor4ubVertex2fSUN (GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat);
+GLAPI void APIENTRY glColor4ubVertex2fvSUN (const GLubyte *, const GLfloat *);
+GLAPI void APIENTRY glColor4ubVertex3fSUN (GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glColor4ubVertex3fvSUN (const GLubyte *, const GLfloat *);
+GLAPI void APIENTRY glColor3fVertex3fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glColor3fVertex3fvSUN (const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glNormal3fVertex3fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glNormal3fVertex3fvSUN (const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glColor4fNormal3fVertex3fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glColor4fNormal3fVertex3fvSUN (const GLfloat *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glTexCoord2fVertex3fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTexCoord2fVertex3fvSUN (const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glTexCoord4fVertex4fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTexCoord4fVertex4fvSUN (const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glTexCoord2fColor4ubVertex3fSUN (GLfloat, GLfloat, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTexCoord2fColor4ubVertex3fvSUN (const GLfloat *, const GLubyte *, const GLfloat *);
+GLAPI void APIENTRY glTexCoord2fColor3fVertex3fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTexCoord2fColor3fVertex3fvSUN (const GLfloat *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glTexCoord2fNormal3fVertex3fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTexCoord2fNormal3fVertex3fvSUN (const GLfloat *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glTexCoord2fColor4fNormal3fVertex3fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTexCoord2fColor4fNormal3fVertex3fvSUN (const GLfloat *, const GLfloat *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glTexCoord4fColor4fNormal3fVertex4fSUN (GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glTexCoord4fColor4fNormal3fVertex4fvSUN (const GLfloat *, const GLfloat *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiVertex3fSUN (GLuint, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiVertex3fvSUN (const GLuint *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiColor4ubVertex3fSUN (GLuint, GLubyte, GLubyte, GLubyte, GLubyte, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiColor4ubVertex3fvSUN (const GLuint *, const GLubyte *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiColor3fVertex3fSUN (GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiColor3fVertex3fvSUN (const GLuint *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiNormal3fVertex3fSUN (GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiNormal3fVertex3fvSUN (const GLuint *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiColor4fNormal3fVertex3fSUN (GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiColor4fNormal3fVertex3fvSUN (const GLuint *, const GLfloat *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiTexCoord2fVertex3fSUN (GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiTexCoord2fVertex3fvSUN (const GLuint *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN (GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN (const GLuint *, const GLfloat *, const GLfloat *, const GLfloat *);
+GLAPI void APIENTRY glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN (GLuint, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN (const GLuint *, const GLfloat *, const GLfloat *, const GLfloat *, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
+typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte *c, const GLfloat *v);
+typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte *c, const GLfloat *v);
+typedef void (APIENTRYP PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *v);
+typedef void (APIENTRYP PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *c, const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
+typedef void (APIENTRYP PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *v);
+typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat *tc, const GLubyte *c, const GLfloat *v);
+typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *v);
+typedef void (APIENTRYP PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint *rc, const GLubyte *c, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
+#endif
+
+#ifndef GL_EXT_blend_func_separate
+#define GL_EXT_blend_func_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendFuncSeparateEXT (GLenum, GLenum, GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+#endif
+
+#ifndef GL_INGR_blend_func_separate
+#define GL_INGR_blend_func_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendFuncSeparateINGR (GLenum, GLenum, GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEINGRPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+#endif
+
+#ifndef GL_INGR_color_clamp
+#define GL_INGR_color_clamp 1
+#endif
+
+#ifndef GL_INGR_interlace_read
+#define GL_INGR_interlace_read 1
+#endif
+
+#ifndef GL_EXT_stencil_wrap
+#define GL_EXT_stencil_wrap 1
+#endif
+
+#ifndef GL_EXT_422_pixels
+#define GL_EXT_422_pixels 1
+#endif
+
+#ifndef GL_NV_texgen_reflection
+#define GL_NV_texgen_reflection 1
+#endif
+
+#ifndef GL_SUN_convolution_border_modes
+#define GL_SUN_convolution_border_modes 1
+#endif
+
+#ifndef GL_EXT_texture_env_add
+#define GL_EXT_texture_env_add 1
+#endif
+
+#ifndef GL_EXT_texture_lod_bias
+#define GL_EXT_texture_lod_bias 1
+#endif
+
+#ifndef GL_EXT_texture_filter_anisotropic
+#define GL_EXT_texture_filter_anisotropic 1
+#endif
+
+#ifndef GL_EXT_vertex_weighting
+#define GL_EXT_vertex_weighting 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glVertexWeightfEXT (GLfloat);
+GLAPI void APIENTRY glVertexWeightfvEXT (const GLfloat *);
+GLAPI void APIENTRY glVertexWeightPointerEXT (GLsizei, GLenum, GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
+typedef void (APIENTRYP PFNGLVERTEXWEIGHTFVEXTPROC) (const GLfloat *weight);
+typedef void (APIENTRYP PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer);
+#endif
+
+#ifndef GL_NV_light_max_exponent
+#define GL_NV_light_max_exponent 1
+#endif
+
+#ifndef GL_NV_vertex_array_range
+#define GL_NV_vertex_array_range 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glFlushVertexArrayRangeNV (void);
+GLAPI void APIENTRY glVertexArrayRangeNV (GLsizei, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
+typedef void (APIENTRYP PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, const GLvoid *pointer);
+#endif
+
+#ifndef GL_NV_register_combiners
+#define GL_NV_register_combiners 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCombinerParameterfvNV (GLenum, const GLfloat *);
+GLAPI void APIENTRY glCombinerParameterfNV (GLenum, GLfloat);
+GLAPI void APIENTRY glCombinerParameterivNV (GLenum, const GLint *);
+GLAPI void APIENTRY glCombinerParameteriNV (GLenum, GLint);
+GLAPI void APIENTRY glCombinerInputNV (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum);
+GLAPI void APIENTRY glCombinerOutputNV (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean);
+GLAPI void APIENTRY glFinalCombinerInputNV (GLenum, GLenum, GLenum, GLenum);
+GLAPI void APIENTRY glGetCombinerInputParameterfvNV (GLenum, GLenum, GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetCombinerInputParameterivNV (GLenum, GLenum, GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetCombinerOutputParameterfvNV (GLenum, GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetCombinerOutputParameterivNV (GLenum, GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetFinalCombinerInputParameterfvNV (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetFinalCombinerInputParameterivNV (GLenum, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
+typedef void (APIENTRYP PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+typedef void (APIENTRYP PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
+typedef void (APIENTRYP PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
+typedef void (APIENTRYP PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_NV_fog_distance
+#define GL_NV_fog_distance 1
+#endif
+
+#ifndef GL_NV_texgen_emboss
+#define GL_NV_texgen_emboss 1
+#endif
+
+#ifndef GL_NV_blend_square
+#define GL_NV_blend_square 1
+#endif
+
+#ifndef GL_NV_texture_env_combine4
+#define GL_NV_texture_env_combine4 1
+#endif
+
+#ifndef GL_MESA_resize_buffers
+#define GL_MESA_resize_buffers 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glResizeBuffersMESA (void);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLRESIZEBUFFERSMESAPROC) (void);
+#endif
+
+#ifndef GL_MESA_window_pos
+#define GL_MESA_window_pos 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glWindowPos2dMESA (GLdouble, GLdouble);
+GLAPI void APIENTRY glWindowPos2dvMESA (const GLdouble *);
+GLAPI void APIENTRY glWindowPos2fMESA (GLfloat, GLfloat);
+GLAPI void APIENTRY glWindowPos2fvMESA (const GLfloat *);
+GLAPI void APIENTRY glWindowPos2iMESA (GLint, GLint);
+GLAPI void APIENTRY glWindowPos2ivMESA (const GLint *);
+GLAPI void APIENTRY glWindowPos2sMESA (GLshort, GLshort);
+GLAPI void APIENTRY glWindowPos2svMESA (const GLshort *);
+GLAPI void APIENTRY glWindowPos3dMESA (GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glWindowPos3dvMESA (const GLdouble *);
+GLAPI void APIENTRY glWindowPos3fMESA (GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glWindowPos3fvMESA (const GLfloat *);
+GLAPI void APIENTRY glWindowPos3iMESA (GLint, GLint, GLint);
+GLAPI void APIENTRY glWindowPos3ivMESA (const GLint *);
+GLAPI void APIENTRY glWindowPos3sMESA (GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glWindowPos3svMESA (const GLshort *);
+GLAPI void APIENTRY glWindowPos4dMESA (GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glWindowPos4dvMESA (const GLdouble *);
+GLAPI void APIENTRY glWindowPos4fMESA (GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glWindowPos4fvMESA (const GLfloat *);
+GLAPI void APIENTRY glWindowPos4iMESA (GLint, GLint, GLint, GLint);
+GLAPI void APIENTRY glWindowPos4ivMESA (const GLint *);
+GLAPI void APIENTRY glWindowPos4sMESA (GLshort, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glWindowPos4svMESA (const GLshort *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2IVMESAPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
+typedef void (APIENTRYP PFNGLWINDOWPOS2SVMESAPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3IVMESAPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
+typedef void (APIENTRYP PFNGLWINDOWPOS3SVMESAPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
+typedef void (APIENTRYP PFNGLWINDOWPOS4IVMESAPROC) (const GLint *v);
+typedef void (APIENTRYP PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
+typedef void (APIENTRYP PFNGLWINDOWPOS4SVMESAPROC) (const GLshort *v);
+#endif
+
+#ifndef GL_IBM_cull_vertex
+#define GL_IBM_cull_vertex 1
+#endif
+
+#ifndef GL_IBM_multimode_draw_arrays
+#define GL_IBM_multimode_draw_arrays 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glMultiModeDrawArraysIBM (const GLenum *, const GLint *, const GLsizei *, GLsizei, GLint);
+GLAPI void APIENTRY glMultiModeDrawElementsIBM (const GLenum *, const GLsizei *, GLenum, const GLvoid* const *, GLsizei, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
+typedef void (APIENTRYP PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, GLint modestride);
+#endif
+
+#ifndef GL_IBM_vertex_array_lists
+#define GL_IBM_vertex_array_lists 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glColorPointerListIBM (GLint, GLenum, GLint, const GLvoid* *, GLint);
+GLAPI void APIENTRY glSecondaryColorPointerListIBM (GLint, GLenum, GLint, const GLvoid* *, GLint);
+GLAPI void APIENTRY glEdgeFlagPointerListIBM (GLint, const GLboolean* *, GLint);
+GLAPI void APIENTRY glFogCoordPointerListIBM (GLenum, GLint, const GLvoid* *, GLint);
+GLAPI void APIENTRY glIndexPointerListIBM (GLenum, GLint, const GLvoid* *, GLint);
+GLAPI void APIENTRY glNormalPointerListIBM (GLenum, GLint, const GLvoid* *, GLint);
+GLAPI void APIENTRY glTexCoordPointerListIBM (GLint, GLenum, GLint, const GLvoid* *, GLint);
+GLAPI void APIENTRY glVertexPointerListIBM (GLint, GLenum, GLint, const GLvoid* *, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean* *pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid* *pointer, GLint ptrstride);
+#endif
+
+#ifndef GL_SGIX_subsample
+#define GL_SGIX_subsample 1
+#endif
+
+#ifndef GL_SGIX_ycrcba
+#define GL_SGIX_ycrcba 1
+#endif
+
+#ifndef GL_SGIX_ycrcb_subsample
+#define GL_SGIX_ycrcb_subsample 1
+#endif
+
+#ifndef GL_SGIX_depth_pass_instrument
+#define GL_SGIX_depth_pass_instrument 1
+#endif
+
+#ifndef GL_3DFX_texture_compression_FXT1
+#define GL_3DFX_texture_compression_FXT1 1
+#endif
+
+#ifndef GL_3DFX_multisample
+#define GL_3DFX_multisample 1
+#endif
+
+#ifndef GL_3DFX_tbuffer
+#define GL_3DFX_tbuffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTbufferMask3DFX (GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
+#endif
+
+#ifndef GL_EXT_multisample
+#define GL_EXT_multisample 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glSampleMaskEXT (GLclampf, GLboolean);
+GLAPI void APIENTRY glSamplePatternEXT (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
+typedef void (APIENTRYP PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
+#endif
+
+#ifndef GL_SGIX_vertex_preclip
+#define GL_SGIX_vertex_preclip 1
+#endif
+
+#ifndef GL_SGIX_convolution_accuracy
+#define GL_SGIX_convolution_accuracy 1
+#endif
+
+#ifndef GL_SGIX_resample
+#define GL_SGIX_resample 1
+#endif
+
+#ifndef GL_SGIS_point_line_texgen
+#define GL_SGIS_point_line_texgen 1
+#endif
+
+#ifndef GL_SGIS_texture_color_mask
+#define GL_SGIS_texture_color_mask 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTextureColorMaskSGIS (GLboolean, GLboolean, GLboolean, GLboolean);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTEXTURECOLORMASKSGISPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
+#endif
+
+#ifndef GL_SGIX_igloo_interface
+#define GL_SGIX_igloo_interface 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glIglooInterfaceSGIX (GLenum, const GLvoid *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, const GLvoid *params);
+#endif
+
+#ifndef GL_EXT_texture_env_dot3
+#define GL_EXT_texture_env_dot3 1
+#endif
+
+#ifndef GL_ATI_texture_mirror_once
+#define GL_ATI_texture_mirror_once 1
+#endif
+
+#ifndef GL_NV_fence
+#define GL_NV_fence 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDeleteFencesNV (GLsizei, const GLuint *);
+GLAPI void APIENTRY glGenFencesNV (GLsizei, GLuint *);
+GLAPI GLboolean APIENTRY glIsFenceNV (GLuint);
+GLAPI GLboolean APIENTRY glTestFenceNV (GLuint);
+GLAPI void APIENTRY glGetFenceivNV (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glFinishFenceNV (GLuint);
+GLAPI void APIENTRY glSetFenceNV (GLuint, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint *fences);
+typedef void (APIENTRYP PFNGLGENFENCESNVPROC) (GLsizei n, GLuint *fences);
+typedef GLboolean (APIENTRYP PFNGLISFENCENVPROC) (GLuint fence);
+typedef GLboolean (APIENTRYP PFNGLTESTFENCENVPROC) (GLuint fence);
+typedef void (APIENTRYP PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLFINISHFENCENVPROC) (GLuint fence);
+typedef void (APIENTRYP PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
+#endif
+
+#ifndef GL_NV_evaluators
+#define GL_NV_evaluators 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glMapControlPointsNV (GLenum, GLuint, GLenum, GLsizei, GLsizei, GLint, GLint, GLboolean, const GLvoid *);
+GLAPI void APIENTRY glMapParameterivNV (GLenum, GLenum, const GLint *);
+GLAPI void APIENTRY glMapParameterfvNV (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glGetMapControlPointsNV (GLenum, GLuint, GLenum, GLsizei, GLsizei, GLboolean, GLvoid *);
+GLAPI void APIENTRY glGetMapParameterivNV (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glGetMapParameterfvNV (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetMapAttribParameterivNV (GLenum, GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetMapAttribParameterfvNV (GLenum, GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glEvalMapsNV (GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
+typedef void (APIENTRYP PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
+typedef void (APIENTRYP PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
+#endif
+
+#ifndef GL_NV_packed_depth_stencil
+#define GL_NV_packed_depth_stencil 1
+#endif
+
+#ifndef GL_NV_register_combiners2
+#define GL_NV_register_combiners2 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCombinerStageParameterfvNV (GLenum, GLenum, const GLfloat *);
+GLAPI void APIENTRY glGetCombinerStageParameterfvNV (GLenum, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat *params);
+#endif
+
+#ifndef GL_NV_texture_compression_vtc
+#define GL_NV_texture_compression_vtc 1
+#endif
+
+#ifndef GL_NV_texture_rectangle
+#define GL_NV_texture_rectangle 1
+#endif
+
+#ifndef GL_NV_texture_shader
+#define GL_NV_texture_shader 1
+#endif
+
+#ifndef GL_NV_texture_shader2
+#define GL_NV_texture_shader2 1
+#endif
+
+#ifndef GL_NV_vertex_array_range2
+#define GL_NV_vertex_array_range2 1
+#endif
+
+#ifndef GL_NV_vertex_program
+#define GL_NV_vertex_program 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI GLboolean APIENTRY glAreProgramsResidentNV (GLsizei, const GLuint *, GLboolean *);
+GLAPI void APIENTRY glBindProgramNV (GLenum, GLuint);
+GLAPI void APIENTRY glDeleteProgramsNV (GLsizei, const GLuint *);
+GLAPI void APIENTRY glExecuteProgramNV (GLenum, GLuint, const GLfloat *);
+GLAPI void APIENTRY glGenProgramsNV (GLsizei, GLuint *);
+GLAPI void APIENTRY glGetProgramParameterdvNV (GLenum, GLuint, GLenum, GLdouble *);
+GLAPI void APIENTRY glGetProgramParameterfvNV (GLenum, GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetProgramivNV (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetProgramStringNV (GLuint, GLenum, GLubyte *);
+GLAPI void APIENTRY glGetTrackMatrixivNV (GLenum, GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetVertexAttribdvNV (GLuint, GLenum, GLdouble *);
+GLAPI void APIENTRY glGetVertexAttribfvNV (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetVertexAttribivNV (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetVertexAttribPointervNV (GLuint, GLenum, GLvoid* *);
+GLAPI GLboolean APIENTRY glIsProgramNV (GLuint);
+GLAPI void APIENTRY glLoadProgramNV (GLenum, GLuint, GLsizei, const GLubyte *);
+GLAPI void APIENTRY glProgramParameter4dNV (GLenum, GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glProgramParameter4dvNV (GLenum, GLuint, const GLdouble *);
+GLAPI void APIENTRY glProgramParameter4fNV (GLenum, GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glProgramParameter4fvNV (GLenum, GLuint, const GLfloat *);
+GLAPI void APIENTRY glProgramParameters4dvNV (GLenum, GLuint, GLuint, const GLdouble *);
+GLAPI void APIENTRY glProgramParameters4fvNV (GLenum, GLuint, GLuint, const GLfloat *);
+GLAPI void APIENTRY glRequestResidentProgramsNV (GLsizei, const GLuint *);
+GLAPI void APIENTRY glTrackMatrixNV (GLenum, GLuint, GLenum, GLenum);
+GLAPI void APIENTRY glVertexAttribPointerNV (GLuint, GLint, GLenum, GLsizei, const GLvoid *);
+GLAPI void APIENTRY glVertexAttrib1dNV (GLuint, GLdouble);
+GLAPI void APIENTRY glVertexAttrib1dvNV (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib1fNV (GLuint, GLfloat);
+GLAPI void APIENTRY glVertexAttrib1fvNV (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib1sNV (GLuint, GLshort);
+GLAPI void APIENTRY glVertexAttrib1svNV (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib2dNV (GLuint, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexAttrib2dvNV (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib2fNV (GLuint, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexAttrib2fvNV (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib2sNV (GLuint, GLshort, GLshort);
+GLAPI void APIENTRY glVertexAttrib2svNV (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib3dNV (GLuint, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexAttrib3dvNV (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib3fNV (GLuint, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexAttrib3fvNV (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib3sNV (GLuint, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glVertexAttrib3svNV (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib4dNV (GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexAttrib4dvNV (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVertexAttrib4fNV (GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexAttrib4fvNV (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVertexAttrib4sNV (GLuint, GLshort, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glVertexAttrib4svNV (GLuint, const GLshort *);
+GLAPI void APIENTRY glVertexAttrib4ubNV (GLuint, GLubyte, GLubyte, GLubyte, GLubyte);
+GLAPI void APIENTRY glVertexAttrib4ubvNV (GLuint, const GLubyte *);
+GLAPI void APIENTRY glVertexAttribs1dvNV (GLuint, GLsizei, const GLdouble *);
+GLAPI void APIENTRY glVertexAttribs1fvNV (GLuint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glVertexAttribs1svNV (GLuint, GLsizei, const GLshort *);
+GLAPI void APIENTRY glVertexAttribs2dvNV (GLuint, GLsizei, const GLdouble *);
+GLAPI void APIENTRY glVertexAttribs2fvNV (GLuint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glVertexAttribs2svNV (GLuint, GLsizei, const GLshort *);
+GLAPI void APIENTRY glVertexAttribs3dvNV (GLuint, GLsizei, const GLdouble *);
+GLAPI void APIENTRY glVertexAttribs3fvNV (GLuint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glVertexAttribs3svNV (GLuint, GLsizei, const GLshort *);
+GLAPI void APIENTRY glVertexAttribs4dvNV (GLuint, GLsizei, const GLdouble *);
+GLAPI void APIENTRY glVertexAttribs4fvNV (GLuint, GLsizei, const GLfloat *);
+GLAPI void APIENTRY glVertexAttribs4svNV (GLuint, GLsizei, const GLshort *);
+GLAPI void APIENTRY glVertexAttribs4ubvNV (GLuint, GLsizei, const GLubyte *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef GLboolean (APIENTRYP PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint *programs, GLboolean *residences);
+typedef void (APIENTRYP PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
+typedef void (APIENTRYP PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
+typedef void (APIENTRYP PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat *params);
+typedef void (APIENTRYP PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint *programs);
+typedef void (APIENTRYP PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte *program);
+typedef void (APIENTRYP PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
+typedef GLboolean (APIENTRYP PFNGLISPROGRAMNVPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
+typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLuint count, const GLdouble *v);
+typedef void (APIENTRYP PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLuint count, const GLfloat *v);
+typedef void (APIENTRYP PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
+typedef void (APIENTRYP PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei count, const GLubyte *v);
+#endif
+
+#ifndef GL_SGIX_texture_coordinate_clamp
+#define GL_SGIX_texture_coordinate_clamp 1
+#endif
+
+#ifndef GL_SGIX_scalebias_hint
+#define GL_SGIX_scalebias_hint 1
+#endif
+
+#ifndef GL_OML_interlace
+#define GL_OML_interlace 1
+#endif
+
+#ifndef GL_OML_subsample
+#define GL_OML_subsample 1
+#endif
+
+#ifndef GL_OML_resample
+#define GL_OML_resample 1
+#endif
+
+#ifndef GL_NV_copy_depth_to_color
+#define GL_NV_copy_depth_to_color 1
+#endif
+
+#ifndef GL_ATI_envmap_bumpmap
+#define GL_ATI_envmap_bumpmap 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTexBumpParameterivATI (GLenum, const GLint *);
+GLAPI void APIENTRY glTexBumpParameterfvATI (GLenum, const GLfloat *);
+GLAPI void APIENTRY glGetTexBumpParameterivATI (GLenum, GLint *);
+GLAPI void APIENTRY glGetTexBumpParameterfvATI (GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, const GLint *param);
+typedef void (APIENTRYP PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, const GLfloat *param);
+typedef void (APIENTRYP PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
+typedef void (APIENTRYP PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
+#endif
+
+#ifndef GL_ATI_fragment_shader
+#define GL_ATI_fragment_shader 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI GLuint APIENTRY glGenFragmentShadersATI (GLuint);
+GLAPI void APIENTRY glBindFragmentShaderATI (GLuint);
+GLAPI void APIENTRY glDeleteFragmentShaderATI (GLuint);
+GLAPI void APIENTRY glBeginFragmentShaderATI (void);
+GLAPI void APIENTRY glEndFragmentShaderATI (void);
+GLAPI void APIENTRY glPassTexCoordATI (GLuint, GLuint, GLenum);
+GLAPI void APIENTRY glSampleMapATI (GLuint, GLuint, GLenum);
+GLAPI void APIENTRY glColorFragmentOp1ATI (GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glColorFragmentOp2ATI (GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glColorFragmentOp3ATI (GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glAlphaFragmentOp1ATI (GLenum, GLuint, GLuint, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glAlphaFragmentOp2ATI (GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glAlphaFragmentOp3ATI (GLenum, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glSetFragmentShaderConstantATI (GLuint, const GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef GLuint (APIENTRYP PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
+typedef void (APIENTRYP PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
+typedef void (APIENTRYP PFNGLENDFRAGMENTSHADERATIPROC) (void);
+typedef void (APIENTRYP PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
+typedef void (APIENTRYP PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
+typedef void (APIENTRYP PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
+typedef void (APIENTRYP PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
+typedef void (APIENTRYP PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
+typedef void (APIENTRYP PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
+typedef void (APIENTRYP PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
+typedef void (APIENTRYP PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
+typedef void (APIENTRYP PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat *value);
+#endif
+
+#ifndef GL_ATI_pn_triangles
+#define GL_ATI_pn_triangles 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPNTrianglesiATI (GLenum, GLint);
+GLAPI void APIENTRY glPNTrianglesfATI (GLenum, GLfloat);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
+#endif
+
+#ifndef GL_ATI_vertex_array_object
+#define GL_ATI_vertex_array_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI GLuint APIENTRY glNewObjectBufferATI (GLsizei, const GLvoid *, GLenum);
+GLAPI GLboolean APIENTRY glIsObjectBufferATI (GLuint);
+GLAPI void APIENTRY glUpdateObjectBufferATI (GLuint, GLuint, GLsizei, const GLvoid *, GLenum);
+GLAPI void APIENTRY glGetObjectBufferfvATI (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetObjectBufferivATI (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glFreeObjectBufferATI (GLuint);
+GLAPI void APIENTRY glArrayObjectATI (GLenum, GLint, GLenum, GLsizei, GLuint, GLuint);
+GLAPI void APIENTRY glGetArrayObjectfvATI (GLenum, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetArrayObjectivATI (GLenum, GLenum, GLint *);
+GLAPI void APIENTRY glVariantArrayObjectATI (GLuint, GLenum, GLsizei, GLuint, GLuint);
+GLAPI void APIENTRY glGetVariantArrayObjectfvATI (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetVariantArrayObjectivATI (GLuint, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef GLuint (APIENTRYP PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const GLvoid *pointer, GLenum usage);
+typedef GLboolean (APIENTRYP PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
+typedef void (APIENTRYP PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
+typedef void (APIENTRYP PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
+typedef void (APIENTRYP PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
+typedef void (APIENTRYP PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
+typedef void (APIENTRYP PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_EXT_vertex_shader
+#define GL_EXT_vertex_shader 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBeginVertexShaderEXT (void);
+GLAPI void APIENTRY glEndVertexShaderEXT (void);
+GLAPI void APIENTRY glBindVertexShaderEXT (GLuint);
+GLAPI GLuint APIENTRY glGenVertexShadersEXT (GLuint);
+GLAPI void APIENTRY glDeleteVertexShaderEXT (GLuint);
+GLAPI void APIENTRY glShaderOp1EXT (GLenum, GLuint, GLuint);
+GLAPI void APIENTRY glShaderOp2EXT (GLenum, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glShaderOp3EXT (GLenum, GLuint, GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glSwizzleEXT (GLuint, GLuint, GLenum, GLenum, GLenum, GLenum);
+GLAPI void APIENTRY glWriteMaskEXT (GLuint, GLuint, GLenum, GLenum, GLenum, GLenum);
+GLAPI void APIENTRY glInsertComponentEXT (GLuint, GLuint, GLuint);
+GLAPI void APIENTRY glExtractComponentEXT (GLuint, GLuint, GLuint);
+GLAPI GLuint APIENTRY glGenSymbolsEXT (GLenum, GLenum, GLenum, GLuint);
+GLAPI void APIENTRY glSetInvariantEXT (GLuint, GLenum, const GLvoid *);
+GLAPI void APIENTRY glSetLocalConstantEXT (GLuint, GLenum, const GLvoid *);
+GLAPI void APIENTRY glVariantbvEXT (GLuint, const GLbyte *);
+GLAPI void APIENTRY glVariantsvEXT (GLuint, const GLshort *);
+GLAPI void APIENTRY glVariantivEXT (GLuint, const GLint *);
+GLAPI void APIENTRY glVariantfvEXT (GLuint, const GLfloat *);
+GLAPI void APIENTRY glVariantdvEXT (GLuint, const GLdouble *);
+GLAPI void APIENTRY glVariantubvEXT (GLuint, const GLubyte *);
+GLAPI void APIENTRY glVariantusvEXT (GLuint, const GLushort *);
+GLAPI void APIENTRY glVariantuivEXT (GLuint, const GLuint *);
+GLAPI void APIENTRY glVariantPointerEXT (GLuint, GLenum, GLuint, const GLvoid *);
+GLAPI void APIENTRY glEnableVariantClientStateEXT (GLuint);
+GLAPI void APIENTRY glDisableVariantClientStateEXT (GLuint);
+GLAPI GLuint APIENTRY glBindLightParameterEXT (GLenum, GLenum);
+GLAPI GLuint APIENTRY glBindMaterialParameterEXT (GLenum, GLenum);
+GLAPI GLuint APIENTRY glBindTexGenParameterEXT (GLenum, GLenum, GLenum);
+GLAPI GLuint APIENTRY glBindTextureUnitParameterEXT (GLenum, GLenum);
+GLAPI GLuint APIENTRY glBindParameterEXT (GLenum);
+GLAPI GLboolean APIENTRY glIsVariantEnabledEXT (GLuint, GLenum);
+GLAPI void APIENTRY glGetVariantBooleanvEXT (GLuint, GLenum, GLboolean *);
+GLAPI void APIENTRY glGetVariantIntegervEXT (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetVariantFloatvEXT (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetVariantPointervEXT (GLuint, GLenum, GLvoid* *);
+GLAPI void APIENTRY glGetInvariantBooleanvEXT (GLuint, GLenum, GLboolean *);
+GLAPI void APIENTRY glGetInvariantIntegervEXT (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetInvariantFloatvEXT (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetLocalConstantBooleanvEXT (GLuint, GLenum, GLboolean *);
+GLAPI void APIENTRY glGetLocalConstantIntegervEXT (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetLocalConstantFloatvEXT (GLuint, GLenum, GLfloat *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBEGINVERTEXSHADEREXTPROC) (void);
+typedef void (APIENTRYP PFNGLENDVERTEXSHADEREXTPROC) (void);
+typedef void (APIENTRYP PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
+typedef GLuint (APIENTRYP PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
+typedef void (APIENTRYP PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
+typedef void (APIENTRYP PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
+typedef void (APIENTRYP PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
+typedef void (APIENTRYP PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
+typedef void (APIENTRYP PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
+typedef void (APIENTRYP PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
+typedef void (APIENTRYP PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
+typedef GLuint (APIENTRYP PFNGLGENSYMBOLSEXTPROC) (GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
+typedef void (APIENTRYP PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
+typedef void (APIENTRYP PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
+typedef void (APIENTRYP PFNGLVARIANTBVEXTPROC) (GLuint id, const GLbyte *addr);
+typedef void (APIENTRYP PFNGLVARIANTSVEXTPROC) (GLuint id, const GLshort *addr);
+typedef void (APIENTRYP PFNGLVARIANTIVEXTPROC) (GLuint id, const GLint *addr);
+typedef void (APIENTRYP PFNGLVARIANTFVEXTPROC) (GLuint id, const GLfloat *addr);
+typedef void (APIENTRYP PFNGLVARIANTDVEXTPROC) (GLuint id, const GLdouble *addr);
+typedef void (APIENTRYP PFNGLVARIANTUBVEXTPROC) (GLuint id, const GLubyte *addr);
+typedef void (APIENTRYP PFNGLVARIANTUSVEXTPROC) (GLuint id, const GLushort *addr);
+typedef void (APIENTRYP PFNGLVARIANTUIVEXTPROC) (GLuint id, const GLuint *addr);
+typedef void (APIENTRYP PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
+typedef void (APIENTRYP PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
+typedef GLuint (APIENTRYP PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
+typedef GLuint (APIENTRYP PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
+typedef GLuint (APIENTRYP PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
+typedef GLuint (APIENTRYP PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
+typedef GLuint (APIENTRYP PFNGLBINDPARAMETEREXTPROC) (GLenum value);
+typedef GLboolean (APIENTRYP PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
+typedef void (APIENTRYP PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
+typedef void (APIENTRYP PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
+typedef void (APIENTRYP PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
+typedef void (APIENTRYP PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid* *data);
+typedef void (APIENTRYP PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
+typedef void (APIENTRYP PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
+typedef void (APIENTRYP PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
+typedef void (APIENTRYP PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
+typedef void (APIENTRYP PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
+typedef void (APIENTRYP PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
+#endif
+
+#ifndef GL_ATI_vertex_streams
+#define GL_ATI_vertex_streams 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glVertexStream1sATI (GLenum, GLshort);
+GLAPI void APIENTRY glVertexStream1svATI (GLenum, const GLshort *);
+GLAPI void APIENTRY glVertexStream1iATI (GLenum, GLint);
+GLAPI void APIENTRY glVertexStream1ivATI (GLenum, const GLint *);
+GLAPI void APIENTRY glVertexStream1fATI (GLenum, GLfloat);
+GLAPI void APIENTRY glVertexStream1fvATI (GLenum, const GLfloat *);
+GLAPI void APIENTRY glVertexStream1dATI (GLenum, GLdouble);
+GLAPI void APIENTRY glVertexStream1dvATI (GLenum, const GLdouble *);
+GLAPI void APIENTRY glVertexStream2sATI (GLenum, GLshort, GLshort);
+GLAPI void APIENTRY glVertexStream2svATI (GLenum, const GLshort *);
+GLAPI void APIENTRY glVertexStream2iATI (GLenum, GLint, GLint);
+GLAPI void APIENTRY glVertexStream2ivATI (GLenum, const GLint *);
+GLAPI void APIENTRY glVertexStream2fATI (GLenum, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexStream2fvATI (GLenum, const GLfloat *);
+GLAPI void APIENTRY glVertexStream2dATI (GLenum, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexStream2dvATI (GLenum, const GLdouble *);
+GLAPI void APIENTRY glVertexStream3sATI (GLenum, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glVertexStream3svATI (GLenum, const GLshort *);
+GLAPI void APIENTRY glVertexStream3iATI (GLenum, GLint, GLint, GLint);
+GLAPI void APIENTRY glVertexStream3ivATI (GLenum, const GLint *);
+GLAPI void APIENTRY glVertexStream3fATI (GLenum, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexStream3fvATI (GLenum, const GLfloat *);
+GLAPI void APIENTRY glVertexStream3dATI (GLenum, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexStream3dvATI (GLenum, const GLdouble *);
+GLAPI void APIENTRY glVertexStream4sATI (GLenum, GLshort, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glVertexStream4svATI (GLenum, const GLshort *);
+GLAPI void APIENTRY glVertexStream4iATI (GLenum, GLint, GLint, GLint, GLint);
+GLAPI void APIENTRY glVertexStream4ivATI (GLenum, const GLint *);
+GLAPI void APIENTRY glVertexStream4fATI (GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glVertexStream4fvATI (GLenum, const GLfloat *);
+GLAPI void APIENTRY glVertexStream4dATI (GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glVertexStream4dvATI (GLenum, const GLdouble *);
+GLAPI void APIENTRY glNormalStream3bATI (GLenum, GLbyte, GLbyte, GLbyte);
+GLAPI void APIENTRY glNormalStream3bvATI (GLenum, const GLbyte *);
+GLAPI void APIENTRY glNormalStream3sATI (GLenum, GLshort, GLshort, GLshort);
+GLAPI void APIENTRY glNormalStream3svATI (GLenum, const GLshort *);
+GLAPI void APIENTRY glNormalStream3iATI (GLenum, GLint, GLint, GLint);
+GLAPI void APIENTRY glNormalStream3ivATI (GLenum, const GLint *);
+GLAPI void APIENTRY glNormalStream3fATI (GLenum, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glNormalStream3fvATI (GLenum, const GLfloat *);
+GLAPI void APIENTRY glNormalStream3dATI (GLenum, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glNormalStream3dvATI (GLenum, const GLdouble *);
+GLAPI void APIENTRY glClientActiveVertexStreamATI (GLenum);
+GLAPI void APIENTRY glVertexBlendEnviATI (GLenum, GLint);
+GLAPI void APIENTRY glVertexBlendEnvfATI (GLenum, GLfloat);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort nx, GLshort ny, GLshort nz);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint nx, GLint ny, GLint nz);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz);
+typedef void (APIENTRYP PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
+typedef void (APIENTRYP PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
+typedef void (APIENTRYP PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
+#endif
+
+#ifndef GL_ATI_element_array
+#define GL_ATI_element_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glElementPointerATI (GLenum, const GLvoid *);
+GLAPI void APIENTRY glDrawElementArrayATI (GLenum, GLsizei);
+GLAPI void APIENTRY glDrawRangeElementArrayATI (GLenum, GLuint, GLuint, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLELEMENTPOINTERATIPROC) (GLenum type, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
+typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
+#endif
+
+#ifndef GL_SUN_mesh_array
+#define GL_SUN_mesh_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDrawMeshArraysSUN (GLenum, GLint, GLsizei, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDRAWMESHARRAYSSUNPROC) (GLenum mode, GLint first, GLsizei count, GLsizei width);
+#endif
+
+#ifndef GL_SUN_slice_accum
+#define GL_SUN_slice_accum 1
+#endif
+
+#ifndef GL_NV_multisample_filter_hint
+#define GL_NV_multisample_filter_hint 1
+#endif
+
+#ifndef GL_NV_depth_clamp
+#define GL_NV_depth_clamp 1
+#endif
+
+#ifndef GL_NV_occlusion_query
+#define GL_NV_occlusion_query 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGenOcclusionQueriesNV (GLsizei, GLuint *);
+GLAPI void APIENTRY glDeleteOcclusionQueriesNV (GLsizei, const GLuint *);
+GLAPI GLboolean APIENTRY glIsOcclusionQueryNV (GLuint);
+GLAPI void APIENTRY glBeginOcclusionQueryNV (GLuint);
+GLAPI void APIENTRY glEndOcclusionQueryNV (void);
+GLAPI void APIENTRY glGetOcclusionQueryivNV (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetOcclusionQueryuivNV (GLuint, GLenum, GLuint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint *ids);
+typedef void (APIENTRYP PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint *ids);
+typedef GLboolean (APIENTRYP PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
+typedef void (APIENTRYP PFNGLENDOCCLUSIONQUERYNVPROC) (void);
+typedef void (APIENTRYP PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint *params);
+#endif
+
+#ifndef GL_NV_point_sprite
+#define GL_NV_point_sprite 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPointParameteriNV (GLenum, GLint);
+GLAPI void APIENTRY glPointParameterivNV (GLenum, const GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint *params);
+#endif
+
+#ifndef GL_NV_texture_shader3
+#define GL_NV_texture_shader3 1
+#endif
+
+#ifndef GL_NV_vertex_program1_1
+#define GL_NV_vertex_program1_1 1
+#endif
+
+#ifndef GL_EXT_shadow_funcs
+#define GL_EXT_shadow_funcs 1
+#endif
+
+#ifndef GL_EXT_stencil_two_side
+#define GL_EXT_stencil_two_side 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glActiveStencilFaceEXT (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
+#endif
+
+#ifndef GL_ATI_text_fragment_shader
+#define GL_ATI_text_fragment_shader 1
+#endif
+
+#ifndef GL_APPLE_client_storage
+#define GL_APPLE_client_storage 1
+#endif
+
+#ifndef GL_APPLE_element_array
+#define GL_APPLE_element_array 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glElementPointerAPPLE (GLenum, const GLvoid *);
+GLAPI void APIENTRY glDrawElementArrayAPPLE (GLenum, GLint, GLsizei);
+GLAPI void APIENTRY glDrawRangeElementArrayAPPLE (GLenum, GLuint, GLuint, GLint, GLsizei);
+GLAPI void APIENTRY glMultiDrawElementArrayAPPLE (GLenum, const GLint *, const GLsizei *, GLsizei);
+GLAPI void APIENTRY glMultiDrawRangeElementArrayAPPLE (GLenum, GLuint, GLuint, const GLint *, const GLsizei *, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
+typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
+typedef void (APIENTRYP PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
+#endif
+
+#ifndef GL_APPLE_fence
+#define GL_APPLE_fence 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glGenFencesAPPLE (GLsizei, GLuint *);
+GLAPI void APIENTRY glDeleteFencesAPPLE (GLsizei, const GLuint *);
+GLAPI void APIENTRY glSetFenceAPPLE (GLuint);
+GLAPI GLboolean APIENTRY glIsFenceAPPLE (GLuint);
+GLAPI GLboolean APIENTRY glTestFenceAPPLE (GLuint);
+GLAPI void APIENTRY glFinishFenceAPPLE (GLuint);
+GLAPI GLboolean APIENTRY glTestObjectAPPLE (GLenum, GLuint);
+GLAPI void APIENTRY glFinishObjectAPPLE (GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint *fences);
+typedef void (APIENTRYP PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint *fences);
+typedef void (APIENTRYP PFNGLSETFENCEAPPLEPROC) (GLuint fence);
+typedef GLboolean (APIENTRYP PFNGLISFENCEAPPLEPROC) (GLuint fence);
+typedef GLboolean (APIENTRYP PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
+typedef void (APIENTRYP PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
+typedef GLboolean (APIENTRYP PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
+typedef void (APIENTRYP PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
+#endif
+
+#ifndef GL_APPLE_vertex_array_object
+#define GL_APPLE_vertex_array_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBindVertexArrayAPPLE (GLuint);
+GLAPI void APIENTRY glDeleteVertexArraysAPPLE (GLsizei, const GLuint *);
+GLAPI void APIENTRY glGenVertexArraysAPPLE (GLsizei, const GLuint *);
+GLAPI GLboolean APIENTRY glIsVertexArrayAPPLE (GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
+typedef void (APIENTRYP PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint *arrays);
+typedef void (APIENTRYP PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint *arrays);
+typedef GLboolean (APIENTRYP PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
+#endif
+
+#ifndef GL_APPLE_vertex_array_range
+#define GL_APPLE_vertex_array_range 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glVertexArrayRangeAPPLE (GLsizei, GLvoid *);
+GLAPI void APIENTRY glFlushVertexArrayRangeAPPLE (GLsizei, GLvoid *);
+GLAPI void APIENTRY glVertexArrayParameteriAPPLE (GLenum, GLint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
+typedef void (APIENTRYP PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
+#endif
+
+#ifndef GL_APPLE_ycbcr_422
+#define GL_APPLE_ycbcr_422 1
+#endif
+
+#ifndef GL_S3_s3tc
+#define GL_S3_s3tc 1
+#endif
+
+#ifndef GL_ATI_draw_buffers
+#define GL_ATI_draw_buffers 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDrawBuffersATI (GLsizei, const GLenum *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum *bufs);
+#endif
+
+#ifndef GL_ATI_texture_env_combine3
+#define GL_ATI_texture_env_combine3 1
+#endif
+
+#ifndef GL_ATI_texture_float
+#define GL_ATI_texture_float 1
+#endif
+
+#ifndef GL_NV_float_buffer
+#define GL_NV_float_buffer 1
+#endif
+
+#ifndef GL_NV_fragment_program
+#define GL_NV_fragment_program 1
+/* Some NV_fragment_program entry points are shared with ARB_vertex_program. */
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glProgramNamedParameter4fNV (GLuint, GLsizei, const GLubyte *, GLfloat, GLfloat, GLfloat, GLfloat);
+GLAPI void APIENTRY glProgramNamedParameter4dNV (GLuint, GLsizei, const GLubyte *, GLdouble, GLdouble, GLdouble, GLdouble);
+GLAPI void APIENTRY glProgramNamedParameter4fvNV (GLuint, GLsizei, const GLubyte *, const GLfloat *);
+GLAPI void APIENTRY glProgramNamedParameter4dvNV (GLuint, GLsizei, const GLubyte *, const GLdouble *);
+GLAPI void APIENTRY glGetProgramNamedParameterfvNV (GLuint, GLsizei, const GLubyte *, GLfloat *);
+GLAPI void APIENTRY glGetProgramNamedParameterdvNV (GLuint, GLsizei, const GLubyte *, GLdouble *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
+typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v);
+typedef void (APIENTRYP PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v);
+typedef void (APIENTRYP PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte *name, GLdouble *params);
+#endif
+
+#ifndef GL_NV_half_float
+#define GL_NV_half_float 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glVertex2hNV (GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glVertex2hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glVertex3hNV (GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glVertex3hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glVertex4hNV (GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glVertex4hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glNormal3hNV (GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glNormal3hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glColor3hNV (GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glColor3hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glColor4hNV (GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glColor4hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glTexCoord1hNV (GLhalfNV);
+GLAPI void APIENTRY glTexCoord1hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glTexCoord2hNV (GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glTexCoord2hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glTexCoord3hNV (GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glTexCoord3hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glTexCoord4hNV (GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glTexCoord4hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glMultiTexCoord1hNV (GLenum, GLhalfNV);
+GLAPI void APIENTRY glMultiTexCoord1hvNV (GLenum, const GLhalfNV *);
+GLAPI void APIENTRY glMultiTexCoord2hNV (GLenum, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glMultiTexCoord2hvNV (GLenum, const GLhalfNV *);
+GLAPI void APIENTRY glMultiTexCoord3hNV (GLenum, GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glMultiTexCoord3hvNV (GLenum, const GLhalfNV *);
+GLAPI void APIENTRY glMultiTexCoord4hNV (GLenum, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glMultiTexCoord4hvNV (GLenum, const GLhalfNV *);
+GLAPI void APIENTRY glFogCoordhNV (GLhalfNV);
+GLAPI void APIENTRY glFogCoordhvNV (const GLhalfNV *);
+GLAPI void APIENTRY glSecondaryColor3hNV (GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glSecondaryColor3hvNV (const GLhalfNV *);
+GLAPI void APIENTRY glVertexWeighthNV (GLhalfNV);
+GLAPI void APIENTRY glVertexWeighthvNV (const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttrib1hNV (GLuint, GLhalfNV);
+GLAPI void APIENTRY glVertexAttrib1hvNV (GLuint, const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttrib2hNV (GLuint, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glVertexAttrib2hvNV (GLuint, const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttrib3hNV (GLuint, GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glVertexAttrib3hvNV (GLuint, const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttrib4hNV (GLuint, GLhalfNV, GLhalfNV, GLhalfNV, GLhalfNV);
+GLAPI void APIENTRY glVertexAttrib4hvNV (GLuint, const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttribs1hvNV (GLuint, GLsizei, const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttribs2hvNV (GLuint, GLsizei, const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttribs3hvNV (GLuint, GLsizei, const GLhalfNV *);
+GLAPI void APIENTRY glVertexAttribs4hvNV (GLuint, GLsizei, const GLhalfNV *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLVERTEX2HNVPROC) (GLhalfNV x, GLhalfNV y);
+typedef void (APIENTRYP PFNGLVERTEX2HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEX3HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z);
+typedef void (APIENTRYP PFNGLVERTEX3HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEX4HNVPROC) (GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
+typedef void (APIENTRYP PFNGLVERTEX4HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLNORMAL3HNVPROC) (GLhalfNV nx, GLhalfNV ny, GLhalfNV nz);
+typedef void (APIENTRYP PFNGLNORMAL3HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
+typedef void (APIENTRYP PFNGLCOLOR3HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLCOLOR4HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha);
+typedef void (APIENTRYP PFNGLCOLOR4HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLTEXCOORD1HNVPROC) (GLhalfNV s);
+typedef void (APIENTRYP PFNGLTEXCOORD1HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLTEXCOORD2HNVPROC) (GLhalfNV s, GLhalfNV t);
+typedef void (APIENTRYP PFNGLTEXCOORD2HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLTEXCOORD3HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r);
+typedef void (APIENTRYP PFNGLTEXCOORD3HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLTEXCOORD4HNVPROC) (GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
+typedef void (APIENTRYP PFNGLTEXCOORD4HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalfNV s);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q);
+typedef void (APIENTRYP PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLFOGCOORDHNVPROC) (GLhalfNV fog);
+typedef void (APIENTRYP PFNGLFOGCOORDHVNVPROC) (const GLhalfNV *fog);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3HNVPROC) (GLhalfNV red, GLhalfNV green, GLhalfNV blue);
+typedef void (APIENTRYP PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXWEIGHTHNVPROC) (GLhalfNV weight);
+typedef void (APIENTRYP PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalfNV *weight);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalfNV x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w);
+typedef void (APIENTRYP PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalfNV *v);
+#endif
+
+#ifndef GL_NV_pixel_data_range
+#define GL_NV_pixel_data_range 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPixelDataRangeNV (GLenum, GLsizei, GLvoid *);
+GLAPI void APIENTRY glFlushPixelDataRangeNV (GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, GLvoid *pointer);
+typedef void (APIENTRYP PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
+#endif
+
+#ifndef GL_NV_primitive_restart
+#define GL_NV_primitive_restart 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glPrimitiveRestartNV (void);
+GLAPI void APIENTRY glPrimitiveRestartIndexNV (GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLPRIMITIVERESTARTNVPROC) (void);
+typedef void (APIENTRYP PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
+#endif
+
+#ifndef GL_NV_texture_expand_normal
+#define GL_NV_texture_expand_normal 1
+#endif
+
+#ifndef GL_NV_vertex_program2
+#define GL_NV_vertex_program2 1
+#endif
+
+#ifndef GL_ATI_map_object_buffer
+#define GL_ATI_map_object_buffer 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI GLvoid* APIENTRY glMapObjectBufferATI (GLuint);
+GLAPI void APIENTRY glUnmapObjectBufferATI (GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef GLvoid* (APIENTRYP PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
+typedef void (APIENTRYP PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
+#endif
+
+#ifndef GL_ATI_separate_stencil
+#define GL_ATI_separate_stencil 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glStencilOpSeparateATI (GLenum, GLenum, GLenum, GLenum);
+GLAPI void APIENTRY glStencilFuncSeparateATI (GLenum, GLenum, GLint, GLuint);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
+typedef void (APIENTRYP PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
+#endif
+
+#ifndef GL_ATI_vertex_attrib_array_object
+#define GL_ATI_vertex_attrib_array_object 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glVertexAttribArrayObjectATI (GLuint, GLint, GLenum, GLboolean, GLsizei, GLuint, GLuint);
+GLAPI void APIENTRY glGetVertexAttribArrayObjectfvATI (GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetVertexAttribArrayObjectivATI (GLuint, GLenum, GLint *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint *params);
+#endif
+
+#ifndef GL_EXT_depth_bounds_test
+#define GL_EXT_depth_bounds_test 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDepthBoundsEXT (GLclampd, GLclampd);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
+#endif
+
+#ifndef GL_EXT_texture_mirror_clamp
+#define GL_EXT_texture_mirror_clamp 1
+#endif
+
+#ifndef GL_EXT_blend_equation_separate
+#define GL_EXT_blend_equation_separate 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendEquationSeparateEXT (GLenum, GLenum);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
+#endif
+
+#ifndef GL_MESA_pack_invert
+#define GL_MESA_pack_invert 1
+#endif
+
+#ifndef GL_MESA_ycbcr_texture
+#define GL_MESA_ycbcr_texture 1
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+#endif /* NO_SDL_GLEXT */

Added: trunk/msvc-libs/include/SDL/SDL_quit.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_quit.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_quit.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,52 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_quit.h,v 1.5 2004/01/04 16:49:07 slouken Exp $&quot;;
+#endif
+
+/* Include file for SDL quit event handling */
+
+#ifndef _SDL_quit_h
+#define _SDL_quit_h
+
+/* 
+  An SDL_QUITEVENT is generated when the user tries to close the application
+  window.  If it is ignored or filtered out, the window will remain open.
+  If it is not ignored or filtered, it is queued normally and the window
+  is allowed to close.  When the window is closed, screen updates will 
+  complete, but have no effect.
+
+  SDL_Init() installs signal handlers for SIGINT (keyboard interrupt)
+  and SIGTERM (system termination request), if handlers do not already
+  exist, that generate SDL_QUITEVENT events as well.  There is no way
+  to determine the cause of an SDL_QUITEVENT, but setting a signal
+  handler in your application will override the default generation of
+  quit events for that signal.
+*/
+
+/* There are no functions directly affecting the quit event */
+#define SDL_QuitRequested() \
+        (SDL_PumpEvents(), SDL_PeepEvents(NULL,0,SDL_PEEKEVENT,SDL_QUITMASK))
+
+#endif /* _SDL_quit_h */

Added: trunk/msvc-libs/include/SDL/SDL_rwops.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_rwops.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_rwops.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,114 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_rwops.h,v 1.8 2004/08/20 18:57:01 slouken Exp $&quot;;
+#endif
+
+/* This file provides a general interface for SDL to read and write
+   data sources.  It can easily be extended to files, memory, etc.
+*/
+
+#ifndef _SDL_RWops_h
+#define _SDL_RWops_h
+
+#include &lt;stdio.h&gt;
+
+#include &quot;SDL_types.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This is the read/write operation structure -- very basic */
+
+typedef struct SDL_RWops {
+	/* Seek to 'offset' relative to whence, one of stdio's whence values:
+		SEEK_SET, SEEK_CUR, SEEK_END
+	   Returns the final offset in the data source.
+	 */
+	int (SDLCALL *seek)(struct SDL_RWops *context, int offset, int whence);
+
+	/* Read up to 'num' objects each of size 'objsize' from the data
+	   source to the area pointed at by 'ptr'.
+	   Returns the number of objects read, or -1 if the read failed.
+	 */
+	int (SDLCALL *read)(struct SDL_RWops *context, void *ptr, int size, int maxnum);
+
+	/* Write exactly 'num' objects each of size 'objsize' from the area
+	   pointed at by 'ptr' to data source.
+	   Returns 'num', or -1 if the write failed.
+	 */
+	int (SDLCALL *write)(struct SDL_RWops *context, const void *ptr, int size, int num);
+
+	/* Close and free an allocated SDL_FSops structure */
+	int (SDLCALL *close)(struct SDL_RWops *context);
+
+	Uint32 type;
+	union {
+	    struct {
+		int autoclose;
+	 	FILE *fp;
+	    } stdio;
+	    struct {
+		Uint8 *base;
+	 	Uint8 *here;
+		Uint8 *stop;
+	    } mem;
+	    struct {
+		void *data1;
+	    } unknown;
+	} hidden;
+
+} SDL_RWops;
+
+
+/* Functions to create SDL_RWops structures from various data sources */
+
+extern DECLSPEC SDL_RWops * SDLCALL SDL_RWFromFile(const char *file, const char *mode);
+
+extern DECLSPEC SDL_RWops * SDLCALL SDL_RWFromFP(FILE *fp, int autoclose);
+
+extern DECLSPEC SDL_RWops * SDLCALL SDL_RWFromMem(void *mem, int size);
+extern DECLSPEC SDL_RWops * SDLCALL SDL_RWFromConstMem(const void *mem, int size);
+
+extern DECLSPEC SDL_RWops * SDLCALL SDL_AllocRW(void);
+extern DECLSPEC void SDLCALL SDL_FreeRW(SDL_RWops *area);
+
+/* Macros to easily read and write from an SDL_RWops structure */
+#define SDL_RWseek(ctx, offset, whence)	(ctx)-&gt;seek(ctx, offset, whence)
+#define SDL_RWtell(ctx)			(ctx)-&gt;seek(ctx, 0, SEEK_CUR)
+#define SDL_RWread(ctx, ptr, size, n)	(ctx)-&gt;read(ctx, ptr, size, n)
+#define SDL_RWwrite(ctx, ptr, size, n)	(ctx)-&gt;write(ctx, ptr, size, n)
+#define SDL_RWclose(ctx)		(ctx)-&gt;close(ctx)
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_RWops_h */

Added: trunk/msvc-libs/include/SDL/SDL_syswm.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_syswm.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_syswm.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,206 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_syswm.h,v 1.15 2004/11/30 15:21:29 slouken Exp $&quot;;
+#endif
+
+/* Include file for SDL custom system window manager hooks */
+
+#ifndef _SDL_syswm_h
+#define _SDL_syswm_h
+
+#include &quot;SDL_version.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Your application has access to a special type of event 'SDL_SYSWMEVENT',
+   which contains window-manager specific information and arrives whenever
+   an unhandled window event occurs.  This event is ignored by default, but
+   you can enable it with SDL_EventState()
+*/
+#ifdef SDL_PROTOTYPES_ONLY
+struct SDL_SysWMinfo;
+typedef struct SDL_SysWMinfo SDL_SysWMinfo;
+#else
+
+/* This is the structure for custom window manager events */
+#if (defined(unix) || defined(__unix__) || defined(_AIX) || defined(__OpenBSD__)) &amp;&amp; \
+    (!defined(DISABLE_X11) &amp;&amp; !defined(__CYGWIN32__) &amp;&amp; !defined(ENABLE_NANOX) &amp;&amp; \
+     !defined(__QNXNTO__))
+ /* AIX is unix, of course, but the native compiler CSet doesn't define unix */
+#include &lt;X11/Xlib.h&gt;
+#include &lt;X11/Xatom.h&gt;
+
+/* These are the various supported subsystems under UNIX */
+typedef enum {
+	SDL_SYSWM_X11
+} SDL_SYSWM_TYPE;
+
+/* The UNIX custom event structure */
+struct SDL_SysWMmsg {
+	SDL_version version;
+	SDL_SYSWM_TYPE subsystem;
+	union {
+	    XEvent xevent;
+	} event;
+};
+
+/* The UNIX custom window manager information structure.
+   When this structure is returned, it holds information about which
+   low level system it is using, and will be one of SDL_SYSWM_TYPE.
+ */
+typedef struct SDL_SysWMinfo {
+	SDL_version version;
+	SDL_SYSWM_TYPE subsystem;
+	union {
+	    struct {
+	    	Display *display;	/* The X11 display */
+	    	Window window;		/* The X11 display window */
+		/* These locking functions should be called around
+                   any X11 functions using the display variable.
+                   They lock the event thread, so should not be
+		   called around event functions or from event filters.
+		 */
+		void (*lock_func)(void);
+		void (*unlock_func)(void);
+
+		/* Introduced in SDL 1.0.2 */
+	    	Window fswindow;	/* The X11 fullscreen window */
+	    	Window wmwindow;	/* The X11 managed input window */
+	    } x11;
+	} info;
+} SDL_SysWMinfo;
+
+#elif defined(ENABLE_NANOX)
+#include &lt;microwin/nano-X.h&gt;
+
+/* The generic custom event structure */
+struct SDL_SysWMmsg {
+	SDL_version version;
+	int data;
+};
+
+/* The windows custom window manager information structure */
+typedef struct SDL_SysWMinfo {
+	SDL_version version ;
+	GR_WINDOW_ID window ;	/* The display window */
+} SDL_SysWMinfo;
+
+#elif defined(WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include &lt;windows.h&gt;
+
+/* The windows custom event structure */
+struct SDL_SysWMmsg {
+	SDL_version version;
+	HWND hwnd;			/* The window for the message */
+	UINT msg;			/* The type of message */
+	WPARAM wParam;			/* WORD message parameter */
+	LPARAM lParam;			/* LONG message parameter */
+};
+
+/* The windows custom window manager information structure */
+typedef struct SDL_SysWMinfo {
+	SDL_version version;
+	HWND window;			/* The Win32 display window */
+	HGLRC hglrc;			/* The OpenGL context, if any */
+} SDL_SysWMinfo;
+
+#elif defined(__riscos__)
+
+/* RISC OS custom event structure */
+struct SDL_SysWMmsg {
+	SDL_version version;
+	int eventCode;		/* The window for the message */
+	int pollBlock[64];
+};
+
+/* The RISCOS custom window manager information structure */
+typedef struct SDL_SysWMinfo {
+	SDL_version version;
+	int wimpVersion;    /* Wimp version running under */
+	int taskHandle;     /* The RISCOS task handle */
+	int window;			/* The RISCOS display window */
+} SDL_SysWMinfo;
+
+#elif defined(__QNXNTO__)
+#include &lt;sys/neutrino.h&gt;
+#include &lt;Ph.h&gt;
+
+/* The QNX custom event structure */
+struct SDL_SysWMmsg {
+	SDL_version version;
+	int data;
+};
+
+/* The QNX custom window manager information structure */
+typedef struct SDL_SysWMinfo {
+	SDL_version version;
+	int data;
+} SDL_SysWMinfo;
+
+#else
+
+/* The generic custom event structure */
+struct SDL_SysWMmsg {
+	SDL_version version;
+	int data;
+};
+
+/* The generic custom window manager information structure */
+typedef struct SDL_SysWMinfo {
+	SDL_version version;
+	int data;
+} SDL_SysWMinfo;
+
+#endif /* OS type */
+
+#endif /* SDL_PROTOTYPES_ONLY */
+
+/* Function prototypes */
+/*
+ * This function gives you custom hooks into the window manager information.
+ * It fills the structure pointed to by 'info' with custom information and
+ * returns 1 if the function is implemented.  If it's not implemented, or
+ * the version member of the 'info' structure is invalid, it returns 0. 
+ *
+ * You typically use this function like this:
+ * SDL_SysWMInfo info;
+ * SDL_VERSION(&amp;info.version);
+ * if ( SDL_GetWMInfo(&amp;info) ) { ... }
+ */
+extern DECLSPEC int SDLCALL SDL_GetWMInfo(SDL_SysWMinfo *info);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_syswm_h */

Added: trunk/msvc-libs/include/SDL/SDL_thread.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_thread.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_thread.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,79 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_thread.h,v 1.7 2004/08/20 18:57:01 slouken Exp $&quot;;
+#endif
+
+#ifndef _SDL_thread_h
+#define _SDL_thread_h
+
+/* Header for the SDL thread management routines 
+
+	These are independent of the other SDL routines.
+*/
+
+#include &quot;SDL_main.h&quot;
+#include &quot;SDL_types.h&quot;
+
+/* Thread synchronization primitives */
+#include &quot;SDL_mutex.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* The SDL thread structure, defined in SDL_thread.c */
+struct SDL_Thread;
+typedef struct SDL_Thread SDL_Thread;
+
+/* Create a thread */
+extern DECLSPEC SDL_Thread * SDLCALL SDL_CreateThread(int (SDLCALL *fn)(void *), void *data);
+
+/* Get the 32-bit thread identifier for the current thread */
+extern DECLSPEC Uint32 SDLCALL SDL_ThreadID(void);
+
+/* Get the 32-bit thread identifier for the specified thread,
+   equivalent to SDL_ThreadID() if the specified thread is NULL.
+ */
+extern DECLSPEC Uint32 SDLCALL SDL_GetThreadID(SDL_Thread *thread);
+
+/* Wait for a thread to finish.
+   The return code for the thread function is placed in the area
+   pointed to by 'status', if 'status' is not NULL.
+ */
+extern DECLSPEC void SDLCALL SDL_WaitThread(SDL_Thread *thread, int *status);
+
+/* Forcefully kill a thread without worrying about its state */
+extern DECLSPEC void SDLCALL SDL_KillThread(SDL_Thread *thread);
+
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_thread_h */

Added: trunk/msvc-libs/include/SDL/SDL_timer.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_timer.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_timer.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,118 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_timer.h,v 1.6 2004/01/04 16:49:08 slouken Exp $&quot;;
+#endif
+
+#ifndef _SDL_timer_h
+#define _SDL_timer_h
+
+/* Header for the SDL time management routines */
+
+#include &quot;SDL_main.h&quot;
+#include &quot;SDL_types.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This is the OS scheduler timeslice, in milliseconds */
+#define SDL_TIMESLICE		10
+
+/* This is the maximum resolution of the SDL timer on all platforms */
+#define TIMER_RESOLUTION	10	/* Experimentally determined */
+
+/* Get the number of milliseconds since the SDL library initialization.
+ * Note that this value wraps if the program runs for more than ~49 days.
+ */ 
+extern DECLSPEC Uint32 SDLCALL SDL_GetTicks(void);
+
+/* Wait a specified number of milliseconds before returning */
+extern DECLSPEC void SDLCALL SDL_Delay(Uint32 ms);
+
+/* Function prototype for the timer callback function */
+typedef Uint32 (SDLCALL *SDL_TimerCallback)(Uint32 interval);
+
+/* Set a callback to run after the specified number of milliseconds has
+ * elapsed. The callback function is passed the current timer interval
+ * and returns the next timer interval.  If the returned value is the 
+ * same as the one passed in, the periodic alarm continues, otherwise a
+ * new alarm is scheduled.  If the callback returns 0, the periodic alarm
+ * is cancelled.
+ *
+ * To cancel a currently running timer, call SDL_SetTimer(0, NULL);
+ *
+ * The timer callback function may run in a different thread than your
+ * main code, and so shouldn't call any functions from within itself.
+ *
+ * The maximum resolution of this timer is 10 ms, which means that if
+ * you request a 16 ms timer, your callback will run approximately 20 ms
+ * later on an unloaded system.  If you wanted to set a flag signaling
+ * a frame update at 30 frames per second (every 33 ms), you might set a 
+ * timer for 30 ms:
+ *   SDL_SetTimer((33/10)*10, flag_update);
+ *
+ * If you use this function, you need to pass SDL_INIT_TIMER to SDL_Init().
+ *
+ * Under UNIX, you should not use raise or use SIGALRM and this function
+ * in the same program, as it is implemented using setitimer().  You also
+ * should not use this function in multi-threaded applications as signals
+ * to multi-threaded apps have undefined behavior in some implementations.
+ */
+extern DECLSPEC int SDLCALL SDL_SetTimer(Uint32 interval, SDL_TimerCallback callback);
+
+/* New timer API, supports multiple timers
+ * Written by Stephane Peter &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">megastep at lokigames.com</A>&gt;
+ */
+
+/* Function prototype for the new timer callback function.
+ * The callback function is passed the current timer interval and returns
+ * the next timer interval.  If the returned value is the same as the one
+ * passed in, the periodic alarm continues, otherwise a new alarm is
+ * scheduled.  If the callback returns 0, the periodic alarm is cancelled.
+ */
+typedef Uint32 (SDLCALL *SDL_NewTimerCallback)(Uint32 interval, void *param);
+
+/* Definition of the timer ID type */
+typedef struct _SDL_TimerID *SDL_TimerID;
+
+/* Add a new timer to the pool of timers already running.
+   Returns a timer ID, or NULL when an error occurs.
+ */
+extern DECLSPEC SDL_TimerID SDLCALL SDL_AddTimer(Uint32 interval, SDL_NewTimerCallback callback, void *param);
+
+/* Remove one of the multiple timers knowing its ID.
+ * Returns a boolean value indicating success.
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_RemoveTimer(SDL_TimerID t);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_timer_h */

Added: trunk/msvc-libs/include/SDL/SDL_types.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_types.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_types.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,120 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_types.h,v 1.13 2004/07/21 04:53:26 slouken Exp $&quot;;
+#endif
+
+/* General data types used by the SDL library */
+
+#ifndef _SDL_types_h
+#define _SDL_types_h
+
+/* The number of elements in a table */
+#define SDL_TABLESIZE(table)	(sizeof(table)/sizeof(table[0]))
+
+/* Basic data types */
+typedef enum {
+	SDL_FALSE = 0,
+	SDL_TRUE  = 1
+} SDL_bool;
+
+#ifdef H_MMBASIC /* mmbasic.h (Tru64 MME) */
+/* Some of the basic types are already defined in mmbasic.h */
+typedef signed char	Sint8;
+typedef signed short	Sint16;
+typedef signed int	Sint32;
+#else
+typedef unsigned char	Uint8;
+typedef signed char	Sint8;
+typedef unsigned short	Uint16;
+typedef signed short	Sint16;
+typedef unsigned int	Uint32;
+typedef signed int	Sint32;
+#endif
+
+/* Figure out how to support 64-bit datatypes */
+#if !defined(__STRICT_ANSI__)
+#ifdef __osf__ /* Tru64 */
+#define SDL_HAS_64BIT_TYPE	long
+#elif defined(__GNUC__) || defined(__MWERKS__) || defined(__SUNPRO_C) || defined(__DECC)
+#define SDL_HAS_64BIT_TYPE	long long
+#elif defined(_MSC_VER) /* VC++ */
+#define SDL_HAS_64BIT_TYPE	__int64
+#endif
+#endif /* !__STRICT_ANSI__ */
+
+/* The 64-bit type isn't available on EPOC/Symbian OS */
+#ifdef __SYMBIAN32__
+#undef SDL_HAS_64BIT_TYPE
+#endif
+
+/* The 64-bit datatype isn't supported on all platforms */
+#ifdef SDL_HAS_64BIT_TYPE
+#ifndef H_MMBASIC
+typedef unsigned SDL_HAS_64BIT_TYPE Uint64;
+#endif
+typedef SDL_HAS_64BIT_TYPE Sint64;
+#else
+/* This is really just a hack to prevent the compiler from complaining */
+typedef struct {
+	Uint32 hi;
+	Uint32 lo;
+} Uint64, Sint64;
+#endif
+
+/* Make sure the types really have the right sizes */
+#define SDL_COMPILE_TIME_ASSERT(name, x)               \
+       typedef int SDL_dummy_ ## name[(x) * 2 - 1]
+
+SDL_COMPILE_TIME_ASSERT(uint8, sizeof(Uint8) == 1);
+SDL_COMPILE_TIME_ASSERT(sint8, sizeof(Sint8) == 1);
+SDL_COMPILE_TIME_ASSERT(uint16, sizeof(Uint16) == 2);
+SDL_COMPILE_TIME_ASSERT(sint16, sizeof(Sint16) == 2);
+SDL_COMPILE_TIME_ASSERT(uint32, sizeof(Uint32) == 4);
+SDL_COMPILE_TIME_ASSERT(sint32, sizeof(Sint32) == 4);
+SDL_COMPILE_TIME_ASSERT(uint64, sizeof(Uint64) == 8);
+SDL_COMPILE_TIME_ASSERT(sint64, sizeof(Sint64) == 8);
+
+/* Check to make sure enums are the size of ints, for structure packing.
+   For both Watcom C/C++ and Borland C/C++ the compiler option that makes
+   enums having the size of an int must be enabled.
+   This is &quot;-b&quot; for Borland C/C++ and &quot;-ei&quot; for Watcom C/C++ (v11).
+*/
+/* Enable enums always int in CodeWarrior (for MPW use &quot;-enum int&quot;) */
+#ifdef __MWERKS__
+#pragma enumsalwaysint on
+#endif
+
+typedef enum {
+	DUMMY_ENUM_VALUE
+} SDL_DUMMY_ENUM;
+
+SDL_COMPILE_TIME_ASSERT(enum, sizeof(SDL_DUMMY_ENUM) == sizeof(int));
+
+#undef SDL_COMPILE_TIME_ASSERT
+
+/* General keyboard/mouse state definitions */
+enum { SDL_PRESSED = 0x01, SDL_RELEASED = 0x00 };
+
+#endif

Added: trunk/msvc-libs/include/SDL/SDL_version.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_version.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_version.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,90 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_version.h,v 1.14 2004/07/18 22:57:40 slouken Exp $&quot;;
+#endif
+
+/* This header defines the current SDL version */
+
+#ifndef _SDL_version_h
+#define _SDL_version_h
+
+#include &quot;SDL_types.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Printable format: &quot;%d.%d.%d&quot;, MAJOR, MINOR, PATCHLEVEL
+*/
+#define SDL_MAJOR_VERSION	1
+#define SDL_MINOR_VERSION	2
+#define SDL_PATCHLEVEL		8
+
+typedef struct SDL_version {
+	Uint8 major;
+	Uint8 minor;
+	Uint8 patch;
+} SDL_version;
+
+/* This macro can be used to fill a version structure with the compile-time
+ * version of the SDL library.
+ */
+#define SDL_VERSION(X)							\
+{									\
+	(X)-&gt;major = SDL_MAJOR_VERSION;					\
+	(X)-&gt;minor = SDL_MINOR_VERSION;					\
+	(X)-&gt;patch = SDL_PATCHLEVEL;					\
+}
+
+/* This macro turns the version numbers into a numeric value:
+   (1,2,3) -&gt; (1203)
+   This assumes that there will never be more than 100 patchlevels
+*/
+#define SDL_VERSIONNUM(X, Y, Z)						\
+	(X)*1000 + (Y)*100 + (Z)
+
+/* This is the version number macro for the current SDL version */
+#define SDL_COMPILEDVERSION \
+	SDL_VERSIONNUM(SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL)
+
+/* This macro will evaluate to true if compiled with SDL at least X.Y.Z */
+#define SDL_VERSION_ATLEAST(X, Y, Z) \
+	(SDL_COMPILEDVERSION &gt;= SDL_VERSIONNUM(X, Y, Z))
+
+/* This function gets the version of the dynamically linked SDL library.
+   it should NOT be used to fill a version structure, instead you should
+   use the SDL_Version() macro.
+ */
+extern DECLSPEC const SDL_version * SDLCALL SDL_Linked_Version(void);
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_version_h */

Added: trunk/msvc-libs/include/SDL/SDL_video.h
===================================================================
--- trunk/msvc-libs/include/SDL/SDL_video.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/SDL_video.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,897 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+#ifdef SAVE_RCSID
+static char rcsid =
+ &quot;@(#) $Id: SDL_video.h,v 1.18 2004/07/18 22:57:40 slouken Exp $&quot;;
+#endif
+
+/* Header file for access to the SDL raw framebuffer window */
+
+#ifndef _SDL_video_h
+#define _SDL_video_h
+
+#include &lt;stdio.h&gt;
+
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_mutex.h&quot;
+#include &quot;SDL_rwops.h&quot;
+
+#include &quot;begin_code.h&quot;
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Transparency definitions: These define alpha as the opacity of a surface */
+#define SDL_ALPHA_OPAQUE 255
+#define SDL_ALPHA_TRANSPARENT 0
+
+/* Useful data types */
+typedef struct SDL_Rect {
+	Sint16 x, y;
+	Uint16 w, h;
+} SDL_Rect;
+
+typedef struct SDL_Color {
+	Uint8 r;
+	Uint8 g;
+	Uint8 b;
+	Uint8 unused;
+} SDL_Color;
+#define SDL_Colour SDL_Color
+
+typedef struct SDL_Palette {
+	int       ncolors;
+	SDL_Color *colors;
+} SDL_Palette;
+
+/* Everything in the pixel format structure is read-only */
+typedef struct SDL_PixelFormat {
+	SDL_Palette *palette;
+	Uint8  BitsPerPixel;
+	Uint8  BytesPerPixel;
+	Uint8  Rloss;
+	Uint8  Gloss;
+	Uint8  Bloss;
+	Uint8  Aloss;
+	Uint8  Rshift;
+	Uint8  Gshift;
+	Uint8  Bshift;
+	Uint8  Ashift;
+	Uint32 Rmask;
+	Uint32 Gmask;
+	Uint32 Bmask;
+	Uint32 Amask;
+
+	/* RGB color key information */
+	Uint32 colorkey;
+	/* Alpha value information (per-surface alpha) */
+	Uint8  alpha;
+} SDL_PixelFormat;
+
+/* typedef for private surface blitting functions */
+struct SDL_Surface;
+typedef int (*SDL_blit)(struct SDL_Surface *src, SDL_Rect *srcrect,
+			struct SDL_Surface *dst, SDL_Rect *dstrect);
+
+/* This structure should be treated as read-only, except for 'pixels',
+   which, if not NULL, contains the raw pixel data for the surface.
+*/
+typedef struct SDL_Surface {
+	Uint32 flags;				/* Read-only */
+	SDL_PixelFormat *format;		/* Read-only */
+	int w, h;				/* Read-only */
+	Uint16 pitch;				/* Read-only */
+	void *pixels;				/* Read-write */
+	int offset;				/* Private */
+
+	/* Hardware-specific surface info */
+	struct private_hwdata *hwdata;
+
+	/* clipping information */
+	SDL_Rect clip_rect;			/* Read-only */
+	Uint32 unused1;				/* for binary compatibility */
+
+	/* Allow recursive locks */
+	Uint32 locked;				/* Private */
+
+	/* info for fast blit mapping to other surfaces */
+	struct SDL_BlitMap *map;		/* Private */
+
+	/* format version, bumped at every change to invalidate blit maps */
+	unsigned int format_version;		/* Private */
+
+	/* Reference count -- used when freeing surface */
+	int refcount;				/* Read-mostly */
+} SDL_Surface;
+
+/* These are the currently supported flags for the SDL_surface */
+/* Available for SDL_CreateRGBSurface() or SDL_SetVideoMode() */
+#define SDL_SWSURFACE	0x00000000	/* Surface is in system memory */
+#define SDL_HWSURFACE	0x00000001	/* Surface is in video memory */
+#define SDL_ASYNCBLIT	0x00000004	/* Use asynchronous blits if possible */
+/* Available for SDL_SetVideoMode() */
+#define SDL_ANYFORMAT	0x10000000	/* Allow any video depth/pixel-format */
+#define SDL_HWPALETTE	0x20000000	/* Surface has exclusive palette */
+#define SDL_DOUBLEBUF	0x40000000	/* Set up double-buffered video mode */
+#define SDL_FULLSCREEN	0x80000000	/* Surface is a full screen display */
+#define SDL_OPENGL      0x00000002      /* Create an OpenGL rendering context */
+#define SDL_OPENGLBLIT	0x0000000A	/* Create an OpenGL rendering context and use it for blitting */
+#define SDL_RESIZABLE	0x00000010	/* This video mode may be resized */
+#define SDL_NOFRAME	0x00000020	/* No window caption or edge frame */
+/* Used internally (read-only) */
+#define SDL_HWACCEL	0x00000100	/* Blit uses hardware acceleration */
+#define SDL_SRCCOLORKEY	0x00001000	/* Blit uses a source color key */
+#define SDL_RLEACCELOK	0x00002000	/* Private flag */
+#define SDL_RLEACCEL	0x00004000	/* Surface is RLE encoded */
+#define SDL_SRCALPHA	0x00010000	/* Blit uses source alpha blending */
+#define SDL_PREALLOC	0x01000000	/* Surface uses preallocated memory */
+
+/* Evaluates to true if the surface needs to be locked before access */
+#define SDL_MUSTLOCK(surface)	\
+  (surface-&gt;offset ||		\
+  ((surface-&gt;flags &amp; (SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_RLEACCEL)) != 0))
+
+
+/* Useful for determining the video hardware capabilities */
+typedef struct SDL_VideoInfo {
+	Uint32 hw_available :1;	/* Flag: Can you create hardware surfaces? */
+	Uint32 wm_available :1;	/* Flag: Can you talk to a window manager? */
+	Uint32 UnusedBits1  :6;
+	Uint32 UnusedBits2  :1;
+	Uint32 blit_hw      :1;	/* Flag: Accelerated blits HW --&gt; HW */
+	Uint32 blit_hw_CC   :1;	/* Flag: Accelerated blits with Colorkey */
+	Uint32 blit_hw_A    :1;	/* Flag: Accelerated blits with Alpha */
+	Uint32 blit_sw      :1;	/* Flag: Accelerated blits SW --&gt; HW */
+	Uint32 blit_sw_CC   :1;	/* Flag: Accelerated blits with Colorkey */
+	Uint32 blit_sw_A    :1;	/* Flag: Accelerated blits with Alpha */
+	Uint32 blit_fill    :1;	/* Flag: Accelerated color fill */
+	Uint32 UnusedBits3  :16;
+	Uint32 video_mem;	/* The total amount of video memory (in K) */
+	SDL_PixelFormat *vfmt;	/* Value: The format of the video surface */
+} SDL_VideoInfo;
+
+
+/* The most common video overlay formats.
+   For an explanation of these pixel formats, see:
+	<A HREF="http://www.webartz.com/fourcc/indexyuv.htm">http://www.webartz.com/fourcc/indexyuv.htm</A>
+
+   For information on the relationship between color spaces, see:
+   <A HREF="http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html">http://www.neuro.sfc.keio.ac.jp/~aly/polygon/info/color-space-faq.html</A>
+ */
+#define SDL_YV12_OVERLAY  0x32315659	/* Planar mode: Y + V + U  (3 planes) */
+#define SDL_IYUV_OVERLAY  0x56555949	/* Planar mode: Y + U + V  (3 planes) */
+#define SDL_YUY2_OVERLAY  0x32595559	/* Packed mode: Y0+U0+Y1+V0 (1 plane) */
+#define SDL_UYVY_OVERLAY  0x59565955	/* Packed mode: U0+Y0+V0+Y1 (1 plane) */
+#define SDL_YVYU_OVERLAY  0x55595659	/* Packed mode: Y0+V0+Y1+U0 (1 plane) */
+
+/* The YUV hardware video overlay */
+typedef struct SDL_Overlay {
+	Uint32 format;				/* Read-only */
+	int w, h;				/* Read-only */
+	int planes;				/* Read-only */
+	Uint16 *pitches;			/* Read-only */
+	Uint8 **pixels;				/* Read-write */
+
+	/* Hardware-specific surface info */
+	struct private_yuvhwfuncs *hwfuncs;
+	struct private_yuvhwdata *hwdata;
+
+	/* Special flags */
+	Uint32 hw_overlay :1;	/* Flag: This overlay hardware accelerated? */
+	Uint32 UnusedBits :31;
+} SDL_Overlay;
+
+
+/* Public enumeration for setting the OpenGL window attributes. */
+typedef enum {
+    SDL_GL_RED_SIZE,
+    SDL_GL_GREEN_SIZE,
+    SDL_GL_BLUE_SIZE,
+    SDL_GL_ALPHA_SIZE,
+    SDL_GL_BUFFER_SIZE,
+    SDL_GL_DOUBLEBUFFER,
+    SDL_GL_DEPTH_SIZE,
+    SDL_GL_STENCIL_SIZE,
+    SDL_GL_ACCUM_RED_SIZE,
+    SDL_GL_ACCUM_GREEN_SIZE,
+    SDL_GL_ACCUM_BLUE_SIZE,
+    SDL_GL_ACCUM_ALPHA_SIZE,
+    SDL_GL_STEREO,
+    SDL_GL_MULTISAMPLEBUFFERS,
+    SDL_GL_MULTISAMPLESAMPLES
+} SDL_GLattr;
+
+/* flags for SDL_SetPalette() */
+#define SDL_LOGPAL 0x01
+#define SDL_PHYSPAL 0x02
+
+/* Function prototypes */
+
+/* These functions are used internally, and should not be used unless you
+ * have a specific need to specify the video driver you want to use.
+ * You should normally use SDL_Init() or SDL_InitSubSystem().
+ *
+ * SDL_VideoInit() initializes the video subsystem -- sets up a connection
+ * to the window manager, etc, and determines the current video mode and
+ * pixel format, but does not initialize a window or graphics mode.
+ * Note that event handling is activated by this routine.
+ *
+ * If you use both sound and video in your application, you need to call
+ * SDL_Init() before opening the sound device, otherwise under Win32 DirectX,
+ * you won't be able to set full-screen display modes.
+ */
+extern DECLSPEC int SDLCALL SDL_VideoInit(const char *driver_name, Uint32 flags);
+extern DECLSPEC void SDLCALL SDL_VideoQuit(void);
+
+/* This function fills the given character buffer with the name of the
+ * video driver, and returns a pointer to it if the video driver has
+ * been initialized.  It returns NULL if no driver has been initialized.
+ */
+extern DECLSPEC char * SDLCALL SDL_VideoDriverName(char *namebuf, int maxlen);
+
+/*
+ * This function returns a pointer to the current display surface.
+ * If SDL is doing format conversion on the display surface, this
+ * function returns the publicly visible surface, not the real video
+ * surface.
+ */
+extern DECLSPEC SDL_Surface * SDLCALL SDL_GetVideoSurface(void);
+
+/*
+ * This function returns a read-only pointer to information about the
+ * video hardware.  If this is called before SDL_SetVideoMode(), the 'vfmt'
+ * member of the returned structure will contain the pixel format of the
+ * &quot;best&quot; video mode.
+ */
+extern DECLSPEC const SDL_VideoInfo * SDLCALL SDL_GetVideoInfo(void);
+
+/* 
+ * Check to see if a particular video mode is supported.
+ * It returns 0 if the requested mode is not supported under any bit depth,
+ * or returns the bits-per-pixel of the closest available mode with the
+ * given width and height.  If this bits-per-pixel is different from the
+ * one used when setting the video mode, SDL_SetVideoMode() will succeed,
+ * but will emulate the requested bits-per-pixel with a shadow surface.
+ *
+ * The arguments to SDL_VideoModeOK() are the same ones you would pass to
+ * SDL_SetVideoMode()
+ */
+extern DECLSPEC int SDLCALL SDL_VideoModeOK(int width, int height, int bpp, Uint32 flags);
+
+/*
+ * Return a pointer to an array of available screen dimensions for the
+ * given format and video flags, sorted largest to smallest.  Returns 
+ * NULL if there are no dimensions available for a particular format, 
+ * or (SDL_Rect **)-1 if any dimension is okay for the given format.
+ *
+ * If 'format' is NULL, the mode list will be for the format given 
+ * by SDL_GetVideoInfo()-&gt;vfmt
+ */
+extern DECLSPEC SDL_Rect ** SDLCALL SDL_ListModes(SDL_PixelFormat *format, Uint32 flags);
+
+/*
+ * Set up a video mode with the specified width, height and bits-per-pixel.
+ *
+ * If 'bpp' is 0, it is treated as the current display bits per pixel.
+ *
+ * If SDL_ANYFORMAT is set in 'flags', the SDL library will try to set the
+ * requested bits-per-pixel, but will return whatever video pixel format is
+ * available.  The default is to emulate the requested pixel format if it
+ * is not natively available.
+ *
+ * If SDL_HWSURFACE is set in 'flags', the video surface will be placed in
+ * video memory, if possible, and you may have to call SDL_LockSurface()
+ * in order to access the raw framebuffer.  Otherwise, the video surface
+ * will be created in system memory.
+ *
+ * If SDL_ASYNCBLIT is set in 'flags', SDL will try to perform rectangle
+ * updates asynchronously, but you must always lock before accessing pixels.
+ * SDL will wait for updates to complete before returning from the lock.
+ *
+ * If SDL_HWPALETTE is set in 'flags', the SDL library will guarantee
+ * that the colors set by SDL_SetColors() will be the colors you get.
+ * Otherwise, in 8-bit mode, SDL_SetColors() may not be able to set all
+ * of the colors exactly the way they are requested, and you should look
+ * at the video surface structure to determine the actual palette.
+ * If SDL cannot guarantee that the colors you request can be set, 
+ * i.e. if the colormap is shared, then the video surface may be created
+ * under emulation in system memory, overriding the SDL_HWSURFACE flag.
+ *
+ * If SDL_FULLSCREEN is set in 'flags', the SDL library will try to set
+ * a fullscreen video mode.  The default is to create a windowed mode
+ * if the current graphics system has a window manager.
+ * If the SDL library is able to set a fullscreen video mode, this flag 
+ * will be set in the surface that is returned.
+ *
+ * If SDL_DOUBLEBUF is set in 'flags', the SDL library will try to set up
+ * two surfaces in video memory and swap between them when you call 
+ * SDL_Flip().  This is usually slower than the normal single-buffering
+ * scheme, but prevents &quot;tearing&quot; artifacts caused by modifying video 
+ * memory while the monitor is refreshing.  It should only be used by 
+ * applications that redraw the entire screen on every update.
+ *
+ * If SDL_RESIZABLE is set in 'flags', the SDL library will allow the
+ * window manager, if any, to resize the window at runtime.  When this
+ * occurs, SDL will send a SDL_VIDEORESIZE event to you application,
+ * and you must respond to the event by re-calling SDL_SetVideoMode()
+ * with the requested size (or another size that suits the application).
+ *
+ * If SDL_NOFRAME is set in 'flags', the SDL library will create a window
+ * without any title bar or frame decoration.  Fullscreen video modes have
+ * this flag set automatically.
+ *
+ * This function returns the video framebuffer surface, or NULL if it fails.
+ *
+ * If you rely on functionality provided by certain video flags, check the
+ * flags of the returned surface to make sure that functionality is available.
+ * SDL will fall back to reduced functionality if the exact flags you wanted
+ * are not available.
+ */
+extern DECLSPEC SDL_Surface * SDLCALL SDL_SetVideoMode
+			(int width, int height, int bpp, Uint32 flags);
+
+/*
+ * Makes sure the given list of rectangles is updated on the given screen.
+ * If 'x', 'y', 'w' and 'h' are all 0, SDL_UpdateRect will update the entire
+ * screen.
+ * These functions should not be called while 'screen' is locked.
+ */
+extern DECLSPEC void SDLCALL SDL_UpdateRects
+		(SDL_Surface *screen, int numrects, SDL_Rect *rects);
+extern DECLSPEC void SDLCALL SDL_UpdateRect
+		(SDL_Surface *screen, Sint32 x, Sint32 y, Uint32 w, Uint32 h);
+
+/*
+ * On hardware that supports double-buffering, this function sets up a flip
+ * and returns.  The hardware will wait for vertical retrace, and then swap
+ * video buffers before the next video surface blit or lock will return.
+ * On hardware that doesn not support double-buffering, this is equivalent
+ * to calling SDL_UpdateRect(screen, 0, 0, 0, 0);
+ * The SDL_DOUBLEBUF flag must have been passed to SDL_SetVideoMode() when
+ * setting the video mode for this function to perform hardware flipping.
+ * This function returns 0 if successful, or -1 if there was an error.
+ */
+extern DECLSPEC int SDLCALL SDL_Flip(SDL_Surface *screen);
+
+/*
+ * Set the gamma correction for each of the color channels.
+ * The gamma values range (approximately) between 0.1 and 10.0
+ * 
+ * If this function isn't supported directly by the hardware, it will
+ * be emulated using gamma ramps, if available.  If successful, this
+ * function returns 0, otherwise it returns -1.
+ */
+extern DECLSPEC int SDLCALL SDL_SetGamma(float red, float green, float blue);
+
+/*
+ * Set the gamma translation table for the red, green, and blue channels
+ * of the video hardware.  Each table is an array of 256 16-bit quantities,
+ * representing a mapping between the input and output for that channel.
+ * The input is the index into the array, and the output is the 16-bit
+ * gamma value at that index, scaled to the output color precision.
+ * 
+ * You may pass NULL for any of the channels to leave it unchanged.
+ * If the call succeeds, it will return 0.  If the display driver or
+ * hardware does not support gamma translation, or otherwise fails,
+ * this function will return -1.
+ */
+extern DECLSPEC int SDLCALL SDL_SetGammaRamp(const Uint16 *red, const Uint16 *green, const Uint16 *blue);
+
+/*
+ * Retrieve the current values of the gamma translation tables.
+ * 
+ * You must pass in valid pointers to arrays of 256 16-bit quantities.
+ * Any of the pointers may be NULL to ignore that channel.
+ * If the call succeeds, it will return 0.  If the display driver or
+ * hardware does not support gamma translation, or otherwise fails,
+ * this function will return -1.
+ */
+extern DECLSPEC int SDLCALL SDL_GetGammaRamp(Uint16 *red, Uint16 *green, Uint16 *blue);
+
+/*
+ * Sets a portion of the colormap for the given 8-bit surface.  If 'surface'
+ * is not a palettized surface, this function does nothing, returning 0.
+ * If all of the colors were set as passed to SDL_SetColors(), it will
+ * return 1.  If not all the color entries were set exactly as given,
+ * it will return 0, and you should look at the surface palette to
+ * determine the actual color palette.
+ *
+ * When 'surface' is the surface associated with the current display, the
+ * display colormap will be updated with the requested colors.  If 
+ * SDL_HWPALETTE was set in SDL_SetVideoMode() flags, SDL_SetColors()
+ * will always return 1, and the palette is guaranteed to be set the way
+ * you desire, even if the window colormap has to be warped or run under
+ * emulation.
+ */
+extern DECLSPEC int SDLCALL SDL_SetColors(SDL_Surface *surface, 
+			SDL_Color *colors, int firstcolor, int ncolors);
+
+/*
+ * Sets a portion of the colormap for a given 8-bit surface.
+ * 'flags' is one or both of:
+ * SDL_LOGPAL  -- set logical palette, which controls how blits are mapped
+ *                to/from the surface,
+ * SDL_PHYSPAL -- set physical palette, which controls how pixels look on
+ *                the screen
+ * Only screens have physical palettes. Separate change of physical/logical
+ * palettes is only possible if the screen has SDL_HWPALETTE set.
+ *
+ * The return value is 1 if all colours could be set as requested, and 0
+ * otherwise.
+ *
+ * SDL_SetColors() is equivalent to calling this function with
+ *     flags = (SDL_LOGPAL|SDL_PHYSPAL).
+ */
+extern DECLSPEC int SDLCALL SDL_SetPalette(SDL_Surface *surface, int flags,
+				   SDL_Color *colors, int firstcolor,
+				   int ncolors);
+
+/*
+ * Maps an RGB triple to an opaque pixel value for a given pixel format
+ */
+extern DECLSPEC Uint32 SDLCALL SDL_MapRGB
+			(SDL_PixelFormat *format, Uint8 r, Uint8 g, Uint8 b);
+
+/*
+ * Maps an RGBA quadruple to a pixel value for a given pixel format
+ */
+extern DECLSPEC Uint32 SDLCALL SDL_MapRGBA(SDL_PixelFormat *format,
+				   Uint8 r, Uint8 g, Uint8 b, Uint8 a);
+
+/*
+ * Maps a pixel value into the RGB components for a given pixel format
+ */
+extern DECLSPEC void SDLCALL SDL_GetRGB(Uint32 pixel, SDL_PixelFormat *fmt,
+				Uint8 *r, Uint8 *g, Uint8 *b);
+
+/*
+ * Maps a pixel value into the RGBA components for a given pixel format
+ */
+extern DECLSPEC void SDLCALL SDL_GetRGBA(Uint32 pixel, SDL_PixelFormat *fmt,
+				 Uint8 *r, Uint8 *g, Uint8 *b, Uint8 *a);
+
+/*
+ * Allocate and free an RGB surface (must be called after SDL_SetVideoMode)
+ * If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
+ * If the depth is greater than 8 bits, the pixel format is set using the
+ * flags '[RGB]mask'.
+ * If the function runs out of memory, it will return NULL.
+ *
+ * The 'flags' tell what kind of surface to create.
+ * SDL_SWSURFACE means that the surface should be created in system memory.
+ * SDL_HWSURFACE means that the surface should be created in video memory,
+ * with the same format as the display surface.  This is useful for surfaces
+ * that will not change much, to take advantage of hardware acceleration
+ * when being blitted to the display surface.
+ * SDL_ASYNCBLIT means that SDL will try to perform asynchronous blits with
+ * this surface, but you must always lock it before accessing the pixels.
+ * SDL will wait for current blits to finish before returning from the lock.
+ * SDL_SRCCOLORKEY indicates that the surface will be used for colorkey blits.
+ * If the hardware supports acceleration of colorkey blits between
+ * two surfaces in video memory, SDL will try to place the surface in
+ * video memory. If this isn't possible or if there is no hardware
+ * acceleration available, the surface will be placed in system memory.
+ * SDL_SRCALPHA means that the surface will be used for alpha blits and 
+ * if the hardware supports hardware acceleration of alpha blits between
+ * two surfaces in video memory, to place the surface in video memory
+ * if possible, otherwise it will be placed in system memory.
+ * If the surface is created in video memory, blits will be _much_ faster,
+ * but the surface format must be identical to the video surface format,
+ * and the only way to access the pixels member of the surface is to use
+ * the SDL_LockSurface() and SDL_UnlockSurface() calls.
+ * If the requested surface actually resides in video memory, SDL_HWSURFACE
+ * will be set in the flags member of the returned surface.  If for some
+ * reason the surface could not be placed in video memory, it will not have
+ * the SDL_HWSURFACE flag set, and will be created in system memory instead.
+ */
+#define SDL_AllocSurface    SDL_CreateRGBSurface
+extern DECLSPEC SDL_Surface * SDLCALL SDL_CreateRGBSurface
+			(Uint32 flags, int width, int height, int depth, 
+			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
+extern DECLSPEC SDL_Surface * SDLCALL SDL_CreateRGBSurfaceFrom(void *pixels,
+			int width, int height, int depth, int pitch,
+			Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);
+extern DECLSPEC void SDLCALL SDL_FreeSurface(SDL_Surface *surface);
+
+/*
+ * SDL_LockSurface() sets up a surface for directly accessing the pixels.
+ * Between calls to SDL_LockSurface()/SDL_UnlockSurface(), you can write
+ * to and read from 'surface-&gt;pixels', using the pixel format stored in 
+ * 'surface-&gt;format'.  Once you are done accessing the surface, you should 
+ * use SDL_UnlockSurface() to release it.
+ *
+ * Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates
+ * to 0, then you can read and write to the surface at any time, and the
+ * pixel format of the surface will not change.  In particular, if the
+ * SDL_HWSURFACE flag is not given when calling SDL_SetVideoMode(), you
+ * will not need to lock the display surface before accessing it.
+ * 
+ * No operating system or library calls should be made between lock/unlock
+ * pairs, as critical system locks may be held during this time.
+ *
+ * SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.
+ */
+extern DECLSPEC int SDLCALL SDL_LockSurface(SDL_Surface *surface);
+extern DECLSPEC void SDLCALL SDL_UnlockSurface(SDL_Surface *surface);
+
+/*
+ * Load a surface from a seekable SDL data source (memory or file.)
+ * If 'freesrc' is non-zero, the source will be closed after being read.
+ * Returns the new surface, or NULL if there was an error.
+ * The new surface should be freed with SDL_FreeSurface().
+ */
+extern DECLSPEC SDL_Surface * SDLCALL SDL_LoadBMP_RW(SDL_RWops *src, int freesrc);
+
+/* Convenience macro -- load a surface from a file */
+#define SDL_LoadBMP(file)	SDL_LoadBMP_RW(SDL_RWFromFile(file, &quot;rb&quot;), 1)
+
+/*
+ * Save a surface to a seekable SDL data source (memory or file.)
+ * If 'freedst' is non-zero, the source will be closed after being written.
+ * Returns 0 if successful or -1 if there was an error.
+ */
+extern DECLSPEC int SDLCALL SDL_SaveBMP_RW
+		(SDL_Surface *surface, SDL_RWops *dst, int freedst);
+
+/* Convenience macro -- save a surface to a file */
+#define SDL_SaveBMP(surface, file) \
+		SDL_SaveBMP_RW(surface, SDL_RWFromFile(file, &quot;wb&quot;), 1)
+
+/*
+ * Sets the color key (transparent pixel) in a blittable surface.
+ * If 'flag' is SDL_SRCCOLORKEY (optionally OR'd with SDL_RLEACCEL), 
+ * 'key' will be the transparent pixel in the source image of a blit.
+ * SDL_RLEACCEL requests RLE acceleration for the surface if present,
+ * and removes RLE acceleration if absent.
+ * If 'flag' is 0, this function clears any current color key.
+ * This function returns 0, or -1 if there was an error.
+ */
+extern DECLSPEC int SDLCALL SDL_SetColorKey
+			(SDL_Surface *surface, Uint32 flag, Uint32 key);
+
+/*
+ * This function sets the alpha value for the entire surface, as opposed to
+ * using the alpha component of each pixel. This value measures the range
+ * of transparency of the surface, 0 being completely transparent to 255
+ * being completely opaque. An 'alpha' value of 255 causes blits to be
+ * opaque, the source pixels copied to the destination (the default). Note
+ * that per-surface alpha can be combined with colorkey transparency.
+ *
+ * If 'flag' is 0, alpha blending is disabled for the surface.
+ * If 'flag' is SDL_SRCALPHA, alpha blending is enabled for the surface.
+ * OR:ing the flag with SDL_RLEACCEL requests RLE acceleration for the
+ * surface; if SDL_RLEACCEL is not specified, the RLE accel will be removed.
+ *
+ * The 'alpha' parameter is ignored for surfaces that have an alpha channel.
+ */
+extern DECLSPEC int SDLCALL SDL_SetAlpha(SDL_Surface *surface, Uint32 flag, Uint8 alpha);
+
+/*
+ * Sets the clipping rectangle for the destination surface in a blit.
+ *
+ * If the clip rectangle is NULL, clipping will be disabled.
+ * If the clip rectangle doesn't intersect the surface, the function will
+ * return SDL_FALSE and blits will be completely clipped.  Otherwise the
+ * function returns SDL_TRUE and blits to the surface will be clipped to
+ * the intersection of the surface area and the clipping rectangle.
+ *
+ * Note that blits are automatically clipped to the edges of the source
+ * and destination surfaces.
+ */
+extern DECLSPEC SDL_bool SDLCALL SDL_SetClipRect(SDL_Surface *surface, const SDL_Rect *rect);
+
+/*
+ * Gets the clipping rectangle for the destination surface in a blit.
+ * 'rect' must be a pointer to a valid rectangle which will be filled
+ * with the correct values.
+ */
+extern DECLSPEC void SDLCALL SDL_GetClipRect(SDL_Surface *surface, SDL_Rect *rect);
+
+/*
+ * Creates a new surface of the specified format, and then copies and maps 
+ * the given surface to it so the blit of the converted surface will be as 
+ * fast as possible.  If this function fails, it returns NULL.
+ *
+ * The 'flags' parameter is passed to SDL_CreateRGBSurface() and has those 
+ * semantics.  You can also pass SDL_RLEACCEL in the flags parameter and
+ * SDL will try to RLE accelerate colorkey and alpha blits in the resulting
+ * surface.
+ *
+ * This function is used internally by SDL_DisplayFormat().
+ */
+extern DECLSPEC SDL_Surface * SDLCALL SDL_ConvertSurface
+			(SDL_Surface *src, SDL_PixelFormat *fmt, Uint32 flags);
+
+/*
+ * This performs a fast blit from the source surface to the destination
+ * surface.  It assumes that the source and destination rectangles are
+ * the same size.  If either 'srcrect' or 'dstrect' are NULL, the entire
+ * surface (src or dst) is copied.  The final blit rectangles are saved
+ * in 'srcrect' and 'dstrect' after all clipping is performed.
+ * If the blit is successful, it returns 0, otherwise it returns -1.
+ *
+ * The blit function should not be called on a locked surface.
+ *
+ * The blit semantics for surfaces with and without alpha and colorkey
+ * are defined as follows:
+ *
+ * RGBA-&gt;RGB:
+ *     SDL_SRCALPHA set:
+ * 	alpha-blend (using alpha-channel).
+ * 	SDL_SRCCOLORKEY ignored.
+ *     SDL_SRCALPHA not set:
+ * 	copy RGB.
+ * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the
+ * 	RGB values of the source colour key, ignoring alpha in the
+ * 	comparison.
+ * 
+ * RGB-&gt;RGBA:
+ *     SDL_SRCALPHA set:
+ * 	alpha-blend (using the source per-surface alpha value);
+ * 	set destination alpha to opaque.
+ *     SDL_SRCALPHA not set:
+ * 	copy RGB, set destination alpha to source per-surface alpha value.
+ *     both:
+ * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the
+ * 	source colour key.
+ * 
+ * RGBA-&gt;RGBA:
+ *     SDL_SRCALPHA set:
+ * 	alpha-blend (using the source alpha channel) the RGB values;
+ * 	leave destination alpha untouched. [Note: is this correct?]
+ * 	SDL_SRCCOLORKEY ignored.
+ *     SDL_SRCALPHA not set:
+ * 	copy all of RGBA to the destination.
+ * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the
+ * 	RGB values of the source colour key, ignoring alpha in the
+ * 	comparison.
+ * 
+ * RGB-&gt;RGB: 
+ *     SDL_SRCALPHA set:
+ * 	alpha-blend (using the source per-surface alpha value).
+ *     SDL_SRCALPHA not set:
+ * 	copy RGB.
+ *     both:
+ * 	if SDL_SRCCOLORKEY set, only copy the pixels matching the
+ * 	source colour key.
+ *
+ * If either of the surfaces were in video memory, and the blit returns -2,
+ * the video memory was lost, so it should be reloaded with artwork and 
+ * re-blitted:
+	while ( SDL_BlitSurface(image, imgrect, screen, dstrect) == -2 ) {
+		while ( SDL_LockSurface(image) &lt; 0 )
+			Sleep(10);
+		-- Write image pixels to image-&gt;pixels --
+		SDL_UnlockSurface(image);
+	}
+ * This happens under DirectX 5.0 when the system switches away from your
+ * fullscreen application.  The lock will also fail until you have access
+ * to the video memory again.
+ */
+/* You should call SDL_BlitSurface() unless you know exactly how SDL
+   blitting works internally and how to use the other blit functions.
+*/
+#define SDL_BlitSurface SDL_UpperBlit
+
+/* This is the public blit function, SDL_BlitSurface(), and it performs
+   rectangle validation and clipping before passing it to SDL_LowerBlit()
+*/
+extern DECLSPEC int SDLCALL SDL_UpperBlit
+			(SDL_Surface *src, SDL_Rect *srcrect,
+			 SDL_Surface *dst, SDL_Rect *dstrect);
+/* This is a semi-private blit function and it performs low-level surface
+   blitting only.
+*/
+extern DECLSPEC int SDLCALL SDL_LowerBlit
+			(SDL_Surface *src, SDL_Rect *srcrect,
+			 SDL_Surface *dst, SDL_Rect *dstrect);
+
+/*
+ * This function performs a fast fill of the given rectangle with 'color'
+ * The given rectangle is clipped to the destination surface clip area
+ * and the final fill rectangle is saved in the passed in pointer.
+ * If 'dstrect' is NULL, the whole surface will be filled with 'color'
+ * The color should be a pixel of the format used by the surface, and 
+ * can be generated by the SDL_MapRGB() function.
+ * This function returns 0 on success, or -1 on error.
+ */
+extern DECLSPEC int SDLCALL SDL_FillRect
+		(SDL_Surface *dst, SDL_Rect *dstrect, Uint32 color);
+
+/* 
+ * This function takes a surface and copies it to a new surface of the
+ * pixel format and colors of the video framebuffer, suitable for fast
+ * blitting onto the display surface.  It calls SDL_ConvertSurface()
+ *
+ * If you want to take advantage of hardware colorkey or alpha blit
+ * acceleration, you should set the colorkey and alpha value before
+ * calling this function.
+ *
+ * If the conversion fails or runs out of memory, it returns NULL
+ */
+extern DECLSPEC SDL_Surface * SDLCALL SDL_DisplayFormat(SDL_Surface *surface);
+
+/* 
+ * This function takes a surface and copies it to a new surface of the
+ * pixel format and colors of the video framebuffer (if possible),
+ * suitable for fast alpha blitting onto the display surface.
+ * The new surface will always have an alpha channel.
+ *
+ * If you want to take advantage of hardware colorkey or alpha blit
+ * acceleration, you should set the colorkey and alpha value before
+ * calling this function.
+ *
+ * If the conversion fails or runs out of memory, it returns NULL
+ */
+extern DECLSPEC SDL_Surface * SDLCALL SDL_DisplayFormatAlpha(SDL_Surface *surface);
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* YUV video surface overlay functions                                       */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/* This function creates a video output overlay
+   Calling the returned surface an overlay is something of a misnomer because
+   the contents of the display surface underneath the area where the overlay
+   is shown is undefined - it may be overwritten with the converted YUV data.
+*/
+extern DECLSPEC SDL_Overlay * SDLCALL SDL_CreateYUVOverlay(int width, int height,
+				Uint32 format, SDL_Surface *display);
+
+/* Lock an overlay for direct access, and unlock it when you are done */
+extern DECLSPEC int SDLCALL SDL_LockYUVOverlay(SDL_Overlay *overlay);
+extern DECLSPEC void SDLCALL SDL_UnlockYUVOverlay(SDL_Overlay *overlay);
+
+/* Blit a video overlay to the display surface.
+   The contents of the video surface underneath the blit destination are
+   not defined.  
+   The width and height of the destination rectangle may be different from
+   that of the overlay, but currently only 2x scaling is supported.
+*/
+extern DECLSPEC int SDLCALL SDL_DisplayYUVOverlay(SDL_Overlay *overlay, SDL_Rect *dstrect);
+
+/* Free a video overlay */
+extern DECLSPEC void SDLCALL SDL_FreeYUVOverlay(SDL_Overlay *overlay);
+
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* OpenGL support functions.                                                 */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Dynamically load a GL driver, if SDL is built with dynamic GL.
+ *
+ * SDL links normally with the OpenGL library on your system by default,
+ * but you can compile it to dynamically load the GL driver at runtime.
+ * If you do this, you need to retrieve all of the GL functions used in
+ * your program from the dynamic library using SDL_GL_GetProcAddress().
+ *
+ * This is disabled in default builds of SDL.
+ */
+extern DECLSPEC int SDLCALL SDL_GL_LoadLibrary(const char *path);
+
+/*
+ * Get the address of a GL function (for extension functions)
+ */
+extern DECLSPEC void * SDLCALL SDL_GL_GetProcAddress(const char* proc);
+
+/*
+ * Set an attribute of the OpenGL subsystem before intialization.
+ */
+extern DECLSPEC int SDLCALL SDL_GL_SetAttribute(SDL_GLattr attr, int value);
+
+/*
+ * Get an attribute of the OpenGL subsystem from the windowing
+ * interface, such as glX. This is of course different from getting
+ * the values from SDL's internal OpenGL subsystem, which only
+ * stores the values you request before initialization.
+ *
+ * Developers should track the values they pass into SDL_GL_SetAttribute
+ * themselves if they want to retrieve these values.
+ */
+extern DECLSPEC int SDLCALL SDL_GL_GetAttribute(SDL_GLattr attr, int* value);
+
+/*
+ * Swap the OpenGL buffers, if double-buffering is supported.
+ */
+extern DECLSPEC void SDLCALL SDL_GL_SwapBuffers(void);
+
+/*
+ * Internal functions that should not be called unless you have read
+ * and understood the source code for these functions.
+ */
+extern DECLSPEC void SDLCALL SDL_GL_UpdateRects(int numrects, SDL_Rect* rects);
+extern DECLSPEC void SDLCALL SDL_GL_Lock(void);
+extern DECLSPEC void SDLCALL SDL_GL_Unlock(void);
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+/* These functions allow interaction with the window manager, if any.        */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+/*
+ * Sets/Gets the title and icon text of the display window
+ */
+extern DECLSPEC void SDLCALL SDL_WM_SetCaption(const char *title, const char *icon);
+extern DECLSPEC void SDLCALL SDL_WM_GetCaption(char **title, char **icon);
+
+/*
+ * Sets the icon for the display window.
+ * This function must be called before the first call to SDL_SetVideoMode().
+ * It takes an icon surface, and a mask in MSB format.
+ * If 'mask' is NULL, the entire icon surface will be used as the icon.
+ */
+extern DECLSPEC void SDLCALL SDL_WM_SetIcon(SDL_Surface *icon, Uint8 *mask);
+
+/*
+ * This function iconifies the window, and returns 1 if it succeeded.
+ * If the function succeeds, it generates an SDL_APPACTIVE loss event.
+ * This function is a noop and returns 0 in non-windowed environments.
+ */
+extern DECLSPEC int SDLCALL SDL_WM_IconifyWindow(void);
+
+/*
+ * Toggle fullscreen mode without changing the contents of the screen.
+ * If the display surface does not require locking before accessing
+ * the pixel information, then the memory pointers will not change.
+ *
+ * If this function was able to toggle fullscreen mode (change from 
+ * running in a window to fullscreen, or vice-versa), it will return 1.
+ * If it is not implemented, or fails, it returns 0.
+ *
+ * The next call to SDL_SetVideoMode() will set the mode fullscreen
+ * attribute based on the flags parameter - if SDL_FULLSCREEN is not
+ * set, then the display will be windowed by default where supported.
+ *
+ * This is currently only implemented in the X11 video driver.
+ */
+extern DECLSPEC int SDLCALL SDL_WM_ToggleFullScreen(SDL_Surface *surface);
+
+/*
+ * This function allows you to set and query the input grab state of
+ * the application.  It returns the new input grab state.
+ */
+typedef enum {
+	SDL_GRAB_QUERY = -1,
+	SDL_GRAB_OFF = 0,
+	SDL_GRAB_ON = 1,
+	SDL_GRAB_FULLSCREEN	/* Used internally */
+} SDL_GrabMode;
+/*
+ * Grabbing means that the mouse is confined to the application window,
+ * and nearly all keyboard input is passed directly to the application,
+ * and not interpreted by a window manager, if any.
+ */
+extern DECLSPEC SDL_GrabMode SDLCALL SDL_WM_GrabInput(SDL_GrabMode mode);
+
+/* Not in public API at the moment - do not use! */
+extern DECLSPEC int SDLCALL SDL_SoftStretch(SDL_Surface *src, SDL_Rect *srcrect,
+                                    SDL_Surface *dst, SDL_Rect *dstrect);
+                    
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_video_h */

Added: trunk/msvc-libs/include/SDL/begin_code.h
===================================================================
--- trunk/msvc-libs/include/SDL/begin_code.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/begin_code.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,136 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+/* This file sets things up for C dynamic library function definitions,
+   static inlined functions, and structures aligned at 4-byte alignment.
+   If you don't like ugly C preprocessor code, don't look at this file. :)
+*/
+
+/* This shouldn't be nested -- included it around code only. */
+#ifdef _begin_code_h
+#error Nested inclusion of begin_code.h
+#endif
+#define _begin_code_h
+
+/* Make sure the correct platform symbols are defined */
+#if !defined(WIN32) &amp;&amp; defined(_WIN32)
+#define WIN32
+#endif /* Windows */
+
+/* Some compilers use a special export keyword */
+#ifndef DECLSPEC
+# ifdef __BEOS__
+#  if defined(__GNUC__)
+#   define DECLSPEC	__declspec(dllexport)
+#  else
+#   define DECLSPEC	__declspec(export)
+#  endif
+# else
+# ifdef WIN32
+#  ifdef __BORLANDC__
+#   ifdef BUILD_SDL
+#    define DECLSPEC 
+#   else
+#    define DECLSPEC __declspec(dllimport)
+#   endif
+#  else
+#   define DECLSPEC	__declspec(dllexport)
+#  endif
+# else
+#  define DECLSPEC
+# endif
+# endif
+#endif
+
+/* By default SDL uses the C calling convention */
+#ifndef SDLCALL
+#ifdef WIN32
+#define SDLCALL __cdecl
+#else
+#define SDLCALL
+#endif
+#endif /* SDLCALL */
+
+/* Removed DECLSPEC on Symbian OS because SDL cannot be a DLL in EPOC */
+#ifdef __SYMBIAN32__ 
+#undef DECLSPEC
+#define DECLSPEC
+#endif /* __SYMBIAN32__ */
+
+/* Force structure packing at 4 byte alignment.
+   This is necessary if the header is included in code which has structure
+   packing set to an alternate value, say for loading structures from disk.
+   The packing is reset to the previous value in close_code.h
+ */
+#if defined(_MSC_VER) || defined(__MWERKS__) || defined(__BORLANDC__)
+#ifdef _MSC_VER
+#pragma warning(disable: 4103)
+#endif
+#ifdef __BORLANDC__
+#pragma nopackwarning
+#endif
+#pragma pack(push,4)
+#elif (defined(__MWERKS__) &amp;&amp; defined(macintosh))
+#pragma options align=mac68k4byte
+#pragma enumsalwaysint on
+#endif /* Compiler needs structure packing set */
+
+/* Set up compiler-specific options for inlining functions */
+#ifndef SDL_INLINE_OKAY
+#ifdef __GNUC__
+#define SDL_INLINE_OKAY
+#else
+/* Add any special compiler-specific cases here */
+#if defined(_MSC_VER) || defined(__BORLANDC__) || \
+    defined(__DMC__) || defined(__SC__) || \
+    defined(__WATCOMC__) || defined(__LCC__)
+#ifndef __inline__
+#define __inline__	__inline
+#endif
+#define SDL_INLINE_OKAY
+#else
+#if !defined(__MRC__) &amp;&amp; !defined(_SGI_SOURCE)
+#define __inline__ inline
+#define SDL_INLINE_OKAY
+#endif /* Not a funky compiler */
+#endif /* Visual C++ */
+#endif /* GNU C */
+#endif /* SDL_INLINE_OKAY */
+
+/* If inlining isn't supported, remove &quot;__inline__&quot;, turning static
+   inlined functions into static functions (resulting in code bloat
+   in all files which include the offending header files)
+*/
+#ifndef SDL_INLINE_OKAY
+#define __inline__
+#endif
+
+/* Apparently this is needed by several Windows compilers */
+#if !defined(__MACH__)
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+#endif /* NULL */
+#endif /* ! MacOS X - breaks precompiled headers */

Added: trunk/msvc-libs/include/SDL/close_code.h
===================================================================
--- trunk/msvc-libs/include/SDL/close_code.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL/close_code.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,41 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+/* This file reverses the effects of begin_code.h and should be included
+   after you finish any function and structure declarations in your headers
+*/
+
+#undef _begin_code_h
+
+/* Reset structure packing at previous byte alignment */
+#if defined(_MSC_VER) || defined(__MWERKS__) || defined(__WATCOMC__)  || defined(__BORLANDC__)
+#ifdef __BORLANDC__
+#pragma nopackwarning
+#endif
+#if (defined(__MWERKS__) &amp;&amp; defined(macintosh))
+#pragma options align=reset
+#pragma enumsalwaysint reset
+#else
+#pragma pack(pop)
+#endif
+#endif /* Compiler needs structure packing set */
+

Added: trunk/msvc-libs/include/SDL_mixer.h
===================================================================
--- trunk/msvc-libs/include/SDL_mixer.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/SDL_mixer.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,584 @@
+/*
+    SDL_mixer:  An audio mixer library based on the SDL library
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">slouken at libsdl.org</A>
+*/
+
+/* $Id: SDL_mixer.h,v 1.30 2004/01/04 17:37:04 slouken Exp $ */
+
+#ifndef _SDL_MIXER_H
+#define _SDL_MIXER_H
+
+#include &quot;SDL_types.h&quot;
+#include &quot;SDL_rwops.h&quot;
+#include &quot;SDL_audio.h&quot;
+#include &quot;SDL_byteorder.h&quot;
+#include &quot;SDL_version.h&quot;
+#include &quot;begin_code.h&quot;
+
+/* Set up for C function definitions, even when using C++ */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Printable format: &quot;%d.%d.%d&quot;, MAJOR, MINOR, PATCHLEVEL
+*/
+#define SDL_MIXER_MAJOR_VERSION	1
+#define SDL_MIXER_MINOR_VERSION	2
+#define SDL_MIXER_PATCHLEVEL	6
+
+/* This macro can be used to fill a version structure with the compile-time
+ * version of the SDL_mixer library.
+ */
+#define SDL_MIXER_VERSION(X)						\
+{									\
+	(X)-&gt;major = SDL_MIXER_MAJOR_VERSION;				\
+	(X)-&gt;minor = SDL_MIXER_MINOR_VERSION;				\
+	(X)-&gt;patch = SDL_MIXER_PATCHLEVEL;				\
+}
+
+/* Backwards compatibility */
+#define MIX_MAJOR_VERSION	SDL_MIXER_MAJOR_VERSION
+#define MIX_MINOR_VERSION	SDL_MIXER_MINOR_VERSION
+#define MIX_PATCHLEVEL		SDL_MIXER_PATCHLEVEL
+#define MIX_VERSION(X)		SDL_MIXER_VERSION(X)
+
+/* This function gets the version of the dynamically linked SDL_mixer library.
+   it should NOT be used to fill a version structure, instead you should
+   use the SDL_MIXER_VERSION() macro.
+ */
+extern DECLSPEC const SDL_version * SDLCALL Mix_Linked_Version(void);
+
+
+/* The default mixer has 8 simultaneous mixing channels */
+#ifndef MIX_CHANNELS
+#define MIX_CHANNELS	8
+#endif
+
+/* Good default values for a PC soundcard */
+#define MIX_DEFAULT_FREQUENCY	22050
+#if SDL_BYTEORDER == SDL_LIL_ENDIAN
+#define MIX_DEFAULT_FORMAT	AUDIO_S16LSB
+#else
+#define MIX_DEFAULT_FORMAT	AUDIO_S16MSB
+#endif
+#define MIX_DEFAULT_CHANNELS	2
+#define MIX_MAX_VOLUME		128	/* Volume of a chunk */
+
+/* The internal format for an audio chunk */
+typedef struct {
+	int allocated;
+	Uint8 *abuf;
+	Uint32 alen;
+	Uint8 volume;		/* Per-sample volume, 0-128 */
+} Mix_Chunk;
+
+/* The different fading types supported */
+typedef enum {
+	MIX_NO_FADING,
+	MIX_FADING_OUT,
+	MIX_FADING_IN
+} Mix_Fading;
+
+typedef enum {
+	MUS_NONE,
+	MUS_CMD,
+	MUS_WAV,
+	MUS_MOD,
+	MUS_MID,
+	MUS_OGG,
+	MUS_MP3
+} Mix_MusicType;
+
+/* The internal format for a music chunk interpreted via mikmod */
+typedef struct _Mix_Music Mix_Music;
+
+/* Open the mixer with a certain audio format */
+extern DECLSPEC int SDLCALL Mix_OpenAudio(int frequency, Uint16 format, int channels,
+							int chunksize);
+
+/* Dynamically change the number of channels managed by the mixer.
+   If decreasing the number of channels, the upper channels are
+   stopped.
+   This function returns the new number of allocated channels.
+ */
+extern DECLSPEC int SDLCALL Mix_AllocateChannels(int numchans);
+
+/* Find out what the actual audio device parameters are.
+   This function returns 1 if the audio has been opened, 0 otherwise.
+ */
+extern DECLSPEC int SDLCALL Mix_QuerySpec(int *frequency,Uint16 *format,int *channels);
+
+/* Load a wave file or a music (.mod .s3m .it .xm) file */
+extern DECLSPEC Mix_Chunk * SDLCALL Mix_LoadWAV_RW(SDL_RWops *src, int freesrc);
+#define Mix_LoadWAV(file)	Mix_LoadWAV_RW(SDL_RWFromFile(file, &quot;rb&quot;), 1)
+extern DECLSPEC Mix_Music * SDLCALL Mix_LoadMUS(const char *file);
+
+#ifdef USE_RWOPS /* This hasn't been hooked into music.c yet */
+/* Load a music file from an SDL_RWop object (MikMod-specific currently)
+   Matt Campbell (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">matt at campbellhome.dhs.org</A>) April 2000 */
+extern DECLSPEC Mix_Music * SDLCALL Mix_LoadMUS_RW(SDL_RWops *rw);
+#endif
+
+/* Load a wave file of the mixer format from a memory buffer */
+extern DECLSPEC Mix_Chunk * SDLCALL Mix_QuickLoad_WAV(Uint8 *mem);
+
+/* Load raw audio data of the mixer format from a memory buffer */
+extern DECLSPEC Mix_Chunk * SDLCALL Mix_QuickLoad_RAW(Uint8 *mem, Uint32 len);
+
+/* Free an audio chunk previously loaded */
+extern DECLSPEC void SDLCALL Mix_FreeChunk(Mix_Chunk *chunk);
+extern DECLSPEC void SDLCALL Mix_FreeMusic(Mix_Music *music);
+
+/* Find out the music format of a mixer music, or the currently playing
+   music, if 'music' is NULL.
+*/
+extern DECLSPEC Mix_MusicType SDLCALL Mix_GetMusicType(const Mix_Music *music);
+
+/* Set a function that is called after all mixing is performed.
+   This can be used to provide real-time visual display of the audio stream
+   or add a custom mixer filter for the stream data.
+*/
+extern DECLSPEC void SDLCALL Mix_SetPostMix(void (*mix_func)
+                             (void *udata, Uint8 *stream, int len), void *arg);
+
+/* Add your own music player or additional mixer function.
+   If 'mix_func' is NULL, the default music player is re-enabled.
+ */
+extern DECLSPEC void SDLCALL Mix_HookMusic(void (*mix_func)
+                          (void *udata, Uint8 *stream, int len), void *arg);
+
+/* Add your own callback when the music has finished playing.
+   This callback is only called if the music finishes naturally.
+ */
+extern DECLSPEC void SDLCALL Mix_HookMusicFinished(void (*music_finished)(void));
+
+/* Get a pointer to the user data for the current music hook */
+extern DECLSPEC void * SDLCALL Mix_GetMusicHookData(void);
+
+/*
+ * Add your own callback when a channel has finished playing. NULL
+ *  to disable callback. The callback may be called from the mixer's audio 
+ *  callback or it could be called as a result of Mix_HaltChannel(), etc.
+ *  do not call SDL_LockAudio() from this callback; you will either be 
+ *  inside the audio callback, or SDL_mixer will explicitly lock the audio
+ *  before calling your callback.
+ */
+extern DECLSPEC void SDLCALL Mix_ChannelFinished(void (*channel_finished)(int channel));
+
+
+/* Special Effects API by ryan c. gordon. (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">icculus at linuxgames.com</A>) */
+
+#define MIX_CHANNEL_POST  -2
+
+/* This is the format of a special effect callback:
+ *
+ *   myeffect(int chan, void *stream, int len, void *udata);
+ *
+ * (chan) is the channel number that your effect is affecting. (stream) is
+ *  the buffer of data to work upon. (len) is the size of (stream), and
+ *  (udata) is a user-defined bit of data, which you pass as the last arg of
+ *  Mix_RegisterEffect(), and is passed back unmolested to your callback.
+ *  Your effect changes the contents of (stream) based on whatever parameters
+ *  are significant, or just leaves it be, if you prefer. You can do whatever
+ *  you like to the buffer, though, and it will continue in its changed state
+ *  down the mixing pipeline, through any other effect functions, then finally
+ *  to be mixed with the rest of the channels and music for the final output
+ *  stream.
+ *
+ * DO NOT EVER call SDL_LockAudio() from your callback function!
+ */
+typedef void (*Mix_EffectFunc_t)(int chan, void *stream, int len, void *udata);
+
+/*
+ * This is a callback that signifies that a channel has finished all its
+ *  loops and has completed playback. This gets called if the buffer
+ *  plays out normally, or if you call Mix_HaltChannel(), implicitly stop
+ *  a channel via Mix_AllocateChannels(), or unregister a callback while
+ *  it's still playing.
+ *
+ * DO NOT EVER call SDL_LockAudio() from your callback function!
+ */
+typedef void (*Mix_EffectDone_t)(int chan, void *udata);
+
+
+/* Register a special effect function. At mixing time, the channel data is
+ *  copied into a buffer and passed through each registered effect function.
+ *  After it passes through all the functions, it is mixed into the final
+ *  output stream. The copy to buffer is performed once, then each effect
+ *  function performs on the output of the previous effect. Understand that
+ *  this extra copy to a buffer is not performed if there are no effects
+ *  registered for a given chunk, which saves CPU cycles, and any given
+ *  effect will be extra cycles, too, so it is crucial that your code run
+ *  fast. Also note that the data that your function is given is in the
+ *  format of the sound device, and not the format you gave to Mix_OpenAudio(),
+ *  although they may in reality be the same. This is an unfortunate but
+ *  necessary speed concern. Use Mix_QuerySpec() to determine if you can
+ *  handle the data before you register your effect, and take appropriate
+ *  actions.
+ * You may also specify a callback (Mix_EffectDone_t) that is called when
+ *  the channel finishes playing. This gives you a more fine-grained control
+ *  than Mix_ChannelFinished(), in case you need to free effect-specific
+ *  resources, etc. If you don't need this, you can specify NULL.
+ * You may set the callbacks before or after calling Mix_PlayChannel().
+ * Things like Mix_SetPanning() are just internal special effect functions,
+ *  so if you are using that, you've already incurred the overhead of a copy
+ *  to a separate buffer, and that these effects will be in the queue with
+ *  any functions you've registered. The list of registered effects for a
+ *  channel is reset when a chunk finishes playing, so you need to explicitly
+ *  set them with each call to Mix_PlayChannel*().
+ * You may also register a special effect function that is to be run after
+ *  final mixing occurs. The rules for these callbacks are identical to those
+ *  in Mix_RegisterEffect, but they are run after all the channels and the
+ *  music have been mixed into a single stream, whereas channel-specific
+ *  effects run on a given channel before any other mixing occurs. These
+ *  global effect callbacks are call &quot;posteffects&quot;. Posteffects only have
+ *  their Mix_EffectDone_t function called when they are unregistered (since
+ *  the main output stream is never &quot;done&quot; in the same sense as a channel).
+ *  You must unregister them manually when you've had enough. Your callback
+ *  will be told that the channel being mixed is (MIX_CHANNEL_POST) if the
+ *  processing is considered a posteffect.
+ *
+ * After all these effects have finished processing, the callback registered
+ *  through Mix_SetPostMix() runs, and then the stream goes to the audio
+ *  device. 
+ *
+ * DO NOT EVER call SDL_LockAudio() from your callback function!
+ *
+ * returns zero if error (no such channel), nonzero if added.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern DECLSPEC int SDLCALL Mix_RegisterEffect(int chan, Mix_EffectFunc_t f,
+					Mix_EffectDone_t d, void *arg);
+
+
+/* You may not need to call this explicitly, unless you need to stop an
+ *  effect from processing in the middle of a chunk's playback.
+ * Posteffects are never implicitly unregistered as they are for channels,
+ *  but they may be explicitly unregistered through this function by
+ *  specifying MIX_CHANNEL_POST for a channel.
+ * returns zero if error (no such channel or effect), nonzero if removed.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern DECLSPEC int SDLCALL Mix_UnregisterEffect(int channel, Mix_EffectFunc_t f);
+
+
+/* You may not need to call this explicitly, unless you need to stop all
+ *  effects from processing in the middle of a chunk's playback. Note that
+ *  this will also shut off some internal effect processing, since
+ *  Mix_SetPanning() and others may use this API under the hood. This is
+ *  called internally when a channel completes playback.
+ * Posteffects are never implicitly unregistered as they are for channels,
+ *  but they may be explicitly unregistered through this function by
+ *  specifying MIX_CHANNEL_POST for a channel.
+ * returns zero if error (no such channel), nonzero if all effects removed.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern DECLSPEC int SDLCALL Mix_UnregisterAllEffects(int channel);
+
+
+#define MIX_EFFECTSMAXSPEED  &quot;MIX_EFFECTSMAXSPEED&quot;
+
+/*
+ * These are the internally-defined mixing effects. They use the same API that
+ *  effects defined in the application use, but are provided here as a
+ *  convenience. Some effects can reduce their quality or use more memory in
+ *  the name of speed; to enable this, make sure the environment variable
+ *  MIX_EFFECTSMAXSPEED (see above) is defined before you call
+ *  Mix_OpenAudio().
+ */
+
+
+/* Set the panning of a channel. The left and right channels are specified
+ *  as integers between 0 and 255, quietest to loudest, respectively.
+ *
+ * Technically, this is just individual volume control for a sample with
+ *  two (stereo) channels, so it can be used for more than just panning.
+ *  If you want real panning, call it like this:
+ *
+ *   Mix_SetPanning(channel, left, 255 - left);
+ *
+ * ...which isn't so hard.
+ *
+ * Setting (channel) to MIX_CHANNEL_POST registers this as a posteffect, and
+ *  the panning will be done to the final mixed stream before passing it on
+ *  to the audio device.
+ *
+ * This uses the Mix_RegisterEffect() API internally, and returns without
+ *  registering the effect function if the audio device is not configured
+ *  for stereo output. Setting both (left) and (right) to 255 causes this
+ *  effect to be unregistered, since that is the data's normal state.
+ *
+ * returns zero if error (no such channel or Mix_RegisterEffect() fails),
+ *  nonzero if panning effect enabled. Note that an audio device in mono
+ *  mode is a no-op, but this call will return successful in that case.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern DECLSPEC int SDLCALL Mix_SetPanning(int channel, Uint8 left, Uint8 right);
+
+
+/* Set the position of a channel. (angle) is an integer from 0 to 360, that
+ *  specifies the location of the sound in relation to the listener. (angle)
+ *  will be reduced as neccesary (540 becomes 180 degrees, -100 becomes 260).
+ *  Angle 0 is due north, and rotates clockwise as the value increases.
+ *  For efficiency, the precision of this effect may be limited (angles 1
+ *  through 7 might all produce the same effect, 8 through 15 are equal, etc).
+ *  (distance) is an integer between 0 and 255 that specifies the space
+ *  between the sound and the listener. The larger the number, the further
+ *  away the sound is. Using 255 does not guarantee that the channel will be
+ *  culled from the mixing process or be completely silent. For efficiency,
+ *  the precision of this effect may be limited (distance 0 through 5 might
+ *  all produce the same effect, 6 through 10 are equal, etc). Setting (angle)
+ *  and (distance) to 0 unregisters this effect, since the data would be
+ *  unchanged.
+ *
+ * If you need more precise positional audio, consider using OpenAL for
+ *  spatialized effects instead of SDL_mixer. This is only meant to be a
+ *  basic effect for simple &quot;3D&quot; games.
+ *
+ * If the audio device is configured for mono output, then you won't get
+ *  any effectiveness from the angle; however, distance attenuation on the
+ *  channel will still occur. While this effect will function with stereo
+ *  voices, it makes more sense to use voices with only one channel of sound,
+ *  so when they are mixed through this effect, the positioning will sound
+ *  correct. You can convert them to mono through SDL before giving them to
+ *  the mixer in the first place if you like.
+ *
+ * Setting (channel) to MIX_CHANNEL_POST registers this as a posteffect, and
+ *  the positioning will be done to the final mixed stream before passing it
+ *  on to the audio device.
+ *
+ * This is a convenience wrapper over Mix_SetDistance() and Mix_SetPanning().
+ *
+ * returns zero if error (no such channel or Mix_RegisterEffect() fails),
+ *  nonzero if position effect is enabled.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern DECLSPEC int SDLCALL Mix_SetPosition(int channel, Sint16 angle, Uint8 distance);
+
+
+/* Set the &quot;distance&quot; of a channel. (distance) is an integer from 0 to 255
+ *  that specifies the location of the sound in relation to the listener.
+ *  Distance 0 is overlapping the listener, and 255 is as far away as possible
+ *  A distance of 255 does not guarantee silence; in such a case, you might
+ *  want to try changing the chunk's volume, or just cull the sample from the
+ *  mixing process with Mix_HaltChannel().
+ * For efficiency, the precision of this effect may be limited (distances 1
+ *  through 7 might all produce the same effect, 8 through 15 are equal, etc).
+ *  (distance) is an integer between 0 and 255 that specifies the space
+ *  between the sound and the listener. The larger the number, the further
+ *  away the sound is.
+ * Setting (distance) to 0 unregisters this effect, since the data would be
+ *  unchanged.
+ * If you need more precise positional audio, consider using OpenAL for
+ *  spatialized effects instead of SDL_mixer. This is only meant to be a
+ *  basic effect for simple &quot;3D&quot; games.
+ *
+ * Setting (channel) to MIX_CHANNEL_POST registers this as a posteffect, and
+ *  the distance attenuation will be done to the final mixed stream before
+ *  passing it on to the audio device.
+ *
+ * This uses the Mix_RegisterEffect() API internally.
+ *
+ * returns zero if error (no such channel or Mix_RegisterEffect() fails),
+ *  nonzero if position effect is enabled.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern DECLSPEC int SDLCALL Mix_SetDistance(int channel, Uint8 distance);
+
+
+/*
+ * !!! FIXME : Haven't implemented, since the effect goes past the
+ *              end of the sound buffer. Will have to think about this.
+ *               --ryan.
+ */
+#if 0
+/* Causes an echo effect to be mixed into a sound. (echo) is the amount
+ *  of echo to mix. 0 is no echo, 255 is infinite (and probably not
+ *  what you want).
+ *
+ * Setting (channel) to MIX_CHANNEL_POST registers this as a posteffect, and
+ *  the reverbing will be done to the final mixed stream before passing it on
+ *  to the audio device.
+ *
+ * This uses the Mix_RegisterEffect() API internally. If you specify an echo
+ *  of zero, the effect is unregistered, as the data is already in that state.
+ *
+ * returns zero if error (no such channel or Mix_RegisterEffect() fails),
+ *  nonzero if reversing effect is enabled.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern no_parse_DECLSPEC int SDLCALL Mix_SetReverb(int channel, Uint8 echo);
+#endif
+
+/* Causes a channel to reverse its stereo. This is handy if the user has his
+ *  speakers hooked up backwards, or you would like to have a minor bit of
+ *  psychedelia in your sound code.  :)  Calling this function with (flip)
+ *  set to non-zero reverses the chunks's usual channels. If (flip) is zero,
+ *  the effect is unregistered.
+ *
+ * This uses the Mix_RegisterEffect() API internally, and thus is probably
+ *  more CPU intensive than having the user just plug in his speakers
+ *  correctly. Mix_SetReverseStereo() returns without registering the effect
+ *  function if the audio device is not configured for stereo output.
+ *
+ * If you specify MIX_CHANNEL_POST for (channel), then this the effect is used
+ *  on the final mixed stream before sending it on to the audio device (a
+ *  posteffect).
+ *
+ * returns zero if error (no such channel or Mix_RegisterEffect() fails),
+ *  nonzero if reversing effect is enabled. Note that an audio device in mono
+ *  mode is a no-op, but this call will return successful in that case.
+ *  Error messages can be retrieved from Mix_GetError().
+ */
+extern DECLSPEC int SDLCALL Mix_SetReverseStereo(int channel, int flip);
+
+/* end of effects API. --ryan. */
+
+
+/* Reserve the first channels (0 -&gt; n-1) for the application, i.e. don't allocate
+   them dynamically to the next sample if requested with a -1 value below.
+   Returns the number of reserved channels.
+ */
+extern DECLSPEC int SDLCALL Mix_ReserveChannels(int num);
+
+/* Channel grouping functions */
+
+/* Attach a tag to a channel. A tag can be assigned to several mixer
+   channels, to form groups of channels.
+   If 'tag' is -1, the tag is removed (actually -1 is the tag used to
+   represent the group of all the channels).
+   Returns true if everything was OK.
+ */
+extern DECLSPEC int SDLCALL Mix_GroupChannel(int which, int tag);
+/* Assign several consecutive channels to a group */
+extern DECLSPEC int SDLCALL Mix_GroupChannels(int from, int to, int tag);
+/* Finds the first available channel in a group of channels,
+   returning -1 if none are available.
+ */
+extern DECLSPEC int SDLCALL Mix_GroupAvailable(int tag);
+/* Returns the number of channels in a group. This is also a subtle
+   way to get the total number of channels when 'tag' is -1
+ */
+extern DECLSPEC int SDLCALL Mix_GroupCount(int tag);
+/* Finds the &quot;oldest&quot; sample playing in a group of channels */
+extern DECLSPEC int SDLCALL Mix_GroupOldest(int tag);
+/* Finds the &quot;most recent&quot; (i.e. last) sample playing in a group of channels */
+extern DECLSPEC int SDLCALL Mix_GroupNewer(int tag);
+
+/* Play an audio chunk on a specific channel.
+   If the specified channel is -1, play on the first free channel.
+   If 'loops' is greater than zero, loop the sound that many times.
+   If 'loops' is -1, loop inifinitely (~65000 times).
+   Returns which channel was used to play the sound.
+*/
+#define Mix_PlayChannel(channel,chunk,loops) Mix_PlayChannelTimed(channel,chunk,loops,-1)
+/* The same as above, but the sound is played at most 'ticks' milliseconds */
+extern DECLSPEC int SDLCALL Mix_PlayChannelTimed(int channel, Mix_Chunk *chunk, int loops, int ticks);
+extern DECLSPEC int SDLCALL Mix_PlayMusic(Mix_Music *music, int loops);
+
+/* Fade in music or a channel over &quot;ms&quot; milliseconds, same semantics as the &quot;Play&quot; functions */
+extern DECLSPEC int SDLCALL Mix_FadeInMusic(Mix_Music *music, int loops, int ms);
+extern DECLSPEC int SDLCALL Mix_FadeInMusicPos(Mix_Music *music, int loops, int ms, double position);
+#define Mix_FadeInChannel(channel,chunk,loops,ms) Mix_FadeInChannelTimed(channel,chunk,loops,ms,-1)
+extern DECLSPEC int SDLCALL Mix_FadeInChannelTimed(int channel, Mix_Chunk *chunk, int loops, int ms, int ticks);
+
+/* Set the volume in the range of 0-128 of a specific channel or chunk.
+   If the specified channel is -1, set volume for all channels.
+   Returns the original volume.
+   If the specified volume is -1, just return the current volume.
+*/
+extern DECLSPEC int SDLCALL Mix_Volume(int channel, int volume);
+extern DECLSPEC int SDLCALL Mix_VolumeChunk(Mix_Chunk *chunk, int volume);
+extern DECLSPEC int SDLCALL Mix_VolumeMusic(int volume);
+
+/* Halt playing of a particular channel */
+extern DECLSPEC int SDLCALL Mix_HaltChannel(int channel);
+extern DECLSPEC int SDLCALL Mix_HaltGroup(int tag);
+extern DECLSPEC int SDLCALL Mix_HaltMusic(void);
+
+/* Change the expiration delay for a particular channel.
+   The sample will stop playing after the 'ticks' milliseconds have elapsed,
+   or remove the expiration if 'ticks' is -1
+*/
+extern DECLSPEC int SDLCALL Mix_ExpireChannel(int channel, int ticks);
+
+/* Halt a channel, fading it out progressively till it's silent
+   The ms parameter indicates the number of milliseconds the fading
+   will take.
+ */
+extern DECLSPEC int SDLCALL Mix_FadeOutChannel(int which, int ms);
+extern DECLSPEC int SDLCALL Mix_FadeOutGroup(int tag, int ms);
+extern DECLSPEC int SDLCALL Mix_FadeOutMusic(int ms);
+
+/* Query the fading status of a channel */
+extern DECLSPEC Mix_Fading SDLCALL Mix_FadingMusic(void);
+extern DECLSPEC Mix_Fading SDLCALL Mix_FadingChannel(int which);
+
+/* Pause/Resume a particular channel */
+extern DECLSPEC void SDLCALL Mix_Pause(int channel);
+extern DECLSPEC void SDLCALL Mix_Resume(int channel);
+extern DECLSPEC int SDLCALL Mix_Paused(int channel);
+
+/* Pause/Resume the music stream */
+extern DECLSPEC void SDLCALL Mix_PauseMusic(void);
+extern DECLSPEC void SDLCALL Mix_ResumeMusic(void);
+extern DECLSPEC void SDLCALL Mix_RewindMusic(void);
+extern DECLSPEC int SDLCALL Mix_PausedMusic(void);
+
+/* Set the current position in the music stream.
+   This returns 0 if successful, or -1 if it failed or isn't implemented.
+   This function is only implemented for MOD music formats (set pattern
+   order number) and for OGG music (set position in seconds), at the
+   moment.
+*/
+extern DECLSPEC int SDLCALL Mix_SetMusicPosition(double position);
+
+/* Check the status of a specific channel.
+   If the specified channel is -1, check all channels.
+*/
+extern DECLSPEC int SDLCALL Mix_Playing(int channel);
+extern DECLSPEC int SDLCALL Mix_PlayingMusic(void);
+
+/* Stop music and set external music playback command */
+extern DECLSPEC int SDLCALL Mix_SetMusicCMD(const char *command);
+
+/* Synchro value is set by MikMod from modules while playing */
+extern DECLSPEC int SDLCALL Mix_SetSynchroValue(int value);
+extern DECLSPEC int SDLCALL Mix_GetSynchroValue(void);
+
+/* Get the Mix_Chunk currently associated with a mixer channel
+    Returns NULL if it's an invalid channel, or there's no chunk associated.
+*/
+extern DECLSPEC Mix_Chunk * SDLCALL Mix_GetChunk(int channel);
+
+/* Close the mixer, halting all playing audio */
+extern DECLSPEC void SDLCALL Mix_CloseAudio(void);
+
+/* We'll use SDL for reporting errors */
+#define Mix_SetError	SDL_SetError
+#define Mix_GetError	SDL_GetError
+
+/* Ends C function definitions when using C++ */
+#ifdef __cplusplus
+}
+#endif
+#include &quot;close_code.h&quot;
+
+#endif /* _SDL_MIXER_H */

Added: trunk/msvc-libs/include/abstract.h
===================================================================
--- trunk/msvc-libs/include/abstract.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/abstract.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,1223 @@
+#ifndef Py_ABSTRACTOBJECT_H
+#define Py_ABSTRACTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Abstract Object Interface (many thanks to Jim Fulton) */
+
+/*
+   PROPOSAL: A Generic Python Object Interface for Python C Modules
+
+Problem
+
+  Python modules written in C that must access Python objects must do
+  so through routines whose interfaces are described by a set of
+  include files.  Unfortunately, these routines vary according to the
+  object accessed.  To use these routines, the C programmer must check
+  the type of the object being used and must call a routine based on
+  the object type.  For example, to access an element of a sequence,
+  the programmer must determine whether the sequence is a list or a
+  tuple:
+
+    if(is_tupleobject(o))
+      e=gettupleitem(o,i)
+    else if(is_listitem(o))
+      e=getlistitem(o,i)
+
+  If the programmer wants to get an item from another type of object
+  that provides sequence behavior, there is no clear way to do it
+  correctly.  
+
+  The persistent programmer may peruse object.h and find that the
+  _typeobject structure provides a means of invoking up to (currently
+  about) 41 special operators.  So, for example, a routine can get an
+  item from any object that provides sequence behavior. However, to
+  use this mechanism, the programmer must make their code dependent on
+  the current Python implementation.
+
+  Also, certain semantics, especially memory management semantics, may
+  differ by the type of object being used.  Unfortunately, these
+  semantics are not clearly described in the current include files.
+  An abstract interface providing more consistent semantics is needed. 
+
+Proposal
+
+  I propose the creation of a standard interface (with an associated
+  library of routines and/or macros) for generically obtaining the
+  services of Python objects.  This proposal can be viewed as one
+  components of a Python C interface consisting of several components.
+
+  From the viewpoint of C access to Python services, we have (as
+  suggested by Guido in off-line discussions):
+
+  - &quot;Very high level layer&quot;: two or three functions that let you exec or
+    eval arbitrary Python code given as a string in a module whose name is
+    given, passing C values in and getting C values out using
+    mkvalue/getargs style format strings.  This does not require the user
+    to declare any variables of type &quot;PyObject *&quot;.  This should be enough
+    to write a simple application that gets Python code from the user,
+    execs it, and returns the output or errors.  (Error handling must also
+    be part of this API.)
+
+  - &quot;Abstract objects layer&quot;: which is the subject of this proposal.
+    It has many functions operating on objects, and lest you do many
+    things from C that you can also write in Python, without going
+    through the Python parser.
+
+  - &quot;Concrete objects layer&quot;: This is the public type-dependent
+    interface provided by the standard built-in types, such as floats,
+    strings, and lists.  This interface exists and is currently
+    documented by the collection of include files provided with the
+    Python distributions.
+
+  From the point of view of Python accessing services provided by C
+  modules: 
+
+  - &quot;Python module interface&quot;: this interface consist of the basic
+    routines used to define modules and their members.  Most of the
+    current extensions-writing guide deals with this interface.
+
+  - &quot;Built-in object interface&quot;: this is the interface that a new
+    built-in type must provide and the mechanisms and rules that a
+    developer of a new built-in type must use and follow.
+
+  This proposal is a &quot;first-cut&quot; that is intended to spur
+  discussion. See especially the lists of notes.
+
+  The Python C object interface will provide four protocols: object,
+  numeric, sequence, and mapping.  Each protocol consists of a
+  collection of related operations.  If an operation that is not
+  provided by a particular type is invoked, then a standard exception,
+  NotImplementedError is raised with a operation name as an argument.
+  In addition, for convenience this interface defines a set of
+  constructors for building objects of built-in types.  This is needed
+  so new objects can be returned from C functions that otherwise treat
+  objects generically.
+
+Memory Management
+
+  For all of the functions described in this proposal, if a function
+  retains a reference to a Python object passed as an argument, then the
+  function will increase the reference count of the object.  It is
+  unnecessary for the caller to increase the reference count of an
+  argument in anticipation of the object's retention.
+
+  All Python objects returned from functions should be treated as new
+  objects.  Functions that return objects assume that the caller will
+  retain a reference and the reference count of the object has already
+  been incremented to account for this fact.  A caller that does not
+  retain a reference to an object that is returned from a function
+  must decrement the reference count of the object (using
+  DECREF(object)) to prevent memory leaks.
+
+  Note that the behavior mentioned here is different from the current
+  behavior for some objects (e.g. lists and tuples) when certain
+  type-specific routines are called directly (e.g. setlistitem).  The
+  proposed abstraction layer will provide a consistent memory
+  management interface, correcting for inconsistent behavior for some
+  built-in types.
+
+Protocols
+
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/
+
+/*  Object Protocol: */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Print(PyObject *o, FILE *fp, int flags);
+
+         Print an object, o, on file, fp.  Returns -1 on
+	 error.  The flags argument is used to enable certain printing
+	 options. The only option currently supported is Py_Print_RAW. 
+
+         (What should be said about Py_Print_RAW?)	
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_HasAttrString(PyObject *o, char *attr_name);
+
+         Returns 1 if o has the attribute attr_name, and 0 otherwise.
+	 This is equivalent to the Python expression:
+	 hasattr(o,attr_name). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject* PyObject_GetAttrString(PyObject *o, char *attr_name);
+
+	 Retrieve an attributed named attr_name form object o.
+	 Returns the attribute value on success, or NULL on failure.
+	 This is the equivalent of the Python expression: o.attr_name.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_HasAttr(PyObject *o, PyObject *attr_name);
+
+         Returns 1 if o has the attribute attr_name, and 0 otherwise.
+	 This is equivalent to the Python expression:
+	 hasattr(o,attr_name). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);
+
+	 Retrieve an attributed named attr_name form object o.
+	 Returns the attribute value on success, or NULL on failure.
+	 This is the equivalent of the Python expression: o.attr_name.
+
+       */
+
+
+     /* Implemented elsewhere:
+
+     int PyObject_SetAttrString(PyObject *o, char *attr_name, PyObject *v);
+
+	 Set the value of the attribute named attr_name, for object o,
+	 to the value, v. Returns -1 on failure.  This is
+	 the equivalent of the Python statement: o.attr_name=v.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);
+
+	 Set the value of the attribute named attr_name, for object o,
+	 to the value, v. Returns -1 on failure.  This is
+	 the equivalent of the Python statement: o.attr_name=v.
+
+       */
+
+     /* implemented as a macro:
+
+     int PyObject_DelAttrString(PyObject *o, char *attr_name);
+
+	 Delete attribute named attr_name, for object o. Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: del o.attr_name.
+
+       */
+#define  PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A),NULL)
+
+     /* implemented as a macro:
+
+     int PyObject_DelAttr(PyObject *o, PyObject *attr_name);
+
+	 Delete attribute named attr_name, for object o. Returns -1
+	 on failure.  This is the equivalent of the Python
+	 statement: del o.attr_name.
+
+       */
+#define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A),NULL)
+
+     PyAPI_FUNC(int) PyObject_Cmp(PyObject *o1, PyObject *o2, int *result);
+
+       /*
+	 Compare the values of o1 and o2 using a routine provided by
+	 o1, if one exists, otherwise with a routine provided by o2.
+	 The result of the comparison is returned in result.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: result=cmp(o1,o2).
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Compare(PyObject *o1, PyObject *o2);
+
+	 Compare the values of o1 and o2 using a routine provided by
+	 o1, if one exists, otherwise with a routine provided by o2.
+	 Returns the result of the comparison on success.  On error,
+	 the value returned is undefined. This is equivalent to the
+	 Python expression: cmp(o1,o2).
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Repr(PyObject *o);
+
+	 Compute the string representation of object, o.  Returns the
+	 string representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: repr(o).
+
+	 Called by the repr() built-in function and by reverse quotes.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Str(PyObject *o);
+
+	 Compute the string representation of object, o.  Returns the
+	 string representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: str(o).)
+
+	 Called by the str() built-in function and by the print
+	 statement.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Unicode(PyObject *o);
+
+	 Compute the unicode representation of object, o.  Returns the
+	 unicode representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: unistr(o).)
+
+	 Called by the unistr() built-in function.
+
+       */
+
+     PyAPI_FUNC(int) PyCallable_Check(PyObject *o);
+
+       /*
+	 Determine if the object, o, is callable.  Return 1 if the
+	 object is callable and 0 otherwise.
+
+	 This function always succeeds.
+
+       */
+
+
+
+     PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable_object,
+					 PyObject *args, PyObject *kw);
+
+       /*
+	 Call a callable Python object, callable_object, with
+	 arguments and keywords arguments.  The 'args' argument can not be
+	 NULL, but the 'kw' argument can be NULL.
+
+       */
+     
+     PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable_object,
+                                               PyObject *args);
+
+       /*
+	 Call a callable Python object, callable_object, with
+	 arguments given by the tuple, args.  If no arguments are
+	 needed, then args may be NULL.  Returns the result of the
+	 call on success, or NULL on failure.  This is the equivalent
+	 of the Python expression: apply(o,args).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable_object,
+                                                 char *format, ...);
+
+       /*
+	 Call a callable Python object, callable_object, with a
+	 variable number of C arguments. The C arguments are described
+	 using a mkvalue-style format string. The format may be NULL,
+	 indicating that no arguments are provided.  Returns the
+	 result of the call on success, or NULL on failure.  This is
+	 the equivalent of the Python expression: apply(o,args).
+
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *o, char *m,
+                                               char *format, ...);
+
+       /*
+	 Call the method named m of object o with a variable number of
+	 C arguments.  The C arguments are described by a mkvalue
+	 format string.  The format may be NULL, indicating that no
+	 arguments are provided. Returns the result of the call on
+	 success, or NULL on failure.  This is the equivalent of the
+	 Python expression: o.method(args).
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
+                                                        ...);
+
+       /*
+	 Call a callable Python object, callable_object, with a
+	 variable number of C arguments.  The C arguments are provided
+	 as PyObject * values, terminated by a NULL.  Returns the
+	 result of the call on success, or NULL on failure.  This is
+	 the equivalent of the Python expression: apply(o,args).
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(PyObject *o,
+                                                      PyObject *m, ...);
+
+       /*
+	 Call the method named m of object o with a variable number of
+	 C arguments.  The C arguments are provided as PyObject *
+	 values, terminated by NULL.  Returns the result of the call
+	 on success, or NULL on failure.  This is the equivalent of
+	 the Python expression: o.method(args).
+       */
+
+
+     /* Implemented elsewhere:
+
+     long PyObject_Hash(PyObject *o);
+
+         Compute and return the hash, hash_value, of an object, o.  On
+	 failure, return -1.  This is the equivalent of the Python
+	 expression: hash(o).
+
+       */
+
+
+     /* Implemented elsewhere:
+
+     int PyObject_IsTrue(PyObject *o);
+
+	 Returns 1 if the object, o, is considered to be true, 0 if o is
+	 considered to be false and -1 on failure. This is equivalent to the
+	 Python expression: not not o
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Not(PyObject *o);
+
+	 Returns 0 if the object, o, is considered to be true, 1 if o is
+	 considered to be false and -1 on failure. This is equivalent to the
+	 Python expression: not o
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
+
+       /*
+	 On success, returns a type object corresponding to the object
+	 type of object o. On failure, returns NULL.  This is
+	 equivalent to the Python expression: type(o).
+       */
+
+     PyAPI_FUNC(int) PyObject_Size(PyObject *o);
+
+       /*
+         Return the size of object o.  If the object, o, provides
+	 both sequence and mapping protocols, the sequence size is
+	 returned. On error, -1 is returned.  This is the equivalent
+	 to the Python expression: len(o).
+
+       */
+
+       /* For DLL compatibility */
+#undef PyObject_Length
+     PyAPI_FUNC(int) PyObject_Length(PyObject *o);
+#define PyObject_Length PyObject_Size
+
+
+     PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
+
+       /*
+	 Return element of o corresponding to the object, key, or NULL
+	 on failure. This is the equivalent of the Python expression:
+	 o[key].
+
+       */
+
+     PyAPI_FUNC(int) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);
+
+       /*
+	 Map the object, key, to the value, v.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[key]=v.
+       */
+
+     PyAPI_FUNC(int) PyObject_DelItemString(PyObject *o, char *key);
+
+       /*
+         Remove the mapping for object, key, from the object *o.
+         Returns -1 on failure.  This is equivalent to
+         the Python statement: del o[key].
+       */
+
+     PyAPI_FUNC(int) PyObject_DelItem(PyObject *o, PyObject *key);
+
+       /*
+	 Delete the mapping for key from *o.  Returns -1 on failure.
+	 This is the equivalent of the Python statement: del o[key].
+       */
+
+     PyAPI_FUNC(int) PyObject_AsCharBuffer(PyObject *obj,
+					  const char **buffer,
+					  int *buffer_len);
+
+       /* 
+	  Takes an arbitrary object which must support the (character,
+	  single segment) buffer interface and returns a pointer to a
+	  read-only memory location useable as character based input
+	  for subsequent processing.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurs. Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+     PyAPI_FUNC(int) PyObject_CheckReadBuffer(PyObject *obj);
+
+      /*  
+	  Checks whether an arbitrary object supports the (character,
+	  single segment) buffer interface.  Returns 1 on success, 0
+	  on failure.
+
+      */
+
+     PyAPI_FUNC(int) PyObject_AsReadBuffer(PyObject *obj,
+					  const void **buffer,
+					  int *buffer_len);
+
+       /* 
+	  Same as PyObject_AsCharBuffer() except that this API expects
+	  (readable, single segment) buffer interface and returns a
+	  pointer to a read-only memory location which can contain
+	  arbitrary data.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurrs.  Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+     PyAPI_FUNC(int) PyObject_AsWriteBuffer(PyObject *obj,
+					   void **buffer,
+					   int *buffer_len);
+
+       /* 
+	  Takes an arbitrary object which must support the (writeable,
+	  single segment) buffer interface and returns a pointer to a
+	  writeable memory location in buffer of size buffer_len.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurrs. Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+/* Iterators */
+
+     PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
+     /* Takes an object and returns an iterator for it.
+        This is typically a new iterator but if the argument
+	is an iterator, this returns itself. */
+
+#define PyIter_Check(obj) \
+    (PyType_HasFeature((obj)-&gt;ob_type, Py_TPFLAGS_HAVE_ITER) &amp;&amp; \
+     (obj)-&gt;ob_type-&gt;tp_iternext != NULL)
+
+     PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
+     /* Takes an iterator object and calls its tp_iternext slot,
+	returning the next value.  If the iterator is exhausted,
+	this returns NULL without setting an exception.
+	NULL with an exception means an error occurred. */
+
+/*  Number Protocol:*/
+
+     PyAPI_FUNC(int) PyNumber_Check(PyObject *o);
+
+       /*
+         Returns 1 if the object, o, provides numeric protocols, and
+	 false otherwise. 
+
+	 This function always succeeds.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of adding o1 and o2, or null on failure.
+	 This is the equivalent of the Python expression: o1+o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of subtracting o2 from o1, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1-o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of multiplying o1 and o2, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1*o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Divide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2, or null on failure.
+	 This is the equivalent of the Python expression: o1/o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving an integral result,
+	 or null on failure.
+	 This is the equivalent of the Python expression: o1//o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving a float result,
+	 or null on failure.
+	 This is the equivalent of the Python expression: o1/o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the remainder of dividing o1 by o2, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1%o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
+
+       /*
+	 See the built-in function divmod.  Returns NULL on failure.
+	 This is the equivalent of the Python expression:
+	 divmod(o1,o2).
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
+                                          PyObject *o3);
+
+       /*
+	 See the built-in function pow.  Returns NULL on failure.
+	 This is the equivalent of the Python expression:
+	 pow(o1,o2,o3), where o3 is optional.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
+
+       /*
+	 Returns the negation of o on success, or null on failure.
+	 This is the equivalent of the Python expression: -o.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
+
+       /*
+         Returns the (what?) of o on success, or NULL on failure.
+	 This is the equivalent of the Python expression: +o.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
+
+       /*
+	 Returns the absolute value of o, or null on failure.  This is
+	 the equivalent of the Python expression: abs(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
+
+       /*
+	 Returns the bitwise negation of o on success, or NULL on
+	 failure.  This is the equivalent of the Python expression:
+	 ~o.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of left shifting o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1 &lt;&lt; o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of right shifting o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1 &gt;&gt; o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise and of o1 and o2 on success, or
+	 NULL on failure. This is the equivalent of the Python
+	 expression: o1&amp;o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the bitwise exclusive or of o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1^o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise or on o1 and o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1|o2.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyNumber_Coerce(PyObject **p1, PyObject **p2);
+
+	 This function takes the addresses of two variables of type
+	 PyObject*.
+
+	 If the objects pointed to by *p1 and *p2 have the same type,
+	 increment their reference count and return 0 (success).
+	 If the objects can be converted to a common numeric type,
+	 replace *p1 and *p2 by their converted value (with 'new'
+	 reference counts), and return 0.
+	 If no conversion is possible, or if some other error occurs,
+	 return -1 (failure) and don't increment the reference counts.
+	 The call PyNumber_Coerce(&amp;o1, &amp;o2) is equivalent to the Python
+	 statement o1, o2 = coerce(o1, o2).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Int(PyObject *o);
+
+       /*
+	 Returns the o converted to an integer object on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: int(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
+
+       /*
+	 Returns the o converted to a long integer object on success,
+	 or NULL on failure.  This is the equivalent of the Python
+	 expression: long(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
+
+       /*
+	 Returns the o converted to a float object on success, or NULL
+	 on failure.  This is the equivalent of the Python expression:
+	 float(o).
+       */
+	 
+/*  In-place variants of (some of) the above number protocol functions */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of adding o2 to o1, possibly in-place, or null
+	 on failure.  This is the equivalent of the Python expression:
+	 o1 += o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of subtracting o2 from o1, possibly in-place or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 -= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of multiplying o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 *= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2, possibly in-place, or null
+	 on failure.  This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
+						       PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving an integral result,
+	 possibly in-place, or null on failure.
+	 This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
+						      PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving a float result,
+	 possibly in-place, or null on failure.
+	 This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the remainder of dividing o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 %= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
+     						 PyObject *o3);
+
+       /*
+	 Returns the result of raising o1 to the power of o2, possibly
+	 in-place, or null on failure.  This is the equivalent of the Python
+	 expression: o1 **= o2, or pow(o1, o2, o3) if o3 is present.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of left shifting o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 &lt;&lt;= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of right shifting o1 by o2, possibly in-place or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 &gt;&gt;= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise and of o1 and o2, possibly in-place,
+	 or null on failure. This is the equivalent of the Python
+	 expression: o1 &amp;= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the bitwise exclusive or of o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 ^= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise or of o1 and o2, possibly in-place,
+	 or null on failure.  This is the equivalent of the Python
+	 expression: o1 |= o2.
+
+       */
+
+
+/*  Sequence protocol:*/
+
+     PyAPI_FUNC(int) PySequence_Check(PyObject *o);
+
+       /*
+         Return 1 if the object provides sequence protocol, and zero
+	 otherwise.  
+
+	 This function always succeeds.
+
+       */
+
+     PyAPI_FUNC(int) PySequence_Size(PyObject *o);
+
+       /*
+         Return the size of sequence object o, or -1 on failure.
+
+       */
+
+       /* For DLL compatibility */
+#undef PySequence_Length
+     PyAPI_FUNC(int) PySequence_Length(PyObject *o);
+#define PySequence_Length PySequence_Size
+
+
+     PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
+
+       /*
+	 Return the concatenation of o1 and o2 on success, and NULL on
+	 failure.   This is the equivalent of the Python
+	 expression: o1+o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, int count);
+
+       /*
+	 Return the result of repeating sequence object o count times,
+	 or NULL on failure.  This is the equivalent of the Python
+	 expression: o1*count.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, int i);
+
+       /*
+	 Return the ith element of o, or NULL on failure. This is the
+	 equivalent of the Python expression: o[i].
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, int i1, int i2);
+
+       /*
+	 Return the slice of sequence object o between i1 and i2, or
+	 NULL on failure. This is the equivalent of the Python
+	 expression: o[i1:i2].
+
+       */
+
+     PyAPI_FUNC(int) PySequence_SetItem(PyObject *o, int i, PyObject *v);
+
+       /*
+	 Assign object v to the ith element of o.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[i]=v.
+
+       */
+
+     PyAPI_FUNC(int) PySequence_DelItem(PyObject *o, int i);
+
+       /*
+	 Delete the ith element of object v.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: del o[i].
+       */
+
+     PyAPI_FUNC(int) PySequence_SetSlice(PyObject *o, int i1, int i2,
+                                        PyObject *v);
+
+       /*
+         Assign the sequence object, v, to the slice in sequence
+	 object, o, from i1 to i2.  Returns -1 on failure. This is the
+	 equivalent of the Python statement: o[i1:i2]=v.
+       */
+
+     PyAPI_FUNC(int) PySequence_DelSlice(PyObject *o, int i1, int i2);
+
+       /*
+	 Delete the slice in sequence object, o, from i1 to i2.
+	 Returns -1 on failure. This is the equivalent of the Python
+	 statement: del o[i1:i2].
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
+
+       /*
+	 Returns the sequence, o, as a tuple on success, and NULL on failure.
+	 This is equivalent to the Python expression: tuple(o)
+       */
+
+
+     PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
+       /*
+	 Returns the sequence, o, as a list on success, and NULL on failure.
+	 This is equivalent to the Python expression: list(o)
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
+       /*
+         Returns the sequence, o, as a tuple, unless it's already a
+         tuple or list.  Use PySequence_Fast_GET_ITEM to access the
+         members of this list, and PySequence_Fast_GET_SIZE to get its length.
+
+         Returns NULL on failure.  If the object does not support iteration,
+         raises a TypeError exception with m as the message text.
+       */
+
+#define PySequence_Fast_GET_SIZE(o) \
+	(PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
+       /*
+	 Return the size of o, assuming that o was returned by
+         PySequence_Fast and is not NULL.
+       */
+
+#define PySequence_Fast_GET_ITEM(o, i)\
+     (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
+       /*
+	 Return the ith element of o, assuming that o was returned by
+         PySequence_Fast, and that i is within bounds.
+       */
+
+#define PySequence_ITEM(o, i)\
+	( o-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item(o, i) )
+       /* Assume tp_as_sequence and sq_item exist and that i does not
+	  need to be corrected for a negative index
+       */     
+
+#define PySequence_Fast_ITEMS(sf) \
+	(PyList_Check(sf) ? ((PyListObject *)(sf))-&gt;ob_item \
+			  : ((PyTupleObject *)(sf))-&gt;ob_item)
+	/* Return a pointer to the underlying item array for
+           an object retured by PySequence_Fast */
+
+     PyAPI_FUNC(int) PySequence_Count(PyObject *o, PyObject *value);
+
+       /*
+         Return the number of occurrences on value on o, that is,
+	 return the number of keys for which o[key]==value.  On
+	 failure, return -1.  This is equivalent to the Python
+	 expression: o.count(value).
+       */
+
+     PyAPI_FUNC(int) PySequence_Contains(PyObject *seq, PyObject *ob);
+       /*
+         Return -1 if error; 1 if ob in seq; 0 if ob not in seq.
+         Use __contains__ if possible, else _PySequence_IterSearch().
+       */
+
+#define PY_ITERSEARCH_COUNT    1
+#define PY_ITERSEARCH_INDEX    2
+#define PY_ITERSEARCH_CONTAINS 3
+     PyAPI_FUNC(int) _PySequence_IterSearch(PyObject *seq, PyObject *obj,
+     		    int operation);
+	/*
+	  Iterate over seq.  Result depends on the operation:
+	  PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
+	  	error.
+	  PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
+	  	obj in seq; set ValueError and return -1 if none found;
+	  	also return -1 on error.
+	  PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
+	  	error.
+	*/
+
+/* For DLL-level backwards compatibility */
+#undef PySequence_In
+     PyAPI_FUNC(int) PySequence_In(PyObject *o, PyObject *value);
+
+/* For source-level backwards compatibility */
+#define PySequence_In PySequence_Contains
+
+       /*
+	 Determine if o contains value.  If an item in o is equal to
+	 X, return 1, otherwise return 0.  On error, return -1.  This
+	 is equivalent to the Python expression: value in o.
+       */
+
+     PyAPI_FUNC(int) PySequence_Index(PyObject *o, PyObject *value);
+
+       /*
+	 Return the first index for which o[i]=value.  On error,
+	 return -1.    This is equivalent to the Python
+	 expression: o.index(value).
+       */
+
+/* In-place versions of some of the above Sequence functions. */
+
+     PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
+
+       /*
+	 Append o2 to o1, in-place when possible. Return the resulting
+	 object, which could be o1, or NULL on failure.  This is the
+	 equivalent of the Python expression: o1 += o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, int count);
+
+       /*
+	 Repeat o1 by count, in-place when possible. Return the resulting
+	 object, which could be o1, or NULL on failure.  This is the
+	 equivalent of the Python expression: o1 *= count.
+
+       */
+
+/*  Mapping protocol:*/
+
+     PyAPI_FUNC(int) PyMapping_Check(PyObject *o);
+
+       /*
+         Return 1 if the object provides mapping protocol, and zero
+	 otherwise.  
+
+	 This function always succeeds.
+       */
+
+     PyAPI_FUNC(int) PyMapping_Size(PyObject *o);
+
+       /*
+         Returns the number of keys in object o on success, and -1 on
+	 failure.  For objects that do not provide sequence protocol,
+	 this is equivalent to the Python expression: len(o).
+       */
+
+       /* For DLL compatibility */
+#undef PyMapping_Length
+     PyAPI_FUNC(int) PyMapping_Length(PyObject *o);
+#define PyMapping_Length PyMapping_Size
+
+
+     /* implemented as a macro:
+
+     int PyMapping_DelItemString(PyObject *o, char *key);
+
+	 Remove the mapping for object, key, from the object *o.
+	 Returns -1 on failure.  This is equivalent to
+	 the Python statement: del o[key].
+       */
+#define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))
+
+     /* implemented as a macro:
+
+     int PyMapping_DelItem(PyObject *o, PyObject *key);
+
+	 Remove the mapping for object, key, from the object *o.
+	 Returns -1 on failure.  This is equivalent to
+	 the Python statement: del o[key].
+       */
+#define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))
+
+     PyAPI_FUNC(int) PyMapping_HasKeyString(PyObject *o, char *key);
+
+       /*
+	 On success, return 1 if the mapping object has the key, key,
+	 and 0 otherwise.  This is equivalent to the Python expression:
+	 o.has_key(key). 
+
+	 This function always succeeds.
+       */
+
+     PyAPI_FUNC(int) PyMapping_HasKey(PyObject *o, PyObject *key);
+
+       /*
+	 Return 1 if the mapping object has the key, key,
+	 and 0 otherwise.  This is equivalent to the Python expression:
+	 o.has_key(key). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Keys(PyObject *o);
+
+         On success, return a list of the keys in object o.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.keys().
+       */
+#define PyMapping_Keys(O) PyObject_CallMethod(O,&quot;keys&quot;,NULL)
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Values(PyObject *o);
+
+         On success, return a list of the values in object o.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.values().
+       */
+#define PyMapping_Values(O) PyObject_CallMethod(O,&quot;values&quot;,NULL)
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Items(PyObject *o);
+
+         On success, return a list of the items in object o, where
+	 each item is a tuple containing a key-value pair.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.items().
+
+       */
+#define PyMapping_Items(O) PyObject_CallMethod(O,&quot;items&quot;,NULL)
+
+     PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o, char *key);
+
+       /*
+	 Return element of o corresponding to the object, key, or NULL
+	 on failure. This is the equivalent of the Python expression:
+	 o[key].
+       */
+
+     PyAPI_FUNC(int) PyMapping_SetItemString(PyObject *o, char *key,
+                                            PyObject *value);
+
+       /*
+	 Map the object, key, to the value, v.  Returns 
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[key]=v.
+      */
+
+
+PyAPI_FUNC(int) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);
+      /* isinstance(object, typeorclass) */
+
+PyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
+      /* issubclass(object, typeorclass) */
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* Py_ABSTRACTOBJECT_H */

Added: trunk/msvc-libs/include/allegro/3d.h
===================================================================
--- trunk/msvc-libs/include/allegro/3d.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/3d.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,104 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      3D polygon drawing routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_3D_H
+#define ALLEGRO_3D_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;fixed.h&quot;
+
+struct BITMAP;
+
+typedef struct V3D                  /* a 3d point (fixed point version) */
+{
+   fixed x, y, z;                   /* position */
+   fixed u, v;                      /* texture map coordinates */
+   int c;                           /* color */
+} V3D;
+
+
+typedef struct V3D_f                /* a 3d point (floating point version) */
+{
+   float x, y, z;                   /* position */
+   float u, v;                      /* texture map coordinates */
+   int c;                           /* color */
+} V3D_f;
+
+
+#define POLYTYPE_FLAT               0
+#define POLYTYPE_GCOL               1
+#define POLYTYPE_GRGB               2
+#define POLYTYPE_ATEX               3
+#define POLYTYPE_PTEX               4
+#define POLYTYPE_ATEX_MASK          5
+#define POLYTYPE_PTEX_MASK          6
+#define POLYTYPE_ATEX_LIT           7
+#define POLYTYPE_PTEX_LIT           8
+#define POLYTYPE_ATEX_MASK_LIT      9
+#define POLYTYPE_PTEX_MASK_LIT      10
+#define POLYTYPE_ATEX_TRANS         11
+#define POLYTYPE_PTEX_TRANS         12
+#define POLYTYPE_ATEX_MASK_TRANS    13
+#define POLYTYPE_PTEX_MASK_TRANS    14
+#define POLYTYPE_MAX                15
+#define POLYTYPE_ZBUF               16
+
+AL_VAR(float, scene_gap);
+
+AL_FUNC(void, polygon3d, (struct BITMAP *bmp, int type, struct BITMAP *texture, int vc, V3D *vtx[]));
+AL_FUNC(void, polygon3d_f, (struct BITMAP *bmp, int type, struct BITMAP *texture, int vc, V3D_f *vtx[]));
+AL_FUNC(void, triangle3d, (struct BITMAP *bmp, int type, struct BITMAP *texture, V3D *v1, V3D *v2, V3D *v3));
+AL_FUNC(void, triangle3d_f, (struct BITMAP *bmp, int type, struct BITMAP *texture, V3D_f *v1, V3D_f *v2, V3D_f *v3));
+AL_FUNC(void, quad3d, (struct BITMAP *bmp, int type, struct BITMAP *texture, V3D *v1, V3D *v2, V3D *v3, V3D *v4));
+AL_FUNC(void, quad3d_f, (struct BITMAP *bmp, int type, struct BITMAP *texture, V3D_f *v1, V3D_f *v2, V3D_f *v3, V3D_f *v4));
+AL_FUNC(int, clip3d, (int type, fixed min_z, fixed max_z, int vc, AL_CONST V3D *vtx[], V3D *vout[], V3D *vtmp[], int out[]));
+AL_FUNC(int, clip3d_f, (int type, float min_z, float max_z, int vc, AL_CONST V3D_f *vtx[], V3D_f *vout[], V3D_f *vtmp[], int out[]));
+
+AL_FUNC(fixed, polygon_z_normal, (AL_CONST V3D *v1, AL_CONST V3D *v2, AL_CONST V3D *v3));
+AL_FUNC(float, polygon_z_normal_f, (AL_CONST V3D_f *v1, AL_CONST V3D_f *v2, AL_CONST V3D_f *v3));
+
+/* Note: You are not supposed to mix ZBUFFER with BITMAP even though it is
+ * currently possible. This is just the internal representation, and it may
+ * change in the future.
+ */
+typedef struct BITMAP ZBUFFER;
+
+AL_FUNC(ZBUFFER *, create_zbuffer, (struct BITMAP *bmp));
+AL_FUNC(ZBUFFER *, create_sub_zbuffer, (ZBUFFER *parent, int x, int y, int width, int height));
+AL_FUNC(void, set_zbuffer, (ZBUFFER *zbuf));
+AL_FUNC(void, clear_zbuffer, (ZBUFFER *zbuf, float z));
+AL_FUNC(void, destroy_zbuffer, (ZBUFFER *zbuf));
+
+AL_FUNC(int, create_scene, (int nedge, int npoly));
+AL_FUNC(void, clear_scene, (struct BITMAP* bmp));
+AL_FUNC(void, destroy_scene, (void));
+AL_FUNC(int, scene_polygon3d, (int type, struct BITMAP *texture, int vx, V3D *vtx[]));
+AL_FUNC(int, scene_polygon3d_f, (int type, struct BITMAP *texture, int vx, V3D_f *vtx[]));
+AL_FUNC(void, render_scene, (void));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_3D_H */
+
+

Added: trunk/msvc-libs/include/allegro/3dmaths.h
===================================================================
--- trunk/msvc-libs/include/allegro/3dmaths.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/3dmaths.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,64 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      3D oriented math routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_3DMATHS_H
+#define ALLEGRO_3DMATHS_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;fixed.h&quot;
+
+struct QUAT;
+struct MATRIX_f;
+
+AL_FUNC(fixed, vector_length, (fixed x, fixed y, fixed z));
+AL_FUNC(float, vector_length_f, (float x, float y, float z));
+
+AL_FUNC(void, normalize_vector, (fixed *x, fixed *y, fixed *z));
+AL_FUNC(void, normalize_vector_f, (float *x, float *y, float *z));
+
+AL_FUNC(void, cross_product, (fixed x1, fixed y1, fixed z1, fixed x2, fixed y2, fixed z2, fixed *xout, fixed *yout, fixed *zout));
+AL_FUNC(void, cross_product_f, (float x1, float y1, float z1, float x2, float y2, float z2, float *xout, float *yout, float *zout));
+
+AL_VAR(fixed, _persp_xscale);
+AL_VAR(fixed, _persp_yscale);
+AL_VAR(fixed, _persp_xoffset);
+AL_VAR(fixed, _persp_yoffset);
+
+AL_VAR(float, _persp_xscale_f);
+AL_VAR(float, _persp_yscale_f);
+AL_VAR(float, _persp_xoffset_f);
+AL_VAR(float, _persp_yoffset_f);
+
+AL_FUNC(void, set_projection_viewport, (int x, int y, int w, int h));
+
+AL_FUNC(void, quat_to_matrix, (AL_CONST struct QUAT *q, struct MATRIX_f *m));
+AL_FUNC(void, matrix_to_quat, (AL_CONST struct MATRIX_f *m, struct QUAT *q));
+
+#include &quot;inline/3dmaths.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_3DMATHS_H */
+
+

Added: trunk/msvc-libs/include/allegro/alcompat.h
===================================================================
--- trunk/msvc-libs/include/allegro/alcompat.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/alcompat.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,146 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Backward compatibility stuff.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_COMPAT_H
+#define ALLEGRO_COMPAT_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+#ifndef ALLEGRO_NO_CLEAR_BITMAP_ALIAS
+   #if (defined ALLEGRO_GCC)
+      static __attribute__((unused)) __inline__ void clear(BITMAP *bmp)
+      {
+         clear_bitmap(bmp);
+      }
+   #else
+      static INLINE void clear(BITMAP *bmp)
+      {
+         clear_bitmap(bmp);
+      }
+   #endif
+#endif
+
+#ifndef ALLEGRO_NO_FIX_ALIASES
+   #if (defined ALLEGRO_GCC)
+      #define AL_ALIAS(DECL, CALL)                      \
+      static __attribute__((unused)) __inline__ DECL    \
+      {                                                 \
+         return CALL;                                   \
+      }
+   #else
+      #define AL_ALIAS(DECL, CALL)              \
+      static INLINE DECL                        \
+      {                                         \
+         return CALL;                           \
+      }
+   #endif
+   AL_ALIAS(fixed fadd(fixed x, fixed y), fixadd(x, y))
+   AL_ALIAS(fixed fsub(fixed x, fixed y), fixsub(x, y))
+   AL_ALIAS(fixed fmul(fixed x, fixed y), fixmul(x, y))
+   AL_ALIAS(fixed fdiv(fixed x, fixed y), fixdiv(x, y))
+   AL_ALIAS(int fceil(fixed x), fixceil(x))
+   AL_ALIAS(int ffloor(fixed x), fixfloor(x))
+   AL_ALIAS(fixed fcos(fixed x), fixcos(x))
+   AL_ALIAS(fixed fsin(fixed x), fixsin(x))
+   AL_ALIAS(fixed ftan(fixed x), fixtan(x))
+   AL_ALIAS(fixed facos(fixed x), fixacos(x))
+   AL_ALIAS(fixed fasin(fixed x), fixasin(x))
+   AL_ALIAS(fixed fatan(fixed x), fixatan(x))
+   AL_ALIAS(fixed fatan2(fixed y, fixed x), fixatan2(y, x))
+   AL_ALIAS(fixed fsqrt(fixed x), fixsqrt(x))
+   AL_ALIAS(fixed fhypot(fixed x, fixed y), fixhypot(x, y))
+   #undef AL_ALIAS
+#endif
+
+#define KB_NORMAL       1
+#define KB_EXTENDED     2
+
+#define SEND_MESSAGE        object_message
+
+#define cpu_fpu         (cpu_capabilities &amp; CPU_FPU)
+#define cpu_mmx         (cpu_capabilities &amp; CPU_MMX)
+#define cpu_3dnow       (cpu_capabilities &amp; CPU_3DNOW)
+#define cpu_cpuid       (cpu_capabilities &amp; CPU_ID)
+
+#define joy_x           (joy[0].stick[0].axis[0].pos)
+#define joy_y           (joy[0].stick[0].axis[1].pos)
+#define joy_left        (joy[0].stick[0].axis[0].d1)
+#define joy_right       (joy[0].stick[0].axis[0].d2)
+#define joy_up          (joy[0].stick[0].axis[1].d1)
+#define joy_down        (joy[0].stick[0].axis[1].d2)
+#define joy_b1          (joy[0].button[0].b)
+#define joy_b2          (joy[0].button[1].b)
+#define joy_b3          (joy[0].button[2].b)
+#define joy_b4          (joy[0].button[3].b)
+#define joy_b5          (joy[0].button[4].b)
+#define joy_b6          (joy[0].button[5].b)
+#define joy_b7          (joy[0].button[6].b)
+#define joy_b8          (joy[0].button[7].b)
+
+#define joy2_x          (joy[1].stick[0].axis[0].pos)
+#define joy2_y          (joy[1].stick[0].axis[1].pos)
+#define joy2_left       (joy[1].stick[0].axis[0].d1)
+#define joy2_right      (joy[1].stick[0].axis[0].d2)
+#define joy2_up         (joy[1].stick[0].axis[1].d1)
+#define joy2_down       (joy[1].stick[0].axis[1].d2)
+#define joy2_b1         (joy[1].button[0].b)
+#define joy2_b2         (joy[1].button[1].b)
+
+#define joy_throttle    (joy[0].stick[2].axis[0].pos)
+
+#define joy_hat         ((joy[0].stick[1].axis[0].d1) ? 1 :             \
+                           ((joy[0].stick[1].axis[0].d2) ? 3 :          \
+                              ((joy[0].stick[1].axis[1].d1) ? 4 :       \
+                                 ((joy[0].stick[1].axis[1].d2) ? 2 :    \
+                                    0))))
+
+#define JOY_HAT_CENTRE        0
+#define JOY_HAT_CENTER        0
+#define JOY_HAT_LEFT          1
+#define JOY_HAT_DOWN          2
+#define JOY_HAT_RIGHT         3
+#define JOY_HAT_UP            4
+
+
+/* in case you want to spell 'palette' as 'pallete' */
+#define PALLETE                        PALETTE
+#define black_pallete                  black_palette
+#define desktop_pallete                desktop_palette
+#define set_pallete                    set_palette
+#define get_pallete                    get_palette
+#define set_pallete_range              set_palette_range
+#define get_pallete_range              get_palette_range
+#define fli_pallete                    fli_palette
+#define pallete_color                  palette_color
+#define DAT_PALLETE                    DAT_PALETTE
+#define select_pallete                 select_palette
+#define unselect_pallete               unselect_palette
+#define generate_332_pallete           generate_332_palette
+#define generate_optimised_pallete     generate_optimised_palette
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_COMPAT_H */
+
+

Added: trunk/msvc-libs/include/allegro/alinline.h
===================================================================
--- trunk/msvc-libs/include/allegro/alinline.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/alinline.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,39 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include &quot;inline/system.inl&quot;
+
+#include &quot;inline/gfx.inl&quot;
+
+#include &quot;inline/color.inl&quot;
+
+#include &quot;inline/draw.inl&quot;
+
+#include &quot;inline/file.inl&quot;
+
+#include &quot;inline/fmaths.inl&quot;
+
+#include &quot;inline/gui.inl&quot;
+
+#include &quot;inline/3dmaths.inl&quot;
+
+#include &quot;inline/matrix.inl&quot;
+
+#ifndef ALLEGRO_LIB_BUILD
+   #include &quot;alcompat.h&quot;
+#endif

Added: trunk/msvc-libs/include/allegro/base.h
===================================================================
--- trunk/msvc-libs/include/allegro/base.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/base.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,87 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Base header, defines basic stuff needed by pretty much
+ *      everything else.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_BASE_H
+#define ALLEGRO_BASE_H
+
+#ifndef ALLEGRO_NO_STD_HEADERS
+   #include &lt;errno.h&gt;
+   #include &lt;limits.h&gt;
+   #include &lt;stdarg.h&gt;
+   #include &lt;stddef.h&gt;
+   #include &lt;stdlib.h&gt;
+   #include &lt;time.h&gt;
+#endif
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;internal/alconfig.h&quot;
+
+#define ALLEGRO_VERSION          4
+#define ALLEGRO_SUB_VERSION      0
+#define ALLEGRO_WIP_VERSION      3
+#define ALLEGRO_VERSION_STR      &quot;4.0.3&quot;
+#define ALLEGRO_DATE_STR         &quot;2003&quot;
+#define ALLEGRO_DATE             20030419    /* yyyymmdd */
+
+/*******************************************/
+/************ Some global stuff ************/
+/*******************************************/
+
+#ifndef TRUE 
+   #define TRUE         -1
+   #define FALSE        0
+#endif
+
+#undef MIN
+#undef MAX
+#undef MID
+     
+#define MIN(x,y)     (((x) &lt; (y)) ? (x) : (y))
+#define MAX(x,y)     (((x) &gt; (y)) ? (x) : (y))
+#define MID(x,y,z)   MAX((x), MIN((y), (z)))
+     
+#undef ABS
+#define ABS(x)       (((x) &gt;= 0) ? (x) : (-(x)))
+     
+#undef SGN
+#define SGN(x)       (((x) &gt;= 0) ? 1 : -1)
+
+#define AL_PI        3.14159265358979323846
+
+#define AL_ID(a,b,c,d)     (((a)&lt;&lt;24) | ((b)&lt;&lt;16) | ((c)&lt;&lt;8) | (d))
+
+AL_VAR(int *, allegro_errno);
+
+typedef struct _DRIVER_INFO         /* info about a hardware driver */
+{
+   int id;                          /* integer ID */
+   void *driver;                    /* the driver structure */
+   int autodetect;                  /* set to allow autodetection */
+} _DRIVER_INFO;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_BASE_H */
+
+

Added: trunk/msvc-libs/include/allegro/color.h
===================================================================
--- trunk/msvc-libs/include/allegro/color.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/color.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,155 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Color manipulation routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_COLOR_H
+#define ALLEGRO_COLOR_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;palette.h&quot;
+
+struct BITMAP;
+
+AL_VAR(PALETTE, black_palette);
+AL_VAR(PALETTE, desktop_palette);
+AL_VAR(PALETTE, default_palette);
+
+typedef struct {
+   unsigned char data[32][32][32];
+} RGB_MAP;
+
+typedef struct {
+   unsigned char data[PAL_SIZE][PAL_SIZE];
+} COLOR_MAP;
+
+AL_VAR(RGB_MAP *, rgb_map);
+AL_VAR(COLOR_MAP *, color_map);
+
+AL_VAR(PALETTE, _current_palette);
+
+AL_VAR(int, _rgb_r_shift_15);
+AL_VAR(int, _rgb_g_shift_15);
+AL_VAR(int, _rgb_b_shift_15);
+AL_VAR(int, _rgb_r_shift_16);
+AL_VAR(int, _rgb_g_shift_16);
+AL_VAR(int, _rgb_b_shift_16);
+AL_VAR(int, _rgb_r_shift_24);
+AL_VAR(int, _rgb_g_shift_24);
+AL_VAR(int, _rgb_b_shift_24);
+AL_VAR(int, _rgb_r_shift_32);
+AL_VAR(int, _rgb_g_shift_32);
+AL_VAR(int, _rgb_b_shift_32);
+AL_VAR(int, _rgb_a_shift_32);
+
+AL_ARRAY(int, _rgb_scale_5);
+AL_ARRAY(int, _rgb_scale_6);
+
+#define MASK_COLOR_8       0
+#define MASK_COLOR_15      0x7C1F
+#define MASK_COLOR_16      0xF81F
+#define MASK_COLOR_24      0xFF00FF
+#define MASK_COLOR_32      0xFF00FF
+
+AL_VAR(int *, palette_color);
+
+AL_FUNC(void, set_color, (int index, AL_CONST RGB *p));
+AL_FUNC(void, set_palette, (AL_CONST PALETTE p));
+AL_FUNC(void, set_palette_range, (AL_CONST PALETTE p, int from, int to, int retracesync));
+
+AL_FUNC(void, get_color, (int index, RGB *p));
+AL_FUNC(void, get_palette, (PALETTE p));
+AL_FUNC(void, get_palette_range, (PALETTE p, int from, int to));
+
+AL_FUNC(void, fade_interpolate, (AL_CONST PALETTE source, AL_CONST PALETTE dest, PALETTE output, int pos, int from, int to));
+AL_FUNC(void, fade_from_range, (AL_CONST PALETTE source, AL_CONST PALETTE dest, int speed, int from, int to));
+AL_FUNC(void, fade_in_range, (AL_CONST PALETTE p, int speed, int from, int to));
+AL_FUNC(void, fade_out_range, (int speed, int from, int to));
+AL_FUNC(void, fade_from, (AL_CONST PALETTE source, AL_CONST PALETTE dest, int speed));
+AL_FUNC(void, fade_in, (AL_CONST PALETTE p, int speed));
+AL_FUNC(void, fade_out, (int speed));
+
+AL_FUNC(void, select_palette, (AL_CONST PALETTE p));
+AL_FUNC(void, unselect_palette, (void));
+
+AL_FUNC(void, generate_332_palette, (PALETTE pal));
+AL_FUNC(int, generate_optimized_palette, (struct BITMAP *image, PALETTE pal, AL_CONST signed char rsvdcols[256]));
+
+AL_FUNC(void, create_rgb_table, (RGB_MAP *table, AL_CONST PALETTE pal, AL_METHOD(void, callback, (int pos))));
+AL_FUNC(void, create_light_table, (COLOR_MAP *table, AL_CONST PALETTE pal, int r, int g, int b, AL_METHOD(void, callback, (int pos))));
+AL_FUNC(void, create_trans_table, (COLOR_MAP *table, AL_CONST PALETTE pal, int r, int g, int b, AL_METHOD(void, callback, (int pos))));
+AL_FUNC(void, create_color_table, (COLOR_MAP *table, AL_CONST PALETTE pal, AL_METHOD(void, blend, (AL_CONST PALETTE pal, int x, int y, RGB *rgb)), AL_METHOD(void, callback, (int pos))));
+AL_FUNC(void, create_blender_table, (COLOR_MAP *table, AL_CONST PALETTE pal, AL_METHOD(void, callback, (int pos))));
+
+typedef AL_METHOD(unsigned long, BLENDER_FUNC, (unsigned long x, unsigned long y, unsigned long n));
+
+AL_FUNC(void, set_blender_mode, (BLENDER_FUNC b15, BLENDER_FUNC b16, BLENDER_FUNC b24, int r, int g, int b, int a));
+AL_FUNC(void, set_blender_mode_ex, (BLENDER_FUNC b15, BLENDER_FUNC b16, BLENDER_FUNC b24, BLENDER_FUNC b32, BLENDER_FUNC b15x, BLENDER_FUNC b16x, BLENDER_FUNC b24x, int r, int g, int b, int a));
+
+AL_FUNC(void, set_alpha_blender, (void));
+AL_FUNC(void, set_write_alpha_blender, (void));
+AL_FUNC(void, set_trans_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_add_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_burn_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_color_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_difference_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_dissolve_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_dodge_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_hue_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_invert_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_luminance_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_multiply_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_saturation_blender, (int r, int g, int b, int a));
+AL_FUNC(void, set_screen_blender, (int r, int g, int b, int a));
+
+AL_FUNC(void, hsv_to_rgb, (float h, float s, float v, int *r, int *g, int *b));
+AL_FUNC(void, rgb_to_hsv, (int r, int g, int b, float *h, float *s, float *v));
+
+AL_FUNC(int, bestfit_color, (AL_CONST PALETTE pal, int r, int g, int b));
+
+AL_FUNC(int, makecol, (int r, int g, int b));
+AL_FUNC(int, makecol8, (int r, int g, int b));
+AL_FUNC(int, makecol_depth, (int color_depth, int r, int g, int b));
+
+AL_FUNC(int, makeacol, (int r, int g, int b, int a));
+AL_FUNC(int, makeacol_depth, (int color_depth, int r, int g, int b, int a));
+
+AL_FUNC(int, makecol15_dither, (int r, int g, int b, int x, int y));
+AL_FUNC(int, makecol16_dither, (int r, int g, int b, int x, int y));
+
+AL_FUNC(int, getr, (int c));
+AL_FUNC(int, getg, (int c));
+AL_FUNC(int, getb, (int c));
+AL_FUNC(int, geta, (int c));
+
+AL_FUNC(int, getr_depth, (int color_depth, int c));
+AL_FUNC(int, getg_depth, (int color_depth, int c));
+AL_FUNC(int, getb_depth, (int color_depth, int c));
+AL_FUNC(int, geta_depth, (int color_depth, int c));
+
+#include &quot;inline/color.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_COLOR_H */
+
+

Added: trunk/msvc-libs/include/allegro/compiled.h
===================================================================
--- trunk/msvc-libs/include/allegro/compiled.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/compiled.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,62 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Compiled sprites.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_COMPILED_H
+#define ALLEGRO_COMPILED_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+struct BITMAP;
+
+#if (defined ALLEGRO_I386) &amp;&amp; (!defined ALLEGRO_USE_C)
+
+/* compiled sprite structure */
+typedef struct COMPILED_SPRITE
+{
+   short planar;                    /* set if it's a planar (mode-X) sprite */
+   short color_depth;               /* color depth of the image */
+   short w, h;                      /* size of the sprite */
+   struct {
+      void *draw;                   /* routines to draw the image */
+      int len;                      /* length of the drawing functions */
+   } proc[4];
+} COMPILED_SPRITE;
+
+#else
+
+/* emulate compiled sprites using RLE on other platforms */
+struct RLE_SPRITE;
+typedef struct RLE_SPRITE COMPILED_SPRITE;
+
+#endif
+
+AL_FUNC(COMPILED_SPRITE *, get_compiled_sprite, (struct BITMAP *bitmap, int planar));
+AL_FUNC(void, destroy_compiled_sprite, (COMPILED_SPRITE *sprite));
+AL_FUNC(void, draw_compiled_sprite, (struct BITMAP *bmp, AL_CONST COMPILED_SPRITE *sprite, int x, int y));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_COMPILED_H */
+
+

Added: trunk/msvc-libs/include/allegro/config.h
===================================================================
--- trunk/msvc-libs/include/allegro/config.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/config.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,61 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration file access routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_CONFIG_H
+#define ALLEGRO_CONFIG_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+AL_FUNC(void, set_config_file, (AL_CONST char *filename));
+AL_FUNC(void, set_config_data, (AL_CONST char *data, int length));
+AL_FUNC(void, override_config_file, (AL_CONST char *filename));
+AL_FUNC(void, override_config_data, (AL_CONST char *data, int length));
+AL_FUNC(void, flush_config_file, (void));
+AL_FUNC(void, reload_config_texts, (AL_CONST char *new_language));
+
+AL_FUNC(void, push_config_state, (void));
+AL_FUNC(void, pop_config_state, (void));
+
+AL_FUNC(void, hook_config_section, (AL_CONST char *section, AL_METHOD(int, intgetter, (AL_CONST char *, int)), AL_METHOD(AL_CONST char *, stringgetter, (AL_CONST char *, AL_CONST char *)), AL_METHOD(void, stringsetter, (AL_CONST char *, AL_CONST char *))));
+AL_FUNC(int, config_is_hooked, (AL_CONST char *section));
+
+AL_FUNC(AL_CONST char *, get_config_string, (AL_CONST char *section, AL_CONST char *name, AL_CONST char *def));
+AL_FUNC(int, get_config_int, (AL_CONST char *section, AL_CONST char *name, int def));
+AL_FUNC(int, get_config_hex, (AL_CONST char *section, AL_CONST char *name, int def));
+AL_FUNC(float, get_config_float, (AL_CONST char *section, AL_CONST char *name, float def));
+AL_FUNC(int, get_config_id, (AL_CONST char *section, AL_CONST char *name, int def));
+AL_FUNC(char **, get_config_argv, (AL_CONST char *section, AL_CONST char *name, int *argc));
+AL_FUNC(AL_CONST char *, get_config_text, (AL_CONST char *msg));
+
+AL_FUNC(void, set_config_string, (AL_CONST char *section, AL_CONST char *name, AL_CONST char *val));
+AL_FUNC(void, set_config_int, (AL_CONST char *section, AL_CONST char *name, int val));
+AL_FUNC(void, set_config_hex, (AL_CONST char *section, AL_CONST char *name, int val));
+AL_FUNC(void, set_config_float, (AL_CONST char *section, AL_CONST char *name, float val));
+AL_FUNC(void, set_config_id, (AL_CONST char *section, AL_CONST char *name, int val));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_CONFIG_H */
+
+

Added: trunk/msvc-libs/include/allegro/datafile.h
===================================================================
--- trunk/msvc-libs/include/allegro/datafile.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/datafile.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,100 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Datafile access routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_DATAFILE_H
+#define ALLEGRO_DATAFILE_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+struct BITMAP;
+struct PACKFILE;
+struct RGB;
+
+#define DAT_ID(a,b,c,d)    AL_ID(a,b,c,d)
+
+#define DAT_MAGIC          DAT_ID('A','L','L','.')
+#define DAT_FILE           DAT_ID('F','I','L','E')
+#define DAT_DATA           DAT_ID('D','A','T','A')
+#define DAT_FONT           DAT_ID('F','O','N','T')
+#define DAT_SAMPLE         DAT_ID('S','A','M','P')
+#define DAT_MIDI           DAT_ID('M','I','D','I')
+#define DAT_PATCH          DAT_ID('P','A','T',' ')
+#define DAT_FLI            DAT_ID('F','L','I','C')
+#define DAT_BITMAP         DAT_ID('B','M','P',' ')
+#define DAT_RLE_SPRITE     DAT_ID('R','L','E',' ')
+#define DAT_C_SPRITE       DAT_ID('C','M','P',' ')
+#define DAT_XC_SPRITE      DAT_ID('X','C','M','P')
+#define DAT_PALETTE        DAT_ID('P','A','L',' ')
+#define DAT_PROPERTY       DAT_ID('p','r','o','p')
+#define DAT_NAME           DAT_ID('N','A','M','E')
+#define DAT_END            -1
+
+
+typedef struct DATAFILE_PROPERTY
+{
+   char *dat;                          /* pointer to the data */
+   int type;                           /* property type */
+} DATAFILE_PROPERTY;
+
+
+typedef struct DATAFILE
+{
+   void *dat;                          /* pointer to the data */
+   int type;                           /* object type */
+   long size;                          /* size of the object */
+   DATAFILE_PROPERTY *prop;            /* object properties */
+} DATAFILE;
+
+
+AL_FUNC(DATAFILE *, load_datafile, (AL_CONST char *filename));
+AL_FUNC(DATAFILE *, load_datafile_callback, (AL_CONST char *filename, AL_METHOD(void, callback, (DATAFILE *))));
+AL_FUNC(void, unload_datafile, (DATAFILE *dat));
+
+AL_FUNC(DATAFILE *, load_datafile_object, (AL_CONST char *filename, AL_CONST char *objectname));
+AL_FUNC(void, unload_datafile_object, (DATAFILE *dat));
+
+AL_FUNC(DATAFILE *, find_datafile_object, (AL_CONST DATAFILE *dat, AL_CONST char *objectname));
+AL_FUNC(AL_CONST char *, get_datafile_property, (AL_CONST DATAFILE *dat, int type));
+AL_FUNC(void, register_datafile_object, (int id_, AL_METHOD(void *, load, (struct PACKFILE *f, long size)), AL_METHOD(void, destroy, (void *data))));
+
+AL_FUNC(void, fixup_datafile, (DATAFILE *data));
+
+AL_FUNC(struct BITMAP *, load_bitmap, (AL_CONST char *filename, struct RGB *pal));
+AL_FUNC(struct BITMAP *, load_bmp, (AL_CONST char *filename, struct RGB *pal));
+AL_FUNC(struct BITMAP *, load_lbm, (AL_CONST char *filename, struct RGB *pal));
+AL_FUNC(struct BITMAP *, load_pcx, (AL_CONST char *filename, struct RGB *pal));
+AL_FUNC(struct BITMAP *, load_tga, (AL_CONST char *filename, struct RGB *pal));
+
+AL_FUNC(int, save_bitmap, (AL_CONST char *filename, struct BITMAP *bmp, AL_CONST struct RGB *pal));
+AL_FUNC(int, save_bmp, (AL_CONST char *filename, struct BITMAP *bmp, AL_CONST struct RGB *pal));
+AL_FUNC(int, save_pcx, (AL_CONST char *filename, struct BITMAP *bmp, AL_CONST struct RGB *pal));
+AL_FUNC(int, save_tga, (AL_CONST char *filename, struct BITMAP *bmp, AL_CONST struct RGB *pal));
+
+AL_FUNC(void, register_bitmap_file_type, (AL_CONST char *ext, AL_METHOD(struct BITMAP *, load, (AL_CONST char *filename, struct RGB *pal)), AL_METHOD(int, save, (AL_CONST char *filename, struct BITMAP *bmp, AL_CONST struct RGB *pal))));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_DATAFILE_H */
+
+

Added: trunk/msvc-libs/include/allegro/debug.h
===================================================================
--- trunk/msvc-libs/include/allegro/debug.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/debug.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,49 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Debug facilities.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_DEBUG_H
+#define ALLEGRO_DEBUG_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+AL_FUNC(void, al_assert, (AL_CONST char *file, int line));
+AL_PRINTFUNC(void, al_trace, (AL_CONST char *msg, ...), 1, 2);
+
+AL_FUNC(void, register_assert_handler, (AL_METHOD(int, handler, (AL_CONST char *msg))));
+AL_FUNC(void, register_trace_handler, (AL_METHOD(int, handler, (AL_CONST char *msg))));
+
+
+#ifdef DEBUGMODE
+   #define ASSERT(condition)     { if (!(condition)) al_assert(__FILE__, __LINE__); }
+   #define TRACE                 al_trace
+#else
+   #define ASSERT(condition)
+   #define TRACE                 1 ? (void) 0 : al_trace
+#endif
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_DEBUG_H */
+
+

Added: trunk/msvc-libs/include/allegro/digi.h
===================================================================
--- trunk/msvc-libs/include/allegro/digi.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/digi.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,210 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Digital sound routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_DIGI_H
+#define ALLEGRO_DIGI_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+#define DIGI_VOICES           64       /* Theoretical maximums: */
+                                       /* actual drivers may not be */
+                                       /* able to handle this many */
+
+typedef struct SAMPLE                  /* a sample */
+{
+   int bits;                           /* 8 or 16 */
+   int stereo;                         /* sample type flag */
+   int freq;                           /* sample frequency */
+   int priority;                       /* 0-255 */
+   unsigned long len;                  /* length (in samples) */
+   unsigned long loop_start;           /* loop start position */
+   unsigned long loop_end;             /* loop finish position */
+   unsigned long param;                /* for internal use by the driver */
+   void *data;                         /* sample data */
+} SAMPLE;
+
+
+#define DIGI_AUTODETECT       -1       /* for passing to install_sound() */
+#define DIGI_NONE             0
+
+typedef struct DIGI_DRIVER             /* driver for playing digital sfx */
+{
+   int  id;                            /* driver ID code */
+   AL_CONST char *name;                /* driver name */
+   AL_CONST char *desc;                /* description string */
+   AL_CONST char *ascii_name;          /* ASCII format name string */
+   int  voices;                        /* available voices */
+   int  basevoice;                     /* voice number offset */
+   int  max_voices;                    /* maximum voices we can support */
+   int  def_voices;                    /* default number of voices to use */
+
+   /* setup routines */
+   AL_METHOD(int,  detect, (int input));
+   AL_METHOD(int,  init, (int input, int voices));
+   AL_METHOD(void, exit, (int input));
+   AL_METHOD(int,  mixer_volume, (int volume));
+
+   /* for use by the audiostream functions */
+   AL_METHOD(void *, lock_voice, (int voice, int start, int end));
+   AL_METHOD(void, unlock_voice, (int voice));
+   AL_METHOD(int,  buffer_size, (void));
+
+   /* voice control functions */
+   AL_METHOD(void, init_voice, (int voice, AL_CONST SAMPLE *sample));
+   AL_METHOD(void, release_voice, (int voice));
+   AL_METHOD(void, start_voice, (int voice));
+   AL_METHOD(void, stop_voice, (int voice));
+   AL_METHOD(void, loop_voice, (int voice, int playmode));
+
+   /* position control functions */
+   AL_METHOD(int,  get_position, (int voice));
+   AL_METHOD(void, set_position, (int voice, int position));
+
+   /* volume control functions */
+   AL_METHOD(int,  get_volume, (int voice));
+   AL_METHOD(void, set_volume, (int voice, int volume));
+   AL_METHOD(void, ramp_volume, (int voice, int time, int endvol));
+   AL_METHOD(void, stop_volume_ramp, (int voice));
+
+   /* pitch control functions */
+   AL_METHOD(int,  get_frequency, (int voice));
+   AL_METHOD(void, set_frequency, (int voice, int frequency));
+   AL_METHOD(void, sweep_frequency, (int voice, int time, int endfreq));
+   AL_METHOD(void, stop_frequency_sweep, (int voice));
+
+   /* pan control functions */
+   AL_METHOD(int,  get_pan, (int voice));
+   AL_METHOD(void, set_pan, (int voice, int pan));
+   AL_METHOD(void, sweep_pan, (int voice, int time, int endpan));
+   AL_METHOD(void, stop_pan_sweep, (int voice));
+
+   /* effect control functions */
+   AL_METHOD(void, set_echo, (int voice, int strength, int delay));
+   AL_METHOD(void, set_tremolo, (int voice, int rate, int depth));
+   AL_METHOD(void, set_vibrato, (int voice, int rate, int depth));
+
+   /* input functions */
+   int rec_cap_bits;
+   int rec_cap_stereo;
+   AL_METHOD(int,  rec_cap_rate, (int bits, int stereo));
+   AL_METHOD(int,  rec_cap_parm, (int rate, int bits, int stereo));
+   AL_METHOD(int,  rec_source, (int source));
+   AL_METHOD(int,  rec_start, (int rate, int bits, int stereo));
+   AL_METHOD(void, rec_stop, (void));
+   AL_METHOD(int,  rec_read, (void *buf));
+} DIGI_DRIVER;
+
+AL_ARRAY(_DRIVER_INFO, _digi_driver_list);
+
+/* macros for constructing the driver lists */
+#define BEGIN_DIGI_DRIVER_LIST                                 \
+   _DRIVER_INFO _digi_driver_list[] =                          \
+   {
+
+#define END_DIGI_DRIVER_LIST                                   \
+      {  0,                NULL,                0     }        \
+   };
+
+AL_VAR(DIGI_DRIVER *, digi_driver);
+
+AL_VAR(DIGI_DRIVER *, digi_input_driver);
+
+AL_VAR(int, digi_card);
+
+AL_VAR(int, digi_input_card);
+
+AL_FUNC(int, detect_digi_driver, (int driver_id));
+
+
+AL_FUNC(SAMPLE *, load_sample, (AL_CONST char *filename));
+AL_FUNC(SAMPLE *, load_wav, (AL_CONST char *filename));
+AL_FUNC(SAMPLE *, load_voc, (AL_CONST char *filename));
+AL_FUNC(SAMPLE *, create_sample, (int bits, int stereo, int freq, int len));
+AL_FUNC(void, destroy_sample, (SAMPLE *spl));
+
+AL_FUNC(int, play_sample, (AL_CONST SAMPLE *spl, int vol, int pan, int freq, int loop));
+AL_FUNC(void, stop_sample, (AL_CONST SAMPLE *spl));
+AL_FUNC(void, adjust_sample, (AL_CONST SAMPLE *spl, int vol, int pan, int freq, int loop));
+
+AL_FUNC(int, allocate_voice, (AL_CONST SAMPLE *spl));
+AL_FUNC(void, deallocate_voice, (int voice));
+AL_FUNC(void, reallocate_voice, (int voice, AL_CONST SAMPLE *spl));
+AL_FUNC(void, release_voice, (int voice));
+AL_FUNC(void, voice_start, (int voice));
+AL_FUNC(void, voice_stop, (int voice));
+AL_FUNC(void, voice_set_priority, (int voice, int priority));
+AL_FUNC(SAMPLE *, voice_check, (int voice));
+
+#define PLAYMODE_PLAY           0
+#define PLAYMODE_LOOP           1
+#define PLAYMODE_FORWARD        0
+#define PLAYMODE_BACKWARD       2
+#define PLAYMODE_BIDIR          4
+
+AL_FUNC(void, voice_set_playmode, (int voice, int playmode));
+
+AL_FUNC(int, voice_get_position, (int voice));
+AL_FUNC(void, voice_set_position, (int voice, int position));
+
+AL_FUNC(int, voice_get_volume, (int voice));
+AL_FUNC(void, voice_set_volume, (int voice, int volume));
+AL_FUNC(void, voice_ramp_volume, (int voice, int time, int endvol));
+AL_FUNC(void, voice_stop_volumeramp, (int voice));
+
+AL_FUNC(int, voice_get_frequency, (int voice));
+AL_FUNC(void, voice_set_frequency, (int voice, int frequency));
+AL_FUNC(void, voice_sweep_frequency, (int voice, int time, int endfreq));
+AL_FUNC(void, voice_stop_frequency_sweep, (int voice));
+
+AL_FUNC(int, voice_get_pan, (int voice));
+AL_FUNC(void, voice_set_pan, (int voice, int pan));
+AL_FUNC(void, voice_sweep_pan, (int voice, int time, int endpan));
+AL_FUNC(void, voice_stop_pan_sweep, (int voice));
+
+AL_FUNC(void, voice_set_echo, (int voice, int strength, int delay));
+AL_FUNC(void, voice_set_tremolo, (int voice, int rate, int depth));
+AL_FUNC(void, voice_set_vibrato, (int voice, int rate, int depth));
+
+#define SOUND_INPUT_MIC    1
+#define SOUND_INPUT_LINE   2
+#define SOUND_INPUT_CD     3
+
+AL_FUNC(int, get_sound_input_cap_bits, (void));
+AL_FUNC(int, get_sound_input_cap_stereo, (void));
+AL_FUNC(int, get_sound_input_cap_rate, (int bits, int stereo));
+AL_FUNC(int, get_sound_input_cap_parm, (int rate, int bits, int stereo));
+AL_FUNC(int, set_sound_input_source, (int source));
+AL_FUNC(int, start_sound_input, (int rate, int bits, int stereo));
+AL_FUNC(void, stop_sound_input, (void));
+AL_FUNC(int, read_sound_input, (void *buffer));
+
+AL_FUNCPTR(void, digi_recorder, (void));
+
+AL_FUNC(void, lock_sample, (struct SAMPLE *spl));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_DIGI_H */
+
+

Added: trunk/msvc-libs/include/allegro/draw.h
===================================================================
--- trunk/msvc-libs/include/allegro/draw.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/draw.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,70 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Drawing and sprite routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_DRAW_H
+#define ALLEGRO_DRAW_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;fixed.h&quot;
+#include &quot;gfx.h&quot;
+
+#define DRAW_MODE_SOLID             0        /* flags for drawing_mode() */
+#define DRAW_MODE_XOR               1
+#define DRAW_MODE_COPY_PATTERN      2
+#define DRAW_MODE_SOLID_PATTERN     3
+#define DRAW_MODE_MASKED_PATTERN    4
+#define DRAW_MODE_TRANS             5
+
+AL_FUNC(void, drawing_mode, (int mode, struct BITMAP *pattern, int x_anchor, int y_anchor));
+AL_FUNC(void, xor_mode, (int on));
+AL_FUNC(void, solid_mode, (void));
+AL_FUNC(void, do_line, (struct BITMAP *bmp, int x1, int y1, int x2, int y2, int d, AL_METHOD(void, proc, (struct BITMAP *, int, int, int))));
+AL_FUNC(void, triangle, (struct BITMAP *bmp, int x1, int y1, int x2, int y2, int x3, int y3, int color));
+AL_FUNC(void, polygon, (struct BITMAP *bmp, int vertices, AL_CONST int *points, int color));
+AL_FUNC(void, rect, (struct BITMAP *bmp, int x1, int y1, int x2, int y2, int color));
+AL_FUNC(void, do_circle, (struct BITMAP *bmp, int x, int y, int radius, int d, AL_METHOD(void, proc, (struct BITMAP *, int, int, int))));
+AL_FUNC(void, circle, (struct BITMAP *bmp, int x, int y, int radius, int color));
+AL_FUNC(void, circlefill, (struct BITMAP *bmp, int x, int y, int radius, int color));
+AL_FUNC(void, do_ellipse, (struct BITMAP *bmp, int x, int y, int rx, int ry, int d, AL_METHOD(void, proc, (struct BITMAP *, int, int, int))));
+AL_FUNC(void, ellipse, (struct BITMAP *bmp, int x, int y, int rx, int ry, int color));
+AL_FUNC(void, ellipsefill, (struct BITMAP *bmp, int x, int y, int rx, int ry, int color));
+AL_FUNC(void, do_arc, (struct BITMAP *bmp, int x, int y, fixed ang1, fixed ang2, int r, int d, AL_METHOD(void, proc, (struct BITMAP *, int, int, int))));
+AL_FUNC(void, arc, (struct BITMAP *bmp, int x, int y, fixed ang1, fixed ang2, int r, int color));
+AL_FUNC(void, calc_spline, (AL_CONST int points[8], int npts, int *x, int *y));
+AL_FUNC(void, spline, (struct BITMAP *bmp, AL_CONST int points[8], int color));
+AL_FUNC(void, floodfill, (struct BITMAP *bmp, int x, int y, int color));
+AL_FUNC(void, blit, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, masked_blit, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, stretch_blit, (struct BITMAP *s, struct BITMAP *d, int s_x, int s_y, int s_w, int s_h, int d_x, int d_y, int d_w, int d_h));
+AL_FUNC(void, masked_stretch_blit, (struct BITMAP *s, struct BITMAP *d, int s_x, int s_y, int s_w, int s_h, int d_x, int d_y, int d_w, int d_h));
+AL_FUNC(void, stretch_sprite, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y, int w, int h));
+AL_FUNC(void, draw_gouraud_sprite, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y, int c1, int c2, int c3, int c4));
+
+#include &quot;inline/draw.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_DRAW_H */
+
+

Added: trunk/msvc-libs/include/allegro/file.h
===================================================================
--- trunk/msvc-libs/include/allegro/file.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/file.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,128 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      File I/O and compression routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FILE_H
+#define ALLEGRO_FILE_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+AL_FUNC(char *, fix_filename_case, (char *path));
+AL_FUNC(char *, fix_filename_slashes, (char *path));
+AL_FUNC(char *, fix_filename_path, (char *dest, AL_CONST char *path, int size));
+AL_FUNC(char *, replace_filename, (char *dest, AL_CONST char *path, AL_CONST char *filename, int size));
+AL_FUNC(char *, replace_extension, (char *dest, AL_CONST char *filename, AL_CONST char *ext, int size));
+AL_FUNC(char *, append_filename, (char *dest, AL_CONST char *path, AL_CONST char *filename, int size));
+AL_FUNC(char *, get_filename, (AL_CONST char *path));
+AL_FUNC(char *, get_extension, (AL_CONST char *filename));
+AL_FUNC(void, put_backslash, (char *filename));
+AL_FUNC(int, file_exists, (AL_CONST char *filename, int attrib, int *aret));
+AL_FUNC(int, exists, (AL_CONST char *filename));
+AL_FUNC(long, file_size, (AL_CONST char *filename));
+AL_FUNC(time_t, file_time, (AL_CONST char *filename));
+AL_FUNC(int, delete_file, (AL_CONST char *filename));
+AL_FUNC(int, for_each_file, (AL_CONST char *name, int attrib, AL_METHOD(void, callback, (AL_CONST char *filename, int attrib, int param)), int param));
+AL_FUNC(int, find_allegro_resource, (char *dest, AL_CONST char *resource, AL_CONST char *ext, AL_CONST char *datafile, AL_CONST char *objectname, AL_CONST char *envvar, AL_CONST char *subdir, int size));
+
+struct al_ffblk        /* file info block for the al_find*() routines */
+{
+   int attrib;         /* actual attributes of the file found */
+   time_t time;        /* modification time of file */
+   long size;          /* size of file */
+   char name[512];     /* name of file */
+   void *ff_data;      /* private hook */
+};
+
+AL_FUNC(int, al_findfirst, (AL_CONST char *pattern, struct al_ffblk *info, int attrib));
+AL_FUNC(int, al_findnext, (struct al_ffblk *info));
+AL_FUNC(void, al_findclose, (struct al_ffblk *info));
+
+#ifndef EOF
+   #define EOF    (-1)
+#endif
+
+#define F_READ          &quot;r&quot;
+#define F_WRITE         &quot;w&quot;
+#define F_READ_PACKED   &quot;rp&quot;
+#define F_WRITE_PACKED  &quot;wp&quot;
+#define F_WRITE_NOPACK  &quot;w!&quot;
+
+#define F_BUF_SIZE      4096           /* 4K buffer for caching data */
+#define F_PACK_MAGIC    0x736C6821L    /* magic number for packed files */
+#define F_NOPACK_MAGIC  0x736C682EL    /* magic number for autodetect */
+#define F_EXE_MAGIC     0x736C682BL    /* magic number for appended data */
+
+#define PACKFILE_FLAG_WRITE      1     /* the file is being written */
+#define PACKFILE_FLAG_PACK       2     /* data is compressed */
+#define PACKFILE_FLAG_CHUNK      4     /* file is a sub-chunk */
+#define PACKFILE_FLAG_EOF        8     /* reached the end-of-file */
+#define PACKFILE_FLAG_ERROR      16    /* an error has occurred */
+#define PACKFILE_FLAG_OLD_CRYPT  32    /* backward compatibility mode */
+#define PACKFILE_FLAG_EXEDAT     64    /* reading from our executable */
+
+
+typedef struct PACKFILE                /* our very own FILE structure... */
+{
+   int hndl;                           /* DOS file handle */
+   int flags;                          /* PACKFILE_FLAG_* constants */
+   unsigned char *buf_pos;             /* position in buffer */
+   int buf_size;                       /* number of bytes in the buffer */
+   long todo;                          /* number of bytes still on the disk */
+   struct PACKFILE *parent;            /* nested, parent file */
+   void *pack_data;                    /* for LZSS compression */
+   char *filename;                     /* name of the file */
+   char *passdata;                     /* encryption key data */
+   char *passpos;                      /* current key position */
+   unsigned char buf[F_BUF_SIZE];      /* the actual data buffer */
+} PACKFILE;
+
+
+AL_FUNC(void, packfile_password, (AL_CONST char *password));
+AL_FUNC(PACKFILE *, pack_fopen, (AL_CONST char *filename, AL_CONST char *mode));
+AL_FUNC(int, pack_fclose, (PACKFILE *f));
+AL_FUNC(int, pack_fseek, (PACKFILE *f, int offset));
+AL_FUNC(PACKFILE *, pack_fopen_chunk, (PACKFILE *f, int pack));
+AL_FUNC(PACKFILE *, pack_fclose_chunk, (PACKFILE *f));
+AL_FUNC(int, pack_igetw, (PACKFILE *f));
+AL_FUNC(long, pack_igetl, (PACKFILE *f));
+AL_FUNC(int, pack_iputw, (int w, PACKFILE *f));
+AL_FUNC(long, pack_iputl, (long l, PACKFILE *f));
+AL_FUNC(int, pack_mgetw, (PACKFILE *f));
+AL_FUNC(long, pack_mgetl, (PACKFILE *f));
+AL_FUNC(int, pack_mputw, (int w, PACKFILE *f));
+AL_FUNC(long, pack_mputl, (long l, PACKFILE *f));
+AL_FUNC(long, pack_fread, (void *p, long n, PACKFILE *f));
+AL_FUNC(long, pack_fwrite, (AL_CONST void *p, long n, PACKFILE *f));
+AL_FUNC(char *, pack_fgets, (char *p, int max, PACKFILE *f));
+AL_FUNC(int, pack_fputs, (AL_CONST char *p, PACKFILE *f));
+
+AL_FUNC(int, _sort_out_getc, (PACKFILE *f));
+AL_FUNC(int, _sort_out_putc, (int c, PACKFILE *f));
+
+#include &quot;inline/file.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_FILE_H */
+
+

Added: trunk/msvc-libs/include/allegro/fix.h
===================================================================
--- trunk/msvc-libs/include/allegro/fix.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/fix.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,210 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      C++ wrapper for fixed point math type.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FIX_H
+#define ALLEGRO_FIX_H
+
+#ifdef __cplusplus
+
+#include &quot;fixed.h&quot;
+#include &quot;fmaths.h&quot;
+
+class fix      /* C++ wrapper for the fixed point routines */
+{
+public:
+   fixed v;
+
+   fix() : v(0)                              { }
+   fix(const fix &amp;x) : v(x.v)                { }
+   fix(const int x) : v(itofix(x))           { }
+   fix(const long x) : v(itofix(x))          { }
+   fix(const unsigned int x) : v(itofix(x))  { }
+   fix(const unsigned long x) : v(itofix(x)) { }
+   fix(const float x) : v(ftofix(x))         { }
+   fix(const double x) : v(ftofix(x))        { }
+
+   operator int() const                      { return fixtoi(v); }
+   operator long() const                     { return fixtoi(v); }
+   operator unsigned int() const             { return fixtoi(v); }
+   operator unsigned long() const            { return fixtoi(v); }
+   operator float() const                    { return fixtof(v); }
+   operator double() const                   { return fixtof(v); }
+
+   fix&amp; operator = (const fix &amp;x)            { v = x.v;           return *this; }
+   fix&amp; operator = (const int x)             { v = itofix(x);     return *this; }
+   fix&amp; operator = (const long x)            { v = itofix(x);     return *this; }
+   fix&amp; operator = (const unsigned int x)    { v = itofix(x);     return *this; }
+   fix&amp; operator = (const unsigned long x)   { v = itofix(x);     return *this; }
+   fix&amp; operator = (const float x)           { v = ftofix(x);     return *this; }
+   fix&amp; operator = (const double x)          { v = ftofix(x);     return *this; }
+
+   fix&amp; operator +=  (const fix x)           { v += x.v;          return *this; }
+   fix&amp; operator +=  (const int x)           { v += itofix(x);    return *this; }
+   fix&amp; operator +=  (const long x)          { v += itofix(x);    return *this; }
+   fix&amp; operator +=  (const float x)         { v += ftofix(x);    return *this; }
+   fix&amp; operator +=  (const double x)        { v += ftofix(x);    return *this; }
+
+   fix&amp; operator -=  (const fix x)           { v -= x.v;          return *this; }
+   fix&amp; operator -=  (const int x)           { v -= itofix(x);    return *this; }
+   fix&amp; operator -=  (const long x)          { v -= itofix(x);    return *this; }
+   fix&amp; operator -=  (const float x)         { v -= ftofix(x);    return *this; }
+   fix&amp; operator -=  (const double x)        { v -= ftofix(x);    return *this; }
+
+   fix&amp; operator *=  (const fix x)           { v = fixmul(v, x.v);         return *this; }
+   fix&amp; operator *=  (const int x)           { v *= x;                     return *this; }
+   fix&amp; operator *=  (const long x)          { v *= x;                     return *this; }
+   fix&amp; operator *=  (const float x)         { v = ftofix(fixtof(v) * x);  return *this; }
+   fix&amp; operator *=  (const double x)        { v = ftofix(fixtof(v) * x);  return *this; }
+
+   fix&amp; operator /=  (const fix x)           { v = fixdiv(v, x.v);         return *this; }
+   fix&amp; operator /=  (const int x)           { v /= x;                     return *this; }
+   fix&amp; operator /=  (const long x)          { v /= x;                     return *this; }
+   fix&amp; operator /=  (const float x)         { v = ftofix(fixtof(v) / x);  return *this; }
+   fix&amp; operator /=  (const double x)        { v = ftofix(fixtof(v) / x);  return *this; }
+
+   fix&amp; operator &lt;&lt;= (const int x)           { v &lt;&lt;= x;           return *this; }
+   fix&amp; operator &gt;&gt;= (const int x)           { v &gt;&gt;= x;           return *this; }
+
+   fix&amp; operator ++ ()                       { v += itofix(1);    return *this; }
+   fix&amp; operator -- ()                       { v -= itofix(1);    return *this; }
+
+   fix operator ++ (int)                     { fix t;  t.v = v;   v += itofix(1);  return t; }
+   fix operator -- (int)                     { fix t;  t.v = v;   v -= itofix(1);  return t; }
+
+   fix operator - () const                   { fix t;  t.v = -v;  return t; }
+
+   inline friend fix operator +  (const fix x, const fix y);
+   inline friend fix operator +  (const fix x, const int y);
+   inline friend fix operator +  (const int x, const fix y);
+   inline friend fix operator +  (const fix x, const long y);
+   inline friend fix operator +  (const long x, const fix y);
+   inline friend fix operator +  (const fix x, const float y);
+   inline friend fix operator +  (const float x, const fix y);
+   inline friend fix operator +  (const fix x, const double y);
+   inline friend fix operator +  (const double x, const fix y);
+
+   inline friend fix operator -  (const fix x, const fix y);
+   inline friend fix operator -  (const fix x, const int y);
+   inline friend fix operator -  (const int x, const fix y);
+   inline friend fix operator -  (const fix x, const long y);
+   inline friend fix operator -  (const long x, const fix y);
+   inline friend fix operator -  (const fix x, const float y);
+   inline friend fix operator -  (const float x, const fix y);
+   inline friend fix operator -  (const fix x, const double y);
+   inline friend fix operator -  (const double x, const fix y);
+
+   inline friend fix operator *  (const fix x, const fix y);
+   inline friend fix operator *  (const fix x, const int y);
+   inline friend fix operator *  (const int x, const fix y);
+   inline friend fix operator *  (const fix x, const long y);
+   inline friend fix operator *  (const long x, const fix y);
+   inline friend fix operator *  (const fix x, const float y);
+   inline friend fix operator *  (const float x, const fix y);
+   inline friend fix operator *  (const fix x, const double y);
+   inline friend fix operator *  (const double x, const fix y);
+
+   inline friend fix operator /  (const fix x, const fix y);
+   inline friend fix operator /  (const fix x, const int y);
+   inline friend fix operator /  (const int x, const fix y);
+   inline friend fix operator /  (const fix x, const long y);
+   inline friend fix operator /  (const long x, const fix y);
+   inline friend fix operator /  (const fix x, const float y);
+   inline friend fix operator /  (const float x, const fix y);
+   inline friend fix operator /  (const fix x, const double y);
+   inline friend fix operator /  (const double x, const fix y);
+
+   inline friend fix operator &lt;&lt; (const fix x, const int y);
+   inline friend fix operator &gt;&gt; (const fix x, const int y);
+
+   inline friend int operator == (const fix x, const fix y);
+   inline friend int operator == (const fix x, const int y);
+   inline friend int operator == (const int x, const fix y);
+   inline friend int operator == (const fix x, const long y);
+   inline friend int operator == (const long x, const fix y);
+   inline friend int operator == (const fix x, const float y);
+   inline friend int operator == (const float x, const fix y);
+   inline friend int operator == (const fix x, const double y);
+   inline friend int operator == (const double x, const fix y);
+
+   inline friend int operator != (const fix x, const fix y);
+   inline friend int operator != (const fix x, const int y);
+   inline friend int operator != (const int x, const fix y);
+   inline friend int operator != (const fix x, const long y);
+   inline friend int operator != (const long x, const fix y);
+   inline friend int operator != (const fix x, const float y);
+   inline friend int operator != (const float x, const fix y);
+   inline friend int operator != (const fix x, const double y);
+   inline friend int operator != (const double x, const fix y);
+
+   inline friend int operator &lt;  (const fix x, const fix y);
+   inline friend int operator &lt;  (const fix x, const int y);
+   inline friend int operator &lt;  (const int x, const fix y);
+   inline friend int operator &lt;  (const fix x, const long y);
+   inline friend int operator &lt;  (const long x, const fix y);
+   inline friend int operator &lt;  (const fix x, const float y);
+   inline friend int operator &lt;  (const float x, const fix y);
+   inline friend int operator &lt;  (const fix x, const double y);
+   inline friend int operator &lt;  (const double x, const fix y);
+
+   inline friend int operator &gt;  (const fix x, const fix y);
+   inline friend int operator &gt;  (const fix x, const int y);
+   inline friend int operator &gt;  (const int x, const fix y);
+   inline friend int operator &gt;  (const fix x, const long y);
+   inline friend int operator &gt;  (const long x, const fix y);
+   inline friend int operator &gt;  (const fix x, const float y);
+   inline friend int operator &gt;  (const float x, const fix y);
+   inline friend int operator &gt;  (const fix x, const double y);
+   inline friend int operator &gt;  (const double x, const fix y);
+
+   inline friend int operator &lt;= (const fix x, const fix y);
+   inline friend int operator &lt;= (const fix x, const int y);
+   inline friend int operator &lt;= (const int x, const fix y);
+   inline friend int operator &lt;= (const fix x, const long y);
+   inline friend int operator &lt;= (const long x, const fix y);
+   inline friend int operator &lt;= (const fix x, const float y);
+   inline friend int operator &lt;= (const float x, const fix y);
+   inline friend int operator &lt;= (const fix x, const double y);
+   inline friend int operator &lt;= (const double x, const fix y);
+
+   inline friend int operator &gt;= (const fix x, const fix y);
+   inline friend int operator &gt;= (const fix x, const int y);
+   inline friend int operator &gt;= (const int x, const fix y);
+   inline friend int operator &gt;= (const fix x, const long y);
+   inline friend int operator &gt;= (const long x, const fix y);
+   inline friend int operator &gt;= (const fix x, const float y);
+   inline friend int operator &gt;= (const float x, const fix y);
+   inline friend int operator &gt;= (const fix x, const double y);
+   inline friend int operator &gt;= (const double x, const fix y);
+
+   inline friend fix sqrt(fix x);
+   inline friend fix cos(fix x);
+   inline friend fix sin(fix x);
+   inline friend fix tan(fix x);
+   inline friend fix acos(fix x);
+   inline friend fix asin(fix x);
+   inline friend fix atan(fix x);
+   inline friend fix atan2(fix x, fix y);
+};
+
+#include &quot;inline/fix.inl&quot;
+
+#endif          /* ifdef __cplusplus */
+
+#endif          /* ifndef ALLEGRO_FIX_H */
+
+

Added: trunk/msvc-libs/include/allegro/fixed.h
===================================================================
--- trunk/msvc-libs/include/allegro/fixed.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/fixed.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,34 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Fixed point type.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FIXED_H
+#define ALLEGRO_FIXED_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+typedef long fixed;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_FIXED_H */
+
+

Added: trunk/msvc-libs/include/allegro/fli.h
===================================================================
--- trunk/msvc-libs/include/allegro/fli.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/fli.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,63 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      FLI/FLC routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FLI_H
+#define ALLEGRO_FLI_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;palette.h&quot;
+
+struct BITMAP;
+
+#define FLI_OK          0              /* FLI player return values */
+#define FLI_EOF         -1
+#define FLI_ERROR       -2
+#define FLI_NOT_OPEN    -3
+
+AL_FUNC(int, play_fli, (AL_CONST char *filename, struct BITMAP *bmp, int loop, AL_METHOD(int, callback, (void))));
+AL_FUNC(int, play_memory_fli, (void *fli_data, struct BITMAP *bmp, int loop, AL_METHOD(int, callback, (void))));
+
+AL_FUNC(int, open_fli, (AL_CONST char *filename));
+AL_FUNC(int, open_memory_fli, (void *fli_data));
+AL_FUNC(void, close_fli, (void));
+AL_FUNC(int, next_fli_frame, (int loop));
+AL_FUNC(void, reset_fli_variables, (void));
+
+AL_VAR(struct BITMAP *, fli_bitmap);   /* current frame of the FLI */
+AL_VAR(PALETTE, fli_palette);          /* current FLI palette */
+
+AL_VAR(int, fli_bmp_dirty_from);       /* what part of fli_bitmap is dirty */
+AL_VAR(int, fli_bmp_dirty_to);
+AL_VAR(int, fli_pal_dirty_from);       /* what part of fli_palette is dirty */
+AL_VAR(int, fli_pal_dirty_to);
+
+AL_VAR(int, fli_frame);                /* current frame number */
+
+AL_VAR(volatile int, fli_timer);       /* for timing FLI playback */
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_FLI_H */
+
+

Added: trunk/msvc-libs/include/allegro/fmaths.h
===================================================================
--- trunk/msvc-libs/include/allegro/fmaths.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/fmaths.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,46 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Fixed point math routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FMATH_H
+#define ALLEGRO_FMATH_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;fixed.h&quot;
+
+AL_FUNC(fixed, fixsqrt, (fixed x));
+AL_FUNC(fixed, fixhypot, (fixed x, fixed y));
+AL_FUNC(fixed, fixatan, (fixed x));
+AL_FUNC(fixed, fixatan2, (fixed y, fixed x));
+
+AL_ARRAY(fixed, _cos_tbl);
+AL_ARRAY(fixed, _tan_tbl);
+AL_ARRAY(fixed, _acos_tbl);
+
+#include &quot;inline/fmaths.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_FMATH_H */
+
+

Added: trunk/msvc-libs/include/allegro/gfx.h
===================================================================
--- trunk/msvc-libs/include/allegro/gfx.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/gfx.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,392 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Basic graphics support routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_GFX_H
+#define ALLEGRO_GFX_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;fixed.h&quot;
+
+struct RLE_SPRITE;
+struct FONT_GLYPH;
+struct RGB;
+
+#define GFX_TEXT                       -1
+#define GFX_AUTODETECT                 0
+#define GFX_AUTODETECT_FULLSCREEN      1
+#define GFX_AUTODETECT_WINDOWED        2
+#define GFX_SAFE                       AL_ID('S','A','F','E')
+
+
+typedef struct GFX_MODE
+{
+   int width, height, bpp;
+} GFX_MODE;
+
+typedef struct GFX_MODE_LIST
+{
+   int num_modes;                /* number of gfx modes */
+   GFX_MODE *mode;               /* pointer to the actual mode list array */
+} GFX_MODE_LIST;
+
+typedef struct GFX_DRIVER        /* creates and manages the screen bitmap */
+{
+   int  id;
+   AL_CONST char *name;
+   AL_CONST char *desc;
+   AL_CONST char *ascii_name;
+   AL_METHOD(struct BITMAP *, init, (int w, int h, int v_w, int v_h, int color_depth));
+   AL_METHOD(void, exit, (struct BITMAP *b));
+   AL_METHOD(int, scroll, (int x, int y));
+   AL_METHOD(void, vsync, (void));
+   AL_METHOD(void, set_palette, (AL_CONST struct RGB *p, int from, int to, int retracesync));
+   AL_METHOD(int, request_scroll, (int x, int y));
+   AL_METHOD(int, poll_scroll, (void));
+   AL_METHOD(void, enable_triple_buffer, (void));
+   AL_METHOD(struct BITMAP *, create_video_bitmap, (int width, int height));
+   AL_METHOD(void, destroy_video_bitmap, (struct BITMAP *bitmap));
+   AL_METHOD(int, show_video_bitmap, (struct BITMAP *bitmap));
+   AL_METHOD(int, request_video_bitmap, (struct BITMAP *bitmap));
+   AL_METHOD(struct BITMAP *, create_system_bitmap, (int width, int height));
+   AL_METHOD(void, destroy_system_bitmap, (struct BITMAP *bitmap));
+   AL_METHOD(int, set_mouse_sprite, (struct BITMAP *sprite, int xfocus, int yfocus));
+   AL_METHOD(int, show_mouse, (struct BITMAP *bmp, int x, int y));
+   AL_METHOD(void, hide_mouse, (void));
+   AL_METHOD(void, move_mouse, (int x, int y));
+   AL_METHOD(void, drawing_mode, (void));
+   AL_METHOD(void, save_video_state, (void));
+   AL_METHOD(void, restore_video_state, (void));
+   AL_METHOD(GFX_MODE_LIST *, fetch_mode_list, (void));
+   int w, h;                     /* physical (not virtual!) screen size */
+   int linear;                   /* true if video memory is linear */
+   long bank_size;               /* bank size, in bytes */
+   long bank_gran;               /* bank granularity, in bytes */
+   long vid_mem;                 /* video memory size, in bytes */
+   long vid_phys_base;           /* physical address of video memory */
+   int windowed;                 /* true if driver runs windowed */
+} GFX_DRIVER;
+
+
+AL_VAR(GFX_DRIVER *, gfx_driver);
+AL_ARRAY(_DRIVER_INFO, _gfx_driver_list);
+
+
+/* macros for constructing the driver list */
+#define BEGIN_GFX_DRIVER_LIST                      \
+   _DRIVER_INFO _gfx_driver_list[] =               \
+   {
+
+#define END_GFX_DRIVER_LIST                        \
+      {  0,          NULL,       0     }           \
+   };
+
+
+#define GFX_CAN_SCROLL                    0x00000001
+#define GFX_CAN_TRIPLE_BUFFER             0x00000002
+#define GFX_HW_CURSOR                     0x00000004
+#define GFX_HW_HLINE                      0x00000008
+#define GFX_HW_HLINE_XOR                  0x00000010
+#define GFX_HW_HLINE_SOLID_PATTERN        0x00000020
+#define GFX_HW_HLINE_COPY_PATTERN         0x00000040
+#define GFX_HW_FILL                       0x00000080
+#define GFX_HW_FILL_XOR                   0x00000100
+#define GFX_HW_FILL_SOLID_PATTERN         0x00000200
+#define GFX_HW_FILL_COPY_PATTERN          0x00000400
+#define GFX_HW_LINE                       0x00000800
+#define GFX_HW_LINE_XOR                   0x00001000
+#define GFX_HW_TRIANGLE                   0x00002000
+#define GFX_HW_TRIANGLE_XOR               0x00004000
+#define GFX_HW_GLYPH                      0x00008000
+#define GFX_HW_VRAM_BLIT                  0x00010000
+#define GFX_HW_VRAM_BLIT_MASKED           0x00020000
+#define GFX_HW_MEM_BLIT                   0x00040000
+#define GFX_HW_MEM_BLIT_MASKED            0x00080000
+#define GFX_HW_SYS_TO_VRAM_BLIT           0x00100000
+#define GFX_HW_SYS_TO_VRAM_BLIT_MASKED    0x00200000
+
+
+AL_VAR(int, gfx_capabilities);   /* current driver capabilities */
+
+
+typedef struct GFX_VTABLE        /* functions for drawing onto bitmaps */
+{
+   int color_depth;
+   int mask_color;
+   void *unwrite_bank;  /* C function on some machines, asm on i386 */
+   AL_METHOD(void, set_clip, (struct BITMAP *bmp));
+   AL_METHOD(void, acquire, (struct BITMAP *bmp));
+   AL_METHOD(void, release, (struct BITMAP *bmp));
+   AL_METHOD(struct BITMAP *, create_sub_bitmap, (struct BITMAP *parent, int x, int y, int width, int height));
+   AL_METHOD(void, created_sub_bitmap, (struct BITMAP *bmp, struct BITMAP *parent));
+   AL_METHOD(int,  getpixel, (struct BITMAP *bmp, int x, int y));
+   AL_METHOD(void, putpixel, (struct BITMAP *bmp, int x, int y, int color));
+   AL_METHOD(void, vline, (struct BITMAP *bmp, int x, int y1, int y2, int color));
+   AL_METHOD(void, hline, (struct BITMAP *bmp, int x1, int y, int x2, int color));
+   AL_METHOD(void, hfill, (struct BITMAP *bmp, int x1, int y, int x2, int color));
+   AL_METHOD(void, line, (struct BITMAP *bmp, int x1, int y1, int x2, int y2, int color));
+   AL_METHOD(void, rectfill, (struct BITMAP *bmp, int x1, int y1, int x2, int y2, int color));
+   AL_METHOD(int,  triangle, (struct BITMAP *bmp, int x1, int y1, int x2, int y2, int x3, int y3, int color));
+   AL_METHOD(void, draw_sprite, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y));
+   AL_METHOD(void, draw_256_sprite, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y));
+   AL_METHOD(void, draw_sprite_v_flip, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y));
+   AL_METHOD(void, draw_sprite_h_flip, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y));
+   AL_METHOD(void, draw_sprite_vh_flip, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y));
+   AL_METHOD(void, draw_trans_sprite, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y));
+   AL_METHOD(void, draw_trans_rgba_sprite, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y));
+   AL_METHOD(void, draw_lit_sprite, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y, int color));
+   AL_METHOD(void, draw_rle_sprite, (struct BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+   AL_METHOD(void, draw_trans_rle_sprite, (struct BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+   AL_METHOD(void, draw_trans_rgba_rle_sprite, (struct BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+   AL_METHOD(void, draw_lit_rle_sprite, (struct BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color));
+   AL_METHOD(void, draw_character, (struct BITMAP *bmp, struct BITMAP *sprite, int x, int y, int color));
+   AL_METHOD(void, draw_glyph, (struct BITMAP *bmp, AL_CONST struct FONT_GLYPH *glyph, int x, int y, int color));
+   AL_METHOD(void, blit_from_memory, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, blit_to_memory, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, blit_from_system, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, blit_to_system, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, blit_to_self, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, blit_to_self_forward, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, blit_to_self_backward, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, blit_between_formats, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, masked_blit, (struct BITMAP *source, struct BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+   AL_METHOD(void, clear_to_color, (struct BITMAP *bitmap, int color));
+   AL_METHOD(void, pivot_scaled_sprite_flip, (struct BITMAP *bmp, struct BITMAP *sprite, fixed x, fixed y, fixed cx, fixed cy, fixed angle, fixed scale, int v_flip));
+   AL_METHOD(void, draw_sprite_end, (void));
+   AL_METHOD(void, blit_end, (void));
+} GFX_VTABLE;
+
+
+AL_VAR(GFX_VTABLE, __linear_vtable8);
+AL_VAR(GFX_VTABLE, __linear_vtable15);
+AL_VAR(GFX_VTABLE, __linear_vtable16);
+AL_VAR(GFX_VTABLE, __linear_vtable24);
+AL_VAR(GFX_VTABLE, __linear_vtable32);
+
+
+typedef struct _VTABLE_INFO
+{
+   int color_depth;
+   GFX_VTABLE *vtable;
+} _VTABLE_INFO;
+
+AL_ARRAY(_VTABLE_INFO, _vtable_list);
+
+
+/* macros for constructing the vtable list */
+#define BEGIN_COLOR_DEPTH_LIST               \
+   _VTABLE_INFO _vtable_list[] =             \
+   {
+
+#define END_COLOR_DEPTH_LIST                 \
+      {  0,    NULL  }                       \
+   };
+
+#define COLOR_DEPTH_8                        \
+   {  8,    &amp;__linear_vtable8    },
+
+#define COLOR_DEPTH_15                       \
+   {  15,   &amp;__linear_vtable15   },
+
+#define COLOR_DEPTH_16                       \
+   {  16,   &amp;__linear_vtable16   },
+
+#define COLOR_DEPTH_24                       \
+   {  24,   &amp;__linear_vtable24   },
+
+#define COLOR_DEPTH_32                       \
+   {  32,   &amp;__linear_vtable32   },
+
+
+typedef struct BITMAP            /* a bitmap structure */
+{
+   int w, h;                     /* width and height in pixels */
+   int clip;                     /* flag if clipping is turned on */
+   int cl, cr, ct, cb;           /* clip left, right, top and bottom values */
+   GFX_VTABLE *vtable;           /* drawing functions */
+   void *write_bank;             /* C func on some machines, asm on i386 */
+   void *read_bank;              /* C func on some machines, asm on i386 */
+   void *dat;                    /* the memory we allocated for the bitmap */
+   unsigned long id;             /* for identifying sub-bitmaps */
+   void *extra;                  /* points to a structure with more info */
+   int x_ofs;                    /* horizontal offset (for sub-bitmaps) */
+   int y_ofs;                    /* vertical offset (for sub-bitmaps) */
+   int seg;                      /* bitmap segment */
+   ZERO_SIZE_ARRAY(unsigned char *, line);
+} BITMAP;
+
+
+#define BMP_ID_VIDEO       0x80000000
+#define BMP_ID_SYSTEM      0x40000000
+#define BMP_ID_SUB         0x20000000
+#define BMP_ID_PLANAR      0x10000000
+#define BMP_ID_NOBLIT      0x08000000
+#define BMP_ID_LOCKED      0x04000000
+#define BMP_ID_AUTOLOCK    0x02000000
+#define BMP_ID_MASK        0x01FFFFFF
+
+
+AL_VAR(BITMAP *, screen);
+
+#define SCREEN_W     (gfx_driver ? gfx_driver-&gt;w : 0)
+#define SCREEN_H     (gfx_driver ? gfx_driver-&gt;h : 0)
+
+#define VIRTUAL_W    (screen ? screen-&gt;w : 0)
+#define VIRTUAL_H    (screen ? screen-&gt;h : 0)
+
+#define COLORCONV_NONE              0
+
+#define COLORCONV_8_TO_15           1
+#define COLORCONV_8_TO_16           2
+#define COLORCONV_8_TO_24           4
+#define COLORCONV_8_TO_32           8
+
+#define COLORCONV_15_TO_8           0x10
+#define COLORCONV_15_TO_16          0x20
+#define COLORCONV_15_TO_24          0x40
+#define COLORCONV_15_TO_32          0x80
+
+#define COLORCONV_16_TO_8           0x100
+#define COLORCONV_16_TO_15          0x200
+#define COLORCONV_16_TO_24          0x400
+#define COLORCONV_16_TO_32          0x800
+
+#define COLORCONV_24_TO_8           0x1000
+#define COLORCONV_24_TO_15          0x2000
+#define COLORCONV_24_TO_16          0x4000
+#define COLORCONV_24_TO_32          0x8000
+
+#define COLORCONV_32_TO_8           0x10000
+#define COLORCONV_32_TO_15          0x20000
+#define COLORCONV_32_TO_16          0x40000
+#define COLORCONV_32_TO_24          0x80000
+
+#define COLORCONV_32A_TO_8          0x100000
+#define COLORCONV_32A_TO_15         0x200000
+#define COLORCONV_32A_TO_16         0x400000
+#define COLORCONV_32A_TO_24         0x800000
+
+#define COLORCONV_DITHER_PAL        0x1000000
+#define COLORCONV_DITHER_HI         0x2000000
+#define COLORCONV_KEEP_TRANS        0x4000000
+
+#define COLORCONV_DITHER            (COLORCONV_DITHER_PAL |          \
+                                     COLORCONV_DITHER_HI)
+
+#define COLORCONV_EXPAND_256        (COLORCONV_8_TO_15 |             \
+                                     COLORCONV_8_TO_16 |             \
+                                     COLORCONV_8_TO_24 |             \
+                                     COLORCONV_8_TO_32)
+
+#define COLORCONV_REDUCE_TO_256     (COLORCONV_15_TO_8 |             \
+                                     COLORCONV_16_TO_8 |             \
+                                     COLORCONV_24_TO_8 |             \
+                                     COLORCONV_32_TO_8 |             \
+                                     COLORCONV_32A_TO_8)
+
+#define COLORCONV_EXPAND_15_TO_16    COLORCONV_15_TO_16
+
+#define COLORCONV_REDUCE_16_TO_15    COLORCONV_16_TO_15
+
+#define COLORCONV_EXPAND_HI_TO_TRUE (COLORCONV_15_TO_24 |            \
+                                     COLORCONV_15_TO_32 |            \
+                                     COLORCONV_16_TO_24 |            \
+                                     COLORCONV_16_TO_32)
+
+#define COLORCONV_REDUCE_TRUE_TO_HI (COLORCONV_24_TO_15 |            \
+                                     COLORCONV_24_TO_16 |            \
+                                     COLORCONV_32_TO_15 |            \
+                                     COLORCONV_32_TO_16)
+
+#define COLORCONV_24_EQUALS_32      (COLORCONV_24_TO_32 |            \
+                                     COLORCONV_32_TO_24)
+
+#define COLORCONV_TOTAL             (COLORCONV_EXPAND_256 |          \
+                                     COLORCONV_REDUCE_TO_256 |       \
+                                     COLORCONV_EXPAND_15_TO_16 |     \
+                                     COLORCONV_REDUCE_16_TO_15 |     \
+                                     COLORCONV_EXPAND_HI_TO_TRUE |   \
+                                     COLORCONV_REDUCE_TRUE_TO_HI |   \
+                                     COLORCONV_24_EQUALS_32 |        \
+                                     COLORCONV_32A_TO_15 |           \
+                                     COLORCONV_32A_TO_16 |           \
+                                     COLORCONV_32A_TO_24)
+
+#define COLORCONV_PARTIAL           (COLORCONV_EXPAND_15_TO_16 |     \
+                                     COLORCONV_REDUCE_16_TO_15 |     \
+                                     COLORCONV_24_EQUALS_32)
+
+#define COLORCONV_MOST              (COLORCONV_EXPAND_15_TO_16 |     \
+                                     COLORCONV_REDUCE_16_TO_15 |     \
+                                     COLORCONV_EXPAND_HI_TO_TRUE |   \
+                                     COLORCONV_REDUCE_TRUE_TO_HI |   \
+                                     COLORCONV_24_EQUALS_32)
+
+AL_FUNC(GFX_MODE_LIST *, get_gfx_mode_list, (int card));
+AL_FUNC(void, destroy_gfx_mode_list, (GFX_MODE_LIST *gfx_mode_list));
+AL_FUNC(void, set_color_depth, (int depth));
+AL_FUNC(void, set_color_conversion, (int mode));
+AL_FUNC(void, request_refresh_rate, (int rate));
+AL_FUNC(int, get_refresh_rate, (void));
+AL_FUNC(int, set_gfx_mode, (int card, int w, int h, int v_w, int v_h));
+AL_FUNC(int, scroll_screen, (int x, int y));
+AL_FUNC(int, request_scroll, (int x, int y));
+AL_FUNC(int, poll_scroll, (void));
+AL_FUNC(int, show_video_bitmap, (BITMAP *bitmap));
+AL_FUNC(int, request_video_bitmap, (BITMAP *bitmap));
+AL_FUNC(int, enable_triple_buffer, (void));
+AL_FUNC(BITMAP *, create_bitmap, (int width, int height));
+AL_FUNC(BITMAP *, create_bitmap_ex, (int color_depth, int width, int height));
+AL_FUNC(BITMAP *, create_sub_bitmap, (BITMAP *parent, int x, int y, int width, int height));
+AL_FUNC(BITMAP *, create_video_bitmap, (int width, int height));
+AL_FUNC(BITMAP *, create_system_bitmap, (int width, int height));
+AL_FUNC(void, destroy_bitmap, (BITMAP *bitmap));
+AL_FUNC(void, set_clip, (BITMAP *bitmap, int x1, int y1, int x2, int y2));
+AL_FUNC(void, clear_bitmap, (BITMAP *bitmap));
+AL_FUNC(void, vsync, (void));
+
+
+
+#define SWITCH_NONE           0
+#define SWITCH_PAUSE          1
+#define SWITCH_AMNESIA        2
+#define SWITCH_BACKGROUND     3
+#define SWITCH_BACKAMNESIA    4
+
+#define SWITCH_IN             0
+#define SWITCH_OUT            1
+
+AL_FUNC(int, set_display_switch_mode, (int mode));
+AL_FUNC(int, get_display_switch_mode, (void));
+AL_FUNC(int, set_display_switch_callback, (int dir, AL_METHOD(void, cb, (void))));
+AL_FUNC(void, remove_display_switch_callback, (AL_METHOD(void, cb, (void))));
+
+AL_FUNC(void, lock_bitmap, (struct BITMAP *bmp));
+
+#include &quot;inline/gfx.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_GFX_H */
+
+

Added: trunk/msvc-libs/include/allegro/gui.h
===================================================================
--- trunk/msvc-libs/include/allegro/gui.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/gui.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,203 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      GUI routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_GUI_H
+#define ALLEGRO_GUI_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+struct BITMAP;
+struct DIALOG;
+
+typedef AL_METHOD(int, DIALOG_PROC, (int msg, struct DIALOG *d, int c));
+
+typedef struct DIALOG
+{
+   DIALOG_PROC proc;
+   int x, y, w, h;               /* position and size of the object */
+   int fg, bg;                   /* foreground and background colors */
+   int key;                      /* keyboard shortcut (ASCII code) */
+   int flags;                    /* flags about the object state */
+   int d1, d2;                   /* any data the object might require */
+   void *dp, *dp2, *dp3;         /* pointers to more object data */
+} DIALOG;
+
+
+/* a popup menu */
+typedef struct MENU
+{
+   char *text;                   /* menu item text */
+   AL_METHOD(int, proc, (void)); /* callback function */
+   struct MENU *child;           /* to allow nested menus */
+   int flags;                    /* flags about the menu state */
+   void *dp;                     /* any data the menu might require */
+} MENU;
+
+
+/* stored information about the state of an active GUI dialog */
+typedef struct DIALOG_PLAYER
+{
+   int obj;
+   int res;
+   int mouse_obj;
+   int focus_obj;
+   int joy_on;
+   int click_wait;
+   int mouse_ox, mouse_oy;
+   int mouse_oz;
+   int mouse_b;
+   DIALOG *dialog;
+} DIALOG_PLAYER;
+
+
+/* bits for the flags field */
+#define D_EXIT          1        /* object makes the dialog exit */
+#define D_SELECTED      2        /* object is selected */
+#define D_GOTFOCUS      4        /* object has the input focus */
+#define D_GOTMOUSE      8        /* mouse is on top of object */
+#define D_HIDDEN        16       /* object is not visible */
+#define D_DISABLED      32       /* object is visible but inactive */
+#define D_DIRTY         64       /* object needs to be redrawn */
+#define D_INTERNAL      128      /* reserved for internal use */
+#define D_USER          256      /* from here on is free for your own use */
+
+
+/* return values for the dialog procedures */
+#define D_O_K           0        /* normal exit status */
+#define D_CLOSE         1        /* request to close the dialog */
+#define D_REDRAW        2        /* request to redraw the dialog */
+#define D_REDRAWME      4        /* request to redraw this object */
+#define D_WANTFOCUS     8        /* this object wants the input focus */
+#define D_USED_CHAR     16       /* object has used the keypress */
+#define D_REDRAW_ALL    32       /* request to redraw all active dialogs */
+
+
+/* messages for the dialog procedures */
+#define MSG_START       1        /* start the dialog, initialise */
+#define MSG_END         2        /* dialog is finished - cleanup */
+#define MSG_DRAW        3        /* draw the object */
+#define MSG_CLICK       4        /* mouse click on the object */
+#define MSG_DCLICK      5        /* double click on the object */
+#define MSG_KEY         6        /* keyboard shortcut */
+#define MSG_CHAR        7        /* other keyboard input */
+#define MSG_UCHAR       8        /* unicode keyboard input */
+#define MSG_XCHAR       9        /* broadcast character to all objects */
+#define MSG_WANTFOCUS   10       /* does object want the input focus? */
+#define MSG_GOTFOCUS    11       /* got the input focus */
+#define MSG_LOSTFOCUS   12       /* lost the input focus */
+#define MSG_GOTMOUSE    13       /* mouse on top of object */
+#define MSG_LOSTMOUSE   14       /* mouse moved away from object */
+#define MSG_IDLE        15       /* update any background stuff */
+#define MSG_RADIO       16       /* clear radio buttons */
+#define MSG_WHEEL       17       /* mouse wheel moved */
+#define MSG_LPRESS      18       /* mouse left button pressed */
+#define MSG_LRELEASE    19       /* mouse left button released */
+#define MSG_MPRESS      20       /* mouse middle button pressed */
+#define MSG_MRELEASE    21       /* mouse middle button released */
+#define MSG_RPRESS      22       /* mouse right button pressed */
+#define MSG_RRELEASE    23       /* mouse right button released */
+#define MSG_USER        24       /* from here on are free... */
+
+
+/* some dialog procedures */
+AL_FUNC(int, d_yield_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_clear_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_box_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_shadow_box_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_bitmap_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_text_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_ctext_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_rtext_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_button_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_check_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_radio_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_icon_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_keyboard_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_edit_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_list_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_text_list_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_textbox_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_slider_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, d_menu_proc, (int msg, DIALOG *d, int c));
+
+AL_VAR(DIALOG_PROC, gui_shadow_box_proc);
+AL_VAR(DIALOG_PROC, gui_ctext_proc);
+AL_VAR(DIALOG_PROC, gui_button_proc);
+AL_VAR(DIALOG_PROC, gui_edit_proc);
+AL_VAR(DIALOG_PROC, gui_list_proc);
+AL_VAR(DIALOG_PROC, gui_text_list_proc);
+
+AL_FUNCPTR(void, gui_menu_draw_menu, (int x, int y, int w, int h));
+AL_FUNCPTR(void, gui_menu_draw_menu_item, (MENU *m, int x, int y, int w, int h, int bar, int sel));
+
+AL_VAR(DIALOG *, active_dialog);
+AL_VAR(MENU *, active_menu);
+
+AL_VAR(int, gui_mouse_focus);
+
+AL_VAR(int, gui_fg_color);
+AL_VAR(int, gui_mg_color);
+AL_VAR(int, gui_bg_color);
+
+AL_VAR(int, gui_font_baseline);
+
+AL_FUNCPTR(int, gui_mouse_x, (void));
+AL_FUNCPTR(int, gui_mouse_y, (void));
+AL_FUNCPTR(int, gui_mouse_z, (void));
+AL_FUNCPTR(int, gui_mouse_b, (void));
+
+AL_FUNC(int, gui_textout, (struct BITMAP *bmp, AL_CONST char *s, int x, int y, int color, int centre));
+AL_FUNC(int, gui_strlen, (AL_CONST char *s));
+AL_FUNC(void, position_dialog, (DIALOG *dialog, int x, int y));
+AL_FUNC(void, centre_dialog, (DIALOG *dialog));
+AL_FUNC(void, set_dialog_color, (DIALOG *dialog, int fg, int bg));
+AL_FUNC(int, find_dialog_focus, (DIALOG *dialog));
+AL_FUNC(int, offer_focus, (DIALOG *d, int obj, int *focus_obj, int force));
+AL_FUNC(int, dialog_message, (DIALOG *dialog, int msg, int c, int *obj));
+AL_FUNC(int, broadcast_dialog_message, (int msg, int c));
+AL_FUNC(int, do_dialog, (DIALOG *dialog, int focus_obj));
+AL_FUNC(int, popup_dialog, (DIALOG *dialog, int focus_obj));
+AL_FUNC(DIALOG_PLAYER *, init_dialog, (DIALOG *dialog, int focus_obj));
+AL_FUNC(int, update_dialog, (DIALOG_PLAYER *player));
+AL_FUNC(int, shutdown_dialog, (DIALOG_PLAYER *player));
+AL_FUNC(int, do_menu, (MENU *menu, int x, int y));
+AL_FUNC(int, alert, (AL_CONST char *s1, AL_CONST char *s2, AL_CONST char *s3, AL_CONST char *b1, AL_CONST char *b2, int c1, int c2));
+AL_FUNC(int, alert3, (AL_CONST char *s1, AL_CONST char *s2, AL_CONST char *s3, AL_CONST char *b1, AL_CONST char *b2, AL_CONST char *b3, int c1, int c2, int c3));
+
+#define OLD_FILESEL_WIDTH   -1
+#define OLD_FILESEL_HEIGHT  -1
+
+AL_FUNC(int, file_select, (AL_CONST char *message, char *path, AL_CONST char *ext));
+AL_FUNC(int, file_select_ex, (AL_CONST char *message, char *path, AL_CONST char *ext, int size, int w, int h));
+
+AL_FUNC(int, gfx_mode_select, (int *card, int *w, int *h));
+AL_FUNC(int, gfx_mode_select_ex, (int *card, int *w, int *h, int *color_depth));
+
+#include &quot;inline/gui.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_GUI_H */
+
+

Added: trunk/msvc-libs/include/allegro/inline/3dmaths.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/3dmaths.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/3dmaths.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,60 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      3D maths inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_3DMATHS_INL
+#define ALLEGRO_3DMATHS_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+AL_INLINE(fixed, dot_product, (fixed x1, fixed y1, fixed z1, fixed x2, fixed y2, fixed z2),
+{
+   return fixmul(x1, x2) + fixmul(y1, y2) + fixmul(z1, z2);
+})
+
+
+AL_INLINE(float, dot_product_f, (float x1, float y1, float z1, float x2, float y2, float z2),
+{
+   return (x1 * x2) + (y1 * y2) + (z1 * z2);
+})
+
+
+AL_INLINE(void, persp_project, (fixed x, fixed y, fixed z, fixed *xout, fixed *yout),
+{
+   *xout = fixmul(fixdiv(x, z), _persp_xscale) + _persp_xoffset;
+   *yout = fixmul(fixdiv(y, z), _persp_yscale) + _persp_yoffset;
+})
+
+
+AL_INLINE(void, persp_project_f, (float x, float y, float z, float *xout, float *yout),
+{
+   float z1 = 1.0f / z;
+   *xout = ((x * z1) * _persp_xscale_f) + _persp_xoffset_f;
+   *yout = ((y * z1) * _persp_yscale_f) + _persp_yoffset_f;
+})
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_3DMATHS_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/asm.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/asm.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/asm.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,53 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Imports asm definitions of various inline functions.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+#ifndef ALLEGRO_NO_ASM
+
+#if (defined ALLEGRO_GCC) &amp;&amp; (defined ALLEGRO_I386)
+
+   /* use i386 asm, GCC syntax */
+   #include &quot;allegro/platform/al386gcc.h&quot;
+
+#elif (defined ALLEGRO_MSVC) &amp;&amp; (defined ALLEGRO_I386)
+
+   /* use i386 asm, MSVC syntax */
+   #include &quot;allegro/platform/al386vc.h&quot;
+
+#elif (defined ALLEGRO_WATCOM) &amp;&amp; (defined ALLEGRO_I386)
+
+   /* use i386 asm, Watcom syntax */
+   #include &quot;allegro/platform/al386wat.h&quot;
+
+#else
+
+   /* asm not supported */
+   #define ALLEGRO_NO_ASM
+
+#endif
+
+#endif
+
+
+#ifdef __cplusplus
+   }
+#endif
+

Added: trunk/msvc-libs/include/allegro/inline/color.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/color.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/color.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,179 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Color inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_COLOR_INL
+#define ALLEGRO_COLOR_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+AL_INLINE(int, makecol15, (int r, int g, int b),
+{
+   return (((r &gt;&gt; 3) &lt;&lt; _rgb_r_shift_15) |
+           ((g &gt;&gt; 3) &lt;&lt; _rgb_g_shift_15) |
+           ((b &gt;&gt; 3) &lt;&lt; _rgb_b_shift_15));
+})
+
+
+AL_INLINE(int, makecol16, (int r, int g, int b),
+{
+   return (((r &gt;&gt; 3) &lt;&lt; _rgb_r_shift_16) |
+           ((g &gt;&gt; 2) &lt;&lt; _rgb_g_shift_16) |
+           ((b &gt;&gt; 3) &lt;&lt; _rgb_b_shift_16));
+})
+
+
+AL_INLINE(int, makecol24, (int r, int g, int b),
+{
+   return ((r &lt;&lt; _rgb_r_shift_24) |
+           (g &lt;&lt; _rgb_g_shift_24) |
+           (b &lt;&lt; _rgb_b_shift_24));
+})
+
+
+AL_INLINE(int, makecol32, (int r, int g, int b),
+{
+   return ((r &lt;&lt; _rgb_r_shift_32) |
+           (g &lt;&lt; _rgb_g_shift_32) |
+           (b &lt;&lt; _rgb_b_shift_32));
+})
+
+
+AL_INLINE(int, makeacol32, (int r, int g, int b, int a),
+{
+   return ((r &lt;&lt; _rgb_r_shift_32) |
+           (g &lt;&lt; _rgb_g_shift_32) |
+           (b &lt;&lt; _rgb_b_shift_32) |
+           (a &lt;&lt; _rgb_a_shift_32));
+})
+
+
+AL_INLINE(int, getr8, (int c),
+{
+   return _rgb_scale_6[(int)_current_palette[c].r];
+})
+
+
+AL_INLINE(int, getg8, (int c),
+{
+   return _rgb_scale_6[(int)_current_palette[c].g];
+})
+
+
+AL_INLINE(int, getb8, (int c),
+{
+   return _rgb_scale_6[(int)_current_palette[c].b];
+})
+
+
+AL_INLINE(int, getr15, (int c),
+{
+   return _rgb_scale_5[(c &gt;&gt; _rgb_r_shift_15) &amp; 0x1F];
+})
+
+
+AL_INLINE(int, getg15, (int c),
+{
+   return _rgb_scale_5[(c &gt;&gt; _rgb_g_shift_15) &amp; 0x1F];
+})
+
+
+AL_INLINE(int, getb15, (int c),
+{
+   return _rgb_scale_5[(c &gt;&gt; _rgb_b_shift_15) &amp; 0x1F];
+})
+
+
+AL_INLINE(int, getr16, (int c),
+{
+   return _rgb_scale_5[(c &gt;&gt; _rgb_r_shift_16) &amp; 0x1F];
+})
+
+
+AL_INLINE(int, getg16, (int c),
+{
+   return _rgb_scale_6[(c &gt;&gt; _rgb_g_shift_16) &amp; 0x3F];
+})
+
+
+AL_INLINE(int, getb16, (int c),
+{
+   return _rgb_scale_5[(c &gt;&gt; _rgb_b_shift_16) &amp; 0x1F];
+})
+
+
+AL_INLINE(int, getr24, (int c),
+{
+   return ((c &gt;&gt; _rgb_r_shift_24) &amp; 0xFF);
+})
+
+
+AL_INLINE(int, getg24, (int c),
+{
+   return ((c &gt;&gt; _rgb_g_shift_24) &amp; 0xFF);
+})
+
+
+AL_INLINE(int, getb24, (int c),
+{
+   return ((c &gt;&gt; _rgb_b_shift_24) &amp; 0xFF);
+})
+
+
+AL_INLINE(int, getr32, (int c),
+{
+   return ((c &gt;&gt; _rgb_r_shift_32) &amp; 0xFF);
+})
+
+
+AL_INLINE(int, getg32, (int c),
+{
+   return ((c &gt;&gt; _rgb_g_shift_32) &amp; 0xFF);
+})
+
+
+AL_INLINE(int, getb32, (int c),
+{
+   return ((c &gt;&gt; _rgb_b_shift_32) &amp; 0xFF);
+})
+
+
+AL_INLINE(int, geta32, (int c),
+{
+   return ((c &gt;&gt; _rgb_a_shift_32) &amp; 0xFF);
+})
+
+
+#ifndef ALLEGRO_DOS
+
+AL_INLINE(void, _set_color, (int index, AL_CONST RGB *p),
+{
+   set_color(index, p);
+})
+
+#endif
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_COLOR_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/draw.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/draw.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/draw.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,373 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Draw inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_DRAW_INL
+#define ALLEGRO_DRAW_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;allegro/debug.h&quot;
+#include &quot;gfx.inl&quot;
+
+
+AL_INLINE(int, getpixel, (BITMAP *bmp, int x, int y),
+{
+   ASSERT(bmp);
+
+   return bmp-&gt;vtable-&gt;getpixel(bmp, x, y);
+})
+
+
+AL_INLINE(void, putpixel, (BITMAP *bmp, int x, int y, int color),
+{
+   ASSERT(bmp);
+
+   bmp-&gt;vtable-&gt;putpixel(bmp, x, y, color);
+})
+
+
+AL_INLINE(void, vline, (BITMAP *bmp, int x, int y1, int y2, int color),
+{
+   ASSERT(bmp);
+
+   bmp-&gt;vtable-&gt;vline(bmp, x, y1, y2, color);
+})
+
+
+AL_INLINE(void, hline, (BITMAP *bmp, int x1, int y, int x2, int color),
+{
+   ASSERT(bmp);
+
+   bmp-&gt;vtable-&gt;hline(bmp, x1, y, x2, color);
+})
+
+
+AL_INLINE(void, line, (BITMAP *bmp, int x1, int y1, int x2, int y2, int color),
+{
+   ASSERT(bmp);
+
+   bmp-&gt;vtable-&gt;line(bmp, x1, y1, x2, y2, color);
+})
+
+
+AL_INLINE(void, rectfill, (BITMAP *bmp, int x1, int y1, int x2, int y2, int color),
+{
+   ASSERT(bmp);
+
+   bmp-&gt;vtable-&gt;rectfill(bmp, x1, y1, x2, y2, color);
+})
+
+
+AL_INLINE(void, draw_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   if (sprite-&gt;vtable-&gt;color_depth == 8) {
+      bmp-&gt;vtable-&gt;draw_256_sprite(bmp, sprite, x, y);
+   }
+   else {
+      ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;vtable-&gt;color_depth);
+      bmp-&gt;vtable-&gt;draw_sprite(bmp, sprite, x, y);
+   }
+})
+
+
+AL_INLINE(void, draw_sprite_v_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y),{
+   ASSERT(bmp);
+   ASSERT(sprite);
+   ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;vtable-&gt;color_depth);
+
+   bmp-&gt;vtable-&gt;draw_sprite_v_flip(bmp, sprite, x, y);
+})
+
+
+AL_INLINE(void, draw_sprite_h_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y),{
+   ASSERT(bmp);
+   ASSERT(sprite);
+   ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;vtable-&gt;color_depth);
+
+   bmp-&gt;vtable-&gt;draw_sprite_h_flip(bmp, sprite, x, y);
+})
+
+
+AL_INLINE(void, draw_sprite_vh_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+   ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;vtable-&gt;color_depth);
+
+   bmp-&gt;vtable-&gt;draw_sprite_vh_flip(bmp, sprite, x, y);
+})
+
+
+AL_INLINE(void, draw_trans_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   if (sprite-&gt;vtable-&gt;color_depth == 32) {
+      ASSERT(bmp-&gt;vtable-&gt;draw_trans_rgba_sprite);
+      bmp-&gt;vtable-&gt;draw_trans_rgba_sprite(bmp, sprite, x, y);
+   }
+   else {
+      ASSERT((bmp-&gt;vtable-&gt;color_depth == sprite-&gt;vtable-&gt;color_depth) ||
+             ((bmp-&gt;vtable-&gt;color_depth == 32) &amp;&amp;
+              (sprite-&gt;vtable-&gt;color_depth == 8)));
+      bmp-&gt;vtable-&gt;draw_trans_sprite(bmp, sprite, x, y);
+   }
+})
+
+
+AL_INLINE(void, draw_lit_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+   ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;vtable-&gt;color_depth);
+
+   bmp-&gt;vtable-&gt;draw_lit_sprite(bmp, sprite, x, y, color);
+})
+
+
+AL_INLINE(void, draw_character, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+   ASSERT(sprite-&gt;vtable-&gt;color_depth == 8);
+
+   bmp-&gt;vtable-&gt;draw_character(bmp, sprite, x, y, color);
+})
+
+
+AL_INLINE(void, rotate_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, (x&lt;&lt;16) + (sprite-&gt;w * 0x10000) / 2,
+			     			      (y&lt;&lt;16) + (sprite-&gt;h * 0x10000) / 2,
+			     			      sprite-&gt;w &lt;&lt; 15, sprite-&gt;h &lt;&lt; 15,
+			     			      angle, 0x10000, FALSE);
+})
+
+
+AL_INLINE(void, rotate_sprite_v_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, (x&lt;&lt;16) + (sprite-&gt;w * 0x10000) / 2,
+			     			      (y&lt;&lt;16) + (sprite-&gt;h * 0x10000) / 2,
+			     			      sprite-&gt;w &lt;&lt; 15, sprite-&gt;h &lt;&lt; 15,
+			     			      angle, 0x10000, TRUE);
+})
+
+
+AL_INLINE(void, rotate_scaled_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, (x&lt;&lt;16) + (sprite-&gt;w * scale) / 2,
+			     			      (y&lt;&lt;16) + (sprite-&gt;h * scale) / 2,
+			     			      sprite-&gt;w &lt;&lt; 15, sprite-&gt;h &lt;&lt; 15,
+			     			      angle, scale, FALSE);
+})
+
+
+AL_INLINE(void, rotate_scaled_sprite_v_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y, fixed angle, fixed scale),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, (x&lt;&lt;16) + (sprite-&gt;w * scale) / 2,
+			     			      (y&lt;&lt;16) + (sprite-&gt;h * scale) / 2,
+			     			      sprite-&gt;w &lt;&lt; 15, sprite-&gt;h &lt;&lt; 15,
+			     			      angle, scale, TRUE);
+})
+
+
+AL_INLINE(void, pivot_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, x&lt;&lt;16, y&lt;&lt;16, cx&lt;&lt;16, cy&lt;&lt;16, angle, 0x10000, FALSE);
+})
+
+
+AL_INLINE(void, pivot_sprite_v_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, x&lt;&lt;16, y&lt;&lt;16, cx&lt;&lt;16, cy&lt;&lt;16, angle, 0x10000, TRUE);
+})
+
+
+AL_INLINE(void, pivot_scaled_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, x&lt;&lt;16, y&lt;&lt;16, cx&lt;&lt;16, cy&lt;&lt;16, angle, scale, FALSE);
+})
+
+
+AL_INLINE(void, pivot_scaled_sprite_v_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y, int cx, int cy, fixed angle, fixed scale),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   bmp-&gt;vtable-&gt;pivot_scaled_sprite_flip(bmp, sprite, x&lt;&lt;16, y&lt;&lt;16, cx&lt;&lt;16, cy&lt;&lt;16, angle, scale, TRUE);
+})
+
+
+AL_INLINE(void, _putpixel, (BITMAP *bmp, int x, int y, int color),
+{
+   unsigned long addr;
+
+   bmp_select(bmp);
+   addr = bmp_write_line(bmp, y);
+   bmp_write8(addr+x, color);
+   bmp_unwrite_line(bmp);
+})
+
+
+AL_INLINE(int, _getpixel, (BITMAP *bmp, int x, int y),
+{
+   unsigned long addr;
+   int c;
+
+   bmp_select(bmp);
+   addr = bmp_read_line(bmp, y);
+   c = bmp_read8(addr+x);
+   bmp_unwrite_line(bmp);
+
+   return c;
+})
+
+
+AL_INLINE(void, _putpixel15, (BITMAP *bmp, int x, int y, int color),
+{
+   unsigned long addr;
+
+   bmp_select(bmp);
+   addr = bmp_write_line(bmp, y);
+   bmp_write15(addr+x*sizeof(short), color);
+   bmp_unwrite_line(bmp);
+})
+
+
+AL_INLINE(int, _getpixel15, (BITMAP *bmp, int x, int y),
+{
+   unsigned long addr;
+   int c;
+
+   bmp_select(bmp);
+   addr = bmp_read_line(bmp, y);
+   c = bmp_read15(addr+x*sizeof(short));
+   bmp_unwrite_line(bmp);
+
+   return c;
+})
+
+
+AL_INLINE(void, _putpixel16, (BITMAP *bmp, int x, int y, int color),
+{
+   unsigned long addr;
+
+   bmp_select(bmp);
+   addr = bmp_write_line(bmp, y);
+   bmp_write16(addr+x*sizeof(short), color);
+   bmp_unwrite_line(bmp);
+})
+
+
+AL_INLINE(int, _getpixel16, (BITMAP *bmp, int x, int y),
+{
+   unsigned long addr;
+   int c;
+
+   bmp_select(bmp);
+   addr = bmp_read_line(bmp, y);
+   c = bmp_read16(addr+x*sizeof(short));
+   bmp_unwrite_line(bmp);
+
+   return c;
+})
+
+
+AL_INLINE(void, _putpixel24, (BITMAP *bmp, int x, int y, int color),
+{
+   unsigned long addr;
+
+   bmp_select(bmp);
+   addr = bmp_write_line(bmp, y);
+   bmp_write24(addr+x*3, color);
+   bmp_unwrite_line(bmp);
+})
+
+
+AL_INLINE(int, _getpixel24, (BITMAP *bmp, int x, int y),
+{
+   unsigned long addr;
+   int c;
+
+   bmp_select(bmp);
+   addr = bmp_read_line(bmp, y);
+   c = bmp_read24(addr+x*3);
+   bmp_unwrite_line(bmp);
+
+   return c;
+})
+
+
+AL_INLINE(void, _putpixel32, (BITMAP *bmp, int x, int y, int color),
+{
+   unsigned long addr;
+
+   bmp_select(bmp);
+   addr = bmp_write_line(bmp, y);
+   bmp_write32(addr+x*sizeof(long), color);
+   bmp_unwrite_line(bmp);
+})
+
+
+AL_INLINE(int, _getpixel32, (BITMAP *bmp, int x, int y),
+{
+   unsigned long addr;
+   int c;
+
+   bmp_select(bmp);
+   addr = bmp_read_line(bmp, y);
+   c = bmp_read32(addr+x*sizeof(long));
+   bmp_unwrite_line(bmp);
+
+   return c;
+})
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_DRAW_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/file.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/file.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/file.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,63 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      File inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FILE_INL
+#define ALLEGRO_FILE_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+AL_INLINE(int, pack_getc, (PACKFILE *f),
+{
+   f-&gt;buf_size--;
+   if (f-&gt;buf_size &gt; 0)
+      return *(f-&gt;buf_pos++);
+   else
+      return _sort_out_getc(f);
+})
+
+
+AL_INLINE(int, pack_putc, (int c, PACKFILE *f),
+{
+   f-&gt;buf_size++;
+   if (f-&gt;buf_size &gt;= F_BUF_SIZE)
+      return _sort_out_putc(c, f);
+   else
+      return (*(f-&gt;buf_pos++) = c);
+})
+
+
+AL_INLINE(int, pack_feof, (PACKFILE *f),
+{
+   return (f-&gt;flags &amp; PACKFILE_FLAG_EOF);
+})
+
+
+AL_INLINE(int, pack_ferror, (PACKFILE *f),
+{
+   return (f-&gt;flags &amp; PACKFILE_FLAG_ERROR);
+})
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_FILE_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/fix.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/fix.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/fix.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,254 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Fix class inline functions.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FIX_INL
+#define ALLEGRO_FIX_INL
+
+#ifdef __cplusplus
+
+
+inline  fix operator +  (const fix x, const fix y)    { fix t;  t.v = x.v + y.v;        return t; }
+inline  fix operator +  (const fix x, const int y)    { fix t;  t.v = x.v + itofix(y);  return t; }
+inline  fix operator +  (const int x, const fix y)    { fix t;  t.v = itofix(x) + y.v;  return t; }
+inline  fix operator +  (const fix x, const long y)   { fix t;  t.v = x.v + itofix(y);  return t; }
+inline  fix operator +  (const long x, const fix y)   { fix t;  t.v = itofix(x) + y.v;  return t; }
+inline  fix operator +  (const fix x, const float y)  { fix t;  t.v = x.v + ftofix(y);  return t; }
+inline  fix operator +  (const float x, const fix y)  { fix t;  t.v = ftofix(x) + y.v;  return t; }
+inline  fix operator +  (const fix x, const double y) { fix t;  t.v = x.v + ftofix(y);  return t; }
+inline  fix operator +  (const double x, const fix y) { fix t;  t.v = ftofix(x) + y.v;  return t; }
+
+inline  fix operator -  (const fix x, const fix y)    { fix t;  t.v = x.v - y.v;        return t; }
+inline  fix operator -  (const fix x, const int y)    { fix t;  t.v = x.v - itofix(y);  return t; }
+inline  fix operator -  (const int x, const fix y)    { fix t;  t.v = itofix(x) - y.v;  return t; }
+inline  fix operator -  (const fix x, const long y)   { fix t;  t.v = x.v - itofix(y);  return t; }
+inline  fix operator -  (const long x, const fix y)   { fix t;  t.v = itofix(x) - y.v;  return t; }
+inline  fix operator -  (const fix x, const float y)  { fix t;  t.v = x.v - ftofix(y);  return t; }
+inline  fix operator -  (const float x, const fix y)  { fix t;  t.v = ftofix(x) - y.v;  return t; }
+inline  fix operator -  (const fix x, const double y) { fix t;  t.v = x.v - ftofix(y);  return t; }
+inline  fix operator -  (const double x, const fix y) { fix t;  t.v = ftofix(x) - y.v;  return t; }
+
+inline  fix operator *  (const fix x, const fix y)    { fix t;  t.v = fixmul(x.v, y.v);         return t; }
+inline  fix operator *  (const fix x, const int y)    { fix t;  t.v = x.v * y;                  return t; }
+inline  fix operator *  (const int x, const fix y)    { fix t;  t.v = x * y.v;                  return t; }
+inline  fix operator *  (const fix x, const long y)   { fix t;  t.v = x.v * y;                  return t; }
+inline  fix operator *  (const long x, const fix y)   { fix t;  t.v = x * y.v;                  return t; }
+inline  fix operator *  (const fix x, const float y)  { fix t;  t.v = ftofix(fixtof(x.v) * y);  return t; }
+inline  fix operator *  (const float x, const fix y)  { fix t;  t.v = ftofix(x * fixtof(y.v));  return t; }
+inline  fix operator *  (const fix x, const double y) { fix t;  t.v = ftofix(fixtof(x.v) * y);  return t; }
+inline  fix operator *  (const double x, const fix y) { fix t;  t.v = ftofix(x * fixtof(y.v));  return t; }
+
+inline  fix operator /  (const fix x, const fix y)    { fix t;  t.v = fixdiv(x.v, y.v);         return t; }
+inline  fix operator /  (const fix x, const int y)    { fix t;  t.v = x.v / y;                  return t; }
+inline  fix operator /  (const int x, const fix y)    { fix t;  t.v = fixdiv(itofix(x), y.v);   return t; }
+inline  fix operator /  (const fix x, const long y)   { fix t;  t.v = x.v / y;                  return t; }
+inline  fix operator /  (const long x, const fix y)   { fix t;  t.v = fixdiv(itofix(x), y.v);   return t; }
+inline  fix operator /  (const fix x, const float y)  { fix t;  t.v = ftofix(fixtof(x.v) / y);  return t; }
+inline  fix operator /  (const float x, const fix y)  { fix t;  t.v = ftofix(x / fixtof(y.v));  return t; }
+inline  fix operator /  (const fix x, const double y) { fix t;  t.v = ftofix(fixtof(x.v) / y);  return t; }
+inline  fix operator /  (const double x, const fix y) { fix t;  t.v = ftofix(x / fixtof(y.v));  return t; }
+
+inline  fix operator &lt;&lt; (const fix x, const int y)    { fix t;  t.v = x.v &lt;&lt; y;   return t; }
+inline  fix operator &gt;&gt; (const fix x, const int y)    { fix t;  t.v = x.v &gt;&gt; y;   return t; }
+
+inline  int operator == (const fix x, const fix y)    { return (x.v == y.v);       }
+inline  int operator == (const fix x, const int y)    { return (x.v == itofix(y)); }
+inline  int operator == (const int x, const fix y)    { return (itofix(x) == y.v); }
+inline  int operator == (const fix x, const long y)   { return (x.v == itofix(y)); }
+inline  int operator == (const long x, const fix y)   { return (itofix(x) == y.v); }
+inline  int operator == (const fix x, const float y)  { return (x.v == ftofix(y)); }
+inline  int operator == (const float x, const fix y)  { return (ftofix(x) == y.v); }
+inline  int operator == (const fix x, const double y) { return (x.v == ftofix(y)); }
+inline  int operator == (const double x, const fix y) { return (ftofix(x) == y.v); }
+
+inline  int operator != (const fix x, const fix y)    { return (x.v != y.v);       }
+inline  int operator != (const fix x, const int y)    { return (x.v != itofix(y)); }
+inline  int operator != (const int x, const fix y)    { return (itofix(x) != y.v); }
+inline  int operator != (const fix x, const long y)   { return (x.v != itofix(y)); }
+inline  int operator != (const long x, const fix y)   { return (itofix(x) != y.v); }
+inline  int operator != (const fix x, const float y)  { return (x.v != ftofix(y)); }
+inline  int operator != (const float x, const fix y)  { return (ftofix(x) != y.v); }
+inline  int operator != (const fix x, const double y) { return (x.v != ftofix(y)); }
+inline  int operator != (const double x, const fix y) { return (ftofix(x) != y.v); }
+
+inline  int operator &lt;  (const fix x, const fix y)    { return (x.v &lt; y.v);        }
+inline  int operator &lt;  (const fix x, const int y)    { return (x.v &lt; itofix(y));  }
+inline  int operator &lt;  (const int x, const fix y)    { return (itofix(x) &lt; y.v);  }
+inline  int operator &lt;  (const fix x, const long y)   { return (x.v &lt; itofix(y));  }
+inline  int operator &lt;  (const long x, const fix y)   { return (itofix(x) &lt; y.v);  }
+inline  int operator &lt;  (const fix x, const float y)  { return (x.v &lt; ftofix(y));  }
+inline  int operator &lt;  (const float x, const fix y)  { return (ftofix(x) &lt; y.v);  }
+inline  int operator &lt;  (const fix x, const double y) { return (x.v &lt; ftofix(y));  }
+inline  int operator &lt;  (const double x, const fix y) { return (ftofix(x) &lt; y.v);  }
+
+inline  int operator &gt;  (const fix x, const fix y)    { return (x.v &gt; y.v);        }
+inline  int operator &gt;  (const fix x, const int y)    { return (x.v &gt; itofix(y));  }
+inline  int operator &gt;  (const int x, const fix y)    { return (itofix(x) &gt; y.v);  }
+inline  int operator &gt;  (const fix x, const long y)   { return (x.v &gt; itofix(y));  }
+inline  int operator &gt;  (const long x, const fix y)   { return (itofix(x) &gt; y.v);  }
+inline  int operator &gt;  (const fix x, const float y)  { return (x.v &gt; ftofix(y));  }
+inline  int operator &gt;  (const float x, const fix y)  { return (ftofix(x) &gt; y.v);  }
+inline  int operator &gt;  (const fix x, const double y) { return (x.v &gt; ftofix(y));  }
+inline  int operator &gt;  (const double x, const fix y) { return (ftofix(x) &gt; y.v);  }
+
+inline  int operator &lt;= (const fix x, const fix y)    { return (x.v &lt;= y.v);       }
+inline  int operator &lt;= (const fix x, const int y)    { return (x.v &lt;= itofix(y)); }
+inline  int operator &lt;= (const int x, const fix y)    { return (itofix(x) &lt;= y.v); }
+inline  int operator &lt;= (const fix x, const long y)   { return (x.v &lt;= itofix(y)); }
+inline  int operator &lt;= (const long x, const fix y)   { return (itofix(x) &lt;= y.v); }
+inline  int operator &lt;= (const fix x, const float y)  { return (x.v &lt;= ftofix(y)); }
+inline  int operator &lt;= (const float x, const fix y)  { return (ftofix(x) &lt;= y.v); }
+inline  int operator &lt;= (const fix x, const double y) { return (x.v &lt;= ftofix(y)); }
+inline  int operator &lt;= (const double x, const fix y) { return (ftofix(x) &lt;= y.v); }
+
+inline  int operator &gt;= (const fix x, const fix y)    { return (x.v &gt;= y.v);       }
+inline  int operator &gt;= (const fix x, const int y)    { return (x.v &gt;= itofix(y)); }
+inline  int operator &gt;= (const int x, const fix y)    { return (itofix(x) &gt;= y.v); }
+inline  int operator &gt;= (const fix x, const long y)   { return (x.v &gt;= itofix(y)); }
+inline  int operator &gt;= (const long x, const fix y)   { return (itofix(x) &gt;= y.v); }
+inline  int operator &gt;= (const fix x, const float y)  { return (x.v &gt;= ftofix(y)); }
+inline  int operator &gt;= (const float x, const fix y)  { return (ftofix(x) &gt;= y.v); }
+inline  int operator &gt;= (const fix x, const double y) { return (x.v &gt;= ftofix(y)); }
+inline  int operator &gt;= (const double x, const fix y) { return (ftofix(x) &gt;= y.v); }
+
+inline  fix sqrt(fix x)          { fix t;  t.v = fixsqrt(x.v);        return t; }
+inline  fix cos(fix x)           { fix t;  t.v = fixcos(x.v);         return t; }
+inline  fix sin(fix x)           { fix t;  t.v = fixsin(x.v);         return t; }
+inline  fix tan(fix x)           { fix t;  t.v = fixtan(x.v);         return t; }
+inline  fix acos(fix x)          { fix t;  t.v = fixacos(x.v);        return t; }
+inline  fix asin(fix x)          { fix t;  t.v = fixasin(x.v);        return t; }
+inline  fix atan(fix x)          { fix t;  t.v = fixatan(x.v);        return t; }
+inline  fix atan2(fix x, fix y)  { fix t;  t.v = fixatan2(x.v, y.v);  return t; }
+
+
+inline void get_translation_matrix(MATRIX *m, fix x, fix y, fix z)
+{
+   get_translation_matrix(m, x.v, y.v, z.v);
+}
+
+
+inline void get_scaling_matrix(MATRIX *m, fix x, fix y, fix z)
+{
+   get_scaling_matrix(m, x.v, y.v, z.v);
+}
+
+
+inline void get_x_rotate_matrix(MATRIX *m, fix r)
+{
+   get_x_rotate_matrix(m, r.v);
+}
+
+
+inline void get_y_rotate_matrix(MATRIX *m, fix r)
+{
+   get_y_rotate_matrix(m, r.v);
+}
+
+
+inline void get_z_rotate_matrix(MATRIX *m, fix r)
+{
+   get_z_rotate_matrix(m, r.v);
+}
+
+
+inline void get_rotation_matrix(MATRIX *m, fix x, fix y, fix z)
+{
+   get_rotation_matrix(m, x.v, y.v, z.v);
+}
+
+
+inline void get_align_matrix(MATRIX *m, fix xfront, fix yfront, fix zfront, fix xup, fix yup, fix zup)
+{
+   get_align_matrix(m, xfront.v, yfront.v, zfront.v, xup.v, yup.v, zup.v);
+}
+
+
+inline void get_vector_rotation_matrix(MATRIX *m, fix x, fix y, fix z, fix a)
+{
+   get_vector_rotation_matrix(m, x.v, y.v, z.v, a.v);
+}
+
+
+inline void get_transformation_matrix(MATRIX *m, fix scale, fix xrot, fix yrot, fix zrot, fix x, fix y, fix z)
+{
+   get_transformation_matrix(m, scale.v, xrot.v, yrot.v, zrot.v, x.v, y.v, z.v);
+}
+
+
+inline void get_camera_matrix(MATRIX *m, fix x, fix y, fix z, fix xfront, fix yfront, fix zfront, fix xup, fix yup, fix zup, fix fov, fix aspect)
+{
+   get_camera_matrix(m, x.v, y.v, z.v, xfront.v, yfront.v, zfront.v, xup.v, yup.v, zup.v, fov.v, aspect.v);
+}
+
+
+inline void qtranslate_matrix(MATRIX *m, fix x, fix y, fix z)
+{
+   qtranslate_matrix(m, x.v, y.v, z.v);
+}
+
+
+inline void qscale_matrix(MATRIX *m, fix scale)
+{
+   qscale_matrix(m, scale.v);
+}
+
+
+inline fix vector_length(fix x, fix y, fix z)
+{
+   fix t;
+   t.v = vector_length(x.v, y.v, z.v);
+   return t;
+}
+
+
+inline void normalize_vector(fix *x, fix *y, fix *z)
+{
+   normalize_vector(&amp;x-&gt;v, &amp;y-&gt;v, &amp;z-&gt;v);
+}
+
+
+inline void cross_product(fix x1, fix y1, fix z1, fix x2, fix y2, fix z2, fix *xout, fix *yout, fix *zout)
+{
+   cross_product(x1.v, y1.v, z1.v, x2.v, y2.v, z2.v, &amp;xout-&gt;v, &amp;yout-&gt;v, &amp;zout-&gt;v);
+}
+
+
+inline fix dot_product(fix x1, fix y1, fix z1, fix x2, fix y2, fix z2)
+{
+   fix t;
+   t.v = dot_product(x1.v, y1.v, z1.v, x2.v, y2.v, z2.v);
+   return t;
+}
+
+
+inline void apply_matrix(MATRIX *m, fix x, fix y, fix z, fix *xout, fix *yout, fix *zout)
+{
+   apply_matrix(m, x.v, y.v, z.v, &amp;xout-&gt;v, &amp;yout-&gt;v, &amp;zout-&gt;v);
+}
+
+
+inline void persp_project(fix x, fix y, fix z, fix *xout, fix *yout)
+{
+   persp_project(x.v, y.v, z.v, &amp;xout-&gt;v, &amp;yout-&gt;v);
+}
+
+
+#endif          /* ifdef __cplusplus */
+
+#endif          /* ifndef ALLEGRO_FIX_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/fmaths.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/fmaths.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/fmaths.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,202 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Fixed point math inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_FMATHS_INL
+#define ALLEGRO_FMATHS_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+#define ALLEGRO_IMPORT_MATH_ASM
+#include &quot;asm.inl&quot;
+#undef ALLEGRO_IMPORT_MATH_ASM
+
+
+/* ftofix and fixtof are used in generic C versions of fixmul and fixdiv */
+AL_INLINE(fixed, ftofix, (double x),
+{
+   if (x &gt; 32767.0) {
+      *allegro_errno = ERANGE;
+      return 0x7FFFFFFF;
+   }
+
+   if (x &lt; -32767.0) {
+      *allegro_errno = ERANGE;
+      return -0x7FFFFFFF;
+   }
+
+   return (long)(x * 65536.0 + (x &lt; 0 ? -0.5 : 0.5));
+})
+
+
+AL_INLINE(double, fixtof, (fixed x),
+{
+   return (double)x / 65536.0;
+})
+
+
+#ifdef ALLEGRO_NO_ASM
+
+/* use generic C versions */
+
+AL_INLINE(fixed, fixadd, (fixed x, fixed y),
+{
+   fixed result = x + y;
+
+   if (result &gt;= 0) {
+      if ((x &lt; 0) &amp;&amp; (y &lt; 0)) {
+         *allegro_errno = ERANGE;
+         return -0x7FFFFFFF;
+      }
+      else
+         return result;
+   }
+   else {
+      if ((x &gt; 0) &amp;&amp; (y &gt; 0)) {
+         *allegro_errno = ERANGE;
+         return 0x7FFFFFFF;
+      }
+      else
+         return result;
+   }
+})
+
+
+AL_INLINE(fixed, fixsub, (fixed x, fixed y),
+{
+   fixed result = x - y;
+
+   if (result &gt;= 0) {
+      if ((x &lt; 0) &amp;&amp; (y &gt; 0)) {
+         *allegro_errno = ERANGE;
+         return -0x7FFFFFFF;
+      }
+      else
+         return result;
+   }
+   else {
+      if ((x &gt; 0) &amp;&amp; (y &lt; 0)) {
+         *allegro_errno = ERANGE;
+         return 0x7FFFFFFF;
+      }
+      else
+         return result;
+   }
+})
+
+
+AL_INLINE(fixed, fixmul, (fixed x, fixed y),
+{
+   return ftofix(fixtof(x) * fixtof(y));
+})
+
+
+AL_INLINE(fixed, fixdiv, (fixed x, fixed y),
+{
+   if (y == 0) {
+      *allegro_errno = ERANGE;
+      return (x &lt; 0) ? -0x7FFFFFFF : 0x7FFFFFFF;
+   }
+   else
+      return ftofix(fixtof(x) / fixtof(y));
+})
+
+
+AL_INLINE(int, fixfloor, (fixed x),
+{
+   /* (x &gt;&gt; 16) is not portable */
+   if (x &gt;= 0)
+      return (x &gt;&gt; 16);
+   else
+      return ~((~x) &gt;&gt; 16);
+})
+
+
+AL_INLINE(int, fixceil, (fixed x),
+{
+   if (x &gt; (long)(0x7FFF0000)) {
+      *allegro_errno = ERANGE;
+      return 0x7FFF;
+   }
+
+   return fixfloor(x + 0xFFFF);
+})
+
+#endif      /* C vs. inline asm */
+
+
+AL_INLINE(fixed, itofix, (int x),
+{
+   return x &lt;&lt; 16;
+})
+
+
+AL_INLINE(int, fixtoi, (fixed x),
+{
+   return fixfloor(x) + ((x &amp; 0x8000) &gt;&gt; 15);
+})
+
+
+AL_INLINE(fixed, fixcos, (fixed x),
+{
+   return _cos_tbl[((x + 0x4000) &gt;&gt; 15) &amp; 0x1FF];
+})
+
+
+AL_INLINE(fixed, fixsin, (fixed x),
+{
+   return _cos_tbl[((x - 0x400000 + 0x4000) &gt;&gt; 15) &amp; 0x1FF];
+})
+
+
+AL_INLINE(fixed, fixtan, (fixed x),
+{
+   return _tan_tbl[((x + 0x4000) &gt;&gt; 15) &amp; 0xFF];
+})
+
+
+AL_INLINE(fixed, fixacos, (fixed x),
+{
+   if ((x &lt; -65536) || (x &gt; 65536)) {
+      *allegro_errno = EDOM;
+      return 0;
+   }
+
+   return _acos_tbl[(x+65536+127)&gt;&gt;8];
+})
+
+
+AL_INLINE(fixed, fixasin, (fixed x),
+{
+   if ((x &lt; -65536) || (x &gt; 65536)) {
+      *allegro_errno = EDOM;
+      return 0;
+   }
+
+   return 0x00400000 - _acos_tbl[(x+65536+127)&gt;&gt;8];
+})
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_FMATHS_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/gfx.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/gfx.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/gfx.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,233 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Graphics inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_GFX_INL
+#define ALLEGRO_GFX_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;allegro/debug.h&quot;
+
+
+#define ALLEGRO_IMPORT_GFX_ASM
+#include &quot;asm.inl&quot;
+#undef ALLEGRO_IMPORT_GFX_ASM
+
+
+#ifdef ALLEGRO_NO_ASM
+
+   /* use generic C versions */
+
+AL_INLINE(int, _default_ds, (void),
+{
+   return 0;
+})
+
+#ifdef ALLEGRO_BCC32
+
+   /* BCC32 is a somewhat unusual platform because it mixes a MSVC/MinGW generated DLL
+    * (for which ALLEGRO_NO_ASM is not defined) with Borland C++ compiled programs for
+    * which ALLEGRO_NO_ASM is defined. As a result, Borland C++ compiled programs can't
+    * use the inlined version of bmp_write_line(), bmp_read_line() and bmp_unwrite_line()
+    * because the write_bank() and read_bank() methods of the BITMAP class don't expect
+    * the same calling convention on both sides.
+    */
+
+AL_FUNC(unsigned long, bmp_write_line, (BITMAP *bmp, int line));
+AL_FUNC(unsigned long, bmp_read_line, (BITMAP *bmp, int line));
+AL_FUNC(void, bmp_unwrite_line, (BITMAP *bmp));
+
+#else
+
+typedef AL_METHOD(unsigned long, _BMP_BANK_SWITCHER, (BITMAP *bmp, int line));
+typedef AL_METHOD(void, _BMP_UNBANK_SWITCHER, (BITMAP *bmp));
+
+
+AL_INLINE(unsigned long, bmp_write_line, (BITMAP *bmp, int line),
+{
+   _BMP_BANK_SWITCHER switcher = (_BMP_BANK_SWITCHER)bmp-&gt;write_bank;
+   return switcher(bmp, line);
+})
+
+
+AL_INLINE(unsigned long, bmp_read_line, (BITMAP *bmp, int line),
+{
+   _BMP_BANK_SWITCHER switcher = (_BMP_BANK_SWITCHER)bmp-&gt;read_bank;
+   return switcher(bmp, line);
+})
+
+
+AL_INLINE(void, bmp_unwrite_line, (BITMAP *bmp),
+{
+   _BMP_UNBANK_SWITCHER switcher = (_BMP_UNBANK_SWITCHER)bmp-&gt;vtable-&gt;unwrite_bank;
+   switcher(bmp);
+})
+
+#endif      /* defined ALLEGRO_BCC32 */
+
+#endif      /* C vs. inline asm */
+
+
+AL_INLINE(void, clear_to_color, (BITMAP *bitmap, int color),
+{
+   ASSERT(bitmap);
+
+   bitmap-&gt;vtable-&gt;clear_to_color(bitmap, color);
+})
+
+
+AL_INLINE(int, bitmap_color_depth, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return bmp-&gt;vtable-&gt;color_depth;
+})
+
+
+AL_INLINE(int, bitmap_mask_color, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return bmp-&gt;vtable-&gt;mask_color;
+})
+
+
+AL_INLINE(int, is_same_bitmap, (BITMAP *bmp1, BITMAP *bmp2),
+{
+   unsigned long m1;
+   unsigned long m2;
+
+   if ((!bmp1) || (!bmp2))
+      return FALSE;
+
+   if (bmp1 == bmp2)
+      return TRUE;
+
+   m1 = bmp1-&gt;id &amp; BMP_ID_MASK;
+   m2 = bmp2-&gt;id &amp; BMP_ID_MASK;
+
+   return ((m1) &amp;&amp; (m1 == m2));
+})
+
+
+AL_INLINE(int, is_linear_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return (bmp-&gt;id &amp; BMP_ID_PLANAR) == 0;
+})
+
+
+AL_INLINE(int, is_planar_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return (bmp-&gt;id &amp; BMP_ID_PLANAR) != 0;
+})
+
+
+AL_INLINE(int, is_memory_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return (bmp-&gt;id &amp; (BMP_ID_VIDEO | BMP_ID_SYSTEM)) == 0;
+})
+
+
+AL_INLINE(int, is_screen_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return is_same_bitmap(bmp, screen);
+})
+
+
+AL_INLINE(int, is_video_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return (bmp-&gt;id &amp; BMP_ID_VIDEO) != 0;
+})
+
+
+AL_INLINE(int, is_system_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return (bmp-&gt;id &amp; BMP_ID_SYSTEM) != 0;
+})
+
+
+AL_INLINE(int, is_sub_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   return (bmp-&gt;id &amp; BMP_ID_SUB) != 0;
+})
+
+
+
+#ifdef ALLEGRO_MPW
+
+   #define acquire_bitmap(bmp)
+   #define release_bitmap(bmp)
+   #define acquire_screen()
+   #define release_screen()
+
+#else
+
+AL_INLINE(void, acquire_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   if (bmp-&gt;vtable-&gt;acquire)
+      bmp-&gt;vtable-&gt;acquire(bmp);
+})
+
+
+AL_INLINE(void, release_bitmap, (BITMAP *bmp),
+{
+   ASSERT(bmp);
+
+   if (bmp-&gt;vtable-&gt;release)
+      bmp-&gt;vtable-&gt;release(bmp);
+})
+
+
+AL_INLINE(void, acquire_screen, (void),
+{
+   acquire_bitmap(screen);
+})
+
+
+AL_INLINE(void, release_screen, (void),
+{
+   release_bitmap(screen);
+})
+
+#endif
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_GFX_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/gui.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/gui.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/gui.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,54 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      GUI inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_GUI_INL
+#define ALLEGRO_GUI_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+AL_INLINE(int, object_message, (DIALOG *d, int msg, int c),
+{
+   int ret;
+
+   if (msg == MSG_DRAW) {
+      if (d-&gt;flags &amp; D_HIDDEN) return D_O_K;
+      acquire_screen();
+   }
+
+   ret = d-&gt;proc(msg, d, c);
+
+   if (msg == MSG_DRAW)
+      release_screen();
+
+   if (ret &amp; D_REDRAWME) {
+      d-&gt;flags |= D_DIRTY;
+      ret &amp;= ~D_REDRAWME;
+   }
+
+   return ret;
+})
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_GUI_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/matrix.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/matrix.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/matrix.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,48 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Matrix math inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_MATRIX_INL
+#define ALLEGRO_MATRIX_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+#define CALC_ROW(n)     (fixmul(x, m-&gt;v[n][0]) +      \
+                         fixmul(y, m-&gt;v[n][1]) +      \
+                         fixmul(z, m-&gt;v[n][2]) +      \
+                         m-&gt;t[n])
+
+AL_INLINE(void, apply_matrix, (MATRIX *m, fixed x, fixed y, fixed z, fixed *xout, fixed *yout, fixed *zout),
+{
+   *xout = CALC_ROW(0);
+   *yout = CALC_ROW(1);
+   *zout = CALC_ROW(2);
+})
+
+#undef CALC_ROW
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_MATRIX_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/rle.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/rle.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/rle.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,70 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      RLE sprite inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_RLE_INL
+#define ALLEGRO_RLE_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;allegro/debug.h&quot;
+
+
+AL_INLINE(void, draw_rle_sprite, (struct BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+   ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;color_depth);
+
+   bmp-&gt;vtable-&gt;draw_rle_sprite(bmp, sprite, x, y);
+})
+
+
+AL_INLINE(void, draw_trans_rle_sprite, (struct BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+
+   if (sprite-&gt;color_depth == 32) {
+      ASSERT(bmp-&gt;vtable-&gt;draw_trans_rgba_rle_sprite);
+      bmp-&gt;vtable-&gt;draw_trans_rgba_rle_sprite(bmp, sprite, x, y);
+   }
+   else {
+      ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;color_depth);
+      bmp-&gt;vtable-&gt;draw_trans_rle_sprite(bmp, sprite, x, y);
+   }
+})
+
+
+AL_INLINE(void, draw_lit_rle_sprite, (struct BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color),
+{
+   ASSERT(bmp);
+   ASSERT(sprite);
+   ASSERT(bmp-&gt;vtable-&gt;color_depth == sprite-&gt;color_depth);
+
+   bmp-&gt;vtable-&gt;draw_lit_rle_sprite(bmp, sprite, x, y, color);
+})
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_RLE_INL */
+
+

Added: trunk/msvc-libs/include/allegro/inline/system.inl
===================================================================
--- trunk/msvc-libs/include/allegro/inline/system.inl	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/inline/system.inl	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,101 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      System inline functions (generic C).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_SYSTEM_INL
+#define ALLEGRO_SYSTEM_INL
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;allegro/debug.h&quot;
+
+
+AL_INLINE(void, set_window_title, (AL_CONST char *name),
+{
+   ASSERT(system_driver);
+
+   if (system_driver-&gt;set_window_title)
+      system_driver-&gt;set_window_title(name);
+})
+
+
+#define ALLEGRO_WINDOW_CLOSE_MESSAGE                                         \
+   &quot;Warning: forcing program shutdown may lead to data loss and unexpected &quot; \
+   &quot;results. It is preferable to use the exit command inside the window. &quot;   \
+   &quot;Proceed anyway?&quot;
+
+
+AL_INLINE(int, set_window_close_button, (int enable),
+{
+   ASSERT(system_driver);
+
+   if (system_driver-&gt;set_window_close_button)
+      return system_driver-&gt;set_window_close_button(enable);
+
+   return -1;
+})
+
+
+AL_INLINE(void, set_window_close_hook, (AL_METHOD(void, proc, (void))),
+{
+   ASSERT(system_driver);
+
+   if (system_driver-&gt;set_window_close_hook)
+      system_driver-&gt;set_window_close_hook(proc);
+})
+
+
+AL_INLINE(int, desktop_color_depth, (void),
+{
+   ASSERT(system_driver);
+
+   if (system_driver-&gt;desktop_color_depth)
+      return system_driver-&gt;desktop_color_depth();
+   else
+      return 0;
+})
+
+
+AL_INLINE(int, get_desktop_resolution, (int *width, int *height),
+{
+   ASSERT(system_driver);
+
+   if (system_driver-&gt;get_desktop_resolution)
+      return system_driver-&gt;get_desktop_resolution(width, height);
+   else
+      return -1;
+})
+
+
+AL_INLINE(void, yield_timeslice, (void),
+{
+   ASSERT(system_driver);
+
+   if (system_driver-&gt;yield_timeslice)
+      system_driver-&gt;yield_timeslice();
+})
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_SYSTEM_INL */
+
+

Added: trunk/msvc-libs/include/allegro/internal/aintern.h
===================================================================
--- trunk/msvc-libs/include/allegro/internal/aintern.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/internal/aintern.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,1157 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Some definitions for internal use by the library code.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTERN_H
+#define AINTERN_H
+
+#ifndef ALLEGRO_H
+   #error must include allegro.h first
+#endif
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+/* flag for how many times we have been initialised */
+AL_VAR(int, _allegro_count);
+
+
+/* some Allegro functions need a block of scratch memory */
+AL_VAR(void *, _scratch_mem);
+AL_VAR(int, _scratch_mem_size);
+
+
+AL_INLINE(void, _grow_scratch_mem, (int size),
+{
+   if (size &gt; _scratch_mem_size) {
+      size = (size+1023) &amp; 0xFFFFFC00;
+      _scratch_mem = realloc(_scratch_mem, size);
+      _scratch_mem_size = size;
+   }
+})
+
+
+/* malloc wrappers for DLL &lt;-&gt; application shared memory */
+AL_FUNC(void *, _al_malloc, (int size));
+AL_FUNC(void, _al_free, (void *mem));
+AL_FUNC(void *, _al_realloc, (void *mem, int size));
+
+
+/* list of functions to call at program cleanup */
+AL_FUNC(void, _add_exit_func, (AL_METHOD(void, func, (void))));
+AL_FUNC(void, _remove_exit_func, (AL_METHOD(void, func, (void))));
+
+
+/* helper structure for talking to Unicode strings */
+typedef struct UTYPE_INFO
+{
+   int id;
+   AL_METHOD(int, u_getc, (AL_CONST char *s));
+   AL_METHOD(int, u_getx, (char **s));
+   AL_METHOD(int, u_setc, (char *s, int c));
+   AL_METHOD(int, u_width, (AL_CONST char *s));
+   AL_METHOD(int, u_cwidth, (int c));
+   AL_METHOD(int, u_isok, (int c));
+   int u_width_max;
+} UTYPE_INFO;
+
+AL_FUNC(UTYPE_INFO *, _find_utype, (int type));
+
+
+/* message stuff */
+#define ALLEGRO_MESSAGE_SIZE  4096
+
+
+/* wrappers for implementing disk I/O on different platforms */
+AL_FUNC(int, _al_file_isok, (AL_CONST char *filename));
+AL_FUNC(long, _al_file_size, (AL_CONST char *filename));
+AL_FUNC(time_t, _al_file_time, (AL_CONST char *filename));
+AL_FUNC(int, _al_drive_exists, (int drive));
+AL_FUNC(int, _al_getdrive, (void));
+AL_FUNC(void, _al_getdcwd, (int drive, char *buf, int size));
+
+
+/* packfile stuff */
+AL_VAR(int, _packfile_filesize);
+AL_VAR(int, _packfile_datasize);
+AL_VAR(int, _packfile_type);
+AL_FUNC(PACKFILE *, _pack_fdopen, (int fd, AL_CONST char *mode));
+
+
+/* various bits of mouse stuff */
+AL_FUNC(void, _handle_mouse_input, (void));
+
+AL_VAR(int, _mouse_x);
+AL_VAR(int, _mouse_y);
+AL_VAR(int, _mouse_z);
+AL_VAR(int, _mouse_b);
+AL_VAR(int, _mouse_on);
+
+AL_VAR(int, _mouse_installed);
+
+AL_VAR(int, _mouse_type);
+AL_VAR(BITMAP *, _mouse_screen);
+AL_VAR(BITMAP *, _mouse_pointer);
+
+
+/* various bits of timer stuff */
+AL_FUNC(long, _handle_timer_tick, (int interval));
+
+#define MAX_TIMERS      16
+
+/* list of active timer handlers */
+typedef struct TIMER_QUEUE
+{
+   AL_METHOD(void, proc, (void));      /* timer handler functions */
+   AL_METHOD(void, param_proc, (void *param));
+   void *param;                        /* param for param_proc if used */
+   long speed;                         /* timer speed */
+   long counter;                       /* counts down to zero=blastoff */
+} TIMER_QUEUE;
+
+AL_ARRAY(TIMER_QUEUE, _timer_queue);
+
+AL_VAR(int, _timer_installed);
+
+AL_VAR(int, _timer_use_retrace);
+AL_VAR(volatile int, _retrace_hpp_value);
+
+
+/* various bits of keyboard stuff */
+AL_FUNC(void, _handle_key_press, (int keycode, int scancode));
+AL_FUNC(void, _handle_key_release, (int scancode));
+
+AL_VAR(int, _keyboard_installed);
+
+AL_ARRAY(volatile char, _key);
+AL_VAR(volatile int, _key_shifts);
+
+AL_FUNC(void, _pckeys_init, (void));
+AL_FUNC(void, _handle_pckey, (int code));
+AL_FUNC(int,  _pckey_scancode_to_ascii, (int scancode));
+
+AL_VAR(unsigned short *, _key_ascii_table);
+AL_VAR(unsigned short *, _key_capslock_table);
+AL_VAR(unsigned short *, _key_shift_table);
+AL_VAR(unsigned short *, _key_control_table);
+AL_VAR(unsigned short *, _key_altgr_lower_table);
+AL_VAR(unsigned short *, _key_altgr_upper_table);
+AL_VAR(unsigned short *, _key_accent1_lower_table);
+AL_VAR(unsigned short *, _key_accent1_upper_table);
+AL_VAR(unsigned short *, _key_accent2_lower_table);
+AL_VAR(unsigned short *, _key_accent2_upper_table);
+AL_VAR(unsigned short *, _key_accent3_lower_table);
+AL_VAR(unsigned short *, _key_accent3_upper_table);
+AL_VAR(unsigned short *, _key_accent4_lower_table);
+AL_VAR(unsigned short *, _key_accent4_upper_table);
+
+AL_VAR(int, _key_accent1);
+AL_VAR(int, _key_accent2);
+AL_VAR(int, _key_accent3);
+AL_VAR(int, _key_accent4);
+AL_VAR(int, _key_accent1_flag);
+AL_VAR(int, _key_accent2_flag);
+AL_VAR(int, _key_accent3_flag);
+AL_VAR(int, _key_accent4_flag);
+
+AL_VAR(int, _key_standard_kb);
+
+
+/* various bits of joystick stuff */
+AL_VAR(int, _joy_type);
+
+AL_VAR(int, _joystick_installed);
+
+
+/* some GUI innards that other people need to use */
+AL_FUNC(int, _gui_shadow_box_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, _gui_ctext_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, _gui_button_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, _gui_edit_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, _gui_list_proc, (int msg, DIALOG *d, int c));
+AL_FUNC(int, _gui_text_list_proc, (int msg, DIALOG *d, int c));
+
+AL_FUNC(void, _handle_scrollable_scroll_click, (DIALOG *d, int listsize, int *offset, int height));
+AL_FUNC(void, _handle_scrollable_scroll, (DIALOG *d, int listsize, int *index, int *offset));
+AL_FUNC(void, _handle_listbox_click, (DIALOG *d));
+AL_FUNC(void, _draw_scrollable_frame, (DIALOG *d, int listsize, int offset, int height, int fg_color, int bg));
+AL_FUNC(void, _draw_listbox, (DIALOG *d));
+AL_FUNC(void, _draw_textbox, (char *thetext, int *listsize, int draw, int offset, int wword, int tabsize, int x, int y, int w, int h, int disabled, int fore, int deselect, int disable));
+
+
+/* text- and font-related stuff */
+typedef struct FONT_VTABLE
+{
+   AL_METHOD(int, font_height, (AL_CONST FONT *f));
+   AL_METHOD(int, char_length, (AL_CONST FONT *f, int ch));
+   AL_METHOD(int, text_length, (AL_CONST FONT *f, AL_CONST char *text));
+   AL_METHOD(int, render_char, (AL_CONST FONT *f, int ch, int fg, int bg, BITMAP *bmp, int x, int y));
+   AL_METHOD(void, render, (AL_CONST FONT *f, AL_CONST char *text, int fg, int bg, BITMAP *bmp, int x, int y));
+   AL_METHOD(void, destroy, (FONT *f));
+} FONT_VTABLE;
+
+AL_VAR(FONT, _default_font);
+AL_VAR(FONT_VTABLE, _font_vtable_mono);
+AL_VAR(FONT_VTABLE *, font_vtable_mono);
+AL_VAR(FONT_VTABLE, _font_vtable_color);
+AL_VAR(FONT_VTABLE *, font_vtable_color);
+
+AL_FUNC(FONT_GLYPH *, _mono_find_glyph, (AL_CONST FONT *f, int ch));
+AL_FUNC(BITMAP *, _color_find_glyph, (AL_CONST FONT *f, int ch));
+
+typedef struct FONT_MONO_DATA 
+{
+   int begin, end;                  /* first char and one-past-the-end char */
+   FONT_GLYPH **glyphs;             /* our glyphs */
+   struct FONT_MONO_DATA *next;     /* linked list structure */
+} FONT_MONO_DATA;
+
+typedef struct FONT_COLOR_DATA
+{
+   int begin, end;                  /* first char and one-past-the-end char */
+   BITMAP **bitmaps;                /* our glyphs */
+   struct FONT_COLOR_DATA *next;    /* linked list structure */
+} FONT_COLOR_DATA;
+
+
+/* caches and tables for svga bank switching */
+AL_VAR(int, _last_bank_1);
+AL_VAR(int, _last_bank_2); 
+
+AL_VAR(int *, _gfx_bank);
+
+/* bank switching routines (these use a non-C calling convention on i386!) */
+AL_FUNC(unsigned long, _stub_bank_switch, (BITMAP *bmp, int line));
+AL_FUNC(void, _stub_unbank_switch, (BITMAP *bmp));
+AL_FUNC(void, _stub_bank_switch_end, (void));
+
+#ifdef GFX_MODEX
+
+AL_FUNC(unsigned long, _x_bank_switch, (BITMAP *bmp, int line));
+AL_FUNC(void, _x_unbank_switch, (BITMAP *bmp));
+AL_FUNC(void, _x_bank_switch_end, (void));
+
+#endif
+
+#ifdef GFX_VBEAF
+
+AL_FUNC(void, _accel_bank_stub, (void));
+AL_FUNC(void, _accel_bank_stub_end, (void));
+AL_FUNC(void, _accel_bank_switch, (void));
+AL_FUNC(void, _accel_bank_switch_end, (void));
+
+AL_VAR(void *, _accel_driver);
+
+AL_VAR(int, _accel_active);
+
+AL_VAR(void *, _accel_set_bank);
+AL_VAR(void *, _accel_idle);
+
+AL_FUNC(void, _fill_vbeaf_libc_exports, (void *ptr));
+AL_FUNC(void, _fill_vbeaf_pmode_exports, (void *ptr));
+
+#endif
+
+
+/* stuff for setting up bitmaps */
+AL_FUNC(BITMAP *, _make_bitmap, (int w, int h, unsigned long addr, GFX_DRIVER *driver, int color_depth, int bpl));
+AL_FUNC(void, _sort_out_virtual_width, (int *width, GFX_DRIVER *driver));
+
+AL_FUNC(GFX_VTABLE *, _get_vtable, (int color_depth));
+
+AL_VAR(GFX_VTABLE, _screen_vtable);
+
+AL_VAR(int, _gfx_mode_set_count);
+
+AL_VAR(int, _refresh_rate_request);
+AL_VAR(int, _current_refresh_rate);
+
+AL_VAR(int, _sub_bitmap_id_count);
+
+AL_VAR(int, _screen_split_position);
+
+AL_VAR(int, _safe_gfx_mode_change);
+
+#ifdef ALLEGRO_I386
+   #define BYTES_PER_PIXEL(bpp)     (((int)(bpp) + 7) / 8)
+#else
+   #ifdef ALLEGRO_MPW 
+      /* in Mac 24 bit is a unsigned long */
+      #define BYTES_PER_PIXEL(bpp)  (((bpp) &lt;= 8) ? 1                                    \
+				     : (((bpp) &lt;= 16) ? sizeof (unsigned short)          \
+					: sizeof (unsigned long)))
+   #else
+      #define BYTES_PER_PIXEL(bpp)  (((bpp) &lt;= 8) ? 1                                    \
+				     : (((bpp) &lt;= 16) ? sizeof (unsigned short)          \
+					: (((bpp) &lt;= 24) ? 3 : sizeof (unsigned long))))
+   #endif
+#endif
+
+AL_FUNC(int, _color_load_depth, (int depth, int hasalpha));
+
+AL_VAR(int, _color_conv);
+
+AL_FUNC(BITMAP *, _fixup_loaded_bitmap, (BITMAP *bmp, PALETTE pal, int bpp));
+
+
+/* default truecolor pixel format */
+#define DEFAULT_RGB_R_SHIFT_15  0
+#define DEFAULT_RGB_G_SHIFT_15  5
+#define DEFAULT_RGB_B_SHIFT_15  10
+#define DEFAULT_RGB_R_SHIFT_16  0
+#define DEFAULT_RGB_G_SHIFT_16  5
+#define DEFAULT_RGB_B_SHIFT_16  11
+#define DEFAULT_RGB_R_SHIFT_24  0
+#define DEFAULT_RGB_G_SHIFT_24  8
+#define DEFAULT_RGB_B_SHIFT_24  16
+#define DEFAULT_RGB_R_SHIFT_32  0
+#define DEFAULT_RGB_G_SHIFT_32  8
+#define DEFAULT_RGB_B_SHIFT_32  16
+#define DEFAULT_RGB_A_SHIFT_32  24
+
+
+/* console switching support */
+AL_FUNC(void, _register_switch_bitmap, (BITMAP *bmp, BITMAP *parent));
+AL_FUNC(void, _unregister_switch_bitmap, (BITMAP *bmp));
+AL_FUNC(void, _save_switch_state, (int switch_mode));
+AL_FUNC(void, _restore_switch_state, (void));
+
+AL_VAR(int, _dispsw_status);
+
+
+/* current drawing mode */
+AL_VAR(int, _drawing_mode);
+AL_VAR(BITMAP *, _drawing_pattern);
+AL_VAR(int, _drawing_x_anchor);
+AL_VAR(int, _drawing_y_anchor);
+AL_VAR(unsigned int, _drawing_x_mask);
+AL_VAR(unsigned int, _drawing_y_mask);
+
+AL_VAR(int, _textmode);
+
+AL_FUNCPTR(int *, _palette_expansion_table, (int bpp));
+
+AL_VAR(int, _color_depth);
+
+AL_VAR(int, _current_palette_changed);
+AL_VAR(PALETTE, _prev_current_palette);
+AL_VAR(int, _got_prev_current_palette);
+
+AL_ARRAY(int, _palette_color8);
+AL_ARRAY(int, _palette_color15);
+AL_ARRAY(int, _palette_color16);
+AL_ARRAY(int, _palette_color24);
+AL_ARRAY(int, _palette_color32);
+
+/* truecolor blending functions */
+AL_VAR(BLENDER_FUNC, _blender_func15);
+AL_VAR(BLENDER_FUNC, _blender_func16);
+AL_VAR(BLENDER_FUNC, _blender_func24);
+AL_VAR(BLENDER_FUNC, _blender_func32);
+
+AL_VAR(BLENDER_FUNC, _blender_func15x);
+AL_VAR(BLENDER_FUNC, _blender_func16x);
+AL_VAR(BLENDER_FUNC, _blender_func24x);
+
+AL_VAR(int, _blender_col_15);
+AL_VAR(int, _blender_col_16);
+AL_VAR(int, _blender_col_24);
+AL_VAR(int, _blender_col_32);
+
+AL_VAR(int, _blender_alpha);
+
+AL_FUNC(unsigned long, _blender_black, (unsigned long x, unsigned long y, unsigned long n));
+
+#ifdef ALLEGRO_COLOR16
+
+AL_FUNC(unsigned long, _blender_trans15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_add15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_burn15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_color15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_difference15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_dissolve15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_dodge15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_hue15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_invert15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_luminance15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_multiply15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_saturation15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_screen15, (unsigned long x, unsigned long y, unsigned long n));
+
+AL_FUNC(unsigned long, _blender_trans16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_add16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_burn16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_color16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_difference16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_dissolve16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_dodge16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_hue16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_invert16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_luminance16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_multiply16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_saturation16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_screen16, (unsigned long x, unsigned long y, unsigned long n));
+
+#endif
+
+#if (defined ALLEGRO_COLOR24) || (defined ALLEGRO_COLOR32)
+
+AL_FUNC(unsigned long, _blender_trans24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_add24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_burn24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_color24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_difference24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_dissolve24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_dodge24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_hue24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_invert24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_luminance24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_multiply24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_saturation24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_screen24, (unsigned long x, unsigned long y, unsigned long n));
+
+#endif
+
+AL_FUNC(unsigned long, _blender_alpha15, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_alpha16, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_alpha24, (unsigned long x, unsigned long y, unsigned long n));
+AL_FUNC(unsigned long, _blender_alpha32, (unsigned long x, unsigned long y, unsigned long n));
+
+AL_FUNC(unsigned long, _blender_write_alpha, (unsigned long x, unsigned long y, unsigned long n));
+
+
+/* graphics drawing routines */
+AL_FUNC(void, _normal_line, (BITMAP *bmp, int x1, int y1, int x2, int y2, int color));
+AL_FUNC(void, _normal_rectfill, (BITMAP *bmp, int x1, int y1, int x2, int y2, int color));
+
+#ifdef ALLEGRO_COLOR8
+
+AL_FUNC(int,  _linear_getpixel8, (BITMAP *bmp, int x, int y));
+AL_FUNC(void, _linear_putpixel8, (BITMAP *bmp, int x, int y, int color));
+AL_FUNC(void, _linear_vline8, (BITMAP *bmp, int x, int y1, int y2, int color));
+AL_FUNC(void, _linear_hline8, (BITMAP *bmp, int x1, int y, int x2, int color));
+AL_FUNC(void, _linear_draw_sprite8, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_v_flip8, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_h_flip8, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_vh_flip8, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_sprite8, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_sprite8, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_rle_sprite8, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rle_sprite8, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_rle_sprite8, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_character8, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_glyph8, (BITMAP *bmp, AL_CONST FONT_GLYPH *glyph, int x, int y, int color));
+AL_FUNC(void, _linear_blit8, (BITMAP *source,BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_blit_backward8, (BITMAP *source,BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_masked_blit8, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_clear_to_color8, (BITMAP *bitmap, int color));
+
+#endif
+
+#ifdef ALLEGRO_COLOR16
+
+AL_FUNC(void, _linear_putpixel15, (BITMAP *bmp, int x, int y, int color));
+AL_FUNC(void, _linear_vline15, (BITMAP *bmp, int x, int y1, int y2, int color));
+AL_FUNC(void, _linear_hline15, (BITMAP *bmp, int x1, int y, int x2, int color));
+AL_FUNC(void, _linear_draw_trans_sprite15, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rgba_sprite15, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_sprite15, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_rle_sprite15, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rle_sprite15, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rgba_rle_sprite15, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_rle_sprite15, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color));
+
+AL_FUNC(int,  _linear_getpixel16, (BITMAP *bmp, int x, int y));
+AL_FUNC(void, _linear_putpixel16, (BITMAP *bmp, int x, int y, int color));
+AL_FUNC(void, _linear_vline16, (BITMAP *bmp, int x, int y1, int y2, int color));
+AL_FUNC(void, _linear_hline16, (BITMAP *bmp, int x1, int y, int x2, int color));
+AL_FUNC(void, _linear_draw_sprite16, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_256_sprite16, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_v_flip16, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_h_flip16, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_vh_flip16, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_sprite16, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rgba_sprite16, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_sprite16, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_rle_sprite16, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rle_sprite16, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rgba_rle_sprite16, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_rle_sprite16, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_character16, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_glyph16, (BITMAP *bmp, AL_CONST FONT_GLYPH *glyph, int x, int y, int color));
+AL_FUNC(void, _linear_blit16, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_blit_backward16, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_masked_blit16, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_clear_to_color16, (BITMAP *bitmap, int color));
+
+#endif
+
+#ifdef ALLEGRO_COLOR24
+
+AL_FUNC(int,  _linear_getpixel24, (BITMAP *bmp, int x, int y));
+AL_FUNC(void, _linear_putpixel24, (BITMAP *bmp, int x, int y, int color));
+AL_FUNC(void, _linear_vline24, (BITMAP *bmp, int x, int y1, int y2, int color));
+AL_FUNC(void, _linear_hline24, (BITMAP *bmp, int x1, int y, int x2, int color));
+AL_FUNC(void, _linear_draw_sprite24, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_256_sprite24, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_v_flip24, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_h_flip24, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_vh_flip24, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_sprite24, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rgba_sprite24, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_sprite24, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_rle_sprite24, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rle_sprite24, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rgba_rle_sprite24, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_rle_sprite24, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_character24, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_glyph24, (BITMAP *bmp, AL_CONST FONT_GLYPH *glyph, int x, int y, int color));
+AL_FUNC(void, _linear_blit24, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_blit_backward24, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_masked_blit24, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_clear_to_color24, (BITMAP *bitmap, int color));
+
+#endif
+
+#ifdef ALLEGRO_COLOR32
+
+AL_FUNC(int,  _linear_getpixel32, (BITMAP *bmp, int x, int y));
+AL_FUNC(void, _linear_putpixel32, (BITMAP *bmp, int x, int y, int color));
+AL_FUNC(void, _linear_vline32, (BITMAP *bmp, int x, int y1, int y2, int color));
+AL_FUNC(void, _linear_hline32, (BITMAP *bmp, int x1, int y, int x2, int color));
+AL_FUNC(void, _linear_draw_sprite32, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_256_sprite32, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_v_flip32, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_h_flip32, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_sprite_vh_flip32, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_sprite32, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_sprite32, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_rle_sprite32, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_trans_rle_sprite32, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _linear_draw_lit_rle_sprite32, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_character32, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _linear_draw_glyph32, (BITMAP *bmp, AL_CONST FONT_GLYPH *glyph, int x, int y, int color));
+AL_FUNC(void, _linear_blit32, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_blit_backward32, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_masked_blit32, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _linear_clear_to_color32, (BITMAP *bitmap, int color));
+
+#endif
+
+#ifdef GFX_MODEX
+
+AL_FUNC(int,  _x_getpixel, (BITMAP *bmp, int x, int y));
+AL_FUNC(void, _x_putpixel, (BITMAP *bmp, int x, int y, int color));
+AL_FUNC(void, _x_vline, (BITMAP *bmp, int x, int y1, int y2, int color));
+AL_FUNC(void, _x_hline, (BITMAP *bmp, int x1, int y, int x2, int color));
+AL_FUNC(void, _x_draw_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _x_draw_sprite_v_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _x_draw_sprite_h_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _x_draw_sprite_vh_flip, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _x_draw_trans_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y));
+AL_FUNC(void, _x_draw_lit_sprite, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _x_draw_rle_sprite, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _x_draw_trans_rle_sprite, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y));
+AL_FUNC(void, _x_draw_lit_rle_sprite, (BITMAP *bmp, AL_CONST struct RLE_SPRITE *sprite, int x, int y, int color));
+AL_FUNC(void, _x_draw_character, (BITMAP *bmp, BITMAP *sprite, int x, int y, int color));
+AL_FUNC(void, _x_draw_glyph, (BITMAP *bmp, AL_CONST FONT_GLYPH *glyph, int x, int y, int color));
+AL_FUNC(void, _x_blit_from_memory, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _x_blit_to_memory, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _x_blit, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _x_blit_forward, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _x_blit_backward, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _x_masked_blit, (BITMAP *source, BITMAP *dest, int source_x, int source_y, int dest_x, int dest_y, int width, int height));
+AL_FUNC(void, _x_clear_to_color, (BITMAP *bitmap, int color));
+
+#endif
+
+
+/* color conversion routines */
+typedef struct GRAPHICS_RECT {
+   int width;
+   int height;
+   int pitch;
+   void *data;
+} GRAPHICS_RECT;
+
+typedef void (COLORCONV_BLITTER_FUNC)(GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect);
+
+AL_FUNC(COLORCONV_BLITTER_FUNC *, _get_colorconv_blitter, (int from_depth, int to_depth));
+AL_FUNC(void, _release_colorconv_blitter, (COLORCONV_BLITTER_FUNC *blitter));
+AL_FUNC(void, _set_colorconv_palette, (AL_CONST struct RGB *p, int from, int to));
+AL_FUNC(unsigned char *, _get_colorconv_map, (void));
+
+#ifdef ALLEGRO_COLOR8
+
+AL_FUNC(void, _colorconv_blit_8_to_8, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_8_to_15, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_8_to_16, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_8_to_24, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_8_to_32, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+
+#endif
+
+#ifdef ALLEGRO_COLOR16
+
+AL_FUNC(void, _colorconv_blit_15_to_8, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_15_to_16, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_15_to_24, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_15_to_32, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+
+AL_FUNC(void, _colorconv_blit_16_to_8, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_16_to_15, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_16_to_24, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_16_to_32, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+
+#endif
+
+#ifdef ALLEGRO_COLOR24
+
+AL_FUNC(void, _colorconv_blit_24_to_8, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_24_to_15, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_24_to_16, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_24_to_32, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+
+#endif
+
+#ifdef ALLEGRO_COLOR32
+
+AL_FUNC(void, _colorconv_blit_32_to_8, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_32_to_15, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_32_to_16, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorconv_blit_32_to_24, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+
+#endif
+
+
+/* color copy routines */
+#ifndef ALLEGRO_NO_COLORCOPY
+
+#ifdef ALLEGRO_COLOR16
+AL_FUNC(void, _colorcopy_blit_15_to_15, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+AL_FUNC(void, _colorcopy_blit_16_to_16, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+#endif
+
+#ifdef ALLEGRO_COLOR24
+AL_FUNC(void, _colorcopy_blit_24_to_24, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+#endif
+
+#ifdef ALLEGRO_COLOR32
+AL_FUNC(void, _colorcopy_blit_32_to_32, (GRAPHICS_RECT *src_rect, GRAPHICS_RECT *dest_rect));
+#endif
+
+#endif
+
+
+/* generic color conversion blitter */
+AL_FUNC(void, _blit_between_formats, (BITMAP *src, BITMAP *dest, int s_x, int s_y, int d_x, int d_y, int w, int h));
+
+
+/* asm helper for stretch_blit() */
+#ifndef SCAN_EXPORT
+AL_FUNC(void, _do_stretch, (BITMAP *source, BITMAP *dest, void *drawer, int sx, fixed sy, fixed syd, int dx, int dy, int dh, int color_depth));
+#endif
+
+
+/* lower level functions for rotation */
+AL_FUNC(void, _parallelogram_map, (BITMAP *bmp, BITMAP *spr, fixed xs[4], fixed ys[4], void (*draw_scanline)(BITMAP *bmp, BITMAP *spr, fixed l_bmp_x, int bmp_y, fixed r_bmp_x, fixed l_spr_x, fixed l_spr_y, fixed spr_dx, fixed spr_dy), int sub_pixel_accuracy));
+AL_FUNC(void, _parallelogram_map_standard, (BITMAP *bmp, BITMAP *sprite, fixed xs[4], fixed ys[4]));
+AL_FUNC(void, _rotate_scale_flip_coordinates, (fixed w, fixed h, fixed x, fixed y, fixed cx, fixed cy, fixed angle, fixed scale_x, fixed scale_y, int h_flip, int v_flip, fixed xs[4], fixed ys[4]));
+AL_FUNC(void, _pivot_scaled_sprite_flip, (struct BITMAP *bmp, struct BITMAP *sprite, fixed x, fixed y, fixed cx, fixed cy, fixed angle, fixed scale, int v_flip));
+
+
+/* number of fractional bits used by the polygon rasteriser */
+#define POLYGON_FIX_SHIFT     18
+
+
+/* bitfield specifying which polygon attributes need interpolating */
+#define INTERP_FLAT           1      /* no interpolation */
+#define INTERP_1COL           2      /* gcol or alpha */
+#define INTERP_3COL           4      /* grgb */
+#define INTERP_FIX_UV         8      /* atex */
+#define INTERP_Z              16     /* always in scene3d */
+#define INTERP_FLOAT_UV       32     /* ptex */
+#define OPT_FLOAT_UV_TO_FIX   64     /* translate ptex to atex */
+#define COLOR_TO_RGB          128    /* grgb to gcol for truecolor */
+#define INTERP_ZBUF           256    /* z-buffered */
+#define INTERP_THRU           512    /* any kind of transparent */
+#define INTERP_NOSOLID        1024   /* non-solid modes for 8-bit flat */
+#define INTERP_BLEND          2048   /* lit for truecolor */
+#define INTERP_TRANS          4096   /* trans for truecolor */
+
+
+/* information for polygon scanline fillers */
+typedef struct POLYGON_SEGMENT
+{
+   fixed u, v, du, dv;              /* fixed point u/v coordinates */
+   fixed c, dc;                     /* single color gouraud shade values */
+   fixed r, g, b, dr, dg, db;       /* RGB gouraud shade values */
+   float z, dz;                     /* polygon depth (1/z) */
+   float fu, fv, dfu, dfv;          /* floating point u/v coordinates */
+   unsigned char *texture;          /* the texture map */
+   int umask, vmask, vshift;        /* texture map size information */
+   int seg;                         /* destination bitmap selector */
+   unsigned long zbuf_addr;	    /* Z-buffer address */
+   unsigned long read_addr;	    /* reading address for transparency modes */
+} POLYGON_SEGMENT;
+
+
+/* prototype for the scanline filler functions */
+typedef AL_METHOD(void, SCANLINE_FILLER, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+
+/* an active polygon edge */
+typedef struct POLYGON_EDGE 
+{
+   int top;                         /* top y position */
+   int bottom;                      /* bottom y position */
+   fixed x, dx;                     /* fixed point x position and gradient */
+   fixed w;                         /* width of line segment */
+   POLYGON_SEGMENT dat;             /* texture/gouraud information */
+   struct POLYGON_EDGE *prev;       /* doubly linked list */
+   struct POLYGON_EDGE *next;
+   struct POLYGON_INFO *poly;	    /* father polygon */
+} POLYGON_EDGE;
+
+
+typedef struct POLYGON_INFO         /* a polygon waiting rendering */
+{
+   struct POLYGON_INFO *next, *prev;/* double linked list */
+   int inside;                      /* flag for &quot;scanlining&quot; */
+   int flags;                       /* INTERP_* flags */
+   int color;                       /* vtx[0]-&gt;c */
+   float a, b, c;                   /* plane's coefficients -a/d, -b/d, -c/d */
+   int dmode;                       /* drawing mode */
+   BITMAP *dpat;                    /* drawing pattern */
+   int xanchor, yanchor;            /* for dpat */
+   int alpha;                       /* blender alpha */
+   int b15, b16, b24, b32;          /* blender colors */
+   COLOR_MAP *cmap;                 /* trans color map */
+   SCANLINE_FILLER drawer;	    /* scanline drawing functions */
+   SCANLINE_FILLER alt_drawer; 
+   POLYGON_EDGE *left_edge;	    /* true edges used in interpolation */
+   POLYGON_EDGE *right_edge;
+   POLYGON_SEGMENT info;            /* base information for scanline functions */
+} POLYGON_INFO;
+
+
+/* global variable for z-buffer */
+AL_VAR(BITMAP *, _zbuffer);
+
+
+/* polygon helper functions */
+AL_VAR(SCANLINE_FILLER, _optim_alternative_drawer);
+AL_FUNC(POLYGON_EDGE *, _add_edge, (POLYGON_EDGE *list, POLYGON_EDGE *edge, int sort_by_x));
+AL_FUNC(POLYGON_EDGE *, _remove_edge, (POLYGON_EDGE *list, POLYGON_EDGE *edge));
+AL_FUNC(int, _fill_3d_edge_structure, (POLYGON_EDGE *edge, AL_CONST V3D *v1, AL_CONST V3D *v2, int flags, BITMAP *bmp));
+AL_FUNC(int, _fill_3d_edge_structure_f, (POLYGON_EDGE *edge, AL_CONST V3D_f *v1, AL_CONST V3D_f *v2, int flags, BITMAP *bmp));
+AL_FUNC(SCANLINE_FILLER, _get_scanline_filler, (int type, int *flags, POLYGON_SEGMENT *info, BITMAP *texture, BITMAP *bmp));
+AL_FUNC(void, _clip_polygon_segment, (POLYGON_SEGMENT *info, fixed gap, int flags));
+AL_FUNC(void, _clip_polygon_segment_f, (POLYGON_SEGMENT *info, int gap, int flags));
+
+
+/* polygon scanline filler functions */
+AL_FUNC(void, _poly_scanline_dummy, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#ifdef ALLEGRO_COLOR8
+
+AL_FUNC(void, _poly_scanline_gcol8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_grgb8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#ifndef SCAN_EXPORT
+AL_FUNC(void, _poly_scanline_grgb8x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+#endif
+
+AL_FUNC(void, _poly_zbuf_flat8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_gcol8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_grgb8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_lit8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_trans8, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#endif
+
+#ifdef ALLEGRO_COLOR16
+
+AL_FUNC(void, _poly_scanline_grgb15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#ifndef SCAN_EXPORT
+AL_FUNC(void, _poly_scanline_grgb15x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit15x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit15x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit15x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit15x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+AL_FUNC(void, _poly_scanline_ptex_lit15d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit15d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+#endif
+
+AL_FUNC(void, _poly_zbuf_grgb15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_lit15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_trans15, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+AL_FUNC(void, _poly_scanline_grgb16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#ifndef SCAN_EXPORT
+AL_FUNC(void, _poly_scanline_grgb16x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit16x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit16x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit16x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit16x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+AL_FUNC(void, _poly_scanline_ptex_lit16d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit16d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+#endif
+
+AL_FUNC(void, _poly_zbuf_flat16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_grgb16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_lit16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_trans16, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#endif
+
+#ifdef ALLEGRO_COLOR24
+
+AL_FUNC(void, _poly_scanline_grgb24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#ifndef SCAN_EXPORT
+AL_FUNC(void, _poly_scanline_grgb24x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit24x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit24x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit24x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit24x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+AL_FUNC(void, _poly_scanline_ptex_lit24d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit24d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+#endif
+
+AL_FUNC(void, _poly_zbuf_flat24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_grgb24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_lit24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_trans24, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#endif
+
+#ifdef ALLEGRO_COLOR32
+
+AL_FUNC(void, _poly_scanline_grgb32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#ifndef SCAN_EXPORT
+AL_FUNC(void, _poly_scanline_grgb32x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_lit32x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_lit32x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_atex_mask_lit32x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit32x, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+AL_FUNC(void, _poly_scanline_ptex_lit32d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_scanline_ptex_mask_lit32d, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+#endif
+
+AL_FUNC(void, _poly_zbuf_flat32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_grgb32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_lit32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_atex_mask_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+AL_FUNC(void, _poly_zbuf_ptex_mask_trans32, (unsigned long addr, int w, POLYGON_SEGMENT *info));
+
+#endif
+
+
+/* sound lib stuff */
+AL_VAR(MIDI_DRIVER, _midi_none);
+AL_VAR(int, _digi_volume);
+AL_VAR(int, _midi_volume);
+AL_VAR(int, _sound_flip_pan); 
+AL_VAR(int, _sound_hq);
+AL_VAR(int, _sound_stereo);
+AL_VAR(int, _sound_bits);
+AL_VAR(int, _sound_freq);
+AL_VAR(int, _sound_port);
+AL_VAR(int, _sound_dma);
+AL_VAR(int, _sound_irq);
+
+AL_VAR(int, _sound_installed);
+AL_VAR(int, _sound_input_installed);
+
+AL_FUNC(int, _midi_allocate_voice, (int min, int max));
+
+AL_VAR(volatile long, _midi_tick);
+
+AL_FUNC(int, _digmid_find_patches, (char *dir, int dir_size, char *file, int file_size));
+
+#define VIRTUAL_VOICES  256
+
+
+typedef struct          /* a virtual (as seen by the user) soundcard voice */
+{
+   AL_CONST SAMPLE *sample;      /* which sample are we playing? (NULL = free) */
+   int num;             /* physical voice number (-1 = been killed off) */
+   int autokill;        /* set to free the voice when the sample finishes */
+   long time;           /* when we were started (for voice allocation) */
+   int priority;        /* how important are we? */
+} VOICE;
+
+AL_ARRAY(VOICE, _voice);
+
+
+typedef struct          /* a physical (as used by hardware) soundcard voice */
+{
+   int num;             /* the virtual voice currently using me (-1 = free) */
+   int playmode;        /* are we looping? */
+   int vol;             /* current volume (fixed point .12) */
+   int dvol;            /* volume delta, for ramping */
+   int target_vol;      /* target volume, for ramping */
+   int pan;             /* current pan (fixed point .12) */
+   int dpan;            /* pan delta, for sweeps */
+   int target_pan;      /* target pan, for sweeps */
+   int freq;            /* current frequency (fixed point .12) */
+   int dfreq;           /* frequency delta, for sweeps */
+   int target_freq;     /* target frequency, for sweeps */
+} PHYS_VOICE;
+
+AL_ARRAY(PHYS_VOICE, _phys_voice);
+
+
+#define MIXER_DEF_SFX               8
+#define MIXER_MAX_SFX               64
+
+AL_FUNC(int,  _mixer_init, (int bufsize, int freq, int stereo, int is16bit, int *voices));
+AL_FUNC(void, _mixer_exit, (void));
+AL_FUNC(void, _mix_some_samples, (unsigned long buf, unsigned short seg, int issigned));
+AL_FUNC(void, _mixer_init_voice, (int voice, AL_CONST SAMPLE *sample));
+AL_FUNC(void, _mixer_release_voice, (int voice));
+AL_FUNC(void, _mixer_start_voice, (int voice));
+AL_FUNC(void, _mixer_stop_voice, (int voice));
+AL_FUNC(void, _mixer_loop_voice, (int voice, int loopmode));
+AL_FUNC(int,  _mixer_get_position, (int voice));
+AL_FUNC(void, _mixer_set_position, (int voice, int position));
+AL_FUNC(int,  _mixer_get_volume, (int voice));
+AL_FUNC(void, _mixer_set_volume, (int voice, int volume));
+AL_FUNC(void, _mixer_ramp_volume, (int voice, int time, int endvol));
+AL_FUNC(void, _mixer_stop_volume_ramp, (int voice));
+AL_FUNC(int,  _mixer_get_frequency, (int voice));
+AL_FUNC(void, _mixer_set_frequency, (int voice, int frequency));
+AL_FUNC(void, _mixer_sweep_frequency, (int voice, int time, int endfreq));
+AL_FUNC(void, _mixer_stop_frequency_sweep, (int voice));
+AL_FUNC(int,  _mixer_get_pan, (int voice));
+AL_FUNC(void, _mixer_set_pan, (int voice, int pan));
+AL_FUNC(void, _mixer_sweep_pan, (int voice, int time, int endpan));
+AL_FUNC(void, _mixer_stop_pan_sweep, (int voice));
+AL_FUNC(void, _mixer_set_echo, (int voice, int strength, int delay));
+AL_FUNC(void, _mixer_set_tremolo, (int voice, int rate, int depth));
+AL_FUNC(void, _mixer_set_vibrato, (int voice, int rate, int depth));
+
+AL_FUNC(void, _dummy_noop1, (int p));
+AL_FUNC(void, _dummy_noop2, (int p1, int p2));
+AL_FUNC(void, _dummy_noop3, (int p1, int p2, int p3));
+AL_FUNC(int,  _dummy_load_patches, (AL_CONST char *patches, AL_CONST char *drums));
+AL_FUNC(void, _dummy_adjust_patches, (AL_CONST char *patches, AL_CONST char *drums));
+AL_FUNC(void, _dummy_key_on, (int inst, int note, int bend, int vol, int pan));
+
+
+/* datafile ID's for compatibility with the old datafile format */
+#define V1_DAT_MAGIC             0x616C6C2EL
+
+#define V1_DAT_DATA              0
+#define V1_DAT_FONT              1
+#define V1_DAT_BITMAP_16         2 
+#define V1_DAT_BITMAP_256        3
+#define V1_DAT_SPRITE_16         4
+#define V1_DAT_SPRITE_256        5
+#define V1_DAT_PALETTE_16        6
+#define V1_DAT_PALETTE_256       7
+#define V1_DAT_FONT_8x8          8
+#define V1_DAT_FONT_PROP         9
+#define V1_DAT_BITMAP            10
+#define V1_DAT_PALETTE           11
+#define V1_DAT_SAMPLE            12
+#define V1_DAT_MIDI              13
+#define V1_DAT_RLE_SPRITE        14
+#define V1_DAT_FLI               15
+#define V1_DAT_C_SPRITE          16
+#define V1_DAT_XC_SPRITE         17
+
+#define OLD_FONT_SIZE            95
+#define LESS_OLD_FONT_SIZE       224
+
+
+/* datafile object loading functions */
+AL_FUNC(void, _unload_datafile_object, (DATAFILE *dat));
+
+
+/* information about a datafile object */
+typedef struct DATAFILE_TYPE
+{
+   int type;
+   AL_METHOD(void *, load, (PACKFILE *f, long size));
+   AL_METHOD(void, destroy, (void *));
+} DATAFILE_TYPE;
+
+
+#define MAX_DATAFILE_TYPES    32
+
+AL_ARRAY(DATAFILE_TYPE, _datafile_type);
+
+AL_VAR(int, _compile_sprites);
+
+AL_FUNC(void, _construct_datafile, (DATAFILE *data));
+
+
+/* for readbmp.c */
+AL_FUNC(void, _register_bitmap_file_type_init, (void));
+
+
+/* for module linking system; see comment in allegro.c */
+struct _AL_LINKER_MIDI
+{
+   AL_METHOD(int, init, (void));
+   AL_METHOD(void, exit, (void));
+};
+
+AL_VAR(struct _AL_LINKER_MIDI *, _al_linker_midi);
+
+struct _AL_LINKER_MOUSE
+{
+   AL_METHOD(void, set_mouse_etc, (void));
+   AL_METHOD(void, show_mouse, (BITMAP *));
+   BITMAP **mouse_screen_ptr;
+};
+
+AL_VAR(struct _AL_LINKER_MOUSE *, _al_linker_mouse);
+
+
+/* dynamic driver lists */
+AL_FUNC(_DRIVER_INFO *, _create_driver_list, (void));
+AL_FUNC(void, _destroy_driver_list, (_DRIVER_INFO *drvlist));
+AL_FUNC(void, _driver_list_append_driver, (_DRIVER_INFO **drvlist, int id, void *driver, int autodetect));
+AL_FUNC(void, _driver_list_prepend_driver, (_DRIVER_INFO **drvlist, int id, void *driver, int autodetect));
+AL_FUNC(void, _driver_list_append_list, (_DRIVER_INFO **drvlist, _DRIVER_INFO *srclist));
+
+
+AL_FUNC(void *, _al_sane_realloc, (void *ptr, size_t size));
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef AINTERN_H */

Added: trunk/msvc-libs/include/allegro/internal/aintvga.h
===================================================================
--- trunk/msvc-libs/include/allegro/internal/aintvga.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/internal/aintvga.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,135 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Helpers for accessing the VGA hardware registers.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTVGA_H
+#define AINTVGA_H
+
+#ifndef ALLEGRO_H
+   #error must include allegro.h first
+#endif
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+AL_VAR(int, _crtc);
+
+AL_FUNC(void, _vga_regs_init, (void));
+AL_FUNC(void, _vga_vsync, (void));
+AL_FUNC(void, _vga_set_palette_range, (AL_CONST PALETTE p, int from, int to, int sync));
+AL_FUNC(void, _set_vga_virtual_width, (int old_width, int new_width));
+AL_FUNC(unsigned long, _set_vga_mode, (int modenum));
+AL_FUNC(void, _unset_vga_mode, (void));
+AL_FUNC(void, _save_vga_mode, (void));
+AL_FUNC(void, _restore_vga_mode, (void));
+
+
+/* reads the current value of a VGA hardware register */
+AL_INLINE(int, _read_vga_register, (int port, int index),
+{
+   if (port==0x3C0)
+      inportb(_crtc+6); 
+
+   outportb(port, index);
+   return inportb(port+1);
+})
+
+
+/* writes to a VGA hardware register */
+AL_INLINE(void, _write_vga_register, (int port, int index, int v),
+{
+   if (port==0x3C0) {
+      inportb(_crtc+6);
+      outportb(port, index);
+      outportb(port, v);
+   }
+   else {
+      outportb(port, index);
+      outportb(port+1, v);
+   }
+})
+
+
+/* alters specific bits of a VGA hardware register */
+AL_INLINE(void, _alter_vga_register, (int port, int index, int mask, int v),
+{
+   int temp;
+   temp = _read_vga_register(port, index);
+   temp &amp;= (~mask);
+   temp |= (v &amp; mask);
+   _write_vga_register(port, index, temp);
+})
+
+
+/* waits until the VGA isn't in a horizontal blank */
+AL_INLINE(void, _vsync_out_h, (void),
+{
+   do {
+   } while (inportb(0x3DA) &amp; 1);
+})
+
+
+/* waits until the VGA isn't in a vertical blank */
+AL_INLINE(void, _vsync_out_v, (void),
+{
+   do {
+   } while (inportb(0x3DA) &amp; 8);
+})
+
+
+/* waits until the VGA is in a vertical blank */
+AL_INLINE(void, _vsync_in, (void),
+{
+   if (_timer_use_retrace) {
+      int t = retrace_count; 
+
+      do {
+      } while (t == retrace_count);
+   }
+   else {
+      do {
+      } while (!(inportb(0x3DA) &amp; 8));
+   }
+})
+
+
+/* modifies the VGA pelpan register */
+AL_INLINE(void, _write_hpp, (int value),
+{
+   if (_timer_use_retrace) {
+      _retrace_hpp_value = value;
+
+      do {
+      } while (_retrace_hpp_value == value);
+   }
+   else {
+      do {
+      } while (!(inportb(0x3DA) &amp; 8));
+
+      _write_vga_register(0x3C0, 0x33, value);
+   }
+})
+
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef AINTVGA_H */

Added: trunk/msvc-libs/include/allegro/internal/alconfig.h
===================================================================
--- trunk/msvc-libs/include/allegro/internal/alconfig.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/internal/alconfig.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,313 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+/* which color depths to include? */
+#define ALLEGRO_COLOR8
+#define ALLEGRO_COLOR16
+#define ALLEGRO_COLOR24
+#define ALLEGRO_COLOR32
+
+
+/* include platform-specific stuff */
+#ifndef SCAN_EXPORT
+   #ifndef SCAN_DEPEND
+      #include &quot;allegro/platform/alplatf.h&quot;
+   #endif
+
+   #if defined ALLEGRO_DJGPP
+      #include &quot;allegro/platform/aldjgpp.h&quot;
+   #elif defined ALLEGRO_WATCOM
+      #include &quot;allegro/platform/alwatcom.h&quot;
+   #elif defined ALLEGRO_MINGW32
+      #include &quot;allegro/platform/almngw32.h&quot;
+   #elif defined ALLEGRO_BCC32
+      #include &quot;allegro/platform/albcc32.h&quot;
+   #elif defined ALLEGRO_MSVC
+      #include &quot;allegro/platform/almsvc.h&quot;
+   #elif defined ALLEGRO_BEOS
+      #include &quot;allegro/platform/albecfg.h&quot;
+   #elif defined ALLEGRO_MPW
+      #include &quot;allegro/platform/almaccfg.h&quot;
+   #elif defined ALLEGRO_QNX
+      #include &quot;allegro/platform/alqnxcfg.h&quot;
+   #elif defined ALLEGRO_UNIX
+      #include &quot;allegro/platform/alucfg.h&quot;
+   #else
+      #error platform not supported
+   #endif
+#endif
+
+
+/* special definitions for the GCC compiler */
+#ifdef __GNUC__
+   #define ALLEGRO_GCC
+
+   #ifndef AL_INLINE
+      #ifdef __cplusplus
+         #define AL_INLINE(type, name, args, code)    static inline type name args code
+      #else
+         #define AL_INLINE(type, name, args, code)    extern __inline__ type name args code
+      #endif
+   #endif
+
+   #define AL_PRINTFUNC(type, name, args, a, b)    AL_FUNC(type, name, args) __attribute__ ((format (printf, a, b)))
+
+   #ifndef INLINE
+      #define INLINE          __inline__
+   #endif
+
+   #if __GNUC__ &gt;= 3
+      /* SET: According to gcc volatile is ignored for a return type.
+       * I think the code should just ensure that inportb is declared as an
+       * __asm__ __volatile__ macro. If that's the case the extra volatile
+       * doesn't have any sense.
+       */
+      #define RET_VOLATILE
+   #else
+      #define RET_VOLATILE    volatile
+   #endif
+
+   #ifndef ZERO_SIZE_ARRAY
+      #if __GNUC__ &lt; 3
+         #define ZERO_SIZE_ARRAY(type, name)  __extension__ type name[0]
+      #else
+         #define ZERO_SIZE_ARRAY(type, name)  type name[] /* ISO C99 flexible array members */
+      #endif
+   #endif
+   
+   #ifndef LONG_LONG
+      #define LONG_LONG       long long
+   #endif
+
+   #ifdef __i386__
+      #define ALLEGRO_I386
+   #endif
+
+   #ifndef AL_CONST
+      #define AL_CONST     const
+   #endif
+
+#endif
+
+
+/* use constructor functions, if supported */
+#ifdef ALLEGRO_USE_CONSTRUCTOR
+   #define CONSTRUCTOR_FUNCTION(func)              func __attribute__ ((constructor))
+   #define DESTRUCTOR_FUNCTION(func)               func __attribute__ ((destructor))
+#endif
+
+
+/* the rest of this file fills in some default definitions of language
+ * features and helper functions, which are conditionalised so they will
+ * only be included if none of the above headers defined custom versions.
+ */
+
+#ifndef INLINE
+   #define INLINE
+#endif
+
+#ifndef RET_VOLATILE
+   #define RET_VOLATILE   volatile
+#endif
+
+#ifndef ZERO_SIZE_ARRAY
+   #define ZERO_SIZE_ARRAY(type, name)             type name[]
+#endif
+
+#ifndef AL_CONST
+   #define AL_CONST
+#endif
+
+#ifndef AL_VAR
+   #define AL_VAR(type, name)                      extern type name
+#endif
+
+#ifndef AL_ARRAY
+   #define AL_ARRAY(type, name)                    extern type name[]
+#endif
+
+#ifndef AL_FUNC
+   #define AL_FUNC(type, name, args)               type name args
+#endif
+
+#ifndef AL_PRINTFUNC
+   #define AL_PRINTFUNC(type, name, args, a, b)    AL_FUNC(type, name, args)
+#endif
+
+#ifndef AL_METHOD
+   #define AL_METHOD(type, name, args)             type (*name) args
+#endif
+
+#ifndef AL_FUNCPTR
+   #define AL_FUNCPTR(type, name, args)            extern type (*name) args
+#endif
+
+#ifndef AL_INLINE
+   #define AL_INLINE(type, name, args, code)       type name args;
+#endif
+
+#ifndef END_OF_MAIN
+   #define END_OF_MAIN()
+#endif
+
+
+/* fill in default memory locking macros */
+#ifndef END_OF_FUNCTION
+   #define END_OF_FUNCTION(x)
+   #define END_OF_STATIC_FUNCTION(x)
+   #define LOCK_DATA(d, s)
+   #define LOCK_CODE(c, s)
+   #define UNLOCK_DATA(d, s)
+   #define LOCK_VARIABLE(x)
+   #define LOCK_FUNCTION(x)
+#endif
+
+
+/* fill in default filename behaviour */
+#ifndef ALLEGRO_LFN
+   #define ALLEGRO_LFN  1
+#endif
+
+#if (defined ALLEGRO_DOS) || (defined ALLEGRO_WINDOWS)
+   #define OTHER_PATH_SEPARATOR  '\\'
+   #define DEVICE_SEPARATOR      ':'
+#else
+   #define OTHER_PATH_SEPARATOR  '/'
+   #define DEVICE_SEPARATOR      '\0'
+#endif
+
+
+/* emulate the FA_* flags for platforms that don't already have them */
+#ifndef FA_RDONLY
+   #define FA_RDONLY       1
+   #define FA_HIDDEN       2
+   #define FA_SYSTEM       4
+   #define FA_LABEL        8
+   #define FA_DIREC        16
+   #define FA_ARCH         32
+#endif
+
+
+/* emulate missing library functions */
+#ifdef ALLEGRO_NO_STRICMP
+   AL_FUNC(int, _alemu_stricmp, (AL_CONST char *s1, AL_CONST char *s2));
+   #define stricmp _alemu_stricmp
+#endif
+
+#ifdef ALLEGRO_NO_STRLWR
+   AL_FUNC(char *, _alemu_strlwr, (char *string));
+   #define strlwr _alemu_strlwr
+#endif
+
+#ifdef ALLEGRO_NO_STRUPR
+   AL_FUNC(char *, _alemu_strupr, (char *string));
+   #define strupr _alemu_strupr
+#endif
+
+#ifdef ALLEGRO_NO_MEMCMP
+   AL_FUNC(int, _alemu_memcmp, (AL_CONST void *s1, AL_CONST void *s2, size_t num));
+   #define memcmp _alemu_memcmp
+#endif
+
+
+/* if nobody put them elsewhere, video bitmaps go in regular memory */
+#ifndef _video_ds
+   #define _video_ds()  _default_ds()
+#endif
+
+
+/* not many places actually use these, but still worth emulating */
+#ifndef ALLEGRO_DJGPP
+   #define _farsetsel(seg)
+   #define _farnspokeb(addr, val)   (*((unsigned char  *)(addr)) = (val))
+   #define _farnspokew(addr, val)   (*((unsigned short *)(addr)) = (val))
+   #define _farnspokel(addr, val)   (*((unsigned long  *)(addr)) = (val))
+   #define _farnspeekb(addr)        (*((unsigned char  *)(addr)))
+   #define _farnspeekw(addr)        (*((unsigned short *)(addr)))
+   #define _farnspeekl(addr)        (*((unsigned long  *)(addr)))
+#endif
+
+
+/* endian-independent 3-byte accessor macros */
+#ifdef ALLEGRO_LITTLE_ENDIAN
+
+   #define READ3BYTES(p)  (((int) *(p))               \
+                           | ((int) *((p) + 1) &lt;&lt; 8)  \
+                           | ((int) *((p) + 2) &lt;&lt; 16))
+
+   #define WRITE3BYTES(p,c)  ((*(p) = (c)),             \
+                              (*((p) + 1) = (c) &gt;&gt; 8),  \
+                              (*((p) + 2) = (c) &gt;&gt; 16))
+
+#elif defined ALLEGRO_BIG_ENDIAN
+
+   #define READ3BYTES(p)  (((int) *(p) &lt;&lt; 16)         \
+                           | ((int) *((p) + 1) &lt;&lt; 8)  \
+                           | ((int) *((p) + 2)))
+
+   #define WRITE3BYTES(p,c)  ((*(p) = (c) &gt;&gt; 16),       \
+                              (*((p) + 1) = (c) &gt;&gt; 8),  \
+                              (*((p) + 2) = (c)))
+
+#else
+   #error endianess not defined
+#endif
+
+
+/* generic versions of the video memory access helpers */
+#ifndef bmp_select
+   #define bmp_select(bmp)
+#endif
+
+#ifndef bmp_write8
+   #define bmp_write8(addr, c)         (*((unsigned char  *)(addr)) = (c))
+   #define bmp_write15(addr, c)        (*((unsigned short *)(addr)) = (c))
+   #define bmp_write16(addr, c)        (*((unsigned short *)(addr)) = (c))
+   #define bmp_write32(addr, c)        (*((unsigned long  *)(addr)) = (c))
+
+   #define bmp_read8(addr)             (*((unsigned char  *)(addr)))
+   #define bmp_read15(addr)            (*((unsigned short *)(addr)))
+   #define bmp_read16(addr)            (*((unsigned short *)(addr)))
+   #define bmp_read32(addr)            (*((unsigned long  *)(addr)))
+
+   AL_INLINE(int, bmp_read24, (unsigned long addr),
+   {
+      unsigned char *p = (unsigned char *)addr;
+      int c;
+
+      c = READ3BYTES(p);
+
+      return c;
+   })
+
+   AL_INLINE(void, bmp_write24, (unsigned long addr, int c),
+   {
+      unsigned char *p = (unsigned char *)addr;
+
+      WRITE3BYTES(p, c);
+   })
+
+#endif
+
+
+/* parameters for the color conversion code */
+#if (defined ALLEGRO_WINDOWS) || (defined ALLEGRO_QNX)
+   #define ALLEGRO_COLORCONV_ALIGNED_WIDTH
+   #define ALLEGRO_NO_COLORCOPY
+#endif
+

Added: trunk/msvc-libs/include/allegro/joystick.h
===================================================================
--- trunk/msvc-libs/include/allegro/joystick.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/joystick.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,147 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Joystick routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_JOYSTICK_H
+#define ALLEGRO_JOYSTICK_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+#define JOY_TYPE_AUTODETECT      -1
+#define JOY_TYPE_NONE            0
+
+
+#define MAX_JOYSTICKS            8
+#define MAX_JOYSTICK_AXIS        3
+#define MAX_JOYSTICK_STICKS      5
+#define MAX_JOYSTICK_BUTTONS     16
+
+
+/* information about a single joystick axis */
+typedef struct JOYSTICK_AXIS_INFO
+{
+   int pos;
+   int d1, d2;
+   AL_CONST char *name;
+} JOYSTICK_AXIS_INFO;
+
+
+/* information about one or more axis (a slider or directional control) */
+typedef struct JOYSTICK_STICK_INFO
+{
+   int flags;
+   int num_axis;
+   JOYSTICK_AXIS_INFO axis[MAX_JOYSTICK_AXIS];
+   AL_CONST char *name;
+} JOYSTICK_STICK_INFO;
+
+
+/* information about a joystick button */
+typedef struct JOYSTICK_BUTTON_INFO
+{
+   int b;
+   AL_CONST char *name;
+} JOYSTICK_BUTTON_INFO;
+
+
+/* information about an entire joystick */
+typedef struct JOYSTICK_INFO
+{
+   int flags;
+   int num_sticks;
+   int num_buttons;
+   JOYSTICK_STICK_INFO stick[MAX_JOYSTICK_STICKS];
+   JOYSTICK_BUTTON_INFO button[MAX_JOYSTICK_BUTTONS];
+} JOYSTICK_INFO;
+
+
+/* joystick status flags */
+#define JOYFLAG_DIGITAL             1
+#define JOYFLAG_ANALOGUE            2
+#define JOYFLAG_CALIB_DIGITAL       4
+#define JOYFLAG_CALIB_ANALOGUE      8
+#define JOYFLAG_CALIBRATE           16
+#define JOYFLAG_SIGNED              32
+#define JOYFLAG_UNSIGNED            64
+
+
+/* alternative spellings */
+#define JOYFLAG_ANALOG              JOYFLAG_ANALOGUE
+#define JOYFLAG_CALIB_ANALOG        JOYFLAG_CALIB_ANALOGUE
+
+
+/* global joystick information */
+AL_ARRAY(JOYSTICK_INFO, joy);
+AL_VAR(int, num_joysticks);
+
+
+typedef struct JOYSTICK_DRIVER         /* driver for reading joystick input */
+{
+   int  id;
+   AL_CONST char *name;
+   AL_CONST char *desc;
+   AL_CONST char *ascii_name;
+   AL_METHOD(int, init, (void));
+   AL_METHOD(void, exit, (void));
+   AL_METHOD(int, poll, (void));
+   AL_METHOD(int, save_data, (void));
+   AL_METHOD(int, load_data, (void));
+   AL_METHOD(AL_CONST char *, calibrate_name, (int n));
+   AL_METHOD(int, calibrate, (int n));
+} JOYSTICK_DRIVER;
+
+
+AL_VAR(JOYSTICK_DRIVER, joystick_none);
+AL_VAR(JOYSTICK_DRIVER *, joystick_driver);
+AL_ARRAY(_DRIVER_INFO, _joystick_driver_list);
+
+
+/* macros for constructing the driver list */
+#define BEGIN_JOYSTICK_DRIVER_LIST                             \
+   _DRIVER_INFO _joystick_driver_list[] =                      \
+   {
+
+#define END_JOYSTICK_DRIVER_LIST                               \
+      {  JOY_TYPE_NONE,    &amp;joystick_none,      TRUE  },       \
+      {  0,                NULL,                0     }        \
+   };
+
+
+AL_FUNC(int, install_joystick, (int type));
+AL_FUNC(void, remove_joystick, (void));
+
+AL_FUNC(int, initialise_joystick, (void));
+
+AL_FUNC(int, poll_joystick, (void));
+
+AL_FUNC(int, save_joystick_data, (AL_CONST char *filename));
+AL_FUNC(int, load_joystick_data, (AL_CONST char *filename));
+
+AL_FUNC(AL_CONST char *, calibrate_joystick_name, (int n));
+AL_FUNC(int, calibrate_joystick, (int n));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_JOYSTICK_H */
+
+

Added: trunk/msvc-libs/include/allegro/keyboard.h
===================================================================
--- trunk/msvc-libs/include/allegro/keyboard.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/keyboard.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,222 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Keyboard routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_KEYBOARD_H
+#define ALLEGRO_KEYBOARD_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+typedef struct KEYBOARD_DRIVER
+{
+   int  id;
+   AL_CONST char *name;
+   AL_CONST char *desc;
+   AL_CONST char *ascii_name;
+   int autorepeat;
+   AL_METHOD(int,  init, (void));
+   AL_METHOD(void, exit, (void));
+   AL_METHOD(void, poll, (void));
+   AL_METHOD(void, set_leds, (int leds));
+   AL_METHOD(void, set_rate, (int delay, int rate));
+   AL_METHOD(void, wait_for_input, (void));
+   AL_METHOD(void, stop_waiting_for_input, (void));
+   AL_METHOD(int,  scancode_to_ascii, (int scancode));
+} KEYBOARD_DRIVER;
+
+
+AL_VAR(KEYBOARD_DRIVER *, keyboard_driver);
+AL_ARRAY(_DRIVER_INFO, _keyboard_driver_list);
+
+AL_FUNC(int, install_keyboard, (void));
+AL_FUNC(void, remove_keyboard, (void));
+
+AL_FUNC(int, poll_keyboard, (void));
+AL_FUNC(int, keyboard_needs_poll, (void));
+
+AL_FUNCPTR(int, keyboard_callback, (int key));
+AL_FUNCPTR(int, keyboard_ucallback, (int key, int *scancode));
+AL_FUNCPTR(void, keyboard_lowlevel_callback, (int scancode));
+
+AL_FUNC(void, install_keyboard_hooks, (AL_METHOD(int, keypressed, (void)), AL_METHOD(int, readkey, (void))));
+
+AL_ARRAY(volatile char, key);
+AL_VAR(volatile int, key_shifts);
+
+AL_VAR(int, three_finger_flag);
+AL_VAR(int, key_led_flag);
+
+AL_FUNC(int, keypressed, (void));
+AL_FUNC(int, readkey, (void));
+AL_FUNC(int, ureadkey, (int *scancode));
+AL_FUNC(void, simulate_keypress, (int keycode));
+AL_FUNC(void, simulate_ukeypress, (int keycode, int scancode));
+AL_FUNC(void, clear_keybuf, (void));
+AL_FUNC(void, set_leds, (int leds));
+AL_FUNC(void, set_keyboard_rate, (int delay, int repeat));
+AL_FUNC(int, scancode_to_ascii, (int scancode));
+
+#ifndef ALLEGRO_NO_KEY_DEFINES
+
+#define KB_SHIFT_FLAG         0x0001
+#define KB_CTRL_FLAG          0x0002
+#define KB_ALT_FLAG           0x0004
+#define KB_LWIN_FLAG          0x0008
+#define KB_RWIN_FLAG          0x0010
+#define KB_MENU_FLAG          0x0020
+#define KB_SCROLOCK_FLAG      0x0100
+#define KB_NUMLOCK_FLAG       0x0200
+#define KB_CAPSLOCK_FLAG      0x0400
+#define KB_INALTSEQ_FLAG      0x0800
+#define KB_ACCENT1_FLAG       0x1000
+#define KB_ACCENT2_FLAG       0x2000
+#define KB_ACCENT3_FLAG       0x4000
+#define KB_ACCENT4_FLAG       0x8000
+
+#define KEY_A                 1
+#define KEY_B                 2
+#define KEY_C                 3
+#define KEY_D                 4
+#define KEY_E                 5
+#define KEY_F                 6
+#define KEY_G                 7
+#define KEY_H                 8
+#define KEY_I                 9
+#define KEY_J                 10
+#define KEY_K                 11
+#define KEY_L                 12
+#define KEY_M                 13
+#define KEY_N                 14
+#define KEY_O                 15
+#define KEY_P                 16
+#define KEY_Q                 17
+#define KEY_R                 18
+#define KEY_S                 19
+#define KEY_T                 20
+#define KEY_U                 21
+#define KEY_V                 22
+#define KEY_W                 23
+#define KEY_X                 24
+#define KEY_Y                 25
+#define KEY_Z                 26
+#define KEY_0                 27
+#define KEY_1                 28
+#define KEY_2                 29
+#define KEY_3                 30
+#define KEY_4                 31
+#define KEY_5                 32
+#define KEY_6                 33
+#define KEY_7                 34
+#define KEY_8                 35
+#define KEY_9                 36
+#define KEY_0_PAD             37
+#define KEY_1_PAD             38
+#define KEY_2_PAD             39
+#define KEY_3_PAD             40
+#define KEY_4_PAD             41
+#define KEY_5_PAD             42
+#define KEY_6_PAD             43
+#define KEY_7_PAD             44
+#define KEY_8_PAD             45
+#define KEY_9_PAD             46
+#define KEY_F1                47
+#define KEY_F2                48
+#define KEY_F3                49
+#define KEY_F4                50
+#define KEY_F5                51
+#define KEY_F6                52
+#define KEY_F7                53
+#define KEY_F8                54
+#define KEY_F9                55
+#define KEY_F10               56
+#define KEY_F11               57
+#define KEY_F12               58
+#define KEY_ESC               59
+#define KEY_TILDE             60
+#define KEY_MINUS             61
+#define KEY_EQUALS            62
+#define KEY_BACKSPACE         63
+#define KEY_TAB               64
+#define KEY_OPENBRACE         65
+#define KEY_CLOSEBRACE        66
+#define KEY_ENTER             67
+#define KEY_COLON             68
+#define KEY_QUOTE             69
+#define KEY_BACKSLASH         70
+#define KEY_BACKSLASH2        71
+#define KEY_COMMA             72
+#define KEY_STOP              73
+#define KEY_SLASH             74
+#define KEY_SPACE             75
+#define KEY_INSERT            76
+#define KEY_DEL               77
+#define KEY_HOME              78
+#define KEY_END               79
+#define KEY_PGUP              80
+#define KEY_PGDN              81
+#define KEY_LEFT              82
+#define KEY_RIGHT             83
+#define KEY_UP                84
+#define KEY_DOWN              85
+#define KEY_SLASH_PAD         86
+#define KEY_ASTERISK          87
+#define KEY_MINUS_PAD         88
+#define KEY_PLUS_PAD          89
+#define KEY_DEL_PAD           90
+#define KEY_ENTER_PAD         91
+#define KEY_PRTSCR            92
+#define KEY_PAUSE             93
+#define KEY_ABNT_C1           94
+#define KEY_YEN               95
+#define KEY_KANA              96
+#define KEY_CONVERT           97
+#define KEY_NOCONVERT         98
+#define KEY_AT                99
+#define KEY_CIRCUMFLEX        100
+#define KEY_COLON2            101
+#define KEY_KANJI             102
+
+#define KEY_MODIFIERS         103
+
+#define KEY_LSHIFT            103
+#define KEY_RSHIFT            104
+#define KEY_LCONTROL          105
+#define KEY_RCONTROL          106
+#define KEY_ALT               107
+#define KEY_ALTGR             108
+#define KEY_LWIN              109
+#define KEY_RWIN              110
+#define KEY_MENU              111
+#define KEY_SCRLOCK           112
+#define KEY_NUMLOCK           113
+#define KEY_CAPSLOCK          114
+
+#define KEY_MAX               115
+
+#endif /* ALLEGRO_NO_KEY_DEFINES */
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_KEYBOARD_H */
+
+

Added: trunk/msvc-libs/include/allegro/matrix.h
===================================================================
--- trunk/msvc-libs/include/allegro/matrix.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/matrix.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,96 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Matrix math routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_MATRIX_H
+#define ALLEGRO_MATRIX_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;fixed.h&quot;
+#include &quot;fmaths.h&quot;
+
+typedef struct MATRIX            /* transformation matrix (fixed point) */
+{
+   fixed v[3][3];                /* scaling and rotation */
+   fixed t[3];                   /* translation */
+} MATRIX;
+
+
+typedef struct MATRIX_f          /* transformation matrix (floating point) */
+{
+   float v[3][3];                /* scaling and rotation */
+   float t[3];                   /* translation */
+} MATRIX_f;
+
+
+AL_VAR(MATRIX, identity_matrix);
+AL_VAR(MATRIX_f, identity_matrix_f);
+
+AL_FUNC(void, get_translation_matrix, (MATRIX *m, fixed x, fixed y, fixed z));
+AL_FUNC(void, get_translation_matrix_f, (MATRIX_f *m, float x, float y, float z));
+
+AL_FUNC(void, get_scaling_matrix, (MATRIX *m, fixed x, fixed y, fixed z));
+AL_FUNC(void, get_scaling_matrix_f, (MATRIX_f *m, float x, float y, float z));
+
+AL_FUNC(void, get_x_rotate_matrix, (MATRIX *m, fixed r));
+AL_FUNC(void, get_x_rotate_matrix_f, (MATRIX_f *m, float r));
+
+AL_FUNC(void, get_y_rotate_matrix, (MATRIX *m, fixed r));
+AL_FUNC(void, get_y_rotate_matrix_f, (MATRIX_f *m, float r));
+
+AL_FUNC(void, get_z_rotate_matrix, (MATRIX *m, fixed r));
+AL_FUNC(void, get_z_rotate_matrix_f, (MATRIX_f *m, float r));
+
+AL_FUNC(void, get_rotation_matrix, (MATRIX *m, fixed x, fixed y, fixed z));
+AL_FUNC(void, get_rotation_matrix_f, (MATRIX_f *m, float x, float y, float z));
+
+AL_FUNC(void, get_align_matrix, (MATRIX *m, fixed xfront, fixed yfront, fixed zfront, fixed xup, fixed yup, fixed zup));
+AL_FUNC(void, get_align_matrix_f, (MATRIX_f *m, float xfront, float yfront, float zfront, float xup, float yup, float zup));
+
+AL_FUNC(void, get_vector_rotation_matrix, (MATRIX *m, fixed x, fixed y, fixed z, fixed a));
+AL_FUNC(void, get_vector_rotation_matrix_f, (MATRIX_f *m, float x, float y, float z, float a));
+
+AL_FUNC(void, get_transformation_matrix, (MATRIX *m, fixed scale, fixed xrot, fixed yrot, fixed zrot, fixed x, fixed y, fixed z));
+AL_FUNC(void, get_transformation_matrix_f, (MATRIX_f *m, float scale, float xrot, float yrot, float zrot, float x, float y, float z));
+
+AL_FUNC(void, get_camera_matrix, (MATRIX *m, fixed x, fixed y, fixed z, fixed xfront, fixed yfront, fixed zfront, fixed xup, fixed yup, fixed zup, fixed fov, fixed aspect));
+AL_FUNC(void, get_camera_matrix_f, (MATRIX_f *m, float x, float y, float z, float xfront, float yfront, float zfront, float xup, float yup, float zup, float fov, float aspect));
+
+AL_FUNC(void, qtranslate_matrix, (MATRIX *m, fixed x, fixed y, fixed z));
+AL_FUNC(void, qtranslate_matrix_f, (MATRIX_f *m, float x, float y, float z));
+
+AL_FUNC(void, qscale_matrix, (MATRIX *m, fixed scale));
+AL_FUNC(void, qscale_matrix_f, (MATRIX_f *m, float scale));
+
+AL_FUNC(void, matrix_mul, (AL_CONST MATRIX *m1, AL_CONST MATRIX *m2, MATRIX *out));
+AL_FUNC(void, matrix_mul_f, (AL_CONST MATRIX_f *m1, AL_CONST MATRIX_f *m2, MATRIX_f *out));
+
+AL_FUNC(void, apply_matrix_f, (AL_CONST MATRIX_f *m, float x, float y, float z, float *xout, float *yout, float *zout));
+
+#include &quot;inline/matrix.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_MATRIX_H */
+
+

Added: trunk/msvc-libs/include/allegro/midi.h
===================================================================
--- trunk/msvc-libs/include/allegro/midi.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/midi.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,141 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      MIDI music routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_MIDI_H
+#define ALLEGRO_MIDI_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+                                       /* Theoretical maximums: */
+#include &quot;base.h&quot;
+
+#define MIDI_VOICES           64       /* actual drivers may not be */
+#define MIDI_TRACKS           32       /* able to handle this many */
+
+
+
+typedef struct MIDI                    /* a midi file */
+{
+   int divisions;                      /* number of ticks per quarter note */
+   struct {
+      unsigned char *data;             /* MIDI message stream */
+      int len;                         /* length of the track data */
+   } track[MIDI_TRACKS];
+} MIDI;
+
+
+
+#define MIDI_AUTODETECT       -1
+#define MIDI_NONE             0
+#define MIDI_DIGMID           AL_ID('D','I','G','I')
+
+typedef struct MIDI_DRIVER             /* driver for playing midi music */
+{
+   int  id;                            /* driver ID code */
+   AL_CONST char *name;                /* driver name */
+   AL_CONST char *desc;                /* description string */
+   AL_CONST char *ascii_name;          /* ASCII format name string */
+   int  voices;                        /* available voices */
+   int  basevoice;                     /* voice number offset */
+   int  max_voices;                    /* maximum voices we can support */
+   int  def_voices;                    /* default number of voices to use */
+   int  xmin, xmax;                    /* reserved voice range */
+
+   /* setup routines */
+   AL_METHOD(int,  detect, (int input));
+   AL_METHOD(int,  init, (int input, int voices));
+   AL_METHOD(void, exit, (int input));
+   AL_METHOD(int,  mixer_volume, (int volume));
+
+   /* raw MIDI output to MPU-401, etc. */
+   AL_METHOD(void, raw_midi, (int data));
+
+   /* dynamic patch loading routines */
+   AL_METHOD(int,  load_patches, (AL_CONST char *patches, AL_CONST char *drums));
+   AL_METHOD(void, adjust_patches, (AL_CONST char *patches, AL_CONST char *drums));
+
+   /* note control functions */
+   AL_METHOD(void, key_on, (int inst, int note, int bend, int vol, int pan));
+   AL_METHOD(void, key_off, (int voice));
+   AL_METHOD(void, set_volume, (int voice, int vol));
+   AL_METHOD(void, set_pitch, (int voice, int note, int bend));
+   AL_METHOD(void, set_pan, (int voice, int pan));
+   AL_METHOD(void, set_vibrato, (int voice, int amount));
+} MIDI_DRIVER;
+
+
+AL_VAR(MIDI_DRIVER, midi_digmid);
+
+AL_ARRAY(_DRIVER_INFO, _midi_driver_list);
+
+
+/* macros for constructing the driver lists */
+#define BEGIN_MIDI_DRIVER_LIST                                 \
+   _DRIVER_INFO _midi_driver_list[] =                          \
+   {
+
+#define END_MIDI_DRIVER_LIST                                   \
+      {  0,                NULL,                0     }        \
+   };
+
+#define MIDI_DRIVER_DIGMID                                     \
+      {  MIDI_DIGMID,      &amp;midi_digmid,        TRUE  },
+
+
+AL_VAR(MIDI_DRIVER *, midi_driver);
+
+AL_VAR(MIDI_DRIVER *, midi_input_driver);
+
+AL_VAR(int, midi_card);
+
+AL_VAR(int, midi_input_card);
+
+AL_VAR(volatile long, midi_pos);       /* current position in the midi file */
+
+AL_VAR(long, midi_loop_start);         /* where to loop back to at EOF */
+AL_VAR(long, midi_loop_end);           /* loop when we hit this position */
+
+AL_FUNC(int, detect_midi_driver, (int driver_id));
+
+AL_FUNC(MIDI *, load_midi, (AL_CONST char *filename));
+AL_FUNC(void, destroy_midi, (MIDI *midi));
+AL_FUNC(int, play_midi, (MIDI *midi, int loop));
+AL_FUNC(int, play_looped_midi, (MIDI *midi, int loop_start, int loop_end));
+AL_FUNC(void, stop_midi, (void));
+AL_FUNC(void, midi_pause, (void));
+AL_FUNC(void, midi_resume, (void));
+AL_FUNC(int, midi_seek, (int target));
+AL_FUNC(void, midi_out, (unsigned char *data, int length));
+AL_FUNC(int, load_midi_patches, (void));
+
+AL_FUNCPTR(void, midi_msg_callback, (int msg, int byte1, int byte2));
+AL_FUNCPTR(void, midi_meta_callback, (int type, AL_CONST unsigned char *data, int length));
+AL_FUNCPTR(void, midi_sysex_callback, (AL_CONST unsigned char *data, int length));
+
+AL_FUNCPTR(void, midi_recorder, (unsigned char data));
+
+AL_FUNC(void, lock_midi, (struct MIDI *midi));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_MIDI_H */
+
+

Added: trunk/msvc-libs/include/allegro/mouse.h
===================================================================
--- trunk/msvc-libs/include/allegro/mouse.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/mouse.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,101 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Mouse routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_MOUSE_H
+#define ALLEGRO_MOUSE_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+#define MOUSEDRV_AUTODETECT  -1
+#define MOUSEDRV_NONE         0
+
+
+typedef struct MOUSE_DRIVER
+{
+   int  id;
+   AL_CONST char *name;
+   AL_CONST char *desc;
+   AL_CONST char *ascii_name;
+   AL_METHOD(int,  init, (void));
+   AL_METHOD(void, exit, (void));
+   AL_METHOD(void, poll, (void));
+   AL_METHOD(void, timer_poll, (void));
+   AL_METHOD(void, position, (int x, int y));
+   AL_METHOD(void, set_range, (int x1, int y1, int x2, int y2));
+   AL_METHOD(void, set_speed, (int xspeed, int yspeed));
+   AL_METHOD(void, get_mickeys, (int *mickeyx, int *mickeyy));
+   AL_METHOD(int,  analyse_data, (AL_CONST char *buffer, int size));
+} MOUSE_DRIVER;
+
+
+AL_VAR(MOUSE_DRIVER, mousedrv_none);
+AL_VAR(MOUSE_DRIVER *, mouse_driver);
+AL_ARRAY(_DRIVER_INFO, _mouse_driver_list);
+
+AL_FUNC(int, install_mouse, (void));
+AL_FUNC(void, remove_mouse, (void));
+
+AL_FUNC(int, poll_mouse, (void));
+AL_FUNC(int, mouse_needs_poll, (void));
+
+AL_VAR(struct BITMAP *, mouse_sprite);
+AL_VAR(int, mouse_x_focus);
+AL_VAR(int, mouse_y_focus);
+
+AL_VAR(volatile int, mouse_x);
+AL_VAR(volatile int, mouse_y);
+AL_VAR(volatile int, mouse_z);
+AL_VAR(volatile int, mouse_b);
+AL_VAR(volatile int, mouse_pos);
+
+AL_VAR(volatile int, freeze_mouse_flag);
+
+#define MOUSE_FLAG_MOVE             1
+#define MOUSE_FLAG_LEFT_DOWN        2
+#define MOUSE_FLAG_LEFT_UP          4
+#define MOUSE_FLAG_RIGHT_DOWN       8
+#define MOUSE_FLAG_RIGHT_UP         16
+#define MOUSE_FLAG_MIDDLE_DOWN      32
+#define MOUSE_FLAG_MIDDLE_UP        64
+#define MOUSE_FLAG_MOVE_Z           128
+
+AL_FUNCPTR(void, mouse_callback, (int flags));
+
+AL_FUNC(void, show_mouse, (struct BITMAP *bmp));
+AL_FUNC(void, scare_mouse, (void));
+AL_FUNC(void, scare_mouse_area, (int x, int y, int w, int h));
+AL_FUNC(void, unscare_mouse, (void));
+AL_FUNC(void, position_mouse, (int x, int y));
+AL_FUNC(void, position_mouse_z, (int z));
+AL_FUNC(void, set_mouse_range, (int x1, int y1, int x2, int y2));
+AL_FUNC(void, set_mouse_speed, (int xspeed, int yspeed));
+AL_FUNC(void, set_mouse_sprite, (struct BITMAP *sprite));
+AL_FUNC(void, set_mouse_sprite_focus, (int x, int y));
+AL_FUNC(void, get_mouse_mickeys, (int *mickeyx, int *mickeyy));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_MOUSE_H */
+
+

Added: trunk/msvc-libs/include/allegro/palette.h
===================================================================
--- trunk/msvc-libs/include/allegro/palette.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/palette.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,42 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Palette type.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_PALETTE_H
+#define ALLEGRO_PALETTE_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+typedef struct RGB
+{
+   unsigned char r, g, b;
+   unsigned char filler;
+} RGB;
+
+#define PAL_SIZE     256
+
+typedef RGB PALETTE[PAL_SIZE];
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_PALETTE_H */
+
+

Added: trunk/msvc-libs/include/allegro/platform/aintbeos.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aintbeos.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aintbeos.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,136 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Definitions for internal use by the BeOS configuration.
+ *
+ *      By Jason Wilkins.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include &quot;bealleg.h&quot;
+
+#ifdef __cplusplus
+extern status_t       ignore_result;
+
+extern volatile int32 focus_count;
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+int  be_key_init(void);
+void be_key_exit(void);
+void be_key_set_leds(int leds);
+void be_key_set_rate(int delay, int repeat);
+void be_key_wait_for_input(void);
+void be_key_stop_waiting_for_input(void);
+void be_key_suspend(void);
+void be_key_resume(void);
+
+int  be_sys_init(void);
+void be_sys_exit(void);
+void _be_sys_get_executable_name(char *output, int size);
+void be_sys_get_executable_name(char *output, int size);
+int be_sys_find_resource(char *dest, AL_CONST char *resource, int size);
+void be_sys_set_window_title(AL_CONST char *name);
+int be_sys_set_window_close_button(int enable);
+void be_sys_set_window_close_hook(void (*proc)(void));
+void be_sys_message(AL_CONST char *msg);
+int be_sys_desktop_color_depth(void);
+int be_sys_get_desktop_resolution(int *width, int *height);
+void be_sys_yield_timeslice(void);
+int be_sys_set_display_switch_mode(int mode);
+int be_sys_set_display_switch_cb(int dir, void (*cb)(void));
+void be_sys_remove_display_switch_cb(void (*cb)(void));
+void be_sys_suspend(void);
+void be_sys_resume(void);
+void be_main_suspend(void);
+void be_main_resume(void);
+void be_display_switch_callback(int dir);
+
+struct BITMAP *be_gfx_fullscreen_init(int w, int h, int v_w, int v_h, int color_depth);
+struct BITMAP *be_gfx_fullscreen_safe_init(int w, int h, int v_w, int v_h, int color_depth);
+void be_gfx_fullscreen_exit(struct BITMAP *b);
+void be_gfx_fullscreen_acquire(struct BITMAP *b);
+void be_gfx_fullscreen_release(struct BITMAP *b);
+void be_gfx_fullscreen_set_palette(AL_CONST struct RGB *p, int from, int to, int vsync);
+int be_gfx_fullscreen_scroll(int x, int y);
+int be_gfx_fullscreen_request_scroll(int x, int y);
+int be_gfx_fullscreen_poll_scroll(void);
+int be_gfx_fullscreen_request_video_bitmap(struct BITMAP *bitmap);
+void be_gfx_vsync(void);
+struct GFX_MODE_LIST *be_gfx_fullscreen_fetch_mode_list(void);
+void be_gfx_fullscreen_accelerate(int color_depth);
+#ifdef ALLEGRO_NO_ASM
+unsigned long be_gfx_fullscreen_read_write_bank(BITMAP *bmp, int line);
+void be_gfx_fullscreen_unwrite_bank(BITMAP *bmp);
+#else
+unsigned long _be_gfx_fullscreen_read_write_bank_asm(BITMAP *bmp, int line);
+void _be_gfx_fullscreen_unwrite_bank_asm(BITMAP *bmp);
+#endif
+
+struct BITMAP *be_gfx_windowed_init(int w, int h, int v_w, int v_h, int color_depth);
+void be_gfx_windowed_exit(struct BITMAP *b);
+void be_gfx_windowed_acquire(struct BITMAP *bmp);
+void be_gfx_windowed_release(struct BITMAP *bmp);
+void be_gfx_windowed_set_palette(AL_CONST struct RGB *p, int from, int to, int vsync);
+#ifdef ALLEGRO_NO_ASM
+void be_gfx_windowed_unwrite_bank(BITMAP *bmp);
+unsigned long be_gfx_windowed_read_write_bank(BITMAP *bmp, int line);
+#else
+void _be_gfx_windowed_unwrite_bank_asm(BITMAP *bmp);
+unsigned long _be_gfx_windowed_read_write_bank_asm(BITMAP *bmp, int line);
+#endif
+
+int  be_time_init(void);
+void be_time_exit(void);
+//int  be_time_can_simulate_retrace(void);
+//void be_time_simulate_retrace(int enable);
+void be_time_rest(long time, AL_METHOD(void, callback, (void)));
+void be_time_suspend(void);
+void be_time_resume(void);
+
+int be_mouse_init(void);
+void be_mouse_exit(void);
+void be_mouse_position(int x, int y);
+void be_mouse_set_range(int x1, int y1, int x2, int y2);
+void be_mouse_set_speed(int xspeed, int yspeed);
+void be_mouse_get_mickeys(int *mickeyx, int *mickeyy);
+
+int be_joy_init(void);
+void be_joy_exit(void);
+int be_joy_poll(void);
+
+int be_sound_detect(int input);
+int be_sound_init(int input, int voices);
+void be_sound_exit(int input);
+void *be_sound_lock_voice(int voice, int start, int end);
+void be_sound_unlock_voice(int voice);
+int be_sound_buffer_size(void);
+int be_sound_mixer_volume(int volume);
+void be_sound_suspend(void);
+void be_sound_resume(void);
+
+int be_midi_detect(int input);
+int be_midi_init(int input, int voices);
+void be_midi_exit(int input);
+int be_midi_mixer_volume(int volume);
+void be_midi_key_on(int inst, int note, int bend, int vol, int pan);
+void be_midi_key_off(int voice);
+void be_midi_set_volume(int voice, int vol);
+void be_midi_set_pitch(int voice, int note, int bend);
+void be_midi_set_pan(int voice, int pan);
+
+#ifdef __cplusplus
+}
+#endif

Added: trunk/msvc-libs/include/allegro/platform/aintdos.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aintdos.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aintdos.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,185 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Some definitions for internal use by the DOS library code.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTDOS_H
+#define AINTDOS_H
+
+#ifndef ALLEGRO_H
+   #error must include allegro.h first
+#endif
+
+#ifndef ALLEGRO_DOS
+   #error bad include
+#endif
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+/* macros to enable and disable interrupts */
+#if defined ALLEGRO_GCC
+
+   #define DISABLE()    asm volatile (&quot;cli&quot;)
+   #define ENABLE()     asm volatile (&quot;sti&quot;)
+
+#elif defined ALLEGRO_WATCOM
+
+   void DISABLE(void);
+   void ENABLE(void);
+
+   #pragma aux DISABLE  = &quot;cli&quot;;
+   #pragma aux ENABLE   = &quot;sti&quot;;
+
+#else
+
+   #define DISABLE()    asm { cli }
+   #define ENABLE()     asm { sti }
+
+#endif
+
+
+AL_INLINE(void, _enter_critical, (void),
+{
+   /* check if windows is running */
+   if ((os_type == OSTYPE_WIN3)  || (os_type == OSTYPE_WIN95) ||
+       (os_type == OSTYPE_WIN98) || (os_type == OSTYPE_WINME) ||
+       (os_type == OSTYPE_WINNT) || (os_type == OSTYPE_WIN2000)) {
+      __dpmi_regs r;
+      r.x.ax = 0x1681; 
+      __dpmi_int(0x2F, &amp;r);
+   }
+
+   DISABLE();
+})
+
+
+AL_INLINE(void, _exit_critical, (void),
+{
+   /* check if windows is running */
+   if ((os_type == OSTYPE_WIN3)  || (os_type == OSTYPE_WIN95) ||
+       (os_type == OSTYPE_WIN98) || (os_type == OSTYPE_WINME) || 
+       (os_type == OSTYPE_WINNT) || (os_type == OSTYPE_WIN2000)) {
+      __dpmi_regs r;
+      r.x.ax = 0x1682; 
+      __dpmi_int(0x2F, &amp;r);
+   }
+
+   ENABLE();
+})
+
+
+/* interrupt hander stuff */
+AL_FUNC(void, _dos_irq_init, (void));
+AL_FUNC(void, _dos_irq_exit, (void));
+
+#define _map_irq(irq)   (((irq)&gt;7) ? ((irq)+104) : ((irq)+8))
+
+AL_FUNC(int, _install_irq, (int num, AL_METHOD(int, handler, (void))));
+AL_FUNC(void, _remove_irq, (int num));
+AL_FUNC(void, _restore_irq, (int irq));
+AL_FUNC(void, _enable_irq, (int irq));
+AL_FUNC(void, _disable_irq, (int irq));
+
+#define _eoi(irq) { outportb(0x20, 0x20); if ((irq)&gt;7) outportb(0xA0, 0x20); }
+
+typedef struct _IRQ_HANDLER
+{
+   AL_METHOD(int, handler, (void));    /* our C handler */
+   int number;                         /* irq number */
+
+   #ifdef ALLEGRO_DJGPP
+      __dpmi_paddr old_vector;         /* original protected mode vector */
+   #else
+      void (__interrupt __far *old_vector)();
+   #endif
+} _IRQ_HANDLER;
+
+
+/* sound lib stuff */
+AL_VAR(int, _fm_port);
+AL_VAR(int, _mpu_port);
+AL_VAR(int, _mpu_irq);
+
+
+/* DPMI memory mapping routines */
+AL_FUNC(int, _create_physical_mapping, (unsigned long *linear, int *segment, unsigned long physaddr, int size));
+AL_FUNC(void, _remove_physical_mapping, (unsigned long *linear, int *segment));
+AL_FUNC(int, _create_linear_mapping, (unsigned long *linear, unsigned long physaddr, int size));
+AL_FUNC(void, _remove_linear_mapping, (unsigned long *linear));
+AL_FUNC(int, _create_selector, (int *segment, unsigned long linear, int size));
+AL_FUNC(void, _remove_selector, (int *segment));
+AL_FUNC(void, _unlock_dpmi_data, (void *addr, int size));
+
+
+/* bank switching routines (these use a non-C calling convention on i386!) */
+AL_FUNC(void, _vesa_window_1, (void));
+AL_FUNC(void, _vesa_window_1_end, (void));
+
+AL_FUNC(void, _vesa_window_2, (void));
+AL_FUNC(void, _vesa_window_2_end, (void));
+
+AL_FUNC(void, _vesa_pm_window_1, (void));
+AL_FUNC(void, _vesa_pm_window_1_end, (void));
+
+AL_FUNC(void, _vesa_pm_window_2, (void));
+AL_FUNC(void, _vesa_pm_window_2_end, (void));
+
+AL_FUNC(void, _vesa_pm_es_window_1, (void));
+AL_FUNC(void, _vesa_pm_es_window_1_end, (void));
+
+AL_FUNC(void, _vesa_pm_es_window_2, (void));
+AL_FUNC(void, _vesa_pm_es_window_2_end, (void));
+
+
+/* stuff for the VESA driver */
+AL_VAR(__dpmi_regs, _dpmi_reg);
+
+AL_VAR(int, _window_2_offset);
+
+AL_VAR(int, _mmio_segment);
+
+AL_FUNCPTR(void, _pm_vesa_switcher, (void));
+AL_FUNCPTR(void, _pm_vesa_scroller, (void));
+AL_FUNCPTR(void, _pm_vesa_palette, (void));
+
+
+AL_FUNC(int, _sb_read_dsp_version, (void));
+AL_FUNC(int, _sb_reset_dsp, (int data));
+AL_FUNC(void, _sb_voice, (int state));
+AL_FUNC(int, _sb_set_mixer, (int digi_volume, int midi_volume));
+
+AL_FUNC(void, _mpu_poll, (void));
+
+AL_FUNC(int, _dma_allocate_mem, (int bytes, int *sel, unsigned long *phys));
+AL_FUNC(void, _dma_start, (int channel, unsigned long addr, int size, int auto_init, int input));
+AL_FUNC(void, _dma_stop, (int channel));
+AL_FUNC(unsigned long, _dma_todo, (int channel));
+AL_FUNC(void, _dma_lock_mem, (void));
+
+
+/* VGA register access helpers */
+#include &quot;allegro/internal/aintvga.h&quot;
+
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef AINTDOS_H */

Added: trunk/msvc-libs/include/allegro/platform/aintlnx.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aintlnx.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aintlnx.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,272 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Some definitions for internal use by the Linux console code.
+ *
+ *      By George Foot.
+ * 
+ *      See readme.txt for copyright information.
+ */
+
+#ifndef AINTLNX_H
+#define AINTLNX_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/**************************************/
+/************ Driver lists ************/
+/**************************************/
+
+extern _DRIVER_INFO _linux_gfx_driver_list[];
+extern _DRIVER_INFO _linux_keyboard_driver_list[];
+extern _DRIVER_INFO _linux_mouse_driver_list[];
+extern _DRIVER_INFO _linux_timer_driver_list[];
+extern _DRIVER_INFO _linux_joystick_driver_list[];
+
+
+/****************************************/
+/************ Memory mapping ************/ /* (src/linux/lmemory.c) */
+/****************************************/
+
+/* struct MAPPED_MEMORY:  Used to describe a block of memory mapped 
+ *  into our address space (in particular, the video memory).
+ */
+struct MAPPED_MEMORY {
+	unsigned int base, size;      /* linear address and size of block */
+	int perms;                    /* PROT_READ | PROT_WRITE, etc */
+	void *data;                   /* pointer to block after mapping */
+};
+
+extern int __al_linux_have_ioperms;
+
+int __al_linux_init_memory (void);
+int __al_linux_shutdown_memory (void);
+int __al_linux_map_memory (struct MAPPED_MEMORY *info);
+int __al_linux_unmap_memory (struct MAPPED_MEMORY *info);
+
+
+/******************************************/
+/************ Standard drivers ************/ /* (src/linux/lstddrv.c) */
+/******************************************/
+
+#define PRIVATE_SIZE   1
+
+typedef struct STD_DRIVER {
+   unsigned    type; /* One of the above STD_ constants */
+
+   int (*update) (void);
+   void (*resume) (void);
+   void (*suspend) (void);
+
+   int         fd;   /* Descriptor of the opened device */
+
+#ifndef __cplusplus
+   unsigned    private[PRIVATE_SIZE];
+#else
+   unsigned    priv[PRIVATE_SIZE];
+#endif
+} STD_DRIVER;
+
+#define STD_RTC              0
+#define STD_MOUSE            1
+#define STD_KBD              2
+
+#define N_STD_DRIVERS        3
+
+/* List of standard drivers */
+extern STD_DRIVER *__al_linux_std_drivers[];
+
+/* Indices of the fields in the STD_DRIVER.private array */
+#define PRIV_ENABLED       0
+
+/* Exported functions */
+int  __al_linux_add_standard_driver (STD_DRIVER *spec);
+int  __al_linux_remove_standard_driver (STD_DRIVER *spec);
+int  __al_linux_update_standard_driver (int type);
+void __al_linux_update_standard_drivers (void);
+void __al_linux_async_set_drivers (int which, int on_off);
+void __al_linux_disable_standard_driver (int type);
+void __al_linux_enable_standard_driver (int type);
+
+
+/******************************************/
+/************ Asynchronous I/O ************/ /* (src/linux/lasyncio.c) */
+/******************************************/
+
+extern unsigned __al_linux_async_io_mode;
+
+
+/******************************************/
+/************ Console routines ************/ /* (src/linux/lconsole.c) */
+/******************************************/
+
+#define N_CRTC_REGS  24
+#define N_ATC_REGS   21
+#define N_GC_REGS    9
+#define N_SEQ_REGS   5
+
+#define MISC_REG_R       0x03CC
+#define MISC_REG_W       0x03C2
+#define ATC_REG_IW       0x03C0
+#define ATC_REG_R        0x03C1
+#define GC_REG_I         0x03CE
+#define GC_REG_RW        0x03CF
+#define SEQ_REG_I        0x03C4
+#define SEQ_REG_RW       0x03C5
+#define PEL_REG_IW       0x03C8
+#define PEL_REG_IR       0x03C7
+#define PEL_REG_D        0x03C9
+
+#define _is1             0x03DA
+
+#define ATC_DELAY        10 /* microseconds - for usleep() */
+
+#define VGA_MEMORY_BASE  0xA0000
+#define VGA_MEMORY_SIZE  0x10000
+#define VGA_FONT_SIZE    0x02000
+
+/* This structure is also used for video state saving/restoring, therefore it
+ * contains fields that are used only when saving/restoring the text mode. */
+typedef struct MODE_REGISTERS
+{
+   unsigned char crt[N_CRTC_REGS];
+   unsigned char seq[N_SEQ_REGS];
+   unsigned char atc[N_ATC_REGS];
+   unsigned char gc[N_GC_REGS];
+   unsigned char misc;
+   unsigned char *ext;
+   unsigned short ext_count;
+   unsigned char *text_font1;
+   unsigned char *text_font2;
+   unsigned long flags;
+   union {
+      unsigned char vga[768];
+      PALETTE allegro;
+   } palette;
+} MODE_REGISTERS;
+
+extern int __al_linux_vt;
+extern int __al_linux_console_fd;
+extern int __al_linux_prev_vt;
+extern int __al_linux_got_text_message;
+extern struct termios __al_linux_startup_termio;
+extern struct termios __al_linux_work_termio;
+
+int __al_linux_init_console (void);
+int __al_linux_done_console (void);
+
+int __al_linux_console_graphics (void);
+int __al_linux_console_text (void);
+
+int __al_linux_wait_for_display (void);
+
+
+/*************************************/
+/************ VGA helpers ************/ /* (src/linux/lvgahelp.c) */
+/*************************************/
+
+int __al_linux_init_vga_helpers (void);
+int __al_linux_shutdown_vga_helpers (void);
+
+void __al_linux_screen_off (void);
+void __al_linux_screen_on (void);
+
+void __al_linux_clear_vram (void);
+
+void __al_linux_set_vga_regs (MODE_REGISTERS *regs);
+void __al_linux_get_vga_regs (MODE_REGISTERS *regs);
+
+void __al_linux_save_gfx_mode (void);
+void __al_linux_restore_gfx_mode (void);
+void __al_linux_save_text_mode (void);
+void __al_linux_restore_text_mode (void);
+
+#define __just_a_moment() usleep(ATC_DELAY)
+
+
+/**************************************/
+/************ VT switching ************/ /* (src/linux/vtswitch.c) */
+/**************************************/
+
+/* signals for VT switching */
+#define SIGRELVT        SIGUSR1
+#define SIGACQVT        SIGUSR2
+
+int __al_linux_init_vtswitch (void);
+int __al_linux_done_vtswitch (void);
+
+void __al_linux_acquire_bitmap (BITMAP *bmp);
+void __al_linux_release_bitmap (BITMAP *bmp);
+
+int __al_linux_set_display_switch_mode (int mode);
+int __al_linux_set_display_switch_callback (int dir, void (*cb) (void));
+void __al_linux_remove_display_switch_callback (void (*cb) (void));
+
+void __al_linux_display_switch_lock (int lock, int foreground);
+
+extern volatile int __al_linux_switching_blocked;
+
+
+/**************************************/
+/************ Mode setting ************/ /* (src/linux/lgraph.c) */
+/**************************************/
+
+typedef struct GFX_MODE_INFO {
+	int w,h,c;   /* width, height, colour depth */
+	int id;      /* ID code, for driver's reference */
+	void *data;  /* data for driver's use in setting the mode */
+} GFX_MODE_INFO;
+
+BITMAP *__al_linux_gfx_mode_set_helper (
+	int w, int h, int v_w, int v_h, int c,
+	GFX_DRIVER *driver, GFX_MODE_INFO *mode,
+	int (*set_video_mode) (GFX_MODE_INFO *mode),
+	void (*set_width) (int w)
+);
+
+
+/*******************************/
+/************ Mouse ************/ /* (src/linux/lmouse.c) */
+/*******************************/
+
+struct mouse_info {
+   int x, y, z, l, r, m;
+   int updated;
+};
+
+typedef struct INTERNAL_MOUSE_DRIVER {
+   int device;
+   int (*process) (unsigned char *buf, int buf_size, struct mouse_info *info);
+   int num_buttons;
+} INTERNAL_MOUSE_DRIVER;
+
+int  __al_linux_mouse_init (INTERNAL_MOUSE_DRIVER *drv);
+void __al_linux_mouse_exit (void);
+void __al_linux_mouse_position (int x, int y);
+void __al_linux_mouse_set_range (int x1, int y1, int x2, int y2);
+void __al_linux_mouse_set_speed (int xspeed, int yspeed);
+void __al_linux_mouse_get_mickeys (int *mickeyx, int *mickeyy);
+
+
+/* VGA register access helpers */
+#include &quot;allegro/internal/aintern.h&quot;
+#include &quot;allegro/internal/aintvga.h&quot;
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef AINTLNX_H */
+

Added: trunk/msvc-libs/include/allegro/platform/aintmac.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aintmac.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aintmac.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,95 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Some definitions for internal use by the MacOs library code.
+ *
+ *      By Ronaldo Hideki Yamada.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTMAC_H
+#define AINTMAC_H
+
+#ifndef ALLEGRO_H
+   #error must include allegro.h first
+#endif
+
+#ifndef ALLEGRO_MPW
+   #error bad include
+#endif
+
+#include &quot;macalleg.h&quot;
+#include &quot;allegro/aintern.h&quot;
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+/*macsbmp.c*/
+extern void _mac_init_system_bitmap(void);
+extern BITMAP *_mac_create_system_bitmap(int w, int h);
+extern void _mac_destroy_system_bitmap(BITMAP *bmp);
+extern void _mac_sys_set_clip(struct BITMAP *dst);
+extern void _mac_sys_clear_to_color8(BITMAP *bmp, int color);
+extern void _mac_sys_blit8(BITMAP *src, BITMAP *dst, int src_x, int src_y, int dst_x, int dst_y, int w, int h);
+extern void _mac_sys_selfblit8(BITMAP *src, BITMAP *dst, int src_x, int src_y, int dst_x, int dst_y, int w, int h);
+extern int _mac_sys_triangle(struct BITMAP *bmp, int x1, int y1, int x2, int y2, int x3, int y3, int color);
+extern void _mac_sys_rectfill8(struct BITMAP *bmp, int x1, int y1, int x2, int y2, int color);
+extern void _mac_sys_hline8(struct BITMAP *bmp, int x1, int y, int x2, int color);
+extern void _mac_sys_vline8(struct BITMAP *bmp, int x, int y1, int y2, int color);
+extern BITMAP *_CGrafPtr_to_system_bitmap(CGrafPtr cg);
+
+/*macdraw.c*/
+extern GDHandle MainGDevice;
+extern CTabHandle MainCTable;
+extern short dspr_depth;
+extern volatile short _sync;
+extern const RGBColor ForeDef;
+extern const RGBColor BackDef;
+extern int _dspr_sys_init();
+extern void _dspr_sys_exit();
+
+enum{kRDDNull    =0,
+   kRDDStarted   =1,
+   kRDDReserved  =2,
+   kRDDFadeOut   =4,
+   kRDDActive    =8,
+   kRDDPaused    =16,
+   kRDDUnder     =32,
+   kRDDOver      =64,
+   kRDDouble     =128,
+};
+
+/*macsys.c*/
+extern void _mac_get_executable_name(char *output, int size);
+extern void _mac_message(const char *msg);
+extern int _tm_sys_init();
+extern void _tm_sys_exit();
+
+/*macfile.c*/
+extern int _al_open(const char *filename, int mode);
+extern int _mac_file_sys_init();
+
+/*macallegro.c*/
+extern QDGlobals qd;                                 /*The our QuickDraw globals */
+extern char *strdup(const char *p);
+extern void ptoc(StringPtr pstr, char *cstr);
+extern Boolean RTrapAvailable(short tNumber, TrapType tType);
+extern void MacEntry();
+
+#ifdef __cplusplus
+   }
+#endif
+
+
+#endif          /* ifndef AINTMAC_H */
+

Added: trunk/msvc-libs/include/allegro/platform/aintqnx.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aintqnx.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aintqnx.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,73 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Internal header for the QNX Allegro library.
+ *
+ *      By Angelo Mottola.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTQNX_H
+#define AINTQNX_H
+
+#include &quot;allegro/platform/aintunix.h&quot;
+
+#ifndef SCAN_DEPEND
+   #include &lt;pthread.h&gt;
+   #include &lt;Ph.h&gt;
+   #include &lt;Pt.h&gt;
+#endif
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+#define PH_GFX_NONE       0
+#define PH_GFX_WINDOW     1
+#define PH_GFX_DIRECT     2
+#define PH_GFX_OVERLAY    3
+
+/* from qphoton.c */
+AL_VAR(int, ph_gfx_mode);
+AL_FUNCPTR(void, ph_update_window, (PhRect_t* rect));
+AL_VAR(PdOffscreenContext_t, *ph_window_context);
+AL_ARRAY(PgColor_t, ph_palette);
+
+/* from qsystem.c */
+AL_VAR(PtWidget_t, *ph_window);
+AL_VAR(pthread_mutex_t, qnx_event_mutex);
+AL_VAR(pthread_mutex_t, qnx_gfx_mutex);
+
+/* from qkeydrv.c */
+AL_FUNC(void, qnx_keyboard_handler, (int, int));
+AL_FUNC(void, qnx_keyboard_focused, (int, int));
+
+/* from qmouse.c */
+AL_VAR(int, qnx_mouse_warped);
+AL_FUNC(void, qnx_mouse_handler, (int, int, int, int));
+
+
+/* A very strange thing: PgWaitHWIdle() cannot be found in any system
+ * header file, but it is explained in the QNX docs, and it actually
+ * exists in the Photon library... So until QNX fixes the missing declaration,
+ * we will declare it here.
+ */
+int PgWaitHWIdle(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif

Added: trunk/msvc-libs/include/allegro/platform/aintunix.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aintunix.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aintunix.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,145 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Some definitions for internal use by the Unix library code.
+ *
+ *      By Shawn Hargreaves.
+ * 
+ *      See readme.txt for copyright information.
+ */
+
+#ifndef AINTUNIX_H
+#define AINTUNIX_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#ifndef HAVE_LIBPTHREAD
+   /* Asynchronous event processing with SIGALRM */
+   AL_FUNC(void, _sigalrm_request_abort, (void));
+   AL_FUNCPTR(void, _sigalrm_timer_interrupt_handler, (unsigned long interval));
+#endif
+
+   /* Macros to enable and disable interrupts */
+   #define DISABLE() _unix_bg_man-&gt;disable_interrupts()
+   #define ENABLE()  _unix_bg_man-&gt;enable_interrupts()
+
+
+   /* Helper for locating config files */
+   AL_FUNC(int, _unix_find_resource, (char *dest, AL_CONST char *resource, int size));
+
+
+   /* Generic system driver entry for finding the executable */
+   AL_FUNC(void, _unix_get_executable_name, (char *output, int size));
+
+
+   /* Helper for setting os_type */
+   AL_FUNC(void, _read_os_type, (void));
+
+
+   /* Helper for yield CPU */
+   AL_FUNC(void, _unix_yield_timeslice, (void));
+
+
+   /* Module support */
+   AL_FUNC(void, _unix_load_modules, (int system_driver));
+   AL_FUNC(void, _unix_unload_modules, (void));
+
+
+   /* Dynamic driver lists, for modules */
+   AL_VAR(_DRIVER_INFO *, _unix_gfx_driver_list);
+   AL_VAR(_DRIVER_INFO *, _unix_digi_driver_list);
+   AL_VAR(_DRIVER_INFO *, _unix_midi_driver_list);
+   AL_FUNC(void, _unix_driver_lists_init, (void));
+   AL_FUNC(void, _unix_driver_lists_shutdown, (void));
+   AL_FUNC(void, _unix_register_gfx_driver, (int id, GFX_DRIVER *driver, int autodetect, int priority));
+   AL_FUNC(void, _unix_register_digi_driver, (int id, DIGI_DRIVER *driver, int autodetect, int priority));
+   AL_FUNC(void, _unix_register_midi_driver, (int id, MIDI_DRIVER *driver, int autodetect, int priority));
+
+
+#ifdef ALLEGRO_WITH_XWINDOWS
+   AL_FUNCPTR(void, _xwin_keyboard_interrupt, (int pressed, int code));
+   AL_FUNCPTR(void, _xwin_keyboard_focused, (int focused, int state));
+   AL_FUNCPTR(void, _xwin_mouse_interrupt, (int x, int y, int z, int buttons));
+   AL_FUNCPTR(void, _xwin_timer_interrupt, (unsigned long interval));
+
+   AL_ARRAY(_DRIVER_INFO, _xwin_gfx_driver_list);
+   AL_ARRAY(_DRIVER_INFO, _xwin_keyboard_driver_list);
+   AL_ARRAY(_DRIVER_INFO, _xwin_mouse_driver_list);
+   AL_ARRAY(_DRIVER_INFO, _xwin_timer_driver_list);
+
+   AL_FUNC(void, _xwin_handle_input, (void));
+
+
+   #define XLOCK()                              \
+      do {                                      \
+         if (_unix_bg_man-&gt;multi_threaded) {    \
+            if (_xwin.display)                  \
+               XLockDisplay(_xwin.display);     \
+         }                                      \
+         _xwin.lock_count++;                    \
+      } while (0)
+
+   #define XUNLOCK()                            \
+      do {                                      \
+         if (_unix_bg_man-&gt;multi_threaded) {    \
+            if (_xwin.display)                  \
+               XUnlockDisplay(_xwin.display);   \
+         }                                      \
+         _xwin.lock_count--;                    \
+      } while (0)
+
+#endif
+
+
+#ifdef DIGI_OSS
+   /* So the setup program can read what we detected */
+   AL_VAR(int, _oss_fragsize);
+   AL_VAR(int, _oss_numfrags);
+#endif
+
+
+#ifdef ALLEGRO_LINUX
+   #include &quot;aintlnx.h&quot;
+#endif
+
+
+/* Typedef for background functions, called frequently in the background.
+ * `threaded' is nonzero if the function is being called from a thread.
+ */
+typedef void (*bg_func) (int threaded);
+
+/* Background function manager -- responsible for calling background 
+ * functions.  `int' methods return -1 on failure, 0 on success. */
+struct bg_manager
+{
+   int multi_threaded;
+   int (*init) (void);
+   void (*exit) (void);
+   int (*register_func) (bg_func f);
+   int (*unregister_func) (bg_func f);
+   void (*enable_interrupts) (void);
+   void (*disable_interrupts) (void);
+   int (*interrupts_disabled) (void);
+};	
+
+extern struct bg_manager _bg_man_pthreads;
+extern struct bg_manager _bg_man_sigalrm;
+
+extern struct bg_manager *_unix_bg_man;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ifndef AINTUNIX_H */
+

Added: trunk/msvc-libs/include/allegro/platform/aintwin.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aintwin.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aintwin.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,198 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Some definitions for internal use by the Windows library code.
+ *
+ *      By Stefan Schimanski.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef AINTWIN_H
+#define AINTWIN_H
+
+#ifndef ALLEGRO_H
+   #error must include allegro.h first
+#endif
+
+#ifndef ALLEGRO_WINDOWS
+   #error bad include
+#endif
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+#include &quot;winalleg.h&quot;
+
+#ifndef SCAN_DEPEND
+   /* workaround for buggy MinGW32 headers */
+   #ifdef ALLEGRO_MINGW32
+      #ifndef HMONITOR_DECLARED
+         #define HMONITOR_DECLARED
+      #endif
+      #if (defined _HRESULT_DEFINED) &amp;&amp; (defined WINNT)
+         #undef WINNT
+      #endif
+   #endif
+
+   #include &lt;objbase.h&gt;  /* for LPGUID */
+#endif
+
+
+/*******************************************/
+/***************** general *****************/
+/*******************************************/
+AL_VAR(HINSTANCE, allegro_inst);
+AL_VAR(HANDLE, allegro_thread);
+AL_VAR(CRITICAL_SECTION, allegro_critical_section);
+AL_VAR(int, _dx_ver);
+
+#define _enter_critical()  EnterCriticalSection(&amp;allegro_critical_section)
+#define _exit_critical()   LeaveCriticalSection(&amp;allegro_critical_section)
+
+
+AL_FUNC(int, init_directx_window, (void));
+AL_FUNC(void, exit_directx_window, (void));
+AL_FUNC(int, wnd_call_proc, (AL_METHOD(int, proc, (void))));
+AL_FUNC(int, get_dx_ver, (void));
+AL_FUNC(void, set_sync_timer_freq, (int freq));
+AL_FUNC(int, adjust_window, (int w, int h));
+AL_FUNC(void, restore_window_style, (void));
+AL_FUNC(void, save_window_pos, (void));
+
+
+/* main window */
+#define WND_TITLE_SIZE  128
+
+AL_VAR(HWND, allegro_wnd);
+AL_ARRAY(char, wnd_title);
+AL_VAR(int, wnd_x);
+AL_VAR(int, wnd_y);
+AL_VAR(int, wnd_width);
+AL_VAR(int, wnd_height);
+AL_VAR(int, wnd_sysmenu);
+
+AL_FUNCPTR(void, user_close_proc, (void));
+
+
+/* gfx synchronization */
+AL_VAR(CRITICAL_SECTION, gfx_crit_sect);
+AL_VAR(int, gfx_crit_sect_nesting);
+
+#define _enter_gfx_critical()  EnterCriticalSection(&amp;gfx_crit_sect); \
+                               gfx_crit_sect_nesting++
+#define _exit_gfx_critical()   LeaveCriticalSection(&amp;gfx_crit_sect); \
+                               gfx_crit_sect_nesting--
+#define GFX_CRITICAL_RELEASED  (!gfx_crit_sect_nesting)
+
+AL_FUNC(void, gfx_directx_restore, (void));
+
+
+/* focus switch routines */
+AL_VAR(BOOL, app_foreground);
+AL_VAR(HANDLE, _foreground_event);
+
+AL_FUNC(void, sys_directx_display_switch_init, (void));
+AL_FUNC(void, sys_directx_display_switch_exit, (void));
+AL_FUNC(int, sys_directx_set_display_switch_mode, (int mode));
+AL_FUNC(int, sys_directx_set_display_switch_callback, (int dir, AL_METHOD(void, cb, (void))));
+AL_FUNC(void, sys_directx_remove_display_switch_callback, (AL_METHOD(void, cb, (void))));
+
+AL_FUNC(void, sys_switch_in, (void));
+
+AL_FUNC(void, sys_switch_out, (void));
+AL_FUNC(int, thread_switch_out, (void));
+AL_FUNC(void, midi_switch_out, (void));
+
+AL_FUNC(void, sys_directx_switch_out_callback, (void));
+AL_FUNC(void, sys_directx_switch_in_callback, (void));
+
+
+
+/*******************************************/
+/************** keyboard routines **********/
+/*******************************************/
+AL_VAR(HANDLE, key_thread);
+AL_FUNC(int, key_dinput_acquire, (void));
+AL_FUNC(int, key_dinput_unacquire, (void));
+AL_FUNC(void, wnd_acquire_keyboard, (void));
+AL_FUNC(void, wnd_unacquire_keyboard, (void));
+
+
+
+/*******************************************/
+/************** mouse routines *************/
+/*******************************************/
+AL_VAR(HANDLE, mouse_thread);
+AL_FUNC(int, mouse_dinput_acquire, (void));
+AL_FUNC(int, mouse_dinput_unacquire, (void));
+AL_FUNC(int, mouse_set_syscursor, (int state));
+AL_FUNC(int, mouse_set_sysmenu, (int state));
+AL_FUNC(void, wnd_acquire_mouse, (void));
+AL_FUNC(void, wnd_unacquire_mouse, (void));
+AL_FUNC(void, wnd_set_syscursor, (int state));
+
+
+
+/*******************************************/
+/************* thread routines *************/
+/*******************************************/
+AL_FUNC(void, win_init_thread, (void));
+AL_FUNC(void, win_exit_thread, (void));
+
+
+
+/******************************************/
+/************* sound routines *************/
+/******************************************/
+AL_FUNC(_DRIVER_INFO *, _get_win_digi_driver_list, (void));
+AL_FUNC(_DRIVER_INFO *, _get_win_midi_driver_list, (void));
+
+AL_FUNC(void, _free_win_digi_driver_list, (void));
+AL_FUNC(void, _free_win_midi_driver_list, (void));
+
+AL_FUNC(DIGI_DRIVER *, _get_dsalmix_driver, (char *name, LPGUID guid, int num));
+AL_FUNC(DIGI_DRIVER *, _get_woalmix_driver, (int num));
+
+AL_FUNC(int, digi_directsound_capture_init, (LPGUID guid));
+AL_FUNC(void, digi_directsound_capture_exit, (void));
+AL_FUNC(int, digi_directsound_capture_detect, (LPGUID guid));
+AL_FUNC(int, digi_directsound_rec_cap_rate, (int bits, int stereo));
+AL_FUNC(int, digi_directsound_rec_cap_param, (int rate, int bits, int stereo));
+AL_FUNC(int, digi_directsound_rec_source, (int source));
+AL_FUNC(int, digi_directsound_rec_start, (int rate, int bits, int stereo));
+AL_FUNC(void, digi_directsound_rec_stop, (void));
+AL_FUNC(int, digi_directsound_rec_read, (void *buf));
+
+
+
+/*******************************************/
+/************* error handling **************/
+/*******************************************/
+AL_FUNC(char* , win_err_str, (long err));
+AL_FUNC(void, thread_safe_trace, (char *msg, ...));
+
+#if DEBUGMODE &gt;= 2
+   #define _TRACE                 thread_safe_trace
+#else
+   #define _TRACE                 1 ? (void) 0 : thread_safe_trace
+#endif
+
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef AINTWIN_H */
+

Added: trunk/msvc-libs/include/allegro/platform/al386gcc.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/al386gcc.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/al386gcc.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,402 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Inline functions (gcc style 386 asm).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#if (!defined ALLEGRO_GCC) || (!defined ALLEGRO_I386)
+   #error bad include
+#endif
+
+#ifdef ALLEGRO_IMPORT_GFX_ASM
+
+/* _default_ds:
+ *  Return a copy of the current %ds selector.
+ */
+AL_INLINE(int, _default_ds, (void),
+{
+   short result;
+
+   __asm__ (
+      &quot;  movw %%ds, %0 &quot;
+
+   : &quot;=r&quot; (result)
+   );
+
+   return result;
+})
+
+
+
+/* bmp_write_line:
+ *  Bank switch function.
+ */
+AL_INLINE(unsigned long, bmp_write_line, (BITMAP *bmp, int line),
+{
+   unsigned long result;
+
+   __asm__ volatile (
+      &quot;  call *%3 &quot;
+
+   : &quot;=a&quot; (result)                     /* result in eax */
+
+   : &quot;d&quot; (bmp),                        /* bitmap in edx */
+     &quot;0&quot; (line),                       /* line number in eax */
+     &quot;r&quot; (bmp-&gt;write_bank)             /* the bank switch routine */
+   );
+
+   return result;
+})
+
+
+
+/* bmp_read_line:
+ *  Bank switch function.
+ */
+AL_INLINE(unsigned long, bmp_read_line, (BITMAP *bmp, int line),
+{
+   unsigned long result;
+
+   __asm__ volatile (
+      &quot;  call *%3 &quot;
+
+   : &quot;=a&quot; (result)                     /* result in eax */
+
+   : &quot;d&quot; (bmp),                        /* bitmap in edx */
+     &quot;0&quot; (line),                       /* line number in eax */
+     &quot;r&quot; (bmp-&gt;read_bank)              /* the bank switch routine */
+   );
+
+   return result;
+})
+
+
+
+/* bmp_unwrite_line:
+ *  Terminate bank switch function.
+ */
+AL_INLINE(void, bmp_unwrite_line, (BITMAP *bmp),
+{
+   __asm__ volatile (
+      &quot;  call *%1 &quot;
+   :
+   : &quot;d&quot; (bmp),                        /* bitmap in edx */
+     &quot;r&quot; (bmp-&gt;vtable-&gt;unwrite_bank)   /* the bank switch routine */
+   );
+})
+
+#endif /* ALLEGRO_IMPORT_GFX_ASM */
+
+
+#ifdef ALLEGRO_IMPORT_MATH_ASM
+
+/* Helper macro that makes the compiler reduce fixadd(), fixsub(), fixmul() and
+   fixdiv() calls to a single constant if both operands are constant. Since
+   this doesn't work unless we compile with optimization, it's better to skip
+   the test then. */
+#if (defined __OPTIMIZE__) &amp;&amp; ((__GNUC__ &gt; 2) || ((__GNUC__ == 2) &amp;&amp; (__GNUC_MINOR__ &gt;= 95)))
+   #define __PRECALCULATE_CONSTANTS(calc)                                  \
+      if(__builtin_constant_p(x) &amp;&amp; __builtin_constant_p(y)) {             \
+	 if((calc) &gt; (double)0x7FFFFFFF) {                                 \
+	    *allegro_errno = ERANGE;                                       \
+	    return 0x7FFFFFFF;                                             \
+	 }                                                                 \
+	 else if(-(calc) &gt; (double)0x7FFFFFFF) {                           \
+	    *allegro_errno = ERANGE;                                       \
+	    return -0x7FFFFFFF;                                            \
+	 }                                                                 \
+	 else                                                              \
+	    return (fixed)(calc);                                          \
+      }                                                                    \
+      else
+#else
+   #define __PRECALCULATE_CONSTANTS(calc)
+#endif
+
+
+
+/* fixadd:
+ *  Fixed point (16.16) addition.
+ */
+AL_INLINE(fixed, fixadd, (fixed x, fixed y),
+{
+   fixed result;
+
+   __PRECALCULATE_CONSTANTS(x + (double)y)
+   {
+      __asm__ (
+	 &quot;  addl %2, %0 ; &quot;               /* do the addition */
+	 &quot;  jno 0f ; &quot;                    /* check for overflow */
+
+	 &quot;  movl %4, %0 ; &quot;               /* on overflow, set errno */
+	 &quot;  movl %3, (%0) ; &quot;
+	 &quot;  movl $0x7FFFFFFF, %0 ; &quot;      /* and return MAXINT */
+	 &quot;  cmpl $0, %2 ; &quot;
+	 &quot;  jg 0f ; &quot;
+	 &quot;  negl %0 ; &quot;
+
+	 &quot; 0: &quot;                           /* finished */
+
+      : &quot;=r&quot; (result)                     /* result in a register */
+
+      : &quot;0&quot; (x),                          /* x in the output register */
+	&quot;rm&quot; (y),                         /* y can go in register or memory */
+	&quot;i&quot; (ERANGE),
+	&quot;m&quot; (allegro_errno)
+
+      : &quot;%cc&quot;, &quot;memory&quot;                   /* clobbers flags and errno */
+      );
+
+      return result;
+   }
+})
+
+
+
+/* fixsub:
+ *  Fixed point (16.16) subtraction.
+ */
+AL_INLINE(fixed, fixsub, (fixed x, fixed y),
+{
+   fixed result;
+
+   __PRECALCULATE_CONSTANTS(x - (double)y)
+   {
+      __asm__ (
+	 &quot;  subl %2, %0 ; &quot;               /* do the subtraction */
+	 &quot;  jno 0f ; &quot;                    /* check for overflow */
+
+	 &quot;  movl %4, %0 ; &quot;               /* on overflow, set errno */
+	 &quot;  movl %3, (%0) ; &quot;
+	 &quot;  movl $0x7FFFFFFF, %0 ; &quot;      /* and return MAXINT */
+	 &quot;  cmpl $0, %2 ; &quot;
+	 &quot;  jl 0f ; &quot;
+	 &quot;  negl %0 ; &quot;
+
+	 &quot; 0: &quot;                           /* finished */
+
+      : &quot;=r&quot; (result)                     /* result in a register */
+
+      : &quot;0&quot; (x),                          /* x in the output register */
+	&quot;rm&quot; (y),                         /* y can go in register or memory */
+	&quot;i&quot; (ERANGE),
+	&quot;m&quot; (allegro_errno)
+
+      : &quot;%cc&quot;, &quot;memory&quot;                   /* clobbers flags and errno */
+      );
+
+      return result;
+   }
+})
+
+
+
+/* fixmul:
+ *  Fixed point (16.16) multiplication.
+ */
+AL_INLINE(fixed, fixmul, (fixed x, fixed y),
+{
+   fixed edx __attribute__ ((__unused__));
+   fixed result;
+
+   __PRECALCULATE_CONSTANTS(x / 65536.0 * y)
+   {
+      __asm__ (
+	 &quot;  movl %2, %%eax ; &quot;
+	 &quot;  imull %3 ; &quot;                  /* do the multiply */
+	 &quot;  shrdl $16, %%edx, %%eax ; &quot;
+
+	 &quot;  sarl $15, %%edx ; &quot;           /* check for overflow */
+	 &quot;  jz 0f ; &quot;
+	 &quot;  cmpl $-1, %%edx ; &quot;
+	 &quot;  je 0f ; &quot;
+
+	 &quot;  movl %5, %%eax ; &quot;            /* on overflow, set errno */
+	 &quot;  movl %4, (%%eax) ; &quot;
+	 &quot;  movl $0x7FFFFFFF, %%eax ; &quot;   /* and return MAXINT */
+	 &quot;  cmpl $0, %2 ; &quot;
+	 &quot;  jge 1f ; &quot;
+	 &quot;  negl %%eax ; &quot;
+	 &quot; 1: &quot;
+	 &quot;  cmpl $0, %3 ; &quot;
+	 &quot;  jge 0f ; &quot;
+	 &quot;  negl %%eax ; &quot;
+
+	 &quot;  .balign 4, 0x90 ; &quot;
+
+	 &quot; 0: &quot;                           /* finished */
+
+      : &quot;=&amp;a&quot; (result),                   /* the result has to go in eax */
+	&quot;=&amp;d&quot; (edx)                       /* reliably reserve edx */
+
+      : &quot;mr&quot; (x),                         /* x and y can be regs or mem */
+	&quot;mr&quot; (y),
+	&quot;i&quot; (ERANGE),
+	&quot;m&quot; (allegro_errno)
+
+      : &quot;%cc&quot;, &quot;memory&quot;                   /* clobbers flags and errno */
+      );
+
+      return result;
+   }
+})
+
+
+
+/* fixdiv:
+ *  Fixed point (16.16) division.
+ */
+AL_INLINE(fixed, fixdiv, (fixed x, fixed y),
+{
+   fixed edx __attribute__ ((__unused__));
+   fixed reg __attribute__ ((__unused__));
+   fixed result;
+
+   __PRECALCULATE_CONSTANTS(x * 65536.0 / y)
+   {
+      __asm__ (
+	 &quot;  testl %%eax, %%eax ; &quot;        /* test sign of x */
+	 &quot;  js 3f ; &quot;
+
+	 &quot;  testl %2, %2 ; &quot;              /* test sign of y */
+	 &quot;  jns 4f ; &quot;
+	 &quot;  negl %2 ; &quot;
+
+	 &quot; 0: &quot;                           /* result will be negative */
+	 &quot;  movl %%eax, %%edx ; &quot;         /* check the range is ok */
+	 &quot;  shrl $16, %%edx ; &quot;
+	 &quot;  shll $16, %%eax ; &quot;
+	 &quot;  cmpl %2, %%edx ; &quot;
+	 &quot;  jae 1f ; &quot;
+
+	 &quot;  divl %2 ; &quot;                   /* do the divide */
+	 &quot;  testl %%eax, %%eax ; &quot;
+	 &quot;  jns 2f ; &quot;
+
+	 &quot; 1: &quot;
+	 &quot;  movl %6, %%eax ; &quot;            /* on overflow, set errno */
+	 &quot;  movl %5, (%%eax) ; &quot;
+	 &quot;  movl $0x7FFFFFFF, %%eax ; &quot;   /* and return MAXINT */
+
+	 &quot; 2: &quot;
+	 &quot;  negl %%eax ; &quot;                /* fix up the sign of the result */
+	 &quot;  jmp 6f ; &quot;
+
+	 &quot;  .balign 4, 0x90 ; &quot;
+
+	 &quot; 3: &quot;                           /* x is negative */
+	 &quot;  negl %%eax ; &quot;
+	 &quot;  testl %2, %2 ; &quot;              /* test sign of y */
+	 &quot;  jns 0b ; &quot;
+	 &quot;  negl %2 ; &quot;
+
+	 &quot; 4: &quot;                           /* result will be positive */
+	 &quot;  movl %%eax, %%edx ; &quot;         /* check the range is ok */
+	 &quot;  shrl $16, %%edx ; &quot;
+	 &quot;  shll $16, %%eax ; &quot;
+	 &quot;  cmpl %2, %%edx ; &quot;
+	 &quot;  jae 5f ; &quot;
+
+	 &quot;  divl %2 ; &quot;                   /* do the divide */
+	 &quot;  testl %%eax, %%eax ; &quot;
+	 &quot;  jns 6f ; &quot;
+
+	 &quot; 5: &quot;
+	 &quot;  movl %6, %%eax ; &quot;            /* on overflow, set errno */
+	 &quot;  movl %5, (%%eax) ; &quot;
+	 &quot;  movl $0x7FFFFFFF, %%eax ; &quot;   /* and return MAXINT */
+
+	 &quot; 6: &quot;                           /* finished */
+
+      : &quot;=a&quot; (result),                    /* the result has to go in eax */
+	&quot;=&amp;d&quot; (edx),                      /* reliably reserve edx */
+	&quot;=r&quot; (reg)                        /* input operand will be clobbered */
+
+      : &quot;0&quot; (x),                          /* x in eax */
+	&quot;2&quot; (y),                          /* y in register */
+	&quot;i&quot; (ERANGE),
+	&quot;m&quot; (allegro_errno)
+
+      : &quot;%cc&quot;, &quot;memory&quot;                   /* clobbers flags and memory  */
+      );
+
+      return result;
+   }
+})
+
+
+
+/* fixfloor:
+ * Fixed point version of floor().
+ * Note that it returns an integer result (not a fixed one)
+ */
+AL_INLINE(int, fixfloor, (fixed x),
+{
+   int result;
+
+   __asm__ (
+      &quot; sarl $16, %0 &quot;		/* convert to int */
+
+    : &quot;=r&quot; (result)		/* result in a register */
+
+    : &quot;0&quot; (x) 			/* x in the output register */
+   );
+
+   return result;
+})
+
+
+
+/* fixceil:
+ * Fixed point version of ceil().
+ * Note that it returns an integer result (not a fixed one)
+ */
+AL_INLINE(int, fixceil, (fixed x),
+{
+   int result;
+
+   __asm__ (
+      &quot; addl $0xFFFF, %0 ;&quot;	/* ceil () */
+      &quot; jns 0f ;&quot;
+      &quot; jo 1f ;&quot;
+
+      &quot;0:&quot;
+      &quot; sarl $16, %0 ;&quot;		/* convert to int */
+      &quot; jmp 2f ;&quot;
+
+      &quot;1:&quot;
+      &quot; movl %3, %0 ;&quot;		/* on overflow, set errno */
+      &quot; movl %2, (%0) ;&quot;
+      &quot; movl $0x7FFF, %0 ;&quot;	/* and return large int */
+
+      &quot;2:&quot;
+    : &quot;=r&quot; (result)		/* result in a register */
+
+    : &quot;0&quot; (x),			/* x in the output register */
+      &quot;i&quot; (ERANGE),
+      &quot;m&quot; (allegro_errno)
+
+    : &quot;%cc&quot;, &quot;memory&quot;		/* clobbers flags and errno */
+   );
+
+   return result;
+})
+
+
+
+#undef __PRECALCULATE_CONSTANTS
+
+#endif /* ALLEGRO_IMPORT_MATH_ASM */
+

Added: trunk/msvc-libs/include/allegro/platform/al386vc.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/al386vc.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/al386vc.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,269 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Inline functions (MSVC style 386 asm).
+ *
+ *      By Stefan Schimanski.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#if (!defined ALLEGRO_MSVC) || (!defined ALLEGRO_I386)
+   #error bad include
+#endif
+
+
+#pragma warning (disable: 4035)
+
+
+#ifdef ALLEGRO_IMPORT_GFX_ASM
+
+/* _default_ds:
+ *  Return a copy of the current %ds selector.
+ */
+INLINE _AL_DLL int _default_ds(void)
+{
+   _asm {
+      mov eax, 0
+      mov ax, ds
+   }
+}
+
+END_OF_INLINE(_default_ds);
+
+
+
+/* bmp_write_line:
+ *  Bank switch function.
+ */
+INLINE _AL_DLL unsigned long bmp_write_line(BITMAP *bmp, int line)
+{ 
+   _asm { 
+      mov edx, bmp
+      mov ecx, [edx]BITMAP.write_bank
+      mov eax, line
+      call ecx
+   }
+}
+
+END_OF_INLINE(bmp_write_line);
+
+
+
+/* bmp_read_line:
+ *  Bank switch function.
+ */
+INLINE _AL_DLL unsigned long bmp_read_line(BITMAP *bmp, int line)
+{
+   _asm {
+      mov edx, bmp
+      mov ecx, [edx]BITMAP.read_bank
+      mov eax, line
+      call ecx
+   }
+}
+
+END_OF_INLINE(bmp_read_line);
+
+
+
+/* bmp_unwrite_line:
+ *  Terminate bank switch function.
+ */
+INLINE _AL_DLL void bmp_unwrite_line(BITMAP *bmp)
+{
+   _asm {
+      mov edx, bmp
+      mov ecx, [edx]BITMAP.vtable
+      mov ecx, [ecx]GFX_VTABLE.unwrite_bank
+      call ecx
+   }
+}
+
+END_OF_INLINE(bmp_unwrite_line);
+
+
+#endif /* ALLEGRO_IMPORT_GFX_ASM */
+
+
+#ifdef ALLEGRO_IMPORT_MATH_ASM
+
+/* _set_errno_erange:
+ */
+INLINE void _set_errno_erange(void)
+{
+   *allegro_errno = ERANGE;
+}
+
+END_OF_INLINE(_set_errno_erange);
+
+
+
+/* fixadd:
+ *  Fixed point (16.16) addition.
+ */
+INLINE _AL_DLL fixed fixadd(fixed x, fixed y)
+{
+   _asm {
+      mov eax, x
+      add eax, y
+      jno Out1
+      call _set_errno_erange
+      mov eax, 0x7FFFFFFF
+      cmp y, 0
+      jg Out1
+      neg eax
+   Out1:
+   }
+}
+
+END_OF_INLINE(fixadd);
+
+
+
+/* fixsub:
+ *  Fixed point (16.16) subtraction.
+ */
+INLINE _AL_DLL fixed fixsub(fixed x, fixed y)
+{
+   _asm {
+      mov eax, x
+      sub eax, y
+      jno Out1
+      call _set_errno_erange
+      mov eax, 0x7FFFFFFF
+      cmp y, 0
+      jl Out1
+      neg eax
+   Out1:
+   }
+}
+
+END_OF_INLINE(fixsub);
+
+
+
+/* fixmul:
+ *  Fixed point (16.16) multiplication.
+ */
+INLINE _AL_DLL fixed fixmul(fixed x, fixed y)
+{
+   _asm {
+      mov eax, x
+      imul y
+      shrd eax, edx, 16
+      sar edx, 15
+      jz Out2
+      cmp edx, -1
+      jz Out2
+      call _set_errno_erange
+      mov eax, 0x7FFFFFFF
+      cmp x, 0
+      jge Out1
+      neg eax
+   Out1:
+      cmp y, 0
+      jge Out2
+      neg eax
+   Out2:
+   }
+}
+
+END_OF_INLINE(fixmul);
+
+
+
+/* fixdiv:
+ *  Fixed point (16.16) division.
+ */
+INLINE _AL_DLL fixed fixdiv(fixed x, fixed y)
+{
+   _asm {
+      mov ecx, y
+      xor ebx, ebx
+      mov eax, x
+      or eax, eax
+      jns Out1
+      neg eax
+      inc ebx
+   Out1:
+      or ecx, ecx
+      jns Out2
+      neg ecx
+      inc ebx
+   Out2:
+      mov edx, eax
+      shr edx, 0x10
+      shl eax, 0x10
+      cmp edx, ecx
+      jae Out3
+      div ecx
+      or eax, eax
+      jns Out4
+   Out3:
+      call _set_errno_erange
+      mov eax, 0x7FFFFFFF
+   Out4:
+      test ebx, 1
+      je Out5
+      neg eax
+   Out5:
+   }
+}
+
+END_OF_INLINE(fixdiv);
+
+
+
+/* fixfloor :
+ * Fixed point version of floor().
+ * Note that it returns an integer result (not a fixed one)
+ */
+INLINE _AL_DLL int fixfloor(fixed x)
+{
+   _asm {
+      mov eax, x
+      sar eax, 0x10
+   }
+}
+
+END_OF_INLINE(fixfloor);
+
+
+
+/* fixceil:
+ *  Fixed point version of ceil().
+ *  Note that it returns an integer result (not a fixed one)
+ */
+INLINE _AL_DLL int fixceil(fixed x)
+{
+   _asm {
+      mov eax, x
+      add eax, 0xFFFF
+      jns Out1
+      jo  Out2
+   Out1:
+      sar eax, 0x10
+      jmp Out3
+   Out2:
+      call _set_errno_erange
+      mov eax, 0x7FFF
+   Out3:
+   }
+}
+
+END_OF_INLINE(fixceil);
+
+#endif /* ALLEGRO_IMPORT_MATH_ASM */
+
+
+#pragma warning (default: 4035)
+

Added: trunk/msvc-libs/include/allegro/platform/al386wat.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/al386wat.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/al386wat.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,241 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Inline functions (Watcom style 386 asm).
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#if (!defined ALLEGRO_WATCOM) || (!defined ALLEGRO_I386)
+   #error bad include
+#endif
+
+
+#ifdef ALLEGRO_IMPORT_GFX_ASM
+
+/* _default_ds:
+ *  Return a copy of the current %ds selector.
+ */
+int _default_ds(void);
+
+#pragma aux _default_ds =     \
+   &quot; mov eax, 0 &quot;             \
+   &quot; mov ax, ds &quot;             \
+			      \
+   value [eax];
+
+
+
+/* _my_cs:
+ *  Return a copy of the current %cs selector.
+ */
+int _my_cs(void);
+
+#pragma aux _my_cs =          \
+   &quot; mov eax, 0 &quot;             \
+   &quot; mov ax, cs &quot;             \
+			      \
+   value [eax];
+
+
+
+/* bmp_write_line/bmp_read_line:
+ *  Bank switch functions.
+ */
+unsigned long _bmp_bank_switcher(BITMAP *bmp, int line, void *bank_switch);
+
+#pragma aux _bmp_bank_switcher =    \
+   &quot; call ecx &quot;                     \
+				    \
+   parm [edx] [eax] [ecx]           \
+   value [eax];
+
+#define bmp_write_line(bmp, line)   _bmp_bank_switcher(bmp, line, (void *)bmp-&gt;write_bank)
+#define bmp_read_line(bmp, line)    _bmp_bank_switcher(bmp, line, (void *)bmp-&gt;read_bank)
+
+
+
+/* bmp_unwrite_line:
+ *  Terminate bank switch function.
+ */
+void _bmp_unbank_switcher(BITMAP *bmp, void *bank_unswitcher);
+
+#pragma aux _bmp_unbank_switcher =  \
+   &quot; call ecx &quot;                     \
+				    \
+   parm [edx] [ecx];
+
+#define bmp_unwrite_line(bmp)       _bmp_unbank_switcher(bmp, (void *)bmp-&gt;vtable-&gt;unwrite_bank)
+
+#endif /* ALLEGRO_IMPORT_GFX_ASM */
+
+
+#ifdef ALLEGRO_IMPORT_MATH_ASM
+
+/* _set_errno_erange:
+ *  Watcom's asm syntax doesn't provide any nice way to do this inline...
+ */
+AL_INLINE(void, _set_errno_erange, (void),
+{
+   *allegro_errno = ERANGE;
+})
+
+
+
+/* fixadd:
+ *  Fixed point (16.16) addition.
+ */
+fixed fixadd(fixed x, fixed y);
+
+#pragma aux fixadd =             \
+   &quot;  add eax, edx &quot;             \
+   &quot;  jno Out1 &quot;                 \
+   &quot;  call _set_errno_erange &quot;   \
+   &quot;  mov eax, 0x7FFFFFFF &quot;      \
+   &quot;  cmp edx, 0 &quot;               \
+   &quot;  jg Out1 &quot;                  \
+   &quot;  neg eax &quot;                  \
+   &quot; Out1: &quot;                     \
+				 \
+   parm [eax] [edx]              \
+   value [eax];
+
+
+
+/* fixsub:
+ *  Fixed point (16.16) subtraction.
+ */
+fixed fixsub(fixed x, fixed y);
+
+#pragma aux fixsub =             \
+   &quot;  sub eax, edx &quot;             \
+   &quot;  jno Out1 &quot;                 \
+   &quot;  call _set_errno_erange &quot;   \
+   &quot;  mov eax, 0x7FFFFFFF &quot;      \
+   &quot;  cmp edx, 0 &quot;               \
+   &quot;  jl Out1 &quot;                  \
+   &quot;  neg eax &quot;                  \
+   &quot; Out1: &quot;                     \
+				 \
+   parm [eax] [edx]              \
+   value [eax];
+
+
+
+/* fixmul:
+ *  Fixed point (16.16) multiplication.
+ */
+fixed fixmul(fixed x, fixed y);
+
+#pragma aux fixmul =             \
+   &quot;  mov eax, ebx &quot;             \
+   &quot;  imul ecx &quot;                 \
+   &quot;  shrd eax, edx, 16 &quot;        \
+   &quot;  sar edx, 15 &quot;              \
+   &quot;  jz Out2 &quot;                  \
+   &quot;  cmp edx, -1 &quot;              \
+   &quot;  jz Out2 &quot;                  \
+   &quot;  call _set_errno_erange &quot;   \
+   &quot;  mov eax, 0x7FFFFFFF &quot;      \
+   &quot;  cmp ebx, 0 &quot;               \
+   &quot;  jge Out1 &quot;                 \
+   &quot;  neg eax &quot;                  \
+   &quot; Out1: &quot;                     \
+   &quot;  cmp ecx, 0 &quot;               \
+   &quot;  jge Out2 &quot;                 \
+   &quot;  neg eax &quot;                  \
+   &quot; Out2: &quot;                     \
+				 \
+   parm [ebx] [ecx]              \
+   modify [edx]                  \
+   value [eax];
+
+
+
+/* fixdiv:
+ *  Fixed point (16.16) division.
+ */
+fixed fixdiv(fixed x, fixed y);
+
+#pragma aux fixdiv =             \
+   &quot;  xor ebx, ebx &quot;             \
+   &quot;  or eax, eax &quot;              \
+   &quot;  jns Out1 &quot;                 \
+   &quot;  neg eax &quot;                  \
+   &quot;  inc ebx &quot;                  \
+   &quot; Out1: &quot;                     \
+   &quot;  or ecx, ecx &quot;              \
+   &quot;  jns Out2 &quot;                 \
+   &quot;  neg ecx &quot;                  \
+   &quot;  inc ebx &quot;                  \
+   &quot; Out2: &quot;                     \
+   &quot;  mov edx, eax &quot;             \
+   &quot;  shr edx, 0x10 &quot;            \
+   &quot;  shl eax, 0x10 &quot;            \
+   &quot;  cmp edx, ecx &quot;             \
+   &quot;  jae Out3 &quot;                 \
+   &quot;  div ecx &quot;                  \
+   &quot;  or eax, eax &quot;              \
+   &quot;  jns Out4 &quot;                 \
+   &quot; Out3: &quot;                     \
+   &quot;  call _set_errno_erange &quot;   \
+   &quot;  mov eax, 0x7FFFFFFF &quot;      \
+   &quot; Out4: &quot;                     \
+   &quot;  test ebx, 1 &quot;              \
+   &quot;  je Out5 &quot;                  \
+   &quot;  neg eax &quot;                  \
+   &quot; Out5: &quot;                     \
+				 \
+   parm [eax] [ecx]              \
+   modify [ebx edx]              \
+   value [eax];
+
+
+
+/* fixfloor :
+ * Fixed point version of floor().
+ * Note that it returns an integer result (not a fixed one)
+ */
+int fixfloor(fixed x);
+
+#pragma aux fixfloor =           \
+   &quot;  sar eax, 0x10 &quot;		 \
+				 \
+   parm [eax]			 \
+   value [eax];
+
+
+
+/* fixceil :
+ * Fixed point version of ceil().
+ * Note that it returns an integer result (not a fixed one)
+ */
+int fixceil(fixed x);
+
+#pragma aux fixceil =            \
+   &quot;  add eax, 0xFFFF &quot;		 \
+   &quot;  jns Out1 &quot;		 \
+   &quot;  jo  Out2 &quot;		 \
+   &quot; Out1: &quot;			 \
+   &quot;  sar eax, 0x10 &quot;		 \
+   &quot;  jmp Out3 &quot;		 \
+   &quot; Out2: &quot;			 \
+   &quot;  call _set_errno_erange &quot;	 \
+   &quot;  mov eax, 0x7FFF &quot;		 \
+   &quot; Out3: &quot;			 \
+				 \
+   parm [eax]			 \
+   value [eax];
+
+#endif /* ALLEGRO_IMPORT_MATH_ASM */
+

Added: trunk/msvc-libs/include/allegro/platform/albcc32.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/albcc32.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/albcc32.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,81 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with Borland C++Builder.
+ *
+ *      By Greg Hackmann.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifdef ALLEGRO_SRC
+   #error Currently BCC32 cannot build the library
+#endif
+
+#ifndef SCAN_DEPEND
+   #include &lt;io.h&gt;
+   #include &lt;fcntl.h&gt;
+   #include &lt;direct.h&gt;
+   #include &lt;malloc.h&gt;
+#endif
+
+
+#pragma warn -8004  /* unused assigned value         */
+#pragma warn -8008  /* condition always met          */
+#pragma warn -8027  /* inline functions not expanded */
+#pragma warn -8057  /* unused parameter              */
+#pragma warn -8066  /* unreachable code              */
+
+
+/* describe this platform */
+#define ALLEGRO_PLATFORM_STR  &quot;BCC32&quot;
+#define ALLEGRO_WINDOWS
+#define ALLEGRO_I386
+#define ALLEGRO_LITTLE_ENDIAN
+
+#ifdef USE_CONSOLE
+   #define ALLEGRO_CONSOLE_OK
+   #define ALLEGRO_NO_MAGIC_MAIN
+#endif
+
+
+/* describe how function prototypes look to BCC32 */
+#if (defined ALLEGRO_STATICLINK) || (defined ALLEGRO_SRC)
+   #define _AL_DLL
+#else
+   #define _AL_DLL   __declspec(dllimport)
+#endif
+
+#define AL_VAR(type, name)             extern _AL_DLL type name
+#define AL_ARRAY(type, name)           extern _AL_DLL type name[]
+#define AL_FUNC(type, name, args)      _AL_DLL type __cdecl name args
+#define AL_METHOD(type, name, args)    type (__cdecl *name) args
+#define AL_FUNCPTR(type, name, args)   extern _AL_DLL type (__cdecl *name) args
+
+
+#define END_OF_INLINE(name)
+#define AL_INLINE(type, name, args, code)    extern __inline type __cdecl name args code END_OF_INLINE(name)
+
+#define INLINE       __inline
+
+#define LONG_LONG    __int64
+
+#define AL_CONST     const
+
+/* windows specific defines */
+#ifdef NONAMELESSUNION
+   #undef NONAMELESSUNION
+#endif
+/* This fixes 99.999999% of Borland C++Builder's problems with structs. */
+
+/* arrange for other headers to be included later on */
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/alwin.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintwin.h&quot;

Added: trunk/msvc-libs/include/allegro/platform/albecfg.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/albecfg.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/albecfg.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,42 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with BeOS.
+ *
+ *      By Jason Wilkins.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+
+/* provide implementations of missing functions */
+#define ALLEGRO_NO_STRICMP
+#define ALLEGRO_NO_STRLWR
+#define ALLEGRO_NO_STRUPR
+
+/* a static auto config */
+#define HAVE_DIRENT_H
+#define HAVE_SYS_DIR_H
+#define HAVE_SYS_TIME_H
+#define TIME_WITH_SYS_TIME
+
+/* describe this platform */
+#define ALLEGRO_PLATFORM_STR  &quot;BeOS&quot;
+#define ALLEGRO_LITTLE_ENDIAN
+#define ALLEGRO_CONSOLE_OK
+#define ALLEGRO_USE_CONSTRUCTOR
+
+/* arrange for other headers to be included later on */
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/albeos.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintbeos.h&quot;
+#define ALLEGRO_ASMCAPA_HEADER   &quot;obj/beos/asmcapa.h&quot;

Added: trunk/msvc-libs/include/allegro/platform/albeos.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/albeos.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/albeos.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,78 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      BeOS specific definitions header file.
+ *
+ *      By Jason Wilkins.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+/* system driver */
+#define SYSTEM_BEOS           AL_ID('B','S','Y','S')
+AL_VAR(SYSTEM_DRIVER, system_beos);
+
+/* timer driver */
+#define TIMER_BEOS            AL_ID('B','T','I','M')
+AL_VAR(TIMER_DRIVER, timer_beos);
+
+/* keyboard driver */
+#define KEYBOARD_BEOS         AL_ID('B','K','E','Y')
+AL_VAR(KEYBOARD_DRIVER, keyboard_beos);
+
+/* mouse driver */
+#define MOUSE_BEOS            AL_ID('B','M','O','U')
+AL_VAR(MOUSE_DRIVER, mouse_beos);
+
+/* joystick driver */
+#define JOYSTICK_BEOS         AL_ID('B','J','O','Y')
+AL_VAR(JOYSTICK_DRIVER, joystick_beos);
+
+/* graphics drivers */
+#define GFX_BEOS                 AL_ID('B','F','S',' ')
+
+#define GFX_BEOS_FULLSCREEN      AL_ID('B','F','S',' ')
+#define GFX_BEOS_FULLSCREEN_SAFE AL_ID('B','F','S','S')
+AL_VAR(GFX_DRIVER, gfx_beos_fullscreen);
+AL_VAR(GFX_DRIVER, gfx_beos_fullscreen_safe);
+
+#define GFX_BEOS_WINDOWED        AL_ID('B','W','N',' ')
+#define GFX_BEOS_WINDOWED_SAFE   AL_ID('B','W','N','S')
+AL_VAR(GFX_DRIVER, gfx_beos_windowed);
+//AL_VAR(GFX_DRIVER, gfx_beos_windowed_safe);
+
+/* digi drivers */
+#define DIGI_BEOS             AL_ID('B','D','I','G')
+AL_VAR(DIGI_DRIVER, digi_beos);
+
+/* midi drivers */
+#define MIDI_BEOS             AL_ID('B','M','I','D')
+AL_VAR(MIDI_DRIVER, midi_beos);
+
+#define GFX_DRIVER_BEOS                                                 \
+   { GFX_BEOS_FULLSCREEN,      &amp;gfx_beos_fullscreen,      TRUE },	\
+   { GFX_BEOS_FULLSCREEN_SAFE, &amp;gfx_beos_fullscreen_safe, TRUE },	\
+   { GFX_BEOS_WINDOWED,        &amp;gfx_beos_windowed,        TRUE },	\
+ /*{ GFX_BEOS_WINDOWED_SAFE,   &amp;gfx_beos_windowed_safe,   TRUE },*/
+
+#define DIGI_DRIVER_BEOS                                                \
+   {  DIGI_BEOS,       &amp;digi_beos,      TRUE  },
+   
+#define MIDI_DRIVER_BEOS                                                \
+   {  MIDI_BEOS,       &amp;midi_beos,      TRUE  },
+
+#define JOYSTICK_DRIVER_BEOS                                            \
+   {  JOYSTICK_BEOS,   &amp;joystick_beos,  TRUE  },
+
+#define GFX_SAFE_ID	GFX_BEOS
+#define GFX_SAFE_DEPTH	8
+#define GFX_SAFE_W	640
+#define GFX_SAFE_H	480

Added: trunk/msvc-libs/include/allegro/platform/aldjgpp.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aldjgpp.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aldjgpp.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,96 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with djgpp.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef SCAN_DEPEND
+   #include &lt;pc.h&gt;
+   #include &lt;dir.h&gt;
+   #include &lt;dpmi.h&gt;
+   #include &lt;go32.h&gt;
+   #include &lt;fcntl.h&gt;
+   #include &lt;unistd.h&gt;
+   #include &lt;sys/farptr.h&gt;
+#endif
+
+
+/* describe this platform */
+#define ALLEGRO_PLATFORM_STR  &quot;djgpp&quot;
+#define ALLEGRO_DOS
+#define ALLEGRO_I386
+#define ALLEGRO_LITTLE_ENDIAN
+#define ALLEGRO_CONSOLE_OK
+#define ALLEGRO_VRAM_SINGLE_SURFACE
+#define ALLEGRO_USE_CONSTRUCTOR
+
+
+/* memory locking macros */
+void _unlock_dpmi_data(void *addr, int size);
+
+#define END_OF_FUNCTION(x)          void x##_end(void) { }
+#define END_OF_STATIC_FUNCTION(x)   static void x##_end(void) { }
+#define LOCK_DATA(d, s)             _go32_dpmi_lock_data((void *)d, s)
+#define LOCK_CODE(c, s)             _go32_dpmi_lock_code((void *)c, s)
+#define UNLOCK_DATA(d,s)            _unlock_dpmi_data((void *)d, s)
+#define LOCK_VARIABLE(x)            LOCK_DATA((void *)&amp;x, sizeof(x))
+#define LOCK_FUNCTION(x)            LOCK_CODE((void *)x, (long)x##_end - (long)x)
+
+
+/* long filename status */
+#ifdef _USE_LFN
+   #define ALLEGRO_LFN  _USE_LFN
+#else
+   #define ALLEGRO_LFN  0
+#endif
+
+
+/* selector for video memory bitmaps */
+#define _video_ds()  _dos_ds
+
+
+/* helpers for talking to video memory */
+#define bmp_select(bmp)             _farsetsel((bmp)-&gt;seg)
+
+#define bmp_write8(addr, c)         _farnspokeb(addr, c)
+#define bmp_write15(addr, c)        _farnspokew(addr, c)
+#define bmp_write16(addr, c)        _farnspokew(addr, c)
+#define bmp_write32(addr, c)        _farnspokel(addr, c)
+
+#define bmp_read8(addr)             _farnspeekb(addr)
+#define bmp_read15(addr)            _farnspeekw(addr)
+#define bmp_read16(addr)            _farnspeekw(addr)
+#define bmp_read32(addr)            _farnspeekl(addr)
+#define bmp_read24(addr)            (_farnspeekl(addr) &amp; 0xFFFFFF)
+
+#ifndef AL_INLINE
+extern __inline__  /* special bodge because AL_INLINE isn't defined yet */
+#endif
+void bmp_write24(unsigned long addr, int c)
+{
+   _farnspokew(addr, c&amp;0xFFFF);
+   _farnspokeb(addr+2, c&gt;&gt;16);
+}
+
+
+/* describe the asm syntax for this platform */
+#define ALLEGRO_ASM_PREFIX    &quot;_&quot;
+#define ALLEGRO_ASM_USE_FS
+
+
+/* arrange for other headers to be included later on */
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/aldos.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintdos.h&quot;
+#define ALLEGRO_ASMCAPA_HEADER   &quot;obj/djgpp/asmcapa.h&quot;

Added: trunk/msvc-libs/include/allegro/platform/aldos.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/aldos.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/aldos.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,350 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      DOS-specific header defines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_DOS
+   #error bad include
+#endif
+
+
+/********************************************/
+/************ Platform-specifics ************/
+/********************************************/
+
+#define SYSTEM_DOS               AL_ID('D','O','S',' ')
+
+AL_VAR(SYSTEM_DRIVER, system_dos);
+
+AL_VAR(int, i_love_bill);
+
+
+#define KEYDRV_PCDOS             AL_ID('P','C','K','B')
+
+AL_VAR(KEYBOARD_DRIVER, keydrv_pcdos);
+
+
+#define TIMEDRV_FIXED_RATE       AL_ID('F','I','X','T')
+#define TIMEDRV_VARIABLE_RATE    AL_ID('V','A','R','T')
+
+AL_VAR(TIMER_DRIVER, timedrv_fixed_rate);
+AL_VAR(TIMER_DRIVER, timedrv_variable_rate);
+
+
+#define MOUSEDRV_MICKEYS         AL_ID('M','I','C','K')
+#define MOUSEDRV_INT33           AL_ID('I','3','3',' ')
+#define MOUSEDRV_POLLING         AL_ID('P','O','L','L')
+#define MOUSEDRV_WINNT           AL_ID('W','N','T',' ')
+#define MOUSEDRV_WIN2K           AL_ID('W','2','K',' ')
+
+AL_VAR(MOUSE_DRIVER, mousedrv_mickeys);
+AL_VAR(MOUSE_DRIVER, mousedrv_int33);
+AL_VAR(MOUSE_DRIVER, mousedrv_polling);
+AL_VAR(MOUSE_DRIVER, mousedrv_winnt);
+AL_VAR(MOUSE_DRIVER, mousedrv_win2k);
+
+
+
+/*******************************************/
+/************ Joystick routines ************/
+/*******************************************/
+
+#define JOY_TYPE_STANDARD        AL_ID('S','T','D',' ')
+#define JOY_TYPE_2PADS           AL_ID('2','P','A','D')
+#define JOY_TYPE_4BUTTON         AL_ID('4','B','U','T')
+#define JOY_TYPE_6BUTTON         AL_ID('6','B','U','T')
+#define JOY_TYPE_8BUTTON         AL_ID('8','B','U','T')
+#define JOY_TYPE_FSPRO           AL_ID('F','P','R','O')
+#define JOY_TYPE_WINGEX          AL_ID('W','I','N','G')
+#define JOY_TYPE_SIDEWINDER      AL_ID('S','W',' ',' ')
+#define JOY_TYPE_SIDEWINDER_AG   AL_ID('S','W','A','G')
+#define JOY_TYPE_GAMEPAD_PRO     AL_ID('G','P','R','O')
+#define JOY_TYPE_GRIP            AL_ID('G','R','I','P')
+#define JOY_TYPE_GRIP4           AL_ID('G','R','I','4')
+#define JOY_TYPE_SNESPAD_LPT1    AL_ID('S','N','E','1')
+#define JOY_TYPE_SNESPAD_LPT2    AL_ID('S','N','E','2')
+#define JOY_TYPE_SNESPAD_LPT3    AL_ID('S','N','E','3')
+#define JOY_TYPE_PSXPAD_LPT1     AL_ID('P','S','X','1')
+#define JOY_TYPE_PSXPAD_LPT2     AL_ID('P','S','X','2')
+#define JOY_TYPE_PSXPAD_LPT3     AL_ID('P','S','X','3')
+#define JOY_TYPE_N64PAD_LPT1     AL_ID('N','6','4','1')
+#define JOY_TYPE_N64PAD_LPT2     AL_ID('N','6','4','2')
+#define JOY_TYPE_N64PAD_LPT3     AL_ID('N','6','4','3')
+#define JOY_TYPE_DB9_LPT1        AL_ID('D','B','9','1')
+#define JOY_TYPE_DB9_LPT2        AL_ID('D','B','9','2')
+#define JOY_TYPE_DB9_LPT3        AL_ID('D','B','9','3')
+#define JOY_TYPE_TURBOGRAFX_LPT1 AL_ID('T','G','X','1')
+#define JOY_TYPE_TURBOGRAFX_LPT2 AL_ID('T','G','X','2')
+#define JOY_TYPE_TURBOGRAFX_LPT3 AL_ID('T','G','X','3')
+#define JOY_TYPE_IFSEGA_ISA      AL_ID('S','E','G','I')
+#define JOY_TYPE_IFSEGA_PCI      AL_ID('S','E','G','P')
+#define JOY_TYPE_IFSEGA_PCI_FAST AL_ID('S','G','P','F')
+#define JOY_TYPE_WINGWARRIOR     AL_ID('W','W','A','R')
+
+
+AL_VAR(JOYSTICK_DRIVER, joystick_standard);
+AL_VAR(JOYSTICK_DRIVER, joystick_2pads);
+AL_VAR(JOYSTICK_DRIVER, joystick_4button);
+AL_VAR(JOYSTICK_DRIVER, joystick_6button);
+AL_VAR(JOYSTICK_DRIVER, joystick_8button);
+AL_VAR(JOYSTICK_DRIVER, joystick_fspro);
+AL_VAR(JOYSTICK_DRIVER, joystick_wingex);
+AL_VAR(JOYSTICK_DRIVER, joystick_sw);
+AL_VAR(JOYSTICK_DRIVER, joystick_sw_ag);
+AL_VAR(JOYSTICK_DRIVER, joystick_gpro);
+AL_VAR(JOYSTICK_DRIVER, joystick_grip);
+AL_VAR(JOYSTICK_DRIVER, joystick_grip4);
+AL_VAR(JOYSTICK_DRIVER, joystick_sp1);
+AL_VAR(JOYSTICK_DRIVER, joystick_sp2);
+AL_VAR(JOYSTICK_DRIVER, joystick_sp3);
+AL_VAR(JOYSTICK_DRIVER, joystick_psx1);
+AL_VAR(JOYSTICK_DRIVER, joystick_psx2);
+AL_VAR(JOYSTICK_DRIVER, joystick_psx3);
+AL_VAR(JOYSTICK_DRIVER, joystick_n641);
+AL_VAR(JOYSTICK_DRIVER, joystick_n642);
+AL_VAR(JOYSTICK_DRIVER, joystick_n643);
+AL_VAR(JOYSTICK_DRIVER, joystick_db91);
+AL_VAR(JOYSTICK_DRIVER, joystick_db92);
+AL_VAR(JOYSTICK_DRIVER, joystick_db93);
+AL_VAR(JOYSTICK_DRIVER, joystick_tgx1);
+AL_VAR(JOYSTICK_DRIVER, joystick_tgx2);
+AL_VAR(JOYSTICK_DRIVER, joystick_tgx3);
+AL_VAR(JOYSTICK_DRIVER, joystick_sg1);
+AL_VAR(JOYSTICK_DRIVER, joystick_sg2);
+AL_VAR(JOYSTICK_DRIVER, joystick_sg2f);
+AL_VAR(JOYSTICK_DRIVER, joystick_ww);
+
+
+#define JOYSTICK_DRIVER_STANDARD                                  \
+      { JOY_TYPE_STANDARD,       &amp;joystick_standard,  TRUE  },    \
+      { JOY_TYPE_2PADS,          &amp;joystick_2pads,     FALSE },    \
+      { JOY_TYPE_4BUTTON,        &amp;joystick_4button,   FALSE },    \
+      { JOY_TYPE_6BUTTON,        &amp;joystick_6button,   FALSE },    \
+      { JOY_TYPE_8BUTTON,        &amp;joystick_8button,   FALSE },    \
+      { JOY_TYPE_FSPRO,          &amp;joystick_fspro,     FALSE },    \
+      { JOY_TYPE_WINGEX,         &amp;joystick_wingex,    FALSE },
+
+#define JOYSTICK_DRIVER_SIDEWINDER                                \
+      { JOY_TYPE_SIDEWINDER,     &amp;joystick_sw,        TRUE  },    \
+      { JOY_TYPE_SIDEWINDER_AG,  &amp;joystick_sw_ag,     TRUE  },
+
+#define JOYSTICK_DRIVER_GAMEPAD_PRO                               \
+      { JOY_TYPE_GAMEPAD_PRO,    &amp;joystick_gpro,      TRUE  },
+
+#define JOYSTICK_DRIVER_GRIP                                      \
+      { JOY_TYPE_GRIP,           &amp;joystick_grip,      TRUE  },    \
+      { JOY_TYPE_GRIP4,          &amp;joystick_grip4,     TRUE  },
+
+#define JOYSTICK_DRIVER_SNESPAD                                   \
+      { JOY_TYPE_SNESPAD_LPT1,   &amp;joystick_sp1,       FALSE },    \
+      { JOY_TYPE_SNESPAD_LPT2,   &amp;joystick_sp2,       FALSE },    \
+      { JOY_TYPE_SNESPAD_LPT3,   &amp;joystick_sp3,       FALSE },
+
+#define JOYSTICK_DRIVER_PSXPAD                                    \
+      { JOY_TYPE_PSXPAD_LPT1,    &amp;joystick_psx1,      FALSE },    \
+      { JOY_TYPE_PSXPAD_LPT2,    &amp;joystick_psx2,      FALSE },    \
+      { JOY_TYPE_PSXPAD_LPT3,    &amp;joystick_psx3,      FALSE },
+
+#define JOYSTICK_DRIVER_N64PAD                                    \
+      { JOY_TYPE_N64PAD_LPT1,    &amp;joystick_n641,      FALSE },    \
+      { JOY_TYPE_N64PAD_LPT2,    &amp;joystick_n642,      FALSE },    \
+      { JOY_TYPE_N64PAD_LPT3,    &amp;joystick_n643,      FALSE },
+
+#define JOYSTICK_DRIVER_DB9                                       \
+      { JOY_TYPE_DB9_LPT1,       &amp;joystick_db91,      FALSE },    \
+      { JOY_TYPE_DB9_LPT2,       &amp;joystick_db92,      FALSE },    \
+      { JOY_TYPE_DB9_LPT3,       &amp;joystick_db93,      FALSE },
+
+#define JOYSTICK_DRIVER_TURBOGRAFX                                \
+      { JOY_TYPE_TURBOGRAFX_LPT1,&amp;joystick_tgx1,      FALSE },    \
+      { JOY_TYPE_TURBOGRAFX_LPT2,&amp;joystick_tgx2,      FALSE },    \
+      { JOY_TYPE_TURBOGRAFX_LPT3,&amp;joystick_tgx3,      FALSE },
+
+#define JOYSTICK_DRIVER_IFSEGA_ISA                                \
+      { JOY_TYPE_IFSEGA_ISA,     &amp;joystick_sg1,       FALSE },
+
+#define JOYSTICK_DRIVER_IFSEGA_PCI                                \
+      { JOY_TYPE_IFSEGA_PCI,     &amp;joystick_sg2,       FALSE },
+
+#define JOYSTICK_DRIVER_IFSEGA_PCI_FAST                           \
+      { JOY_TYPE_IFSEGA_PCI_FAST,&amp;joystick_sg2f,      FALSE },
+
+#define JOYSTICK_DRIVER_WINGWARRIOR                               \
+      { JOY_TYPE_WINGWARRIOR,    &amp;joystick_ww,        TRUE  },
+
+
+#define joy_FSPRO_trigger     joy_b1
+#define joy_FSPRO_butleft     joy_b2
+#define joy_FSPRO_butright    joy_b3
+#define joy_FSPRO_butmiddle   joy_b4
+
+#define joy_WINGEX_trigger    joy_b1
+#define joy_WINGEX_buttop     joy_b2
+#define joy_WINGEX_butthumb   joy_b3
+#define joy_WINGEX_butmiddle  joy_b4
+
+
+AL_FUNC(int, calibrate_joystick_tl, (void));
+AL_FUNC(int, calibrate_joystick_br, (void));
+AL_FUNC(int, calibrate_joystick_throttle_min, (void));
+AL_FUNC(int, calibrate_joystick_throttle_max, (void));
+AL_FUNC(int, calibrate_joystick_hat, (int direction));
+
+
+
+/*******************************************/
+/************ Graphics routines ************/
+/*******************************************/
+
+#define GFX_VGA                  AL_ID('V','G','A',' ')
+#define GFX_MODEX                AL_ID('M','O','D','X')
+#define GFX_VESA1                AL_ID('V','B','E','1')
+#define GFX_VESA2B               AL_ID('V','B','2','B')
+#define GFX_VESA2L               AL_ID('V','B','2','L')
+#define GFX_VESA3                AL_ID('V','B','E','3')
+#define GFX_VBEAF                AL_ID('V','B','A','F')
+#define GFX_XTENDED              AL_ID('X','T','N','D')
+
+#define GFX_SAFE_ID              GFX_VGA
+#define GFX_SAFE_DEPTH           8
+#define GFX_SAFE_W               320
+#define GFX_SAFE_H               200
+
+
+AL_VAR(GFX_DRIVER, gfx_vga);
+AL_VAR(GFX_DRIVER, gfx_modex);
+AL_VAR(GFX_DRIVER, gfx_vesa_1);
+AL_VAR(GFX_DRIVER, gfx_vesa_2b);
+AL_VAR(GFX_DRIVER, gfx_vesa_2l);
+AL_VAR(GFX_DRIVER, gfx_vesa_3);
+AL_VAR(GFX_DRIVER, gfx_vbeaf);
+AL_VAR(GFX_DRIVER, gfx_xtended);
+
+
+#define GFX_DRIVER_VGA                                            \
+   {  GFX_VGA,          &amp;gfx_vga,            TRUE  },
+
+#define GFX_DRIVER_MODEX                                          \
+   {  GFX_MODEX,        &amp;gfx_modex,          TRUE  },
+
+#define GFX_DRIVER_VBEAF                                          \
+   {  GFX_VBEAF,        &amp;gfx_vbeaf,          TRUE   },
+
+#define GFX_DRIVER_VESA3                                          \
+   {  GFX_VESA3,        &amp;gfx_vesa_3,         TRUE   },
+
+#define GFX_DRIVER_VESA2L                                         \
+   {  GFX_VESA2L,       &amp;gfx_vesa_2l,        TRUE   },
+
+#define GFX_DRIVER_VESA2B                                         \
+   {  GFX_VESA2B,       &amp;gfx_vesa_2b,        TRUE   },
+
+#define GFX_DRIVER_XTENDED                                        \
+   {  GFX_XTENDED,      &amp;gfx_xtended,        FALSE  },
+
+#define GFX_DRIVER_VESA1                                          \
+   {  GFX_VESA1,        &amp;gfx_vesa_1,         TRUE   },
+
+
+AL_VAR(GFX_VTABLE, __modex_vtable);
+
+
+AL_FUNC(void, split_modex_screen, (int line));
+
+
+AL_INLINE(void, _set_color, (int index, AL_CONST RGB *p),
+{
+   outportb(0x3C8, index);
+   outportb(0x3C9, p-&gt;r);
+   outportb(0x3C9, p-&gt;g);
+   outportb(0x3C9, p-&gt;b);
+
+   _current_palette[index] = *p;
+})
+
+
+
+/****************************************/
+/************ Sound routines ************/
+/****************************************/
+
+#define DIGI_SB10             AL_ID('S','B','1','0')
+#define DIGI_SB15             AL_ID('S','B','1','5')
+#define DIGI_SB20             AL_ID('S','B','2','0')
+#define DIGI_SBPRO            AL_ID('S','B','P',' ')
+#define DIGI_SB16             AL_ID('S','B','1','6')
+#define DIGI_AUDIODRIVE       AL_ID('E','S','S',' ')
+#define DIGI_SOUNDSCAPE       AL_ID('E','S','C',' ')
+#define DIGI_WINSOUNDSYS      AL_ID('W','S','S',' ')
+
+#define MIDI_OPL2             AL_ID('O','P','L','2')
+#define MIDI_2XOPL2           AL_ID('O','P','L','X')
+#define MIDI_OPL3             AL_ID('O','P','L','3')
+#define MIDI_SB_OUT           AL_ID('S','B',' ',' ')
+#define MIDI_MPU              AL_ID('M','P','U',' ')
+#define MIDI_AWE32            AL_ID('A','W','E',' ')
+
+
+AL_VAR(DIGI_DRIVER, digi_sb10);
+AL_VAR(DIGI_DRIVER, digi_sb15);
+AL_VAR(DIGI_DRIVER, digi_sb20);
+AL_VAR(DIGI_DRIVER, digi_sbpro);
+AL_VAR(DIGI_DRIVER, digi_sb16);
+AL_VAR(DIGI_DRIVER, digi_audiodrive);
+AL_VAR(DIGI_DRIVER, digi_soundscape);
+AL_VAR(DIGI_DRIVER, digi_wss);
+
+AL_VAR(MIDI_DRIVER, midi_opl2);
+AL_VAR(MIDI_DRIVER, midi_2xopl2);
+AL_VAR(MIDI_DRIVER, midi_opl3);
+AL_VAR(MIDI_DRIVER, midi_sb_out);
+AL_VAR(MIDI_DRIVER, midi_mpu401);
+AL_VAR(MIDI_DRIVER, midi_awe32);
+
+
+#define DIGI_DRIVER_WINSOUNDSYS                                   \
+      {  DIGI_WINSOUNDSYS, &amp;digi_wss,           FALSE  },
+
+#define DIGI_DRIVER_AUDIODRIVE                                    \
+      {  DIGI_AUDIODRIVE,  &amp;digi_audiodrive,    TRUE   },
+
+#define DIGI_DRIVER_SOUNDSCAPE                                    \
+      {  DIGI_SOUNDSCAPE,  &amp;digi_soundscape,    TRUE   },
+
+#define DIGI_DRIVER_SB                                            \
+      {  DIGI_SB16,        &amp;digi_sb16,          TRUE   },         \
+      {  DIGI_SBPRO,       &amp;digi_sbpro,         TRUE   },         \
+      {  DIGI_SB20,        &amp;digi_sb20,          TRUE   },         \
+      {  DIGI_SB15,        &amp;digi_sb15,          TRUE   },         \
+      {  DIGI_SB10,        &amp;digi_sb10,          TRUE   },
+
+#define MIDI_DRIVER_AWE32                                         \
+      {  MIDI_AWE32,       &amp;midi_awe32,         TRUE   },
+
+#define MIDI_DRIVER_ADLIB                                         \
+      {  MIDI_OPL3,        &amp;midi_opl3,          TRUE   },         \
+      {  MIDI_2XOPL2,      &amp;midi_2xopl2,        TRUE   },         \
+      {  MIDI_OPL2,        &amp;midi_opl2,          TRUE   },
+
+#define MIDI_DRIVER_SB_OUT                                        \
+      {  MIDI_SB_OUT,      &amp;midi_sb_out,        FALSE  },
+
+#define MIDI_DRIVER_MPU                                           \
+      {  MIDI_MPU,         &amp;midi_mpu401,        FALSE  },
+
+
+AL_FUNC(int, load_ibk, (AL_CONST char *filename, int drums));
+

Added: trunk/msvc-libs/include/allegro/platform/almac.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/almac.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/almac.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,78 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Mac-specific header defines.
+ *
+ *      By Ronaldo Hideki Yamada.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+/*******************************************/
+/************* system drivers **************/
+/*******************************************/
+#define SYSTEM_MACOS           AL_ID('M','C','O','S')
+AL_VAR(SYSTEM_DRIVER, system_macos);
+
+/*******************************************/
+/************** timer drivers **************/
+/*******************************************/
+#define TIMER_MACOS           AL_ID('M','C','O','S')
+AL_VAR(TIMER_DRIVER, timer_macos);
+
+/*******************************************/
+/************ keyboard drivers *************/
+/*******************************************/
+#define KEYBOARD_MACOS       AL_ID('M','C','O','S')
+AL_VAR(KEYBOARD_DRIVER, keyboard_macos);
+#define KEYBOARD_ADB         AL_ID('M','A','D','B')
+AL_VAR(KEYBOARD_DRIVER, keyboard_adb);
+
+/*******************************************/
+/************* mouse drivers ***************/
+/*******************************************/
+#define MOUSE_MACOS          AL_ID('M','C','O','S')
+AL_VAR(MOUSE_DRIVER, mouse_macos);
+#define MOUSE_ADB            AL_ID('M','A','D','B')
+AL_VAR(MOUSE_DRIVER, mouse_adb);
+
+
+/*******************************************/
+/*************** gfx drivers ***************/
+/*******************************************/
+#define GFX_DRAWSPROCKET     AL_ID('D','S','P',' ')
+AL_VAR(GFX_DRIVER,gfx_drawsprocket);
+
+#define GFX_SAFE_ID              GFX_DRAWSPROCKET
+#define GFX_SAFE_DEPTH           8
+#define GFX_SAFE_W               640
+#define GFX_SAFE_H               480
+
+/********************************************/
+/*************** sound drivers **************/
+/********************************************/
+#define DIGI_MACOS            AL_ID('M','C','O','S')
+AL_VAR(DIGI_DRIVER, digi_macos);
+
+#define MIDI_QUICKTIME        AL_ID('Q','T',' ',' ')
+AL_VAR(MIDI_DRIVER, midi_quicktime);
+
+/*******************************************/
+/************ joystick drivers *************/
+/*******************************************/
+/*no yet */
+
+#ifdef __cplusplus
+   }
+#endif

Added: trunk/msvc-libs/include/allegro/platform/almaccfg.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/almaccfg.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/almaccfg.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,75 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with MPW.
+ *
+ *      By Ronaldo Hideki Yamada.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef SCAN_DEPEND
+	#include &lt;MacTypes.h&gt;
+	#include &lt;QuickDraw.h&gt;
+#endif
+#define CALL_NOT_IN_CARBON 1
+
+#include &lt;FCntl.h&gt;
+#ifndef ENOSYS
+#define ENOSYS ENOENT
+#endif
+
+/* describe this platform */
+#define ALLEGRO_PLATFORM_STR  &quot;mpw&quot;
+#define ALLEGRO_BIG_ENDIAN
+#undef ALLEGRO_CONSOLE_OK
+
+#define INLINE
+#define ZERO_SIZE_ARRAY(type, name)             type name[64]
+#define AL_CONST								const
+#define AL_VAR(type, name)                      extern type name
+#define AL_ARRAY(type, name)                    extern type name[]
+#define AL_FUNC(type, name, args)               type name args
+#define AL_PRINTFUNC(type, name, args, a, b)    AL_FUNC(type, name, args)
+#define AL_METHOD(type, name, args)             type (*name) args
+#define AL_FUNCPTR(type, name, args)            extern type (*name) args
+
+#define END_OF_MAIN()				void x##_end(void) { }
+
+#define END_OF_FUNCTION(x)			void x##_end(void) { }
+#define END_OF_STATIC_FUNCTION(x)	static void x##_end(void) { }
+#define LOCK_DATA(d, s)				_mac_lock((void *)d, s)
+#define LOCK_CODE(c, s)				_mac_lock((void *)c, s)
+#define UNLOCK_DATA(d,s)			_mac_unlock((void *)d, s)
+#define LOCK_VARIABLE(x)			LOCK_DATA((void *)&amp;x, sizeof(x))
+#define LOCK_FUNCTION(x)			LOCK_CODE((void *)x, (long)x##_end - (long)x)
+
+/* long filename status */
+#define ALLEGRO_LFN  0
+
+#define ALLEGRO_NO_STRICMP 1
+
+#define ALLEGRO_NO_STRUPR 1
+
+//#define ALLEGRO_NO_STRDUP 1
+char *strdup(const char *);
+
+#ifndef AL_INLINE
+   #define AL_INLINE(type, name, args, code)    static type name args code
+#endif
+
+
+// gm_time has an strange return
+#define gmtime localtime
+
+
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/almac.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintmac.h&quot;

Added: trunk/msvc-libs/include/allegro/platform/almngw32.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/almngw32.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/almngw32.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,94 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with Mingw32.
+ *
+ *      By Michael Rickmann.
+ *
+ *      Native build version by Henrik Stokseth.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef SCAN_DEPEND
+   #include &lt;io.h&gt;
+   #include &lt;fcntl.h&gt;
+   #include &lt;direct.h&gt;
+   #include &lt;malloc.h&gt;
+#endif
+
+
+/* describe this platform */
+#ifdef ALLEGRO_STATICLINK
+   #define ALLEGRO_PLATFORM_STR  &quot;MinGW32.s&quot;
+#else
+   #define ALLEGRO_PLATFORM_STR  &quot;MinGW32&quot;
+#endif
+
+#define ALLEGRO_WINDOWS
+#define ALLEGRO_I386
+#define ALLEGRO_LITTLE_ENDIAN
+#define ALLEGRO_USE_CONSTRUCTOR
+
+#ifdef USE_CONSOLE
+   #define ALLEGRO_CONSOLE_OK
+   #define ALLEGRO_NO_MAGIC_MAIN
+#endif
+
+
+/* describe how function prototypes look to MINGW32 */
+#if (defined ALLEGRO_STATICLINK) || (defined ALLEGRO_SRC)
+   #define _AL_DLL
+#else
+   #define _AL_DLL   __declspec(dllimport)
+#endif
+
+#define AL_VAR(type, name)                   extern _AL_DLL type name
+#define AL_ARRAY(type, name)                 extern _AL_DLL type name[]
+#define AL_FUNC(type, name, args)            extern type name args
+#define AL_METHOD(type, name, args)          type (*name) args
+#define AL_FUNCPTR(type, name, args)         extern _AL_DLL type (*name) args
+
+
+/* windows specific defines */
+
+#if (defined ALLEGRO_SRC)
+/* pathches to handle DX7 headers on a win9x system */
+
+/* should WINNT be defined on win9x systems? */
+#ifdef WINNT
+   #undef WINNT
+#endif
+
+/* defined in windef.h */
+#ifndef HMONITOR_DECLARED
+   #define HMONITOR_DECLARED 1
+#endif
+
+/* already defined... */
+#ifndef _LPCWAVEFORMATEX_DEFINED
+   #define _LPCWAVEFORMATEX_DEFINED
+#endif
+
+#endif /* ALLEGRO_SRC */
+
+/* another instance of missing constants in the mingw32 headers */
+#ifndef ENUM_CURRENT_SETTINGS
+   #define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
+#endif
+
+/* describe the asm syntax for this platform */
+#define ALLEGRO_ASM_PREFIX    &quot;_&quot;
+
+/* arrange for other headers to be included later on */
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/alwin.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintwin.h&quot;
+#define ALLEGRO_ASMCAPA_HEADER   &quot;obj/mingw32/asmcapa.h&quot;

Added: trunk/msvc-libs/include/allegro/platform/almsvc.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/almsvc.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/almsvc.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,95 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with MSVC.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef SCAN_DEPEND
+   #include &lt;io.h&gt;
+   #include &lt;fcntl.h&gt;
+   #include &lt;direct.h&gt;
+   #include &lt;malloc.h&gt;
+#endif
+
+
+#pragma warning (disable: 4200 4244 4305)
+
+
+/* describe this platform */
+#ifdef ALLEGRO_STATICLINK
+   #define ALLEGRO_PLATFORM_STR  &quot;MSVC.s&quot;
+#else
+   #define ALLEGRO_PLATFORM_STR  &quot;MSVC&quot;
+#endif
+
+#define ALLEGRO_WINDOWS
+#define ALLEGRO_I386
+#define ALLEGRO_LITTLE_ENDIAN
+
+#ifdef USE_CONSOLE
+   #define ALLEGRO_CONSOLE_OK
+   #define ALLEGRO_NO_MAGIC_MAIN
+#endif
+
+#ifdef ALLEGRO_AND_MFC
+   #define ALLEGRO_NO_MAGIC_MAIN
+#endif
+
+
+/* describe how function prototypes look to MSVC */
+#if (defined ALLEGRO_STATICLINK) || (defined ALLEGRO_SRC)
+   #define _AL_DLL
+#else
+   #define _AL_DLL   __declspec(dllimport)
+#endif
+
+#define AL_VAR(type, name)             extern _AL_DLL type name
+#define AL_ARRAY(type, name)           extern _AL_DLL type name[]
+#define AL_FUNC(type, name, args)      _AL_DLL type __cdecl name args
+#define AL_METHOD(type, name, args)    type (__cdecl *name) args
+#define AL_FUNCPTR(type, name, args)   extern _AL_DLL type (__cdecl *name) args
+
+#ifdef AL_INLINE
+   #define END_OF_INLINE(name)         void *_force_instantiate_##name = name;
+#else
+   #define END_OF_INLINE(name)
+#endif
+
+#undef AL_INLINE
+
+#define AL_INLINE(type, name, args, code)    __inline _AL_DLL type __cdecl name args code END_OF_INLINE(name)
+
+#define INLINE       __inline
+
+#define LONG_LONG    __int64
+
+#define AL_CONST     const
+
+
+/* describe the asm syntax for this platform */
+#define ALLEGRO_ASM_PREFIX    &quot;_&quot;
+
+
+/* life would be so easy if compilers would all use the same names! */
+#if (!defined S_IRUSR) &amp;&amp; (!defined SCAN_DEPEND)
+   #define S_IRUSR   S_IREAD
+   #define S_IWUSR   S_IWRITE
+#endif
+
+
+/* arrange for other headers to be included later on */
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/alwin.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintwin.h&quot;
+#define ALLEGRO_ASMCAPA_HEADER   &quot;obj/msvc/asmcapa.h&quot;

Added: trunk/msvc-libs/include/allegro/platform/alplatf.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alplatf.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alplatf.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,2 @@
+/* generated by fix.sh */
+#define ALLEGRO_MSVC

Added: trunk/msvc-libs/include/allegro/platform/alqnx.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alqnx.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alqnx.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,73 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      QNX specific driver definitions.
+ *
+ *      By Angelo Mottola.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+/* magic to capture name of executable file */
+extern int    __crt0_argc;
+extern char **__crt0_argv;
+
+#ifndef USE_CONSOLE
+   #define ALLEGRO_MAGIC_MAIN
+   #define main _mangled_main
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address = (void*) _mangled_main;
+#else
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address;
+#endif
+
+
+/* System driver */
+#define SYSTEM_QNX            AL_ID('Q','S','Y','S')
+AL_VAR(SYSTEM_DRIVER, system_qnx);
+
+
+/* Timer driver */
+#define TIMERDRV_UNIX_PTHREADS	AL_ID('P','T','H','R')
+AL_VAR(TIMER_DRIVER, timerdrv_unix_pthreads);
+
+
+/* Keyboard driver */
+#define KEYBOARD_QNX          AL_ID('Q','K','E','Y')
+AL_VAR(KEYBOARD_DRIVER, keyboard_qnx);
+
+
+/* Mouse driver */
+#define MOUSE_QNX             AL_ID('Q','M','S','E')
+AL_VAR(MOUSE_DRIVER, mouse_qnx);
+
+
+/* Graphics drivers */
+#define GFX_PHOTON            AL_ID('Q','P','H',' ')
+#define GFX_PHOTON_DIRECT     AL_ID('Q','P','H','D')
+AL_VAR(GFX_DRIVER, gfx_photon);
+AL_VAR(GFX_DRIVER, gfx_photon_direct);
+
+#define GFX_SAFE_ID           GFX_PHOTON
+#define GFX_SAFE_DEPTH        8
+#define GFX_SAFE_W            320
+#define GFX_SAFE_H            200
+
+
+/* Sound driver */
+#define DIGI_ALSA             AL_ID('A','L','S','A')
+AL_VAR(DIGI_DRIVER, digi_alsa);
+
+
+/* MIDI driver */
+#define MIDI_ALSA             AL_ID('A','M','I','D')
+AL_VAR(MIDI_DRIVER, midi_alsa);

Added: trunk/msvc-libs/include/allegro/platform/alqnxcfg.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alqnxcfg.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alqnxcfg.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,53 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with QNX.
+ *
+ *      By Angelo Mottola.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef SCAN_DEPEND
+   #include &lt;stdio.h&gt;
+   #include &lt;stdlib.h&gt;
+   #include &lt;fcntl.h&gt;
+   #include &lt;unistd.h&gt;
+#endif
+
+
+/* a static auto config */
+#define HAVE_STRICMP
+#define HAVE_STRLWR
+#define HAVE_STRUPR
+#define HAVE_MEMCMP
+#define HAVE_MKSTEMP
+#define HAVE_UNISTD_H
+#define HAVE_FCNTL_H
+#define HAVE_LIMITS_H
+#define HAVE_DIRENT_H
+#define HAVE_SYS_DIR_H
+#define HAVE_SYS_UTSNAME_H
+#define HAVE_SYS_TIME_H
+#define TIME_WITH_SYS_TIME
+#define HAVE_LIBPTHREAD
+
+/* describe this platform */
+#define ALLEGRO_PLATFORM_STR  &quot;QNX&quot;
+#define ALLEGRO_LITTLE_ENDIAN
+#define ALLEGRO_CONSOLE_OK
+#define ALLEGRO_USE_SCHED_YIELD
+#define ALLEGRO_USE_CONSTRUCTOR
+
+/* arrange for other headers to be included later on */
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/alqnx.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintqnx.h&quot;
+#define ALLEGRO_ASMCAPA_HEADER   &quot;obj/qnx/asmcapa.h&quot;

Added: trunk/msvc-libs/include/allegro/platform/alucfg.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alucfg.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alucfg.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,65 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use on Unix platforms.
+ *
+ *      By Michael Bukin.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALUCFG_H
+#define ALUCFG_H
+
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+
+/* Describe this platform.  */
+#define ALLEGRO_PLATFORM_STR  &quot;Unix&quot;
+
+#define ALLEGRO_CONSOLE_OK
+
+#define ALLEGRO_EXTRA_HEADER &quot;allegro/platform/alunix.h&quot;
+#define ALLEGRO_INTERNAL_HEADER &quot;allegro/platform/aintunix.h&quot;
+
+#ifndef O_BINARY
+# define O_BINARY  0
+# define O_TEXT    0
+#endif
+
+/* These defines will be provided by configure script.  */
+#undef ALLEGRO_COLOR8
+#undef ALLEGRO_COLOR16
+#undef ALLEGRO_COLOR24
+#undef ALLEGRO_COLOR32
+
+/* Include configuration generated by configure script.  */
+#include &quot;alunixac.h&quot;
+
+/* Provide implementations of missing functions.  */
+#ifndef HAVE_STRICMP
+#define ALLEGRO_NO_STRICMP
+#endif
+
+#ifndef HAVE_STRLWR
+#define ALLEGRO_NO_STRLWR
+#endif
+
+#ifndef HAVE_STRUPR
+#define ALLEGRO_NO_STRUPR
+#endif
+
+#ifndef HAVE_MEMCMP
+#define ALLEGRO_NO_MEMCMP
+#endif
+
+#endif /* ifndef ALUCFG_H */
+

Added: trunk/msvc-libs/include/allegro/platform/alunix.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alunix.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alunix.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,296 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Unix-specific header defines.
+ *
+ *      By Michael Bukin.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#ifndef _ALLEGRO_ALUNIX_H
+#define _ALLEGRO_ALUNIX_H
+
+#ifndef ALLEGRO_UNIX
+   #error bad include
+#endif
+
+
+
+/**************************************/
+/************ General Unix ************/
+/**************************************/
+
+#define ALLEGRO_CONSOLE_OK
+#define ALLEGRO_VRAM_SINGLE_SURFACE
+
+/* magic to capture name of executable file */
+extern int    __crt0_argc;
+extern char **__crt0_argv;
+
+#ifndef USE_CONSOLE
+   #define ALLEGRO_MAGIC_MAIN
+   #define main _mangled_main
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address = (void*) _mangled_main;
+#else
+   #undef END_OF_MAIN
+   #define END_OF_MAIN() void *_mangled_main_address;
+#endif
+
+
+#ifdef HAVE_LIBPTHREAD
+
+#define TIMERDRV_UNIX_PTHREADS	AL_ID('P','T','H','R')
+AL_VAR(TIMER_DRIVER, timerdrv_unix_pthreads);
+
+#else
+
+#define TIMERDRV_UNIX_SIGALRM    AL_ID('A','L','R','M')
+AL_VAR(TIMER_DRIVER, timerdrv_unix_sigalrm);
+
+#endif
+
+
+
+/************************************/
+/*********** Sound drivers **********/
+/************************************/
+
+#ifdef ALLEGRO_WITH_OSSDIGI
+
+#define DIGI_OSS              AL_ID('O','S','S','D')
+
+AL_VAR(DIGI_DRIVER, digi_oss);
+
+#define DIGI_DRIVER_OSS                                          \
+      {  DIGI_OSS,        &amp;digi_oss,            TRUE  },
+
+#endif /* ALLEGRO_WITH_OSSDIGI */
+
+#ifdef ALLEGRO_WITH_OSSMIDI
+
+#define MIDI_OSS              AL_ID('O','S','S','M')
+
+AL_VAR(MIDI_DRIVER, midi_oss);
+
+#define MIDI_DRIVER_OSS                                          \
+      {  MIDI_OSS,        &amp;midi_oss,            TRUE  },
+
+#endif /* ALLEGRO_WITH_OSSMIDI */
+
+#ifdef ALLEGRO_WITH_ESDDIGI
+
+#define DIGI_ESD              AL_ID('E','S','D','D')
+
+#ifndef ALLEGRO_WITH_MODULES
+
+AL_VAR(DIGI_DRIVER, digi_esd);
+
+#define DIGI_DRIVER_ESD                                          \
+      {  DIGI_ESD,        &amp;digi_esd,            TRUE  },
+
+#endif
+
+#endif /* ALLEGRO_WITH_ESDDIGI */
+
+#ifdef ALLEGRO_WITH_ARTSDIGI
+
+#define DIGI_ARTS             AL_ID('A','R','T','S')
+
+#ifndef ALLEGRO_WITH_MODULES
+
+AL_VAR(DIGI_DRIVER, digi_arts);
+
+#define DIGI_DRIVER_ARTS                                         \
+      {  DIGI_ARTS,       &amp;digi_arts,            TRUE  },
+
+#endif
+
+#endif /* ALLEGRO_WITH_ARTSDIGI */
+
+#ifdef ALLEGRO_WITH_ALSADIGI
+
+#define DIGI_ALSA             AL_ID('A','L','S','A')
+
+#ifndef ALLEGRO_WITH_MODULES
+
+AL_VAR(DIGI_DRIVER, digi_alsa);
+
+#define DIGI_DRIVER_ALSA                                         \
+      {  DIGI_ALSA,       &amp;digi_alsa,           TRUE  },
+
+#endif
+      
+#endif /* ALLEGRO_WITH_ALSADIGI */
+
+
+#ifdef ALLEGRO_WITH_ALSAMIDI
+
+#define MIDI_ALSA              AL_ID('A','M','I','D')
+
+#ifndef ALLEGRO_WITH_MODULES
+
+AL_VAR(MIDI_DRIVER, midi_alsa);
+
+#define MIDI_DRIVER_ALSA                                          \
+      {  MIDI_ALSA,        &amp;midi_alsa,            TRUE  },
+
+#endif
+
+#endif /* ALLEGRO_WITH_ALSAMIDI */
+
+
+
+/************************************/
+/************ X-specific ************/
+/************************************/
+
+#ifdef ALLEGRO_WITH_XWINDOWS
+
+
+#define SYSTEM_XWINDOWS          AL_ID('X','W','I','N')
+AL_VAR(SYSTEM_DRIVER, system_xwin);
+
+#define GFX_XWINDOWS             AL_ID('X','W','I','N')
+#ifdef ALLEGRO_XWINDOWS_WITH_XF86VIDMODE
+#define GFX_XWINDOWS_FULLSCREEN  AL_ID('X','W','F','S')
+#endif
+#define KEYBOARD_XWINDOWS        AL_ID('X','W','I','N')
+#define MOUSE_XWINDOWS           AL_ID('X','W','I','N')
+
+#ifdef ALLEGRO_XWINDOWS_WITH_XF86DGA
+#define GFX_XDGA                 AL_ID('X','D','G','A')
+#ifdef ALLEGRO_XWINDOWS_WITH_XF86VIDMODE
+#define GFX_XDGA_FULLSCREEN	 AL_ID('X','D','F','S')
+#endif
+#endif
+
+#ifdef ALLEGRO_XWINDOWS_WITH_XF86DGA2
+#define GFX_XDGA2                AL_ID('D','G','A','2')
+#define GFX_XDGA2_SOFT           AL_ID('D','G','A','S')
+
+#ifndef ALLEGRO_WITH_MODULES
+AL_VAR(GFX_DRIVER, gfx_xdga2);
+AL_VAR(GFX_DRIVER, gfx_xdga2_soft);
+#endif
+#endif
+
+
+#endif /* ALLEGRO_WITH_XWINDOWS */
+
+
+
+/****************************************/
+/************ Linux-specific ************/
+/****************************************/
+
+#ifdef ALLEGRO_LINUX
+
+
+#define SYSTEM_LINUX             AL_ID('L','N','X','C')
+AL_VAR(SYSTEM_DRIVER, system_linux);
+
+#ifdef ALLEGRO_LINUX_VGA
+   #define GFX_VGA                  AL_ID('V','G','A',' ')
+   #define GFX_MODEX                AL_ID('M','O','D','X')
+   AL_VAR(GFX_DRIVER, gfx_vga);
+   AL_VAR(GFX_DRIVER, gfx_modex);
+#endif
+
+#ifdef ALLEGRO_LINUX_FBCON
+   #define GFX_FBCON                AL_ID('F','B',' ',' ')
+#ifndef ALLEGRO_WITH_MODULES
+   AL_VAR(GFX_DRIVER, gfx_fbcon);
+#endif
+#endif
+
+#ifdef ALLEGRO_LINUX_VBEAF
+   #define GFX_VBEAF                AL_ID('V','B','A','F')
+   AL_VAR(GFX_DRIVER, gfx_vbeaf);
+#endif
+
+#ifdef ALLEGRO_LINUX_SVGALIB
+   #define GFX_SVGALIB              AL_ID('S','V','G','A')
+#ifndef ALLEGRO_WITH_MODULES
+   AL_VAR(GFX_DRIVER, gfx_svgalib);
+#endif
+#endif
+
+#define KEYDRV_LINUX             AL_ID('L','N','X','C')
+AL_VAR(KEYBOARD_DRIVER, keydrv_linux_console);
+
+#define MOUSEDRV_LINUX_PS2       AL_ID('L','P','S','2')
+AL_VAR(MOUSE_DRIVER, mousedrv_linux_ps2);
+
+#define MOUSEDRV_LINUX_IPS2      AL_ID('L','I','P','S')
+AL_VAR(MOUSE_DRIVER, mousedrv_linux_ips2);
+
+#define MOUSEDRV_LINUX_GPMDATA   AL_ID('G','P','M','D')
+AL_VAR(MOUSE_DRIVER, mousedrv_linux_gpmdata);
+
+#define MOUSEDRV_LINUX_MS        AL_ID('M','S',' ',' ')
+AL_VAR(MOUSE_DRIVER, mousedrv_linux_ms);
+
+#define MOUSEDRV_LINUX_IMS       AL_ID('I','M','S',' ')
+AL_VAR(MOUSE_DRIVER, mousedrv_linux_ims);
+
+#define JOY_TYPE_LINUX_ANALOGUE  AL_ID('L','N','X','A')
+AL_VAR(JOYSTICK_DRIVER, joystick_linux_analogue);
+
+
+AL_FUNC(void, split_modex_screen, (int line));
+
+
+/* Port I/O functions -- maybe these should be internal */
+
+static INLINE void outportb(unsigned short port, unsigned char value)
+{
+   __asm__ volatile (&quot;outb %0, %1&quot; : : &quot;a&quot; (value), &quot;d&quot; (port));
+}
+
+static INLINE void outportw(unsigned short port, unsigned short value)
+{
+   __asm__ volatile (&quot;outw %0, %1&quot; : : &quot;a&quot; (value), &quot;d&quot; (port));
+}
+
+static INLINE void outportl(unsigned short port, unsigned long value)
+{
+   __asm__ volatile (&quot;outl %0, %1&quot; : : &quot;a&quot; (value), &quot;d&quot; (port));
+}
+
+static INLINE unsigned char inportb(unsigned short port)
+{
+   unsigned char value;
+   __asm__ volatile (&quot;inb %1, %0&quot; : &quot;=a&quot; (value) : &quot;d&quot; (port));
+   return value;
+}
+
+static INLINE unsigned short inportw(unsigned short port)
+{
+   unsigned short value;
+   __asm__ volatile (&quot;inw %1, %0&quot; : &quot;=a&quot; (value) : &quot;d&quot; (port));
+   return value;
+}
+
+static INLINE unsigned long inportl(unsigned short port)
+{
+   unsigned long value;
+   __asm__ volatile (&quot;inl %1, %0&quot; : &quot;=a&quot; (value) : &quot;d&quot; (port));
+   return value;
+}
+
+
+#endif /* ALLEGRO_LINUX */
+
+
+
+#endif /* !_ALLEGRO_ALUNIX_H */
+

Added: trunk/msvc-libs/include/allegro/platform/alunixac.hin
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alunixac.hin	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alunixac.hin	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,213 @@
+/* include/allegro/platform/alunixac.hin.  Generated automatically from configure.in by autoheader.  */
+/* Define if you want support for 8 bpp modes.  */
+#undef ALLEGRO_COLOR8
+
+/* Define if you want support for 16 bpp modes.  */
+#undef ALLEGRO_COLOR16
+
+/* Define if you want support for 24 bpp modes.  */
+#undef ALLEGRO_COLOR24
+
+/* Define if you want support for 32 bpp modes.  */
+#undef ALLEGRO_COLOR32
+
+/* Define if compiler prepends underscore to symbols.  */
+#undef ALLEGRO_ASM_PREFIX
+
+/* Define if assembler supports MMX.  */
+#undef ALLEGRO_MMX
+
+/* Define if assembler supports SSE.  */
+#undef ALLEGRO_SSE
+
+/* Define for Unix platforms, to use C convention for bank switching.  */
+#undef ALLEGRO_NO_ASM
+
+/* Define if target platform is linux.  */
+#undef ALLEGRO_LINUX
+
+/* Define to enable Linux console VGA driver */
+#undef ALLEGRO_LINUX_VGA
+
+/* Define to enable Linux console fbcon driver */
+#undef ALLEGRO_LINUX_FBCON
+
+/* Define to enable Linux console VBE/AF driver */
+#undef ALLEGRO_LINUX_VBEAF
+
+/* Define to enable Linux console SVGAlib driver */
+#undef ALLEGRO_LINUX_SVGALIB
+
+/* Define if SVGAlib driver can check vga_version */
+#undef ALLEGRO_LINUX_SVGALIB_HAVE_VGA_VERSION
+
+/* Define if target machine is little endian.  */
+#undef ALLEGRO_LITTLE_ENDIAN
+
+/* Define if target machine is big endian.  */
+#undef ALLEGRO_BIG_ENDIAN
+
+/* Define if dynamically loaded modules are supported.  */
+#undef ALLEGRO_WITH_MODULES
+
+/* Define if you need support for X-Windows.  */
+#undef ALLEGRO_WITH_XWINDOWS
+
+/* Define if MIT-SHM extension is supported.  */
+#undef ALLEGRO_XWINDOWS_WITH_SHM
+
+/* Define if XF86VidMode extension is supported.  */
+#undef ALLEGRO_XWINDOWS_WITH_XF86VIDMODE
+
+/* Define if XF86DGA extension is supported.  */
+#undef ALLEGRO_XWINDOWS_WITH_XF86DGA
+
+/* Define if DGA version 2.0 or newer is supported */
+#undef ALLEGRO_XWINDOWS_WITH_XF86DGA2
+
+/* Define if OSS DIGI driver is supported.  */
+#undef ALLEGRO_WITH_OSSDIGI
+
+/* Define if OSS MIDI driver is supported.  */
+#undef ALLEGRO_WITH_OSSMIDI
+
+/* Define if ALSA DIGI driver is supported.  */
+#undef ALLEGRO_WITH_ALSADIGI
+
+/* Define if ALSA MIDI driver is supported.  */
+#undef ALLEGRO_WITH_ALSAMIDI
+
+/* Define if ESD DIGI driver is supported.  */
+#undef ALLEGRO_WITH_ESDDIGI
+
+/* Define if aRts DIGI driver is supported.  */
+#undef ALLEGRO_WITH_ARTSDIGI
+
+/* Define to (void *)-1, if MAP_FAILED is not defined.  */
+#undef MAP_FAILED
+
+/* Define if constructor attribute is supported. */
+#undef ALLEGRO_USE_CONSTRUCTOR
+
+/* Define if sched_yield is provided by some library.  */
+#undef ALLEGRO_USE_SCHED_YIELD
+
+
+/* Define if you have the &lt;dirent.h&gt; header file, and it defines `DIR'. */
+#undef HAVE_DIRENT_H
+
+/* Define if you have the &lt;dlfcn.h&gt; header file. */
+#undef HAVE_DLFCN_H
+
+/* Define if you don't have `vprintf' but do have `_doprnt.' */
+#undef HAVE_DOPRNT
+
+/* Define if you have the &lt;fcntl.h&gt; header file. */
+#undef HAVE_FCNTL_H
+
+/* Define if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define if you have the &lt;inttypes.h&gt; header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define if you have the `pthread' library (-lpthread). */
+#undef HAVE_LIBPTHREAD
+
+/* Define if you have the &lt;limits.h&gt; header file. */
+#undef HAVE_LIMITS_H
+
+/* Define if you have the &lt;linux/joystick.h&gt; header file. */
+#undef HAVE_LINUX_JOYSTICK_H
+
+/* Define if you have the &lt;linux/soundcard.h&gt; header file. */
+#undef HAVE_LINUX_SOUNDCARD_H
+
+/* Define if you have the &lt;machine/soundcard.h&gt; header file. */
+#undef HAVE_MACHINE_SOUNDCARD_H
+
+/* Define if you have the `memcmp' function. */
+#undef HAVE_MEMCMP
+
+/* Define if you have the &lt;memory.h&gt; header file. */
+#undef HAVE_MEMORY_H
+
+/* Define if you have the `mkstemp' function. */
+#undef HAVE_MKSTEMP
+
+/* Define if you have a working `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Define if you have the &lt;ndir.h&gt; header file, and it defines `DIR'. */
+#undef HAVE_NDIR_H
+
+/* Define if you have the &lt;soundcard.h&gt; header file. */
+#undef HAVE_SOUNDCARD_H
+
+/* Define if you have the &lt;stdlib.h&gt; header file. */
+#undef HAVE_STDLIB_H
+
+/* Define if you have the `stricmp' function. */
+#undef HAVE_STRICMP
+
+/* Define if you have the &lt;strings.h&gt; header file. */
+#undef HAVE_STRINGS_H
+
+/* Define if you have the &lt;string.h&gt; header file. */
+#undef HAVE_STRING_H
+
+/* Define if you have the `strlwr' function. */
+#undef HAVE_STRLWR
+
+/* Define if you have the `strupr' function. */
+#undef HAVE_STRUPR
+
+/* Define if you have the &lt;sys/dir.h&gt; header file, and it defines `DIR'. */
+#undef HAVE_SYS_DIR_H
+
+/* Define if you have the &lt;sys/io.h&gt; header file. */
+#undef HAVE_SYS_IO_H
+
+/* Define if you have the &lt;sys/ndir.h&gt; header file, and it defines `DIR'. */
+#undef HAVE_SYS_NDIR_H
+
+/* Define if you have the &lt;sys/soundcard.h&gt; header file. */
+#undef HAVE_SYS_SOUNDCARD_H
+
+/* Define if you have the &lt;sys/time.h&gt; header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define if you have the &lt;sys/utsname.h&gt; header file. */
+#undef HAVE_SYS_UTSNAME_H
+
+/* Define if you have the &lt;unistd.h&gt; header file. */
+#undef HAVE_UNISTD_H
+
+/* Define if you have the `vprintf' function. */
+#undef HAVE_VPRINTF
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#undef RETSIGTYPE
+
+/* Define if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define if you can safely include both &lt;sys/time.h&gt; and &lt;time.h&gt;. */
+#undef TIME_WITH_SYS_TIME
+
+/* Define if your &lt;sys/time.h&gt; declares `struct tm'. */
+#undef TM_IN_SYS_TIME
+
+/* Define if your processor stores words with the most significant byte first
+   (like Motorola and SPARC, unlike Intel and VAX). */
+#undef WORDS_BIGENDIAN
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define as `__inline' if that's what the C compiler calls it, or to nothing
+   if it is not supported. */
+#undef inline
+
+/* Define to `unsigned' if &lt;sys/types.h&gt; does not define. */
+#undef size_t

Added: trunk/msvc-libs/include/allegro/platform/alwatcom.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alwatcom.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alwatcom.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,172 @@
+/*         ______   ___    ___ 
+ *        /\  _  \ /\_ \  /\_ \ 
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Configuration defines for use with Watcom.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+#ifndef SCAN_DEPEND
+   #ifndef __SW_3S
+      #error Allegro only supports stack based calling convention
+   #endif
+
+   #ifndef __SW_S
+      #error Stack overflow checking must be disabled
+   #endif
+
+   #include &lt;io.h&gt;
+   #include &lt;i86.h&gt;
+   #include &lt;conio.h&gt;
+   #include &lt;fcntl.h&gt;
+   #include &lt;direct.h&gt;
+   #include &lt;malloc.h&gt;
+#endif
+
+
+#pragma disable_message (120 201 202)
+
+
+/* describe this platform */
+#define ALLEGRO_PLATFORM_STR  &quot;Watcom&quot;
+#define ALLEGRO_DOS
+#define ALLEGRO_I386
+#define ALLEGRO_LITTLE_ENDIAN
+#define ALLEGRO_CONSOLE_OK
+#define ALLEGRO_VRAM_SINGLE_SURFACE
+
+#define ALLEGRO_LFN  0
+
+#if __WATCOMC__ &gt;= 1100
+   #define ALLEGRO_MMX
+#endif
+
+#if __WATCOMC__ &gt;= 1200   /* Open Watcom 1.0 */
+   #define AL_CONST const
+#endif
+
+
+/* emulate some important djgpp routines */
+#define inportb(port)         inp(port)
+#define inportw(port)         inpw(port)
+#define outportb(port, val)   outp(port, val)
+#define outportw(port, val)   outpw(port, val)
+
+#define ffblk        find_t
+#define ff_name      name
+#define ff_attrib    attrib
+#define ff_fsize     size
+#define ff_ftime     wr_time
+#define ff_fdate     wr_date
+
+#define findfirst(name, dta, attrib)   _dos_findfirst(name, attrib, dta)
+#define findnext(dta)                  _dos_findnext(dta)
+
+#define random()     rand()
+#define srandom(n)   srand(n)
+
+#define _dos_ds      _default_ds()
+
+#define dosmemget(offset, length, buffer)    memcpy(buffer, (void *)(offset), length)
+#define dosmemput(buffer, length, offset)    memcpy((void *)(offset), buffer, length)
+
+#define __djgpp_nearptr_enable()    1
+#define __djgpp_nearptr_disable()
+
+#define __djgpp_base_address        0
+#define __djgpp_conventional_base   0
+
+#define _crt0_startup_flags         1
+#define _CRT0_FLAG_NEARPTR          1
+
+
+typedef union __dpmi_regs
+{
+   struct {
+      unsigned long edi, esi, ebp, res, ebx, edx, ecx, eax;
+   } d;
+   struct {
+      unsigned short di, di_hi, si, si_hi, bp, bp_hi, res, res_hi;
+      unsigned short bx, bx_hi, dx, dx_hi, cx, cx_hi, ax, ax_hi;
+      unsigned short flags, es, ds, fs, gs, ip, cs, sp, ss;
+   } x;
+   struct {
+      unsigned char edi[4], esi[4], ebp[4], res[4];
+      unsigned char bl, bh, ebx_b2, ebx_b3, dl, dh, edx_b2, edx_b3;
+      unsigned char cl, ch, ecx_b2, ecx_b3, al, ah, eax_b2, eax_b3;
+   } h;
+} __dpmi_regs;
+
+
+typedef struct __dpmi_meminfo
+{
+   unsigned long handle;
+   unsigned long size;
+   unsigned long address;
+} __dpmi_meminfo;
+
+
+typedef struct __dpmi_free_mem_info
+{
+   unsigned long largest_available_free_block_in_bytes;
+   unsigned long maximum_unlocked_page_allocation_in_pages;
+   unsigned long maximum_locked_page_allocation_in_pages;
+   unsigned long linear_address_space_size_in_pages;
+   unsigned long total_number_of_unlocked_pages;
+   unsigned long total_number_of_free_pages;
+   unsigned long total_number_of_physical_pages;
+   unsigned long free_linear_address_space_in_pages;
+   unsigned long size_of_paging_file_partition_in_pages;
+   unsigned long reserved[3];
+} __dpmi_free_mem_info;
+
+
+extern unsigned long __tb;
+
+
+int __dpmi_int(int vector, __dpmi_regs *regs);
+int __dpmi_allocate_dos_memory(int paragraphs, int *ret);
+int __dpmi_free_dos_memory(int selector);
+int __dpmi_physical_address_mapping(__dpmi_meminfo *info);
+int __dpmi_free_physical_address_mapping(__dpmi_meminfo *info);
+int __dpmi_lock_linear_region(__dpmi_meminfo *info);
+int __dpmi_unlock_linear_region(__dpmi_meminfo *info);
+int __dpmi_allocate_ldt_descriptors(int count);
+int __dpmi_free_ldt_descriptor(int descriptor);
+int __dpmi_get_segment_base_address(int selector, unsigned long *addr);
+int __dpmi_set_segment_base_address(int selector, unsigned long address);
+int __dpmi_set_segment_limit(int selector, unsigned long limit);
+int __dpmi_get_free_memory_information(__dpmi_free_mem_info *info);
+int __dpmi_simulate_real_mode_interrupt(int vector, __dpmi_regs *regs);
+int __dpmi_simulate_real_mode_procedure_retf(__dpmi_regs *regs);
+int _go32_dpmi_lock_data(void *lockaddr, unsigned long locksize);
+int _go32_dpmi_lock_code(void *lockaddr, unsigned long locksize);
+
+long _allocate_real_mode_callback(void (*handler)(__dpmi_regs *r), __dpmi_regs *regs);
+
+
+/* memory locking macros */
+void _unlock_dpmi_data(void *addr, int size);
+
+#define END_OF_FUNCTION(x)          void x##_end(void) { }
+#define END_OF_STATIC_FUNCTION(x)   static void x##_end(void) { }
+#define LOCK_DATA(d, s)             _go32_dpmi_lock_data(d, s)
+#define LOCK_CODE(c, s)             _go32_dpmi_lock_code(c, s)
+#define UNLOCK_DATA(d,s)            _unlock_dpmi_data(d, s)
+#define LOCK_VARIABLE(x)            LOCK_DATA((void *)&amp;x, sizeof(x))
+#define LOCK_FUNCTION(x)            LOCK_CODE((void *)FP_OFF(x), (long)FP_OFF(x##_end) - (long)FP_OFF(x))
+
+
+/* arrange for other headers to be included later on */
+#define ALLEGRO_EXTRA_HEADER     &quot;allegro/platform/aldos.h&quot;
+#define ALLEGRO_INTERNAL_HEADER  &quot;allegro/platform/aintdos.h&quot;
+

Added: trunk/msvc-libs/include/allegro/platform/alwin.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/alwin.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/alwin.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,146 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___ 
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Windows-specific header defines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_WINDOWS
+   #error bad include
+#endif
+
+
+
+/*******************************************/
+/********** magic main emulation ***********/
+/*******************************************/
+AL_FUNC(int, _WinMain, (void *_main, void *hInst, void *hPrev, char *Cmd, int nShow));
+
+
+#if (!defined ALLEGRO_NO_MAGIC_MAIN) &amp;&amp; (!defined ALLEGRO_SRC)
+
+   #define ALLEGRO_MAGIC_MAIN
+   #define main _mangled_main
+   #undef END_OF_MAIN
+
+   /* disable strict pointer typing because of the vague prototype below */
+   #define NO_STRICT
+
+   #ifdef __cplusplus
+      extern &quot;C&quot; int __stdcall WinMain(void *hInst, void *hPrev, char *Cmd, int nShow);
+   #endif
+
+   #define END_OF_MAIN()                                                     \
+                                                                             \
+      int __stdcall WinMain(void *hInst, void *hPrev, char *Cmd, int nShow)  \
+      {                                                                      \
+         return _WinMain((void *)_mangled_main, hInst, hPrev, Cmd, nShow);   \
+      }
+
+#endif
+
+
+
+/*******************************************/
+/************* system drivers **************/
+/*******************************************/
+#define SYSTEM_DIRECTX           AL_ID('D','X',' ',' ')
+
+AL_VAR(SYSTEM_DRIVER, system_directx);
+
+
+
+/*******************************************/
+/************** timer drivers **************/
+/*******************************************/
+#define TIMER_WIN32_HIGH_PERF    AL_ID('W','3','2','H')
+#define TIMER_WIN32_LOW_PERF     AL_ID('W','3','2','L')
+
+AL_VAR(TIMER_DRIVER, timer_win32_high_perf);
+AL_VAR(TIMER_DRIVER, timer_win32_low_perf);
+
+
+
+/*******************************************/
+/************ keyboard drivers *************/
+/*******************************************/
+#define KEYBOARD_DIRECTX         AL_ID('D','X',' ',' ')
+
+AL_VAR(KEYBOARD_DRIVER, keyboard_directx);
+
+
+
+/*******************************************/
+/************* mouse drivers ***************/
+/*******************************************/
+#define MOUSE_DIRECTX            AL_ID('D','X',' ',' ')
+
+AL_VAR(MOUSE_DRIVER, mouse_directx);
+
+
+
+/*******************************************/
+/*************** gfx drivers ***************/
+/*******************************************/
+#define GFX_DIRECTX              AL_ID('D','X','A','C')
+#define GFX_DIRECTX_ACCEL        AL_ID('D','X','A','C')
+#define GFX_DIRECTX_SAFE         AL_ID('D','X','S','A')
+#define GFX_DIRECTX_SOFT         AL_ID('D','X','S','O')
+#define GFX_DIRECTX_WIN          AL_ID('D','X','W','N')
+#define GFX_DIRECTX_OVL          AL_ID('D','X','O','V')
+#define GFX_GDI                  AL_ID('G','D','I','B')
+
+AL_VAR(GFX_DRIVER, gfx_directx_accel);
+AL_VAR(GFX_DRIVER, gfx_directx_safe);
+AL_VAR(GFX_DRIVER, gfx_directx_soft);
+AL_VAR(GFX_DRIVER, gfx_directx_win);
+AL_VAR(GFX_DRIVER, gfx_directx_ovl);
+AL_VAR(GFX_DRIVER, gfx_gdi);
+
+#define GFX_DRIVER_DIRECTX                                              \
+   {  GFX_DIRECTX_ACCEL,   &amp;gfx_directx_accel,     TRUE  },             \
+   {  GFX_DIRECTX_SOFT,    &amp;gfx_directx_soft,      TRUE  },             \
+   {  GFX_DIRECTX_SAFE,    &amp;gfx_directx_safe,      TRUE  },             \
+   {  GFX_DIRECTX_WIN,     &amp;gfx_directx_win,       TRUE  },             \
+   {  GFX_DIRECTX_OVL,     &amp;gfx_directx_ovl,       TRUE  },             \
+   {  GFX_GDI,             &amp;gfx_gdi,               FALSE },
+
+#define GFX_SAFE_ID              GFX_DIRECTX_SAFE
+#define GFX_SAFE_DEPTH           8
+#define GFX_SAFE_W               640
+#define GFX_SAFE_H               480
+
+
+
+/********************************************/
+/*************** sound drivers **************/
+/********************************************/
+#define DIGI_DIRECTX(n)          AL_ID('D','X','A'+(n),' ')
+#define DIGI_DIRECTAMX(n)        AL_ID('A','X','A'+(n),' ')
+#define DIGI_WAVOUTID(n)         AL_ID('W','O','A'+(n),' ')
+#define MIDI_WIN32MAPPER         AL_ID('W','3','2','M')
+#define MIDI_WIN32(n)            AL_ID('W','3','2','A'+(n))
+
+
+
+/*******************************************/
+/************ joystick drivers *************/
+/*******************************************/
+#define JOY_TYPE_WIN32           AL_ID('W','3','2',' ')
+
+AL_VAR(JOYSTICK_DRIVER, joystick_win32);
+
+#define JOYSTICK_DRIVER_WIN32                                     \
+      { JOY_TYPE_WIN32,          &amp;joystick_win32,  TRUE  },
+

Added: trunk/msvc-libs/include/allegro/platform/macdef.h
===================================================================
--- trunk/msvc-libs/include/allegro/platform/macdef.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/platform/macdef.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,7 @@
+#define rmac_message	128		/*message window ID*/
+#define rerror_str		128		/*errors str*/
+
+#define kprefsize		16384	/* kbytes */
+#define kminsize		10000
+#define kStackNeeded	2048*1024 /*unsual stack requeriment? but allegro need*/
+#define kHeapNeeded		8192*1024 /*it's a game OK*/
\ No newline at end of file

Added: trunk/msvc-libs/include/allegro/quat.h
===================================================================
--- trunk/msvc-libs/include/allegro/quat.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/quat.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,60 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Quaternion routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_QUAT_H
+#define ALLEGRO_QUAT_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+typedef struct QUAT
+{
+     float w, x, y, z;
+} QUAT;
+
+
+AL_VAR(QUAT, identity_quat);
+
+AL_FUNC(void, quat_mul, (AL_CONST QUAT *p, AL_CONST QUAT *q, QUAT *out));
+AL_FUNC(void, get_x_rotate_quat, (QUAT *q, float r));
+AL_FUNC(void, get_y_rotate_quat, (QUAT *q, float r));
+AL_FUNC(void, get_z_rotate_quat, (QUAT *q, float r));
+AL_FUNC(void, get_rotation_quat, (QUAT *q, float x, float y, float z));
+AL_FUNC(void, get_vector_rotation_quat, (QUAT *q, float x, float y, float z, float a));
+
+AL_FUNC(void, apply_quat, (AL_CONST QUAT *q, float x, float y, float z, float *xout, float *yout, float *zout));
+AL_FUNC(void, quat_slerp, (AL_CONST QUAT *from, AL_CONST QUAT *to, float t, QUAT *out, int how));
+
+#define QUAT_SHORT   0
+#define QUAT_LONG    1
+#define QUAT_CW      2
+#define QUAT_CCW     3
+#define QUAT_USER    4
+
+#define quat_interpolate(from, to, t, out)   quat_slerp((from), (to), (t), (out), QUAT_SHORT)
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_QUAT_H */
+
+

Added: trunk/msvc-libs/include/allegro/rle.h
===================================================================
--- trunk/msvc-libs/include/allegro/rle.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/rle.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,49 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      RLE sprites.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_RLE_H
+#define ALLEGRO_RLE_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+#include &quot;gfx.h&quot;
+
+typedef struct RLE_SPRITE           /* a RLE compressed sprite */
+{
+   int w, h;                        /* width and height in pixels */
+   int color_depth;                 /* color depth of the image */
+   int size;                        /* size of sprite data in bytes */
+   ZERO_SIZE_ARRAY(signed char, dat);
+} RLE_SPRITE;
+
+
+AL_FUNC(RLE_SPRITE *, get_rle_sprite, (struct BITMAP *bitmap));
+AL_FUNC(void, destroy_rle_sprite, (RLE_SPRITE *sprite));
+
+#include &quot;inline/rle.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_RLE_H */
+
+

Added: trunk/msvc-libs/include/allegro/sound.h
===================================================================
--- trunk/msvc-libs/include/allegro/sound.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/sound.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,49 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Sound support routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_SOUND_H
+#define ALLEGRO_SOUND_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+#include &quot;digi.h&quot;
+#include &quot;stream.h&quot;
+#include &quot;midi.h&quot;
+
+AL_FUNC(void, reserve_voices, (int digi_voices, int midi_voices));
+AL_FUNC(void, set_volume_per_voice, (int scale));
+
+AL_FUNC(int, install_sound, (int digi, int midi, AL_CONST char *cfg_path));
+AL_FUNC(void, remove_sound, (void));
+
+AL_FUNC(int, install_sound_input, (int digi, int midi));
+AL_FUNC(void, remove_sound_input, (void));
+
+AL_FUNC(void, set_volume, (int digi_volume, int midi_volume));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_SOUND_H */
+
+

Added: trunk/msvc-libs/include/allegro/stream.h
===================================================================
--- trunk/msvc-libs/include/allegro/stream.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/stream.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,52 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Streaming sound routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_STREAM_H
+#define ALLEGRO_STREAM_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+struct SAMPLE;
+
+typedef struct AUDIOSTREAM
+{
+   int voice;                          /* the voice we are playing on */
+   struct SAMPLE *samp;                /* the sample we are using */
+   int len;                            /* buffer length */
+   int bufcount;                       /* number of buffers per sample half */
+   int bufnum;                         /* current refill buffer */
+   int active;                         /* which half is currently playing */
+   void *locked;                       /* the locked buffer */
+} AUDIOSTREAM;
+
+AL_FUNC(AUDIOSTREAM *, play_audio_stream, (int len, int bits, int stereo, int freq, int vol, int pan));
+AL_FUNC(void, stop_audio_stream, (AUDIOSTREAM *stream));
+AL_FUNC(void *, get_audio_stream_buffer, (AUDIOSTREAM *stream));
+AL_FUNC(void, free_audio_stream_buffer, (AUDIOSTREAM *stream));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_STREAM_H */
+
+

Added: trunk/msvc-libs/include/allegro/system.h
===================================================================
--- trunk/msvc-libs/include/allegro/system.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/system.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,148 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      System level: initialization, cleanup, etc.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_SYSTEM_H
+#define ALLEGRO_SYSTEM_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+struct RGB;
+struct BITMAP;
+struct GFX_VTABLE;
+
+#define ALLEGRO_ERROR_SIZE 256
+
+AL_ARRAY(char, allegro_id);
+AL_ARRAY(char, allegro_error);
+
+#define OSTYPE_UNKNOWN     0
+#define OSTYPE_WIN3        AL_ID('W','I','N','3')
+#define OSTYPE_WIN95       AL_ID('W','9','5',' ')
+#define OSTYPE_WIN98       AL_ID('W','9','8',' ')
+#define OSTYPE_WINME       AL_ID('W','M','E',' ')
+#define OSTYPE_WINNT       AL_ID('W','N','T',' ')
+#define OSTYPE_WIN2000     AL_ID('W','2','K',' ')
+#define OSTYPE_WINXP       AL_ID('W','X','P',' ')
+#define OSTYPE_OS2         AL_ID('O','S','2',' ')
+#define OSTYPE_WARP        AL_ID('W','A','R','P')
+#define OSTYPE_DOSEMU      AL_ID('D','E','M','U')
+#define OSTYPE_OPENDOS     AL_ID('O','D','O','S')
+#define OSTYPE_LINUX       AL_ID('T','U','X',' ')
+#define OSTYPE_SUNOS       AL_ID('S','U','N',' ')
+#define OSTYPE_FREEBSD     AL_ID('F','B','S','D')
+#define OSTYPE_NETBSD      AL_ID('N','B','S','D')
+#define OSTYPE_IRIX        AL_ID('I','R','I','X')
+#define OSTYPE_QNX         AL_ID('Q','N','X',' ')
+#define OSTYPE_UNIX        AL_ID('U','N','I','X')
+#define OSTYPE_BEOS        AL_ID('B','E','O','S')
+#define OSTYPE_MACOS       AL_ID('M','A','C',' ')
+
+AL_VAR(int, os_type);
+AL_VAR(int, os_version);
+AL_VAR(int, os_revision);
+AL_VAR(int, os_multitasking);
+
+#define SYSTEM_AUTODETECT  0
+#define SYSTEM_NONE        AL_ID('N','O','N','E')
+
+AL_FUNC(int, install_allegro, (int system_id, int *errno_ptr, AL_METHOD(int, atexit_ptr, (AL_METHOD(void, func, (void))))));
+#define allegro_init()  install_allegro(SYSTEM_AUTODETECT, &amp;errno, (int (*)(void (*)(void)))atexit)
+AL_FUNC(void, allegro_exit, (void));
+
+AL_FUNC(void, get_executable_name, (char *output, int size));
+AL_PRINTFUNC(void, allegro_message, (AL_CONST char *msg, ...), 1, 2);
+
+
+AL_FUNC(void, check_cpu, (void));
+
+/* CPU Capabilities flags - set to 0 on non x86 capable chips */
+#define CPU_ID       0x0001
+#define CPU_FPU      0x0002
+#define CPU_MMX      0x0004
+#define CPU_MMXPLUS  0x0008
+#define CPU_SSE      0x0010
+#define CPU_SSE2     0x0020
+#define CPU_3DNOW    0x0040
+#define CPU_ENH3DNOW 0x0080
+#define CPU_CMOV     0x0100
+
+AL_ARRAY(char, cpu_vendor);
+AL_VAR(int, cpu_family);
+AL_VAR(int, cpu_model);
+AL_VAR(int, cpu_capabilities);
+
+
+typedef struct SYSTEM_DRIVER
+{
+   int  id;
+   AL_CONST char *name;
+   AL_CONST char *desc;
+   AL_CONST char *ascii_name;
+   AL_METHOD(int, init, (void));
+   AL_METHOD(void, exit, (void));
+   AL_METHOD(void, get_executable_name, (char *output, int size));
+   AL_METHOD(int, find_resource, (char *dest, AL_CONST char *resource, int size));
+   AL_METHOD(void, set_window_title, (AL_CONST char *name));
+   AL_METHOD(int, set_window_close_button, (int enable));
+   AL_METHOD(void, set_window_close_hook, (AL_METHOD(void, proc, (void))));
+   AL_METHOD(void, message, (AL_CONST char *msg));
+   AL_METHOD(void, assert, (AL_CONST char *msg));
+   AL_METHOD(void, save_console_state, (void));
+   AL_METHOD(void, restore_console_state, (void));
+   AL_METHOD(struct BITMAP *, create_bitmap, (int color_depth, int width, int height));
+   AL_METHOD(void, created_bitmap, (struct BITMAP *bmp));
+   AL_METHOD(struct BITMAP *, create_sub_bitmap, (struct BITMAP *parent, int x, int y, int width, int height));
+   AL_METHOD(void, created_sub_bitmap, (struct BITMAP *bmp, struct BITMAP *parent));
+   AL_METHOD(int, destroy_bitmap, (struct BITMAP *bitmap));
+   AL_METHOD(void, read_hardware_palette, (void));
+   AL_METHOD(void, set_palette_range, (AL_CONST struct RGB *p, int from, int to, int retracesync));
+   AL_METHOD(struct GFX_VTABLE *, get_vtable, (int color_depth));
+   AL_METHOD(int, set_display_switch_mode, (int mode));
+   AL_METHOD(int, set_display_switch_callback, (int dir, AL_METHOD(void, cb, (void))));
+   AL_METHOD(void, remove_display_switch_callback, (AL_METHOD(void, cb, (void))));
+   AL_METHOD(void, display_switch_lock, (int lock, int foreground));
+   AL_METHOD(int, desktop_color_depth, (void));
+   AL_METHOD(int, get_desktop_resolution, (int *width, int *height));
+   AL_METHOD(void, yield_timeslice, (void));
+   AL_METHOD(_DRIVER_INFO *, gfx_drivers, (void));
+   AL_METHOD(_DRIVER_INFO *, digi_drivers, (void));
+   AL_METHOD(_DRIVER_INFO *, midi_drivers, (void));
+   AL_METHOD(_DRIVER_INFO *, keyboard_drivers, (void));
+   AL_METHOD(_DRIVER_INFO *, mouse_drivers, (void));
+   AL_METHOD(_DRIVER_INFO *, joystick_drivers, (void));
+   AL_METHOD(_DRIVER_INFO *, timer_drivers, (void));
+} SYSTEM_DRIVER;
+
+
+AL_VAR(SYSTEM_DRIVER, system_none);
+AL_VAR(SYSTEM_DRIVER *, system_driver);
+AL_ARRAY(_DRIVER_INFO, _system_driver_list);
+
+#include &quot;inline/system.inl&quot;
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_SYSTEM_H */
+
+

Added: trunk/msvc-libs/include/allegro/text.h
===================================================================
--- trunk/msvc-libs/include/allegro/text.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/text.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,67 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Text output routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_TEXT_H
+#define ALLEGRO_TEXT_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+struct BITMAP;
+
+typedef struct FONT_GLYPH           /* a single monochrome font character */
+{
+   short w, h;
+   ZERO_SIZE_ARRAY(unsigned char, dat);
+} FONT_GLYPH;
+
+
+struct FONT_VTABLE;
+
+typedef struct FONT
+{
+   void *data;
+   int height;
+   struct FONT_VTABLE *vtable;
+} FONT;
+
+AL_VAR(FONT *, font);
+AL_VAR(int, allegro_404_char);
+AL_FUNC(int, text_mode, (int mode));
+AL_FUNC(void, textout, (struct BITMAP *bmp, AL_CONST FONT *f, AL_CONST char *str, int x, int y, int color));
+AL_FUNC(void, textout_centre, (struct BITMAP *bmp, AL_CONST FONT *f, AL_CONST char *str, int x, int y, int color));
+AL_FUNC(void, textout_right, (struct BITMAP *bmp, AL_CONST FONT *f, AL_CONST char *str, int x, int y, int color));
+AL_FUNC(void, textout_justify, (struct BITMAP *bmp, AL_CONST FONT *f, AL_CONST char *str, int x1, int x2, int y, int diff, int color));
+AL_PRINTFUNC(void, textprintf, (struct BITMAP *bmp, AL_CONST FONT *f, int x, int y, int color, AL_CONST char *format, ...), 6, 7);
+AL_PRINTFUNC(void, textprintf_centre, (struct BITMAP *bmp, AL_CONST FONT *f, int x, int y, int color, AL_CONST char *format, ...), 6, 7);
+AL_PRINTFUNC(void, textprintf_right, (struct BITMAP *bmp, AL_CONST FONT *f, int x, int y, int color, AL_CONST char *format, ...), 6, 7);
+AL_PRINTFUNC(void, textprintf_justify, (struct BITMAP *bmp, AL_CONST FONT *f, int x1, int x2, int y, int diff, int color, AL_CONST char *format, ...), 8, 9);
+AL_FUNC(int, text_length, (AL_CONST FONT *f, AL_CONST char *str));
+AL_FUNC(int, text_height, (AL_CONST FONT *f));
+AL_FUNC(void, destroy_font, (FONT *f));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_TEXT_H */
+
+

Added: trunk/msvc-libs/include/allegro/timer.h
===================================================================
--- trunk/msvc-libs/include/allegro/timer.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/timer.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,82 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Timer routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_TIMER_H
+#define ALLEGRO_TIMER_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+#define TIMERS_PER_SECOND     1193181L
+#define SECS_TO_TIMER(x)      ((long)(x) * TIMERS_PER_SECOND)
+#define MSEC_TO_TIMER(x)      ((long)(x) * (TIMERS_PER_SECOND / 1000))
+#define BPS_TO_TIMER(x)       (TIMERS_PER_SECOND / (long)(x))
+#define BPM_TO_TIMER(x)       ((60 * TIMERS_PER_SECOND) / (long)(x))
+
+
+typedef struct TIMER_DRIVER
+{
+   int  id;
+   AL_CONST char *name;
+   AL_CONST char *desc;
+   AL_CONST char *ascii_name;
+   AL_METHOD(int,  init, (void));
+   AL_METHOD(void, exit, (void));
+   AL_METHOD(int,  install_int, (AL_METHOD(void, proc, (void)), long speed));
+   AL_METHOD(void, remove_int, (AL_METHOD(void, proc, (void))));
+   AL_METHOD(int,  install_param_int, (AL_METHOD(void, proc, (void *param)), void *param, long speed));
+   AL_METHOD(void, remove_param_int, (AL_METHOD(void, proc, (void *param)), void *param));
+   AL_METHOD(int,  can_simulate_retrace, (void));
+   AL_METHOD(void, simulate_retrace, (int enable));
+   AL_METHOD(void, rest, (long time, AL_METHOD(void, callback, (void))));
+} TIMER_DRIVER;
+
+
+AL_VAR(TIMER_DRIVER *, timer_driver);
+AL_ARRAY(_DRIVER_INFO, _timer_driver_list);
+
+AL_FUNC(int, install_timer, (void));
+AL_FUNC(void, remove_timer, (void));
+
+AL_FUNC(int, install_int_ex, (AL_METHOD(void, proc, (void)), long speed));
+AL_FUNC(int, install_int, (AL_METHOD(void, proc, (void)), long speed));
+AL_FUNC(void, remove_int, (AL_METHOD(void, proc, (void))));
+
+AL_FUNC(int, install_param_int_ex, (AL_METHOD(void, proc, (void *param)), void *param, long speed));
+AL_FUNC(int, install_param_int, (AL_METHOD(void, proc, (void *param)), void *param, long speed));
+AL_FUNC(void, remove_param_int, (AL_METHOD(void, proc, (void *param)), void *param));
+
+AL_VAR(volatile int, retrace_count);
+AL_FUNCPTR(void, retrace_proc, (void));
+
+AL_FUNC(int,  timer_can_simulate_retrace, (void));
+AL_FUNC(void, timer_simulate_retrace, (int enable));
+AL_FUNC(int,  timer_is_using_retrace, (void));
+
+AL_FUNC(void, rest, (long time));
+AL_FUNC(void, rest_callback, (long time, AL_METHOD(void, callback, (void))));
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_TIMER_H */
+

Added: trunk/msvc-libs/include/allegro/unicode.h
===================================================================
--- trunk/msvc-libs/include/allegro/unicode.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro/unicode.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,111 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Unicode support routines.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_UNICODE__H
+#define ALLEGRO_UNICODE__H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;base.h&quot;
+
+#define U_ASCII         AL_ID('A','S','C','8')
+#define U_ASCII_CP      AL_ID('A','S','C','P')
+#define U_UNICODE       AL_ID('U','N','I','C')
+#define U_UTF8          AL_ID('U','T','F','8')
+#define U_CURRENT       AL_ID('c','u','r','.')
+
+AL_FUNC(void, set_uformat, (int type));
+AL_FUNC(int, get_uformat, (void));
+AL_FUNC(void, register_uformat, (int type, AL_METHOD(int, u_getc, (AL_CONST char *s)), AL_METHOD(int, u_getx, (char **s)), AL_METHOD(int, u_setc, (char *s, int c)), AL_METHOD(int, u_width, (AL_CONST char *s)), AL_METHOD(int, u_cwidth, (int c)), AL_METHOD(int, u_isok, (int c)), int u_width_max));
+AL_FUNC(void, set_ucodepage, (AL_CONST unsigned short *table, AL_CONST unsigned short *extras));
+
+AL_FUNC(int, need_uconvert, (AL_CONST char *s, int type, int newtype));
+AL_FUNC(int, uconvert_size, (AL_CONST char *s, int type, int newtype));
+AL_FUNC(void, do_uconvert, (AL_CONST char *s, int type, char *buf, int newtype, int size));
+AL_FUNC(char *, uconvert, (AL_CONST char *s, int type, char *buf, int newtype, int size));
+AL_FUNC(int, uwidth_max, (int type));
+
+#define uconvert_ascii(s, buf)      uconvert(s, U_ASCII, buf, U_CURRENT, sizeof(buf))
+#define uconvert_toascii(s, buf)    uconvert(s, U_CURRENT, buf, U_ASCII, sizeof(buf))
+
+#define EMPTY_STRING    &quot;\0\0\0&quot;
+
+AL_ARRAY(char, empty_string);
+
+AL_FUNCPTR(int, ugetc, (AL_CONST char *s));
+AL_FUNCPTR(int, ugetx, (char **s));
+AL_FUNCPTR(int, ugetxc, (AL_CONST char **s));
+AL_FUNCPTR(int, usetc, (char *s, int c));
+AL_FUNCPTR(int, uwidth, (AL_CONST char *s));
+AL_FUNCPTR(int, ucwidth, (int c));
+AL_FUNCPTR(int, uisok, (int c));
+AL_FUNC(int, uoffset, (AL_CONST char *s, int index));
+AL_FUNC(int, ugetat, (AL_CONST char *s, int index));
+AL_FUNC(int, usetat, (char *s, int index, int c));
+AL_FUNC(int, uinsert, (char *s, int index, int c));
+AL_FUNC(int, uremove, (char *s, int index));
+AL_FUNC(int, utolower, (int c));
+AL_FUNC(int, utoupper, (int c));
+AL_FUNC(int, uisspace, (int c));
+AL_FUNC(int, uisdigit, (int c));
+AL_FUNC(int, ustrsize, (AL_CONST char *s));
+AL_FUNC(int, ustrsizez, (AL_CONST char *s));
+AL_FUNC(char *, _ustrdup, (AL_CONST char *src, AL_METHOD(void *, malloc_func, (size_t))));
+AL_FUNC(char *, ustrzcpy, (char *dest, int size, AL_CONST char *src));
+AL_FUNC(char *, ustrzcat, (char *dest, int size, AL_CONST char *src));
+AL_FUNC(int, ustrlen, (AL_CONST char *s));
+AL_FUNC(int, ustrcmp, (AL_CONST char *s1, AL_CONST char *s2));
+AL_FUNC(char *, ustrzncpy, (char *dest, int size, AL_CONST char *src, int n));
+AL_FUNC(char *, ustrzncat, (char *dest, int size, AL_CONST char *src, int n));
+AL_FUNC(int, ustrncmp, (AL_CONST char *s1, AL_CONST char *s2, int n));
+AL_FUNC(int, ustricmp, (AL_CONST char *s1, AL_CONST char *s2));
+AL_FUNC(char *, ustrlwr, (char *s));
+AL_FUNC(char *, ustrupr, (char *s));
+AL_FUNC(char *, ustrchr, (AL_CONST char *s, int c));
+AL_FUNC(char *, ustrrchr, (AL_CONST char *s, int c));
+AL_FUNC(char *, ustrstr, (AL_CONST char *s1, AL_CONST char *s2));
+AL_FUNC(char *, ustrpbrk, (AL_CONST char *s, AL_CONST char *set));
+AL_FUNC(char *, ustrtok, (char *s, AL_CONST char *set));
+AL_FUNC(char *, ustrtok_r, (char *s, AL_CONST char *set, char **last));
+AL_FUNC(double, uatof, (AL_CONST char *s));
+AL_FUNC(long, ustrtol, (AL_CONST char *s, char **endp, int base));
+AL_FUNC(double, ustrtod, (AL_CONST char *s, char **endp));
+AL_FUNC(AL_CONST char *, ustrerror, (int err));
+AL_PRINTFUNC(int, uszprintf, (char *buf, int size, AL_CONST char *format, ...), 3, 4);
+AL_FUNC(int, uvszprintf, (char *buf, int size, AL_CONST char *format, va_list args));
+AL_PRINTFUNC(int, usprintf, (char *buf, AL_CONST char *format, ...), 2, 3);
+
+#ifndef ustrdup
+   #define ustrdup(src)               _ustrdup(src, malloc)
+#endif
+
+#define ustrcpy(dest, src)            ustrzcpy(dest, INT_MAX, src)
+#define ustrcat(dest, src)            ustrzcat(dest, INT_MAX, src)
+#define ustrncpy(dest, src, n)        ustrzncpy(dest, INT_MAX, src, n)
+#define ustrncat(dest, src, n)        ustrzncat(dest, INT_MAX, src, n)
+#define uvsprintf(buf, format, args)  uvszprintf(buf, INT_MAX, format, args)
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef ALLEGRO_UNICODE__H */
+
+

Added: trunk/msvc-libs/include/allegro.h
===================================================================
--- trunk/msvc-libs/include/allegro.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/allegro.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,86 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Main header file for the entire Allegro library.
+ *      (separate modules can be included from the allegro/ directory)
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      Vincent Penquerc'h split the original allegro.h into separate headers.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef ALLEGRO_H
+#define ALLEGRO_H
+
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+#include &quot;allegro/base.h&quot;
+
+#include &quot;allegro/system.h&quot;
+#include &quot;allegro/debug.h&quot;
+
+#include &quot;allegro/unicode.h&quot;
+
+#include &quot;allegro/mouse.h&quot;
+#include &quot;allegro/timer.h&quot;
+#include &quot;allegro/keyboard.h&quot;
+#include &quot;allegro/joystick.h&quot;
+
+#include &quot;allegro/palette.h&quot;
+#include &quot;allegro/gfx.h&quot;
+#include &quot;allegro/color.h&quot;
+#include &quot;allegro/draw.h&quot;
+#include &quot;allegro/rle.h&quot;
+#include &quot;allegro/compiled.h&quot;
+#include &quot;allegro/text.h&quot;
+
+#include &quot;allegro/fli.h&quot;
+#include &quot;allegro/config.h&quot;
+#include &quot;allegro/gui.h&quot;
+
+#include &quot;allegro/sound.h&quot;
+
+#include &quot;allegro/file.h&quot;
+#include &quot;allegro/datafile.h&quot;
+
+#include &quot;allegro/fixed.h&quot;
+#include &quot;allegro/fmaths.h&quot;
+#include &quot;allegro/matrix.h&quot;
+#include &quot;allegro/quat.h&quot;
+
+#include &quot;allegro/3d.h&quot;
+#include &quot;allegro/3dmaths.h&quot;
+
+#ifndef ALLEGRO_LIB_BUILD
+   #include &quot;allegro/alcompat.h&quot;
+#endif
+
+
+#ifdef ALLEGRO_EXTRA_HEADER
+   #include ALLEGRO_EXTRA_HEADER
+#endif
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#ifdef __cplusplus
+#include &quot;allegro/fix.h&quot;
+#endif
+
+#endif          /* ifndef ALLEGRO_H */
+
+

Added: trunk/msvc-libs/include/bitset.h
===================================================================
--- trunk/msvc-libs/include/bitset.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/bitset.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,32 @@
+
+#ifndef Py_BITSET_H
+#define Py_BITSET_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Bitset interface */
+
+#define BYTE		char
+
+typedef BYTE *bitset;
+
+bitset newbitset(int nbits);
+void delbitset(bitset bs);
+#define testbit(ss, ibit) (((ss)[BIT2BYTE(ibit)] &amp; BIT2MASK(ibit)) != 0)
+int addbit(bitset bs, int ibit); /* Returns 0 if already set */
+int samebitset(bitset bs1, bitset bs2, int nbits);
+void mergebitset(bitset bs1, bitset bs2, int nbits);
+
+#define BITSPERBYTE	(8*sizeof(BYTE))
+#define NBYTES(nbits)	(((nbits) + BITSPERBYTE - 1) / BITSPERBYTE)
+
+#define BIT2BYTE(ibit)	((ibit) / BITSPERBYTE)
+#define BIT2SHIFT(ibit)	((ibit) % BITSPERBYTE)
+#define BIT2MASK(ibit)	(1 &lt;&lt; BIT2SHIFT(ibit))
+#define BYTE2BIT(ibyte)	((ibyte) * BITSPERBYTE)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BITSET_H */

Added: trunk/msvc-libs/include/boolobject.h
===================================================================
--- trunk/msvc-libs/include/boolobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boolobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,36 @@
+/* Boolean object interface */
+
+#ifndef Py_BOOLOBJECT_H
+#define Py_BOOLOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+typedef PyIntObject PyBoolObject;
+
+PyAPI_DATA(PyTypeObject) PyBool_Type;
+
+#define PyBool_Check(x) ((x)-&gt;ob_type == &amp;PyBool_Type)
+
+/* Py_False and Py_True are the only two bools in existence.
+Don't forget to apply Py_INCREF() when returning either!!! */
+
+/* Don't use these directly */
+PyAPI_DATA(PyIntObject) _Py_ZeroStruct, _Py_TrueStruct;
+
+/* Use these macros */
+#define Py_False ((PyObject *) &amp;_Py_ZeroStruct)
+#define Py_True ((PyObject *) &amp;_Py_TrueStruct)
+
+/* Macros for returning Py_True or Py_False, respectively */
+#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
+#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False
+
+/* Function to return a bool from a C long */
+PyAPI_FUNC(PyObject *) PyBool_FromLong(long);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BOOLOBJECT_H */

Added: trunk/msvc-libs/include/boost/assert.hpp
===================================================================
--- trunk/msvc-libs/include/boost/assert.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/assert.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,38 @@
+//
+//  boost/assert.hpp - BOOST_ASSERT(expr)
+//
+//  Copyright (c) 2001, 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  Note: There are no include guards. This is intentional.
+//
+//  See <A HREF="http://www.boost.org/libs/utility/assert.html">http://www.boost.org/libs/utility/assert.html</A> for documentation.
+//
+
+#undef BOOST_ASSERT
+
+#if defined(BOOST_DISABLE_ASSERTS)
+
+# define BOOST_ASSERT(expr) ((void)0)
+
+#elif defined(BOOST_ENABLE_ASSERT_HANDLER)
+
+#include &lt;boost/current_function.hpp&gt;
+
+namespace boost
+{
+
+void assertion_failed(char const * expr, char const * function, char const * file, long line); // user defined
+
+} // namespace boost
+
+#define BOOST_ASSERT(expr) ((expr)? ((void)0): ::boost::assertion_failed(#expr, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))
+
+#else
+# include &lt;assert.h&gt;
+# define BOOST_ASSERT(expr) assert(expr)
+#endif

Added: trunk/msvc-libs/include/boost/checked_delete.hpp
===================================================================
--- trunk/msvc-libs/include/boost/checked_delete.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/checked_delete.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,71 @@
+#ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED
+#define BOOST_CHECKED_DELETE_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/checked_delete.hpp
+//
+//  Copyright (c) 1999, 2000, 2001, 2002 boost.org
+//  Copyright (c) 2002, 2003 Peter Dimov
+//  Copyright (c) 2003 Daniel Frey
+//  Copyright (c) 2003 Howard Hinnant
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/utility/checked_delete.html">http://www.boost.org/libs/utility/checked_delete.html</A> for documentation.
+//
+
+namespace boost
+{
+
+// verify that types are complete for increased safety
+
+template&lt;class T&gt; inline void checked_delete(T * x)
+{
+    // intentionally complex - simplification causes regressions
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete x;
+}
+
+template&lt;class T&gt; inline void checked_array_delete(T * x)
+{
+    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
+    (void) sizeof(type_must_be_complete);
+    delete [] x;
+}
+
+template&lt;class T&gt; struct checked_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        // boost:: disables ADL
+        boost::checked_delete(x);
+    }
+};
+
+template&lt;class T&gt; struct checked_array_deleter
+{
+    typedef void result_type;
+    typedef T * argument_type;
+
+    void operator()(T * x) const
+    {
+        boost::checked_array_delete(x);
+    }
+};
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/config/abi/borland_prefix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/abi/borland_prefix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/abi/borland_prefix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,27 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  for C++ Builder the following options effect the ABI:
+//
+//  -b (on or off - effect emum sizes)
+//  -Vx  (on or off - empty members)
+//  -Ve (on or off - empty base classes)
+//  -aX (alignment - 5 options).
+//  -pX (Calling convention - 4 options)
+//  -VmX (member pointer size and layout - 5 options)
+//  -VC (on or off, changes name mangling)
+//  -Vl (on or off, changes struct layout).
+
+//  In addition the following warnings are sufficiently annoying (and
+//  unfixable) to have them turned off by default:
+//
+//  8027 - functions containing [for|while] loops are not expanded inline
+//  8026 - functions taking class by value arguments are not expanded inline
+
+#pragma nopushoptwarn
+#  pragma option push -Vx -Ve -a8 -b -pc -Vmv -VC- -Vl- -w-8027 -w-8026
+
+
+

Added: trunk/msvc-libs/include/boost/config/abi/borland_suffix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/abi/borland_suffix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/abi/borland_suffix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,12 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#  pragma option pop
+#pragma nopushoptwarn
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/abi/msvc_prefix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/abi/msvc_prefix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/abi/msvc_prefix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,8 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#pragma pack(push,8)
+
+

Added: trunk/msvc-libs/include/boost/config/abi/msvc_suffix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/abi/msvc_suffix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/abi/msvc_suffix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,8 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+#pragma pack(pop)
+
+

Added: trunk/msvc-libs/include/boost/config/abi_prefix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/abi_prefix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/abi_prefix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,20 @@
+//  abi_prefix header  -------------------------------------------------------//
+
+// &#169; Copyright John Maddock 2003
+   
+// Use, modification and distribution are subject to the Boost Software License,
+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>).
+
+#ifndef BOOST_CONFIG_ABI_PREFIX_HPP
+# define BOOST_CONFIG_ABI_PREFIX_HPP
+#else
+# error double inclusion of header boost/config/abi_prefix.hpp is an error
+#endif
+
+#include &lt;boost/config.hpp&gt;
+
+// this must occur after all other includes and before any code appears:
+#ifdef BOOST_HAS_ABI_HEADERS
+#  include BOOST_ABI_PREFIX
+#endif

Added: trunk/msvc-libs/include/boost/config/abi_suffix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/abi_suffix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/abi_suffix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,23 @@
+//  abi_sufffix header  -------------------------------------------------------//
+
+// &#169; Copyright John Maddock 2003
+   
+// Use, modification and distribution are subject to the Boost Software License,
+// Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
+// <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>).
+
+// This header should be #included AFTER code that was preceded by a #include
+// &lt;boost/config/abi_prefix.hpp&gt;.
+
+#ifndef BOOST_CONFIG_ABI_PREFIX_HPP
+# error Header boost/config/abi_prefix.hpp must only be used after boost/config/abi_prefix.hpp
+#else
+# undef BOOST_CONFIG_ABI_PREFIX_HPP
+#endif
+
+// the suffix header occurs after all of our code:
+#ifdef BOOST_HAS_ABI_HEADERS
+#  include BOOST_ABI_SUFFIX
+#endif
+
+

Added: trunk/msvc-libs/include/boost/config/auto_link.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/auto_link.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/auto_link.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,331 @@
+//  (C) Copyright John Maddock 2003.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+ /*
+  *   LOCATION:    see <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+  *   FILE         auto_link.hpp
+  *   VERSION      see &lt;boost/version.hpp&gt;
+  *   DESCRIPTION: Automatic library inclusion for Borland/Microsoft compilers.
+  */
+
+/*************************************************************************
+
+USAGE:
+~~~~~~
+
+Before including this header you must define one or more of define the following macros:
+
+BOOST_LIB_NAME:       Required: A string containing the basename of the library,
+                      for example boost_regex.
+BOOST_DYN_LINK:       Optional: when set link to dll rather than static library.
+BOOST_LIB_DIAGNOSTIC: Optional: when set the header will print out the name
+                      of the library selected (useful for debugging).
+
+These macros will be undef'ed at the end of the header, further this header
+has no include guards - so be sure to include it only once from your library!
+
+Algorithm:
+~~~~~~~~~~
+
+Libraries for Borland and Microsoft compilers are automatically
+selected here, the name of the lib is selected according to the following
+formula:
+
+BOOST_LIB_PREFIX
+   + BOOST_LIB_NAME
+   + &quot;_&quot;
+   + BOOST_LIB_TOOLSET
+   + BOOST_LIB_THREAD_OPT
+   + BOOST_LIB_RT_OPT
+   &quot;-&quot;
+   + BOOST_LIB_VERSION
+
+These are defined as:
+
+BOOST_LIB_PREFIX:     &quot;lib&quot; for static libraries otherwise &quot;&quot;.
+
+BOOST_LIB_NAME:       The base name of the lib ( for example boost_regex).
+
+BOOST_LIB_TOOLSET:    The compiler toolset name (vc6, vc7, bcb5 etc).
+
+BOOST_LIB_THREAD_OPT: &quot;-mt&quot; for multithread builds, otherwise nothing.
+
+BOOST_LIB_RT_OPT:     A suffix that indicates the runtime library used,
+                      contains one or more of the following letters after
+                      a hiphen:
+
+                      s      static runtime (dynamic if not present).
+                      d      debug build (release if not present).
+                      g      debug/diagnostic runtime (release if not present).
+                      p      STLPort Build.
+
+BOOST_LIB_VERSION:    The Boost version, in the form x_y, for Boost version x.y.
+
+
+***************************************************************************/
+
+#ifdef __cplusplus
+#  ifndef BOOST_CONFIG_HPP
+#     include &lt;boost/config.hpp&gt;
+#  endif
+#elif defined(_MSC_VER) &amp;&amp; !defined(__MWERKS__) &amp;&amp; !defined(__EDG_VERSION__)
+//
+// C language compatability (no, honestly)
+//
+#  define BOOST_MSVC _MSC_VER
+#  define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)
+#  define BOOST_DO_STRINGIZE(X) #X
+#endif
+//
+// Only include what follows for known and supported compilers:
+//
+#if (defined(BOOST_MSVC) &amp;&amp; defined(_MSC_EXTENSIONS)) \
+    || defined(__BORLANDC__) \
+    || (defined(__MWERKS__) &amp;&amp; defined(_WIN32) &amp;&amp; (__MWERKS__ &gt;= 0x3000)) \
+    || (defined(__ICL) &amp;&amp; defined(_MSC_EXTENSIONS) &amp;&amp; (_MSC_VER &gt;= 1200))
+
+#ifndef BOOST_VERSION_HPP
+#  include &lt;boost/version.hpp&gt;
+#endif
+
+#ifndef BOOST_LIB_NAME
+#  error &quot;Macro BOOST_LIB_NAME not set (internal error)&quot;
+#endif
+
+//
+// error check:
+//
+#if defined(__MSVC_RUNTIME_CHECKS) &amp;&amp; !defined(_DEBUG)
+#  pragma message(&quot;Using the /RTC option without specifying a debug runtime will lead to linker errors&quot;)
+#  pragma message(&quot;Hint: go to the code generation options and switch to one of the debugging runtimes&quot;)
+#  error &quot;Incompatible build options&quot;
+#endif
+//
+// select toolset:
+//
+#if defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC == 1200)
+
+   // vc6:
+#  define BOOST_LIB_TOOLSET &quot;vc6&quot;
+
+#elif defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC == 1300)
+
+   // vc7:
+#  define BOOST_LIB_TOOLSET &quot;vc7&quot;
+
+#elif defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC &gt;= 1310)
+
+   // vc71:
+#  define BOOST_LIB_TOOLSET &quot;vc71&quot;
+
+#elif defined(__BORLANDC__)
+
+   // CBuilder 6:
+#  define BOOST_LIB_TOOLSET &quot;bcb&quot;
+
+#elif defined(__ICL)
+
+   // Intel C++, no version number:
+#  define BOOST_LIB_TOOLSET &quot;iw&quot;
+
+#elif defined(__MWERKS__) &amp;&amp; (__MWERKS__ &lt;= 0x31FF )
+
+   // Metrowerks CodeWarrior 8.x
+#  define BOOST_LIB_TOOLSET &quot;cw8&quot;
+
+#elif defined(__MWERKS__) &amp;&amp; (__MWERKS__ &lt;= 0x32FF )
+
+   // Metrowerks CodeWarrior 9.x
+#  define BOOST_LIB_TOOLSET &quot;cw9&quot;
+
+#endif
+
+//
+// select thread opt:
+//
+#if defined(_MT) || defined(__MT__)
+#  define BOOST_LIB_THREAD_OPT &quot;-mt&quot;
+#else
+#  define BOOST_LIB_THREAD_OPT
+#endif
+
+#if defined(_MSC_VER) || defined(__MWERKS__)
+
+#  ifdef _DLL
+
+#     if (defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) &amp;&amp; (defined(_STLP_OWN_IOSTREAMS) || defined(__STL_OWN_IOSTREAMS))
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-gdp&quot;
+#        elif defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT &quot;-gdp&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-p&quot;
+#        endif
+
+#     elif defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-gdpn&quot;
+#        elif defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT &quot;-gdpn&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-pn&quot;
+#        endif
+
+#     else
+
+#        if defined(_DEBUG)
+#            define BOOST_LIB_RT_OPT &quot;-gd&quot;
+#        else
+#            define BOOST_LIB_RT_OPT
+#        endif
+
+#     endif
+
+#  else
+
+#     if (defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)) &amp;&amp; (defined(_STLP_OWN_IOSTREAMS) || defined(__STL_OWN_IOSTREAMS))
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-sgdp&quot;
+#        elif defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT &quot;-sgdp&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-sp&quot;
+#        endif
+
+#     elif defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+
+#        if defined(_DEBUG) &amp;&amp; (defined(__STL_DEBUG) || defined(_STLP_DEBUG))
+#            define BOOST_LIB_RT_OPT &quot;-sgdpn&quot;
+#        elif defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT &quot;-sgdpn&quot;
+#            pragma message(&quot;warning: STLPort debug versions are built with /D_STLP_DEBUG=1&quot;)
+#            error &quot;Build options aren't compatible with pre-built libraries&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-spn&quot;
+#        endif
+
+#     else
+
+#        if defined(_DEBUG)
+#             define BOOST_LIB_RT_OPT &quot;-sgd&quot;
+#        else
+#            define BOOST_LIB_RT_OPT &quot;-s&quot;
+#        endif
+
+#     endif
+
+#  endif
+
+#elif defined(__BORLANDC__)
+
+//
+// figure out whether we want the debug builds or not:
+//
+#pragma defineonoption BOOST_BORLAND_DEBUG -v
+//
+// sanity check:
+//
+#if defined(__STL_DEBUG) || defined(_STLP_DEBUG)
+#error &quot;Pre-built versions of the Boost libraries are not provided in STLPort-debug form&quot;
+#endif
+
+#  ifdef _RTLDLL
+
+#     ifdef BOOST_BORLAND_DEBUG
+#         define BOOST_LIB_RT_OPT &quot;-d&quot;
+#     else
+#         define BOOST_LIB_RT_OPT
+#     endif
+
+#  else
+
+#     ifdef BOOST_BORLAND_DEBUG
+#         define BOOST_LIB_RT_OPT &quot;-sd&quot;
+#     else
+#         define BOOST_LIB_RT_OPT &quot;-s&quot;
+#     endif
+
+#  endif
+
+#endif
+
+//
+// select linkage opt:
+//
+#if (defined(_DLL) || defined(_RTLDLL)) &amp;&amp; defined(BOOST_DYN_LINK)
+#  define BOOST_LIB_PREFIX
+#elif defined(BOOST_DYN_LINK)
+#  error &quot;Mixing a dll boost library with a static runtime is a really bad idea...&quot;
+#else
+#  define BOOST_LIB_PREFIX &quot;lib&quot;
+#endif
+
+//
+// now include the lib:
+//
+#if defined(BOOST_LIB_NAME) \
+      &amp;&amp; defined(BOOST_LIB_PREFIX) \
+      &amp;&amp; defined(BOOST_LIB_TOOLSET) \
+      &amp;&amp; defined(BOOST_LIB_THREAD_OPT) \
+      &amp;&amp; defined(BOOST_LIB_RT_OPT) \
+      &amp;&amp; defined(BOOST_LIB_VERSION)
+
+#  pragma comment(lib, BOOST_LIB_PREFIX BOOST_STRINGIZE(BOOST_LIB_NAME) &quot;-&quot; BOOST_LIB_TOOLSET BOOST_LIB_THREAD_OPT BOOST_LIB_RT_OPT &quot;-&quot; BOOST_LIB_VERSION &quot;.lib&quot;)
+#ifdef BOOST_LIB_DIAGNOSTIC
+#  pragma message (&quot;Linking to lib file: &quot; BOOST_LIB_PREFIX BOOST_STRINGIZE(BOOST_LIB_NAME) &quot;-&quot; BOOST_LIB_TOOLSET BOOST_LIB_THREAD_OPT BOOST_LIB_RT_OPT &quot;-&quot; BOOST_LIB_VERSION &quot;.lib&quot;)
+#endif
+
+#else
+#  error &quot;some required macros where not defined (internal logic error).&quot;
+#endif
+
+
+#endif // _MSC_VER || __BORLANDC__
+
+//
+// finally undef any macros we may have set:
+//
+#ifdef BOOST_LIB_PREFIX
+#  undef BOOST_LIB_PREFIX
+#endif
+#if defined(BOOST_LIB_NAME)
+#  undef BOOST_LIB_NAME
+#endif
+#if defined(BOOST_LIB_TOOLSET)
+#  undef BOOST_LIB_TOOLSET
+#endif
+#if defined(BOOST_LIB_THREAD_OPT)
+#  undef BOOST_LIB_THREAD_OPT
+#endif
+#if defined(BOOST_LIB_RT_OPT)
+#  undef BOOST_LIB_RT_OPT
+#endif
+#if defined(BOOST_LIB_LINK_OPT)
+#  undef BOOST_LIB_LINK_OPT
+#endif
+#if defined(BOOST_LIB_DEBUG_OPT)
+#  undef BOOST_LIB_DEBUG_OPT
+#endif
+#if defined(BOOST_DYN_LINK)
+#  undef BOOST_DYN_LINK
+#endif
+
+
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/borland.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/borland.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/borland.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,167 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright David Abrahams 2002 - 2003.
+//  (C) Copyright Aleksey Gurtovoy 2002.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Borland C++ compiler setup:
+
+// Version 5.0 and below:
+#   if __BORLANDC__ &lt;= 0x0550
+// Borland C++Builder 4 and 5:
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#     if __BORLANDC__ == 0x0550
+// Borland C++Builder 5, command-line compiler 5.5:
+#       define BOOST_NO_OPERATORS_IN_NAMESPACE
+#     endif
+#   endif
+
+// Version 5.51 and below:
+#if (__BORLANDC__ &lt;= 0x551)
+#  define BOOST_NO_CV_SPECIALIZATIONS
+#  define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#  define BOOST_NO_DEDUCED_TYPENAME
+#endif
+
+#if (__BORLANDC__ &lt;= 0x564)
+#  define BOOST_NO_SFINAE
+#endif
+
+// Version 7.0 (Kylix) and below:
+#if (__BORLANDC__ &lt;= 0x570)
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#  define BOOST_NO_PRIVATE_IN_AGGREGATE
+#  define BOOST_NO_USING_TEMPLATE
+#  define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#  define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+   // we shouldn't really need this - but too many things choke
+   // without it, this needs more investigation:
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#  ifdef NDEBUG
+      // fix broken &lt;cstring&gt; so that Boost.test works:
+#     include &lt;cstring&gt;
+#     undef strcmp
+#  endif
+
+//
+// new bug in 5.61:
+#if (__BORLANDC__ &gt;= 0x561) &amp;&amp; (__BORLANDC__ &lt;= 0x570)
+   // this seems to be needed by the command line compiler, but not the IDE:
+#  define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#endif
+
+#  ifdef _WIN32
+#     define BOOST_NO_SWPRINTF
+#  elif defined(linux) || defined(__linux__) || defined(__linux)
+      // we should really be able to do without this
+      // but the wcs* functions aren't imported into std::
+#     define BOOST_NO_STDC_NAMESPACE
+      // _CPPUNWIND doesn't get automatically set for some reason:
+#     pragma defineonoption BOOST_CPPUNWIND -x
+#  endif
+#endif
+
+//
+// Post 0x561 we have long long and stdint.h:
+#if __BORLANDC__ &gt;= 0x561
+#  ifndef __NO_LONG_LONG
+#     define BOOST_HAS_LONG_LONG
+#  endif
+   // On non-Win32 platforms let the platform config figure this out:
+#  ifdef _WIN32
+#      define BOOST_HAS_STDINT_H
+#  endif
+#endif
+
+// Borland C++Builder 6 defaults to using STLPort.  If _USE_OLD_RW_STL is
+// defined, then we have 0x560 or greater with the Rogue Wave implementation
+// which presumably has the std::DBL_MAX bug.
+#if ((__BORLANDC__ &gt;= 0x550) &amp;&amp; (__BORLANDC__ &lt; 0x560)) || defined(_USE_OLD_RW_STL)
+// &lt;climits&gt; is partly broken, some macros define symbols that are really in
+// namespace std, so you end up having to use illegal constructs like
+// std::DBL_MAX, as a fix we'll just include float.h and have done with:
+#include &lt;float.h&gt;
+#endif
+//
+// __int64:
+//
+#if (__BORLANDC__ &gt;= 0x530) &amp;&amp; !defined(__STRICT_ANSI__)
+#  define BOOST_HAS_MS_INT64
+#endif
+//
+// check for exception handling support:
+//
+#if !defined(_CPPUNWIND) &amp;&amp; !defined(BOOST_CPPUNWIND) &amp;&amp; !defined(__EXCEPTIONS)
+#  define BOOST_NO_EXCEPTIONS
+#endif
+//
+// all versions have a &lt;dirent.h&gt;:
+//
+#ifndef __STRICT_ANSI__
+#  define BOOST_HAS_DIRENT_H
+#endif
+//
+// all versions support __declspec:
+//
+#ifndef __STRICT_ANSI__
+#  define BOOST_HAS_DECLSPEC
+#endif
+//
+// ABI fixing headers:
+//
+#if __BORLANDC__ &lt; 0x600 // not implemented for version 6 compiler yet
+#ifndef BOOST_ABI_PREFIX
+#  define BOOST_ABI_PREFIX &quot;boost/config/abi/borland_prefix.hpp&quot;
+#endif
+#ifndef BOOST_ABI_SUFFIX
+#  define BOOST_ABI_SUFFIX &quot;boost/config/abi/borland_suffix.hpp&quot;
+#endif
+#endif
+//
+// Disable Win32 support in ANSI mode:
+//
+#if __BORLANDC__ &lt; 0x600
+#  pragma defineonoption BOOST_DISABLE_WIN32 -A
+#elif defined(__STRICT_ANSI__)
+#  define BOOST_DISABLE_WIN32
+#endif
+//
+// MSVC compatibility mode does some nasty things:
+//
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1200)
+#  define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#  define BOOST_NO_VOID_RETURNS
+#endif
+
+#define BOOST_COMPILER &quot;Borland C++ version &quot; BOOST_STRINGIZE(__BORLANDC__)
+
+//
+// versions check:
+// we don't support Borland prior to version 5.4:
+#if __BORLANDC__ &lt; 0x540
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 1536 (Builder X preview):
+#if (__BORLANDC__ &gt; 1536)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  else
+#     pragma message( &quot;Unknown compiler version - please run the configure tests and report the results&quot;)
+#  endif
+#endif
+
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/comeau.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/comeau.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/comeau.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,64 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Douglas Gregor 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2003. 
+//  (C) Copyright Beman Dawes 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Comeau C++ compiler setup:
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+#if (__COMO_VERSION__ &lt;= 4245) || !defined(BOOST_STRICT_CONFIG)
+
+#  ifdef _WIN32
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+#  if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1300
+#     define BOOST_NO_STDC_NAMESPACE
+#     if _MSC_VER &gt; 100
+         // only set this in non-strict mode:
+#        define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#     endif
+#  endif
+
+// Void returns don't work when emulating VC 6 (Peter Dimov)
+
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER == 1200)
+#     define BOOST_NO_VOID_RETURNS
+#  endif
+
+#endif  // version 4245
+
+//
+// enable __int64 support in VC emulation mode
+//
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
+#     define BOOST_HAS_MS_INT64
+#  endif
+
+#define BOOST_COMPILER &quot;Comeau compiler version &quot; BOOST_STRINGIZE(__COMO_VERSION__)
+
+//
+// versions check:
+// we don't know Comeau prior to version 4245:
+#if __COMO_VERSION__ &lt; 4245
+#  error &quot;Compiler not configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 4245:
+#if (__COMO_VERSION__ &gt; 4245)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/common_edg.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/common_edg.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/common_edg.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,53 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//
+// Options common to all edg based compilers.
+//
+// This is included from within the individual compiler mini-configs.
+
+#ifndef  __EDG_VERSION__
+#  error This file requires that __EDG_VERSION__ be defined.
+#endif
+
+#if (__EDG_VERSION__ &lt;= 238)
+#   define BOOST_NO_INTEGRAL_INT64_T
+#   define BOOST_NO_SFINAE
+#endif
+
+#if (__EDG_VERSION__ &lt;= 240)
+#   define BOOST_NO_VOID_RETURNS
+#endif
+
+#if (__EDG_VERSION__ &lt;= 241) &amp;&amp; !defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP)
+#   define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#endif
+
+#if (__EDG_VERSION__ &lt;= 244) &amp;&amp; !defined(BOOST_NO_TEMPLATE_TEMPLATES)
+#   define BOOST_NO_TEMPLATE_TEMPLATES
+#endif 
+
+// See also kai.hpp which checks a Kai-specific symbol for EH
+# if !defined(__KCC) &amp;&amp; !defined(__EXCEPTIONS)
+#     define BOOST_NO_EXCEPTIONS
+# endif
+
+# if !defined(__NO_LONG_LONG)
+#     define BOOST_HAS_LONG_LONG
+# endif
+
+#ifdef c_plusplus
+// EDG has &quot;long long&quot; in non-strict mode
+// However, some libraries have insufficient &quot;long long&quot; support
+// #define BOOST_HAS_LONG_LONG
+#endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/compaq_cxx.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/compaq_cxx.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/compaq_cxx.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,19 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Dec Alpha True64 C++ compiler setup:
+
+#define BOOST_COMPILER &quot;Dec Alpha True64 &quot; BOOST_STRINGIZE(__DECCXX_VER)
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+//
+// versions check:
+// Nothing to do here?
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/digitalmars.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/digitalmars.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/digitalmars.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,31 @@
+//  Copyright (C) Christof Meerwald 2003
+//  Copyright (C) Dan Watkins 2003
+//
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  Digital Mars C++ compiler setup:
+#define BOOST_COMPILER __DMC_VERSION_STRING__
+
+#define BOOST_HAS_LONG_LONG
+#define BOOST_HAS_PRAGMA_ONCE
+
+#define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#define BOOST_NO_OPERATORS_IN_NAMESPACE
+#define BOOST_NO_SFINAE
+#define BOOST_NO_TEMPLATE_TEMPLATES
+#define BOOST_NO_USING_TEMPLATE
+#define BOOST_NEEDS_TOKEN_PASTING_OP_FOR_TOKENS_JUXTAPOSING
+#define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+
+// check for exception handling support:
+#ifndef _CPPUNWIND
+#  define BOOST_NO_EXCEPTIONS
+#endif
+
+#if (__DMC__ &lt; 0x833)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif

Added: trunk/msvc-libs/include/boost/config/compiler/gcc.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/gcc.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/gcc.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,96 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001 - 2002. 
+//  (C) Copyright Beman Dawes 2001 - 2003. 
+//  (C) Copyright Douglas Gregor 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Synge Todo 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  GNU C++ compiler setup:
+
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ == 91
+       // egcs 1.1 won't parse shared_ptr.hpp without this:
+#      define BOOST_NO_AUTO_PTR
+#   endif
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 95
+      //
+      // Prior to gcc 2.95 member templates only partly
+      // work - define BOOST_MSVC6_MEMBER_TEMPLATES
+      // instead since inline member templates mostly work.
+      //
+#     define BOOST_NO_MEMBER_TEMPLATES
+#     if __GNUC_MINOR__ &gt;= 9
+#       define BOOST_MSVC6_MEMBER_TEMPLATES
+#     endif
+#   endif
+
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 96
+#     define BOOST_NO_SFINAE
+#   endif
+
+#   if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 97
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#     define BOOST_NO_OPERATORS_IN_NAMESPACE
+#   endif
+
+#   if __GNUC__ &lt; 3
+#      define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+#      define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#   endif
+
+#ifndef __EXCEPTIONS
+# define BOOST_NO_EXCEPTIONS
+#endif
+
+//
+// Bug specific to gcc 3.1 and 3.2:
+//
+#if (__GNUC__ == 3) &amp;&amp; ((__GNUC_MINOR__ == 1) || (__GNUC_MINOR__ == 2))
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#endif
+
+//
+// Threading support: Turn this on unconditionally here (except for
+// those platforms where we can know for sure). It will get turned off again
+// later if no threading API is detected.
+//
+#if !defined(__MINGW32__) &amp;&amp; !defined(linux) &amp;&amp; !defined(__linux) &amp;&amp; !defined(__linux__)
+# define BOOST_HAS_THREADS
+#endif 
+
+//
+// gcc has &quot;long long&quot;
+//
+#define BOOST_HAS_LONG_LONG
+
+//
+// gcc implements the named return value optimization since version 3.1
+//
+#if __GNUC__ &gt; 3 || ( __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 1 )
+#define BOOST_HAS_NRVO
+#endif
+
+#define BOOST_COMPILER &quot;GNU C++ version &quot; __VERSION__
+
+//
+// versions check:
+// we don't know gcc prior to version 2.90:
+#if (__GNUC__ == 2) &amp;&amp; (__GNUC_MINOR__ &lt; 90)
+#  error &quot;Compiler not configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 3.4:
+#if (__GNUC__ &gt; 3) || ((__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt; 4))
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  else
+#     warning &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/greenhills.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/greenhills.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/greenhills.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,28 @@
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Greenhills C++ compiler setup:
+
+#define BOOST_COMPILER &quot;Greenhills C++ version &quot; BOOST_STRINGIZE(__ghs)
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+//
+// versions check:
+// we don't support Greenhills prior to version 0:
+#if __ghs &lt; 0
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0:
+#if (__ghs &gt; 0)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/hp_acc.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/hp_acc.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/hp_acc.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,67 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Toon Knapen 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  HP aCC C++ compiler setup:
+
+#if (__HP_aCC &lt;= 33100)
+#    define BOOST_NO_INTEGRAL_INT64_T
+#    define BOOST_NO_OPERATORS_IN_NAMESPACE
+#  if !defined(_NAMESPACE_STD)
+#     define BOOST_NO_STD_LOCALE
+#     define BOOST_NO_STRINGSTREAM
+#  endif
+#endif
+
+#if (__HP_aCC &lt;= 33300)
+// member templates are sufficiently broken that we disable them for now
+#    define BOOST_NO_MEMBER_TEMPLATES
+#    define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#    define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+#endif
+
+#if (__HP_aCC &lt;= 33900) || !defined(BOOST_STRICT_CONFIG)
+#    define BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#    define BOOST_NO_TEMPLATE_TEMPLATES
+#    define BOOST_NO_SWPRINTF
+#    define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+//     std lib config should set this one already:
+//#    define BOOST_NO_STD_ALLOCATOR
+#endif 
+
+// optional features rather than defects:
+#if (__HP_aCC &gt;= 33900)
+#    define BOOST_HAS_LONG_LONG
+#    define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#endif
+
+#if (__HP_aCC &lt;= 53800 )
+#    define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#endif
+
+#define BOOST_COMPILER &quot;HP aCC version &quot; BOOST_STRINGIZE(__HP_aCC)
+
+//
+// versions check:
+// we don't support HP aCC prior to version 0:
+#if __HP_aCC &lt; 33000
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0:
+#if (__HP_aCC &gt; 53800)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/intel.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/intel.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/intel.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,114 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Aleksey Gurtovoy 2002 - 2003. 
+//  (C) Copyright Guillaume Melquiond 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2003. 
+//  (C) Copyright Martin Wille 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Intel compiler setup:
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+#if defined(__INTEL_COMPILER)
+#  define BOOST_INTEL_CXX_VERSION __INTEL_COMPILER
+#elif defined(__ICL)
+#  define BOOST_INTEL_CXX_VERSION __ICL
+#elif defined(__ICC)
+#  define BOOST_INTEL_CXX_VERSION __ICC
+#elif defined(__ECC)
+#  define BOOST_INTEL_CXX_VERSION __ECC
+#endif
+
+#define BOOST_COMPILER &quot;Intel C++ version &quot; BOOST_STRINGIZE(BOOST_INTEL_CXX_VERSION)
+#define BOOST_INTEL BOOST_INTEL_CXX_VERSION
+
+#if (BOOST_INTEL_CXX_VERSION &lt;= 500) &amp;&amp; defined(_MSC_VER)
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#endif
+
+#if (BOOST_INTEL_CXX_VERSION &lt;= 600) || !defined(BOOST_STRICT_CONFIG)
+
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1300) // added check for &lt;= VC 7 (Peter Dimov)
+
+// Boost libraries assume strong standard conformance unless otherwise
+// indicated by a config macro. As configured by Intel, the EDG front-end
+// requires certain compiler options be set to achieve that strong conformance.
+// Particularly /Qoption,c,--arg_dep_lookup (reported by Kirk Klobe &amp; Thomas Witt)
+// and /Zc:wchar_t,forScope. See boost-root/tools/build/intel-win32-tools.jam for
+// details as they apply to particular versions of the compiler. When the
+// compiler does not predefine a macro indicating if an option has been set,
+// this config file simply assumes the option has been set.
+// Thus BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP will not be defined, even if
+// the compiler option is not enabled.
+
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+// Void returns, 64 bit integrals don't work when emulating VC 6 (Peter Dimov)
+
+#  if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1200)
+#     define BOOST_NO_VOID_RETURNS
+#     define BOOST_NO_INTEGRAL_INT64_T
+#  endif
+
+#endif
+
+// See <A HREF="http://aspn.activestate.com/ASPN/Mail/Message/boost/1614864">http://aspn.activestate.com/ASPN/Mail/Message/boost/1614864</A>
+#if BOOST_INTEL_CXX_VERSION &lt; 700
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#else
+// _WCHAR_T_DEFINED is the Win32 spelling
+// _WCHAR_T is the Linux spelling
+#  if !defined(_WCHAR_T_DEFINED) &amp;&amp; !defined(_WCHAR_T)
+#    define BOOST_NO_INTRINSIC_WCHAR_T
+#  endif
+#endif
+
+#if (BOOST_INTEL_CXX_VERSION &lt;= 800) || !defined(BOOST_STRICT_CONFIG)
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#endif
+
+#if _MSC_VER+0 &gt;= 1000
+#  if _MSC_VER &gt;= 1200
+#     define BOOST_HAS_MS_INT64
+#  endif
+#  define BOOST_NO_SWPRINTF
+#elif defined(_WIN32)
+#  define BOOST_DISABLE_WIN32
+#endif
+
+// I checked version 6.0 build 020312Z, it implements the NRVO.
+// Correct this as you find out which version of the compiler
+// implemented the NRVO first.  (Daniel Frey)
+#if (BOOST_INTEL_CXX_VERSION &gt;= 600)
+#  define BOOST_HAS_NRVO
+#endif
+
+//
+// versions check:
+// we don't support Intel prior to version 5.0:
+#if BOOST_INTEL_CXX_VERSION &lt; 500
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version:
+#if (BOOST_INTEL_CXX_VERSION &gt; 800)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  elif defined(_MSC_VER)
+#     pragma message(&quot;Unknown compiler version - please run the configure tests and report the results&quot;)
+#  endif
+#endif
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/kai.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/kai.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/kai.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,35 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Kai C++ compiler setup:
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+#   if (__KCC_VERSION &lt;= 4001) || !defined(BOOST_STRICT_CONFIG)
+      // at least on Sun, the contents of &lt;cwchar&gt; is not in namespace std
+#     define BOOST_NO_STDC_NAMESPACE
+#   endif
+
+// see also common_edg.hpp which needs a special check for __KCC
+# if !defined(_EXCEPTIONS)
+#     define BOOST_NO_EXCEPTIONS
+# endif
+
+#define BOOST_COMPILER &quot;Kai C++ version &quot; BOOST_STRINGIZE(__KCC_VERSION)
+
+//
+// last known and checked version is 4001:
+#if (__KCC_VERSION &gt; 4001)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/metrowerks.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/metrowerks.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/metrowerks.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,94 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright David Abrahams 2001 - 2002. 
+//  (C) Copyright Beman Dawes 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Metrowerks C++ compiler setup:
+
+// locale support is disabled when linking with the dynamic runtime
+#   ifdef _MSL_NO_LOCALE
+#     define BOOST_NO_STD_LOCALE
+#   endif 
+
+#   if __MWERKS__ &lt;= 0x2301  // 5.3
+#     define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#     define BOOST_NO_POINTER_TO_MEMBER_CONST
+#     define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#     define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#   endif
+
+#   if __MWERKS__ &lt;= 0x2401  // 6.2
+//#     define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#   endif
+
+#   if(__MWERKS__ &lt;= 0x2407)  // 7.x
+#     define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#     define BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#   endif
+
+#   if(__MWERKS__ &lt;= 0x3003)  // 8.x
+#     define BOOST_NO_SFINAE
+#    endif
+
+#   if(__MWERKS__ &lt;= 0x3202)  // 9.2
+#     define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#    endif
+
+#if !__option(wchar_type)
+#   define BOOST_NO_INTRINSIC_WCHAR_T
+#endif
+
+#if !__option(exceptions)
+#   define BOOST_NO_EXCEPTIONS
+#endif
+
+#if (__INTEL__ &amp;&amp; _WIN32) || (__POWERPC__ &amp;&amp; macintosh)
+#   if __MWERKS__ == 0x3000
+#     define BOOST_COMPILER_VERSION 8.0
+#   elif __MWERKS__ == 0x3001
+#     define BOOST_COMPILER_VERSION 8.1
+#   elif __MWERKS__ == 0x3002
+#     define BOOST_COMPILER_VERSION 8.2
+#   elif __MWERKS__ == 0x3003
+#     define BOOST_COMPILER_VERSION 8.3
+#   elif __MWERKS__ == 0x3200
+#     define BOOST_COMPILER_VERSION 9.0
+#   elif __MWERKS__ == 0x3201
+#     define BOOST_COMPILER_VERSION 9.1
+#   elif __MWERKS__ == 0x3202
+#     define BOOST_COMPILER_VERSION 9.2
+#   else
+#     define BOOST_COMPILER_VERSION __MWERKS__
+#   endif
+#else
+#  define BOOST_COMPILER_VERSION __MWERKS__
+#endif
+
+#define BOOST_COMPILER &quot;Metrowerks CodeWarrior C++ version &quot; BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
+
+//
+// versions check:
+// we don't support Metrowerks prior to version 5.3:
+#if __MWERKS__ &lt; 0x2301
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version:
+#if (__MWERKS__ &gt; 0x3202)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/mpw.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/mpw.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/mpw.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,51 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  MPW C++ compilers setup:
+
+#   if    defined(__SC__)
+#     define BOOST_COMPILER &quot;MPW SCpp version &quot; BOOST_STRINGIZE(__SC__)
+#   elif defined(__MRC__)
+#     define BOOST_COMPILER &quot;MPW MrCpp version &quot; BOOST_STRINGIZE(__MRC__)
+#   else
+#     error &quot;Using MPW compiler configuration by mistake.  Please update.&quot;
+#   endif
+
+//
+// MPW 8.90:
+//
+#if (MPW_CPLUS &lt;= 0x890) || !defined(BOOST_STRICT_CONFIG)
+#  define BOOST_NO_CV_SPECIALIZATIONS
+#  define BOOST_NO_DEPENDENT_NESTED_DERIVATIONS
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#  define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#  define BOOST_NO_USING_TEMPLATE
+
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+
+#  define BOOST_NO_STD_ALLOCATOR /* actually a bug with const reference overloading */
+#endif
+
+//
+// versions check:
+// we don't support MPW prior to version 8.9:
+#if MPW_CPLUS &lt; 0x890
+#  error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0x890:
+#if (MPW_CPLUS &gt; 0x890)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/sgi_mipspro.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/sgi_mipspro.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/sgi_mipspro.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,24 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  SGI C++ compiler setup:
+
+#define BOOST_COMPILER &quot;SGI Irix compiler version &quot; BOOST_STRINGIZE(_COMPILER_VERSION)
+
+#include &quot;boost/config/compiler/common_edg.hpp&quot;
+
+//
+// Threading support:
+// Turn this on unconditionally here, it will get turned off again later
+// if no threading API is detected.
+//
+#define BOOST_HAS_THREADS
+//
+// version check:
+// probably nothing to do here?
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/sunpro_cc.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/sunpro_cc.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/sunpro_cc.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,89 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright Peter Dimov 2002. 
+//  (C) Copyright Aleksey Gurtovoy 2002 - 2003. 
+//  (C) Copyright David Abrahams 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Sun C++ compiler setup:
+
+#    if __SUNPRO_CC &lt;= 0x500
+#      define BOOST_NO_MEMBER_TEMPLATES
+#      define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#    endif
+
+#    if (__SUNPRO_CC &lt;= 0x520)
+       //
+       // Sunpro 5.2 and earler:
+       //
+       // although sunpro 5.2 supports the syntax for
+       // inline initialization it often gets the value
+       // wrong, especially where the value is computed
+       // from other constants (J Maddock 6th May 2001)
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+
+       // Although sunpro 5.2 supports the syntax for
+       // partial specialization, it often seems to
+       // bind to the wrong specialization.  Better
+       // to disable it until suppport becomes more stable
+       // (J Maddock 6th May 2001).
+#      define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#    endif
+
+#    if (__SUNPRO_CC &lt;= 0x530) || !defined(BOOST_STRICT_CONFIG)
+       // Requesting debug info (-g) with Boost.Python results
+       // in an internal compiler error for &quot;static const&quot;
+       // initialized in-class.
+       //    &gt;&gt; Assertion:   (../links/dbg_cstabs.cc, line 611)
+       //         while processing ../test.cpp at line 0.
+       // (Jens Maurer according to Gottfried Gan&#223;auge 04 Mar 2002)
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+
+       // SunPro 5.3 has better support for partial specialization,
+       // but breaks when compiling std::less&lt;shared_ptr&lt;T&gt; &gt;
+       // (Jens Maurer 4 Nov 2001).
+
+       // std::less specialization fixed as reported by George
+       // Heintzelman; partial specialization re-enabled
+       // (Peter Dimov 17 Jan 2002)
+
+//#      define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+
+       // integral constant expressions with 64 bit numbers fail
+#      define BOOST_NO_INTEGRAL_INT64_T
+#    endif
+
+#    if (__SUNPRO_CC &lt;= 0x540) || !defined(BOOST_STRICT_CONFIG)
+#      define BOOST_NO_TEMPLATE_TEMPLATES
+       // see <A HREF="http://lists.boost.org/MailArchives/boost/msg47184.php">http://lists.boost.org/MailArchives/boost/msg47184.php</A>
+       // and <A HREF="http://lists.boost.org/MailArchives/boost/msg47220.php">http://lists.boost.org/MailArchives/boost/msg47220.php</A>
+#      define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#      define BOOST_NO_SFINAE
+#      define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+#    endif
+
+#define BOOST_COMPILER &quot;Sun compiler version &quot; BOOST_STRINGIZE(__SUNPRO_CC)
+
+//
+// versions check:
+// we don't support sunpro prior to version 4:
+#if __SUNPRO_CC &lt; 0x400
+#error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 0x530:
+#if (__SUNPRO_CC &gt; 0x530)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/vacpp.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/vacpp.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/vacpp.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,56 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Toon Knapen 2001 - 2003. 
+//  (C) Copyright Lie-Quan Lee 2001. 
+//  (C) Copyright Markus Sch&#246;pflin 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Visual Age (IBM) C++ compiler setup:
+
+#if __IBMCPP__ &lt;= 501
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#  define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#endif
+
+#if (__IBMCPP__ &lt;= 502) 
+// Actually the compiler supports inclass member initialization but it
+// requires a definition for the class member and it doesn't recognize
+// it as an integral constant expression when used as a template argument.
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#endif
+
+#if (__IBMCPP__ &lt;= 600) || !defined(BOOST_STRICT_CONFIG)
+#endif
+
+//
+// On AIX thread support seems to be indicated by _THREAD_SAFE:
+//
+#ifdef _THREAD_SAFE
+#  define BOOST_HAS_THREADS
+#endif
+
+#define BOOST_COMPILER &quot;IBM Visual Age version &quot; BOOST_STRINGIZE(__IBMCPP__)
+
+//
+// versions check:
+// we don't support Visual age prior to version 5:
+#if __IBMCPP__ &lt; 500
+#error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 600:
+#if (__IBMCPP__ &gt; 600)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  endif
+#endif
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/compiler/visualc.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/compiler/visualc.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/compiler/visualc.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,146 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Microsoft Visual C++ compiler setup:
+
+#define BOOST_MSVC _MSC_VER
+
+// turn off the warnings before we #include anything
+#pragma warning( disable : 4503 ) // warning: decorated name length exceeded
+
+#if _MSC_VER &lt;= 1200  // 1200 == VC++ 6.0
+#pragma warning( disable : 4786 ) // ident trunc to '255' chars in debug info
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#  define BOOST_NO_VOID_RETURNS
+#  define BOOST_NO_EXCEPTION_STD_NAMESPACE
+   // disable min/max macro defines on vc6:
+   //
+#endif
+
+#if (_MSC_VER &lt;= 1300)  // 1300 == VC++ 7.0
+
+#if !defined(_MSC_EXTENSIONS) &amp;&amp; !defined(BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS)      // VC7 bug with /Za
+#  define BOOST_NO_DEPENDENT_TYPES_IN_TEMPLATE_VALUE_PARAMETERS
+#endif
+
+#  define BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+#  define BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#  define BOOST_NO_PRIVATE_IN_AGGREGATE
+#  define BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP
+#  define BOOST_NO_INTEGRAL_INT64_T
+#  define BOOST_NO_DEDUCED_TYPENAME
+#  define BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE
+
+//    VC++ 6/7 has member templates but they have numerous problems including
+//    cases of silent failure, so for safety we define:
+#  define BOOST_NO_MEMBER_TEMPLATES
+//    For VC++ experts wishing to attempt workarounds, we define:
+#  define BOOST_MSVC6_MEMBER_TEMPLATES
+
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#  define BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
+#  define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  define BOOST_NO_FUNCTION_TEMPLATE_ORDERING
+#  define BOOST_NO_USING_TEMPLATE
+#  define BOOST_NO_SWPRINTF
+#  define BOOST_NO_TEMPLATE_TEMPLATES
+#  define BOOST_NO_SFINAE
+#  if (_MSC_VER &gt; 1200)
+#     define BOOST_NO_MEMBER_FUNCTION_SPECIALIZATIONS
+#  endif
+
+#endif
+
+#if _MSC_VER &lt; 1310 // 1310 == VC++ 7.1
+#  define BOOST_NO_SWPRINTF
+#endif
+
+#if _MSC_VER &lt;= 1310
+#  define BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+#endif
+
+#ifndef _NATIVE_WCHAR_T_DEFINED
+#  define BOOST_NO_INTRINSIC_WCHAR_T
+#endif
+
+//   
+// check for exception handling support:   
+#ifndef _CPPUNWIND   
+#  define BOOST_NO_EXCEPTIONS   
+#endif 
+
+//
+// __int64 support:
+//
+#if (_MSC_VER &gt;= 1200)
+#   define BOOST_HAS_MS_INT64
+#endif
+#if (_MSC_VER &gt;= 1310) &amp;&amp; defined(_MSC_EXTENSIONS)
+#   define BOOST_HAS_LONG_LONG
+#endif
+//
+// disable Win32 API's if compiler extentions are
+// turned off:
+//
+#ifndef _MSC_EXTENSIONS
+#  define BOOST_DISABLE_WIN32
+#endif
+
+//
+// all versions support __declspec:
+//
+#define BOOST_HAS_DECLSPEC
+//
+// prefix and suffix headers:
+//
+#ifndef BOOST_ABI_PREFIX
+#  define BOOST_ABI_PREFIX &quot;boost/config/abi/msvc_prefix.hpp&quot;
+#endif
+#ifndef BOOST_ABI_SUFFIX
+#  define BOOST_ABI_SUFFIX &quot;boost/config/abi/msvc_suffix.hpp&quot;
+#endif
+
+# if _MSC_VER == 1200
+#   define BOOST_COMPILER_VERSION 6.0
+# elif _MSC_VER == 1300
+#   define BOOST_COMPILER_VERSION 7.0
+# elif _MSC_VER == 1310
+#   define BOOST_COMPILER_VERSION 7.1
+# else
+#   define BOOST_COMPILER_VERSION _MSC_VER
+# endif
+
+#define BOOST_COMPILER &quot;Microsoft Visual C++ version &quot; BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
+
+//
+// versions check:
+// we don't support Visual C++ prior to version 6:
+#if _MSC_VER &lt; 1200
+#error &quot;Compiler not supported or configured - please reconfigure&quot;
+#endif
+//
+// last known and checked version is 1310:
+#if (_MSC_VER &gt; 1310)
+#  if defined(BOOST_ASSERT_CONFIG)
+#     error &quot;Unknown compiler version - please run the configure tests and report the results&quot;
+#  else
+#     pragma message(&quot;Unknown compiler version - please run the configure tests and report the results&quot;)
+#  endif
+#endif
+
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/platform/aix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/aix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/aix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,33 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  IBM/Aix specific config options:
+
+#define BOOST_PLATFORM &quot;IBM Aix&quot;
+
+#define BOOST_HAS_UNISTD_H
+#define BOOST_HAS_NL_TYPES_H
+#define BOOST_HAS_NANOSLEEP
+#define BOOST_HAS_CLOCK_GETTIME
+
+// This needs support in &quot;boost/cstdint.hpp&quot; exactly like FreeBSD.
+// This platform has header named &lt;inttypes.h&gt; which includes all
+// the things needed.
+#define BOOST_HAS_STDINT_H
+
+// Threading API's:
+#define BOOST_HAS_PTHREADS
+#define BOOST_HAS_PTHREAD_DELAY_NP
+#define BOOST_HAS_SCHED_YIELD
+//#define BOOST_HAS_PTHREAD_YIELD
+
+// boilerplate code:
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/platform/amigaos.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/amigaos.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/amigaos.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,15 @@
+//  (C) Copyright John Maddock 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+#define BOOST_PLATFORM &quot;AmigaOS&quot;
+
+#define BOOST_DISABLE_THREADS
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_STD_WSTRING
+#define BOOST_NO_INTRINSIC_WCHAR_T
+ 
+

Added: trunk/msvc-libs/include/boost/config/platform/beos.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/beos.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/beos.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,26 @@
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  BeOS specific config options:
+
+#define BOOST_PLATFORM &quot;BeOS&quot;
+
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_CWCTYPE
+#define BOOST_HAS_UNISTD_H
+
+#define BOOST_HAS_BETHREADS
+
+#ifndef BOOST_DISABLE_THREADS
+#  define BOOST_HAS_THREADS
+#endif
+
+// boilerplate code:
+#include &lt;boost/config/posix_features.hpp&gt;
+ 
+
+

Added: trunk/msvc-libs/include/boost/config/platform/bsd.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/bsd.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/bsd.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,68 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Douglas Gregor 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  generic BSD config options:
+
+#if !defined(__FreeBSD__) &amp;&amp; !defined(__NetBSD__) &amp;&amp; !defined(__OpenBSD__)
+#error &quot;This platform is not BSD&quot;
+#endif
+
+#ifdef __FreeBSD__
+#define BOOST_PLATFORM &quot;FreeBSD &quot; BOOST_STRINGIZE(__FreeBSD__)
+#elif defined(__NetBSD__)
+#define BOOST_PLATFORM &quot;NetBSD &quot; BOOST_STRINGIZE(__NetBSD__)
+#elif defined(__OpenBSD__)
+#define BOOST_PLATFORM &quot;OpenBSD &quot; BOOST_STRINGIZE(__OpenBSD__)
+#endif
+
+//
+// is this the correct version check?
+// FreeBSD has &lt;nl_types.h&gt; but does not
+// advertise the fact in &lt;unistd.h&gt;:
+//
+#if defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &gt;= 3)
+#  define BOOST_HAS_NL_TYPES_H
+#endif
+
+//
+// FreeBSD 3.x has pthreads support, but defines _POSIX_THREADS in &lt;pthread.h&gt;
+// and not in &lt;unistd.h&gt;
+//
+#if defined(__FreeBSD__) &amp;&amp; (__FreeBSD__ &lt;= 3)
+#  define BOOST_HAS_PTHREADS
+#endif
+
+//
+// No wide character support in the BSD header files:
+//
+#define BOOST_NO_CWCHAR
+
+//
+// The BSD &lt;ctype.h&gt; has macros only, no functions:
+//
+#define BOOST_NO_CTYPE_FUNCTIONS
+
+//
+// thread API's not auto detected:
+//
+#define BOOST_HAS_SCHED_YIELD
+#define BOOST_HAS_NANOSLEEP
+#define BOOST_HAS_GETTIMEOFDAY
+#define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#define BOOST_HAS_SIGACTION
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/platform/cygwin.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/cygwin.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/cygwin.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,48 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  cygwin specific config options:
+
+#define BOOST_PLATFORM &quot;Cygwin&quot;
+#define BOOST_NO_CWCTYPE
+#define BOOST_NO_CWCHAR
+#define BOOST_NO_SWPRINTF
+#define BOOST_HAS_DIRENT_H
+
+//
+// Threading API:
+// See if we have POSIX threads, if we do use them, otherwise
+// revert to native Win threads.
+#define BOOST_HAS_UNISTD_H
+#include &lt;unistd.h&gt;
+#if defined(_POSIX_THREADS) &amp;&amp; (_POSIX_THREADS+0 &gt;= 0) &amp;&amp; !defined(BOOST_HAS_WINTHREADS)
+#  define BOOST_HAS_PTHREADS
+#  define BOOST_HAS_SCHED_YIELD
+#  define BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#  define BOOST_HAS_SIGACTION
+#else
+#  if !defined(BOOST_HAS_WINTHREADS)
+#     define BOOST_HAS_WINTHREADS
+#  endif
+#  define BOOST_HAS_FTIME
+#endif
+
+//
+// find out if we have a stdint.h, there should be a better way to do this:
+//
+#include &lt;sys/types.h&gt;
+#ifdef _STDINT_H
+#define BOOST_HAS_STDINT_H
+#endif
+
+// boilerplate code:
+#include &lt;boost/config/posix_features.hpp&gt;
+ 
+
+
+

Added: trunk/msvc-libs/include/boost/config/platform/hpux.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/hpux.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/hpux.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,62 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  (C) Copyright David Abrahams 2002. 
+//  (C) Copyright Toon Knapen 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  hpux specific config options:
+
+#define BOOST_PLATFORM &quot;HP-UX&quot;
+
+// In principle, HP-UX has a nice &lt;stdint.h&gt; under the name &lt;inttypes.h&gt;
+// However, it has the following problem:
+// Use of UINT32_C(0) results in &quot;0u l&quot; for the preprocessed source
+// (verifyable with gcc 2.95.3, assumed for HP aCC)
+// #define BOOST_HAS_STDINT_H
+
+#define BOOST_NO_SWPRINTF 
+#define BOOST_NO_CWCTYPE
+
+#ifdef __GNUC__
+   // GNU C on HP-UX does not support threads (checked up to gcc 3.3)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+// the following are always available:
+#ifndef BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_GETTIMEOFDAY
+#endif
+#ifndef BOOST_HAS_SCHED_YIELD
+#    define BOOST_HAS_SCHED_YIELD
+#endif
+#ifndef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#    define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#endif
+#ifndef BOOST_HAS_NL_TYPES_H
+#    define BOOST_HAS_NL_TYPES_H
+#endif
+#ifndef BOOST_HAS_NANOSLEEP
+#    define BOOST_HAS_NANOSLEEP
+#endif
+#ifndef BOOST_HAS_GETTIMEOFDAY
+#    define BOOST_HAS_GETTIMEOFDAY
+#endif
+#ifndef BOOST_HAS_DIRENT_H
+#    define BOOST_HAS_DIRENT_H
+#endif
+#ifndef BOOST_HAS_CLOCK_GETTIME
+#    define BOOST_HAS_CLOCK_GETTIME
+#endif
+#ifndef BOOST_HAS_SIGACTION
+#  define BOOST_HAS_SIGACTION
+#endif
+
+

Added: trunk/msvc-libs/include/boost/config/platform/irix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/irix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/irix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,31 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  SGI Irix specific config options:
+
+#define BOOST_PLATFORM &quot;SGI Irix&quot;
+
+#define BOOST_NO_SWPRINTF 
+//
+// these are not auto detected by POSIX feature tests:
+//
+#define BOOST_HAS_GETTIMEOFDAY
+#define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+
+#ifdef __GNUC__
+   // GNU C on IRIX does not support threads (checked up to gcc 3.3)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+

Added: trunk/msvc-libs/include/boost/config/platform/linux.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/linux.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/linux.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,98 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  linux specific config options:
+
+#define BOOST_PLATFORM &quot;linux&quot;
+
+// make sure we have __GLIBC_PREREQ if available at all
+#include &lt;cstdlib&gt;
+
+//
+// &lt;stdint.h&gt; added to glibc 2.1.1
+// We can only test for 2.1 though:
+//
+#if defined(__GLIBC__) &amp;&amp; ((__GLIBC__ &gt; 2) || ((__GLIBC__ == 2) &amp;&amp; (__GLIBC_MINOR__ &gt;= 1)))
+   // &lt;stdint.h&gt; defines int64_t unconditionally, but &lt;sys/types.h&gt; defines
+   // int64_t only if __GNUC__.  Thus, assume a fully usable &lt;stdint.h&gt;
+   // only when using GCC.
+#  if defined __GNUC__
+#    define BOOST_HAS_STDINT_H
+#  endif
+#endif
+
+#if defined(__LIBCOMO__)
+   //
+   // como on linux doesn't have std:: c functions:
+   // NOTE: versions of libcomo prior to beta28 have octal version numbering,
+   // e.g. version 25 is 21 (dec)
+   //
+#  if __LIBCOMO_VERSION__ &lt;= 20
+#    define BOOST_NO_STDC_NAMESPACE
+#  endif
+
+#  if __LIBCOMO_VERSION__ &lt;= 21
+#    define BOOST_NO_SWPRINTF
+#  endif
+
+#endif
+
+//
+// If glibc is past version 2 then we definitely have
+// gettimeofday, earlier versions may or may not have it:
+//
+#if defined(__GLIBC__) &amp;&amp; (__GLIBC__ &gt;= 2)
+#  define BOOST_HAS_GETTIMEOFDAY
+#endif
+
+#ifdef __USE_POSIX199309
+#  define BOOST_HAS_NANOSLEEP
+#endif
+
+#if defined(__GLIBC__) &amp;&amp; defined(__GLIBC_PREREQ)
+// __GLIBC_PREREQ is available since 2.1.2
+
+   // swprintf is available since glibc 2.2.0
+#  if !__GLIBC_PREREQ(2,2) || (!defined(__USE_ISOC99) &amp;&amp; !defined(__USE_UNIX98))
+#    define BOOST_NO_SWPRINTF
+#  endif
+#else
+#  define BOOST_NO_SWPRINTF
+#endif
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+#ifndef __GNUC__
+//
+// if the compiler is not gcc we still need to be able to parse
+// the GNU system headers, some of which (mainly &lt;stdint.h&gt;)
+// use GNU specific extensions:
+//
+#  ifndef __extension__
+#     define __extension__
+#  endif
+#  ifndef __const__
+#     define __const__ const
+#  endif
+#  ifndef __volatile__
+#     define __volatile__ volatile
+#  endif
+#  ifndef __signed__
+#     define __signed__ signed
+#  endif
+#  ifndef __typeof__
+#     define __typeof__ typeof
+#  endif
+#  ifndef __inline__
+#     define __inline__ inline
+#  endif
+#endif
+
+

Added: trunk/msvc-libs/include/boost/config/platform/macos.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/macos.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/macos.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,70 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001 - 2002. 
+//  (C) Copyright Bill Kempf 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Mac OS specific config options:
+
+#define BOOST_PLATFORM &quot;Mac OS&quot;
+
+#if __MACH__ &amp;&amp; !defined(_MSL_USING_MSL_C)
+
+// Using the Mac OS X system BSD-style C library.
+
+#  define BOOST_NO_CTYPE_FUNCTIONS
+#  define BOOST_NO_CWCHAR
+#  ifndef BOOST_HAS_UNISTD_H
+#    define BOOST_HAS_UNISTD_H
+#  endif
+// boilerplate code:
+#  ifndef TARGET_CARBON
+#     include &lt;boost/config/posix_features.hpp&gt;
+#  endif
+#  ifndef BOOST_HAS_STDINT_H
+#     define BOOST_HAS_STDINT_H
+#  endif
+
+//
+// BSD runtime has pthreads, sigaction, sched_yield and gettimeofday,
+// of these only pthreads are advertised in &lt;unistd.h&gt;, so set the 
+// other options explicitly:
+//
+#  define BOOST_HAS_SCHED_YIELD
+#  define BOOST_HAS_GETTIMEOFDAY
+#  define BOOST_HAS_SIGACTION
+
+#  if (__GNUC__ &lt; 3) &amp;&amp; !defined( __APPLE_CC__)
+
+// GCC strange &quot;ignore std&quot; mode works better if you pretend everything
+// is in the std namespace, for the most part.
+
+#    define BOOST_NO_STDC_NAMESPACE
+#  endif
+
+#else
+
+// Using the MSL C library.
+
+// We will eventually support threads in non-Carbon builds, but we do
+// not support this yet.
+#  if TARGET_CARBON
+
+#    define BOOST_HAS_MPTASKS
+
+// The MP task implementation of Boost Threads aims to replace MP-unsafe
+// parts of the MSL, so we turn on threads unconditionally.
+#    define BOOST_HAS_THREADS
+
+// The remote call manager depends on this.
+#    define BOOST_BIND_ENABLE_PASCAL
+
+#  endif
+
+#endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/platform/solaris.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/solaris.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/solaris.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,21 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  sun specific config options:
+
+#define BOOST_PLATFORM &quot;Sun Solaris&quot;
+
+#define BOOST_HAS_GETTIMEOFDAY
+
+// boilerplate code:
+#define BOOST_HAS_UNISTD_H
+#include &lt;boost/config/posix_features.hpp&gt;
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/platform/win32.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/platform/win32.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/platform/win32.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,86 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Bill Kempf 2001. 
+//  (C) Copyright Aleksey Gurtovoy 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Win32 specific config options:
+
+#define BOOST_PLATFORM &quot;Win32&quot;
+
+#if defined(__GNUC__) &amp;&amp; !defined(BOOST_NO_SWPRINTF)
+#  define BOOST_NO_SWPRINTF
+#endif
+
+#if !defined(__GNUC__) &amp;&amp; !defined(BOOST_HAS_DECLSPEC)
+#  define BOOST_HAS_DECLSPEC
+#endif
+
+#if defined(__MINGW32__) &amp;&amp; ((__GNUC__ &gt; 3) || ((__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 2)))
+#  define BOOST_HAS_STDINT_H
+#  define __STDC_LIMIT_MACROS
+#endif
+
+//
+// Win32 will normally be using native Win32 threads,
+// but there is a pthread library avaliable as an option,
+// we used to disable this when BOOST_DISABLE_WIN32 was 
+// defined but no longer - this should allow some
+// files to be compiled in strict mode - while maintaining
+// a consistent setting of BOOST_HAS_THREADS across
+// all translation units (needed for shared_ptr etc).
+//
+#ifndef BOOST_HAS_PTHREADS
+#  define BOOST_HAS_WINTHREADS
+#endif
+
+#ifndef BOOST_DISABLE_WIN32
+// WEK: Added
+#define BOOST_HAS_FTIME
+
+#endif
+
+//
+// disable min/max macros:
+//
+#ifdef min
+#  undef min
+#endif
+#ifdef max
+#  undef max
+#endif
+#ifndef NOMINMAX
+#  define NOMINMAX
+#endif
+
+#ifdef BOOST_MSVC
+#include &lt;algorithm&gt; // for existing std::min and std::max
+namespace std{
+  // Apparently, something in the Microsoft libraries requires the &quot;long&quot;
+  // overload, because it calls the min/max functions with arguments of
+  // slightly different type.  (If this proves to be incorrect, this
+  // whole &quot;BOOST_MSVC&quot; section can be removed.)
+  inline long min(long __a, long __b) {
+    return __b &lt; __a ? __b : __a;
+  }
+  inline long max(long __a, long __b) {
+    return  __a &lt; __b ? __b : __a;
+  }
+  // The &quot;long double&quot; overload is required, otherwise user code calling
+  // min/max for floating-point numbers will use the &quot;long&quot; overload.
+  // (SourceForge bug #495495)
+  inline long double min(long double __a, long double __b) {
+    return __b &lt; __a ? __b : __a;
+  }
+  inline long double max(long double __a, long double __b) {
+    return  __a &lt; __b ? __b : __a;
+  }
+}
+using std::min;
+using std::max;
+#     endif
+
+

Added: trunk/msvc-libs/include/boost/config/posix_features.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/posix_features.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/posix_features.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,87 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// All POSIX feature tests go in this file,
+// Note that we test _POSIX_C_SOURCE and _XOPEN_SOURCE as well
+// _POSIX_VERSION and _XOPEN_VERSION: on some systems POSIX API's
+// may be present but none-functional unless _POSIX_C_SOURCE and
+// _XOPEN_SOURCE have been defined to the right value (it's up
+// to the user to do this *before* including any header, although
+// in most cases the compiler will do this for you).
+
+#  if defined(BOOST_HAS_UNISTD_H)
+#     include &lt;unistd.h&gt;
+
+      // XOpen has &lt;nl_types.h&gt;, but is this the correct version check?
+#     if defined(_XOPEN_VERSION) &amp;&amp; (_XOPEN_VERSION &gt;= 3)
+#        define BOOST_HAS_NL_TYPES_H
+#     endif
+
+      // POSIX version 6 requires &lt;stdint.h&gt;
+#     if defined(_POSIX_VERSION) &amp;&amp; (_POSIX_VERSION &gt;= 200100)
+#        define BOOST_HAS_STDINT_H
+#     endif
+
+      // POSIX version 2 requires &lt;dirent.h&gt;
+#     if defined(_POSIX_VERSION) &amp;&amp; (_POSIX_VERSION &gt;= 199009L)
+#        define BOOST_HAS_DIRENT_H
+#     endif
+
+      // POSIX version 3 requires &lt;signal.h&gt; to have sigaction:
+#     if defined(_POSIX_VERSION) &amp;&amp; (_POSIX_VERSION &gt;= 199506L)
+#        define BOOST_HAS_SIGACTION
+#     endif
+      // POSIX defines _POSIX_THREADS &gt; 0 for pthread support,
+      // however some platforms define _POSIX_THREADS without
+      // a value, hence the (_POSIX_THREADS+0 &gt;= 0) check.
+      // Strictly speaking this may catch platforms with a
+      // non-functioning stub &lt;pthreads.h&gt;, but such occurrences should
+      // occur very rarely if at all.
+#     if defined(_POSIX_THREADS) &amp;&amp; (_POSIX_THREADS+0 &gt;= 0) &amp;&amp; !defined(BOOST_HAS_WINTHREADS) &amp;&amp; !defined(BOOST_HAS_MPTASKS)
+#        define BOOST_HAS_PTHREADS
+#     endif
+
+      // BOOST_HAS_NANOSLEEP:
+      // This is predicated on _POSIX_TIMERS or _XOPEN_REALTIME:
+#     if (defined(_POSIX_TIMERS) &amp;&amp; (_POSIX_TIMERS+0 &gt;= 0)) \
+             || (defined(_XOPEN_REALTIME) &amp;&amp; (_XOPEN_REALTIME+0 &gt;= 0))
+#        define BOOST_HAS_NANOSLEEP
+#     endif
+
+      // BOOST_HAS_CLOCK_GETTIME:
+      // This is predicated on _POSIX_TIMERS (also on _XOPEN_REALTIME
+      // but at least one platform - linux - defines that flag without
+      // defining clock_gettime):
+#     if (defined(_POSIX_TIMERS) &amp;&amp; (_POSIX_TIMERS+0 &gt;= 0))
+#        define BOOST_HAS_CLOCK_GETTIME
+#     endif
+
+      // BOOST_HAS_SCHED_YIELD:
+      // This is predicated on _POSIX_PRIORITY_SCHEDULING or
+      // on _POSIX_THREAD_PRIORITY_SCHEDULING or on _XOPEN_REALTIME.
+#     if defined(_POSIX_PRIORITY_SCHEDULING) &amp;&amp; (_POSIX_PRIORITY_SCHEDULING+0 &gt; 0)\
+            || (defined(_POSIX_THREAD_PRIORITY_SCHEDULING) &amp;&amp; (_POSIX_THREAD_PRIORITY_SCHEDULING+0 &gt; 0))\
+            || (defined(_XOPEN_REALTIME) &amp;&amp; (_XOPEN_REALTIME+0 &gt;= 0))
+#        define BOOST_HAS_SCHED_YIELD
+#     endif
+
+      // BOOST_HAS_GETTIMEOFDAY:
+      // BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE:
+      // These are predicated on _XOPEN_VERSION, and appears to be first released
+      // in issue 4, version 2 (_XOPEN_VERSION &gt; 500).
+#     if defined(_XOPEN_VERSION) &amp;&amp; (_XOPEN_VERSION+0 &gt;= 500)
+#        define BOOST_HAS_GETTIMEOFDAY
+#        if defined(_XOPEN_SOURCE) &amp;&amp; (_XOPEN_SOURCE &gt;= 500)
+#           define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#        endif
+#     endif
+
+#  endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/requires_threads.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/requires_threads.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/requires_threads.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,92 @@
+//  (C) Copyright John Maddock 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+#ifndef BOOST_CONFIG_REQUIRES_THREADS_HPP
+#define BOOST_CONFIG_REQUIRES_THREADS_HPP
+
+#ifndef BOOST_CONFIG_HPP
+#  include &lt;boost/config.hpp&gt;
+#endif
+
+#if defined(BOOST_DISABLE_THREADS)
+
+//
+// special case to handle versions of gcc which don't currently support threads:
+//
+#if defined(__GNUC__) &amp;&amp; ((__GNUC__ &lt; 3) || (__GNUC_MINOR__ &lt;= 3) || !defined(BOOST_STRICT_CONFIG))
+//
+// this is checked up to gcc 3.3:
+//
+#if defined(__sgi) || defined(__hpux)
+#  error &quot;Multi-threaded programs are not supported by gcc on HPUX or Irix (last checked with gcc 3.3)&quot;
+#endif
+
+#endif
+
+#  error &quot;Threading support unavaliable: it has been explicitly disabled with BOOST_DISABLE_THREADS&quot;
+
+#elif !defined(BOOST_HAS_THREADS)
+
+# if defined __COMO__
+//  Comeau C++
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -D_MT (Windows) or -D_REENTRANT (Unix)&quot;
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
+//  Intel
+#ifdef _WIN32
+#  error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: either /MT /MTd /MD or /MDd&quot;
+#else
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -openmp&quot;
+#endif
+
+# elif defined __GNUC__
+//  GNU C++:
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -pthread (Linux), -pthreads (Solaris) or -mthreads (Mingw32)&quot;
+
+#elif defined __sgi
+//  SGI MIPSpro C++
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -D_SGI_MP_SOURCE&quot;
+
+#elif defined __DECCXX
+//  Compaq Tru64 Unix cxx
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -pthread&quot;
+
+#elif defined __BORLANDC__
+//  Borland
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -tWM&quot;
+
+#elif defined  __MWERKS__
+//  Metrowerks CodeWarrior
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: either -runtime sm, -runtime smd, -runtime dm, or -runtime dmd&quot;
+
+#elif defined  __SUNPRO_CC
+//  Sun Workshop Compiler C++
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -mt&quot;
+
+#elif defined __HP_aCC
+//  HP aCC
+#   error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: -mt&quot;
+
+#elif defined(__IBMCPP__)
+//  IBM Visual Age
+#   error &quot;Compiler threading support is not turned on. Please compile the code with the xlC_r compiler&quot;
+
+#elif defined _MSC_VER
+//  Microsoft Visual C++
+//
+//  Must remain the last #elif since some other vendors (Metrowerks, for
+//  example) also #define _MSC_VER
+#  error &quot;Compiler threading support is not turned on. Please set the correct command line options for threading: either /MT /MTd /MD or /MDd&quot;
+
+#else
+
+#  error &quot;Compiler threading support is not turned on.  Please consult your compiler's documentation for the appropriate options to use&quot;
+
+#endif // compilers
+
+#endif // BOOST_HAS_THREADS
+
+#endif // BOOST_CONFIG_REQUIRES_THREADS_HPP

Added: trunk/msvc-libs/include/boost/config/select_compiler_config.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/select_compiler_config.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/select_compiler_config.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,83 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Martin Wille 2003.
+//  (C) Copyright Guillaume Melquiond 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// locate which compiler we are using and define
+// BOOST_COMPILER_CONFIG as needed: 
+
+# if defined __COMO__
+//  Comeau C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/comeau.hpp&quot;
+
+#elif defined __DMC__
+//  Digital Mars C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/digitalmars.hpp&quot;
+
+#elif defined(__INTEL_COMPILER) || defined(__ICL) || defined(__ICC) || defined(__ECC)
+//  Intel
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/intel.hpp&quot;
+
+# elif defined __GNUC__
+//  GNU C++:
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/gcc.hpp&quot;
+
+#elif defined __KCC
+//  Kai C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/kai.hpp&quot;
+
+#elif defined __sgi
+//  SGI MIPSpro C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/sgi_mipspro.hpp&quot;
+
+#elif defined __DECCXX
+//  Compaq Tru64 Unix cxx
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/compaq_cxx.hpp&quot;
+
+#elif defined __ghs
+//  Greenhills C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/greenhills.hpp&quot;
+
+#elif defined __BORLANDC__
+//  Borland
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/borland.hpp&quot;
+
+#elif defined  __MWERKS__
+//  Metrowerks CodeWarrior
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/metrowerks.hpp&quot;
+
+#elif defined  __SUNPRO_CC
+//  Sun Workshop Compiler C++
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/sunpro_cc.hpp&quot;
+
+#elif defined __HP_aCC
+//  HP aCC
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/hp_acc.hpp&quot;
+
+#elif defined(__MRC__) || defined(__SC__)
+//  MPW MrCpp or SCpp
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/mpw.hpp&quot;
+
+#elif defined(__IBMCPP__)
+//  IBM Visual Age
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/vacpp.hpp&quot;
+
+#elif defined _MSC_VER
+//  Microsoft Visual C++
+//
+//  Must remain the last #elif since some other vendors (Metrowerks, for
+//  example) also #define _MSC_VER
+#   define BOOST_COMPILER_CONFIG &quot;boost/config/compiler/visualc.hpp&quot;
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the compiler:
+#  error &quot;Unknown compiler - please configure (<A HREF="http://www.boost.org/libs/config/config.htm#configuring">http://www.boost.org/libs/config/config.htm#configuring</A>) and report the results to the main boost mailing list (<A HREF="http://www.boost.org/more/mailing_lists.htm#main">http://www.boost.org/more/mailing_lists.htm#main</A>)&quot;
+
+#endif

Added: trunk/msvc-libs/include/boost/config/select_platform_config.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/select_platform_config.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/select_platform_config.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,86 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// locate which platform we are on and define BOOST_PLATFORM_CONFIG as needed.
+// Note that we define the headers to include using &quot;header_name&quot; not
+// &lt;header_name&gt; in order to prevent macro expansion within the header
+// name (for example &quot;linux&quot; is a macro on linux systems).
+
+#if defined(linux) || defined(__linux) || defined(__linux__)
+// linux:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/linux.hpp&quot;
+
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+// BSD:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/bsd.hpp&quot;
+
+#elif defined(sun) || defined(__sun)
+// solaris:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/solaris.hpp&quot;
+
+#elif defined(__sgi)
+// SGI Irix:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/irix.hpp&quot;
+
+#elif defined(__hpux)
+// hp unix:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/hpux.hpp&quot;
+
+#elif defined(__CYGWIN__)
+// cygwin is not win32:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/cygwin.hpp&quot;
+
+#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
+// win32:
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/win32.hpp&quot;
+
+#elif defined(__BEOS__)
+// BeOS
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/beos.hpp&quot;
+
+#elif defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)
+// MacOS
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/macos.hpp&quot;
+
+#elif defined(__IBMCPP__)
+// IBM
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/aix.hpp&quot;
+
+#elif defined(__amigaos__)
+// AmigaOS
+#  define BOOST_PLATFORM_CONFIG &quot;boost/config/platform/amigaos.hpp&quot;
+
+#else
+
+#  if defined(unix) \
+      || defined(__unix) \
+      || defined(_XOPEN_SOURCE) \
+      || defined(_POSIX_SOURCE)
+
+   // generic unix platform:
+
+#  ifndef BOOST_HAS_UNISTD_H
+#     define BOOST_HAS_UNISTD_H
+#  endif
+
+#  include &lt;boost/config/posix_features.hpp&gt;
+
+#  endif
+
+#  if defined (BOOST_ASSERT_CONFIG)
+      // this must come last - generate an error if we don't
+      // recognise the platform:
+#     error &quot;Unknown platform - please configure and report the results to boost.org&quot;
+#  endif
+
+#endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/select_stdlib_config.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/select_stdlib_config.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/select_stdlib_config.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,68 @@
+//  Boost compiler configuration selection header file
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+// locate which std lib we are using and define BOOST_STDLIB_CONFIG as needed:
+
+// we need to include a std lib header here in order to detect which
+// library is in use, use &lt;utility&gt; as it's about the smallest
+// of the std lib headers - do not rely on this header being included -
+// users can short-circuit this header if they know whose std lib
+// they are using.
+
+#include &lt;utility&gt;
+
+#if defined(__SGI_STL_PORT) || defined(_STLPORT_VERSION)
+// STLPort library; this _must_ come first, otherwise since
+// STLport typically sits on top of some other library, we
+// can end up detecting that first rather than STLport:
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/stlport.hpp&quot;
+
+#elif defined(__LIBCOMO__)
+// Comeau STL:
+#define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/libcomo.hpp&quot;
+
+#elif defined(__STD_RWCOMPILER_H__) || defined(_RWSTD_VER)
+// Rogue Wave library:
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/roguewave.hpp&quot;
+
+#elif defined(__GLIBCPP__)
+// GNU libstdc++ 3
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/libstdcpp3.hpp&quot;
+
+#elif defined(__STL_CONFIG_H)
+// generic SGI STL
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/sgi.hpp&quot;
+
+#elif defined(__MSL_CPP__)
+// MSL standard lib:
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/msl.hpp&quot;
+
+#elif defined(__IBMCPP__)
+// take the default VACPP std lib
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/vacpp.hpp&quot;
+
+#elif defined(MSIPL_COMPILE_H)
+// Modena C++ standard library
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/modena.hpp&quot;
+
+#elif (defined(_YVALS) &amp;&amp; !defined(__IBMCPP__)) || defined(_CPPLIB_VER)
+// Dinkumware Library (this has to appear after any possible replacement libraries):
+#  define BOOST_STDLIB_CONFIG &quot;boost/config/stdlib/dinkumware.hpp&quot;
+
+#elif defined (BOOST_ASSERT_CONFIG)
+// this must come last - generate an error if we don't
+// recognise the library:
+#  error &quot;Unknown standard library - please configure and report the results to boost.org&quot;
+
+#endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/dinkumware.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/dinkumware.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/dinkumware.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,96 @@
+//  (C) Copyright John Maddock 2001 - 2003.
+//  (C) Copyright Jens Maurer 2001.
+//  (C) Copyright Peter Dimov 2001.
+//  (C) Copyright David Abrahams 2002.
+//  (C) Copyright Guillaume Melquiond 2003.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Dinkumware standard library config:
+
+#if !defined(_YVALS) &amp;&amp; !defined(_CPPLIB_VER)
+#include &lt;utility&gt;
+#if !defined(_YVALS) &amp;&amp; !defined(_CPPLIB_VER)
+#error This is not the Dinkumware lib!
+#endif
+#endif
+
+
+#if defined(_CPPLIB_VER) &amp;&amp; (_CPPLIB_VER &gt;= 306)
+   // full dinkumware 3.06 and above
+   // fully conforming provided the compiler supports it:
+#  if !(defined(_GLOBAL_USING) &amp;&amp; (_GLOBAL_USING+0 &gt; 0)) &amp;&amp; !defined(__BORLANDC__) &amp;&amp; !defined(_STD) &amp;&amp; !(defined(__ICC) &amp;&amp; (__ICC &gt;= 700))   // can be defined in yvals.h
+#     define BOOST_NO_STDC_NAMESPACE
+#  endif
+#  if !(defined(_HAS_MEMBER_TEMPLATES_REBIND) &amp;&amp; (_HAS_MEMBER_TEMPLATES_REBIND+0 &gt; 0)) &amp;&amp; !(defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt; 1300)) &amp;&amp; defined(BOOST_MSVC)
+#     define BOOST_NO_STD_ALLOCATOR
+#  endif
+#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#  if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1300)) &amp;&amp; !defined(__BORLANDC__)
+      // if this lib version is set up for vc6 then there is no std::use_facet:
+#     define BOOST_NO_STD_USE_FACET
+#     define BOOST_HAS_TWO_ARG_USE_FACET
+      // C lib functions aren't in namespace std either:
+#     define BOOST_NO_STDC_NAMESPACE
+      // and nor is &lt;exception&gt;
+#     define BOOST_NO_EXCEPTION_STD_NAMESPACE
+#  endif
+// There's no numeric_limits&lt;long long&gt; support unless _LONGLONG is defined:
+#  if !defined(_LONGLONG) &amp;&amp; (_CPPLIB_VER &lt;= 310)
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#  endif
+// 3.06 appears to have (non-sgi versions of) &lt;hash_set&gt; &amp; &lt;hash_map&gt;,
+// and no &lt;slist&gt; at all
+#else
+#  define BOOST_MSVC_STD_ITERATOR 1
+#  define BOOST_NO_STD_ITERATOR
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#  define BOOST_NO_STDC_NAMESPACE
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_NO_STD_OUTPUT_ITERATOR_ASSIGN
+#  define BOOST_HAS_MACRO_USE_FACET
+#  ifndef _CPPLIB_VER
+      // Updated Dinkum library defines this, and provides
+      // its own min and max definitions.
+#     define BOOST_NO_STD_MIN_MAX
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#  endif
+#endif
+
+
+#if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1300) &amp;&amp; !defined(__BORLANDC__)) || !defined(_CPPLIB_VER) || (_CPPLIB_VER &lt; 306)
+   // if we're using a dinkum lib that's
+   // been configured for VC6/7 then there is
+   // no iterator traits (true even for icl)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+#if defined(__ICL) &amp;&amp; defined(_CPPLIB_VER) &amp;&amp; (_CPPLIB_VER &lt;= 310)
+// Intel C++ chokes over any non-trivial use of &lt;locale&gt;
+// this may be an overly restrictive define, but regex fails without it:
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+#ifdef _CPPLIB_VER
+#  define BOOST_DINKUMWARE_STDLIB _CPPLIB_VER
+#else
+#  define BOOST_DINKUMWARE_STDLIB 1
+#endif
+
+#ifdef _CPPLIB_VER
+#  define BOOST_STDLIB &quot;Dinkumware standard library version &quot; BOOST_STRINGIZE(_CPPLIB_VER)
+#else
+#  define BOOST_STDLIB &quot;Dinkumware standard library version 1.x&quot;
+#endif
+
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/libcomo.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/libcomo.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/libcomo.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,37 @@
+//  (C) Copyright John Maddock 2002 - 2003. 
+//  (C) Copyright Jens Maurer 2002 - 2003. 
+//  (C) Copyright Beman Dawes 2002 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Comeau STL:
+
+#if !defined(__LIBCOMO__)
+#  include &lt;utility&gt;
+#  if !defined(__LIBCOMO__)
+#      error &quot;This is not the Comeau STL!&quot;
+#  endif
+#endif
+
+//
+// std::streambuf&lt;wchar_t&gt; is non-standard
+// NOTE: versions of libcomo prior to beta28 have octal version numbering,
+// e.g. version 25 is 21 (dec)
+#if __LIBCOMO_VERSION__ &lt;= 22
+#  define BOOST_NO_STD_WSTREAMBUF
+#endif
+
+//
+// Intrinsic type_traits support.
+// The SGI STL has it's own __type_traits class, which
+// has intrinsic compiler support with SGI's compilers.
+// Whatever map SGI style type traits to boost equivalents:
+//
+#define BOOST_HAS_SGI_TYPE_TRAITS
+
+#define BOOST_STDLIB &quot;Comeau standard library &quot; BOOST_STRINGIZE(__LIBCOMO_VERSION__)
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/libstdcpp3.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/libstdcpp3.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/libstdcpp3.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,27 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  config for libstdc++ v3
+//  not much to go in here:
+
+#define BOOST_STDLIB &quot;GNU libstdc++ version &quot; BOOST_STRINGIZE(__GLIBCPP__)
+
+#ifndef _GLIBCPP_USE_WCHAR_T
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_CWCTYPE
+#  define BOOST_NO_STD_WSTRING
+#  define BOOST_NO_STD_WSTREAMBUF
+#endif
+ 
+#ifndef _GLIBCPP_USE_LONG_LONG
+// May have been set by compiler/*.hpp, but &quot;long long&quot; without library
+// support is useless.
+#  undef BOOST_HAS_LONG_LONG
+#endif
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/modena.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/modena.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/modena.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,30 @@
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Modena C++ standard library (comes with KAI C++)
+
+#if !defined(MSIPL_COMPILE_H)
+#  include &lt;utility&gt;
+#  if !defined(__MSIPL_COMPILE_H)
+#      error &quot;This is not the Modena C++ library!&quot;
+#  endif
+#endif
+
+#ifndef MSIPL_NL_TYPES
+#define BOOST_NO_STD_MESSAGES
+#endif
+
+#ifndef MSIPL_WCHART
+#define BOOST_NO_STD_WSTRING
+#endif
+
+#define BOOST_STDLIB &quot;Modena C++ standard library&quot;
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/msl.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/msl.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/msl.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,52 @@
+//  (C) Copyright John Maddock 2001. 
+//  (C) Copyright Darin Adler 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Metrowerks standard library:
+
+#ifndef __MSL_CPP__
+#  include &lt;utility&gt;
+#  ifndef __MSL_CPP__
+#     error This is not the MSL standard library!
+#  endif
+#endif
+
+#if __MSL_CPP__ &gt;= 0x6000  // Pro 6
+#  define BOOST_HAS_HASH
+#  define BOOST_STD_EXTENSION_NAMESPACE Metrowerks
+#endif
+#define BOOST_HAS_SLIST
+
+#if __MSL_CPP__ &lt; 0x6209
+#  define BOOST_NO_STD_MESSAGES
+#endif
+
+// check C lib version for &lt;stdint.h&gt;
+#include &lt;cstddef&gt;
+
+#if defined(__MSL__) &amp;&amp; (__MSL__ &gt;= 0x5000)
+#  define BOOST_HAS_STDINT_H
+#  define BOOST_HAS_UNISTD_H
+   // boilerplate code:
+#  include &lt;boost/config/posix_features.hpp&gt;
+#endif
+
+#if defined(_MWMT) || _MSL_THREADSAFE
+#  define BOOST_HAS_THREADS
+#endif
+
+
+#define BOOST_STDLIB &quot;Metrowerks Standard Library version &quot; BOOST_STRINGIZE(__MSL_CPP__)
+
+
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/roguewave.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/roguewave.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/roguewave.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,121 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Jens Maurer 2001. 
+//  (C) Copyright David Abrahams 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Rogue Wave std lib:
+
+#if !defined(__STD_RWCOMPILER_H__) &amp;&amp; !defined(_RWSTD_VER)
+#  include &lt;utility&gt;
+#  if !defined(__STD_RWCOMPILER_H__) &amp;&amp; !defined(_RWSTD_VER)
+#     error This is not the Rogue Wave standard library
+#  endif
+#endif
+//
+// figure out a consistent version number:
+//
+#ifndef _RWSTD_VER
+#  define BOOST_RWSTD_VER 0x010000
+#elif _RWSTD_VER &lt; 0x010000
+#  define BOOST_RWSTD_VER (_RWSTD_VER &lt;&lt; 8)
+#else
+#  define BOOST_RWSTD_VER _RWSTD_VER
+#endif
+
+#ifndef _RWSTD_VER
+#  define BOOST_STDLIB &quot;Rogue Wave standard library version (Unknown version)&quot;
+#else
+#  define BOOST_STDLIB &quot;Rogue Wave standard library version &quot; BOOST_STRINGIZE(_RWSTD_VER)
+#endif
+
+//
+// Prior to version 2.2.0 the primary template for std::numeric_limits
+// does not have compile time constants, even though specializations of that
+// template do:
+//
+#if BOOST_RWSTD_VER &lt; 0x020200
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#endif
+
+#if BOOST_RWSTD_VER &lt;= 0x020101
+#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+# endif
+
+//
+// Borland version of numeric_limits lacks __int64 specialisation:
+//
+#ifdef __BORLANDC__
+#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#endif
+
+//
+// No std::iterator if it can't figure out default template args:
+//
+#if defined(_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) || defined(RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) || (BOOST_RWSTD_VER &lt; 0x020000)
+#  define BOOST_NO_STD_ITERATOR
+#endif
+
+//
+// No iterator traits without partial specialization:
+//
+#if defined(_RWSTD_NO_CLASS_PARTIAL_SPEC) || defined(RWSTD_NO_CLASS_PARTIAL_SPEC)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// Prior to version 2.0, std::auto_ptr was buggy, and there were no
+// new-style iostreams, and no conformant std::allocator:
+//
+#if (BOOST_RWSTD_VER &lt; 0x020000)
+#  define BOOST_NO_AUTO_PTR
+#  define BOOST_NO_STRINGSTREAM
+#  define BOOST_NO_STD_ALLOCATOR
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// No template iterator constructors without member template support:
+//
+#if defined(RWSTD_NO_MEMBER_TEMPLATES) || defined(_RWSTD_NO_MEMBER_TEMPLATES)
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#endif
+
+//
+// RW defines _RWSTD_ALLOCATOR if the allocator is conformant and in use
+// (the or _HPACC_ part is a hack - the library seems to define _RWSTD_ALLOCATOR
+// on HP aCC systems even though the allocator is in fact broken):
+//
+#if !defined(_RWSTD_ALLOCATOR) || (defined(__HP_aCC) &amp;&amp; __HP_aCC &lt;= 33100)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// If we have a std::locale, we still may not have std::use_facet:
+//
+#if defined(_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE) &amp;&amp; !defined(BOOST_NO_STD_LOCALE)
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_HAS_TWO_ARG_USE_FACET
+#endif
+
+//
+// There's no std::distance prior to version 2, or without
+// partial specialization support:
+//
+#if (BOOST_RWSTD_VER &lt; 0x020000) || defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)
+    #define BOOST_NO_STD_DISTANCE
+#endif
+
+//
+// Some versions of the rogue wave library don't have assignable
+// OutputIterators:
+//
+#if BOOST_RWSTD_VER &lt; 0x020100
+#  define BOOST_NO_STD_OUTPUT_ITERATOR_ASSIGN
+#endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/sgi.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/sgi.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/sgi.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,111 @@
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Jens Maurer 2001 - 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  generic SGI STL:
+
+#if !defined(__STL_CONFIG_H)
+#  include &lt;utility&gt;
+#  if !defined(__STL_CONFIG_H)
+#      error &quot;This is not the SGI STL!&quot;
+#  endif
+#endif
+
+//
+// No std::iterator traits without partial specialisation:
+//
+#if !defined(__STL_CLASS_PARTIAL_SPECIALIZATION)
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// No std::stringstream with gcc &lt; 3
+//
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3) &amp;&amp; \
+     ((__GNUC_MINOR__ &lt; 95) || (__GNUC_MINOR__ == 96)) &amp;&amp; \
+     !defined(__STL_USE_NEW_IOSTREAMS) || \
+   defined(__APPLE_CC__)
+   // Note that we only set this for GNU C++ prior to 2.95 since the
+   // latest patches for that release do contain a minimal &lt;sstream&gt;
+   // If you are running a 2.95 release prior to 2.95.3 then this will need
+   // setting, but there is no way to detect that automatically (other
+   // than by running the configure script).
+   // Also, the unofficial GNU C++ 2.96 included in RedHat 7.1 doesn't
+   // have &lt;sstream&gt;.
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// Assume no std::locale without own iostreams (this may be an
+// incorrect assumption in some cases):
+//
+#if !defined(__SGI_STL_OWN_IOSTREAMS) &amp;&amp; !defined(__STL_USE_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// Original native SGI streams have non-standard std::messages facet:
+//
+#if defined(__sgi) &amp;&amp; (_COMPILER_VERSION &lt;= 650) &amp;&amp; !defined(__SGI_STL_OWN_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#endif
+
+//
+// SGI's new iostreams have missing &quot;const&quot; in messages&lt;&gt;::open
+//
+#if defined(__sgi) &amp;&amp; (_COMPILER_VERSION &lt;= 740) &amp;&amp; defined(__STL_USE_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_MESSAGES
+#endif
+
+//
+// No template iterator constructors, or std::allocator
+// without member templates:
+//
+#if !defined(__STL_MEMBER_TEMPLATES)
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// We always have SGI style hash_set, hash_map, and slist:
+//
+#define BOOST_HAS_HASH
+#define BOOST_HAS_SLIST
+
+//
+// If this is GNU libstdc++2, then no &lt;limits&gt; and no std::wstring:
+//
+#if (defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3))
+#  include &lt;string&gt;
+#  if defined(__BASTRING__)
+#     define BOOST_NO_LIMITS
+// Note: &lt;boost/limits.hpp&gt; will provide compile-time constants
+#     undef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#     define BOOST_NO_STD_WSTRING
+#  endif
+#endif
+
+//
+// There is no standard iterator unless we have namespace support:
+//
+#if !defined(__STL_USE_NAMESPACES)
+#  define BOOST_NO_STD_ITERATOR
+#endif
+
+//
+// Intrinsic type_traits support.
+// The SGI STL has it's own __type_traits class, which
+// has intrinsic compiler support with SGI's compilers.
+// Whatever map SGI style type traits to boost equivalents:
+//
+#define BOOST_HAS_SGI_TYPE_TRAITS
+
+#define BOOST_STDLIB &quot;SGI standard library&quot;
+
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/stlport.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/stlport.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/stlport.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,169 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Jens Maurer 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  STLPort standard library config:
+
+#if !defined(__SGI_STL_PORT) &amp;&amp; !defined(_STLPORT_VERSION)
+#  include &lt;utility&gt;
+#  if !defined(__SGI_STL_PORT) &amp;&amp; !defined(_STLPORT_VERSION)
+#      error &quot;This is not STLPort!&quot;
+#  endif
+#endif
+
+//
+// __STL_STATIC_CONST_INIT_BUG implies BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+// for versions prior to 4.1(beta)
+//
+#if (defined(__STL_STATIC_CONST_INIT_BUG) || defined(_STLP_STATIC_CONST_INIT_BUG)) &amp;&amp; (__SGI_STL_PORT &lt;= 0x400)
+#  define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#endif
+
+//
+// If STLport thinks that there is no partial specialisation, then there is no
+// std::iterator traits:
+//
+#if !(defined(_STLP_CLASS_PARTIAL_SPECIALIZATION) || defined(__STL_CLASS_PARTIAL_SPECIALIZATION))
+#  define BOOST_NO_STD_ITERATOR_TRAITS
+#endif
+
+//
+// No new style iostreams on GCC without STLport's iostreams enabled:
+//
+#if (defined(__GNUC__) &amp;&amp; (__GNUC__ &lt; 3)) &amp;&amp; !(defined(__SGI_STL_OWN_IOSTREAMS) || defined(_STLP_OWN_IOSTREAMS))
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// No new iostreams implies no std::locale, and no std::stringstream:
+//
+#if defined(__STL_NO_IOSTREAMS) || defined(__STL_NO_NEW_IOSTREAMS) || defined(_STLP_NO_IOSTREAMS) || defined(_STLP_NO_NEW_IOSTREAMS)
+#  define BOOST_NO_STD_LOCALE
+#  define BOOST_NO_STRINGSTREAM
+#endif
+
+//
+// If the streams are not native, and we have a &quot;using ::x&quot; compiler bug
+// then the io stream facets are not available in namespace std::
+//
+#ifdef _STLPORT_VERSION
+#  if !defined(_STLP_OWN_IOSTREAMS) &amp;&amp; defined(_STLP_USE_NAMESPACES) &amp;&amp; defined(BOOST_NO_USING_TEMPLATE) &amp;&amp; !defined(__BORLANDC__)
+#     define BOOST_NO_STD_LOCALE
+#  endif
+#else
+#  if !defined(__SGI_STL_OWN_IOSTREAMS) &amp;&amp; defined(__STL_USE_NAMESPACES) &amp;&amp; defined(BOOST_NO_USING_TEMPLATE) &amp;&amp; !defined(__BORLANDC__)
+#     define BOOST_NO_STD_LOCALE
+#  endif
+#endif
+
+//
+// Without member template support enabled, their are no template
+// iterate constructors, and no std::allocator:
+//
+#if !(defined(__STL_MEMBER_TEMPLATES) || defined(_STLP_MEMBER_TEMPLATES))
+#  define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+//
+// however we always have at least a partial allocator:
+//
+#define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+
+#if !defined(_STLP_MEMBER_TEMPLATE_CLASSES)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+#if defined(_STLP_NO_MEMBER_TEMPLATE_KEYWORD) &amp;&amp; defined(BOOST_MSVC) &amp;&amp; (BOOST_MSVC &lt;= 1300)
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+//
+// We always have SGI style hash_set, hash_map, and slist:
+//
+#define BOOST_HAS_HASH
+#define BOOST_HAS_SLIST
+
+//
+// STLport does a good job of importing names into namespace std::,
+// but doesn't always get them all, define BOOST_NO_STDC_NAMESPACE, since our
+// workaround does not conflict with STLports:
+//
+//
+// Harold Howe says:
+// Borland switched to STLport in BCB6. Defining BOOST_NO_STDC_NAMESPACE with
+// BCB6 does cause problems. If we detect C++ Builder, then don't define 
+// BOOST_NO_STDC_NAMESPACE
+//
+#if !defined(__BORLANDC__) &amp;&amp; !defined(__DMC__)
+//
+// If STLport is using it's own namespace, and the real names are in
+// the global namespace, then we duplicate STLport's using declarations
+// (by defining BOOST_NO_STDC_NAMESPACE), we do this because STLport doesn't
+// necessarily import all the names we need into namespace std::
+// 
+#  if (defined(__STL_IMPORT_VENDOR_CSTD) \
+         || defined(__STL_USE_OWN_NAMESPACE) \
+         || defined(_STLP_IMPORT_VENDOR_CSTD) \
+         || defined(_STLP_USE_OWN_NAMESPACE)) \
+      &amp;&amp; (defined(__STL_VENDOR_GLOBAL_CSTD) || defined (_STLP_VENDOR_GLOBAL_CSTD))
+#     define BOOST_NO_STDC_NAMESPACE
+#     define BOOST_NO_EXCEPTION_STD_NAMESPACE
+#  endif
+#elif defined(__BORLANDC__) &amp;&amp; __BORLANDC__ &lt; 0x560
+// STLport doesn't import std::abs correctly:
+#include &lt;stdlib.h&gt;
+namespace std { using ::abs; }
+// and strcmp/strcpy don't get imported either ('cos they are macros)
+#include &lt;string.h&gt;
+#ifdef strcpy
+#  undef strcpy
+#endif
+#ifdef strcmp
+#  undef strcmp
+#endif
+#ifdef _STLP_VENDOR_CSTD
+namespace std{ using _STLP_VENDOR_CSTD::strcmp; using _STLP_VENDOR_CSTD::strcpy; }
+#endif
+#endif
+
+//
+// std::use_facet may be non-standard, uses a class instead:
+//
+#if defined(__STL_NO_EXPLICIT_FUNCTION_TMPL_ARGS) || defined(_STLP_NO_EXPLICIT_FUNCTION_TMPL_ARGS)
+#  define BOOST_NO_STD_USE_FACET
+#  define BOOST_HAS_STLP_USE_FACET
+#endif
+
+//
+// If STLport thinks there are no wide functions, &lt;cwchar&gt; etc. is not working; but
+// only if BOOST_NO_STDC_NAMESPACE is not defined (if it is then we do the import 
+// into std:: ourselves).
+//
+#if defined(_STLP_NO_NATIVE_WIDE_FUNCTIONS) &amp;&amp; !defined(BOOST_NO_STDC_NAMESPACE)
+#  define BOOST_NO_CWCHAR
+#  define BOOST_NO_CWCTYPE
+#endif
+
+//
+// Borland ships a version of STLport with C++ Builder 6 that lacks
+// hashtables and the like:
+//
+#if defined(__BORLANDC__) &amp;&amp; (__BORLANDC__ == 0x560)
+#  undef BOOST_HAS_HASH
+#endif
+
+
+#define BOOST_STDLIB &quot;STLPort standard library version &quot; BOOST_STRINGIZE(__SGI_STL_PORT)
+
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/config/stdlib/vacpp.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/stdlib/vacpp.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/stdlib/vacpp.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,17 @@
+//  (C) Copyright John Maddock 2001 - 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+#if __IBMCPP__ &lt;= 501
+#  define BOOST_NO_STD_ALLOCATOR
+#endif
+
+#define BOOST_HAS_MACRO_USE_FACET
+
+#define BOOST_STDLIB &quot;Visual Age default standard library&quot;
+
+
+

Added: trunk/msvc-libs/include/boost/config/suffix.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/suffix.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/suffix.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,508 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John Maddock 2001 - 2003. 
+//  (C) Copyright Darin Adler 2001. 
+//  (C) Copyright Peter Dimov 2001. 
+//  (C) Copyright Bill Kempf 2002. 
+//  (C) Copyright Jens Maurer 2002. 
+//  (C) Copyright David Abrahams 2002 - 2003. 
+//  (C) Copyright Gennaro Prota 2003. 
+//  (C) Copyright Eric Friedman 2003. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org">http://www.boost.org</A> for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  <A HREF="http://www.boost.org/libs/config">http://www.boost.org/libs/config</A>
+//
+//  This file is intended to be stable, and relatively unchanging.
+//  It should contain boilerplate code only - no compiler specific
+//  code unless it is unavoidable - no changes unless unavoidable.
+
+#ifndef BOOST_CONFIG_SUFFIX_HPP
+#define BOOST_CONFIG_SUFFIX_HPP
+
+//
+// look for long long by looking for the appropriate macros in &lt;limits.h&gt;.
+// Note that we use limits.h rather than climits for maximal portability,
+// remember that since these just declare a bunch of macros, there should be
+// no namespace issues from this.
+//
+#include &lt;limits.h&gt;
+# if !defined(BOOST_HAS_LONG_LONG)                                              \
+   &amp;&amp; !(defined(BOOST_MSVC) &amp;&amp; BOOST_MSVC &lt;=1300) &amp;&amp; !defined(__BORLANDC__)     \
+   &amp;&amp; (defined(ULLONG_MAX) || defined(ULONG_LONG_MAX) || defined(ULONGLONG_MAX))
+#  define BOOST_HAS_LONG_LONG
+#endif
+#if !defined(BOOST_HAS_LONG_LONG) &amp;&amp; !defined(BOOST_NO_INTEGRAL_INT64_T)
+#  define BOOST_NO_INTEGRAL_INT64_T
+#endif
+
+// GCC 3.x will clean up all of those nasty macro definitions that
+// BOOST_NO_CTYPE_FUNCTIONS is intended to help work around, so undefine
+// it under GCC 3.x.
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 3) &amp;&amp; defined(BOOST_NO_CTYPE_FUNCTIONS)
+#  undef BOOST_NO_CTYPE_FUNCTIONS
+#endif
+
+
+//
+// Assume any extensions are in namespace std:: unless stated otherwise:
+//
+#  ifndef BOOST_STD_EXTENSION_NAMESPACE
+#    define BOOST_STD_EXTENSION_NAMESPACE std
+#  endif
+
+//
+// If cv-qualified specializations are not allowed, then neither are cv-void ones:
+//
+#  if defined(BOOST_NO_CV_SPECIALIZATIONS) \
+      &amp;&amp; !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+#     define BOOST_NO_CV_VOID_SPECIALIZATIONS
+#  endif
+
+//
+// If there is no numeric_limits template, then it can't have any compile time
+// constants either!
+//
+#  if defined(BOOST_NO_LIMITS) \
+      &amp;&amp; !defined(BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS)
+#     define BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS
+#     define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#     define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#  endif
+
+//
+// if there is no long long then there is no specialisation
+// for numeric_limits&lt;long long&gt; either:
+//
+#if !defined(BOOST_HAS_LONG_LONG) &amp;&amp; !defined(BOOST_NO_LONG_LONG_NUMERIC_LIMITS)
+#  define BOOST_NO_LONG_LONG_NUMERIC_LIMITS
+#endif
+
+//
+// if there is no __int64 then there is no specialisation
+// for numeric_limits&lt;__int64&gt; either:
+//
+#if !defined(BOOST_HAS_MS_INT64) &amp;&amp; !defined(BOOST_NO_MS_INT64_NUMERIC_LIMITS)
+#  define BOOST_NO_MS_INT64_NUMERIC_LIMITS
+#endif
+
+//
+// if member templates are supported then so is the
+// VC6 subset of member templates:
+//
+#  if !defined(BOOST_NO_MEMBER_TEMPLATES) \
+       &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#     define BOOST_MSVC6_MEMBER_TEMPLATES
+#  endif
+
+//
+// Without partial specialization, can't test for partial specialisation bugs:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      &amp;&amp; !defined(BOOST_BCB_PARTIAL_SPECIALIZATION_BUG)
+#     define BOOST_BCB_PARTIAL_SPECIALIZATION_BUG
+#  endif
+
+//
+// Without partial specialization, we can't have array-type partial specialisations:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      &amp;&amp; !defined(BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS)
+#     define BOOST_NO_ARRAY_TYPE_SPECIALIZATIONS
+#  endif
+
+//
+// Without partial specialization, std::iterator_traits can't work:
+//
+#  if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) \
+      &amp;&amp; !defined(BOOST_NO_STD_ITERATOR_TRAITS)
+#     define BOOST_NO_STD_ITERATOR_TRAITS
+#  endif
+
+//
+// Without member template support, we can't have template constructors
+// in the standard library either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS)
+#     define BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
+#  endif
+
+//
+// Without member template support, we can't have a conforming
+// std::allocator template either:
+//
+#  if defined(BOOST_NO_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES) \
+      &amp;&amp; !defined(BOOST_NO_STD_ALLOCATOR)
+#     define BOOST_NO_STD_ALLOCATOR
+#  endif
+
+//
+// without ADL support then using declarations will break ADL as well:
+//
+#if defined(BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP) &amp;&amp; !defined(BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL)
+#  define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
+#endif
+
+//
+// If we have a standard allocator, then we have a partial one as well:
+//
+#if !defined(BOOST_NO_STD_ALLOCATOR)
+#  define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#endif
+
+//
+// We can't have a working std::use_facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) &amp;&amp; !defined(BOOST_NO_STD_USE_FACET)
+#     define BOOST_NO_STD_USE_FACET
+#  endif
+
+//
+// We can't have a std::messages facet if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) &amp;&amp; !defined(BOOST_NO_STD_MESSAGES)
+#     define BOOST_NO_STD_MESSAGES
+#  endif
+
+//
+// We can't have a working std::wstreambuf if there is no std::locale:
+//
+#  if defined(BOOST_NO_STD_LOCALE) &amp;&amp; !defined(BOOST_NO_STD_WSTREAMBUF)
+#     define BOOST_NO_STD_WSTREAMBUF
+#  endif
+
+//
+// We can't have a &lt;cwctype&gt; if there is no &lt;cwchar&gt;:
+//
+#  if defined(BOOST_NO_CWCHAR) &amp;&amp; !defined(BOOST_NO_CWCTYPE)
+#     define BOOST_NO_CWCTYPE
+#  endif
+
+//
+// We can't have a swprintf if there is no &lt;cwchar&gt;:
+//
+#  if defined(BOOST_NO_CWCHAR) &amp;&amp; !defined(BOOST_NO_SWPRINTF)
+#     define BOOST_NO_SWPRINTF
+#  endif
+
+//
+// If Win32 support is turned off, then we must turn off
+// threading support also, unless there is some other
+// thread API enabled:
+//
+#if defined(BOOST_DISABLE_WIN32) &amp;&amp; defined(_WIN32) \
+   &amp;&amp; !defined(BOOST_DISABLE_THREADS) &amp;&amp; !defined(BOOST_HAS_PTHREADS)
+#  define BOOST_DISABLE_THREADS
+#endif
+
+//
+// Turn on threading support if the compiler thinks that it's in
+// multithreaded mode.  We put this here because there are only a
+// limited number of macros that identify this (if there's any missing
+// from here then add to the appropriate compiler section):
+//
+#if (defined(__MT__) || defined(_MT) || defined(_REENTRANT) \
+    || defined(_PTHREADS)) &amp;&amp; !defined(BOOST_HAS_THREADS)
+#  define BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if BOOST_DISABLE_THREADS is defined:
+//
+#if defined(BOOST_DISABLE_THREADS) &amp;&amp; defined(BOOST_HAS_THREADS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading support off if we don't recognise the threading API:
+//
+#if defined(BOOST_HAS_THREADS) &amp;&amp; !defined(BOOST_HAS_PTHREADS)\
+      &amp;&amp; !defined(BOOST_HAS_WINTHREADS) &amp;&amp; !defined(BOOST_HAS_BETHREADS)\
+      &amp;&amp; !defined(BOOST_HAS_MPTASKS)
+#  undef BOOST_HAS_THREADS
+#endif
+
+//
+// Turn threading detail macros off if we don't (want to) use threading
+//
+#ifndef BOOST_HAS_THREADS
+#  undef BOOST_HAS_PTHREADS
+#  undef BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#  undef BOOST_HAS_WINTHREADS
+#  undef BOOST_HAS_BETHREADS
+#  undef BOOST_HAS_MPTASKS
+#endif
+
+//
+// If the compiler claims to be C99 conformant, then it had better
+// have a &lt;stdint.h&gt;:
+//
+#  if defined(__STDC_VERSION__) &amp;&amp; (__STDC_VERSION__ &gt;= 199901)
+#     define BOOST_HAS_STDINT_H
+#  endif
+
+//
+// Define BOOST_NO_SLIST and BOOST_NO_HASH if required.
+// Note that this is for backwards compatibility only.
+//
+#  ifndef BOOST_HAS_SLIST
+#     define BOOST_NO_SLIST
+#  endif
+
+#  ifndef BOOST_HAS_HASH
+#     define BOOST_NO_HASH
+#  endif
+
+//  BOOST_HAS_ABI_HEADERS
+//  This macro gets set if we have headers that fix the ABI,
+//  and prevent ODR violations when linking to external libraries:
+#if defined(BOOST_ABI_PREFIX) &amp;&amp; defined(BOOST_ABI_SUFFIX) &amp;&amp; !defined(BOOST_HAS_ABI_HEADERS)
+#  define BOOST_HAS_ABI_HEADERS
+#endif
+
+#if defined(BOOST_HAS_ABI_HEADERS) &amp;&amp; defined(BOOST_DISABLE_ABI_HEADERS)
+#  undef BOOST_HAS_ABI_HEADERS
+#endif
+
+//  BOOST_NO_STDC_NAMESPACE workaround  --------------------------------------//
+//  Because std::size_t usage is so common, even in boost headers which do not
+//  otherwise use the C library, the &lt;cstddef&gt; workaround is included here so
+//  that ugly workaround code need not appear in many other boost headers.
+//  NOTE WELL: This is a workaround for non-conforming compilers; &lt;cstddef&gt; 
+//  must still be #included in the usual places so that &lt;cstddef&gt; inclusion
+//  works as expected with standard conforming compilers.  The resulting
+//  double inclusion of &lt;cstddef&gt; is harmless.
+
+# ifdef BOOST_NO_STDC_NAMESPACE
+#   include &lt;cstddef&gt;
+    namespace std { using ::ptrdiff_t; using ::size_t; }
+# endif
+
+//  BOOST_NO_STD_MIN_MAX workaround  -----------------------------------------//
+
+#  ifdef BOOST_NO_STD_MIN_MAX
+
+namespace std {
+  template &lt;class _Tp&gt;
+  inline const _Tp&amp; min(const _Tp&amp; __a, const _Tp&amp; __b) {
+    return __b &lt; __a ? __b : __a;
+  }
+  template &lt;class _Tp&gt;
+  inline const _Tp&amp; max(const _Tp&amp; __a, const _Tp&amp; __b) {
+    return  __a &lt; __b ? __b : __a;
+  }
+}
+
+#  endif
+
+// BOOST_STATIC_CONSTANT workaround --------------------------------------- //
+// On compilers which don't allow in-class initialization of static integral
+// constant members, we must use enums as a workaround if we want the constants
+// to be available at compile-time. This macro gives us a convenient way to
+// declare such constants.
+
+#  ifdef BOOST_NO_INCLASS_MEMBER_INITIALIZATION
+#       define BOOST_STATIC_CONSTANT(type, assignment) enum { assignment }
+#  else
+#     define BOOST_STATIC_CONSTANT(type, assignment) static const type assignment
+#  endif
+
+// BOOST_USE_FACET workaround ----------------------------------------------//
+// When the standard library does not have a conforming std::use_facet there
+// are various workarounds available, but they differ from library to library.
+// This macro provides a consistent way to access a locale's facets.
+// Usage:
+//    replace
+//       std::use_facet&lt;Type&gt;(loc);
+//    with
+//       BOOST_USE_FACET(Type, loc);
+//    Note do not add a std:: prefix to the front of BOOST_USE_FACET!
+
+#if defined(BOOST_NO_STD_USE_FACET)
+#  ifdef BOOST_HAS_TWO_ARG_USE_FACET
+#     define BOOST_USE_FACET(Type, loc) std::use_facet(loc, static_cast&lt;Type*&gt;(0))
+#  elif defined(BOOST_HAS_MACRO_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) std::_USE(loc, Type)
+#  elif defined(BOOST_HAS_STLP_USE_FACET)
+#     define BOOST_USE_FACET(Type, loc) (*std::_Use_facet&lt;Type &gt;(loc))
+#  endif
+#else
+#  define BOOST_USE_FACET(Type, loc) std::use_facet&lt; Type &gt;(loc)
+#endif
+
+// BOOST_NESTED_TEMPLATE workaround ------------------------------------------//
+// Member templates are supported by some compilers even though they can't use
+// the A::template member&lt;U&gt; syntax, as a workaround replace:
+//
+// typedef typename A::template rebind&lt;U&gt; binder;
+//
+// with:
+//
+// typedef typename A::BOOST_NESTED_TEMPLATE rebind&lt;U&gt; binder;
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_KEYWORD
+#  define BOOST_NESTED_TEMPLATE template
+#else
+#  define BOOST_NESTED_TEMPLATE
+#endif
+
+// BOOST_UNREACHABLE_RETURN(x) workaround -------------------------------------//
+// Normally evaluates to nothing, unless BOOST_NO_UNREACHABLE_RETURN_DETECTION
+// is defined, in which case it evaluates to return x; Use when you have a return
+// statement that can never be reached.
+
+#ifdef BOOST_NO_UNREACHABLE_RETURN_DETECTION
+#  define BOOST_UNREACHABLE_RETURN(x) return x;
+#else
+#  define BOOST_UNREACHABLE_RETURN(x)
+#endif
+
+// BOOST_DEDUCED_TYPENAME workaround ------------------------------------------//
+//
+// Some compilers don't support the use of `typename' for dependent
+// types in deduced contexts, e.g.
+//
+//     template &lt;class T&gt; void f(T, typename T::type);
+//                                  ^^^^^^^^
+// Replace these declarations with:
+//
+//     template &lt;class T&gt; void f(T, BOOST_DEDUCED_TYPENAME T::type);
+
+#ifndef BOOST_NO_DEDUCED_TYPENAME
+#  define BOOST_DEDUCED_TYPENAME typename
+#else 
+#  define BOOST_DEDUCED_TYPENAME
+#endif
+
+// BOOST_[APPEND_]EXPLICIT_TEMPLATE_[NON_]TYPE macros --------------------------//
+//
+// Some compilers have problems with function templates whose
+// template parameters don't appear in the function parameter
+// list (basically they just link one instantiation of the
+// template in the final executable). These macros provide a
+// uniform way to cope with the problem with no effects on the
+// calling syntax.
+
+// Example:
+//
+//  #include &lt;iostream&gt;
+//  #include &lt;ostream&gt;
+//  #include &lt;typeinfo&gt;
+//
+//  template &lt;int n&gt;
+//  void f() { std::cout &lt;&lt; n &lt;&lt; ' '; }
+//
+//  template &lt;typename T&gt;
+//  void g() { std::cout &lt;&lt; typeid(T).name() &lt;&lt; ' '; }
+//
+//  int main() {
+//    f&lt;1&gt;();
+//    f&lt;2&gt;();
+//
+//    g&lt;int&gt;();
+//    g&lt;double&gt;();
+//  }
+//
+// With VC++ 6.0 the output is:
+//
+//   2 2 double double
+//
+// To fix it, write
+//
+//   template &lt;int n&gt;
+//   void f(BOOST_EXPLICIT_TEMPLATE_NON_TYPE(int, n)) { ... }
+//
+//   template &lt;typename T&gt;
+//   void g(BOOST_EXPLICIT_TEMPLATE_TYPE(T)) { ... }
+//
+
+
+#if defined BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+
+#  include &quot;boost/type.hpp&quot;
+#  include &quot;boost/non_type.hpp&quot;
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)         boost::type&lt;t&gt;* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)    boost::type&lt;t&gt;*
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)  boost::non_type&lt;t, v&gt;* = 0
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)  boost::non_type&lt;t, v&gt;*
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)         \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)    \
+             , BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)  \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)  \
+             , BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#else
+
+// no workaround needed: expand to nothing
+
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_TYPE_SPEC(t)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(t, v)
+#  define BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE_SPEC(t, v)
+
+
+#endif // defined BOOST_NO_EXPLICIT_FUNCTION_TEMPLATE_ARGUMENTS
+
+
+// ---------------------------------------------------------------------------//
+
+//
+// Helper macro BOOST_STRINGIZE:
+// Converts the parameter X to a string after macro replacement
+// on X has been performed.
+//
+#define BOOST_STRINGIZE(X) BOOST_DO_STRINGIZE(X)
+#define BOOST_DO_STRINGIZE(X) #X
+
+//
+// Helper macro BOOST_JOIN:
+// The following piece of macro magic joins the two 
+// arguments together, even when one of the arguments is
+// itself a macro (see 16.3.1 in C++ standard).  The key
+// is that macro expansion of macro arguments does not
+// occur in BOOST_DO_JOIN2 but does in BOOST_DO_JOIN.
+//
+#define BOOST_JOIN( X, Y ) BOOST_DO_JOIN( X, Y )
+#define BOOST_DO_JOIN( X, Y ) BOOST_DO_JOIN2(X,Y)
+#define BOOST_DO_JOIN2( X, Y ) X##Y
+
+//
+// Set some default values for compiler/library/platform names.
+// These are for debugging config setup only:
+//
+#  ifndef BOOST_COMPILER
+#     define BOOST_COMPILER &quot;Unknown ISO C++ Compiler&quot;
+#  endif
+#  ifndef BOOST_STDLIB
+#     define BOOST_STDLIB &quot;Unknown ISO standard library&quot;
+#  endif
+#  ifndef BOOST_PLATFORM
+#     if defined(unix) || defined(__unix) || defined(_XOPEN_SOURCE) \
+         || defined(_POSIX_SOURCE)
+#        define BOOST_PLATFORM &quot;Generic Unix&quot;
+#     else
+#        define BOOST_PLATFORM &quot;Unknown&quot;
+#     endif
+#  endif
+
+#endif
+
+
+

Added: trunk/msvc-libs/include/boost/config/user.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config/user.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config/user.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,124 @@
+//  boost/config/user.hpp  ---------------------------------------------------//
+
+//  (C) Copyright John Maddock 2001. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  Do not check in modified versions of this file,
+//  This file may be customized by the end user, but not by boost.
+
+//
+//  Use this file to define a site and compiler specific
+//  configuration policy:
+//
+
+// define this to locate a compiler config file:
+// #define BOOST_COMPILER_CONFIG &lt;myheader&gt;
+
+// define this to locate a stdlib config file:
+// #define BOOST_STDLIB_CONFIG   &lt;myheader&gt;
+
+// define this to locate a platform config file:
+// #define BOOST_PLATFORM_CONFIG &lt;myheader&gt;
+
+// define this to disable compiler config,
+// use if your compiler config has nothing to set:
+// #define BOOST_NO_COMPILER_CONFIG
+
+// define this to disable stdlib config,
+// use if your stdlib config has nothing to set:
+// #define BOOST_NO_STDLIB_CONFIG
+
+// define this to disable platform config,
+// use if your platform config has nothing to set:
+// #define BOOST_NO_PLATFORM_CONFIG
+
+// define this to disable all config options,
+// excluding the user config.  Use if your
+// setup is fully ISO compliant, and has no
+// useful extensions, or for autoconf generated
+// setups:
+// #define BOOST_NO_CONFIG
+
+// define this to make the config &quot;optimistic&quot;
+// about unknown compiler versions.  Normally
+// unknown compiler versions are assumed to have
+// all the defects of the last known version, however
+// setting this flag, causes the config to assume
+// that unknown compiler versions are fully conformant
+// with the standard:
+// #define BOOST_STRICT_CONFIG
+
+// define this to cause the config to halt compilation
+// with an #error if it encounters anything unknown --
+// either an unknown compiler version or an unknown
+// compiler/platform/library:
+// #define BOOST_ASSERT_CONFIG
+
+
+// define if you want to disable threading support, even
+// when available:
+// #define BOOST_DISABLE_THREADS
+
+// define when you want to disable Win32 specific features
+// even when available:
+// #define BOOST_DISABLE_WIN32
+
+// BOOST_DISABLE_ABI_HEADERS: Stops boost headers from including any 
+// prefix/suffix headers that normally control things like struct 
+// packing and alignment. 
+// #define BOOST_DISABLE_ABI_HEADERS
+
+// BOOST_ABI_PREFIX: A prefix header to include in place of whatever
+// boost.config would normally select, any replacement should set up 
+// struct packing and alignment options as required. 
+// #define BOOST_ABI_PREFIX my-header-name
+
+// BOOST_ABI_SUFFIX: A suffix header to include in place of whatever 
+// boost.config would normally select, any replacement should undo 
+// the effects of the prefix header. 
+// #define BOOST_ABI_SUFFIX my-header-name
+
+// BOOST_ALL_DYN_LINK: Forces all libraries that have separate source, 
+// to be linked as dll's rather than static libraries on Microsoft Windows 
+// (this macro is used to turn on __declspec(dllimport) modifiers, so that 
+// the compiler knows which symbols to look for in a dll rather than in a 
+// static library).  Note that there may be some libraries that can only 
+// be statically linked (Boost.Test for example) and others which may only 
+// be dynamically linked (Boost.Threads for example), in these cases this 
+// macro has no effect.
+// #define BOOST_ALL_DYN_LINK
+ 
+// BOOST_WHATEVER_DYN_LINK: Forces library &quot;whatever&quot; to be linked as a dll 
+// rather than a static library on Microsoft Windows: replace the WHATEVER 
+// part of the macro name with the name of the library that you want to 
+// dynamically link to, for example use BOOST_DATE_TIME_DYN_LINK or 
+// BOOST_REGEX_DYN_LINK etc (this macro is used to turn on __declspec(dllimport) 
+// modifiers, so that the compiler knows which symbols to look for in a dll 
+// rather than in a static library).  
+// Note that there may be some libraries that can only be statically linked 
+// (Boost.Test for example) and others which may only be dynamically linked 
+// (Boost.Threads for example), in these cases this macro is unsupported.
+// #define BOOST_WHATEVER_DYN_LINK
+ 
+// BOOST_ALL_NO_LIB: Tells the config system not to automatically select 
+// which libraries to link against.  
+// Normally if a compiler supports #pragma lib, then the correct library 
+// build variant will be automatically selected and linked against, 
+// simply by the act of including one of that library's headers.  
+// This macro turns that feature off.
+// #define BOOST_ALL_NO_LIB
+ 
+// BOOST_WHATEVER_NO_LIB: Tells the config system not to automatically 
+// select which library to link against for library &quot;whatever&quot;, 
+// replace WHATEVER in the macro name with the name of the library; 
+// for example BOOST_DATE_TIME_NO_LIB or BOOST_REGEX_NO_LIB.  
+// Normally if a compiler supports #pragma lib, then the correct library 
+// build variant will be automatically selected and linked against, simply 
+// by the act of including one of that library's headers.  This macro turns 
+// that feature off.
+// #define BOOST_WHATEVER_NO_LIB
+ 
+
+

Added: trunk/msvc-libs/include/boost/config.hpp
===================================================================
--- trunk/msvc-libs/include/boost/config.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/config.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,70 @@
+//  Boost config.hpp configuration header file  ------------------------------//
+
+//  (C) Copyright John Maddock 2002. 
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
+
+//  See <A HREF="http://www.boost.org/libs/config">http://www.boost.org/libs/config</A> for most recent version.
+
+//  Boost config.hpp policy and rationale documentation has been moved to
+//  <A HREF="http://www.boost.org/libs/config">http://www.boost.org/libs/config</A>
+//
+//  CAUTION: This file is intended to be completely stable -
+//           DO NOT MODIFY THIS FILE!
+//
+
+#ifndef BOOST_CONFIG_HPP
+#define BOOST_CONFIG_HPP
+
+// if we don't have a user config, then use the default location:
+#if !defined(BOOST_USER_CONFIG) &amp;&amp; !defined(BOOST_NO_USER_CONFIG)
+#  define BOOST_USER_CONFIG &lt;boost/config/user.hpp&gt;
+#endif
+// include it first:
+#ifdef BOOST_USER_CONFIG
+#  include BOOST_USER_CONFIG
+#endif
+
+// if we don't have a compiler config set, try and find one:
+#if !defined(BOOST_COMPILER_CONFIG) &amp;&amp; !defined(BOOST_NO_COMPILER_CONFIG) &amp;&amp; !defined(BOOST_NO_CONFIG)
+#  include &lt;boost/config/select_compiler_config.hpp&gt;
+#endif
+// if we have a compiler config, include it now:
+#ifdef BOOST_COMPILER_CONFIG
+#  include BOOST_COMPILER_CONFIG
+#endif
+
+// if we don't have a std library config set, try and find one:
+#if !defined(BOOST_STDLIB_CONFIG) &amp;&amp; !defined(BOOST_NO_STDLIB_CONFIG) &amp;&amp; !defined(BOOST_NO_CONFIG)
+#  include &lt;boost/config/select_stdlib_config.hpp&gt;
+#endif
+// if we have a std library config, include it now:
+#ifdef BOOST_STDLIB_CONFIG
+#  include BOOST_STDLIB_CONFIG
+#endif
+
+// if we don't have a platform config set, try and find one:
+#if !defined(BOOST_PLATFORM_CONFIG) &amp;&amp; !defined(BOOST_NO_PLATFORM_CONFIG) &amp;&amp; !defined(BOOST_NO_CONFIG)
+#  include &lt;boost/config/select_platform_config.hpp&gt;
+#endif
+// if we have a platform config, include it now:
+#ifdef BOOST_PLATFORM_CONFIG
+#  include BOOST_PLATFORM_CONFIG
+#endif
+
+// get config suffix code:
+#include &lt;boost/config/suffix.hpp&gt;
+
+#endif  // BOOST_CONFIG_HPP
+
+
+
+
+
+
+
+
+
+
+

Added: trunk/msvc-libs/include/boost/detail/lightweight_mutex.hpp
===================================================================
--- trunk/msvc-libs/include/boost/detail/lightweight_mutex.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/detail/lightweight_mutex.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,99 @@
+#ifndef BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED
+#define BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lightweight_mutex.hpp - lightweight mutex
+//
+//  Copyright (c) 2002, 2003 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  typedef &lt;unspecified&gt; boost::detail::lightweight_mutex;
+//
+//  boost::detail::lightweight_mutex meets a subset of the Mutex concept
+//  requirements: <A HREF="http://www.boost.org/libs/thread/doc/mutex_concept.html#Mutex">http://www.boost.org/libs/thread/doc/mutex_concept.html#Mutex</A>
+//
+//  * Used by the smart pointer library
+//  * Performance oriented
+//  * Header-only implementation
+//  * Small memory footprint
+//  * Not a general purpose mutex, use boost::mutex, CRITICAL_SECTION or
+//    pthread_mutex instead.
+//  * Never spin in a tight lock/do-something/unlock loop, since
+//    lightweight_mutex does not guarantee fairness.
+//  * Never keep a lightweight_mutex locked for long periods.
+//
+//  The current implementation can use a pthread_mutex, a CRITICAL_SECTION,
+//  or a platform-specific spinlock.
+//
+//  You can force a particular implementation by defining BOOST_LWM_USE_PTHREADS,
+//  BOOST_LWM_USE_CRITICAL_SECTION, or BOOST_LWM_USE_SPINLOCK.
+//
+//  If neither macro has been defined, the default is to use a spinlock on Win32,
+//  and a pthread_mutex otherwise.
+//
+//  Note that a spinlock is not a general synchronization primitive. In particular,
+//  it is not guaranteed to be a memory barrier, and it is possible to &quot;livelock&quot;
+//  if a lower-priority thread has acquired the spinlock but a higher-priority
+//  thread is spinning trying to acquire the same lock.
+//
+//  For these reasons, spinlocks have been disabled by default except on Windows,
+//  where a spinlock can be several orders of magnitude faster than a CRITICAL_SECTION.
+
+
+//  Note: lwm_linux.hpp has been disabled by default; see the comments
+//        inside for more info.
+
+
+#include &lt;boost/config.hpp&gt;
+
+//  Note to implementors: if you write a platform-specific spinlock
+//  for a platform that supports pthreads, be sure to test its performance
+//  against the pthreads-based version using shared_ptr_timing_test.cpp and
+//  shared_ptr_mt_test.cpp. Custom versions are usually not worth the trouble
+//  _unless_ the performance gains are substantial.
+//
+//  Be sure to compare against a &quot;real&quot; pthreads library;
+//  shared_ptr_timing_test.cpp will compile succesfully with a stub do-nothing
+//  pthreads library, since it doesn't create any threads.
+
+#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)) &amp;&amp; !defined(BOOST_LWM_USE_CRITICAL_SECTION) &amp;&amp; !defined(BOOST_LWM_USE_PTHREADS)
+# define BOOST_LWM_WIN32
+#endif
+
+#if !defined(BOOST_HAS_THREADS)
+#  if defined(BOOST_LWM_WIN32)
+#    include &lt;boost/detail/lwm_win32_nt.hpp&gt;
+#  else
+#    include &lt;boost/detail/lwm_nop.hpp&gt;
+#  endif
+#elif defined(BOOST_LWM_USE_SPINLOCK) &amp;&amp; defined(BOOST_USE_ASM_ATOMIC_H)
+#  include &lt;boost/detail/lwm_linux.hpp&gt;
+#elif defined(BOOST_LWM_USE_CRITICAL_SECTION)
+#  include &lt;boost/detail/lwm_win32_cs.hpp&gt;
+#elif defined(BOOST_LWM_USE_PTHREADS)
+#  include &lt;boost/detail/lwm_pthreads.hpp&gt;
+#elif defined(BOOST_LWM_WIN32)
+#  include &lt;boost/detail/lwm_win32.hpp&gt;
+#elif defined(BOOST_LWM_USE_SPINLOCK) &amp;&amp; defined(__sgi)
+#  include &lt;boost/detail/lwm_irix.hpp&gt;
+#elif defined(BOOST_LWM_USE_SPINLOCK) &amp;&amp; defined(__GLIBCPP__)
+#  include &lt;boost/detail/lwm_gcc.hpp&gt;
+#elif defined(BOOST_HAS_PTHREADS)
+#  define BOOST_LWM_USE_PTHREADS
+#  include &lt;boost/detail/lwm_pthreads.hpp&gt;
+#else
+// Use #define BOOST_DISABLE_THREADS to avoid the error
+#  error Unrecognized threading platform
+#endif
+
+#endif // #ifndef BOOST_DETAIL_LIGHTWEIGHT_MUTEX_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/detail/lwm_win32.hpp
===================================================================
--- trunk/msvc-libs/include/boost/detail/lwm_win32.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/detail/lwm_win32.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,123 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#ifdef BOOST_USE_WINDOWS_H
+#  include &lt;windows.h&gt;
+#endif
+
+#ifdef __BORLANDC__
+# pragma warn -8027     // Functions containing while are not expanded inline
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+#ifndef BOOST_USE_WINDOWS_H
+
+#ifdef _WIN64
+
+// Intel 6.0 on Win64 version, posted by Tim Fenders to [boost-users]
+
+extern &quot;C&quot; long_type __cdecl _InterlockedExchange(long volatile *, long);
+
+#pragma intrinsic(_InterlockedExchange)
+
+inline long InterlockedExchange(long volatile* lp, long l)
+{
+    return _InterlockedExchange(lp, l);
+}
+
+#else  // _WIN64
+
+extern &quot;C&quot; __declspec(dllimport) long __stdcall InterlockedExchange(long volatile *, long);
+
+#endif // _WIN64
+
+extern &quot;C&quot; __declspec(dllimport) void __stdcall Sleep(unsigned long);
+
+#endif // #ifndef BOOST_USE_WINDOWS_H
+
+class lightweight_mutex
+{
+private:
+
+    long l_;
+
+    lightweight_mutex(lightweight_mutex const &amp;);
+    lightweight_mutex &amp; operator=(lightweight_mutex const &amp;);
+
+public:
+
+    lightweight_mutex(): l_(0)
+    {
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        lightweight_mutex &amp; m_;
+
+        scoped_lock(scoped_lock const &amp;);
+        scoped_lock &amp; operator=(scoped_lock const &amp;);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex &amp; m): m_(m)
+        {
+            while( InterlockedExchange(&amp;m_.l_, 1) )
+            {
+                // Note: changed to Sleep(1) from Sleep(0).
+                // According to MSDN, Sleep(0) will never yield
+                // to a lower-priority thread, whereas Sleep(1)
+                // will. Performance seems not to be affected.
+
+                Sleep(1);
+            }
+        }
+
+        ~scoped_lock()
+        {
+            InterlockedExchange(&amp;m_.l_, 0);
+
+            // Note: adding a yield here will make
+            // the spinlock more fair and will increase the overall
+            // performance of some applications substantially in
+            // high contention situations, but will penalize the
+            // low contention / single thread case up to 5x
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8027     // Functions containing while are not expanded inline
+#endif
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/detail/lwm_win32_cs.hpp
===================================================================
--- trunk/msvc-libs/include/boost/detail/lwm_win32_cs.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/detail/lwm_win32_cs.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,105 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32_cs.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#ifdef BOOST_USE_WINDOWS_H
+#  include &lt;windows.h&gt;
+#endif
+
+namespace boost
+{
+
+namespace detail
+{
+
+#ifndef BOOST_USE_WINDOWS_H
+
+struct CRITICAL_SECTION
+{
+    struct critical_section_debug * DebugInfo;
+    long LockCount;
+    long RecursionCount;
+    void * OwningThread;
+    void * LockSemaphore;
+#if defined(_WIN64)
+    unsigned __int64 SpinCount;
+#else
+    unsigned long SpinCount;
+#endif
+};
+
+extern &quot;C&quot; __declspec(dllimport) void __stdcall InitializeCriticalSection(CRITICAL_SECTION *);
+extern &quot;C&quot; __declspec(dllimport) void __stdcall EnterCriticalSection(CRITICAL_SECTION *);
+extern &quot;C&quot; __declspec(dllimport) void __stdcall LeaveCriticalSection(CRITICAL_SECTION *);
+extern &quot;C&quot; __declspec(dllimport) void __stdcall DeleteCriticalSection(CRITICAL_SECTION *);
+
+#endif // #ifndef BOOST_USE_WINDOWS_H
+
+class lightweight_mutex
+{
+private:
+
+    CRITICAL_SECTION cs_;
+
+    lightweight_mutex(lightweight_mutex const &amp;);
+    lightweight_mutex &amp; operator=(lightweight_mutex const &amp;);
+
+public:
+
+    lightweight_mutex()
+    {
+        InitializeCriticalSection(&amp;cs_);
+    }
+
+    ~lightweight_mutex()
+    {
+        DeleteCriticalSection(&amp;cs_);
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        lightweight_mutex &amp; m_;
+
+        scoped_lock(scoped_lock const &amp;);
+        scoped_lock &amp; operator=(scoped_lock const &amp;);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex &amp; m): m_(m)
+        {
+            EnterCriticalSection(&amp;m_.cs_);
+        }
+
+        ~scoped_lock()
+        {
+            LeaveCriticalSection(&amp;m_.cs_);
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_CS_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/detail/lwm_win32_nt.hpp
===================================================================
--- trunk/msvc-libs/include/boost/detail/lwm_win32_nt.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/detail/lwm_win32_nt.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,64 @@
+#ifndef BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED
+#define BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/detail/lwm_win32_nt.hpp
+//
+//  Copyright (c) 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  &quot;No threads&quot; version of lwm_win32.hpp; binary compatible but no-op.
+//
+
+namespace boost
+{
+
+namespace detail
+{
+
+class lightweight_mutex
+{
+private:
+
+    long l_;
+
+    lightweight_mutex(lightweight_mutex const &amp;);
+    lightweight_mutex &amp; operator=(lightweight_mutex const &amp;);
+
+public:
+
+    lightweight_mutex(): l_(0)
+    {
+    }
+
+    class scoped_lock;
+    friend class scoped_lock;
+
+    class scoped_lock
+    {
+    private:
+
+        scoped_lock(scoped_lock const &amp;);
+        scoped_lock &amp; operator=(scoped_lock const &amp;);
+
+    public:
+
+        explicit scoped_lock(lightweight_mutex &amp;)
+        {
+        }
+    };
+};
+
+} // namespace detail
+
+} // namespace boost
+
+#endif // #ifndef BOOST_DETAIL_LWM_WIN32_NT_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/detail/shared_count.hpp
===================================================================
--- trunk/msvc-libs/include/boost/detail/shared_count.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/detail/shared_count.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,555 @@
+#ifndef BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED
+#define BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  detail/shared_count.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+
+#include &lt;boost/config.hpp&gt;
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR) &amp;&amp; defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+# error BOOST_SP_USE_STD_ALLOCATOR and BOOST_SP_USE_QUICK_ALLOCATOR are incompatible.
+#endif
+
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/throw_exception.hpp&gt;
+#include &lt;boost/detail/lightweight_mutex.hpp&gt;
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+#include &lt;boost/detail/quick_allocator.hpp&gt;
+#endif
+
+#include &lt;memory&gt;           // std::auto_ptr, std::allocator
+#include &lt;functional&gt;       // std::less
+#include &lt;exception&gt;        // std::exception
+#include &lt;new&gt;              // std::bad_alloc
+#include &lt;typeinfo&gt;         // std::type_info in get_deleter
+#include &lt;cstddef&gt;          // std::size_t
+
+#ifdef __BORLANDC__
+# pragma warn -8026     // Functions with excep. spec. are not expanded inline
+# pragma warn -8027     // Functions containing try are not expanded inline
+#endif
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook(void * px, std::size_t size, void * pn);
+void sp_array_constructor_hook(void * px);
+void sp_scalar_destructor_hook(void * px, std::size_t size, void * pn);
+void sp_array_destructor_hook(void * px);
+
+#endif
+
+
+// The standard library that comes with Borland C++ 5.5.1
+// defines std::exception and its members as having C calling
+// convention (-pc). When the definition of bad_weak_ptr
+// is compiled with -ps, the compiler issues an error.
+// Hence, the temporary #pragma option -pc below. The version
+// check is deliberately conservative.
+
+#if defined(__BORLANDC__) &amp;&amp; __BORLANDC__ == 0x551
+# pragma option push -pc
+#endif
+
+class bad_weak_ptr: public std::exception
+{
+public:
+
+    virtual char const * what() const throw()
+    {
+        return &quot;boost::bad_weak_ptr&quot;;
+    }
+};
+
+#if defined(__BORLANDC__) &amp;&amp; __BORLANDC__ == 0x551
+# pragma option pop
+#endif
+
+namespace detail
+{
+
+class sp_counted_base
+{
+private:
+
+    typedef detail::lightweight_mutex mutex_type;
+
+public:
+
+    sp_counted_base(): use_count_(1), weak_count_(1)
+    {
+    }
+
+    virtual ~sp_counted_base() // nothrow
+    {
+    }
+
+    // dispose() is called when use_count_ drops to zero, to release
+    // the resources managed by *this.
+
+    virtual void dispose() = 0; // nothrow
+
+    // destruct() is called when weak_count_ drops to zero.
+
+    virtual void destruct() // nothrow
+    {
+        delete this;
+    }
+
+    virtual void * get_deleter(std::type_info const &amp; ti) = 0;
+
+    void add_ref_copy()
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        ++use_count_;
+    }
+
+    void add_ref_lock()
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        if(use_count_ == 0) boost::throw_exception(boost::bad_weak_ptr());
+        ++use_count_;
+    }
+
+    void release() // nothrow
+    {
+        {
+#if defined(BOOST_HAS_THREADS)
+            mutex_type::scoped_lock lock(mtx_);
+#endif
+            long new_use_count = --use_count_;
+
+            if(new_use_count != 0) return;
+        }
+
+        dispose();
+        weak_release();
+    }
+
+    void weak_add_ref() // nothrow
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        ++weak_count_;
+    }
+
+    void weak_release() // nothrow
+    {
+        long new_weak_count;
+
+        {
+#if defined(BOOST_HAS_THREADS)
+            mutex_type::scoped_lock lock(mtx_);
+#endif
+            new_weak_count = --weak_count_;
+        }
+
+        if(new_weak_count == 0)
+        {
+            destruct();
+        }
+    }
+
+    long use_count() const // nothrow
+    {
+#if defined(BOOST_HAS_THREADS)
+        mutex_type::scoped_lock lock(mtx_);
+#endif
+        return use_count_;
+    }
+
+private:
+
+    sp_counted_base(sp_counted_base const &amp;);
+    sp_counted_base &amp; operator= (sp_counted_base const &amp;);
+
+    long use_count_;        // #shared
+    long weak_count_;       // #weak + (#shared != 0)
+
+#if defined(BOOST_HAS_THREADS) || defined(BOOST_LWM_WIN32)
+    mutable mutex_type mtx_;
+#endif
+};
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+template&lt;class T&gt; void cbi_call_constructor_hook(sp_counted_base * pn, T * px, checked_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_scalar_constructor_hook(px, sizeof(T), pn);
+}
+
+template&lt;class T&gt; void cbi_call_constructor_hook(sp_counted_base *, T * px, checked_array_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_array_constructor_hook(px);
+}
+
+template&lt;class P, class D&gt; void cbi_call_constructor_hook(sp_counted_base *, P const &amp;, D const &amp;, long)
+{
+}
+
+template&lt;class T&gt; void cbi_call_destructor_hook(sp_counted_base * pn, T * px, checked_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_scalar_destructor_hook(px, sizeof(T), pn);
+}
+
+template&lt;class T&gt; void cbi_call_destructor_hook(sp_counted_base *, T * px, checked_array_deleter&lt;T&gt; const &amp;, int)
+{
+    boost::sp_array_destructor_hook(px);
+}
+
+template&lt;class P, class D&gt; void cbi_call_destructor_hook(sp_counted_base *, P const &amp;, D const &amp;, long)
+{
+}
+
+#endif
+
+//
+// Borland's Codeguard trips up over the -Vx- option here:
+//
+#ifdef __CODEGUARD__
+# pragma option push -Vx-
+#endif
+
+template&lt;class P, class D&gt; class sp_counted_base_impl: public sp_counted_base
+{
+private:
+
+    P ptr; // copy constructor must not throw
+    D del; // copy constructor must not throw
+
+    sp_counted_base_impl(sp_counted_base_impl const &amp;);
+    sp_counted_base_impl &amp; operator= (sp_counted_base_impl const &amp;);
+
+    typedef sp_counted_base_impl&lt;P, D&gt; this_type;
+
+public:
+
+    // pre: initial_use_count &lt;= initial_weak_count, d(p) must not throw
+
+    sp_counted_base_impl(P p, D d): ptr(p), del(d)
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        detail::cbi_call_constructor_hook(this, p, d, 0);
+#endif
+    }
+
+    virtual void dispose() // nothrow
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        detail::cbi_call_destructor_hook(this, ptr, del, 0);
+#endif
+        del(ptr);
+    }
+
+    virtual void * get_deleter(std::type_info const &amp; ti)
+    {
+        return ti == typeid(D)? &amp;del: 0;
+    }
+
+#if defined(BOOST_SP_USE_STD_ALLOCATOR)
+
+    void * operator new(std::size_t)
+    {
+        return std::allocator&lt;this_type&gt;().allocate(1, static_cast&lt;this_type *&gt;(0));
+    }
+
+    void operator delete(void * p)
+    {
+        std::allocator&lt;this_type&gt;().deallocate(static_cast&lt;this_type *&gt;(p), 1);
+    }
+
+#endif
+
+#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)
+
+    void * operator new(std::size_t)
+    {
+        return quick_allocator&lt;this_type&gt;::alloc();
+    }
+
+    void operator delete(void * p)
+    {
+        quick_allocator&lt;this_type&gt;::dealloc(p);
+    }
+
+#endif
+};
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+int const shared_count_id = 0x2C35F101;
+int const   weak_count_id = 0x298C38A4;
+
+#endif
+
+class weak_count;
+
+class shared_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class weak_count;
+
+public:
+
+    shared_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+    }
+
+    template&lt;class P, class D&gt; shared_count(P p, D d): pi_(0)
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+#ifndef BOOST_NO_EXCEPTIONS
+
+        try
+        {
+            pi_ = new sp_counted_base_impl&lt;P, D&gt;(p, d);
+        }
+        catch(...)
+        {
+            d(p); // delete p
+            throw;
+        }
+
+#else
+
+        pi_ = new sp_counted_base_impl&lt;P, D&gt;(p, d);
+
+        if(pi_ == 0)
+        {
+            d(p); // delete p
+            boost::throw_exception(std::bad_alloc());
+        }
+
+#endif
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    // auto_ptr&lt;Y&gt; is special cased to provide the strong guarantee
+
+    template&lt;class Y&gt;
+    explicit shared_count(std::auto_ptr&lt;Y&gt; &amp; r): pi_(new sp_counted_base_impl&lt; Y *, checked_deleter&lt;Y&gt; &gt;(r.get(), checked_deleter&lt;Y&gt;()))
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        r.release();
+    }
+
+#endif 
+
+    ~shared_count() // nothrow
+    {
+        if(pi_ != 0) pi_-&gt;release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    shared_count(shared_count const &amp; r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_-&gt;add_ref_copy();
+    }
+
+    explicit shared_count(weak_count const &amp; r); // throws bad_weak_ptr when r.use_count() == 0
+
+    shared_count &amp; operator= (shared_count const &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp-&gt;add_ref_copy();
+        if(pi_ != 0) pi_-&gt;release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    void swap(shared_count &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_-&gt;use_count(): 0;
+    }
+
+    bool unique() const // nothrow
+    {
+        return use_count() == 1;
+    }
+
+    friend inline bool operator==(shared_count const &amp; a, shared_count const &amp; b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator&lt;(shared_count const &amp; a, shared_count const &amp; b)
+    {
+        return std::less&lt;sp_counted_base *&gt;()(a.pi_, b.pi_);
+    }
+
+    void * get_deleter(std::type_info const &amp; ti) const
+    {
+        return pi_? pi_-&gt;get_deleter(ti): 0;
+    }
+};
+
+#ifdef __CODEGUARD__
+# pragma option pop
+#endif
+
+
+class weak_count
+{
+private:
+
+    sp_counted_base * pi_;
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+    int id_;
+#endif
+
+    friend class shared_count;
+
+public:
+
+    weak_count(): pi_(0) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(weak_count_id)
+#endif
+    {
+    }
+
+    weak_count(shared_count const &amp; r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_-&gt;weak_add_ref();
+    }
+
+    weak_count(weak_count const &amp; r): pi_(r.pi_) // nothrow
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+    {
+        if(pi_ != 0) pi_-&gt;weak_add_ref();
+    }
+
+    ~weak_count() // nothrow
+    {
+        if(pi_ != 0) pi_-&gt;weak_release();
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        id_ = 0;
+#endif
+    }
+
+    weak_count &amp; operator= (shared_count const &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp-&gt;weak_add_ref();
+        if(pi_ != 0) pi_-&gt;weak_release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    weak_count &amp; operator= (weak_count const &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        if(tmp != 0) tmp-&gt;weak_add_ref();
+        if(pi_ != 0) pi_-&gt;weak_release();
+        pi_ = tmp;
+
+        return *this;
+    }
+
+    void swap(weak_count &amp; r) // nothrow
+    {
+        sp_counted_base * tmp = r.pi_;
+        r.pi_ = pi_;
+        pi_ = tmp;
+    }
+
+    long use_count() const // nothrow
+    {
+        return pi_ != 0? pi_-&gt;use_count(): 0;
+    }
+
+    friend inline bool operator==(weak_count const &amp; a, weak_count const &amp; b)
+    {
+        return a.pi_ == b.pi_;
+    }
+
+    friend inline bool operator&lt;(weak_count const &amp; a, weak_count const &amp; b)
+    {
+        return std::less&lt;sp_counted_base *&gt;()(a.pi_, b.pi_);
+    }
+};
+
+inline shared_count::shared_count(weak_count const &amp; r): pi_(r.pi_)
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        , id_(shared_count_id)
+#endif
+{
+    if(pi_ != 0)
+    {
+        pi_-&gt;add_ref_lock();
+    }
+    else
+    {
+        boost::throw_exception(boost::bad_weak_ptr());
+    }
+}
+
+} // namespace detail
+
+} // namespace boost
+
+#ifdef __BORLANDC__
+# pragma warn .8027     // Functions containing try are not expanded inline
+# pragma warn .8026     // Functions with excep. spec. are not expanded inline
+#endif
+
+#endif  // #ifndef BOOST_DETAIL_SHARED_COUNT_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/detail/workaround.hpp
===================================================================
--- trunk/msvc-libs/include/boost/detail/workaround.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/detail/workaround.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,74 @@
+// Copyright David Abrahams 2002. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// &quot;as is&quot; without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+#ifndef WORKAROUND_DWA2002126_HPP
+# define WORKAROUND_DWA2002126_HPP
+
+// Compiler/library version workaround macro
+//
+// Usage:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, &lt;= 1200)
+//        ... // workaround code here
+//     #endif
+//
+// When BOOST_STRICT_CONFIG is defined, expands to 0. Otherwise, the
+// first argument must be undefined or expand to a numeric
+// value. The above expands to:
+//
+//     (BOOST_MSVC) != 0 &amp;&amp; (BOOST_MSVC) &lt;= 1200
+//
+// When used for workarounds that apply to the latest known version 
+// and all earlier versions of a compiler, the following convention 
+// should be observed:
+//
+//     #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1301))
+//
+// The version number in this case corresponds to the last version in
+// which the workaround was known to have been required. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is not the defined, the macro
+// BOOST_TESTED_AT(x) expands to &quot;!= 0&quot;, which effectively activates
+// the workaround for any version of the compiler. When
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is defined, a compiler warning or
+// error will be issued if the compiler version exceeds the argument
+// to BOOST_TESTED_AT().  This can be used to locate workarounds which
+// may be obsoleted by newer versions.
+
+# ifndef BOOST_STRICT_CONFIG
+
+#  define BOOST_WORKAROUND(symbol, test)                \
+        ((symbol != 0) &amp;&amp; (1 % (( (symbol test) ) + 1)))
+//                              ^ ^           ^ ^
+// The extra level of parenthesis nesting above, along with the
+// BOOST_OPEN_PAREN indirection below, is required to satisfy the
+// broken preprocessor in MWCW 8.3 and earlier.
+//
+// The basic mechanism works as follows:
+//      (symbol test) + 1        =&gt;   if (symbol test) then 2 else 1
+//      1 % ((symbol test) + 1)  =&gt;   if (symbol test) then 1 else 0
+//
+// The complication with % is for cooperation with BOOST_TESTED_AT().
+// When &quot;test&quot; is BOOST_TESTED_AT(x) and
+// BOOST_DETECT_OUTDATED_WORKAROUNDS is #defined,
+//
+//      symbol test              =&gt;   if (symbol &lt;= x) then 1 else -1
+//      (symbol test) + 1        =&gt;   if (symbol &lt;= x) then 2 else 0
+//      1 % ((symbol test) + 1)  =&gt;   if (symbol &lt;= x) then 1 else divide-by-zero
+//
+
+#  ifdef BOOST_DETECT_OUTDATED_WORKAROUNDS
+#   define BOOST_OPEN_PAREN (
+#   define BOOST_TESTED_AT(value)  &gt; value) ?(-1): BOOST_OPEN_PAREN 1
+#  else
+#   define BOOST_TESTED_AT(value) != ((value)-(value))
+#  endif
+
+# else
+
+#  define BOOST_WORKAROUND(symbol, test) 0
+
+# endif 
+
+#endif // WORKAROUND_DWA2002126_HPP

Added: trunk/msvc-libs/include/boost/non_type.hpp
===================================================================
--- trunk/msvc-libs/include/boost/non_type.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/non_type.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,24 @@
+// (C) Copyright Gennaro Prota 2003. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// &quot;as is&quot; without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+
+
+#ifndef BOOST_NON_TYPE_HPP_GP_20030417
+#define BOOST_NON_TYPE_HPP_GP_20030417
+
+
+namespace boost {
+
+  // Just a simple &quot;envelope&quot; for non-type template parameters. Useful
+  // to work around some MSVC deficiencies.
+
+ template &lt;typename T, T n&gt;
+ struct non_type { };
+
+
+}
+
+
+#endif // include guard

Added: trunk/msvc-libs/include/boost/scoped_array.hpp
===================================================================
--- trunk/msvc-libs/include/boost/scoped_array.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/scoped_array.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,136 @@
+#ifndef BOOST_SCOPED_ARRAY_HPP_INCLUDED
+#define BOOST_SCOPED_ARRAY_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/smart_ptr/scoped_array.htm">http://www.boost.org/libs/smart_ptr/scoped_array.htm</A>
+//
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/config.hpp&gt;   // in case ptrdiff_t not in std
+
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#include &lt;cstddef&gt;            // for std::ptrdiff_t
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_array_constructor_hook(void * p);
+void sp_array_destructor_hook(void * p);
+
+#endif
+
+//  scoped_array extends scoped_ptr to arrays. Deletion of the array pointed to
+//  is guaranteed, either on destruction of the scoped_array or via an explicit
+//  reset(). Use shared_array or std::vector if your needs are more complex.
+
+template&lt;class T&gt; class scoped_array // noncopyable
+{
+private:
+
+    T * ptr;
+
+    scoped_array(scoped_array const &amp;);
+    scoped_array &amp; operator=(scoped_array const &amp;);
+
+    typedef scoped_array&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_array(T * p = 0) : ptr(p) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_array_constructor_hook(ptr);
+#endif
+    }
+
+    ~scoped_array() // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_array_destructor_hook(ptr);
+#endif
+        boost::checked_array_delete(ptr);
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        BOOST_ASSERT(p == 0 || p != ptr); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T &amp; operator[](std::ptrdiff_t i) const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        BOOST_ASSERT(i &gt;= 0);
+        return ptr[i];
+    }
+
+    T * get() const // never throws
+    {
+        return ptr;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return ptr != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::ptr;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return ptr == 0;
+    }
+
+    void swap(scoped_array &amp; b) // never throws
+    {
+        T * tmp = b.ptr;
+        b.ptr = ptr;
+        ptr = tmp;
+    }
+
+};
+
+template&lt;class T&gt; inline void swap(scoped_array&lt;T&gt; &amp; a, scoped_array&lt;T&gt; &amp; b) // never throws
+{
+    a.swap(b);
+}
+
+} // namespace boost
+
+#endif  // #ifndef BOOST_SCOPED_ARRAY_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/scoped_ptr.hpp
===================================================================
--- trunk/msvc-libs/include/boost/scoped_ptr.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/scoped_ptr.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,158 @@
+#ifndef BOOST_SCOPED_PTR_HPP_INCLUDED
+#define BOOST_SCOPED_PTR_HPP_INCLUDED
+
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/smart_ptr/scoped_ptr.htm">http://www.boost.org/libs/smart_ptr/scoped_ptr.htm</A>
+//
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#ifndef BOOST_NO_AUTO_PTR
+# include &lt;memory&gt;          // for std::auto_ptr
+#endif
+
+namespace boost
+{
+
+// Debug hooks
+
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+
+void sp_scalar_constructor_hook(void * p);
+void sp_scalar_destructor_hook(void * p);
+
+#endif
+
+//  scoped_ptr mimics a built-in pointer except that it guarantees deletion
+//  of the object pointed to, either on destruction of the scoped_ptr or via
+//  an explicit reset(). scoped_ptr is a simple solution for simple needs;
+//  use shared_ptr or std::auto_ptr if your needs are more complex.
+
+template&lt;class T&gt; class scoped_ptr // noncopyable
+{
+private:
+
+    T * ptr;
+
+    scoped_ptr(scoped_ptr const &amp;);
+    scoped_ptr &amp; operator=(scoped_ptr const &amp;);
+
+    typedef scoped_ptr&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit scoped_ptr(T * p = 0): ptr(p) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook(ptr);
+#endif
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    explicit scoped_ptr(std::auto_ptr&lt;T&gt; p): ptr(p.release()) // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_constructor_hook(ptr);
+#endif
+    }
+
+#endif
+
+    ~scoped_ptr() // never throws
+    {
+#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)
+        boost::sp_scalar_destructor_hook(ptr);
+#endif
+        boost::checked_delete(ptr);
+    }
+
+    void reset(T * p = 0) // never throws
+    {
+        BOOST_ASSERT(p == 0 || p != ptr); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    T &amp; operator*() const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        return *ptr;
+    }
+
+    T * operator-&gt;() const // never throws
+    {
+        BOOST_ASSERT(ptr != 0);
+        return ptr;
+    }
+
+    T * get() const // never throws
+    {
+        return ptr;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return ptr != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return ptr == 0? 0: &amp;this_type::ptr;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return ptr == 0;
+    }
+
+    void swap(scoped_ptr &amp; b) // never throws
+    {
+        T * tmp = b.ptr;
+        b.ptr = ptr;
+        ptr = tmp;
+    }
+};
+
+template&lt;class T&gt; inline void swap(scoped_ptr&lt;T&gt; &amp; a, scoped_ptr&lt;T&gt; &amp; b) // never throws
+{
+    a.swap(b);
+}
+
+// get_pointer(p) is a generic way to say p.get()
+
+template&lt;class T&gt; inline T * get_pointer(scoped_ptr&lt;T&gt; const &amp; p)
+{
+    return p.get();
+}
+
+} // namespace boost
+
+#endif // #ifndef BOOST_SCOPED_PTR_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/shared_array.hpp
===================================================================
--- trunk/msvc-libs/include/boost/shared_array.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/shared_array.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,176 @@
+#ifndef BOOST_SHARED_ARRAY_HPP_INCLUDED
+#define BOOST_SHARED_ARRAY_HPP_INCLUDED
+
+//
+//  shared_array.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/smart_ptr/shared_array.htm">http://www.boost.org/libs/smart_ptr/shared_array.htm</A> for documentation.
+//
+
+#include &lt;boost/config.hpp&gt;   // for broken compiler workarounds
+
+#if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#include &lt;boost/detail/shared_array_nmt.hpp&gt;
+#else
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+
+#include &lt;boost/detail/shared_count.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#include &lt;cstddef&gt;            // for std::ptrdiff_t
+#include &lt;algorithm&gt;          // for std::swap
+#include &lt;functional&gt;         // for std::less
+
+namespace boost
+{
+
+//
+//  shared_array
+//
+//  shared_array extends shared_ptr to arrays.
+//  The array pointed to is deleted when the last shared_array pointing to it
+//  is destroyed or reset.
+//
+
+template&lt;class T&gt; class shared_array
+{
+private:
+
+    // Borland 5.5.1 specific workarounds
+    typedef checked_array_deleter&lt;T&gt; deleter;
+    typedef shared_array&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    explicit shared_array(T * p = 0): px(p), pn(p, deleter())
+    {
+    }
+
+    //
+    // Requirements: D's copy constructor must not throw
+    //
+    // shared_array will release p by calling d(p)
+    //
+
+    template&lt;class D&gt; shared_array(T * p, D d): px(p), pn(p, d)
+    {
+    }
+
+//  generated copy constructor, assignment, destructor are fine
+
+    void reset(T * p = 0)
+    {
+        BOOST_ASSERT(p == 0 || p != px);
+        this_type(p).swap(*this);
+    }
+
+    template &lt;class D&gt; void reset(T * p, D d)
+    {
+        this_type(p, d).swap(*this);
+    }
+
+    T &amp; operator[] (std::ptrdiff_t i) const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        BOOST_ASSERT(i &gt;= 0);
+        return px[i];
+    }
+    
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return px != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::px;
+    }
+
+#endif
+
+    bool operator! () const // never throws
+    {
+        return px == 0;
+    }
+
+    bool unique() const // never throws
+    {
+        return pn.unique();
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    void swap(shared_array&lt;T&gt; &amp; other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+private:
+
+    T * px;                     // contained pointer
+    detail::shared_count pn;    // reference counter
+
+};  // shared_array
+
+template&lt;class T&gt; inline bool operator==(shared_array&lt;T&gt; const &amp; a, shared_array&lt;T&gt; const &amp; b) // never throws
+{
+    return a.get() == b.get();
+}
+
+template&lt;class T&gt; inline bool operator!=(shared_array&lt;T&gt; const &amp; a, shared_array&lt;T&gt; const &amp; b) // never throws
+{
+    return a.get() != b.get();
+}
+
+template&lt;class T&gt; inline bool operator&lt;(shared_array&lt;T&gt; const &amp; a, shared_array&lt;T&gt; const &amp; b) // never throws
+{
+    return std::less&lt;T*&gt;()(a.get(), b.get());
+}
+
+template&lt;class T&gt; void swap(shared_array&lt;T&gt; &amp; a, shared_array&lt;T&gt; &amp; b) // never throws
+{
+    a.swap(b);
+}
+
+} // namespace boost
+
+#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+#endif  // #ifndef BOOST_SHARED_ARRAY_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/shared_container_iterator.hpp
===================================================================
--- trunk/msvc-libs/include/boost/shared_container_iterator.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/shared_container_iterator.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,62 @@
+// (C) Copyright Ronald Garcia 2002. Permission to copy, use, modify, sell and
+// distribute this software is granted provided this copyright notice appears
+// in all copies. This software is provided &quot;as is&quot; without express or implied
+// warranty, and with no claim as to its suitability for any purpose.
+
+// See <A HREF="http://www.boost.org/libs/utility/shared_container_iterator.html">http://www.boost.org/libs/utility/shared_container_iterator.html</A> for documentation.
+
+#ifndef SHARED_CONTAINER_ITERATOR_RG08102002_HPP
+#define SHARED_CONTAINER_ITERATOR_RG08102002_HPP
+
+#include &quot;boost/iterator_adaptors.hpp&quot;
+#include &quot;boost/shared_ptr.hpp&quot;
+#include &lt;utility&gt;
+
+namespace boost {
+
+template &lt;typename Container&gt;
+class shared_container_iterator : public iterator_adaptor&lt;
+                                    shared_container_iterator&lt;Container&gt;,
+                                    typename Container::iterator&gt; {
+
+  typedef iterator_adaptor&lt;
+    shared_container_iterator&lt;Container&gt;,
+    typename Container::iterator&gt; super_t;
+
+  typedef typename Container::iterator iterator_t;
+  typedef boost::shared_ptr&lt;Container&gt; container_ref_t;
+
+  container_ref_t container_ref;
+public:
+  shared_container_iterator() { }
+
+  shared_container_iterator(iterator_t const&amp; x,container_ref_t const&amp; c) :
+    super_t(x), container_ref(c) { }
+
+
+};
+
+template &lt;typename Container&gt;
+shared_container_iterator&lt;Container&gt;
+make_shared_container_iterator(typename Container::iterator iter,
+                               boost::shared_ptr&lt;Container&gt; const&amp; container) {
+  typedef shared_container_iterator&lt;Container&gt; iterator;
+  return iterator(iter,container);
+}
+
+
+
+template &lt;typename Container&gt;
+std::pair&lt;
+  shared_container_iterator&lt;Container&gt;,
+  shared_container_iterator&lt;Container&gt; &gt;
+make_shared_container_range(boost::shared_ptr&lt;Container&gt; const&amp; container) {
+  return
+    std::make_pair(
+      make_shared_container_iterator(container-&gt;begin(),container),
+      make_shared_container_iterator(container-&gt;end(),container));
+}
+
+
+} // namespace boost
+#endif  // SHARED_CONTAINER_ITERATOR_RG08102002_HPP

Added: trunk/msvc-libs/include/boost/shared_ptr.hpp
===================================================================
--- trunk/msvc-libs/include/boost/shared_ptr.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/shared_ptr.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,474 @@
+#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
+#define BOOST_SHARED_PTR_HPP_INCLUDED
+
+//
+//  shared_ptr.hpp
+//
+//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/libs/smart_ptr/shared_ptr.htm</A> for documentation.
+//
+
+#include &lt;boost/config.hpp&gt;   // for broken compiler workarounds
+
+#if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+#include &lt;boost/detail/shared_ptr_nmt.hpp&gt;
+#else
+
+#include &lt;boost/assert.hpp&gt;
+#include &lt;boost/checked_delete.hpp&gt;
+#include &lt;boost/throw_exception.hpp&gt;
+#include &lt;boost/detail/shared_count.hpp&gt;
+#include &lt;boost/detail/workaround.hpp&gt;
+
+#include &lt;memory&gt;               // for std::auto_ptr
+#include &lt;algorithm&gt;            // for std::swap
+#include &lt;functional&gt;           // for std::less
+#include &lt;typeinfo&gt;             // for std::bad_cast
+#include &lt;iosfwd&gt;               // for std::basic_ostream
+
+#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
+# pragma warning(push)
+# pragma warning(disable:4284) // odd return type for operator-&gt;
+#endif
+
+namespace boost
+{
+
+template&lt;class T&gt; class weak_ptr;
+template&lt;class T&gt; class enable_shared_from_this;
+
+namespace detail
+{
+
+struct static_cast_tag {};
+struct const_cast_tag {};
+struct dynamic_cast_tag {};
+struct polymorphic_cast_tag {};
+
+template&lt;class T&gt; struct shared_ptr_traits
+{
+    typedef T &amp; reference;
+};
+
+template&lt;&gt; struct shared_ptr_traits&lt;void&gt;
+{
+    typedef void reference;
+};
+
+#if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)
+
+template&lt;&gt; struct shared_ptr_traits&lt;void const&gt;
+{
+    typedef void reference;
+};
+
+template&lt;&gt; struct shared_ptr_traits&lt;void volatile&gt;
+{
+    typedef void reference;
+};
+
+template&lt;&gt; struct shared_ptr_traits&lt;void const volatile&gt;
+{
+    typedef void reference;
+};
+
+#endif
+
+// enable_shared_from_this support
+
+template&lt;class T, class Y&gt; void sp_enable_shared_from_this(boost::enable_shared_from_this&lt;T&gt; * pe, Y * px, shared_count const &amp; pn)
+{
+    if(pe != 0) pe-&gt;_internal_weak_this._internal_assign(px, pn);
+}
+
+inline void sp_enable_shared_from_this(void const volatile *, void const volatile *, shared_count const &amp;)
+{
+}
+
+} // namespace detail
+
+
+//
+//  shared_ptr
+//
+//  An enhanced relative of scoped_ptr with reference counted copy semantics.
+//  The object pointed to is deleted when the last shared_ptr pointing to it
+//  is destroyed or reset.
+//
+
+template&lt;class T&gt; class shared_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workaround
+    typedef shared_ptr&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+    typedef T value_type;
+    typedef T * pointer;
+    typedef typename detail::shared_ptr_traits&lt;T&gt;::reference reference;
+
+    shared_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+    template&lt;class Y&gt;
+    explicit shared_ptr(Y * p): px(p), pn(p, checked_deleter&lt;Y&gt;()) // Y must be complete
+    {
+        detail::sp_enable_shared_from_this(p, p, pn);
+    }
+
+    //
+    // Requirements: D's copy constructor must not throw
+    //
+    // shared_ptr will release p by calling d(p)
+    //
+
+    template&lt;class Y, class D&gt; shared_ptr(Y * p, D d): px(p), pn(p, d)
+    {
+        detail::sp_enable_shared_from_this(p, p, pn);
+    }
+
+//  generated copy constructor, assignment, destructor are fine...
+
+//  except that Borland C++ has a bug, and g++ with -Wsynth warns
+#if defined(__BORLANDC__) || defined(__GNUC__)
+
+    shared_ptr &amp; operator=(shared_ptr const &amp; r) // never throws
+    {
+        px = r.px;
+        pn = r.pn; // shared_count::op= doesn't throw
+        return *this;
+    }
+
+#endif
+
+    template&lt;class Y&gt;
+    explicit shared_ptr(weak_ptr&lt;Y&gt; const &amp; r): pn(r.pn) // may throw
+    {
+        // it is now safe to copy r.px, as pn(r.pn) did not throw
+        px = r.px;
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r): px(r.px), pn(r.pn) // never throws
+    {
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::static_cast_tag): px(static_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::const_cast_tag): px(const_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::dynamic_cast_tag): px(dynamic_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+        if(px == 0) // need to allocate new counter -- the cast failed
+        {
+            pn = detail::shared_count();
+        }
+    }
+
+    template&lt;class Y&gt;
+    shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, detail::polymorphic_cast_tag): px(dynamic_cast&lt;element_type *&gt;(r.px)), pn(r.pn)
+    {
+        if(px == 0)
+        {
+            boost::throw_exception(std::bad_cast());
+        }
+    }
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template&lt;class Y&gt;
+    explicit shared_ptr(std::auto_ptr&lt;Y&gt; &amp; r): px(r.get()), pn()
+    {
+        Y * tmp = r.get();
+        pn = detail::shared_count(r);
+        detail::sp_enable_shared_from_this(tmp, tmp, pn);
+    }
+
+#endif
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC &gt; 1200)
+
+    template&lt;class Y&gt;
+    shared_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r) // never throws
+    {
+        px = r.px;
+        pn = r.pn; // shared_count::op= doesn't throw
+        return *this;
+    }
+
+#endif
+
+#ifndef BOOST_NO_AUTO_PTR
+
+    template&lt;class Y&gt;
+    shared_ptr &amp; operator=(std::auto_ptr&lt;Y&gt; &amp; r)
+    {
+        this_type(r).swap(*this);
+        return *this;
+    }
+
+#endif
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    template&lt;class Y&gt; void reset(Y * p) // Y must be complete
+    {
+        BOOST_ASSERT(p == 0 || p != px); // catch self-reset errors
+        this_type(p).swap(*this);
+    }
+
+    template&lt;class Y, class D&gt; void reset(Y * p, D d)
+    {
+        this_type(p, d).swap(*this);
+    }
+
+    reference operator* () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return *px;
+    }
+
+    T * operator-&gt; () const // never throws
+    {
+        BOOST_ASSERT(px != 0);
+        return px;
+    }
+    
+    T * get() const // never throws
+    {
+        return px;
+    }
+
+    // implicit conversion to &quot;bool&quot;
+
+#if defined(__SUNPRO_CC) &amp;&amp; BOOST_WORKAROUND(__SUNPRO_CC, &lt;= 0x530)
+
+    operator bool () const
+    {
+        return px != 0;
+    }
+
+#elif defined(__MWERKS__) &amp;&amp; BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3003))
+    typedef T * (this_type::*unspecified_bool_type)() const;
+    
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::get;
+    }
+
+#else 
+
+    typedef T * this_type::*unspecified_bool_type;
+
+    operator unspecified_bool_type() const // never throws
+    {
+        return px == 0? 0: &amp;this_type::px;
+    }
+
+#endif
+
+    // operator! is redundant, but some compilers need it
+
+    bool operator! () const // never throws
+    {
+        return px == 0;
+    }
+
+    bool unique() const // never throws
+    {
+        return pn.unique();
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    void swap(shared_ptr&lt;T&gt; &amp; other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    template&lt;class Y&gt; bool _internal_less(shared_ptr&lt;Y&gt; const &amp; rhs) const
+    {
+        return pn &lt; rhs.pn;
+    }
+
+    void * _internal_get_deleter(std::type_info const &amp; ti) const
+    {
+        return pn.get_deleter(ti);
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template&lt;class Y&gt; friend class shared_ptr;
+    template&lt;class Y&gt; friend class weak_ptr;
+
+
+#endif
+
+    T * px;                     // contained pointer
+    detail::shared_count pn;    // reference counter
+
+};  // shared_ptr
+
+template&lt;class T, class U&gt; inline bool operator==(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b)
+{
+    return a.get() == b.get();
+}
+
+template&lt;class T, class U&gt; inline bool operator!=(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b)
+{
+    return a.get() != b.get();
+}
+
+#if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt;= 96
+
+// Resolve the ambiguity between our op!= and the one in rel_ops
+
+template&lt;class T&gt; inline bool operator!=(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;T&gt; const &amp; b)
+{
+    return a.get() != b.get();
+}
+
+#endif
+
+template&lt;class T, class U&gt; inline bool operator&lt;(shared_ptr&lt;T&gt; const &amp; a, shared_ptr&lt;U&gt; const &amp; b)
+{
+    return a._internal_less(b);
+}
+
+template&lt;class T&gt; inline void swap(shared_ptr&lt;T&gt; &amp; a, shared_ptr&lt;T&gt; &amp; b)
+{
+    a.swap(b);
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; static_pointer_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::static_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; const_pointer_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::const_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; dynamic_pointer_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::dynamic_cast_tag());
+}
+
+// shared_*_cast names are deprecated. Use *_pointer_cast instead.
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_static_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::static_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_dynamic_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::dynamic_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_polymorphic_cast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    return shared_ptr&lt;T&gt;(r, detail::polymorphic_cast_tag());
+}
+
+template&lt;class T, class U&gt; shared_ptr&lt;T&gt; shared_polymorphic_downcast(shared_ptr&lt;U&gt; const &amp; r)
+{
+    BOOST_ASSERT(dynamic_cast&lt;T *&gt;(r.get()) == r.get());
+    return shared_static_cast&lt;T&gt;(r);
+}
+
+// get_pointer() enables boost::mem_fn to recognize shared_ptr
+
+template&lt;class T&gt; inline T * get_pointer(shared_ptr&lt;T&gt; const &amp; p)
+{
+    return p.get();
+}
+
+// operator&lt;&lt;
+
+#if defined(__GNUC__) &amp;&amp;  (__GNUC__ &lt; 3)
+
+template&lt;class Y&gt; std::ostream &amp; operator&lt;&lt; (std::ostream &amp; os, shared_ptr&lt;Y&gt; const &amp; p)
+{
+    os &lt;&lt; p.get();
+    return os;
+}
+
+#else
+
+# if defined(BOOST_MSVC) &amp;&amp; BOOST_WORKAROUND(BOOST_MSVC, &lt;= 1200 &amp;&amp; __SGI_STL_PORT)
+// MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL
+using std::basic_ostream;
+template&lt;class E, class T, class Y&gt; basic_ostream&lt;E, T&gt; &amp; operator&lt;&lt; (basic_ostream&lt;E, T&gt; &amp; os, shared_ptr&lt;Y&gt; const &amp; p)
+# else
+template&lt;class E, class T, class Y&gt; std::basic_ostream&lt;E, T&gt; &amp; operator&lt;&lt; (std::basic_ostream&lt;E, T&gt; &amp; os, shared_ptr&lt;Y&gt; const &amp; p)
+# endif 
+{
+    os &lt;&lt; p.get();
+    return os;
+}
+
+#endif
+
+// get_deleter (experimental)
+
+#if (defined(__GNUC__) &amp;&amp;  (__GNUC__ &lt; 3)) || (defined(__EDG_VERSION__) &amp;&amp; (__EDG_VERSION__ &lt;= 238))
+
+// g++ 2.9x doesn't allow static_cast&lt;X const *&gt;(void *)
+// apparently EDG 2.38 also doesn't accept it
+
+template&lt;class D, class T&gt; D * get_deleter(shared_ptr&lt;T&gt; const &amp; p)
+{
+    void const * q = p._internal_get_deleter(typeid(D));
+    return const_cast&lt;D *&gt;(static_cast&lt;D const *&gt;(q));
+}
+
+#else
+
+template&lt;class D, class T&gt; D * get_deleter(shared_ptr&lt;T&gt; const &amp; p)
+{
+    return static_cast&lt;D *&gt;(p._internal_get_deleter(typeid(D)));
+}
+
+#endif
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif    
+
+#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) &amp;&amp; !defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+
+#endif  // #ifndef BOOST_SHARED_PTR_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/smart_ptr.hpp
===================================================================
--- trunk/msvc-libs/include/boost/smart_ptr.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/smart_ptr.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,29 @@
+//
+//  smart_ptr.hpp
+//
+//  For convenience, this header includes the rest of the smart
+//  pointer library headers.
+//
+//  Copyright (c) 1998-2002 boost.org
+//  Copyright (c) 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/smart_ptr/smart_ptr.htm">http://www.boost.org/libs/smart_ptr/smart_ptr.htm</A>
+//
+
+#include &lt;boost/config.hpp&gt;
+
+#include &lt;boost/scoped_ptr.hpp&gt;
+#include &lt;boost/scoped_array.hpp&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/shared_array.hpp&gt;
+
+#if !defined(BOOST_NO_MEMBER_TEMPLATES) || defined(BOOST_MSVC6_MEMBER_TEMPLATES)
+# include &lt;boost/weak_ptr.hpp&gt;
+# include &lt;boost/intrusive_ptr.hpp&gt;
+# include &lt;boost/enable_shared_from_this.hpp&gt;
+#endif

Added: trunk/msvc-libs/include/boost/throw_exception.hpp
===================================================================
--- trunk/msvc-libs/include/boost/throw_exception.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/throw_exception.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,47 @@
+#ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED
+#define BOOST_THROW_EXCEPTION_HPP_INCLUDED
+
+// MS compatible compilers support #pragma once
+
+#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
+# pragma once
+#endif
+
+//
+//  boost/throw_exception.hpp
+//
+//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  <A HREF="http://www.boost.org/libs/utility/throw_exception.html">http://www.boost.org/libs/utility/throw_exception.html</A>
+//
+
+#include &lt;boost/config.hpp&gt;
+
+#ifdef BOOST_NO_EXCEPTIONS
+# include &lt;exception&gt;
+#endif
+
+namespace boost
+{
+
+#ifdef BOOST_NO_EXCEPTIONS
+
+void throw_exception(std::exception const &amp; e); // user defined
+
+#else
+
+template&lt;class E&gt; void throw_exception(E const &amp; e)
+{
+    throw e;
+}
+
+#endif
+
+} // namespace boost
+
+#endif // #ifndef BOOST_THROW_EXCEPTION_HPP_INCLUDED

Added: trunk/msvc-libs/include/boost/type.hpp
===================================================================
--- trunk/msvc-libs/include/boost/type.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/type.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,19 @@
+// (C) Copyright David Abrahams 2001. Permission to copy, use,
+// modify, sell and distribute this software is granted provided this
+// copyright notice appears in all copies. This software is provided
+// &quot;as is&quot; without express or implied warranty, and with no claim as
+// to its suitability for any purpose.
+
+#ifndef BOOST_TYPE_DWA20010120_HPP
+# define BOOST_TYPE_DWA20010120_HPP
+
+namespace boost {
+
+  // Just a simple &quot;type envelope&quot;. Useful in various contexts, mostly to work
+  // around some MSVC deficiencies.
+  template &lt;class T&gt;
+  struct type {};
+
+}
+
+#endif // BOOST_TYPE_DWA20010120_HPP

Added: trunk/msvc-libs/include/boost/weak_ptr.hpp
===================================================================
--- trunk/msvc-libs/include/boost/weak_ptr.hpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/boost/weak_ptr.hpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,193 @@
+#ifndef BOOST_WEAK_PTR_HPP_INCLUDED
+#define BOOST_WEAK_PTR_HPP_INCLUDED
+
+//
+//  weak_ptr.hpp
+//
+//  Copyright (c) 2001, 2002, 2003 Peter Dimov
+//
+//  Permission to copy, use, modify, sell and distribute this software
+//  is granted provided this copyright notice appears in all copies.
+//  This software is provided &quot;as is&quot; without express or implied
+//  warranty, and with no claim as to its suitability for any purpose.
+//
+//  See <A HREF="http://www.boost.org/libs/smart_ptr/weak_ptr.htm">http://www.boost.org/libs/smart_ptr/weak_ptr.htm</A> for documentation.
+//
+
+#include &lt;boost/shared_ptr.hpp&gt;
+
+#ifdef BOOST_MSVC  // moved here to work around VC++ compiler crash
+# pragma warning(push)
+# pragma warning(disable:4284) // odd return type for operator-&gt;
+#endif
+
+namespace boost
+{
+
+template&lt;class T&gt; class weak_ptr
+{
+private:
+
+    // Borland 5.5.1 specific workarounds
+    typedef weak_ptr&lt;T&gt; this_type;
+
+public:
+
+    typedef T element_type;
+
+    weak_ptr(): px(0), pn() // never throws in 1.30+
+    {
+    }
+
+//  generated copy constructor, assignment, destructor are fine
+
+
+//
+//  The &quot;obvious&quot; converting constructor implementation:
+//
+//  template&lt;class Y&gt;
+//  weak_ptr(weak_ptr&lt;Y&gt; const &amp; r): px(r.px), pn(r.pn) // never throws
+//  {
+//  }
+//
+//  has a serious problem.
+//
+//  r.px may already have been invalidated. The px(r.px)
+//  conversion may require access to *r.px (virtual inheritance).
+//
+//  It is not possible to avoid spurious access violations since
+//  in multithreaded programs r.px may be invalidated at any point.
+//
+
+    template&lt;class Y&gt;
+    weak_ptr(weak_ptr&lt;Y&gt; const &amp; r): pn(r.pn) // never throws
+    {
+        px = r.lock().get();
+    }
+
+    template&lt;class Y&gt;
+    weak_ptr(shared_ptr&lt;Y&gt; const &amp; r): px(r.px), pn(r.pn) // never throws
+    {
+    }
+
+#if !defined(BOOST_MSVC) || (BOOST_MSVC &gt; 1200)
+
+    template&lt;class Y&gt;
+    weak_ptr &amp; operator=(weak_ptr&lt;Y&gt; const &amp; r) // never throws
+    {
+        px = r.lock().get();
+        pn = r.pn;
+        return *this;
+    }
+
+    template&lt;class Y&gt;
+    weak_ptr &amp; operator=(shared_ptr&lt;Y&gt; const &amp; r) // never throws
+    {
+        px = r.px;
+        pn = r.pn;
+        return *this;
+    }
+
+#endif
+
+    shared_ptr&lt;T&gt; lock() const // never throws
+    {
+#if defined(BOOST_HAS_THREADS)
+
+        // optimization: avoid throw overhead
+        if(expired())
+        {
+            return shared_ptr&lt;element_type&gt;();
+        }
+
+        try
+        {
+            return shared_ptr&lt;element_type&gt;(*this);
+        }
+        catch(bad_weak_ptr const &amp;)
+        {
+            // Q: how can we get here?
+            // A: another thread may have invalidated r after the use_count test above.
+            return shared_ptr&lt;element_type&gt;();
+        }
+
+#else
+
+        // optimization: avoid try/catch overhead when single threaded
+        return expired()? shared_ptr&lt;element_type&gt;(): shared_ptr&lt;element_type&gt;(*this);
+
+#endif
+    }
+
+    long use_count() const // never throws
+    {
+        return pn.use_count();
+    }
+
+    bool expired() const // never throws
+    {
+        return pn.use_count() == 0;
+    }
+
+    void reset() // never throws in 1.30+
+    {
+        this_type().swap(*this);
+    }
+
+    void swap(this_type &amp; other) // never throws
+    {
+        std::swap(px, other.px);
+        pn.swap(other.pn);
+    }
+
+    void _internal_assign(T * px2, detail::shared_count const &amp; pn2)
+    {
+        px = px2;
+        pn = pn2;
+    }
+
+    template&lt;class Y&gt; bool _internal_less(weak_ptr&lt;Y&gt; const &amp; rhs) const
+    {
+        return pn &lt; rhs.pn;
+    }
+
+// Tasteless as this may seem, making all members public allows member templates
+// to work in the absence of member template friends. (Matthew Langston)
+
+#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
+
+private:
+
+    template&lt;class Y&gt; friend class weak_ptr;
+    template&lt;class Y&gt; friend class shared_ptr;
+
+#endif
+
+    T * px;                     // contained pointer
+    detail::weak_count pn;      // reference counter
+
+};  // weak_ptr
+
+template&lt;class T, class U&gt; inline bool operator&lt;(weak_ptr&lt;T&gt; const &amp; a, weak_ptr&lt;U&gt; const &amp; b)
+{
+    return a._internal_less(b);
+}
+
+template&lt;class T&gt; void swap(weak_ptr&lt;T&gt; &amp; a, weak_ptr&lt;T&gt; &amp; b)
+{
+    a.swap(b);
+}
+
+// deprecated, provided for backward compatibility
+template&lt;class T&gt; shared_ptr&lt;T&gt; make_shared(weak_ptr&lt;T&gt; const &amp; r)
+{
+    return r.lock();
+}
+
+} // namespace boost
+
+#ifdef BOOST_MSVC
+# pragma warning(pop)
+#endif    
+
+#endif  // #ifndef BOOST_WEAK_PTR_HPP_INCLUDED

Added: trunk/msvc-libs/include/bufferobject.h
===================================================================
--- trunk/msvc-libs/include/bufferobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/bufferobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,33 @@
+
+/* Buffer object interface */
+
+/* Note: the object's structure is private */
+
+#ifndef Py_BUFFEROBJECT_H
+#define Py_BUFFEROBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+PyAPI_DATA(PyTypeObject) PyBuffer_Type;
+
+#define PyBuffer_Check(op) ((op)-&gt;ob_type == &amp;PyBuffer_Type)
+
+#define Py_END_OF_BUFFER	(-1)
+
+PyAPI_FUNC(PyObject *) PyBuffer_FromObject(PyObject *base,
+                                                 int offset, int size);
+PyAPI_FUNC(PyObject *) PyBuffer_FromReadWriteObject(PyObject *base,
+                                                          int offset,
+                                                          int size);
+
+PyAPI_FUNC(PyObject *) PyBuffer_FromMemory(void *ptr, int size);
+PyAPI_FUNC(PyObject *) PyBuffer_FromReadWriteMemory(void *ptr, int size);
+
+PyAPI_FUNC(PyObject *) PyBuffer_New(int size);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BUFFEROBJECT_H */

Added: trunk/msvc-libs/include/cStringIO.h
===================================================================
--- trunk/msvc-libs/include/cStringIO.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/cStringIO.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,70 @@
+#ifndef Py_CSTRINGIO_H
+#define Py_CSTRINGIO_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+/*
+
+  This header provides access to cStringIO objects from C.
+  Functions are provided for calling cStringIO objects and
+  macros are provided for testing whether you have cStringIO 
+  objects.
+
+  Before calling any of the functions or macros, you must initialize
+  the routines with:
+
+    PycString_IMPORT
+
+  This would typically be done in your init function.
+
+*/
+#define PycString_IMPORT \
+  PycStringIO = (struct PycStringIO_CAPI*)PyCObject_Import(&quot;cStringIO&quot;, \
+                                                           &quot;cStringIO_CAPI&quot;)
+
+/* Basic functions to manipulate cStringIO objects from C */
+
+static struct PycStringIO_CAPI {
+  
+ /* Read a string from an input object.  If the last argument
+    is -1, the remainder will be read.
+    */
+  int(*cread)(PyObject *, char **, int);
+
+ /* Read a line from an input object.  Returns the length of the read
+    line as an int and a pointer inside the object buffer as char** (so
+    the caller doesn't have to provide its own buffer as destination).
+    */
+  int(*creadline)(PyObject *, char **);
+
+  /* Write a string to an output object*/
+  int(*cwrite)(PyObject *, char *, int);
+
+  /* Get the output object as a Python string (returns new reference). */
+  PyObject *(*cgetvalue)(PyObject *);
+
+  /* Create a new output object */
+  PyObject *(*NewOutput)(int);
+
+  /* Create an input object from a Python string
+     (copies the Python string reference).
+     */
+  PyObject *(*NewInput)(PyObject *);
+
+  /* The Python types for cStringIO input and output objects.
+     Note that you can do input on an output object.
+     */
+  PyTypeObject *InputType, *OutputType;
+
+} *PycStringIO;
+
+/* These can be used to test if you have one */
+#define PycStringIO_InputCheck(O) \
+  ((O)-&gt;ob_type==PycStringIO-&gt;InputType)
+#define PycStringIO_OutputCheck(O) \
+  ((O)-&gt;ob_type==PycStringIO-&gt;OutputType)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CSTRINGIO_H */

Added: trunk/msvc-libs/include/cellobject.h
===================================================================
--- trunk/msvc-libs/include/cellobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/cellobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,28 @@
+/* Cell object interface */
+
+#ifndef Py_CELLOBJECT_H
+#define Py_CELLOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *ob_ref;	/* Content of the cell or NULL when empty */
+} PyCellObject;
+
+PyAPI_DATA(PyTypeObject) PyCell_Type;
+
+#define PyCell_Check(op) ((op)-&gt;ob_type == &amp;PyCell_Type)
+
+PyAPI_FUNC(PyObject *) PyCell_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyCell_Get(PyObject *);
+PyAPI_FUNC(int) PyCell_Set(PyObject *, PyObject *);
+
+#define PyCell_GET(op) (((PyCellObject *)(op))-&gt;ob_ref)
+#define PyCell_SET(op, v) (((PyCellObject *)(op))-&gt;ob_ref = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TUPLEOBJECT_H */

Added: trunk/msvc-libs/include/ceval.h
===================================================================
--- trunk/msvc-libs/include/ceval.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/ceval.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,154 @@
+#ifndef Py_CEVAL_H
+#define Py_CEVAL_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Interface to random parts in ceval.c */
+
+PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
+	PyObject *, PyObject *, PyObject *);
+
+/* DLL-level Backwards compatibility: */
+#undef PyEval_CallObject
+PyAPI_FUNC(PyObject *) PyEval_CallObject(PyObject *, PyObject *);
+
+/* Inline this */
+#define PyEval_CallObject(func,arg) \
+        PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)
+
+PyAPI_FUNC(PyObject *) PyEval_CallFunction(PyObject *obj, char *format, ...);
+PyAPI_FUNC(PyObject *) PyEval_CallMethod(PyObject *obj,
+                                        char *methodname, char *format, ...);
+
+PyAPI_FUNC(void) PyEval_SetProfile(Py_tracefunc, PyObject *);
+PyAPI_FUNC(void) PyEval_SetTrace(Py_tracefunc, PyObject *);
+
+struct _frame; /* Avoid including frameobject.h */
+
+PyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);
+PyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);
+PyAPI_FUNC(PyObject *) PyEval_GetLocals(void);
+PyAPI_FUNC(struct _frame *) PyEval_GetFrame(void);
+PyAPI_FUNC(int) PyEval_GetRestricted(void);
+
+/* Look at the current frame's (if any) code's co_flags, and turn on
+   the corresponding compiler flags in cf-&gt;cf_flags.  Return 1 if any
+   flag was set, else return 0. */
+PyAPI_FUNC(int) PyEval_MergeCompilerFlags(PyCompilerFlags *cf);
+
+PyAPI_FUNC(int) Py_FlushLine(void);
+
+PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
+PyAPI_FUNC(int) Py_MakePendingCalls(void);
+
+/* Protection against deeply nested recursive calls */
+PyAPI_FUNC(void) Py_SetRecursionLimit(int);
+PyAPI_FUNC(int) Py_GetRecursionLimit(void);
+
+#define Py_EnterRecursiveCall(where)                                    \
+	    (_Py_MakeRecCheck(PyThreadState_GET()-&gt;recursion_depth) &amp;&amp;  \
+	     _Py_CheckRecursiveCall(where))
+#define Py_LeaveRecursiveCall()				\
+	    (--PyThreadState_GET()-&gt;recursion_depth)
+PyAPI_FUNC(int) _Py_CheckRecursiveCall(char *where);
+PyAPI_DATA(int) _Py_CheckRecursionLimit;
+#ifdef USE_STACKCHECK
+#  define _Py_MakeRecCheck(x)  (++(x) &gt; --_Py_CheckRecursionLimit)
+#else
+#  define _Py_MakeRecCheck(x)  (++(x) &gt; _Py_CheckRecursionLimit)
+#endif
+
+PyAPI_FUNC(char *) PyEval_GetFuncName(PyObject *);
+PyAPI_FUNC(char *) PyEval_GetFuncDesc(PyObject *);
+
+PyAPI_FUNC(PyObject *) PyEval_GetCallStats(PyObject *);
+PyAPI_FUNC(PyObject *) PyEval_EvalFrame(struct _frame *);
+
+/* this used to be handled on a per-thread basis - now just two globals */
+PyAPI_DATA(volatile int) _Py_Ticker;
+PyAPI_DATA(int) _Py_CheckInterval;
+
+/* Interface for threads.
+
+   A module that plans to do a blocking system call (or something else
+   that lasts a long time and doesn't touch Python data) can allow other
+   threads to run as follows:
+
+	...preparations here...
+	Py_BEGIN_ALLOW_THREADS
+	...blocking system call here...
+	Py_END_ALLOW_THREADS
+	...interpret result here...
+
+   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
+   {}-surrounded block.
+   To leave the block in the middle (e.g., with return), you must insert
+   a line containing Py_BLOCK_THREADS before the return, e.g.
+
+	if (...premature_exit...) {
+		Py_BLOCK_THREADS
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+
+   An alternative is:
+
+	Py_BLOCK_THREADS
+	if (...premature_exit...) {
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+	Py_UNBLOCK_THREADS
+
+   For convenience, that the value of 'errno' is restored across
+   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.
+
+   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
+   Py_END_ALLOW_THREADS!!!
+
+   The function PyEval_InitThreads() should be called only from
+   initthread() in &quot;threadmodule.c&quot;.
+
+   Note that not yet all candidates have been converted to use this
+   mechanism!
+*/
+
+PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
+PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
+
+#ifdef WITH_THREAD
+
+PyAPI_FUNC(int)  PyEval_ThreadsInitialized(void);
+PyAPI_FUNC(void) PyEval_InitThreads(void);
+PyAPI_FUNC(void) PyEval_AcquireLock(void);
+PyAPI_FUNC(void) PyEval_ReleaseLock(void);
+PyAPI_FUNC(void) PyEval_AcquireThread(PyThreadState *tstate);
+PyAPI_FUNC(void) PyEval_ReleaseThread(PyThreadState *tstate);
+PyAPI_FUNC(void) PyEval_ReInitThreads(void);
+
+#define Py_BEGIN_ALLOW_THREADS { \
+			PyThreadState *_save; \
+			_save = PyEval_SaveThread();
+#define Py_BLOCK_THREADS	PyEval_RestoreThread(_save);
+#define Py_UNBLOCK_THREADS	_save = PyEval_SaveThread();
+#define Py_END_ALLOW_THREADS	PyEval_RestoreThread(_save); \
+		 }
+
+#else /* !WITH_THREAD */
+
+#define Py_BEGIN_ALLOW_THREADS {
+#define Py_BLOCK_THREADS
+#define Py_UNBLOCK_THREADS
+#define Py_END_ALLOW_THREADS }
+
+#endif /* !WITH_THREAD */
+
+PyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, int *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CEVAL_H */

Added: trunk/msvc-libs/include/classobject.h
===================================================================
--- trunk/msvc-libs/include/classobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/classobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,81 @@
+
+/* Class object interface */
+
+/* Revealing some structures (not for general use) */
+
+#ifndef Py_CLASSOBJECT_H
+#define Py_CLASSOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    PyObject	*cl_bases;	/* A tuple of class objects */
+    PyObject	*cl_dict;	/* A dictionary */
+    PyObject	*cl_name;	/* A string */
+    /* The following three are functions or NULL */
+    PyObject	*cl_getattr;
+    PyObject	*cl_setattr;
+    PyObject	*cl_delattr;
+} PyClassObject;
+
+typedef struct {
+    PyObject_HEAD
+    PyClassObject *in_class;	/* The class object */
+    PyObject	  *in_dict;	/* A dictionary */
+    PyObject	  *in_weakreflist; /* List of weak references */
+} PyInstanceObject;
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *im_func;   /* The callable object implementing the method */
+    PyObject *im_self;   /* The instance it is bound to, or NULL */
+    PyObject *im_class;  /* The class that asked for the method */
+    PyObject *im_weakreflist; /* List of weak references */
+} PyMethodObject;
+
+PyAPI_DATA(PyTypeObject) PyClass_Type, PyInstance_Type, PyMethod_Type;
+
+#define PyClass_Check(op) ((op)-&gt;ob_type == &amp;PyClass_Type)
+#define PyInstance_Check(op) ((op)-&gt;ob_type == &amp;PyInstance_Type)
+#define PyMethod_Check(op) ((op)-&gt;ob_type == &amp;PyMethod_Type)
+
+PyAPI_FUNC(PyObject *) PyClass_New(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyInstance_New(PyObject *, PyObject *,
+                                            PyObject *);
+PyAPI_FUNC(PyObject *) PyInstance_NewRaw(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_New(PyObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(PyObject *) PyMethod_Function(PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_Self(PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_Class(PyObject *);
+
+/* Look up attribute with name (a string) on instance object pinst, using
+ * only the instance and base class dicts.  If a descriptor is found in
+ * a class dict, the descriptor is returned without calling it.
+ * Returns NULL if nothing found, else a borrowed reference to the
+ * value associated with name in the dict in which name was found.
+ * The point of this routine is that it never calls arbitrary Python
+ * code, so is always &quot;safe&quot;:  all it does is dict lookups.  The function
+ * can't fail, never sets an exception, and NULL is not an error (it just
+ * means &quot;not found&quot;).
+ */
+PyAPI_FUNC(PyObject *) _PyInstance_Lookup(PyObject *pinst, PyObject *name);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyMethod_GET_FUNCTION(meth) \
+        (((PyMethodObject *)meth) -&gt; im_func)
+#define PyMethod_GET_SELF(meth) \
+	(((PyMethodObject *)meth) -&gt; im_self)
+#define PyMethod_GET_CLASS(meth) \
+	(((PyMethodObject *)meth) -&gt; im_class)
+
+PyAPI_FUNC(int) PyClass_IsSubclass(PyObject *, PyObject *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CLASSOBJECT_H */

Added: trunk/msvc-libs/include/cobject.h
===================================================================
--- trunk/msvc-libs/include/cobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/cobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,54 @@
+
+/* C objects to be exported from one extension module to another.
+ 
+   C objects are used for communication between extension modules.
+   They provide a way for an extension module to export a C interface
+   to other extension modules, so that extension modules can use the
+   Python import mechanism to link to one another.
+
+*/
+
+#ifndef Py_COBJECT_H
+#define Py_COBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyCObject_Type;
+
+#define PyCObject_Check(op) ((op)-&gt;ob_type == &amp;PyCObject_Type)
+
+/* Create a PyCObject from a pointer to a C object and an optional
+   destructor function.  If the second argument is non-null, then it
+   will be called with the first argument if and when the PyCObject is
+   destroyed.
+
+*/
+PyAPI_FUNC(PyObject *) PyCObject_FromVoidPtr(
+	void *cobj, void (*destruct)(void*));
+
+
+/* Create a PyCObject from a pointer to a C object, a description object,
+   and an optional destructor function.  If the third argument is non-null,
+   then it will be called with the first and second arguments if and when 
+   the PyCObject is destroyed.
+*/
+PyAPI_FUNC(PyObject *) PyCObject_FromVoidPtrAndDesc(
+	void *cobj, void *desc, void (*destruct)(void*,void*));
+
+/* Retrieve a pointer to a C object from a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_AsVoidPtr(PyObject *);
+
+/* Retrieve a pointer to a description object from a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_GetDesc(PyObject *);
+
+/* Import a pointer to a C object from a module using a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_Import(char *module_name, char *cobject_name);
+
+/* Modify a C object. Fails (==0) if object has a destructor. */
+PyAPI_FUNC(int) PyCObject_SetVoidPtr(PyObject *self, void *cobj);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COBJECT_H */

Added: trunk/msvc-libs/include/codecs.h
===================================================================
--- trunk/msvc-libs/include/codecs.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/codecs.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,153 @@
+#ifndef Py_CODECREGISTRY_H
+#define Py_CODECREGISTRY_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* ------------------------------------------------------------------------
+
+   Python Codec Registry and support functions
+
+
+Written by Marc-Andre Lemburg (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">mal at lemburg.com</A>).
+
+Copyright (c) Corporation for National Research Initiatives.
+
+   ------------------------------------------------------------------------ */
+
+/* Register a new codec search function.
+
+   As side effect, this tries to load the encodings package, if not
+   yet done, to make sure that it is always first in the list of
+   search functions.
+
+   The search_function's refcount is incremented by this function. */
+
+PyAPI_FUNC(int) PyCodec_Register(
+       PyObject *search_function
+       );
+
+/* Codec register lookup API.
+
+   Looks up the given encoding and returns a tuple (encoder, decoder,
+   stream reader, stream writer) of functions which implement the
+   different aspects of processing the encoding.
+
+   The encoding string is looked up converted to all lower-case
+   characters. This makes encodings looked up through this mechanism
+   effectively case-insensitive.
+
+   If no codec is found, a KeyError is set and NULL returned. 
+
+   As side effect, this tries to load the encodings package, if not
+   yet done. This is part of the lazy load strategy for the encodings
+   package.
+
+ */
+
+PyAPI_FUNC(PyObject *) _PyCodec_Lookup(
+       const char *encoding
+       );
+
+/* Generic codec based encoding API.
+
+   object is passed through the encoder function found for the given
+   encoding using the error handling method defined by errors. errors
+   may be NULL to use the default method defined for the codec.
+   
+   Raises a LookupError in case no encoder can be found.
+
+ */
+
+PyAPI_FUNC(PyObject *) PyCodec_Encode(
+       PyObject *object,
+       const char *encoding,
+       const char *errors
+       );
+
+/* Generic codec based decoding API.
+
+   object is passed through the decoder function found for the given
+   encoding using the error handling method defined by errors. errors
+   may be NULL to use the default method defined for the codec.
+   
+   Raises a LookupError in case no encoder can be found.
+
+ */
+
+PyAPI_FUNC(PyObject *) PyCodec_Decode(
+       PyObject *object,
+       const char *encoding,
+       const char *errors
+       );
+
+/* --- Codec Lookup APIs -------------------------------------------------- 
+
+   All APIs return a codec object with incremented refcount and are
+   based on _PyCodec_Lookup().  The same comments w/r to the encoding
+   name also apply to these APIs.
+
+*/
+
+/* Get an encoder function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_Encoder(
+       const char *encoding
+       );
+
+/* Get a decoder function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_Decoder(
+       const char *encoding
+       );
+
+/* Get a StreamReader factory function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_StreamReader(
+       const char *encoding,
+       PyObject *stream,
+       const char *errors
+       );
+
+/* Get a StreamWriter factory function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_StreamWriter(
+       const char *encoding,
+       PyObject *stream,
+       const char *errors
+       );
+
+/* Unicode encoding error handling callback registry API */
+
+/* Register the error handling callback function error under the name
+   name. This function will be called by the codec when it encounters
+   unencodable characters/undecodable bytes and doesn't know the
+   callback name, when name is specified as the error parameter
+   in the call to the encode/decode function.
+   Return 0 on success, -1 on error */
+PyAPI_FUNC(int) PyCodec_RegisterError(const char *name, PyObject *error);
+
+/* Lookup the error handling callback function registered under the
+   name error. As a special case NULL can be passed, in which case
+   the error handling callback for &quot;strict&quot; will be returned. */
+PyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);
+
+/* raise exc as an exception */
+PyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);
+
+/* ignore the unicode error, skipping the faulty input */
+PyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);
+
+/* replace the unicode error with ? or U+FFFD */
+PyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);
+
+/* replace the unicode encode error with XML character references */
+PyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
+
+/* replace the unicode encode error with backslash escapes (\x, \u and \U) */
+PyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CODECREGISTRY_H */

Added: trunk/msvc-libs/include/compile.h
===================================================================
--- trunk/msvc-libs/include/compile.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/compile.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,87 @@
+
+/* Definitions for bytecode */
+
+#ifndef Py_COMPILE_H
+#define Py_COMPILE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Bytecode object */
+typedef struct {
+    PyObject_HEAD
+    int co_argcount;		/* #arguments, except *args */
+    int co_nlocals;		/* #local variables */
+    int co_stacksize;		/* #entries needed for evaluation stack */
+    int co_flags;		/* CO_..., see below */
+    PyObject *co_code;		/* instruction opcodes */
+    PyObject *co_consts;	/* list (constants used) */
+    PyObject *co_names;		/* list of strings (names used) */
+    PyObject *co_varnames;	/* tuple of strings (local variable names) */
+    PyObject *co_freevars;	/* tuple of strings (free variable names) */
+    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
+    /* The rest doesn't count for hash/cmp */
+    PyObject *co_filename;	/* string (where it was loaded from) */
+    PyObject *co_name;		/* string (name, for reference) */
+    int co_firstlineno;		/* first source line number */
+    PyObject *co_lnotab;	/* string (encoding addr&lt;-&gt;lineno mapping) */
+} PyCodeObject;
+
+/* Masks for co_flags above */
+#define CO_OPTIMIZED	0x0001
+#define CO_NEWLOCALS	0x0002
+#define CO_VARARGS	0x0004
+#define CO_VARKEYWORDS	0x0008
+#define CO_NESTED       0x0010
+#define CO_GENERATOR    0x0020
+/* The CO_NOFREE flag is set if there are no free or cell variables.
+   This information is redundant, but it allows a single flag test
+   to determine whether there is any extra work to be done when the
+   call frame it setup.
+*/
+#define CO_NOFREE       0x0040
+/* XXX Temporary hack.  Until generators are a permanent part of the
+   language, we need a way for a code object to record that generators
+   were *possible* when it was compiled.  This is so code dynamically
+   compiled *by* a code object knows whether to allow yield stmts.  In
+   effect, this passes on the &quot;from __future__ import generators&quot; state
+   in effect when the code block was compiled. */
+#define CO_GENERATOR_ALLOWED    0x1000 /* no longer used in an essential way */
+#define CO_FUTURE_DIVISION    	0x2000
+
+PyAPI_DATA(PyTypeObject) PyCode_Type;
+
+#define PyCode_Check(op) ((op)-&gt;ob_type == &amp;PyCode_Type)
+#define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)-&gt;co_freevars))
+
+#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */
+
+/* Public interface */
+struct _node; /* Declare the existence of this type */
+PyAPI_FUNC(PyCodeObject *) PyNode_Compile(struct _node *, const char *);
+PyAPI_FUNC(PyCodeObject *) PyCode_New(
+	int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
+	PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *); 
+        /* same as struct above */
+PyAPI_FUNC(int) PyCode_Addr2Line(PyCodeObject *, int);
+
+/* Future feature support */
+
+typedef struct {
+    int ff_found_docstring;
+    int ff_last_lineno;
+    int ff_features;
+} PyFutureFeatures;
+
+PyAPI_FUNC(PyFutureFeatures *) PyNode_Future(struct _node *, const char *);
+PyAPI_FUNC(PyCodeObject *) PyNode_CompileFlags(struct _node *, const char *,
+					      PyCompilerFlags *);
+
+#define FUTURE_NESTED_SCOPES &quot;nested_scopes&quot;
+#define FUTURE_GENERATORS &quot;generators&quot;
+#define FUTURE_DIVISION &quot;division&quot;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COMPILE_H */

Added: trunk/msvc-libs/include/complexobject.h
===================================================================
--- trunk/msvc-libs/include/complexobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/complexobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,58 @@
+/* Complex number structure */
+
+#ifndef Py_COMPLEXOBJECT_H
+#define Py_COMPLEXOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    double real;
+    double imag;
+} Py_complex;
+
+/* Operations on complex numbers from complexmodule.c */
+
+#define c_sum _Py_c_sum
+#define c_diff _Py_c_diff
+#define c_neg _Py_c_neg
+#define c_prod _Py_c_prod
+#define c_quot _Py_c_quot
+#define c_pow _Py_c_pow
+
+PyAPI_FUNC(Py_complex) c_sum(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_diff(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_neg(Py_complex);
+PyAPI_FUNC(Py_complex) c_prod(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_quot(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_pow(Py_complex, Py_complex);
+
+
+/* Complex object interface */
+
+/*
+PyComplexObject represents a complex number with double-precision
+real and imaginary parts.
+*/
+
+typedef struct {
+    PyObject_HEAD
+    Py_complex cval;
+} PyComplexObject;     
+
+PyAPI_DATA(PyTypeObject) PyComplex_Type;
+
+#define PyComplex_Check(op) PyObject_TypeCheck(op, &amp;PyComplex_Type)
+#define PyComplex_CheckExact(op) ((op)-&gt;ob_type == &amp;PyComplex_Type)
+
+PyAPI_FUNC(PyObject *) PyComplex_FromCComplex(Py_complex);
+PyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);
+
+PyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);
+PyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);
+PyAPI_FUNC(Py_complex) PyComplex_AsCComplex(PyObject *op);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COMPLEXOBJECT_H */

Added: trunk/msvc-libs/include/datetime.h
===================================================================
--- trunk/msvc-libs/include/datetime.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/datetime.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,245 @@
+/*  datetime.h
+ */
+
+#ifndef DATETIME_H
+#define DATETIME_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Fields are packed into successive bytes, each viewed as unsigned and
+ * big-endian, unless otherwise noted:
+ *
+ * byte offset
+ *  0 		year     2 bytes, 1-9999
+ *  2		month    1 byte, 1-12
+ *  3 		day      1 byte, 1-31
+ *  4		hour     1 byte, 0-23
+ *  5 		minute   1 byte, 0-59
+ *  6 		second   1 byte, 0-59
+ *  7 		usecond  3 bytes, 0-999999
+ * 10
+ */
+
+/* # of bytes for year, month, and day. */
+#define _PyDateTime_DATE_DATASIZE 4
+
+/* # of bytes for hour, minute, second, and usecond. */
+#define _PyDateTime_TIME_DATASIZE 6
+
+/* # of bytes for year, month, day, hour, minute, second, and usecond. */
+#define _PyDateTime_DATETIME_DATASIZE 10
+
+
+typedef struct
+{
+	PyObject_HEAD
+	long hashcode;		/* -1 when unknown */
+	int days;		/* -MAX_DELTA_DAYS &lt;= days &lt;= MAX_DELTA_DAYS */
+	int seconds;		/* 0 &lt;= seconds &lt; 24*3600 is invariant */
+	int microseconds;	/* 0 &lt;= microseconds &lt; 1000000 is invariant */
+} PyDateTime_Delta;
+
+typedef struct
+{
+	PyObject_HEAD		/* a pure abstract base clase */
+} PyDateTime_TZInfo;
+
+
+/* The datetime and time types have hashcodes, and an optional tzinfo member,
+ * present if and only if hastzinfo is true.
+ */
+#define _PyTZINFO_HEAD		\
+	PyObject_HEAD		\
+	long hashcode;		\
+	char hastzinfo;		/* boolean flag */
+
+/* No _PyDateTime_BaseTZInfo is allocated; it's just to have something
+ * convenient to cast to, when getting at the hastzinfo member of objects
+ * starting with _PyTZINFO_HEAD.
+ */
+typedef struct
+{
+	_PyTZINFO_HEAD
+} _PyDateTime_BaseTZInfo;
+
+/* All time objects are of PyDateTime_TimeType, but that can be allocated
+ * in two ways, with or without a tzinfo member.  Without is the same as
+ * tzinfo == None, but consumes less memory.  _PyDateTime_BaseTime is an
+ * internal struct used to allocate the right amount of space for the
+ * &quot;without&quot; case.
+ */
+#define _PyDateTime_TIMEHEAD	\
+	_PyTZINFO_HEAD		\
+	unsigned char data[_PyDateTime_TIME_DATASIZE];
+
+typedef struct
+{
+	_PyDateTime_TIMEHEAD
+} _PyDateTime_BaseTime;		/* hastzinfo false */
+
+typedef struct
+{
+	_PyDateTime_TIMEHEAD
+	PyObject *tzinfo;
+} PyDateTime_Time;		/* hastzinfo true */
+
+
+/* All datetime objects are of PyDateTime_DateTimeType, but that can be
+ * allocated in two ways too, just like for time objects above.  In addition,
+ * the plain date type is a base class for datetime, so it must also have
+ * a hastzinfo member (although it's unused there).
+ */
+typedef struct
+{
+	_PyTZINFO_HEAD
+	unsigned char data[_PyDateTime_DATE_DATASIZE];
+} PyDateTime_Date;
+
+#define _PyDateTime_DATETIMEHEAD	\
+	_PyTZINFO_HEAD			\
+	unsigned char data[_PyDateTime_DATETIME_DATASIZE];
+
+typedef struct
+{
+	_PyDateTime_DATETIMEHEAD
+} _PyDateTime_BaseDateTime;	/* hastzinfo false */
+
+typedef struct
+{
+	_PyDateTime_DATETIMEHEAD
+	PyObject *tzinfo;
+} PyDateTime_DateTime;		/* hastzinfo true */
+
+
+/* Apply for date and datetime instances. */
+#define PyDateTime_GET_YEAR(o)     ((((PyDateTime_Date*)o)-&gt;data[0] &lt;&lt; 8) | \
+                                     ((PyDateTime_Date*)o)-&gt;data[1])
+#define PyDateTime_GET_MONTH(o)    (((PyDateTime_Date*)o)-&gt;data[2])
+#define PyDateTime_GET_DAY(o)      (((PyDateTime_Date*)o)-&gt;data[3])
+
+#define PyDateTime_DATE_GET_HOUR(o)        (((PyDateTime_DateTime*)o)-&gt;data[4])
+#define PyDateTime_DATE_GET_MINUTE(o)      (((PyDateTime_DateTime*)o)-&gt;data[5])
+#define PyDateTime_DATE_GET_SECOND(o)      (((PyDateTime_DateTime*)o)-&gt;data[6])
+#define PyDateTime_DATE_GET_MICROSECOND(o) 		\
+	((((PyDateTime_DateTime*)o)-&gt;data[7] &lt;&lt; 16) |	\
+         (((PyDateTime_DateTime*)o)-&gt;data[8] &lt;&lt; 8)  |	\
+          ((PyDateTime_DateTime*)o)-&gt;data[9])
+
+/* Apply for time instances. */
+#define PyDateTime_TIME_GET_HOUR(o)        (((PyDateTime_Time*)o)-&gt;data[0])
+#define PyDateTime_TIME_GET_MINUTE(o)      (((PyDateTime_Time*)o)-&gt;data[1])
+#define PyDateTime_TIME_GET_SECOND(o)      (((PyDateTime_Time*)o)-&gt;data[2])
+#define PyDateTime_TIME_GET_MICROSECOND(o) 		\
+	((((PyDateTime_Time*)o)-&gt;data[3] &lt;&lt; 16) |	\
+         (((PyDateTime_Time*)o)-&gt;data[4] &lt;&lt; 8)  |	\
+          ((PyDateTime_Time*)o)-&gt;data[5])
+
+
+/* Define structure for C API. */
+typedef struct {
+    /* type objects */
+    PyTypeObject *DateType;
+    PyTypeObject *DateTimeType;
+    PyTypeObject *TimeType;
+    PyTypeObject *DeltaType;
+    PyTypeObject *TZInfoType;
+
+    /* constructors */
+    PyObject *(*Date_FromDate)(int, int, int, PyTypeObject*);
+    PyObject *(*DateTime_FromDateAndTime)(int, int, int, int, int, int, int,
+            PyObject*, PyTypeObject*);
+    PyObject *(*Time_FromTime)(int, int, int, int, PyObject*, PyTypeObject*);
+    PyObject *(*Delta_FromDelta)(int, int, int, int, PyTypeObject*);
+
+    /* constructors for the DB API */
+    PyObject *(*DateTime_FromTimestamp)(PyObject*, PyObject*, PyObject*);
+    PyObject *(*Date_FromTimestamp)(PyObject*, PyObject*);
+
+} PyDateTime_CAPI;
+
+
+/* &quot;magic&quot; constant used to partially protect against developer mistakes. */
+#define DATETIME_API_MAGIC 0x414548d5
+
+#ifdef Py_BUILD_CORE
+
+/* Macros for type checking when building the Python core. */
+#define PyDate_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_DateType)
+#define PyDate_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_DateType)
+
+#define PyDateTime_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_DateTimeType)
+#define PyDateTime_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_DateTimeType)
+
+#define PyTime_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_TimeType)
+#define PyTime_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_TimeType)
+
+#define PyDelta_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_DeltaType)
+#define PyDelta_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_DeltaType)
+
+#define PyTZInfo_Check(op) PyObject_TypeCheck(op, &amp;PyDateTime_TZInfoType)
+#define PyTZInfo_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDateTime_TZInfoType)
+
+#else
+
+/* Define global variable for the C API and a macro for setting it. */
+static PyDateTime_CAPI *PyDateTimeAPI;
+
+#define PyDateTime_IMPORT \
+        PyDateTimeAPI = (PyDateTime_CAPI*) PyCObject_Import(&quot;datetime&quot;, \
+                                                            &quot;datetime_CAPI&quot;)
+
+/* This macro would be used if PyCObject_ImportEx() was created.
+#define PyDateTime_IMPORT \
+        PyDateTimeAPI = (PyDateTime_CAPI*) PyCObject_ImportEx(&quot;datetime&quot;, \
+                                                            &quot;datetime_CAPI&quot;, \
+                                                            DATETIME_API_MAGIC)
+*/
+
+/* Macros for type checking when not building the Python core. */
+#define PyDate_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;DateType)
+#define PyDate_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;DateType)
+
+#define PyDateTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;DateTimeType)
+#define PyDateTime_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;DateTimeType)
+
+#define PyTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;TimeType)
+#define PyTime_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;TimeType)
+
+#define PyDelta_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;DeltaType)
+#define PyDelta_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;DeltaType)
+
+#define PyTZInfo_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI-&gt;TZInfoType)
+#define PyTZInfo_CheckExact(op) ((op)-&gt;ob_type == PyDateTimeAPI-&gt;TZInfoType)
+
+/* Macros for accessing constructors in a simplified fashion. */
+#define PyDate_FromDate(year, month, day) \
+	PyDateTimeAPI-&gt;Date_FromDate(year, month, day, PyDateTimeAPI-&gt;DateType)
+
+#define PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, usec) \
+	PyDateTimeAPI-&gt;DateTime_FromDateAndTime(year, month, day, hour, \
+		min, sec, usec, Py_None, PyDateTimeAPI-&gt;DateTimeType)
+
+#define PyTime_FromTime(hour, minute, second, usecond) \
+	PyDateTimeAPI-&gt;Time_FromTime(hour, minute, second, usecond, \
+		Py_None, PyDateTimeAPI-&gt;TimeType)
+
+#define PyDelta_FromDSU(days, seconds, useconds) \
+	PyDateTimeAPI-&gt;Delta_FromDelta(days, seconds, useconds, 1, \
+		PyDateTimeAPI-&gt;DeltaType)
+
+/* Macros supporting the DB API. */
+#define PyDateTime_FromTimestamp(args) \
+	PyDateTimeAPI-&gt;DateTime_FromTimestamp( \
+		(PyObject*) (PyDateTimeAPI-&gt;DateTimeType), args, NULL)
+
+#define PyDate_FromTimestamp(args) \
+	PyDateTimeAPI-&gt;Date_FromTimestamp( \
+		(PyObject*) (PyDateTimeAPI-&gt;DateType), args)
+
+#endif	/* Py_BUILD_CORE */
+
+#ifdef __cplusplus
+}
+#endif
+#endif

Added: trunk/msvc-libs/include/descrobject.h
===================================================================
--- trunk/msvc-libs/include/descrobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/descrobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,91 @@
+/* Descriptors */
+#ifndef Py_DESCROBJECT_H
+#define Py_DESCROBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef PyObject *(*getter)(PyObject *, void *);
+typedef int (*setter)(PyObject *, PyObject *, void *);
+
+typedef struct PyGetSetDef {
+	char *name;
+	getter get;
+	setter set;
+	char *doc;
+	void *closure;
+} PyGetSetDef;
+
+typedef PyObject *(*wrapperfunc)(PyObject *self, PyObject *args,
+				 void *wrapped);
+
+typedef PyObject *(*wrapperfunc_kwds)(PyObject *self, PyObject *args,
+				      void *wrapped, PyObject *kwds);
+
+struct wrapperbase {
+	char *name;
+	int offset;
+	void *function;
+	wrapperfunc wrapper;
+	char *doc;
+	int flags;
+	PyObject *name_strobj;
+};
+
+/* Flags for above struct */
+#define PyWrapperFlag_KEYWORDS 1 /* wrapper function takes keyword args */
+
+/* Various kinds of descriptor objects */
+
+#define PyDescr_COMMON \
+	PyObject_HEAD \
+	PyTypeObject *d_type; \
+	PyObject *d_name
+
+typedef struct {
+	PyDescr_COMMON;
+} PyDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	PyMethodDef *d_method;
+} PyMethodDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	struct PyMemberDef *d_member;
+} PyMemberDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	PyGetSetDef *d_getset;
+} PyGetSetDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	struct wrapperbase *d_base;
+	void *d_wrapped; /* This can be any function pointer */
+} PyWrapperDescrObject;
+
+PyAPI_DATA(PyTypeObject) PyWrapperDescr_Type;
+
+PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *,
+					       struct PyMemberDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *,
+					       struct PyGetSetDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,
+						struct wrapperbase *, void *);
+#define PyDescr_IsData(d) ((d)-&gt;ob_type-&gt;tp_descr_set != NULL)
+
+PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);
+
+
+PyAPI_DATA(PyTypeObject) PyProperty_Type;
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_DESCROBJECT_H */
+

Added: trunk/msvc-libs/include/dictobject.h
===================================================================
--- trunk/msvc-libs/include/dictobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/dictobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,134 @@
+#ifndef Py_DICTOBJECT_H
+#define Py_DICTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Dictionary object type -- mapping from hashable object to object */
+
+/* The distribution includes a separate file, Objects/dictnotes.txt,
+   describing explorations into dictionary design and optimization.  
+   It covers typical dictionary use patterns, the parameters for
+   tuning dictionaries, and several ideas for possible optimizations.
+*/
+
+/*
+There are three kinds of slots in the table:
+
+1. Unused.  me_key == me_value == NULL
+   Does not hold an active (key, value) pair now and never did.  Unused can
+   transition to Active upon key insertion.  This is the only case in which
+   me_key is NULL, and is each slot's initial state.
+
+2. Active.  me_key != NULL and me_key != dummy and me_value != NULL
+   Holds an active (key, value) pair.  Active can transition to Dummy upon
+   key deletion.  This is the only case in which me_value != NULL.
+
+3. Dummy.  me_key == dummy and me_value == NULL
+   Previously held an active (key, value) pair, but that was deleted and an
+   active pair has not yet overwritten the slot.  Dummy can transition to
+   Active upon key insertion.  Dummy slots cannot be made Unused again
+   (cannot have me_key set to NULL), else the probe sequence in case of
+   collision would have no way to know they were once active.
+
+Note: .popitem() abuses the me_hash field of an Unused or Dummy slot to
+hold a search finger.  The me_hash field of Unused or Dummy slots has no
+meaning otherwise.
+*/
+
+/* PyDict_MINSIZE is the minimum size of a dictionary.  This many slots are
+ * allocated directly in the dict object (in the ma_smalltable member).
+ * It must be a power of 2, and at least 4.  8 allows dicts with no more
+ * than 5 active entries to live in ma_smalltable (and so avoid an
+ * additional malloc); instrumentation suggested this suffices for the
+ * majority of dicts (consisting mostly of usually-small instance dicts and
+ * usually-small dicts created to pass keyword arguments).
+ */
+#define PyDict_MINSIZE 8
+
+typedef struct {
+	long me_hash;      /* cached hash code of me_key */
+	PyObject *me_key;
+	PyObject *me_value;
+} PyDictEntry;
+
+/*
+To ensure the lookup algorithm terminates, there must be at least one Unused
+slot (NULL key) in the table.
+The value ma_fill is the number of non-NULL keys (sum of Active and Dummy);
+ma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL
+values == the number of Active items).
+To avoid slowing down lookups on a near-full table, we resize the table when
+it's two-thirds full.
+*/
+typedef struct _dictobject PyDictObject;
+struct _dictobject {
+	PyObject_HEAD
+	int ma_fill;  /* # Active + # Dummy */
+	int ma_used;  /* # Active */
+
+	/* The table contains ma_mask + 1 slots, and that's a power of 2.
+	 * We store the mask instead of the size because the mask is more
+	 * frequently needed.
+	 */
+	int ma_mask;
+
+	/* ma_table points to ma_smalltable for small tables, else to
+	 * additional malloc'ed memory.  ma_table is never NULL!  This rule
+	 * saves repeated runtime null-tests in the workhorse getitem and
+	 * setitem calls.
+	 */
+	PyDictEntry *ma_table;
+	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
+	PyDictEntry ma_smalltable[PyDict_MINSIZE];
+};
+
+PyAPI_DATA(PyTypeObject) PyDict_Type;
+
+#define PyDict_Check(op) PyObject_TypeCheck(op, &amp;PyDict_Type)
+#define PyDict_CheckExact(op) ((op)-&gt;ob_type == &amp;PyDict_Type)
+
+PyAPI_FUNC(PyObject *) PyDict_New(void);
+PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
+PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Next(
+	PyObject *mp, int *pos, PyObject **key, PyObject **value);
+PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Size(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);
+
+/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
+PyAPI_FUNC(int) PyDict_Update(PyObject *mp, PyObject *other);
+
+/* PyDict_Merge updates/merges from a mapping object (an object that
+   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
+   the last occurrence of a key wins, else the first.  The Python
+   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
+*/
+PyAPI_FUNC(int) PyDict_Merge(PyObject *mp,
+				   PyObject *other,
+				   int override);
+
+/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
+   iterable objects of length 2.  If override is true, the last occurrence
+   of a key wins, else the first.  The Python dict constructor dict(seq2)
+   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
+*/
+PyAPI_FUNC(int) PyDict_MergeFromSeq2(PyObject *d,
+					   PyObject *seq2,
+					   int override);
+
+PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
+PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_DICTOBJECT_H */

Added: trunk/msvc-libs/include/enumobject.h
===================================================================
--- trunk/msvc-libs/include/enumobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/enumobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,17 @@
+#ifndef Py_ENUMOBJECT_H
+#define Py_ENUMOBJECT_H
+
+/* Enumerate Object */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyEnum_Type;
+PyAPI_DATA(PyTypeObject) PyReversed_Type;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_ENUMOBJECT_H */

Added: trunk/msvc-libs/include/errcode.h
===================================================================
--- trunk/msvc-libs/include/errcode.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/errcode.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,35 @@
+#ifndef Py_ERRCODE_H
+#define Py_ERRCODE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Error codes passed around between file input, tokenizer, parser and
+   interpreter.  This is necessary so we can turn them into Python
+   exceptions at a higher level.  Note that some errors have a
+   slightly different meaning when passed from the tokenizer to the
+   parser than when passed from the parser to the interpreter; e.g.
+   the parser only returns E_EOF when it hits EOF immediately, and it
+   never returns E_OK. */
+
+#define E_OK		10	/* No error */
+#define E_EOF		11	/* End Of File */
+#define E_INTR		12	/* Interrupted */
+#define E_TOKEN		13	/* Bad token */
+#define E_SYNTAX	14	/* Syntax error */
+#define E_NOMEM		15	/* Ran out of memory */
+#define E_DONE		16	/* Parsing complete */
+#define E_ERROR		17	/* Execution error */
+#define E_TABSPACE	18	/* Inconsistent mixing of tabs and spaces */
+#define E_OVERFLOW      19	/* Node had too many children */
+#define E_TOODEEP	20	/* Too many indentation levels */
+#define E_DEDENT	21	/* No matching outer block for dedent */
+#define E_DECODE	22	/* Error in decoding into Unicode */
+#define E_EOFS		23	/* EOF in triple-quoted string */
+#define E_EOLS		24	/* EOL in single-quoted string */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ERRCODE_H */

Added: trunk/msvc-libs/include/eval.h
===================================================================
--- trunk/msvc-libs/include/eval.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/eval.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,25 @@
+
+/* Interface to execute compiled code */
+
+#ifndef Py_EVAL_H
+#define Py_EVAL_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyCodeObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyCodeObject *co,
+					PyObject *globals,
+					PyObject *locals,
+					PyObject **args, int argc,
+					PyObject **kwds, int kwdc,
+					PyObject **defs, int defc,
+					PyObject *closure);
+
+PyAPI_FUNC(PyObject *) _PyEval_CallTracing(PyObject *func, PyObject *args);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_EVAL_H */

Added: trunk/msvc-libs/include/fileobject.h
===================================================================
--- trunk/msvc-libs/include/fileobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/fileobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,63 @@
+
+/* File object interface */
+
+#ifndef Py_FILEOBJECT_H
+#define Py_FILEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+	PyObject_HEAD
+	FILE *f_fp;
+	PyObject *f_name;
+	PyObject *f_mode;
+	int (*f_close)(FILE *);
+	int f_softspace;	/* Flag used by 'print' command */
+	int f_binary;		/* Flag which indicates whether the file is 
+				   open in binary (1) or text (0) mode */
+	char* f_buf;		/* Allocated readahead buffer */
+	char* f_bufend;		/* Points after last occupied position */
+	char* f_bufptr;		/* Current buffer position */
+	char *f_setbuf;		/* Buffer for setbuf(3) and setvbuf(3) */
+	int f_univ_newline;	/* Handle any newline convention */
+	int f_newlinetypes;	/* Types of newlines seen */
+	int f_skipnextlf;	/* Skip next \n */
+	PyObject *f_encoding;
+	PyObject *weakreflist; /* List of weak references */
+} PyFileObject;
+
+PyAPI_DATA(PyTypeObject) PyFile_Type;
+
+#define PyFile_Check(op) PyObject_TypeCheck(op, &amp;PyFile_Type)
+#define PyFile_CheckExact(op) ((op)-&gt;ob_type == &amp;PyFile_Type)
+
+PyAPI_FUNC(PyObject *) PyFile_FromString(char *, char *);
+PyAPI_FUNC(void) PyFile_SetBufSize(PyObject *, int);
+PyAPI_FUNC(int) PyFile_SetEncoding(PyObject *, const char *);
+PyAPI_FUNC(PyObject *) PyFile_FromFile(FILE *, char *, char *,
+                                             int (*)(FILE *));
+PyAPI_FUNC(FILE *) PyFile_AsFile(PyObject *);
+PyAPI_FUNC(PyObject *) PyFile_Name(PyObject *);
+PyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);
+PyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);
+PyAPI_FUNC(int) PyFile_SoftSpace(PyObject *, int);
+PyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);
+PyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);
+
+/* The default encoding used by the platform file system APIs
+   If non-NULL, this is different than the default encoding for strings
+*/
+PyAPI_DATA(const char *) Py_FileSystemDefaultEncoding;
+
+/* Routines to replace fread() and fgets() which accept any of \r, \n
+   or \r\n as line terminators.
+*/
+#define PY_STDIOTEXTMODE &quot;b&quot;
+char *Py_UniversalNewlineFgets(char *, int, FILE*, PyObject *);
+size_t Py_UniversalNewlineFread(char *, size_t, FILE *, PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FILEOBJECT_H */

Added: trunk/msvc-libs/include/floatobject.h
===================================================================
--- trunk/msvc-libs/include/floatobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/floatobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,95 @@
+
+/* Float object interface */
+
+/*
+PyFloatObject represents a (double precision) floating point number.
+*/
+
+#ifndef Py_FLOATOBJECT_H
+#define Py_FLOATOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    double ob_fval;
+} PyFloatObject;
+
+PyAPI_DATA(PyTypeObject) PyFloat_Type;
+
+#define PyFloat_Check(op) PyObject_TypeCheck(op, &amp;PyFloat_Type)
+#define PyFloat_CheckExact(op) ((op)-&gt;ob_type == &amp;PyFloat_Type)
+
+/* Return Python float from string PyObject.  Second argument ignored on
+   input, and, if non-NULL, NULL is stored into *junk (this tried to serve a
+   purpose once but can't be made to work as intended). */
+PyAPI_FUNC(PyObject *) PyFloat_FromString(PyObject*, char** junk);
+
+/* Return Python float from C double. */
+PyAPI_FUNC(PyObject *) PyFloat_FromDouble(double);
+
+/* Extract C double from Python float.  The macro version trades safety for
+   speed. */
+PyAPI_FUNC(double) PyFloat_AsDouble(PyObject *);
+#define PyFloat_AS_DOUBLE(op) (((PyFloatObject *)(op))-&gt;ob_fval)
+
+/* Write repr(v) into the char buffer argument, followed by null byte.  The
+   buffer must be &quot;big enough&quot;; &gt;= 100 is very safe.
+   PyFloat_AsReprString(buf, x) strives to print enough digits so that
+   PyFloat_FromString(buf) then reproduces x exactly. */
+PyAPI_FUNC(void) PyFloat_AsReprString(char*, PyFloatObject *v);
+
+/* Write str(v) into the char buffer argument, followed by null byte.  The
+   buffer must be &quot;big enough&quot;; &gt;= 100 is very safe.  Note that it's
+   unusual to be able to get back the float you started with from
+   PyFloat_AsString's result -- use PyFloat_AsReprString() if you want to
+   preserve precision across conversions. */
+PyAPI_FUNC(void) PyFloat_AsString(char*, PyFloatObject *v);
+
+/* _PyFloat_{Pack,Unpack}{4,8}
+ *
+ * The struct and pickle (at least) modules need an efficient platform-
+ * independent way to store floating-point values as byte strings.
+ * The Pack routines produce a string from a C double, and the Unpack
+ * routines produce a C double from such a string.  The suffix (4 or 8)
+ * specifies the number of bytes in the string.
+ *
+ * Excepting NaNs and infinities (which aren't handled correctly), the 4-
+ * byte format is identical to the IEEE-754 single precision format, and
+ * the 8-byte format to the IEEE-754 double precision format.  On non-
+ * IEEE platforms with more precision, or larger dynamic range, than
+ * 754 supports, not all values can be packed; on non-IEEE platforms with
+ * less precision, or smaller dynamic range, not all values can be
+ * unpacked.  What happens in such cases is partly accidental (alas).
+ */
+
+/* The pack routines write 4 or 8 bytes, starting at p.  le is a bool
+ * argument, true if you want the string in little-endian format (exponent
+ * last, at p+3 or p+7), false if you want big-endian format (exponent
+ * first, at p).
+ * Return value:  0 if all is OK, -1 if error (and an exception is
+ * set, most likely OverflowError).
+ * Bug:  What this does is undefined if x is a NaN or infinity.
+ * Bug:  -0.0 and +0.0 produce the same string.
+ */
+PyAPI_FUNC(int) _PyFloat_Pack4(double x, unsigned char *p, int le);
+PyAPI_FUNC(int) _PyFloat_Pack8(double x, unsigned char *p, int le);
+
+/* The unpack routines read 4 or 8 bytes, starting at p.  le is a bool
+ * argument, true if the string is in little-endian format (exponent
+ * last, at p+3 or p+7), false if big-endian (exponent first, at p).
+ * Return value:  The unpacked double.  On error, this is -1.0 and
+ * PyErr_Occurred() is true (and an exception is set, most likely
+ * OverflowError).
+ * Bug:  What this does is undefined if the string represents a NaN or
+ * infinity.
+ */
+PyAPI_FUNC(double) _PyFloat_Unpack4(const unsigned char *p, int le);
+PyAPI_FUNC(double) _PyFloat_Unpack8(const unsigned char *p, int le);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FLOATOBJECT_H */

Added: trunk/msvc-libs/include/frameobject.h
===================================================================
--- trunk/msvc-libs/include/frameobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/frameobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,76 @@
+
+/* Frame object interface */
+
+#ifndef Py_FRAMEOBJECT_H
+#define Py_FRAMEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    int b_type;			/* what kind of block this is */
+    int b_handler;		/* where to jump to find handler */
+    int b_level;		/* value stack level to pop to */
+} PyTryBlock;
+
+typedef struct _frame {
+    PyObject_VAR_HEAD
+    struct _frame *f_back;	/* previous frame, or NULL */
+    PyCodeObject *f_code;	/* code segment */
+    PyObject *f_builtins;	/* builtin symbol table (PyDictObject) */
+    PyObject *f_globals;	/* global symbol table (PyDictObject) */
+    PyObject *f_locals;		/* local symbol table (any mapping) */
+    PyObject **f_valuestack;	/* points after the last local */
+    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.
+       Frame evaluation usually NULLs it, but a frame that yields sets it
+       to the current stack top. */
+    PyObject **f_stacktop;
+    PyObject *f_trace;		/* Trace function */
+    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;
+    PyThreadState *f_tstate;
+    int f_lasti;		/* Last instruction if called */
+    /* As of 2.3 f_lineno is only valid when tracing is active (i.e. when
+       f_trace is set) -- at other times use PyCode_Addr2Line instead. */
+    int f_lineno;		/* Current line number */
+    int f_restricted;		/* Flag set if restricted operations
+				   in this scope */
+    int f_iblock;		/* index in f_blockstack */
+    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
+    int f_nlocals;		/* number of locals */
+    int f_ncells;
+    int f_nfreevars;
+    int f_stacksize;		/* size of value stack */
+    PyObject *f_localsplus[1];	/* locals+stack, dynamically sized */
+} PyFrameObject;
+
+
+/* Standard object interface */
+
+PyAPI_DATA(PyTypeObject) PyFrame_Type;
+
+#define PyFrame_Check(op) ((op)-&gt;ob_type == &amp;PyFrame_Type)
+
+PyAPI_FUNC(PyFrameObject *) PyFrame_New(PyThreadState *, PyCodeObject *,
+                                       PyObject *, PyObject *);
+
+
+/* The rest of the interface is specific for frame objects */
+
+/* Block management functions */
+
+PyAPI_FUNC(void) PyFrame_BlockSetup(PyFrameObject *, int, int, int);
+PyAPI_FUNC(PyTryBlock *) PyFrame_BlockPop(PyFrameObject *);
+
+/* Extend the value stack */
+
+PyAPI_FUNC(PyObject **) PyFrame_ExtendStack(PyFrameObject *, int, int);
+
+/* Conversions between &quot;fast locals&quot; and locals in dictionary */
+
+PyAPI_FUNC(void) PyFrame_LocalsToFast(PyFrameObject *, int);
+PyAPI_FUNC(void) PyFrame_FastToLocals(PyFrameObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FRAMEOBJECT_H */

Added: trunk/msvc-libs/include/funcobject.h
===================================================================
--- trunk/msvc-libs/include/funcobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/funcobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,76 @@
+
+/* Function object interface */
+
+#ifndef Py_FUNCOBJECT_H
+#define Py_FUNCOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Function objects and code objects should not be confused with each other:
+ *
+ * Function objects are created by the execution of the 'def' statement.
+ * They reference a code object in their func_code attribute, which is a
+ * purely syntactic object, i.e. nothing more than a compiled version of some
+ * source code lines.  There is one code object per source code &quot;fragment&quot;,
+ * but each code object can be referenced by zero or many function objects
+ * depending only on how many times the 'def' statement in the source was
+ * executed so far.
+ */
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *func_code;	/* A code object */
+    PyObject *func_globals;	/* A dictionary (other mappings won't do) */
+    PyObject *func_defaults;	/* NULL or a tuple */
+    PyObject *func_closure;	/* NULL or a tuple of cell objects */
+    PyObject *func_doc;		/* The __doc__ attribute, can be anything */
+    PyObject *func_name;	/* The __name__ attribute, a string object */
+    PyObject *func_dict;	/* The __dict__ attribute, a dict or NULL */
+    PyObject *func_weakreflist;	/* List of weak references */
+    PyObject *func_module;	/* The __module__ attribute, can be anything */
+
+    /* Invariant:
+     *     func_closure contains the bindings for func_code-&gt;co_freevars, so
+     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
+     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
+     */
+} PyFunctionObject;
+
+PyAPI_DATA(PyTypeObject) PyFunction_Type;
+
+#define PyFunction_Check(op) ((op)-&gt;ob_type == &amp;PyFunction_Type)
+
+PyAPI_FUNC(PyObject *) PyFunction_New(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetCode(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetGlobals(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyFunction_GET_CODE(func) \
+        (((PyFunctionObject *)func) -&gt; func_code)
+#define PyFunction_GET_GLOBALS(func) \
+	(((PyFunctionObject *)func) -&gt; func_globals)
+#define PyFunction_GET_MODULE(func) \
+	(((PyFunctionObject *)func) -&gt; func_module)
+#define PyFunction_GET_DEFAULTS(func) \
+	(((PyFunctionObject *)func) -&gt; func_defaults)
+#define PyFunction_GET_CLOSURE(func) \
+	(((PyFunctionObject *)func) -&gt; func_closure)
+
+/* The classmethod and staticmethod types lives here, too */
+PyAPI_DATA(PyTypeObject) PyClassMethod_Type;
+PyAPI_DATA(PyTypeObject) PyStaticMethod_Type;
+
+PyAPI_FUNC(PyObject *) PyClassMethod_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyStaticMethod_New(PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FUNCOBJECT_H */

Added: trunk/msvc-libs/include/genobject.h
===================================================================
--- trunk/msvc-libs/include/genobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/genobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,35 @@
+
+/* Generator object interface */
+
+#ifndef Py_GENOBJECT_H
+#define Py_GENOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct _frame; /* Avoid including frameobject.h */
+
+typedef struct {
+	PyObject_HEAD
+	/* The gi_ prefix is intended to remind of generator-iterator. */
+
+	struct _frame *gi_frame;
+
+	/* True if generator is being executed. */
+	int gi_running;
+
+	/* List of weak reference. */
+	PyObject *gi_weakreflist;
+} PyGenObject;
+
+PyAPI_DATA(PyTypeObject) PyGen_Type;
+
+#define PyGen_Check(op) PyObject_TypeCheck(op, &amp;PyGen_Type)
+#define PyGen_CheckExact(op) ((op)-&gt;ob_type == &amp;PyGen_Type)
+
+PyAPI_FUNC(PyObject *) PyGen_New(struct _frame *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_GENOBJECT_H */

Added: trunk/msvc-libs/include/graminit.h
===================================================================
--- trunk/msvc-libs/include/graminit.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/graminit.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,78 @@
+#define single_input 256
+#define file_input 257
+#define eval_input 258
+#define decorator 259
+#define decorators 260
+#define funcdef 261
+#define parameters 262
+#define varargslist 263
+#define fpdef 264
+#define fplist 265
+#define stmt 266
+#define simple_stmt 267
+#define small_stmt 268
+#define expr_stmt 269
+#define augassign 270
+#define print_stmt 271
+#define del_stmt 272
+#define pass_stmt 273
+#define flow_stmt 274
+#define break_stmt 275
+#define continue_stmt 276
+#define return_stmt 277
+#define yield_stmt 278
+#define raise_stmt 279
+#define import_stmt 280
+#define import_name 281
+#define import_from 282
+#define import_as_name 283
+#define dotted_as_name 284
+#define import_as_names 285
+#define dotted_as_names 286
+#define dotted_name 287
+#define global_stmt 288
+#define exec_stmt 289
+#define assert_stmt 290
+#define compound_stmt 291
+#define if_stmt 292
+#define while_stmt 293
+#define for_stmt 294
+#define try_stmt 295
+#define except_clause 296
+#define suite 297
+#define test 298
+#define and_test 299
+#define not_test 300
+#define comparison 301
+#define comp_op 302
+#define expr 303
+#define xor_expr 304
+#define and_expr 305
+#define shift_expr 306
+#define arith_expr 307
+#define term 308
+#define factor 309
+#define power 310
+#define atom 311
+#define listmaker 312
+#define testlist_gexp 313
+#define lambdef 314
+#define trailer 315
+#define subscriptlist 316
+#define subscript 317
+#define sliceop 318
+#define exprlist 319
+#define testlist 320
+#define testlist_safe 321
+#define dictmaker 322
+#define classdef 323
+#define arglist 324
+#define argument 325
+#define list_iter 326
+#define list_for 327
+#define list_if 328
+#define gen_iter 329
+#define gen_for 330
+#define gen_if 331
+#define testlist1 332
+#define encoding_decl 333

Added: trunk/msvc-libs/include/grammar.h
===================================================================
--- trunk/msvc-libs/include/grammar.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/grammar.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,93 @@
+
+/* Grammar interface */
+
+#ifndef Py_GRAMMAR_H
+#define Py_GRAMMAR_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;bitset.h&quot; /* Sigh... */
+
+/* A label of an arc */
+
+typedef struct {
+    int		 lb_type;
+    char	*lb_str;
+} label;
+
+#define EMPTY 0		/* Label number 0 is by definition the empty label */
+
+/* A list of labels */
+
+typedef struct {
+    int		 ll_nlabels;
+    label	*ll_label;
+} labellist;
+
+/* An arc from one state to another */
+
+typedef struct {
+    short	a_lbl;		/* Label of this arc */
+    short	a_arrow;	/* State where this arc goes to */
+} arc;
+
+/* A state in a DFA */
+
+typedef struct {
+    int		 s_narcs;
+    arc		*s_arc;		/* Array of arcs */
+	
+    /* Optional accelerators */
+    int		 s_lower;	/* Lowest label index */
+    int		 s_upper;	/* Highest label index */
+    int		*s_accel;	/* Accelerator */
+    int		 s_accept;	/* Nonzero for accepting state */
+} state;
+
+/* A DFA */
+
+typedef struct {
+    int		 d_type;	/* Non-terminal this represents */
+    char	*d_name;	/* For printing */
+    int		 d_initial;	/* Initial state */
+    int		 d_nstates;
+    state	*d_state;	/* Array of states */
+    bitset	 d_first;
+} dfa;
+
+/* A grammar */
+
+typedef struct {
+    int		 g_ndfas;
+    dfa		*g_dfa;		/* Array of DFAs */
+    labellist	 g_ll;
+    int		 g_start;	/* Start symbol of the grammar */
+    int		 g_accel;	/* Set if accelerators present */
+} grammar;
+
+/* FUNCTIONS */
+
+grammar *newgrammar(int start);
+dfa *adddfa(grammar *g, int type, char *name);
+int addstate(dfa *d);
+void addarc(dfa *d, int from, int to, int lbl);
+dfa *PyGrammar_FindDFA(grammar *g, int type);
+
+int addlabel(labellist *ll, int type, char *str);
+int findlabel(labellist *ll, int type, char *str);
+char *PyGrammar_LabelRepr(label *lb);
+void translatelabels(grammar *g);
+
+void addfirstsets(grammar *g);
+
+void PyGrammar_AddAccelerators(grammar *g);
+void PyGrammar_RemoveAccelerators(grammar *);
+
+void printgrammar(grammar *g, FILE *fp);
+void printnonterminals(grammar *g, FILE *fp);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_GRAMMAR_H */

Added: trunk/msvc-libs/include/import.h
===================================================================
--- trunk/msvc-libs/include/import.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/import.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,55 @@
+
+/* Module definition and import interface */
+
+#ifndef Py_IMPORT_H
+#define Py_IMPORT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(long) PyImport_GetMagicNumber(void);
+PyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(char *name, PyObject *co);
+PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(
+	char *name, PyObject *co, char *pathname);
+PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
+PyAPI_FUNC(PyObject *) PyImport_AddModule(char *name);
+PyAPI_FUNC(PyObject *) PyImport_ImportModule(char *name);
+PyAPI_FUNC(PyObject *) PyImport_ImportModuleEx(
+	char *name, PyObject *globals, PyObject *locals, PyObject *fromlist);
+PyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);
+PyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);
+PyAPI_FUNC(void) PyImport_Cleanup(void);
+PyAPI_FUNC(int) PyImport_ImportFrozenModule(char *);
+
+PyAPI_FUNC(struct filedescr *) _PyImport_FindModule(
+	const char *, PyObject *, char *, size_t, FILE **, PyObject **);
+PyAPI_FUNC(int) _PyImport_IsScript(struct filedescr *);
+
+PyAPI_FUNC(PyObject *)_PyImport_FindExtension(char *, char *);
+PyAPI_FUNC(PyObject *)_PyImport_FixupExtension(char *, char *);
+
+struct _inittab {
+    char *name;
+    void (*initfunc)(void);
+};
+
+PyAPI_DATA(struct _inittab *) PyImport_Inittab;
+
+PyAPI_FUNC(int) PyImport_AppendInittab(char *name, void (*initfunc)(void));
+PyAPI_FUNC(int) PyImport_ExtendInittab(struct _inittab *newtab);
+
+struct _frozen {
+    char *name;
+    unsigned char *code;
+    int size;
+};
+
+/* Embedding apps may change this pointer to point to their favorite
+   collection of frozen modules: */
+
+PyAPI_DATA(struct _frozen *) PyImport_FrozenModules;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_IMPORT_H */

Added: trunk/msvc-libs/include/intobject.h
===================================================================
--- trunk/msvc-libs/include/intobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/intobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,61 @@
+
+/* Integer object interface */
+
+/*
+PyIntObject represents a (long) integer.  This is an immutable object;
+an integer cannot change its value after creation.
+
+There are functions to create new integer objects, to test an object
+for integer-ness, and to get the integer value.  The latter functions
+returns -1 and sets errno to EBADF if the object is not an PyIntObject.
+None of the functions should be applied to nil objects.
+
+The type PyIntObject is (unfortunately) exposed here so we can declare
+_Py_TrueStruct and _Py_ZeroStruct in boolobject.h; don't use this.
+*/
+
+#ifndef Py_INTOBJECT_H
+#define Py_INTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    long ob_ival;
+} PyIntObject;
+
+PyAPI_DATA(PyTypeObject) PyInt_Type;
+
+#define PyInt_Check(op) PyObject_TypeCheck(op, &amp;PyInt_Type)
+#define PyInt_CheckExact(op) ((op)-&gt;ob_type == &amp;PyInt_Type)
+
+PyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, int, int);
+#endif
+PyAPI_FUNC(PyObject *) PyInt_FromLong(long);
+PyAPI_FUNC(long) PyInt_AsLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyInt_AsUnsignedLongMask(PyObject *);
+#ifdef HAVE_LONG_LONG
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyInt_AsUnsignedLongLongMask(PyObject *);
+#endif
+
+PyAPI_FUNC(long) PyInt_GetMax(void);
+
+/* Macro, trading safety for speed */
+#define PyInt_AS_LONG(op) (((PyIntObject *)(op))-&gt;ob_ival)
+
+/* These aren't really part of the Int object, but they're handy; the protos
+ * are necessary for systems that need the magic of PyAPI_FUNC and that want
+ * to have stropmodule as a dynamically loaded module instead of building it
+ * into the main Python shared library/DLL.  Guido thinks I'm weird for
+ * building it this way.  :-)  [cjh]
+ */
+PyAPI_FUNC(unsigned long) PyOS_strtoul(char *, char **, int);
+PyAPI_FUNC(long) PyOS_strtol(char *, char **, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_INTOBJECT_H */

Added: trunk/msvc-libs/include/intrcheck.h
===================================================================
--- trunk/msvc-libs/include/intrcheck.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/intrcheck.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,15 @@
+
+#ifndef Py_INTRCHECK_H
+#define Py_INTRCHECK_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(int) PyOS_InterruptOccurred(void);
+PyAPI_FUNC(void) PyOS_InitInterrupts(void);
+PyAPI_FUNC(void) PyOS_AfterFork(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_INTRCHECK_H */

Added: trunk/msvc-libs/include/iterobject.h
===================================================================
--- trunk/msvc-libs/include/iterobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/iterobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,23 @@
+#ifndef Py_ITEROBJECT_H
+#define Py_ITEROBJECT_H
+/* Iterators (the basic kind, over a sequence) */
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PySeqIter_Type;
+
+#define PySeqIter_Check(op) ((op)-&gt;ob_type == &amp;PySeqIter_Type)
+
+PyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);
+
+PyAPI_DATA(PyTypeObject) PyCallIter_Type;
+
+#define PyCallIter_Check(op) ((op)-&gt;ob_type == &amp;PyCallIter_Type)
+
+PyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ITEROBJECT_H */
+

Added: trunk/msvc-libs/include/listobject.h
===================================================================
--- trunk/msvc-libs/include/listobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/listobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,67 @@
+
+/* List object interface */
+
+/*
+Another generally useful object type is an list of object pointers.
+This is a mutable type: the list items can be changed, and items can be
+added or removed.  Out-of-range indices or non-list objects are ignored.
+
+*** WARNING *** PyList_SetItem does not increment the new item's reference
+count, but does decrement the reference count of the item it replaces,
+if not nil.  It does *decrement* the reference count if it is *not*
+inserted in the list.  Similarly, PyList_GetItem does not increment the
+returned item's reference count.
+*/
+
+#ifndef Py_LISTOBJECT_H
+#define Py_LISTOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    PyObject_VAR_HEAD
+    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
+    PyObject **ob_item;
+
+    /* ob_item contains space for 'allocated' elements.  The number
+     * currently in use is ob_size.
+     * Invariants:
+     *     0 &lt;= ob_size &lt;= allocated
+     *     len(list) == ob_size
+     *     ob_item == NULL implies ob_size == allocated == 0
+     * list.sort() temporarily sets allocated to -1 to detect mutations.
+     *
+     * Items must normally not be NULL, except during construction when
+     * the list is not yet visible outside the function that builds it.
+     */
+    int allocated;
+} PyListObject;
+
+PyAPI_DATA(PyTypeObject) PyList_Type;
+
+#define PyList_Check(op) PyObject_TypeCheck(op, &amp;PyList_Type)
+#define PyList_CheckExact(op) ((op)-&gt;ob_type == &amp;PyList_Type)
+
+PyAPI_FUNC(PyObject *) PyList_New(int size);
+PyAPI_FUNC(int) PyList_Size(PyObject *);
+PyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, int);
+PyAPI_FUNC(int) PyList_SetItem(PyObject *, int, PyObject *);
+PyAPI_FUNC(int) PyList_Insert(PyObject *, int, PyObject *);
+PyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, int, int);
+PyAPI_FUNC(int) PyList_SetSlice(PyObject *, int, int, PyObject *);
+PyAPI_FUNC(int) PyList_Sort(PyObject *);
+PyAPI_FUNC(int) PyList_Reverse(PyObject *);
+PyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);
+PyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);
+
+/* Macro, trading safety for speed */
+#define PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])
+#define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))
+#define PyList_GET_SIZE(op)    (((PyListObject *)(op))-&gt;ob_size)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LISTOBJECT_H */

Added: trunk/msvc-libs/include/longintrepr.h
===================================================================
--- trunk/msvc-libs/include/longintrepr.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/longintrepr.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,63 @@
+#ifndef Py_LONGINTREPR_H
+#define Py_LONGINTREPR_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* This is published for the benefit of &quot;friend&quot; marshal.c only. */
+
+/* Parameters of the long integer representation.
+   These shouldn't have to be changed as C should guarantee that a short
+   contains at least 16 bits, but it's made changeable anyway.
+   Note: 'digit' should be able to hold 2*MASK+1, and 'twodigits'
+   should be able to hold the intermediate results in 'mul'
+   (at most (BASE-1)*(2*BASE+1) == MASK*(2*MASK+3)).
+   Also, x_sub assumes that 'digit' is an unsigned type, and overflow
+   is handled by taking the result mod 2**N for some N &gt; SHIFT.
+   And, at some places it is assumed that MASK fits in an int, as well.
+   long_pow() requires that SHIFT be divisible by 5. */
+
+typedef unsigned short digit;
+typedef unsigned int wdigit; /* digit widened to parameter size */
+#define BASE_TWODIGITS_TYPE long
+typedef unsigned BASE_TWODIGITS_TYPE twodigits;
+typedef BASE_TWODIGITS_TYPE stwodigits; /* signed variant of twodigits */
+
+#define SHIFT	15
+#define BASE	((digit)1 &lt;&lt; SHIFT)
+#define MASK	((int)(BASE - 1))
+
+#if SHIFT % 5 != 0
+#error &quot;longobject.c requires that SHIFT be divisible by 5&quot;
+#endif
+
+/* Long integer representation.
+   The absolute value of a number is equal to
+   	SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
+   Negative numbers are represented with ob_size &lt; 0;
+   zero is represented by ob_size == 0.
+   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
+   digit) is never zero.  Also, in all cases, for all valid i,
+   	0 &lt;= ob_digit[i] &lt;= MASK.
+   The allocation function takes care of allocating extra memory
+   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.
+
+   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
+   aware that longs abuse  ob_size's sign bit.
+*/
+
+struct _longobject {
+	PyObject_VAR_HEAD
+	digit ob_digit[1];
+};
+
+PyAPI_FUNC(PyLongObject *) _PyLong_New(int);
+
+/* Return a copy of src. */
+PyAPI_FUNC(PyObject *) _PyLong_Copy(PyLongObject *src);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LONGINTREPR_H */

Added: trunk/msvc-libs/include/longobject.h
===================================================================
--- trunk/msvc-libs/include/longobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/longobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,108 @@
+#ifndef Py_LONGOBJECT_H
+#define Py_LONGOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Long (arbitrary precision) integer object interface */
+
+typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */
+
+PyAPI_DATA(PyTypeObject) PyLong_Type;
+
+#define PyLong_Check(op) PyObject_TypeCheck(op, &amp;PyLong_Type)
+#define PyLong_CheckExact(op) ((op)-&gt;ob_type == &amp;PyLong_Type)
+
+PyAPI_FUNC(PyObject *) PyLong_FromLong(long);
+PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);
+PyAPI_FUNC(PyObject *) PyLong_FromDouble(double);
+PyAPI_FUNC(long) PyLong_AsLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLongMask(PyObject *);
+
+/* _PyLong_AsScaledDouble returns a double x and an exponent e such that
+   the true value is approximately equal to x * 2**(SHIFT*e).  e is &gt;= 0.
+   x is 0.0 if and only if the input is 0 (in which case, e and x are both
+   zeroes).  Overflow is impossible.  Note that the exponent returned must
+   be multiplied by SHIFT!  There may not be enough room in an int to store
+   e*SHIFT directly. */
+PyAPI_FUNC(double) _PyLong_AsScaledDouble(PyObject *vv, int *e);
+
+PyAPI_FUNC(double) PyLong_AsDouble(PyObject *);
+PyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);
+PyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);
+
+#ifdef HAVE_LONG_LONG
+PyAPI_FUNC(PyObject *) PyLong_FromLongLong(PY_LONG_LONG);
+PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned PY_LONG_LONG);
+PyAPI_FUNC(PY_LONG_LONG) PyLong_AsLongLong(PyObject *);
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyLong_AsUnsignedLongLong(PyObject *);
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyLong_AsUnsignedLongLongMask(PyObject *);
+#endif /* HAVE_LONG_LONG */
+
+PyAPI_FUNC(PyObject *) PyLong_FromString(char *, char **, int);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyLong_FromUnicode(Py_UNICODE*, int, int);
+#endif
+
+/* _PyLong_Sign.  Return 0 if v is 0, -1 if v &lt; 0, +1 if v &gt; 0.
+   v must not be NULL, and must be a normalized long.
+   There are no error cases.
+*/
+PyAPI_FUNC(int) _PyLong_Sign(PyObject *v);
+
+
+/* _PyLong_NumBits.  Return the number of bits needed to represent the
+   absolute value of a long.  For example, this returns 1 for 1 and -1, 2
+   for 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.
+   v must not be NULL, and must be a normalized long.
+   (size_t)-1 is returned and OverflowError set if the true result doesn't
+   fit in a size_t.
+*/
+PyAPI_FUNC(size_t) _PyLong_NumBits(PyObject *v);
+
+/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
+   base 256, and return a Python long with the same numeric value.
+   If n is 0, the integer is 0.  Else:
+   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;
+   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the
+   LSB.
+   If is_signed is 0/false, view the bytes as a non-negative integer.
+   If is_signed is 1/true, view the bytes as a 2's-complement integer,
+   non-negative if bit 0x80 of the MSB is clear, negative if set.
+   Error returns:
+   + Return NULL with the appropriate exception set if there's not
+     enough memory to create the Python long.
+*/
+PyAPI_FUNC(PyObject *) _PyLong_FromByteArray(
+	const unsigned char* bytes, size_t n,
+	int little_endian, int is_signed);
+
+/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long
+   v to a base-256 integer, stored in array bytes.  Normally return 0,
+   return -1 on error.
+   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at
+   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and
+   the LSB at bytes[n-1].
+   If is_signed is 0/false, it's an error if v &lt; 0; else (v &gt;= 0) n bytes
+   are filled and there's nothing special about bit 0x80 of the MSB.
+   If is_signed is 1/true, bytes is filled with the 2's-complement
+   representation of v's value.  Bit 0x80 of the MSB is the sign bit.
+   Error returns (-1):
+   + is_signed is 0 and v &lt; 0.  TypeError is set in this case, and bytes
+     isn't altered.
+   + n isn't big enough to hold the full mathematical value of v.  For
+     example, if is_signed is 0 and there are more digits in the v than
+     fit in n; or if is_signed is 1, v &lt; 0, and n is just 1 bit shy of
+     being large enough to hold a sign bit.  OverflowError is set in this
+     case, but bytes holds the least-signficant n bytes of the true value.
+*/
+PyAPI_FUNC(int) _PyLong_AsByteArray(PyLongObject* v,
+	unsigned char* bytes, size_t n,
+	int little_endian, int is_signed);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LONGOBJECT_H */

Added: trunk/msvc-libs/include/marshal.h
===================================================================
--- trunk/msvc-libs/include/marshal.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/marshal.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,25 @@
+
+/* Interface for marshal.c */
+
+#ifndef Py_MARSHAL_H
+#define Py_MARSHAL_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define Py_MARSHAL_VERSION 1
+
+PyAPI_FUNC(void) PyMarshal_WriteLongToFile(long, FILE *, int);
+PyAPI_FUNC(void) PyMarshal_WriteObjectToFile(PyObject *, FILE *, int);
+PyAPI_FUNC(PyObject *) PyMarshal_WriteObjectToString(PyObject *, int);
+
+PyAPI_FUNC(long) PyMarshal_ReadLongFromFile(FILE *);
+PyAPI_FUNC(int) PyMarshal_ReadShortFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadLastObjectFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromString(char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MARSHAL_H */

Added: trunk/msvc-libs/include/metagrammar.h
===================================================================
--- trunk/msvc-libs/include/metagrammar.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/metagrammar.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,18 @@
+#ifndef Py_METAGRAMMAR_H
+#define Py_METAGRAMMAR_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+#define MSTART 256
+#define RULE 257
+#define RHS 258
+#define ALT 259
+#define ITEM 260
+#define ATOM 261
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_METAGRAMMAR_H */

Added: trunk/msvc-libs/include/methodobject.h
===================================================================
--- trunk/msvc-libs/include/methodobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/methodobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,91 @@
+
+/* Method object interface */
+
+#ifndef Py_METHODOBJECT_H
+#define Py_METHODOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This is about the type 'builtin_function_or_method',
+   not Python methods in user-defined classes.  See classobject.h
+   for the latter. */
+
+PyAPI_DATA(PyTypeObject) PyCFunction_Type;
+
+#define PyCFunction_Check(op) ((op)-&gt;ob_type == &amp;PyCFunction_Type)
+
+typedef PyObject *(*PyCFunction)(PyObject *, PyObject *);
+typedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *,
+					     PyObject *);
+typedef PyObject *(*PyNoArgsFunction)(PyObject *);
+
+PyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);
+PyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);
+PyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyCFunction_GET_FUNCTION(func) \
+        (((PyCFunctionObject *)func) -&gt; m_ml -&gt; ml_meth)
+#define PyCFunction_GET_SELF(func) \
+	(((PyCFunctionObject *)func) -&gt; m_self)
+#define PyCFunction_GET_FLAGS(func) \
+	(((PyCFunctionObject *)func) -&gt; m_ml -&gt; ml_flags)
+PyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
+
+struct PyMethodDef {
+    char	*ml_name;	/* The name of the built-in function/method */
+    PyCFunction  ml_meth;	/* The C function that implements it */
+    int		 ml_flags;	/* Combination of METH_xxx flags, which mostly
+				   describe the args expected by the C func */
+    char	*ml_doc;	/* The __doc__ attribute, or NULL */
+};
+typedef struct PyMethodDef PyMethodDef;
+
+PyAPI_FUNC(PyObject *) Py_FindMethod(PyMethodDef[], PyObject *, char *);
+
+#define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
+PyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *, 
+					 PyObject *);
+
+/* Flag passed to newmethodobject */
+#define METH_OLDARGS  0x0000
+#define METH_VARARGS  0x0001
+#define METH_KEYWORDS 0x0002
+/* METH_NOARGS and METH_O must not be combined with the flags above. */
+#define METH_NOARGS   0x0004
+#define METH_O        0x0008
+
+/* METH_CLASS and METH_STATIC are a little different; these control
+   the construction of methods for a class.  These cannot be used for
+   functions in modules. */
+#define METH_CLASS    0x0010
+#define METH_STATIC   0x0020
+
+/* METH_COEXIST allows a method to be entered eventhough a slot has
+   already filled the entry.  When defined, the flag allows a separate
+   method, &quot;__contains__&quot; for example, to coexist with a defined 
+   slot like sq_contains. */
+
+#define METH_COEXIST   0x0040
+
+typedef struct PyMethodChain {
+    PyMethodDef *methods;		/* Methods of this type */
+    struct PyMethodChain *link;	/* NULL or base type */
+} PyMethodChain;
+
+PyAPI_FUNC(PyObject *) Py_FindMethodInChain(PyMethodChain *, PyObject *,
+                                                  char *);
+
+typedef struct {
+    PyObject_HEAD
+    PyMethodDef *m_ml; /* Description of the C function to call */
+    PyObject    *m_self; /* Passed as 'self' arg to the C func, can be NULL */
+    PyObject    *m_module; /* The __module__ attribute, can be anything */
+} PyCFunctionObject;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_METHODOBJECT_H */

Added: trunk/msvc-libs/include/modsupport.h
===================================================================
--- trunk/msvc-libs/include/modsupport.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/modsupport.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,103 @@
+
+#ifndef Py_MODSUPPORT_H
+#define Py_MODSUPPORT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* Module support interface */
+
+#include &lt;stdarg.h&gt;
+
+PyAPI_FUNC(int) PyArg_Parse(PyObject *, char *, ...);
+PyAPI_FUNC(int) PyArg_ParseTuple(PyObject *, char *, ...);
+PyAPI_FUNC(int) PyArg_ParseTupleAndKeywords(PyObject *, PyObject *,
+                                                  char *, char **, ...);
+PyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, char *, int, int, ...);
+PyAPI_FUNC(PyObject *) Py_BuildValue(char *, ...);
+
+PyAPI_FUNC(int) PyArg_VaParse(PyObject *, char *, va_list);
+PyAPI_FUNC(int) PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *,
+                                                  char *, char **, va_list);
+PyAPI_FUNC(PyObject *) Py_VaBuildValue(char *, va_list);
+
+PyAPI_FUNC(int) PyModule_AddObject(PyObject *, char *, PyObject *);
+PyAPI_FUNC(int) PyModule_AddIntConstant(PyObject *, char *, long);
+PyAPI_FUNC(int) PyModule_AddStringConstant(PyObject *, char *, char *);
+
+#define PYTHON_API_VERSION 1012
+#define PYTHON_API_STRING &quot;1012&quot;
+/* The API version is maintained (independently from the Python version)
+   so we can detect mismatches between the interpreter and dynamically
+   loaded modules.  These are diagnosed by an error message but
+   the module is still loaded (because the mismatch can only be tested
+   after loading the module).  The error message is intended to
+   explain the core dump a few seconds later.
+
+   The symbol PYTHON_API_STRING defines the same value as a string
+   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***
+
+   Please add a line or two to the top of this log for each API
+   version change:
+
+   19-Aug-2002  GvR	1012	Changes to string object struct for
+   				interning changes, saving 3 bytes.
+
+   17-Jul-2001	GvR	1011	Descr-branch, just to be on the safe side
+
+   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
+                                PyFrame_New(); Python 2.1a2
+
+   14-Mar-2000  GvR     1009    Unicode API added
+
+   3-Jan-1999	GvR	1007	Decided to change back!  (Don't reuse 1008!)
+
+   3-Dec-1998	GvR	1008	Python 1.5.2b1
+
+   18-Jan-1997	GvR	1007	string interning and other speedups
+
+   11-Oct-1996	GvR	renamed Py_Ellipses to Py_Ellipsis :-(
+
+   30-Jul-1996	GvR	Slice and ellipses syntax added
+
+   23-Jul-1996	GvR	For 1.4 -- better safe than sorry this time :-)
+
+   7-Nov-1995	GvR	Keyword arguments (should've been done at 1.3 :-( )
+
+   10-Jan-1995	GvR	Renamed globals to new naming scheme
+
+   9-Jan-1995	GvR	Initial version (incompatible with older API)
+*/
+
+#ifdef MS_WINDOWS
+/* Special defines for Windows versions used to live here.  Things
+   have changed, and the &quot;Version&quot; is now in a global string variable.
+   Reason for this is that this for easier branding of a &quot;custom DLL&quot;
+   without actually needing a recompile.  */
+#endif /* MS_WINDOWS */
+
+#ifdef Py_TRACE_REFS
+/* When we are tracing reference counts, rename Py_InitModule4 so
+   modules compiled with incompatible settings will generate a
+   link-time error. */
+#define Py_InitModule4 Py_InitModule4TraceRefs
+#endif
+
+PyAPI_FUNC(PyObject *) Py_InitModule4(char *name, PyMethodDef *methods,
+                                            char *doc, PyObject *self,
+                                            int apiver);
+
+#define Py_InitModule(name, methods) \
+	Py_InitModule4(name, methods, (char *)NULL, (PyObject *)NULL, \
+		       PYTHON_API_VERSION)
+
+#define Py_InitModule3(name, methods, doc) \
+	Py_InitModule4(name, methods, doc, (PyObject *)NULL, \
+		       PYTHON_API_VERSION)
+
+PyAPI_DATA(char *) _Py_PackageContext;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MODSUPPORT_H */

Added: trunk/msvc-libs/include/moduleobject.h
===================================================================
--- trunk/msvc-libs/include/moduleobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/moduleobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,24 @@
+
+/* Module object interface */
+
+#ifndef Py_MODULEOBJECT_H
+#define Py_MODULEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyModule_Type;
+
+#define PyModule_Check(op) PyObject_TypeCheck(op, &amp;PyModule_Type)
+#define PyModule_CheckExact(op) ((op)-&gt;ob_type == &amp;PyModule_Type)
+
+PyAPI_FUNC(PyObject *) PyModule_New(char *);
+PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
+PyAPI_FUNC(char *) PyModule_GetName(PyObject *);
+PyAPI_FUNC(char *) PyModule_GetFilename(PyObject *);
+PyAPI_FUNC(void) _PyModule_Clear(PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MODULEOBJECT_H */

Added: trunk/msvc-libs/include/node.h
===================================================================
--- trunk/msvc-libs/include/node.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/node.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,39 @@
+
+/* Parse tree node interface */
+
+#ifndef Py_NODE_H
+#define Py_NODE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct _node {
+    short		n_type;
+    char		*n_str;
+    int			n_lineno;
+    int			n_nchildren;
+    struct _node	*n_child;
+} node;
+
+PyAPI_FUNC(node *) PyNode_New(int type);
+PyAPI_FUNC(int) PyNode_AddChild(node *n, int type,
+                                      char *str, int lineno);
+PyAPI_FUNC(void) PyNode_Free(node *n);
+
+/* Node access functions */
+#define NCH(n)		((n)-&gt;n_nchildren)
+	
+#define CHILD(n, i)	(&amp;(n)-&gt;n_child[i])
+#define RCHILD(n, i)	(CHILD(n, NCH(n) + i))
+#define TYPE(n)		((n)-&gt;n_type)
+#define STR(n)		((n)-&gt;n_str)
+
+/* Assert that the type of a node is what we expect */
+#define REQ(n, type) assert(TYPE(n) == (type))
+
+PyAPI_FUNC(void) PyNode_ListTree(node *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_NODE_H */

Added: trunk/msvc-libs/include/object.h
===================================================================
--- trunk/msvc-libs/include/object.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/object.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,807 @@
+#ifndef Py_OBJECT_H
+#define Py_OBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Object and type object interface */
+
+/*
+Objects are structures allocated on the heap.  Special rules apply to
+the use of objects to ensure they are properly garbage-collected.
+Objects are never allocated statically or on the stack; they must be
+accessed through special macros and functions only.  (Type objects are
+exceptions to the first rule; the standard types are represented by
+statically initialized type objects, although work on type/class unification
+for Python 2.2 made it possible to have heap-allocated type objects too).
+
+An object has a 'reference count' that is increased or decreased when a
+pointer to the object is copied or deleted; when the reference count
+reaches zero there are no references to the object left and it can be
+removed from the heap.
+
+An object has a 'type' that determines what it represents and what kind
+of data it contains.  An object's type is fixed when it is created.
+Types themselves are represented as objects; an object contains a
+pointer to the corresponding type object.  The type itself has a type
+pointer pointing to the object representing the type 'type', which
+contains a pointer to itself!).
+
+Objects do not float around in memory; once allocated an object keeps
+the same size and address.  Objects that must hold variable-size data
+can contain pointers to variable-size parts of the object.  Not all
+objects of the same type have the same size; but the size cannot change
+after allocation.  (These restrictions are made so a reference to an
+object can be simply a pointer -- moving an object would require
+updating all the pointers, and changing an object's size would require
+moving it if there was another object right next to it.)
+
+Objects are always accessed through pointers of the type 'PyObject *'.
+The type 'PyObject' is a structure that only contains the reference count
+and the type pointer.  The actual memory allocated for an object
+contains other data that can only be accessed after casting the pointer
+to a pointer to a longer structure type.  This longer type must start
+with the reference count and type fields; the macro PyObject_HEAD should be
+used for this (to accommodate for future changes).  The implementation
+of a particular object type can cast the object pointer to the proper
+type and back.
+
+A standard interface exists for objects that contain an array of items
+whose size is determined when the object is allocated.
+*/
+
+/* Py_DEBUG implies Py_TRACE_REFS. */
+#if defined(Py_DEBUG) &amp;&amp; !defined(Py_TRACE_REFS)
+#define Py_TRACE_REFS
+#endif
+
+/* Py_TRACE_REFS implies Py_REF_DEBUG. */
+#if defined(Py_TRACE_REFS) &amp;&amp; !defined(Py_REF_DEBUG)
+#define Py_REF_DEBUG
+#endif
+
+#ifdef Py_TRACE_REFS
+/* Define pointers to support a doubly-linked list of all live heap objects. */
+#define _PyObject_HEAD_EXTRA		\
+	struct _object *_ob_next;	\
+	struct _object *_ob_prev;
+
+#define _PyObject_EXTRA_INIT 0, 0,
+
+#else
+#define _PyObject_HEAD_EXTRA
+#define _PyObject_EXTRA_INIT
+#endif
+
+/* PyObject_HEAD defines the initial segment of every PyObject. */
+#define PyObject_HEAD			\
+	_PyObject_HEAD_EXTRA		\
+	int ob_refcnt;			\
+	struct _typeobject *ob_type;
+
+#define PyObject_HEAD_INIT(type)	\
+	_PyObject_EXTRA_INIT		\
+	1, type,
+
+/* PyObject_VAR_HEAD defines the initial segment of all variable-size
+ * container objects.  These end with a declaration of an array with 1
+ * element, but enough space is malloc'ed so that the array actually
+ * has room for ob_size elements.  Note that ob_size is an element count,
+ * not necessarily a byte count.
+ */
+#define PyObject_VAR_HEAD		\
+	PyObject_HEAD			\
+	int ob_size; /* Number of items in variable part */
+
+/* Nothing is actually declared to be a PyObject, but every pointer to
+ * a Python object can be cast to a PyObject*.  This is inheritance built
+ * by hand.  Similarly every pointer to a variable-size Python object can,
+ * in addition, be cast to PyVarObject*.
+ */
+typedef struct _object {
+	PyObject_HEAD
+} PyObject;
+
+typedef struct {
+	PyObject_VAR_HEAD
+} PyVarObject;
+
+
+/*
+Type objects contain a string containing the type name (to help somewhat
+in debugging), the allocation parameters (see PyObject_New() and
+PyObject_NewVar()),
+and methods for accessing objects of the type.  Methods are optional, a
+nil pointer meaning that particular kind of access is not available for
+this type.  The Py_DECREF() macro uses the tp_dealloc method without
+checking for a nil pointer; it should always be implemented except if
+the implementation can guarantee that the reference count will never
+reach zero (e.g., for statically allocated type objects).
+
+NB: the methods for certain type groups are now contained in separate
+method blocks.
+*/
+
+typedef PyObject * (*unaryfunc)(PyObject *);
+typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
+typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
+typedef int (*inquiry)(PyObject *);
+typedef int (*coercion)(PyObject **, PyObject **);
+typedef PyObject *(*intargfunc)(PyObject *, int);
+typedef PyObject *(*intintargfunc)(PyObject *, int, int);
+typedef int(*intobjargproc)(PyObject *, int, PyObject *);
+typedef int(*intintobjargproc)(PyObject *, int, int, PyObject *);
+typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);
+typedef int (*getreadbufferproc)(PyObject *, int, void **);
+typedef int (*getwritebufferproc)(PyObject *, int, void **);
+typedef int (*getsegcountproc)(PyObject *, int *);
+typedef int (*getcharbufferproc)(PyObject *, int, const char **);
+typedef int (*objobjproc)(PyObject *, PyObject *);
+typedef int (*visitproc)(PyObject *, void *);
+typedef int (*traverseproc)(PyObject *, visitproc, void *);
+
+typedef struct {
+	/* For numbers without flag bit Py_TPFLAGS_CHECKTYPES set, all
+	   arguments are guaranteed to be of the object's type (modulo
+	   coercion hacks -- i.e. if the type's coercion function
+	   returns other types, then these are allowed as well).  Numbers that
+	   have the Py_TPFLAGS_CHECKTYPES flag bit set should check *both*
+	   arguments for proper type and implement the necessary conversions
+	   in the slot functions themselves. */
+
+	binaryfunc nb_add;
+	binaryfunc nb_subtract;
+	binaryfunc nb_multiply;
+	binaryfunc nb_divide;
+	binaryfunc nb_remainder;
+	binaryfunc nb_divmod;
+	ternaryfunc nb_power;
+	unaryfunc nb_negative;
+	unaryfunc nb_positive;
+	unaryfunc nb_absolute;
+	inquiry nb_nonzero;
+	unaryfunc nb_invert;
+	binaryfunc nb_lshift;
+	binaryfunc nb_rshift;
+	binaryfunc nb_and;
+	binaryfunc nb_xor;
+	binaryfunc nb_or;
+	coercion nb_coerce;
+	unaryfunc nb_int;
+	unaryfunc nb_long;
+	unaryfunc nb_float;
+	unaryfunc nb_oct;
+	unaryfunc nb_hex;
+	/* Added in release 2.0 */
+	binaryfunc nb_inplace_add;
+	binaryfunc nb_inplace_subtract;
+	binaryfunc nb_inplace_multiply;
+	binaryfunc nb_inplace_divide;
+	binaryfunc nb_inplace_remainder;
+	ternaryfunc nb_inplace_power;
+	binaryfunc nb_inplace_lshift;
+	binaryfunc nb_inplace_rshift;
+	binaryfunc nb_inplace_and;
+	binaryfunc nb_inplace_xor;
+	binaryfunc nb_inplace_or;
+
+	/* Added in release 2.2 */
+	/* The following require the Py_TPFLAGS_HAVE_CLASS flag */
+	binaryfunc nb_floor_divide;
+	binaryfunc nb_true_divide;
+	binaryfunc nb_inplace_floor_divide;
+	binaryfunc nb_inplace_true_divide;
+} PyNumberMethods;
+
+typedef struct {
+	inquiry sq_length;
+	binaryfunc sq_concat;
+	intargfunc sq_repeat;
+	intargfunc sq_item;
+	intintargfunc sq_slice;
+	intobjargproc sq_ass_item;
+	intintobjargproc sq_ass_slice;
+	objobjproc sq_contains;
+	/* Added in release 2.0 */
+	binaryfunc sq_inplace_concat;
+	intargfunc sq_inplace_repeat;
+} PySequenceMethods;
+
+typedef struct {
+	inquiry mp_length;
+	binaryfunc mp_subscript;
+	objobjargproc mp_ass_subscript;
+} PyMappingMethods;
+
+typedef struct {
+	getreadbufferproc bf_getreadbuffer;
+	getwritebufferproc bf_getwritebuffer;
+	getsegcountproc bf_getsegcount;
+	getcharbufferproc bf_getcharbuffer;
+} PyBufferProcs;
+
+
+typedef void (*freefunc)(void *);
+typedef void (*destructor)(PyObject *);
+typedef int (*printfunc)(PyObject *, FILE *, int);
+typedef PyObject *(*getattrfunc)(PyObject *, char *);
+typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
+typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
+typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
+typedef int (*cmpfunc)(PyObject *, PyObject *);
+typedef PyObject *(*reprfunc)(PyObject *);
+typedef long (*hashfunc)(PyObject *);
+typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
+typedef PyObject *(*getiterfunc) (PyObject *);
+typedef PyObject *(*iternextfunc) (PyObject *);
+typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
+typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
+typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
+typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
+typedef PyObject *(*allocfunc)(struct _typeobject *, int);
+
+typedef struct _typeobject {
+	PyObject_VAR_HEAD
+	char *tp_name; /* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */
+	int tp_basicsize, tp_itemsize; /* For allocation */
+
+	/* Methods to implement standard operations */
+
+	destructor tp_dealloc;
+	printfunc tp_print;
+	getattrfunc tp_getattr;
+	setattrfunc tp_setattr;
+	cmpfunc tp_compare;
+	reprfunc tp_repr;
+
+	/* Method suites for standard classes */
+
+	PyNumberMethods *tp_as_number;
+	PySequenceMethods *tp_as_sequence;
+	PyMappingMethods *tp_as_mapping;
+
+	/* More standard operations (here for binary compatibility) */
+
+	hashfunc tp_hash;
+	ternaryfunc tp_call;
+	reprfunc tp_str;
+	getattrofunc tp_getattro;
+	setattrofunc tp_setattro;
+
+	/* Functions to access object as input/output buffer */
+	PyBufferProcs *tp_as_buffer;
+
+	/* Flags to define presence of optional/expanded features */
+	long tp_flags;
+
+	char *tp_doc; /* Documentation string */
+
+	/* Assigned meaning in release 2.0 */
+	/* call function for all accessible objects */
+	traverseproc tp_traverse;
+
+	/* delete references to contained objects */
+	inquiry tp_clear;
+
+	/* Assigned meaning in release 2.1 */
+	/* rich comparisons */
+	richcmpfunc tp_richcompare;
+
+	/* weak reference enabler */
+	long tp_weaklistoffset;
+
+	/* Added in release 2.2 */
+	/* Iterators */
+	getiterfunc tp_iter;
+	iternextfunc tp_iternext;
+
+	/* Attribute descriptor and subclassing stuff */
+	struct PyMethodDef *tp_methods;
+	struct PyMemberDef *tp_members;
+	struct PyGetSetDef *tp_getset;
+	struct _typeobject *tp_base;
+	PyObject *tp_dict;
+	descrgetfunc tp_descr_get;
+	descrsetfunc tp_descr_set;
+	long tp_dictoffset;
+	initproc tp_init;
+	allocfunc tp_alloc;
+	newfunc tp_new;
+	freefunc tp_free; /* Low-level free-memory routine */
+	inquiry tp_is_gc; /* For PyObject_IS_GC */
+	PyObject *tp_bases;
+	PyObject *tp_mro; /* method resolution order */
+	PyObject *tp_cache;
+	PyObject *tp_subclasses;
+	PyObject *tp_weaklist;
+	destructor tp_del;
+
+#ifdef COUNT_ALLOCS
+	/* these must be last and never explicitly initialized */
+	int tp_allocs;
+	int tp_frees;
+	int tp_maxalloc;
+	struct _typeobject *tp_next;
+#endif
+} PyTypeObject;
+
+
+/* The *real* layout of a type object when allocated on the heap */
+typedef struct _heaptypeobject {
+	/* Note: there's a dependency on the order of these members
+	   in slotptr() in typeobject.c . */
+	PyTypeObject type;
+	PyNumberMethods as_number;
+	PyMappingMethods as_mapping;
+	PySequenceMethods as_sequence; /* as_sequence comes after as_mapping,
+					  so that the mapping wins when both
+					  the mapping and the sequence define
+					  a given operator (e.g. __getitem__).
+					  see add_operators() in typeobject.c . */
+	PyBufferProcs as_buffer;
+	PyObject *name, *slots;
+	/* here are optional user slots, followed by the members. */
+} PyHeapTypeObject;
+
+/* access macro to the members which are floating &quot;behind&quot; the object */
+#define PyHeapType_GET_MEMBERS(etype) \
+    ((PyMemberDef *)(((char *)etype) + (etype)-&gt;type.ob_type-&gt;tp_basicsize))
+
+
+/* Generic type check */
+PyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);
+#define PyObject_TypeCheck(ob, tp) \
+	((ob)-&gt;ob_type == (tp) || PyType_IsSubtype((ob)-&gt;ob_type, (tp)))
+
+PyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */
+PyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */
+PyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */
+
+#define PyType_Check(op) PyObject_TypeCheck(op, &amp;PyType_Type)
+#define PyType_CheckExact(op) ((op)-&gt;ob_type == &amp;PyType_Type)
+
+PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
+PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, int);
+PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
+					       PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyType_Lookup(PyTypeObject *, PyObject *);
+
+/* Generic operations on objects */
+PyAPI_FUNC(int) PyObject_Print(PyObject *, FILE *, int);
+PyAPI_FUNC(void) _PyObject_Dump(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyObject_Unicode(PyObject *);
+#endif
+PyAPI_FUNC(int) PyObject_Compare(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
+PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
+PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, char *);
+PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, char *, PyObject *);
+PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, char *);
+PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject **) _PyObject_GetDictPtr(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
+					      PyObject *, PyObject *);
+PyAPI_FUNC(long) PyObject_Hash(PyObject *);
+PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
+PyAPI_FUNC(int) PyObject_Not(PyObject *);
+PyAPI_FUNC(int) PyCallable_Check(PyObject *);
+PyAPI_FUNC(int) PyNumber_Coerce(PyObject **, PyObject **);
+PyAPI_FUNC(int) PyNumber_CoerceEx(PyObject **, PyObject **);
+
+PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
+
+/* A slot function whose address we need to compare */
+extern int _PyObject_SlotCompare(PyObject *, PyObject *);
+
+
+/* PyObject_Dir(obj) acts like Python __builtin__.dir(obj), returning a
+   list of strings.  PyObject_Dir(NULL) is like __builtin__.dir(),
+   returning the names of the current locals.  In this case, if there are
+   no current locals, NULL is returned, and PyErr_Occurred() is false.
+*/
+PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
+
+
+/* Helpers for printing recursive container types */
+PyAPI_FUNC(int) Py_ReprEnter(PyObject *);
+PyAPI_FUNC(void) Py_ReprLeave(PyObject *);
+
+/* Helpers for hash functions */
+PyAPI_FUNC(long) _Py_HashDouble(double);
+PyAPI_FUNC(long) _Py_HashPointer(void*);
+
+/* Helper for passing objects to printf and the like */
+#define PyObject_REPR(obj) PyString_AS_STRING(PyObject_Repr(obj))
+
+/* Flag bits for printing: */
+#define Py_PRINT_RAW	1	/* No string quotes etc. */
+
+/*
+`Type flags (tp_flags)
+
+These flags are used to extend the type structure in a backwards-compatible
+fashion. Extensions can use the flags to indicate (and test) when a given
+type structure contains a new feature. The Python core will use these when
+introducing new functionality between major revisions (to avoid mid-version
+changes in the PYTHON_API_VERSION).
+
+Arbitration of the flag bit positions will need to be coordinated among
+all extension writers who publically release their extensions (this will
+be fewer than you might expect!)..
+
+Python 1.5.2 introduced the bf_getcharbuffer slot into PyBufferProcs.
+
+Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.
+
+Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
+given type object has a specified feature.
+*/
+
+/* PyBufferProcs contains bf_getcharbuffer */
+#define Py_TPFLAGS_HAVE_GETCHARBUFFER  (1L&lt;&lt;0)
+
+/* PySequenceMethods contains sq_contains */
+#define Py_TPFLAGS_HAVE_SEQUENCE_IN (1L&lt;&lt;1)
+
+/* This is here for backwards compatibility.  Extensions that use the old GC
+ * API will still compile but the objects will not be tracked by the GC. */
+#define Py_TPFLAGS_GC 0 /* used to be (1L&lt;&lt;2) */
+
+/* PySequenceMethods and PyNumberMethods contain in-place operators */
+#define Py_TPFLAGS_HAVE_INPLACEOPS (1L&lt;&lt;3)
+
+/* PyNumberMethods do their own coercion */
+#define Py_TPFLAGS_CHECKTYPES (1L&lt;&lt;4)
+
+/* tp_richcompare is defined */
+#define Py_TPFLAGS_HAVE_RICHCOMPARE (1L&lt;&lt;5)
+
+/* Objects which are weakly referencable if their tp_weaklistoffset is &gt;0 */
+#define Py_TPFLAGS_HAVE_WEAKREFS (1L&lt;&lt;6)
+
+/* tp_iter is defined */
+#define Py_TPFLAGS_HAVE_ITER (1L&lt;&lt;7)
+
+/* New members introduced by Python 2.2 exist */
+#define Py_TPFLAGS_HAVE_CLASS (1L&lt;&lt;8)
+
+/* Set if the type object is dynamically allocated */
+#define Py_TPFLAGS_HEAPTYPE (1L&lt;&lt;9)
+
+/* Set if the type allows subclassing */
+#define Py_TPFLAGS_BASETYPE (1L&lt;&lt;10)
+
+/* Set if the type is 'ready' -- fully initialized */
+#define Py_TPFLAGS_READY (1L&lt;&lt;12)
+
+/* Set while the type is being 'readied', to prevent recursive ready calls */
+#define Py_TPFLAGS_READYING (1L&lt;&lt;13)
+
+/* Objects support garbage collection (see objimp.h) */
+#define Py_TPFLAGS_HAVE_GC (1L&lt;&lt;14)
+
+/* These two bits are preserved for Stackless Python, next after this is 16 */
+#ifdef STACKLESS
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3L&lt;&lt;15)
+#else
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
+#endif
+
+#define Py_TPFLAGS_DEFAULT  ( \
+                             Py_TPFLAGS_HAVE_GETCHARBUFFER | \
+                             Py_TPFLAGS_HAVE_SEQUENCE_IN | \
+                             Py_TPFLAGS_HAVE_INPLACEOPS | \
+                             Py_TPFLAGS_HAVE_RICHCOMPARE | \
+                             Py_TPFLAGS_HAVE_WEAKREFS | \
+                             Py_TPFLAGS_HAVE_ITER | \
+                             Py_TPFLAGS_HAVE_CLASS | \
+                             Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
+                            0)
+
+#define PyType_HasFeature(t,f)  (((t)-&gt;tp_flags &amp; (f)) != 0)
+
+
+/*
+The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
+reference counts.  Py_DECREF calls the object's deallocator function when
+the refcount falls to 0; for
+objects that don't contain references to other objects or heap memory
+this can be the standard function free().  Both macros can be used
+wherever a void expression is allowed.  The argument must not be a
+NIL pointer.  If it may be NIL, use Py_XINCREF/Py_XDECREF instead.
+The macro _Py_NewReference(op) initialize reference counts to 1, and
+in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
+bookkeeping appropriate to the special build.
+
+We assume that the reference count field can never overflow; this can
+be proven when the size of the field is the same as the pointer size, so
+we ignore the possibility.  Provided a C int is at least 32 bits (which
+is implicitly assumed in many parts of this code), that's enough for
+about 2**31 references to an object.
+
+XXX The following became out of date in Python 2.2, but I'm not sure
+XXX what the full truth is now.  Certainly, heap-allocated type objects
+XXX can and should be deallocated.
+Type objects should never be deallocated; the type pointer in an object
+is not considered to be a reference to the type object, to save
+complications in the deallocation function.  (This is actually a
+decision that's up to the implementer of each new type so if you want,
+you can count such references to the type object.)
+
+*** WARNING*** The Py_DECREF macro must have a side-effect-free argument
+since it may evaluate its argument multiple times.  (The alternative
+would be to mace it a proper function or assign it to a global temporary
+variable first, both of which are slower; and in a multi-threaded
+environment the global variable trick is not safe.)
+*/
+
+/* First define a pile of simple helper macros, one set per special
+ * build symbol.  These either expand to the obvious things, or to
+ * nothing at all when the special mode isn't in effect.  The main
+ * macros can later be defined just once then, yet expand to different
+ * things depending on which special build options are and aren't in effect.
+ * Trust me &lt;wink&gt;:  while painful, this is 20x easier to understand than,
+ * e.g, defining _Py_NewReference five different times in a maze of nested
+ * #ifdefs (we used to do that -- it was impenetrable).
+ */
+#ifdef Py_REF_DEBUG
+PyAPI_DATA(long) _Py_RefTotal;
+PyAPI_FUNC(void) _Py_NegativeRefcount(const char *fname,
+					    int lineno, PyObject *op);
+#define _Py_INC_REFTOTAL	_Py_RefTotal++
+#define _Py_DEC_REFTOTAL	_Py_RefTotal--
+#define _Py_REF_DEBUG_COMMA	,
+#define _Py_CHECK_REFCNT(OP)					\
+{	if ((OP)-&gt;ob_refcnt &lt; 0)				\
+		_Py_NegativeRefcount(__FILE__, __LINE__,	\
+				     (PyObject *)(OP));		\
+}
+#else
+#define _Py_INC_REFTOTAL
+#define _Py_DEC_REFTOTAL
+#define _Py_REF_DEBUG_COMMA
+#define _Py_CHECK_REFCNT(OP)	/* a semicolon */;
+#endif /* Py_REF_DEBUG */
+
+#ifdef COUNT_ALLOCS
+PyAPI_FUNC(void) inc_count(PyTypeObject *);
+#define _Py_INC_TPALLOCS(OP)	inc_count((OP)-&gt;ob_type)
+#define _Py_INC_TPFREES(OP)	(OP)-&gt;ob_type-&gt;tp_frees++
+#define _Py_DEC_TPFREES(OP)	(OP)-&gt;ob_type-&gt;tp_frees--
+#define _Py_COUNT_ALLOCS_COMMA	,
+#else
+#define _Py_INC_TPALLOCS(OP)
+#define _Py_INC_TPFREES(OP)
+#define _Py_DEC_TPFREES(OP)
+#define _Py_COUNT_ALLOCS_COMMA
+#endif /* COUNT_ALLOCS */
+
+#ifdef Py_TRACE_REFS
+/* Py_TRACE_REFS is such major surgery that we call external routines. */
+PyAPI_FUNC(void) _Py_NewReference(PyObject *);
+PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
+PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
+PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
+PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
+PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
+
+#else
+/* Without Py_TRACE_REFS, there's little enough to do that we expand code
+ * inline.
+ */
+#define _Py_NewReference(op) (				\
+	_Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA	\
+	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA		\
+	(op)-&gt;ob_refcnt = 1)
+
+#define _Py_ForgetReference(op) _Py_INC_TPFREES(op)
+
+#define _Py_Dealloc(op) (				\
+	_Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA	\
+	(*(op)-&gt;ob_type-&gt;tp_dealloc)((PyObject *)(op)))
+#endif /* !Py_TRACE_REFS */
+
+#define Py_INCREF(op) (				\
+	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
+	(op)-&gt;ob_refcnt++)
+
+#define Py_DECREF(op)					\
+	if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
+	    --(op)-&gt;ob_refcnt != 0)			\
+		_Py_CHECK_REFCNT(op)			\
+	else						\
+		_Py_Dealloc((PyObject *)(op))
+
+#define Py_CLEAR(op)				\
+        do {                            	\
+                if (op) {			\
+                        PyObject *tmp = (PyObject *)(op);	\
+                        (op) = NULL;		\
+                        Py_DECREF(tmp);		\
+                }				\
+        } while (0)
+
+/* Macros to use in case the object pointer may be NULL: */
+#define Py_XINCREF(op) if ((op) == NULL) ; else Py_INCREF(op)
+#define Py_XDECREF(op) if ((op) == NULL) ; else Py_DECREF(op)
+
+/*
+These are provided as conveniences to Python runtime embedders, so that
+they can have object code that is not dependent on Python compilation flags.
+*/
+PyAPI_FUNC(void) Py_IncRef(PyObject *);
+PyAPI_FUNC(void) Py_DecRef(PyObject *);
+
+/*
+_Py_NoneStruct is an object of undefined type which can be used in contexts
+where NULL (nil) is not suitable (since NULL often means 'error').
+
+Don't forget to apply Py_INCREF() when returning this value!!!
+*/
+PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */
+#define Py_None (&amp;_Py_NoneStruct)
+
+/* Macro for returning Py_None from a function */
+#define Py_RETURN_NONE return Py_INCREF(Py_None), Py_None
+
+/*
+Py_NotImplemented is a singleton used to signal that an operation is
+not implemented for a given type combination.
+*/
+PyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */
+#define Py_NotImplemented (&amp;_Py_NotImplementedStruct)
+
+/* Rich comparison opcodes */
+#define Py_LT 0
+#define Py_LE 1
+#define Py_EQ 2
+#define Py_NE 3
+#define Py_GT 4
+#define Py_GE 5
+
+/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.
+ * Defined in object.c.
+ */
+PyAPI_DATA(int) _Py_SwappedOp[];
+
+/*
+Define staticforward and statichere for source compatibility with old
+C extensions.
+
+The staticforward define was needed to support certain broken C
+compilers (notably SCO ODT 3.0, perhaps early AIX as well) botched the
+static keyword when it was used with a forward declaration of a static
+initialized structure.  Standard C allows the forward declaration with
+static, and we've decided to stop catering to broken C compilers.
+(In fact, we expect that the compilers are all fixed eight years later.)
+*/
+
+#define staticforward static
+#define statichere static
+
+
+/*
+More conventions
+================
+
+Argument Checking
+-----------------
+
+Functions that take objects as arguments normally don't check for nil
+arguments, but they do check the type of the argument, and return an
+error if the function doesn't apply to the type.
+
+Failure Modes
+-------------
+
+Functions may fail for a variety of reasons, including running out of
+memory.  This is communicated to the caller in two ways: an error string
+is set (see errors.h), and the function result differs: functions that
+normally return a pointer return NULL for failure, functions returning
+an integer return -1 (which could be a legal return value too!), and
+other functions return 0 for success and -1 for failure.
+Callers should always check for errors before using the result.  If
+an error was set, the caller must either explicitly clear it, or pass
+the error on to its caller.
+
+Reference Counts
+----------------
+
+It takes a while to get used to the proper usage of reference counts.
+
+Functions that create an object set the reference count to 1; such new
+objects must be stored somewhere or destroyed again with Py_DECREF().
+Some functions that 'store' objects, such as PyTuple_SetItem() and
+PyList_SetItem(),
+don't increment the reference count of the object, since the most
+frequent use is to store a fresh object.  Functions that 'retrieve'
+objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
+don't increment
+the reference count, since most frequently the object is only looked at
+quickly.  Thus, to retrieve an object and store it again, the caller
+must call Py_INCREF() explicitly.
+
+NOTE: functions that 'consume' a reference count, like
+PyList_SetItem(), consume the reference even if the object wasn't
+successfully stored, to simplify error handling.
+
+It seems attractive to make other functions that take an object as
+argument consume a reference count; however, this may quickly get
+confusing (even the current practice is already confusing).  Consider
+it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
+times.
+*/
+
+
+/* Trashcan mechanism, thanks to Christian Tismer.
+
+When deallocating a container object, it's possible to trigger an unbounded
+chain of deallocations, as each Py_DECREF in turn drops the refcount on &quot;the
+next&quot; object in the chain to 0.  This can easily lead to stack faults, and
+especially in threads (which typically have less stack space to work with).
+
+A container object that participates in cyclic gc can avoid this by
+bracketing the body of its tp_dealloc function with a pair of macros:
+
+static void
+mytype_dealloc(mytype *p)
+{
+        ... declarations go here ...
+
+ 	PyObject_GC_UnTrack(p);	   // must untrack first
+	Py_TRASHCAN_SAFE_BEGIN(p)
+	... The body of the deallocator goes here, including all calls ...
+	... to Py_DECREF on contained objects.                         ...
+	Py_TRASHCAN_SAFE_END(p)
+}
+
+CAUTION:  Never return from the middle of the body!  If the body needs to
+&quot;get out early&quot;, put a label immediately before the Py_TRASHCAN_SAFE_END
+call, and goto it.  Else the call-depth counter (see below) will stay
+above 0 forever, and the trashcan will never get emptied.
+
+How it works:  The BEGIN macro increments a call-depth counter.  So long
+as this counter is small, the body of the deallocator is run directly without
+further ado.  But if the counter gets large, it instead adds p to a list of
+objects to be deallocated later, skips the body of the deallocator, and
+resumes execution after the END macro.  The tp_dealloc routine then returns
+without deallocating anything (and so unbounded call-stack depth is avoided).
+
+When the call stack finishes unwinding again, code generated by the END macro
+notices this, and calls another routine to deallocate all the objects that
+may have been added to the list of deferred deallocations.  In effect, a
+chain of N deallocations is broken into N / PyTrash_UNWIND_LEVEL pieces,
+with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
+*/
+
+PyAPI_FUNC(void) _PyTrash_deposit_object(PyObject*);
+PyAPI_FUNC(void) _PyTrash_destroy_chain(void);
+PyAPI_DATA(int) _PyTrash_delete_nesting;
+PyAPI_DATA(PyObject *) _PyTrash_delete_later;
+
+#define PyTrash_UNWIND_LEVEL 50
+
+#define Py_TRASHCAN_SAFE_BEGIN(op) \
+	if (_PyTrash_delete_nesting &lt; PyTrash_UNWIND_LEVEL) { \
+		++_PyTrash_delete_nesting;
+		/* The body of the deallocator is here. */
+#define Py_TRASHCAN_SAFE_END(op) \
+		--_PyTrash_delete_nesting; \
+		if (_PyTrash_delete_later &amp;&amp; _PyTrash_delete_nesting &lt;= 0) \
+			_PyTrash_destroy_chain(); \
+	} \
+	else \
+		_PyTrash_deposit_object((PyObject*)op);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OBJECT_H */

Added: trunk/msvc-libs/include/objimpl.h
===================================================================
--- trunk/msvc-libs/include/objimpl.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/objimpl.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,340 @@
+/* The PyObject_ memory family:  high-level object memory interfaces.
+   See pymem.h for the low-level PyMem_ family.
+*/
+
+#ifndef Py_OBJIMPL_H
+#define Py_OBJIMPL_H
+
+#include &quot;pymem.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* BEWARE:
+
+   Each interface exports both functions and macros.  Extension modules should
+   use the functions, to ensure binary compatibility across Python versions.
+   Because the Python implementation is free to change internal details, and
+   the macros may (or may not) expose details for speed, if you do use the
+   macros you must recompile your extensions with each Python release.
+
+   Never mix calls to PyObject_ memory functions with calls to the platform
+   malloc/realloc/ calloc/free, or with calls to PyMem_.
+*/
+
+/*
+Functions and macros for modules that implement new object types.
+
+ - PyObject_New(type, typeobj) allocates memory for a new object of the given
+   type, and initializes part of it.  'type' must be the C structure type used
+   to represent the object, and 'typeobj' the address of the corresponding
+   type object.  Reference count and type pointer are filled in; the rest of
+   the bytes of the object are *undefined*!  The resulting expression type is
+   'type *'.  The size of the object is determined by the tp_basicsize field
+   of the type object.
+
+ - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
+   object with room for n items.  In addition to the refcount and type pointer
+   fields, this also fills in the ob_size field.
+
+ - PyObject_Del(op) releases the memory allocated for an object.  It does not
+   run a destructor -- it only frees the memory.  PyObject_Free is identical.
+
+ - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
+   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
+   new object (allocated by an arbitrary allocator), and initialize its object
+   header fields.
+
+Note that objects created with PyObject_{New, NewVar} are allocated using the
+specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
+enabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG
+is also #defined.
+
+In case a specific form of memory management is needed (for example, if you
+must use the platform malloc heap(s), or shared memory, or C++ local storage or
+operator new), you must first allocate the object with your custom allocator,
+then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
+specific fields:  reference count, type pointer, possibly others.  You should
+be aware that Python no control over these objects because they don't
+cooperate with the Python memory manager.  Such objects may not be eligible
+for automatic garbage collection and you have to make sure that they are
+released accordingly whenever their destructor gets called (cf. the specific
+form of memory management you're using).
+
+Unless you have specific memory management requirements, use
+PyObject_{New, NewVar, Del}.
+*/
+
+/*
+ * Raw object memory interface
+ * ===========================
+ */
+
+/* Functions to call the same malloc/realloc/free as used by Python's
+   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
+   the platform malloc/realloc/free.  The Python object allocator is
+   designed for fast, cache-conscious allocation of many &quot;small&quot; objects,
+   and with low hidden memory overhead.
+
+   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.
+
+   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
+   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
+   at p.
+
+   Returned pointers must be checked for NULL explicitly; no action is
+   performed on failure other than to return NULL (no warning it printed, no
+   exception is set, etc).
+
+   For allocating objects, use PyObject_{New, NewVar} instead whenever
+   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
+   so that you can exploit Python's small-block allocator for non-object
+   uses.  If you must use these routines to allocate object memory, make sure
+   the object gets initialized via PyObject_{Init, InitVar} after obtaining
+   the raw memory.
+*/
+PyAPI_FUNC(void *) PyObject_Malloc(size_t);
+PyAPI_FUNC(void *) PyObject_Realloc(void *, size_t);
+PyAPI_FUNC(void) PyObject_Free(void *);
+
+
+/* Macros */
+#ifdef WITH_PYMALLOC
+#ifdef PYMALLOC_DEBUG
+PyAPI_FUNC(void *) _PyObject_DebugMalloc(size_t nbytes);
+PyAPI_FUNC(void *) _PyObject_DebugRealloc(void *p, size_t nbytes);
+PyAPI_FUNC(void) _PyObject_DebugFree(void *p);
+PyAPI_FUNC(void) _PyObject_DebugDumpAddress(const void *p);
+PyAPI_FUNC(void) _PyObject_DebugCheckAddress(const void *p);
+PyAPI_FUNC(void) _PyObject_DebugMallocStats(void);
+#define PyObject_MALLOC		_PyObject_DebugMalloc
+#define PyObject_Malloc		_PyObject_DebugMalloc
+#define PyObject_REALLOC	_PyObject_DebugRealloc
+#define PyObject_Realloc	_PyObject_DebugRealloc
+#define PyObject_FREE		_PyObject_DebugFree
+#define PyObject_Free		_PyObject_DebugFree
+
+#else	/* WITH_PYMALLOC &amp;&amp; ! PYMALLOC_DEBUG */
+#define PyObject_MALLOC		PyObject_Malloc
+#define PyObject_REALLOC	PyObject_Realloc
+#define PyObject_FREE		PyObject_Free
+#endif
+
+#else	/* ! WITH_PYMALLOC */
+#define PyObject_MALLOC		PyMem_MALLOC
+#define PyObject_REALLOC	PyMem_REALLOC
+/* This is an odd one!  For backward compatability with old extensions, the
+   PyMem &quot;release memory&quot; functions have to invoke the object allocator's
+   free() function.  When pymalloc isn't enabled, that leaves us using
+   the platform free(). */
+#define PyObject_FREE		free
+
+#endif	/* WITH_PYMALLOC */
+
+#define PyObject_Del		PyObject_Free
+#define PyObject_DEL		PyObject_FREE
+
+/* for source compatibility with 2.2 */
+#define _PyObject_Del		PyObject_Free
+
+/*
+ * Generic object allocator interface
+ * ==================================
+ */
+
+/* Functions */
+PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
+                                                 PyTypeObject *, int);
+PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, int);
+
+#define PyObject_New(type, typeobj) \
+		( (type *) _PyObject_New(typeobj) )
+#define PyObject_NewVar(type, typeobj, n) \
+		( (type *) _PyObject_NewVar((typeobj), (n)) )
+
+/* Macros trading binary compatibility for speed. See also pymem.h.
+   Note that these macros expect non-NULL object pointers.*/
+#define PyObject_INIT(op, typeobj) \
+	( (op)-&gt;ob_type = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
+#define PyObject_INIT_VAR(op, typeobj, size) \
+	( (op)-&gt;ob_size = (size), PyObject_INIT((op), (typeobj)) )
+
+#define _PyObject_SIZE(typeobj) ( (typeobj)-&gt;tp_basicsize )
+
+/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
+   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
+   value is rounded up to the closest multiple of sizeof(void *), in order to
+   ensure that pointer fields at the end of the object are correctly aligned
+   for the platform (this is of special importance for subclasses of, e.g.,
+   str or long, so that pointers can be stored after the embedded data).
+
+   Note that there's no memory wastage in doing this, as malloc has to
+   return (at worst) pointer-aligned memory anyway.
+*/
+#if ((SIZEOF_VOID_P - 1) &amp; SIZEOF_VOID_P) != 0
+#   error &quot;_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2&quot;
+#endif
+
+#define _PyObject_VAR_SIZE(typeobj, nitems)	\
+	(size_t)				\
+	( ( (typeobj)-&gt;tp_basicsize +		\
+	    (nitems)*(typeobj)-&gt;tp_itemsize +	\
+	    (SIZEOF_VOID_P - 1)			\
+	  ) &amp; ~(SIZEOF_VOID_P - 1)		\
+	)
+
+#define PyObject_NEW(type, typeobj) \
+( (type *) PyObject_Init( \
+	(PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )
+
+#define PyObject_NEW_VAR(type, typeobj, n) \
+( (type *) PyObject_InitVar( \
+      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\
+      (typeobj), (n)) )
+
+/* This example code implements an object constructor with a custom
+   allocator, where PyObject_New is inlined, and shows the important
+   distinction between two steps (at least):
+       1) the actual allocation of the object storage;
+       2) the initialization of the Python specific fields
+          in this storage with PyObject_{Init, InitVar}.
+
+   PyObject *
+   YourObject_New(...)
+   {
+       PyObject *op;
+
+       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));
+       if (op == NULL)
+           return PyErr_NoMemory();
+
+       PyObject_Init(op, &amp;YourTypeStruct);
+
+       op-&gt;ob_field = value;
+       ...
+       return op;
+   }
+
+   Note that in C++, the use of the new operator usually implies that
+   the 1st step is performed automatically for you, so in a C++ class
+   constructor you would start directly with PyObject_Init/InitVar
+*/
+
+/*
+ * Garbage Collection Support
+ * ==========================
+ */
+
+/* C equivalent of gc.collect(). */
+long PyGC_Collect(void);
+
+/* Test if a type has a GC head */
+#define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)
+
+/* Test if an object has a GC head */
+#define PyObject_IS_GC(o) (PyType_IS_GC((o)-&gt;ob_type) &amp;&amp; \
+	((o)-&gt;ob_type-&gt;tp_is_gc == NULL || (o)-&gt;ob_type-&gt;tp_is_gc(o)))
+
+PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, int);
+#define PyObject_GC_Resize(type, op, n) \
+		( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )
+
+/* for source compatibility with 2.2 */
+#define _PyObject_GC_Del PyObject_GC_Del
+
+/* GC information is stored BEFORE the object structure. */
+typedef union _gc_head {
+	struct {
+		union _gc_head *gc_next;
+		union _gc_head *gc_prev;
+		int gc_refs;
+	} gc;
+	long double dummy;  /* force worst-case alignment */
+} PyGC_Head;
+
+extern PyGC_Head *_PyGC_generation0;
+
+#define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)
+
+#define _PyGC_REFS_UNTRACKED			(-2)
+#define _PyGC_REFS_REACHABLE			(-3)
+#define _PyGC_REFS_TENTATIVELY_UNREACHABLE	(-4)
+
+/* Tell the GC to track this object.  NB: While the object is tracked the
+ * collector it must be safe to call the ob_traverse method. */
+#define _PyObject_GC_TRACK(o) do { \
+	PyGC_Head *g = _Py_AS_GC(o); \
+	if (g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED) \
+		Py_FatalError(&quot;GC object already tracked&quot;); \
+	g-&gt;gc.gc_refs = _PyGC_REFS_REACHABLE; \
+	g-&gt;gc.gc_next = _PyGC_generation0; \
+	g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \
+	g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \
+	_PyGC_generation0-&gt;gc.gc_prev = g; \
+    } while (0);
+
+/* Tell the GC to stop tracking this object.
+ * gc_next doesn't need to be set to NULL, but doing so is a good
+ * way to provoke memory errors if calling code is confused.
+ */
+#define _PyObject_GC_UNTRACK(o) do { \
+	PyGC_Head *g = _Py_AS_GC(o); \
+	assert(g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED); \
+	g-&gt;gc.gc_refs = _PyGC_REFS_UNTRACKED; \
+	g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \
+	g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \
+	g-&gt;gc.gc_next = NULL; \
+    } while (0);
+
+PyAPI_FUNC(PyObject *) _PyObject_GC_Malloc(size_t);
+PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, int);
+PyAPI_FUNC(void) PyObject_GC_Track(void *);
+PyAPI_FUNC(void) PyObject_GC_UnTrack(void *);
+PyAPI_FUNC(void) PyObject_GC_Del(void *);
+
+#define PyObject_GC_New(type, typeobj) \
+		( (type *) _PyObject_GC_New(typeobj) )
+#define PyObject_GC_NewVar(type, typeobj, n) \
+		( (type *) _PyObject_GC_NewVar((typeobj), (n)) )
+
+
+/* Utility macro to help write tp_traverse functions.
+ * To use this macro, the tp_traverse function must name its arguments
+ * &quot;visit&quot; and &quot;arg&quot;.  This is intended to keep tp_traverse functions
+ * looking as much alike as possible.
+ */
+#define Py_VISIT(op)					\
+        do { 						\
+                if (op) {				\
+                        int vret = visit((op), arg);	\
+                        if (vret)			\
+                                return vret;		\
+                }					\
+        } while (0)
+
+/* This is here for the sake of backwards compatibility.  Extensions that
+ * use the old GC API will still compile but the objects will not be
+ * tracked by the GC. */
+#define PyGC_HEAD_SIZE 0
+#define PyObject_GC_Init(op)
+#define PyObject_GC_Fini(op)
+#define PyObject_AS_GC(op) (op)
+#define PyObject_FROM_GC(op) (op)
+
+
+/* Test if a type supports weak references */
+#define PyType_SUPPORTS_WEAKREFS(t) \
+        (PyType_HasFeature((t), Py_TPFLAGS_HAVE_WEAKREFS) \
+         &amp;&amp; ((t)-&gt;tp_weaklistoffset &gt; 0))
+
+#define PyObject_GET_WEAKREFS_LISTPTR(o) \
+	((PyObject **) (((char *) (o)) + (o)-&gt;ob_type-&gt;tp_weaklistoffset))
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OBJIMPL_H */

Added: trunk/msvc-libs/include/opcode.h
===================================================================
--- trunk/msvc-libs/include/opcode.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/opcode.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,153 @@
+#ifndef Py_OPCODE_H
+#define Py_OPCODE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Instruction opcodes for compiled code */
+
+#define STOP_CODE	0
+#define POP_TOP		1
+#define ROT_TWO		2
+#define ROT_THREE	3
+#define DUP_TOP		4
+#define ROT_FOUR	5
+#define NOP		9
+
+#define UNARY_POSITIVE	10
+#define UNARY_NEGATIVE	11
+#define UNARY_NOT	12
+#define UNARY_CONVERT	13
+
+#define UNARY_INVERT	15
+
+#define LIST_APPEND	18
+#define BINARY_POWER	19
+
+#define BINARY_MULTIPLY	20
+#define BINARY_DIVIDE	21
+#define BINARY_MODULO	22
+#define BINARY_ADD	23
+#define BINARY_SUBTRACT	24
+#define BINARY_SUBSCR	25
+#define BINARY_FLOOR_DIVIDE 26
+#define BINARY_TRUE_DIVIDE 27
+#define INPLACE_FLOOR_DIVIDE 28
+#define INPLACE_TRUE_DIVIDE 29
+
+#define SLICE		30
+/* Also uses 31-33 */
+
+#define STORE_SLICE	40
+/* Also uses 41-43 */
+
+#define DELETE_SLICE	50
+/* Also uses 51-53 */
+
+#define INPLACE_ADD	55
+#define INPLACE_SUBTRACT	56
+#define INPLACE_MULTIPLY	57
+#define INPLACE_DIVIDE	58
+#define INPLACE_MODULO	59
+#define STORE_SUBSCR	60
+#define DELETE_SUBSCR	61
+
+#define BINARY_LSHIFT	62
+#define BINARY_RSHIFT	63
+#define BINARY_AND	64
+#define BINARY_XOR	65
+#define BINARY_OR	66
+#define INPLACE_POWER	67
+#define GET_ITER	68
+
+#define PRINT_EXPR	70
+#define PRINT_ITEM	71
+#define PRINT_NEWLINE	72
+#define PRINT_ITEM_TO   73
+#define PRINT_NEWLINE_TO 74
+#define INPLACE_LSHIFT	75
+#define INPLACE_RSHIFT	76
+#define INPLACE_AND	77
+#define INPLACE_XOR	78
+#define INPLACE_OR	79
+#define BREAK_LOOP	80
+
+#define LOAD_LOCALS	82
+#define RETURN_VALUE	83
+#define IMPORT_STAR	84
+#define EXEC_STMT	85
+#define YIELD_VALUE	86
+
+#define POP_BLOCK	87
+#define END_FINALLY	88
+#define BUILD_CLASS	89
+
+#define HAVE_ARGUMENT	90	/* Opcodes from here have an argument: */
+
+#define STORE_NAME	90	/* Index in name list */
+#define DELETE_NAME	91	/* &quot;&quot; */
+#define UNPACK_SEQUENCE	92	/* Number of sequence items */
+#define FOR_ITER	93
+
+#define STORE_ATTR	95	/* Index in name list */
+#define DELETE_ATTR	96	/* &quot;&quot; */
+#define STORE_GLOBAL	97	/* &quot;&quot; */
+#define DELETE_GLOBAL	98	/* &quot;&quot; */
+#define DUP_TOPX	99	/* number of items to duplicate */
+#define LOAD_CONST	100	/* Index in const list */
+#define LOAD_NAME	101	/* Index in name list */
+#define BUILD_TUPLE	102	/* Number of tuple items */
+#define BUILD_LIST	103	/* Number of list items */
+#define BUILD_MAP	104	/* Always zero for now */
+#define LOAD_ATTR	105	/* Index in name list */
+#define COMPARE_OP	106	/* Comparison operator */
+#define IMPORT_NAME	107	/* Index in name list */
+#define IMPORT_FROM	108	/* Index in name list */
+
+#define JUMP_FORWARD	110	/* Number of bytes to skip */
+#define JUMP_IF_FALSE	111	/* &quot;&quot; */
+#define JUMP_IF_TRUE	112	/* &quot;&quot; */
+#define JUMP_ABSOLUTE	113	/* Target byte offset from beginning of code */
+
+#define LOAD_GLOBAL	116	/* Index in name list */
+
+#define CONTINUE_LOOP	119	/* Start of loop (absolute) */
+#define SETUP_LOOP	120	/* Target address (absolute) */
+#define SETUP_EXCEPT	121	/* &quot;&quot; */
+#define SETUP_FINALLY	122	/* &quot;&quot; */
+
+#define LOAD_FAST	124	/* Local variable number */
+#define STORE_FAST	125	/* Local variable number */
+#define DELETE_FAST	126	/* Local variable number */
+
+#define RAISE_VARARGS	130	/* Number of raise arguments (1, 2 or 3) */
+/* CALL_FUNCTION_XXX opcodes defined below depend on this definition */
+#define CALL_FUNCTION	131	/* #args + (#kwargs&lt;&lt;8) */
+#define MAKE_FUNCTION	132	/* #defaults */
+#define BUILD_SLICE 	133	/* Number of items */
+
+#define MAKE_CLOSURE    134     /* #free vars */
+#define LOAD_CLOSURE    135     /* Load free variable from closure */
+#define LOAD_DEREF      136     /* Load and dereference from closure cell */ 
+#define STORE_DEREF     137     /* Store into cell */ 
+
+/* The next 3 opcodes must be contiguous and satisfy
+   (CALL_FUNCTION_VAR - CALL_FUNCTION) &amp; 3 == 1  */
+#define CALL_FUNCTION_VAR          140	/* #args + (#kwargs&lt;&lt;8) */
+#define CALL_FUNCTION_KW           141	/* #args + (#kwargs&lt;&lt;8) */
+#define CALL_FUNCTION_VAR_KW       142	/* #args + (#kwargs&lt;&lt;8) */
+
+/* Support for opargs more than 16 bits long */
+#define EXTENDED_ARG  143
+
+
+enum cmp_op {PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE, PyCmp_GT=Py_GT, PyCmp_GE=Py_GE,
+	     PyCmp_IN, PyCmp_NOT_IN, PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD};
+
+#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OPCODE_H */

Added: trunk/msvc-libs/include/osdefs.h
===================================================================
--- trunk/msvc-libs/include/osdefs.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/osdefs.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,51 @@
+#ifndef Py_OSDEFS_H
+#define Py_OSDEFS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Operating system dependencies */
+
+/* Mod by chrish: QNX has WATCOM, but isn't DOS */
+#if !defined(__QNX__)
+#if defined(MS_WINDOWS) || defined(__BORLANDC__) || defined(__WATCOMC__) || defined(__DJGPP__) || defined(PYOS_OS2)
+#if defined(PYOS_OS2) &amp;&amp; defined(PYCC_GCC)
+#define MAXPATHLEN 260
+#define SEP '/'
+#define ALTSEP '\\'
+#else
+#define SEP '\\'
+#define ALTSEP '/'
+#define MAXPATHLEN 256
+#endif
+#define DELIM ';'
+#endif
+#endif
+
+#ifdef RISCOS
+#define SEP '.'
+#define MAXPATHLEN 256
+#define DELIM ','
+#endif
+
+
+/* Filename separator */
+#ifndef SEP
+#define SEP '/'
+#endif
+
+/* Max pathname length */
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
+/* Search path entry delimiter */
+#ifndef DELIM
+#define DELIM ':'
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OSDEFS_H */

Added: trunk/msvc-libs/include/parsetok.h
===================================================================
--- trunk/msvc-libs/include/parsetok.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/parsetok.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,48 @@
+
+/* Parser-tokenizer link interface */
+
+#ifndef Py_PARSETOK_H
+#define Py_PARSETOK_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct {
+    int error;
+    const char *filename;
+    int lineno;
+    int offset;
+    char *text;
+    int token;
+    int expected;
+} perrdetail;
+
+#if 0
+#define PyPARSE_YIELD_IS_KEYWORD	0x0001
+#endif
+
+#define PyPARSE_DONT_IMPLY_DEDENT	0x0002
+
+PyAPI_FUNC(node *) PyParser_ParseString(const char *, grammar *, int,
+                                              perrdetail *);
+PyAPI_FUNC(node *) PyParser_ParseFile (FILE *, const char *, grammar *, int,
+                                             char *, char *, perrdetail *);
+
+PyAPI_FUNC(node *) PyParser_ParseStringFlags(const char *, grammar *, int,
+                                              perrdetail *, int);
+PyAPI_FUNC(node *) PyParser_ParseFileFlags(FILE *, const char *, grammar *,
+						 int, char *, char *,
+						 perrdetail *, int);
+
+PyAPI_FUNC(node *) PyParser_ParseStringFlagsFilename(const char *,
+					      const char *,
+					      grammar *, int,
+                                              perrdetail *, int);
+
+/* Note that he following function is defined in pythonrun.c not parsetok.c. */
+PyAPI_FUNC(void) PyParser_SetError(perrdetail *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PARSETOK_H */

Added: trunk/msvc-libs/include/patchlevel.h
===================================================================
--- trunk/msvc-libs/include/patchlevel.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/patchlevel.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,37 @@
+
+/* Newfangled version identification scheme.
+
+   This scheme was added in Python 1.5.2b2; before that time, only PATCHLEVEL
+   was available.  To test for presence of the scheme, test for
+   defined(PY_MAJOR_VERSION).
+
+   When the major or minor version changes, the VERSION variable in
+   configure.in must also be changed.
+
+   There is also (independent) API version information in modsupport.h.
+*/
+
+/* Values for PY_RELEASE_LEVEL */
+#define PY_RELEASE_LEVEL_ALPHA	0xA
+#define PY_RELEASE_LEVEL_BETA	0xB
+#define PY_RELEASE_LEVEL_GAMMA	0xC     /* For release candidates */
+#define PY_RELEASE_LEVEL_FINAL	0xF	/* Serial should be 0 here */
+					/* Higher for patch releases */
+
+/* Version parsed out into numeric values */
+#define PY_MAJOR_VERSION	2
+#define PY_MINOR_VERSION	4
+#define PY_MICRO_VERSION	0
+#define PY_RELEASE_LEVEL	PY_RELEASE_LEVEL_FINAL
+#define PY_RELEASE_SERIAL	0
+
+/* Version as a string */
+#define PY_VERSION		&quot;2.4&quot;
+
+/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
+   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX &gt;= ... */
+#define PY_VERSION_HEX ((PY_MAJOR_VERSION &lt;&lt; 24) | \
+			(PY_MINOR_VERSION &lt;&lt; 16) | \
+			(PY_MICRO_VERSION &lt;&lt;  8) | \
+			(PY_RELEASE_LEVEL &lt;&lt;  4) | \
+			(PY_RELEASE_SERIAL &lt;&lt; 0))

Added: trunk/msvc-libs/include/pgen.h
===================================================================
--- trunk/msvc-libs/include/pgen.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pgen.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,18 @@
+#ifndef Py_PGEN_H
+#define Py_PGEN_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Parser generator interface */
+
+extern grammar *meta_grammar(void);
+
+struct _node;
+extern grammar *pgen(struct _node *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PGEN_H */

Added: trunk/msvc-libs/include/pgenheaders.h
===================================================================
--- trunk/msvc-libs/include/pgenheaders.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pgenheaders.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,42 @@
+#ifndef Py_PGENHEADERS_H
+#define Py_PGENHEADERS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Include files and extern declarations used by most of the parser. */
+
+#include &quot;Python.h&quot;
+
+PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+
+#define addarc _Py_addarc
+#define addbit _Py_addbit
+#define adddfa _Py_adddfa
+#define addfirstsets _Py_addfirstsets
+#define addlabel _Py_addlabel
+#define addstate _Py_addstate
+#define delbitset _Py_delbitset
+#define dumptree _Py_dumptree
+#define findlabel _Py_findlabel
+#define mergebitset _Py_mergebitset
+#define meta_grammar _Py_meta_grammar
+#define newbitset _Py_newbitset
+#define newgrammar _Py_newgrammar
+#define pgen _Py_pgen
+#define printgrammar _Py_printgrammar
+#define printnonterminals _Py_printnonterminals
+#define printtree _Py_printtree
+#define samebitset _Py_samebitset
+#define showtree _Py_showtree
+#define tok_dump _Py_tok_dump
+#define translatelabels _Py_translatelabels
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PGENHEADERS_H */

Added: trunk/msvc-libs/include/py_curses.h
===================================================================
--- trunk/msvc-libs/include/py_curses.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/py_curses.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,176 @@
+
+#ifndef Py_CURSES_H
+#define Py_CURSES_H
+
+#ifdef __APPLE__
+/*
+** On Mac OS X 10.2 [n]curses.h and stdlib.h use different guards
+** against multiple definition of wchar_t.
+*/
+#ifdef	_BSD_WCHAR_T_DEFINED_
+#define _WCHAR_T
+#endif
+#endif
+
+#ifdef __FreeBSD__
+/*
+** On FreeBSD, [n]curses.h and stdlib.h/wchar.h use different guards
+** against multiple definition of wchar_t and wint_t.
+*/
+#ifdef	_XOPEN_SOURCE_EXTENDED
+#ifndef __FreeBSD_version
+#include &lt;osreldate.h&gt;
+#endif
+#if __FreeBSD_version &gt;= 500000
+#ifndef __wchar_t
+#define __wchar_t
+#endif
+#ifndef __wint_t
+#define __wint_t
+#endif
+#else
+#ifndef _WCHAR_T
+#define _WCHAR_T
+#endif
+#ifndef _WINT_T
+#define _WINT_T
+#endif
+#endif
+#endif
+#endif
+
+#ifdef HAVE_NCURSES_H
+#include &lt;ncurses.h&gt;
+#else
+#include &lt;curses.h&gt;
+#ifdef HAVE_TERM_H
+/* for tigetstr, which is not declared in SysV curses */
+#include &lt;term.h&gt;
+#endif
+#endif
+
+#ifdef HAVE_NCURSES_H
+/* configure was checking &lt;curses.h&gt;, but we will
+   use &lt;ncurses.h&gt;, which has all these features. */
+#ifndef WINDOW_HAS_FLAGS
+#define WINDOW_HAS_FLAGS 1
+#endif
+#ifndef MVWDELCH_IS_EXPRESSION
+#define MVWDELCH_IS_EXPRESSION 1
+#endif
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define PyCurses_API_pointers 4
+
+/* Type declarations */
+
+typedef struct {
+	PyObject_HEAD
+	WINDOW *win;
+} PyCursesWindowObject;
+
+#define PyCursesWindow_Check(v)	 ((v)-&gt;ob_type == &amp;PyCursesWindow_Type)
+
+#ifdef CURSES_MODULE
+/* This section is used when compiling _cursesmodule.c */
+
+#else
+/* This section is used in modules that use the _cursesmodule API */
+
+static void **PyCurses_API;
+
+#define PyCursesWindow_Type (*(PyTypeObject *) PyCurses_API[0])
+#define PyCursesSetupTermCalled  {if (! ((int (*)(void))PyCurses_API[1]) () ) return NULL;}
+#define PyCursesInitialised      {if (! ((int (*)(void))PyCurses_API[2]) () ) return NULL;}
+#define PyCursesInitialisedColor {if (! ((int (*)(void))PyCurses_API[3]) () ) return NULL;}
+
+#define import_curses() \
+{ \
+  PyObject *module = PyImport_ImportModule(&quot;_curses&quot;); \
+  if (module != NULL) { \
+    PyObject *module_dict = PyModule_GetDict(module); \
+    PyObject *c_api_object = PyDict_GetItemString(module_dict, &quot;_C_API&quot;); \
+    if (PyCObject_Check(c_api_object)) { \
+      PyCurses_API = (void **)PyCObject_AsVoidPtr(c_api_object); \
+    } \
+  } \
+}
+#endif
+
+/* general error messages */
+static char *catchall_ERR  = &quot;curses function returned ERR&quot;;
+static char *catchall_NULL = &quot;curses function returned NULL&quot;;
+
+/* Function Prototype Macros - They are ugly but very, very useful. ;-)
+
+   X - function name
+   TYPE - parameter Type
+   ERGSTR - format string for construction of the return value
+   PARSESTR - format string for argument parsing
+   */
+
+#define NoArgNoReturnFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  return PyCursesCheckERR(X(), # X); }
+
+#define NoArgOrFlagNoReturnFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self, PyObject *args) \
+{ \
+  int flag = 0; \
+  PyCursesInitialised \
+  switch(PyTuple_Size(args)) { \
+  case 0: \
+    return PyCursesCheckERR(X(), # X); \
+  case 1: \
+    if (!PyArg_ParseTuple(args, &quot;i;True(1) or False(0)&quot;, &amp;flag)) return NULL; \
+    if (flag) return PyCursesCheckERR(X(), # X); \
+    else return PyCursesCheckERR(no ## X (), # X); \
+  default: \
+    PyErr_SetString(PyExc_TypeError, # X &quot; requires 0 or 1 arguments&quot;); \
+    return NULL; } }
+
+#define NoArgReturnIntFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+ PyCursesInitialised \
+ return PyInt_FromLong((long) X()); }
+
+
+#define NoArgReturnStringFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  return PyString_FromString(X()); }
+
+#define NoArgTrueFalseFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  if (X () == FALSE) { \
+    Py_INCREF(Py_False); \
+    return Py_False; \
+  } \
+  Py_INCREF(Py_True); \
+  return Py_True; }
+
+#define NoArgNoReturnVoidFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  X(); \
+  Py_INCREF(Py_None); \
+  return Py_None; }
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !defined(Py_CURSES_H) */
+
+

Added: trunk/msvc-libs/include/pyconfig.h
===================================================================
--- trunk/msvc-libs/include/pyconfig.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pyconfig.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,565 @@
+#ifndef Py_CONFIG_H
+#define Py_CONFIG_H
+
+/* pyconfig.h.  NOT Generated automatically by configure.
+
+This is a manually maintained version used for the Watcom,
+Borland and Microsoft Visual C++ compilers.  It is a
+standard part of the Python distribution.
+
+WINDOWS DEFINES:
+The code specific to Windows should be wrapped around one of
+the following #defines
+
+MS_WIN64 - Code specific to the MS Win64 API
+MS_WIN32 - Code specific to the MS Win32 (and Win64) API (obsolete, this covers all supported APIs)
+MS_WINDOWS - Code specific to Windows, but all versions.
+Py_ENABLE_SHARED - Code if the Python core is built as a DLL.
+
+Also note that neither &quot;_M_IX86&quot; or &quot;_MSC_VER&quot; should be used for
+any purpose other than &quot;Windows Intel x86 specific&quot; and &quot;Microsoft
+compiler specific&quot;.  Therefore, these should be very rare.
+
+
+NOTE: The following symbols are deprecated:
+NT, WIN32, USE_DL_EXPORT, USE_DL_IMPORT, DL_EXPORT, DL_IMPORT
+MS_CORE_DLL.
+
+*/
+
+#include &lt;io.h&gt;
+#define HAVE_SYS_UTIME_H
+#define HAVE_HYPOT
+#define HAVE_TEMPNAM
+#define HAVE_TMPFILE
+#define HAVE_TMPNAM
+#define HAVE_CLOCK
+#define HAVE_STRFTIME
+#define HAVE_STRERROR
+#define DONT_HAVE_SIG_ALARM
+#define DONT_HAVE_SIG_PAUSE
+#define LONG_BIT	32
+#define WORD_BIT 32
+#define PREFIX &quot;&quot;
+#define EXEC_PREFIX &quot;&quot;
+
+#define MS_WIN32 /* only support win32 and greater. */
+#define MS_WINDOWS
+#ifndef PYTHONPATH
+#	define PYTHONPATH &quot;.\\DLLs;.\\lib;.\\lib\\plat-win;.\\lib\\lib-tk&quot;
+#endif
+#define NT_THREADS
+#define WITH_THREAD
+#ifndef NETSCAPE_PI
+#define USE_SOCKET
+#endif
+
+/* Compiler specific defines */
+
+/* ------------------------------------------------------------------------*/
+/* Microsoft C defines _MSC_VER */
+#ifdef _MSC_VER
+
+/* We want COMPILER to expand to a string containing _MSC_VER's *value*.
+ * This is horridly tricky, because the stringization operator only works
+ * on macro arguments, and doesn't evaluate macros passed *as* arguments.
+ * Attempts simpler than the following appear doomed to produce &quot;_MSC_VER&quot;
+ * literally in the string.
+ */
+#define _Py_PASTE_VERSION(SUFFIX) \
+	(&quot;[MSC v.&quot; _Py_STRINGIZE(_MSC_VER) &quot; &quot; SUFFIX &quot;]&quot;)
+/* e.g., this produces, after compile-time string catenation,
+ * 	(&quot;[MSC v.1200 32 bit (Intel)]&quot;)
+ *
+ * _Py_STRINGIZE(_MSC_VER) expands to
+ * _Py_STRINGIZE1((_MSC_VER)) expands to
+ * _Py_STRINGIZE2(_MSC_VER) but as this call is the result of token-pasting
+ *      it's scanned again for macros and so further expands to (under MSVC 6)
+ * _Py_STRINGIZE2(1200) which then expands to
+ * &quot;1200&quot;
+ */
+#define _Py_STRINGIZE(X) _Py_STRINGIZE1((X))
+#define _Py_STRINGIZE1(X) _Py_STRINGIZE2 ## X
+#define _Py_STRINGIZE2(X) #X
+
+/* MSVC defines _WINxx to differentiate the windows platform types
+
+   Note that for compatibility reasons _WIN32 is defined on Win32
+   *and* on Win64. For the same reasons, in Python, MS_WIN32 is
+   defined on Win32 *and* Win64. Win32 only code must therefore be
+   guarded as follows:
+   	#if defined(MS_WIN32) &amp;&amp; !defined(MS_WIN64)
+*/
+#ifdef _WIN64
+#define MS_WIN64
+#endif
+
+/* set the COMPILER */
+#ifdef MS_WIN64
+#ifdef _M_IX86
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (Intel)&quot;)
+#elif defined(_M_IA64)
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (Itanium)&quot;)
+#elif defined(_M_AMD64)
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (AMD64)&quot;)
+#else
+#define COMPILER _Py_PASTE_VERSION(&quot;64 bit (Unknown)&quot;)
+#endif
+#endif /* MS_WIN64 */
+
+#if defined(MS_WIN32) &amp;&amp; !defined(MS_WIN64)
+#ifdef _M_IX86
+#define COMPILER _Py_PASTE_VERSION(&quot;32 bit (Intel)&quot;)
+#else
+#define COMPILER _Py_PASTE_VERSION(&quot;32 bit (Unknown)&quot;)
+#endif
+#endif /* MS_WIN32 &amp;&amp; !MS_WIN64 */
+
+typedef int pid_t;
+#define hypot _hypot
+
+#include &lt;float.h&gt;
+#define Py_IS_NAN _isnan
+#define Py_IS_INFINITY(X) (!_finite(X) &amp;&amp; !_isnan(X))
+
+#endif /* _MSC_VER */
+
+/* define some ANSI types that are not defined in earlier Win headers */
+#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1200
+/* This file only exists in VC 6.0 or higher */
+#include &lt;basetsd.h&gt;
+#endif
+
+/* ------------------------------------------------------------------------*/
+/* The Borland compiler defines __BORLANDC__ */
+/* XXX These defines are likely incomplete, but should be easy to fix. */
+#ifdef __BORLANDC__
+#define COMPILER &quot;[Borland]&quot;
+
+#ifdef _WIN32
+/* tested with BCC 5.5 (__BORLANDC__ &gt;= 0x0550)
+ */
+
+typedef int pid_t;
+/* BCC55 seems to understand __declspec(dllimport), it is used in its
+   own header files (winnt.h, ...) - so we can do nothing and get the default*/
+
+#undef HAVE_SYS_UTIME_H
+#define HAVE_UTIME_H
+#define HAVE_DIRENT_H
+
+/* rename a few functions for the Borland compiler */
+#include &lt;io.h&gt;
+#define _chsize chsize
+#define _setmode setmode
+
+#else /* !_WIN32 */
+#error &quot;Only Win32 and later are supported&quot;
+#endif /* !_WIN32 */
+
+#endif /* BORLANDC */
+
+/* ------------------------------------------------------------------------*/
+/* egcs/gnu-win32 defines __GNUC__ and _WIN32 */
+#if defined(__GNUC__) &amp;&amp; defined(_WIN32)
+/* XXX These defines are likely incomplete, but should be easy to fix.
+   They should be complete enough to build extension modules. */
+/* Suggested by Rene Liebscher &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">R.Liebscher at gmx.de</A>&gt; to avoid a GCC 2.91.*
+   bug that requires structure imports.  More recent versions of the
+   compiler don't exhibit this bug.
+*/
+#if (__GNUC__==2) &amp;&amp; (__GNUC_MINOR__&lt;=91)
+#warning &quot;Please use an up-to-date version of gcc! (&gt;2.91 recommended)&quot;
+#endif
+
+#define COMPILER &quot;[gcc]&quot;
+#define hypot _hypot
+#define PY_LONG_LONG long long
+#endif /* GNUC */
+
+/* ------------------------------------------------------------------------*/
+/* lcc-win32 defines __LCC__ */
+#if defined(__LCC__)
+/* XXX These defines are likely incomplete, but should be easy to fix.
+   They should be complete enough to build extension modules. */
+
+#define COMPILER &quot;[lcc-win32]&quot;
+typedef int pid_t;
+/* __declspec() is supported here too - do nothing to get the defaults */
+
+#endif /* LCC */
+
+/* ------------------------------------------------------------------------*/
+/* End of compilers - finish up */
+
+#ifndef NO_STDIO_H
+#	include &lt;stdio.h&gt;
+#endif
+
+/* 64 bit ints are usually spelt __int64 unless compiler has overridden */
+#define HAVE_LONG_LONG 1
+#ifndef PY_LONG_LONG
+#	define PY_LONG_LONG __int64
+#endif
+
+/* For Windows the Python core is in a DLL by default.  Test
+Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
+#if !defined(MS_NO_COREDLL) &amp;&amp; !defined(Py_NO_ENABLE_SHARED)
+#	define Py_ENABLE_SHARED 1 /* standard symbol for shared library */
+#	define MS_COREDLL	/* deprecated old symbol */
+#endif /* !MS_NO_COREDLL &amp;&amp; ... */
+
+/* Deprecated USE_DL_EXPORT macro - please use Py_BUILD_CORE */
+#ifdef USE_DL_EXPORT
+#	define Py_BUILD_CORE
+#endif /* USE_DL_EXPORT */
+
+/*  All windows compilers that use this header support __declspec */
+#define HAVE_DECLSPEC_DLL
+
+/* For an MSVC DLL, we can nominate the .lib files used by extensions */
+#ifdef MS_COREDLL
+#	ifndef Py_BUILD_CORE /* not building the core - must be an ext */
+#		if defined(_MSC_VER)
+			/* So MSVC users need not specify the .lib file in
+			their Makefile (other compilers are generally
+			taken care of by distutils.) */
+#			ifdef _DEBUG
+#				pragma comment(lib,&quot;python24_d.lib&quot;)
+#			else
+#				pragma comment(lib,&quot;python24.lib&quot;)
+#			endif /* _DEBUG */
+#		endif /* _MSC_VER */
+#	endif /* Py_BUILD_CORE */
+#endif /* MS_COREDLL */
+
+#if defined(MS_WIN64)
+/* maintain &quot;win32&quot; sys.platform for backward compatibility of Python code,
+   the Win64 API should be close enough to the Win32 API to make this
+   preferable */
+#	define PLATFORM &quot;win32&quot;
+#	define SIZEOF_VOID_P 8
+#	define SIZEOF_TIME_T 8
+#	define SIZEOF_OFF_T 4
+#	define SIZEOF_FPOS_T 8
+#	define SIZEOF_HKEY 8
+/* configure.in defines HAVE_LARGEFILE_SUPPORT iff HAVE_LONG_LONG,
+   sizeof(off_t) &gt; sizeof(long), and sizeof(PY_LONG_LONG) &gt;= sizeof(off_t).
+   On Win64 the second condition is not true, but if fpos_t replaces off_t
+   then this is true. The uses of HAVE_LARGEFILE_SUPPORT imply that Win64
+   should define this. */
+#	define HAVE_LARGEFILE_SUPPORT
+#elif defined(MS_WIN32)
+#	define PLATFORM &quot;win32&quot;
+#	define HAVE_LARGEFILE_SUPPORT
+#	define SIZEOF_VOID_P 4
+#	define SIZEOF_TIME_T 4
+#	define SIZEOF_OFF_T 4
+#	define SIZEOF_FPOS_T 8
+#	define SIZEOF_HKEY 4
+#endif
+
+#ifdef _DEBUG
+#	define Py_DEBUG
+#endif
+
+
+#ifdef MS_WIN32
+
+#define SIZEOF_SHORT 2
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+#define SIZEOF_LONG_LONG 8
+
+/* VC 7.1 has them and VC 6.0 does not.  VC 6.0 has a version number of 1200.
+   If some compiler does not provide them, modify the #if appropriately. */
+#if defined(_MSC_VER)
+#if _MSC_VER &gt; 1200
+#define HAVE_UINTPTR_T 1
+#define HAVE_INTPTR_T 1
+#endif  /* _MSC_VER &gt; 1200  */ 
+#endif  /* _MSC_VER */
+
+#endif
+
+/* Fairly standard from here! */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define to empty if the keyword does not work.  */
+/* #define const  */
+
+/* Define if you have dirent.h.  */
+/* #define DIRENT 1 */
+
+/* Define to the type of elements in the array set by `getgroups'.
+   Usually this is either `int' or `gid_t'.  */
+/* #undef GETGROUPS_T */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef gid_t */
+
+/* Define if your struct tm has tm_zone.  */
+/* #undef HAVE_TM_ZONE */
+
+/* Define if you don't have tm_zone but do have the external array
+   tzname.  */
+#define HAVE_TZNAME
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef mode_t */
+
+/* Define if you don't have dirent.h, but have ndir.h.  */
+/* #undef NDIR */
+
+/* Define to `long' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef off_t */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef pid_t */
+
+/* Define if the system does not provide POSIX.1 features except
+   with this defined.  */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define to `unsigned' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef size_t */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+#if _MSC_VER + 0 &gt;= 1300
+/* VC.NET typedefs socklen_t in ws2tcpip.h. */
+#else
+#define socklen_t int
+#endif
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Define if you don't have dirent.h, but have sys/dir.h.  */
+/* #undef SYSDIR */
+
+/* Define if you don't have dirent.h, but have sys/ndir.h.  */
+/* #undef SYSNDIR */
+
+/* Define if you can safely include both &lt;sys/time.h&gt; and &lt;time.h&gt;.  */
+/* #undef TIME_WITH_SYS_TIME */
+
+/* Define if your &lt;sys/time.h&gt; declares struct tm.  */
+/* #define TM_IN_SYS_TIME 1 */
+
+/* Define to `int' if &lt;sys/types.h&gt; doesn't define.  */
+/* #undef uid_t */
+
+/* Define if the closedir function returns void instead of int.  */
+/* #undef VOID_CLOSEDIR */
+
+/* Define if getpgrp() must be called as getpgrp(0)
+   and (consequently) setpgrp() as setpgrp(0, 0). */
+/* #undef GETPGRP_HAVE_ARGS */
+
+/* Define this if your time.h defines altzone */
+/* #define HAVE_ALTZONE */
+
+/* Define if you have the putenv function.  */
+#define HAVE_PUTENV
+
+/* Define if your compiler supports function prototypes */
+#define HAVE_PROTOTYPES
+
+/* Define if  you can safely include both &lt;sys/select.h&gt; and &lt;sys/time.h&gt;
+   (which you can't on SCO ODT 3.0). */
+/* #undef SYS_SELECT_WITH_SYS_TIME */
+
+/* Define if you want documentation strings in extension modules */
+#define WITH_DOC_STRINGS 1
+
+/* Define if you want to compile in rudimentary thread support */
+/* #undef WITH_THREAD */
+
+/* Define if you want to use the GNU readline library */
+/* #define WITH_READLINE 1 */
+
+/* Define if you want to have a Unicode type. */
+#define Py_USING_UNICODE
+
+/* Define as the integral type used for Unicode representation. */
+#define PY_UNICODE_TYPE unsigned short
+
+/* Define as the size of the unicode type. */
+#define Py_UNICODE_SIZE SIZEOF_SHORT
+
+/* Define if you have a useable wchar_t type defined in wchar.h; useable
+   means wchar_t must be 16-bit unsigned type. (see
+   Include/unicodeobject.h). */
+#if Py_UNICODE_SIZE == 2
+#define HAVE_USABLE_WCHAR_T
+
+/* Define to indicate that the Python Unicode representation can be passed
+   as-is to Win32 Wide API.  */
+#define Py_WIN_WIDE_FILENAMES
+#endif
+
+/* Use Python's own small-block memory-allocator. */
+#define WITH_PYMALLOC 1
+
+/* Define if you have clock.  */
+/* #define HAVE_CLOCK */
+
+/* Define when any dynamic module loading is enabled */
+#define HAVE_DYNAMIC_LOADING
+
+/* Define if you have ftime.  */
+#define HAVE_FTIME
+
+/* Define if you have getpeername.  */
+#define HAVE_GETPEERNAME
+
+/* Define if you have getpgrp.  */
+/* #undef HAVE_GETPGRP */
+
+/* Define if you have getpid.  */
+#define HAVE_GETPID
+
+/* Define if you have gettimeofday.  */
+/* #undef HAVE_GETTIMEOFDAY */
+
+/* Define if you have getwd.  */
+/* #undef HAVE_GETWD */
+
+/* Define if you have lstat.  */
+/* #undef HAVE_LSTAT */
+
+/* Define if you have the mktime function.  */
+#define HAVE_MKTIME
+
+/* Define if you have nice.  */
+/* #undef HAVE_NICE */
+
+/* Define if you have readlink.  */
+/* #undef HAVE_READLINK */
+
+/* Define if you have select.  */
+/* #undef HAVE_SELECT */
+
+/* Define if you have setpgid.  */
+/* #undef HAVE_SETPGID */
+
+/* Define if you have setpgrp.  */
+/* #undef HAVE_SETPGRP */
+
+/* Define if you have setsid.  */
+/* #undef HAVE_SETSID */
+
+/* Define if you have setvbuf.  */
+#define HAVE_SETVBUF
+
+/* Define if you have siginterrupt.  */
+/* #undef HAVE_SIGINTERRUPT */
+
+/* Define if you have symlink.  */
+/* #undef HAVE_SYMLINK */
+
+/* Define if you have tcgetpgrp.  */
+/* #undef HAVE_TCGETPGRP */
+
+/* Define if you have tcsetpgrp.  */
+/* #undef HAVE_TCSETPGRP */
+
+/* Define if you have times.  */
+/* #undef HAVE_TIMES */
+
+/* Define if you have uname.  */
+/* #undef HAVE_UNAME */
+
+/* Define if you have waitpid.  */
+/* #undef HAVE_WAITPID */
+
+/* Define to 1 if you have the `wcscoll' function. */
+#define HAVE_WCSCOLL 1
+
+/* Define if you have the &lt;dlfcn.h&gt; header file.  */
+/* #undef HAVE_DLFCN_H */
+
+/* Define if you have the &lt;fcntl.h&gt; header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the &lt;stdarg.h&gt; prototypes.  */
+#define HAVE_STDARG_PROTOTYPES
+
+/* Define if you have the &lt;stddef.h&gt; header file.  */
+#define HAVE_STDDEF_H 1
+
+/* Define if you have the &lt;sys/audioio.h&gt; header file.  */
+/* #undef HAVE_SYS_AUDIOIO_H */
+
+/* Define if you have the &lt;sys/param.h&gt; header file.  */
+/* #define HAVE_SYS_PARAM_H 1 */
+
+/* Define if you have the &lt;sys/select.h&gt; header file.  */
+/* #define HAVE_SYS_SELECT_H 1 */
+
+/* Define if you have the &lt;sys/time.h&gt; header file.  */
+/* #define HAVE_SYS_TIME_H 1 */
+
+/* Define if you have the &lt;sys/times.h&gt; header file.  */
+/* #define HAVE_SYS_TIMES_H 1 */
+
+/* Define if you have the &lt;sys/un.h&gt; header file.  */
+/* #define HAVE_SYS_UN_H 1 */
+
+/* Define if you have the &lt;sys/utime.h&gt; header file.  */
+/* #define HAVE_SYS_UTIME_H 1 */
+
+/* Define if you have the &lt;sys/utsname.h&gt; header file.  */
+/* #define HAVE_SYS_UTSNAME_H 1 */
+
+/* Define if you have the &lt;thread.h&gt; header file.  */
+/* #undef HAVE_THREAD_H */
+
+/* Define if you have the &lt;unistd.h&gt; header file.  */
+/* #define HAVE_UNISTD_H 1 */
+
+/* Define if you have the &lt;utime.h&gt; header file.  */
+/* #define HAVE_UTIME_H 1 */
+
+/* Define if the compiler provides a wchar.h header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define if you have the dl library (-ldl).  */
+/* #undef HAVE_LIBDL */
+
+/* Define if you have the mpc library (-lmpc).  */
+/* #undef HAVE_LIBMPC */
+
+/* Define if you have the nsl library (-lnsl).  */
+#define HAVE_LIBNSL 1
+
+/* Define if you have the seq library (-lseq).  */
+/* #undef HAVE_LIBSEQ */
+
+/* Define if you have the socket library (-lsocket).  */
+#define HAVE_LIBSOCKET 1
+
+/* Define if you have the sun library (-lsun).  */
+/* #undef HAVE_LIBSUN */
+
+/* Define if you have the termcap library (-ltermcap).  */
+/* #undef HAVE_LIBTERMCAP */
+
+/* Define if you have the termlib library (-ltermlib).  */
+/* #undef HAVE_LIBTERMLIB */
+
+/* Define if you have the thread library (-lthread).  */
+/* #undef HAVE_LIBTHREAD */
+#endif /* !Py_CONFIG_H */

Added: trunk/msvc-libs/include/pydebug.h
===================================================================
--- trunk/msvc-libs/include/pydebug.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pydebug.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,34 @@
+
+#ifndef Py_PYDEBUG_H
+#define Py_PYDEBUG_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(int) Py_DebugFlag;
+PyAPI_DATA(int) Py_VerboseFlag;
+PyAPI_DATA(int) Py_InteractiveFlag;
+PyAPI_DATA(int) Py_OptimizeFlag;
+PyAPI_DATA(int) Py_NoSiteFlag;
+PyAPI_DATA(int) Py_UseClassExceptionsFlag;
+PyAPI_DATA(int) Py_FrozenFlag;
+PyAPI_DATA(int) Py_TabcheckFlag;
+PyAPI_DATA(int) Py_UnicodeFlag;
+PyAPI_DATA(int) Py_IgnoreEnvironmentFlag;
+PyAPI_DATA(int) Py_DivisionWarningFlag;
+/* _XXX Py_QnewFlag should go away in 3.0.  It's true iff -Qnew is passed,
+  on the command line, and is used in 2.2 by ceval.c to make all &quot;/&quot; divisions
+  true divisions (which they will be in 3.0). */
+PyAPI_DATA(int) _Py_QnewFlag;
+
+/* this is a wrapper around getenv() that pays attention to
+   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like
+   PYTHONPATH and PYTHONHOME from the environment */
+#define Py_GETENV(s) (Py_IgnoreEnvironmentFlag ? NULL : getenv(s))
+
+PyAPI_FUNC(void) Py_FatalError(const char *message);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYDEBUG_H */

Added: trunk/msvc-libs/include/pyerrors.h
===================================================================
--- trunk/msvc-libs/include/pyerrors.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pyerrors.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,234 @@
+#ifndef Py_ERRORS_H
+#define Py_ERRORS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Error handling definitions */
+
+PyAPI_FUNC(void) PyErr_SetNone(PyObject *);
+PyAPI_FUNC(void) PyErr_SetObject(PyObject *, PyObject *);
+PyAPI_FUNC(void) PyErr_SetString(PyObject *, const char *);
+PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
+PyAPI_FUNC(void) PyErr_Clear(void);
+PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
+PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
+
+/* Error testing and normalization */
+PyAPI_FUNC(int) PyErr_GivenExceptionMatches(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyErr_ExceptionMatches(PyObject *);
+PyAPI_FUNC(void) PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);
+
+
+/* Predefined exceptions */
+
+PyAPI_DATA(PyObject *) PyExc_Exception;
+PyAPI_DATA(PyObject *) PyExc_StopIteration;
+PyAPI_DATA(PyObject *) PyExc_StandardError;
+PyAPI_DATA(PyObject *) PyExc_ArithmeticError;
+PyAPI_DATA(PyObject *) PyExc_LookupError;
+
+PyAPI_DATA(PyObject *) PyExc_AssertionError;
+PyAPI_DATA(PyObject *) PyExc_AttributeError;
+PyAPI_DATA(PyObject *) PyExc_EOFError;
+PyAPI_DATA(PyObject *) PyExc_FloatingPointError;
+PyAPI_DATA(PyObject *) PyExc_EnvironmentError;
+PyAPI_DATA(PyObject *) PyExc_IOError;
+PyAPI_DATA(PyObject *) PyExc_OSError;
+PyAPI_DATA(PyObject *) PyExc_ImportError;
+PyAPI_DATA(PyObject *) PyExc_IndexError;
+PyAPI_DATA(PyObject *) PyExc_KeyError;
+PyAPI_DATA(PyObject *) PyExc_KeyboardInterrupt;
+PyAPI_DATA(PyObject *) PyExc_MemoryError;
+PyAPI_DATA(PyObject *) PyExc_NameError;
+PyAPI_DATA(PyObject *) PyExc_OverflowError;
+PyAPI_DATA(PyObject *) PyExc_RuntimeError;
+PyAPI_DATA(PyObject *) PyExc_NotImplementedError;
+PyAPI_DATA(PyObject *) PyExc_SyntaxError;
+PyAPI_DATA(PyObject *) PyExc_IndentationError;
+PyAPI_DATA(PyObject *) PyExc_TabError;
+PyAPI_DATA(PyObject *) PyExc_ReferenceError;
+PyAPI_DATA(PyObject *) PyExc_SystemError;
+PyAPI_DATA(PyObject *) PyExc_SystemExit;
+PyAPI_DATA(PyObject *) PyExc_TypeError;
+PyAPI_DATA(PyObject *) PyExc_UnboundLocalError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeEncodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeDecodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeTranslateError;
+PyAPI_DATA(PyObject *) PyExc_ValueError;
+PyAPI_DATA(PyObject *) PyExc_ZeroDivisionError;
+#ifdef MS_WINDOWS
+PyAPI_DATA(PyObject *) PyExc_WindowsError;
+#endif
+#ifdef __VMS
+PyAPI_DATA(PyObject *) PyExc_VMSError;
+#endif
+
+PyAPI_DATA(PyObject *) PyExc_MemoryErrorInst;
+
+/* Predefined warning categories */
+PyAPI_DATA(PyObject *) PyExc_Warning;
+PyAPI_DATA(PyObject *) PyExc_UserWarning;
+PyAPI_DATA(PyObject *) PyExc_DeprecationWarning;
+PyAPI_DATA(PyObject *) PyExc_PendingDeprecationWarning;
+PyAPI_DATA(PyObject *) PyExc_SyntaxWarning;
+/* PyExc_OverflowWarning will go away for Python 2.5 */
+PyAPI_DATA(PyObject *) PyExc_OverflowWarning;
+PyAPI_DATA(PyObject *) PyExc_RuntimeWarning;
+PyAPI_DATA(PyObject *) PyExc_FutureWarning;
+
+
+/* Convenience functions */
+
+PyAPI_FUNC(int) PyErr_BadArgument(void);
+PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
+	PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(PyObject *, char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithUnicodeFilename(
+	PyObject *, Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+
+PyAPI_FUNC(PyObject *) PyErr_Format(PyObject *, const char *, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 2, 3)));
+
+#ifdef MS_WINDOWS
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilenameObject(
+	int, const char *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
+	int, const char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithUnicodeFilename(
+	int, const Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
+	PyObject *,int, PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
+	PyObject *,int, const char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithUnicodeFilename(
+	PyObject *,int, const Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
+#endif /* MS_WINDOWS */
+
+/* Export the old function so that the existing API remains available: */
+PyAPI_FUNC(void) PyErr_BadInternalCall(void);
+PyAPI_FUNC(void) _PyErr_BadInternalCall(char *filename, int lineno);
+/* Mask the old API with a call to the new API for code compiled under
+   Python 2.0: */
+#define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)
+
+/* Function to create a new exception */
+PyAPI_FUNC(PyObject *) PyErr_NewException(char *name, PyObject *base,
+                                         PyObject *dict);
+PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);
+
+/* Issue a warning or exception */
+PyAPI_FUNC(int) PyErr_Warn(PyObject *, char *);
+PyAPI_FUNC(int) PyErr_WarnExplicit(PyObject *, const char *,
+				   const char *, int, 
+				   const char *, PyObject *);
+
+/* In sigcheck.c or signalmodule.c */
+PyAPI_FUNC(int) PyErr_CheckSignals(void);
+PyAPI_FUNC(void) PyErr_SetInterrupt(void);
+
+/* Support for adding program text to SyntaxErrors */
+PyAPI_FUNC(void) PyErr_SyntaxLocation(const char *, int);
+PyAPI_FUNC(PyObject *) PyErr_ProgramText(const char *, int);
+
+#ifdef Py_USING_UNICODE
+/* The following functions are used to create and modify unicode
+   exceptions from C */
+
+/* create a UnicodeDecodeError object */
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
+	const char *, const char *, int, int, int, const char *);
+
+/* create a UnicodeEncodeError object */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_Create(
+	const char *, const Py_UNICODE *, int, int, int, const char *);
+
+/* create a UnicodeTranslateError object */
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_Create(
+	const Py_UNICODE *, int, int, int, const char *);
+
+/* get the encoding attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);
+
+/* get the object attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);
+
+/* get the value of the start attribute (the int * may not be NULL)
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_GetStart(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_GetStart(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_GetStart(PyObject *, int *);
+
+/* assign a new value to the start attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetStart(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetStart(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetStart(PyObject *, int);
+
+/* get the value of the end attribute (the int *may not be NULL)
+ return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_GetEnd(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_GetEnd(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_GetEnd(PyObject *, int *);
+
+/* assign a new value to the end attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetEnd(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetEnd(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, int);
+
+/* get the value of the reason attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);
+
+/* assign a new value to the reason attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetReason(
+	PyObject *, const char *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetReason(
+	PyObject *, const char *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetReason(
+	PyObject *, const char *);
+#endif
+
+
+/* These APIs aren't really part of the error implementation, but
+   often needed to format error messages; the native C lib APIs are
+   not available on all platforms, which is why we provide emulations
+   for those platforms in Python/mysnprintf.c,
+   WARNING:  The return value of snprintf varies across platforms; do
+   not rely on any particular behavior; eventually the C99 defn may
+   be reliable.
+*/
+#if defined(MS_WIN32) &amp;&amp; !defined(HAVE_SNPRINTF)
+# define HAVE_SNPRINTF
+# define snprintf _snprintf
+# define vsnprintf _vsnprintf
+#endif
+
+#include &lt;stdarg.h&gt;
+PyAPI_FUNC(int) PyOS_snprintf(char *str, size_t size, const char  *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 3, 4)));
+PyAPI_FUNC(int) PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)
+			Py_GCC_ATTRIBUTE((format(printf, 3, 0)));
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ERRORS_H */

Added: trunk/msvc-libs/include/pyfpe.h
===================================================================
--- trunk/msvc-libs/include/pyfpe.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pyfpe.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,176 @@
+#ifndef Py_PYFPE_H
+#define Py_PYFPE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+/*
+     ---------------------------------------------------------------------  
+    /                       Copyright (c) 1996.                           \ 
+   |          The Regents of the University of California.                 |
+   |                        All rights reserved.                           |
+   |                                                                       |
+   |   Permission to use, copy, modify, and distribute this software for   |
+   |   any purpose without fee is hereby granted, provided that this en-   |
+   |   tire notice is included in all copies of any software which is or   |
+   |   includes  a  copy  or  modification  of  this software and in all   |
+   |   copies of the supporting documentation for such software.           |
+   |                                                                       |
+   |   This  work was produced at the University of California, Lawrence   |
+   |   Livermore National Laboratory under  contract  no.  W-7405-ENG-48   |
+   |   between  the  U.S.  Department  of  Energy and The Regents of the   |
+   |   University of California for the operation of UC LLNL.              |
+   |                                                                       |
+   |                              DISCLAIMER                               |
+   |                                                                       |
+   |   This  software was prepared as an account of work sponsored by an   |
+   |   agency of the United States Government. Neither the United States   |
+   |   Government  nor the University of California nor any of their em-   |
+   |   ployees, makes any warranty, express or implied, or  assumes  any   |
+   |   liability  or  responsibility  for the accuracy, completeness, or   |
+   |   usefulness of any information,  apparatus,  product,  or  process   |
+   |   disclosed,   or  represents  that  its  use  would  not  infringe   |
+   |   privately-owned rights. Reference herein to any specific  commer-   |
+   |   cial  products,  process,  or  service  by trade name, trademark,   |
+   |   manufacturer, or otherwise, does not  necessarily  constitute  or   |
+   |   imply  its endorsement, recommendation, or favoring by the United   |
+   |   States Government or the University of California. The views  and   |
+   |   opinions  of authors expressed herein do not necessarily state or   |
+   |   reflect those of the United States Government or  the  University   |
+   |   of  California,  and shall not be used for advertising or product   |
+    \  endorsement purposes.                                              / 
+     ---------------------------------------------------------------------  
+*/
+
+/*
+ *       Define macros for handling SIGFPE.
+ *       Lee Busby, LLNL, November, 1996
+ *       <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">busby1 at llnl.gov</A>
+ * 
+ *********************************************
+ * Overview of the system for handling SIGFPE:
+ * 
+ * This file (Include/pyfpe.h) defines a couple of &quot;wrapper&quot; macros for
+ * insertion into your Python C code of choice. Their proper use is
+ * discussed below. The file Python/pyfpe.c defines a pair of global
+ * variables PyFPE_jbuf and PyFPE_counter which are used by the signal
+ * handler for SIGFPE to decide if a particular exception was protected
+ * by the macros. The signal handler itself, and code for enabling the
+ * generation of SIGFPE in the first place, is in a (new) Python module
+ * named fpectl. This module is standard in every respect. It can be loaded
+ * either statically or dynamically as you choose, and like any other
+ * Python module, has no effect until you import it.
+ * 
+ * In the general case, there are three steps toward handling SIGFPE in any
+ * Python code:
+ * 
+ * 1) Add the *_PROTECT macros to your C code as required to protect
+ *    dangerous floating point sections.
+ * 
+ * 2) Turn on the inclusion of the code by adding the ``--with-fpectl''
+ *    flag at the time you run configure.  If the fpectl or other modules
+ *    which use the *_PROTECT macros are to be dynamically loaded, be
+ *    sure they are compiled with WANT_SIGFPE_HANDLER defined.
+ * 
+ * 3) When python is built and running, import fpectl, and execute
+ *    fpectl.turnon_sigfpe(). This sets up the signal handler and enables
+ *    generation of SIGFPE whenever an exception occurs. From this point
+ *    on, any properly trapped SIGFPE should result in the Python
+ *    FloatingPointError exception.
+ * 
+ * Step 1 has been done already for the Python kernel code, and should be
+ * done soon for the NumPy array package.  Step 2 is usually done once at
+ * python install time. Python's behavior with respect to SIGFPE is not
+ * changed unless you also do step 3. Thus you can control this new
+ * facility at compile time, or run time, or both.
+ * 
+ ******************************** 
+ * Using the macros in your code:
+ * 
+ * static PyObject *foobar(PyObject *self,PyObject *args)
+ * {
+ *     ....
+ *     PyFPE_START_PROTECT(&quot;Error in foobar&quot;, return 0)
+ *     result = dangerous_op(somearg1, somearg2, ...);
+ *     PyFPE_END_PROTECT(result)
+ *     ....
+ * }
+ * 
+ * If a floating point error occurs in dangerous_op, foobar returns 0 (NULL),
+ * after setting the associated value of the FloatingPointError exception to
+ * &quot;Error in foobar&quot;. ``Dangerous_op'' can be a single operation, or a block
+ * of code, function calls, or any combination, so long as no alternate
+ * return is possible before the PyFPE_END_PROTECT macro is reached.
+ * 
+ * The macros can only be used in a function context where an error return
+ * can be recognized as signaling a Python exception. (Generally, most
+ * functions that return a PyObject * will qualify.)
+ * 
+ * Guido's original design suggestion for PyFPE_START_PROTECT and
+ * PyFPE_END_PROTECT had them open and close a local block, with a locally
+ * defined jmp_buf and jmp_buf pointer. This would allow recursive nesting
+ * of the macros. The Ansi C standard makes it clear that such local
+ * variables need to be declared with the &quot;volatile&quot; type qualifier to keep
+ * setjmp from corrupting their values. Some current implementations seem
+ * to be more restrictive. For example, the HPUX man page for setjmp says
+ * 
+ *   Upon the return from a setjmp() call caused by a longjmp(), the
+ *   values of any non-static local variables belonging to the routine
+ *   from which setjmp() was called are undefined. Code which depends on
+ *   such values is not guaranteed to be portable.
+ * 
+ * I therefore decided on a more limited form of nesting, using a counter
+ * variable (PyFPE_counter) to keep track of any recursion.  If an exception
+ * occurs in an ``inner'' pair of macros, the return will apparently
+ * come from the outermost level.
+ * 
+ */
+
+#ifdef WANT_SIGFPE_HANDLER
+#include &lt;signal.h&gt;
+#include &lt;setjmp.h&gt;
+#include &lt;math.h&gt;
+extern jmp_buf PyFPE_jbuf;
+extern int PyFPE_counter;
+extern double PyFPE_dummy(void *);
+
+#define PyFPE_START_PROTECT(err_string, leave_stmt) \
+if (!PyFPE_counter++ &amp;&amp; setjmp(PyFPE_jbuf)) { \
+	PyErr_SetString(PyExc_FloatingPointError, err_string); \
+	PyFPE_counter = 0; \
+	leave_stmt; \
+}
+
+/*
+ * This (following) is a heck of a way to decrement a counter. However,
+ * unless the macro argument is provided, code optimizers will sometimes move
+ * this statement so that it gets executed *before* the unsafe expression
+ * which we're trying to protect.  That pretty well messes things up,
+ * of course.
+ * 
+ * If the expression(s) you're trying to protect don't happen to return a
+ * value, you will need to manufacture a dummy result just to preserve the
+ * correct ordering of statements.  Note that the macro passes the address
+ * of its argument (so you need to give it something which is addressable).
+ * If your expression returns multiple results, pass the last such result
+ * to PyFPE_END_PROTECT.
+ * 
+ * Note that PyFPE_dummy returns a double, which is cast to int.
+ * This seeming insanity is to tickle the Floating Point Unit (FPU).
+ * If an exception has occurred in a preceding floating point operation,
+ * some architectures (notably Intel 80x86) will not deliver the interrupt
+ * until the *next* floating point operation.  This is painful if you've
+ * already decremented PyFPE_counter.
+ */
+#define PyFPE_END_PROTECT(v) PyFPE_counter -= (int)PyFPE_dummy(&amp;(v));
+
+#else
+
+#define PyFPE_START_PROTECT(err_string, leave_stmt)
+#define PyFPE_END_PROTECT(v)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYFPE_H */

Added: trunk/msvc-libs/include/pygetopt.h
===================================================================
--- trunk/msvc-libs/include/pygetopt.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pygetopt.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,17 @@
+
+#ifndef Py_PYGETOPT_H
+#define Py_PYGETOPT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_DATA(int) _PyOS_opterr;
+PyAPI_DATA(int) _PyOS_optind;
+PyAPI_DATA(char *) _PyOS_optarg;
+
+PyAPI_FUNC(int) _PyOS_GetOpt(int argc, char **argv, char *optstring);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYGETOPT_H */

Added: trunk/msvc-libs/include/pymactoolbox.h
===================================================================
--- trunk/msvc-libs/include/pymactoolbox.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pymactoolbox.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,189 @@
+/*
+** pymactoolbox.h - globals defined in mactoolboxglue.c
+*/
+#ifndef Py_PYMACTOOLBOX_H
+#define Py_PYMACTOOLBOX_H
+#ifdef __cplusplus
+	extern &quot;C&quot; {
+#endif
+
+#include &lt;Carbon/Carbon.h&gt;
+#include &lt;QuickTime/QuickTime.h&gt;
+
+/*
+** Helper routines for error codes and such.
+*/
+char *PyMac_StrError(int);			/* strerror with mac errors */
+extern PyObject *PyMac_OSErrException;		/* Exception for OSErr */
+PyObject *PyMac_GetOSErrException(void);	/* Initialize &amp; return it */
+PyObject *PyErr_Mac(PyObject *, int);		/* Exception with a mac error */
+PyObject *PyMac_Error(OSErr);			/* Uses PyMac_GetOSErrException */
+extern OSErr PyMac_GetFullPathname(FSSpec *, char *, int); /* convert
+							      fsspec-&gt;path */
+/*
+** These conversion routines are defined in mactoolboxglue.c itself.
+*/
+int PyMac_GetOSType(PyObject *, OSType *);	/* argument parser for OSType */
+PyObject *PyMac_BuildOSType(OSType);		/* Convert OSType to PyObject */
+
+PyObject *PyMac_BuildNumVersion(NumVersion);/* Convert NumVersion to PyObject */
+
+int PyMac_GetStr255(PyObject *, Str255);	/* argument parser for Str255 */
+PyObject *PyMac_BuildStr255(Str255);		/* Convert Str255 to PyObject */
+PyObject *PyMac_BuildOptStr255(Str255);		/* Convert Str255 to PyObject,
+						   NULL to None */
+
+int PyMac_GetRect(PyObject *, Rect *);		/* argument parser for Rect */
+PyObject *PyMac_BuildRect(Rect *);		/* Convert Rect to PyObject */
+
+int PyMac_GetPoint(PyObject *, Point *);	/* argument parser for Point */
+PyObject *PyMac_BuildPoint(Point);		/* Convert Point to PyObject */
+
+int PyMac_GetEventRecord(PyObject *, EventRecord *); /* argument parser for
+							EventRecord */
+PyObject *PyMac_BuildEventRecord(EventRecord *); /* Convert EventRecord to
+						    PyObject */
+
+int PyMac_GetFixed(PyObject *, Fixed *);	/* argument parser for Fixed */
+PyObject *PyMac_BuildFixed(Fixed);		/* Convert Fixed to PyObject */
+int PyMac_Getwide(PyObject *, wide *);		/* argument parser for wide */
+PyObject *PyMac_Buildwide(wide *);		/* Convert wide to PyObject */
+
+/*
+** The rest of the routines are implemented by extension modules. If they are
+** dynamically loaded mactoolboxglue will contain a stub implementation of the
+** routine, which imports the module, whereupon the module's init routine will
+** communicate the routine pointer back to the stub.
+** If USE_TOOLBOX_OBJECT_GLUE is not defined there is no glue code, and the
+** extension modules simply declare the routine. This is the case for static
+** builds (and could be the case for MacPython CFM builds, because CFM extension
+** modules can reference each other without problems).
+*/
+
+#ifdef USE_TOOLBOX_OBJECT_GLUE
+/*
+** These macros are used in the module init code. If we use toolbox object glue
+** it sets the function pointer to point to the real function.
+*/
+#define PyMac_INIT_TOOLBOX_OBJECT_NEW(object, rtn) { \
+	extern PyObject *(*PyMacGluePtr_##rtn)(object); \
+	PyMacGluePtr_##rtn = _##rtn; \
+}
+#define PyMac_INIT_TOOLBOX_OBJECT_CONVERT(object, rtn) { \
+	extern int (*PyMacGluePtr_##rtn)(PyObject *, object *); \
+	PyMacGluePtr_##rtn = _##rtn; \
+}
+#else
+/*
+** If we don't use toolbox object glue the init macros are empty. Moreover, we define
+** _xxx_New to be the same as xxx_New, and the code in mactoolboxglue isn't included.
+*/
+#define PyMac_INIT_TOOLBOX_OBJECT_NEW(object, rtn)
+#define PyMac_INIT_TOOLBOX_OBJECT_CONVERT(object, rtn)
+#endif /* USE_TOOLBOX_OBJECT_GLUE */
+
+/* macfs exports */
+int PyMac_GetFSSpec(PyObject *, FSSpec *);	/* argument parser for FSSpec */
+PyObject *PyMac_BuildFSSpec(FSSpec *);		/* Convert FSSpec to PyObject */
+
+int PyMac_GetFSRef(PyObject *, FSRef *);	/* argument parser for FSRef */
+PyObject *PyMac_BuildFSRef(FSRef *);		/* Convert FSRef to PyObject */
+
+/* AE exports */
+extern PyObject *AEDesc_New(AppleEvent *); /* XXXX Why passed by address?? */
+extern PyObject *AEDesc_NewBorrowed(AppleEvent *);
+extern int AEDesc_Convert(PyObject *, AppleEvent *);
+
+/* Cm exports */
+extern PyObject *CmpObj_New(Component);
+extern int CmpObj_Convert(PyObject *, Component *);
+extern PyObject *CmpInstObj_New(ComponentInstance);
+extern int CmpInstObj_Convert(PyObject *, ComponentInstance *);
+
+/* Ctl exports */
+extern PyObject *CtlObj_New(ControlHandle);
+extern int CtlObj_Convert(PyObject *, ControlHandle *);
+
+/* Dlg exports */
+extern PyObject *DlgObj_New(DialogPtr);
+extern int DlgObj_Convert(PyObject *, DialogPtr *);
+extern PyObject *DlgObj_WhichDialog(DialogPtr);
+
+/* Drag exports */
+extern PyObject *DragObj_New(DragReference);
+extern int DragObj_Convert(PyObject *, DragReference *);
+
+/* List exports */
+extern PyObject *ListObj_New(ListHandle);
+extern int ListObj_Convert(PyObject *, ListHandle *);
+
+/* Menu exports */
+extern PyObject *MenuObj_New(MenuHandle);
+extern int MenuObj_Convert(PyObject *, MenuHandle *);
+
+/* Qd exports */
+extern PyObject *GrafObj_New(GrafPtr);
+extern int GrafObj_Convert(PyObject *, GrafPtr *);
+extern PyObject *BMObj_New(BitMapPtr);
+extern int BMObj_Convert(PyObject *, BitMapPtr *);
+extern PyObject *QdRGB_New(RGBColor *);
+extern int QdRGB_Convert(PyObject *, RGBColor *);
+
+/* Qdoffs exports */
+extern PyObject *GWorldObj_New(GWorldPtr);
+extern int GWorldObj_Convert(PyObject *, GWorldPtr *);
+
+/* Qt exports */
+extern PyObject *TrackObj_New(Track);
+extern int TrackObj_Convert(PyObject *, Track *);
+extern PyObject *MovieObj_New(Movie);
+extern int MovieObj_Convert(PyObject *, Movie *);
+extern PyObject *MovieCtlObj_New(MovieController);
+extern int MovieCtlObj_Convert(PyObject *, MovieController *);
+extern PyObject *TimeBaseObj_New(TimeBase);
+extern int TimeBaseObj_Convert(PyObject *, TimeBase *);
+extern PyObject *UserDataObj_New(UserData);
+extern int UserDataObj_Convert(PyObject *, UserData *);
+extern PyObject *MediaObj_New(Media);
+extern int MediaObj_Convert(PyObject *, Media *);
+
+/* Res exports */
+extern PyObject *ResObj_New(Handle);
+extern int ResObj_Convert(PyObject *, Handle *);
+extern PyObject *OptResObj_New(Handle);
+extern int OptResObj_Convert(PyObject *, Handle *);
+
+/* TE exports */
+extern PyObject *TEObj_New(TEHandle);
+extern int TEObj_Convert(PyObject *, TEHandle *);
+
+/* Win exports */
+extern PyObject *WinObj_New(WindowPtr);
+extern int WinObj_Convert(PyObject *, WindowPtr *);
+extern PyObject *WinObj_WhichWindow(WindowPtr);
+
+/* CF exports */
+extern PyObject *CFObj_New(CFTypeRef);
+extern int CFObj_Convert(PyObject *, CFTypeRef *);
+extern PyObject *CFTypeRefObj_New(CFTypeRef);
+extern int CFTypeRefObj_Convert(PyObject *, CFTypeRef *);
+extern PyObject *CFStringRefObj_New(CFStringRef);
+extern int CFStringRefObj_Convert(PyObject *, CFStringRef *);
+extern PyObject *CFMutableStringRefObj_New(CFMutableStringRef);
+extern int CFMutableStringRefObj_Convert(PyObject *, CFMutableStringRef *);
+extern PyObject *CFArrayRefObj_New(CFArrayRef);
+extern int CFArrayRefObj_Convert(PyObject *, CFArrayRef *);
+extern PyObject *CFMutableArrayRefObj_New(CFMutableArrayRef);
+extern int CFMutableArrayRefObj_Convert(PyObject *, CFMutableArrayRef *);
+extern PyObject *CFDictionaryRefObj_New(CFDictionaryRef);
+extern int CFDictionaryRefObj_Convert(PyObject *, CFDictionaryRef *);
+extern PyObject *CFMutableDictionaryRefObj_New(CFMutableDictionaryRef);
+extern int CFMutableDictionaryRefObj_Convert(PyObject *, CFMutableDictionaryRef *);
+extern PyObject *CFURLRefObj_New(CFURLRef);
+extern int CFURLRefObj_Convert(PyObject *, CFURLRef *);
+extern int OptionalCFURLRefObj_Convert(PyObject *, CFURLRef *);
+
+#ifdef __cplusplus
+	}
+#endif
+#endif

Added: trunk/msvc-libs/include/pymem.h
===================================================================
--- trunk/msvc-libs/include/pymem.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pymem.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,108 @@
+/* The PyMem_ family:  low-level memory allocation interfaces.
+   See objimpl.h for the PyObject_ memory family.
+*/
+
+#ifndef Py_PYMEM_H
+#define Py_PYMEM_H
+
+#include &quot;pyport.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* BEWARE:
+
+   Each interface exports both functions and macros.  Extension modules should
+   use the functions, to ensure binary compatibility across Python versions.
+   Because the Python implementation is free to change internal details, and
+   the macros may (or may not) expose details for speed, if you do use the
+   macros you must recompile your extensions with each Python release.
+
+   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
+   calloc/free.  For example, on Windows different DLLs may end up using
+   different heaps, and if you use PyMem_Malloc you'll get the memory from the
+   heap used by the Python DLL; it could be a disaster if you free()'ed that
+   directly in your own extension.  Using PyMem_Free instead ensures Python
+   can return the memory to the proper heap.  As another example, in
+   PYMALLOC_DEBUG mode, Python wraps all calls to all PyMem_ and PyObject_
+   memory functions in special debugging wrappers that add additional
+   debugging info to dynamic memory blocks.  The system routines have no idea
+   what to do with that stuff, and the Python wrappers have no idea what to do
+   with raw blocks obtained directly by the system routines then.
+*/
+
+/*
+ * Raw memory interface
+ * ====================
+ */
+
+/* Functions
+
+   Functions supplying platform-independent semantics for malloc/realloc/
+   free.  These functions make sure that allocating 0 bytes returns a distinct
+   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
+   may be returned), even if the platform malloc and realloc don't.
+   Returned pointers must be checked for NULL explicitly.  No action is
+   performed on failure (no exception is set, no warning is printed, etc).
+*/
+
+PyAPI_FUNC(void *) PyMem_Malloc(size_t);
+PyAPI_FUNC(void *) PyMem_Realloc(void *, size_t);
+PyAPI_FUNC(void) PyMem_Free(void *);
+
+/* Starting from Python 1.6, the wrappers Py_{Malloc,Realloc,Free} are
+   no longer supported. They used to call PyErr_NoMemory() on failure. */
+
+/* Macros. */
+#ifdef PYMALLOC_DEBUG
+/* Redirect all memory operations to Python's debugging allocator. */
+#define PyMem_MALLOC		PyObject_MALLOC
+#define PyMem_REALLOC		PyObject_REALLOC
+
+#else	/* ! PYMALLOC_DEBUG */
+
+/* PyMem_MALLOC(0) means malloc(1). Some systems would return NULL
+   for malloc(0), which would be treated as an error. Some platforms
+   would return a pointer with no memory behind it, which would break
+   pymalloc. To solve these problems, allocate an extra byte. */
+#define PyMem_MALLOC(n)         malloc((n) ? (n) : 1)
+#define PyMem_REALLOC(p, n)     realloc((p), (n) ? (n) : 1)
+
+#endif	/* PYMALLOC_DEBUG */
+
+/* In order to avoid breaking old code mixing PyObject_{New, NEW} with
+   PyMem_{Del, DEL} and PyMem_{Free, FREE}, the PyMem &quot;release memory&quot;
+   functions have to be redirected to the object deallocator. */
+#define PyMem_FREE           	PyObject_FREE
+
+/*
+ * Type-oriented memory interface
+ * ==============================
+ *
+ * These are carried along for historical reasons.  There's rarely a good
+ * reason to use them anymore (you can just as easily do the multiply and
+ * cast yourself).
+ */
+
+#define PyMem_New(type, n) \
+	( (type *) PyMem_Malloc((n) * sizeof(type)) )
+#define PyMem_NEW(type, n) \
+	( (type *) PyMem_MALLOC((n) * sizeof(type)) )
+
+#define PyMem_Resize(p, type, n) \
+	( (p) = (type *) PyMem_Realloc((p), (n) * sizeof(type)) )
+#define PyMem_RESIZE(p, type, n) \
+	( (p) = (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )
+
+/* In order to avoid breaking old code mixing PyObject_{New, NEW} with
+   PyMem_{Del, DEL} and PyMem_{Free, FREE}, the PyMem &quot;release memory&quot;
+   functions have to be redirected to the object deallocator. */
+#define PyMem_Del		PyObject_Free
+#define PyMem_DEL		PyObject_FREE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_PYMEM_H */

Added: trunk/msvc-libs/include/pyport.h
===================================================================
--- trunk/msvc-libs/include/pyport.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pyport.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,637 @@
+#ifndef Py_PYPORT_H
+#define Py_PYPORT_H
+
+#include &quot;pyconfig.h&quot; /* include for defines */
+
+/**************************************************************************
+Symbols and macros to supply platform-independent interfaces to basic
+C language &amp; library operations whose spellings vary across platforms.
+
+Please try to make documentation here as clear as possible:  by definition,
+the stuff here is trying to illuminate C's darkest corners.
+
+Config #defines referenced here:
+
+SIGNED_RIGHT_SHIFT_ZERO_FILLS
+Meaning:  To be defined iff i&gt;&gt;j does not extend the sign bit when i is a
+          signed integral type and i &lt; 0.
+Used in:  Py_ARITHMETIC_RIGHT_SHIFT
+
+Py_DEBUG
+Meaning:  Extra checks compiled in for debug mode.
+Used in:  Py_SAFE_DOWNCAST
+
+HAVE_UINTPTR_T
+Meaning:  The C9X type uintptr_t is supported by the compiler
+Used in:  Py_uintptr_t
+
+HAVE_LONG_LONG
+Meaning:  The compiler supports the C type &quot;long long&quot;
+Used in:  PY_LONG_LONG
+
+**************************************************************************/
+
+
+/* For backward compatibility only. Obsolete, do not use. */
+#ifdef HAVE_PROTOTYPES
+#define Py_PROTO(x) x
+#else
+#define Py_PROTO(x) ()
+#endif
+#ifndef Py_FPROTO
+#define Py_FPROTO(x) Py_PROTO(x)
+#endif
+
+/* typedefs for some C9X-defined synonyms for integral types.
+ *
+ * The names in Python are exactly the same as the C9X names, except with a
+ * Py_ prefix.  Until C9X is universally implemented, this is the only way
+ * to ensure that Python gets reliable names that don't conflict with names
+ * in non-Python code that are playing their own tricks to define the C9X
+ * names.
+ *
+ * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
+ * integral synonyms.  Only define the ones we actually need.
+ */
+
+#ifdef HAVE_LONG_LONG
+#ifndef PY_LONG_LONG
+#define PY_LONG_LONG long long
+#endif
+#endif /* HAVE_LONG_LONG */
+
+/* uintptr_t is the C9X name for an unsigned integral type such that a
+ * legitimate void* can be cast to uintptr_t and then back to void* again
+ * without loss of information.  Similarly for intptr_t, wrt a signed
+ * integral type.
+ */
+#ifdef HAVE_UINTPTR_T
+typedef uintptr_t	Py_uintptr_t;
+typedef intptr_t	Py_intptr_t;
+
+#elif SIZEOF_VOID_P &lt;= SIZEOF_INT
+typedef unsigned int	Py_uintptr_t;
+typedef int		Py_intptr_t;
+
+#elif SIZEOF_VOID_P &lt;= SIZEOF_LONG
+typedef unsigned long	Py_uintptr_t;
+typedef long		Py_intptr_t;
+
+#elif defined(HAVE_LONG_LONG) &amp;&amp; (SIZEOF_VOID_P &lt;= SIZEOF_LONG_LONG)
+typedef unsigned PY_LONG_LONG	Py_uintptr_t;
+typedef PY_LONG_LONG		Py_intptr_t;
+
+#else
+#   error &quot;Python needs a typedef for Py_uintptr_t in pyport.h.&quot;
+#endif /* HAVE_UINTPTR_T */
+
+#include &lt;stdlib.h&gt;
+
+#include &lt;math.h&gt; /* Moved here from the math section, before extern &quot;C&quot; */
+
+/********************************************
+ * WRAPPER FOR &lt;time.h&gt; and/or &lt;sys/time.h&gt; *
+ ********************************************/
+
+#ifdef TIME_WITH_SYS_TIME
+#include &lt;sys/time.h&gt;
+#include &lt;time.h&gt;
+#else /* !TIME_WITH_SYS_TIME */
+#ifdef HAVE_SYS_TIME_H
+#include &lt;sys/time.h&gt;
+#else /* !HAVE_SYS_TIME_H */
+#include &lt;time.h&gt;
+#endif /* !HAVE_SYS_TIME_H */
+#endif /* !TIME_WITH_SYS_TIME */
+
+
+/******************************
+ * WRAPPER FOR &lt;sys/select.h&gt; *
+ ******************************/
+
+/* NB caller must include &lt;sys/types.h&gt; */
+
+#ifdef HAVE_SYS_SELECT_H
+
+#include &lt;sys/select.h&gt;
+
+#endif /* !HAVE_SYS_SELECT_H */
+
+/*******************************
+ * stat() and fstat() fiddling *
+ *******************************/
+
+/* We expect that stat and fstat exist on most systems.
+ *  It's confirmed on Unix, Mac and Windows.
+ *  If you don't have them, add
+ *      #define DONT_HAVE_STAT
+ * and/or
+ *      #define DONT_HAVE_FSTAT
+ * to your pyconfig.h. Python code beyond this should check HAVE_STAT and
+ * HAVE_FSTAT instead.
+ * Also
+ *      #define DONT_HAVE_SYS_STAT_H
+ * if &lt;sys/stat.h&gt; doesn't exist on your platform, and
+ *      #define HAVE_STAT_H
+ * if &lt;stat.h&gt; does (don't look at me -- ths mess is inherited).
+ */
+#ifndef DONT_HAVE_STAT
+#define HAVE_STAT
+#endif
+
+#ifndef DONT_HAVE_FSTAT
+#define HAVE_FSTAT
+#endif
+
+#ifdef RISCOS
+#include &lt;sys/types.h&gt;
+#include &quot;unixstuff.h&quot;
+#endif
+
+#ifndef DONT_HAVE_SYS_STAT_H
+#if defined(PYOS_OS2) &amp;&amp; defined(PYCC_GCC)
+#include &lt;sys/types.h&gt;
+#endif
+#include &lt;sys/stat.h&gt;
+#elif defined(HAVE_STAT_H)
+#include &lt;stat.h&gt;
+#endif
+
+#if defined(PYCC_VACPP)
+/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */
+#define S_IFMT (S_IFDIR|S_IFCHR|S_IFREG)
+#endif
+
+#ifndef S_ISREG
+#define S_ISREG(x) (((x) &amp; S_IFMT) == S_IFREG)
+#endif
+
+#ifndef S_ISDIR
+#define S_ISDIR(x) (((x) &amp; S_IFMT) == S_IFDIR)
+#endif
+
+
+#ifdef __cplusplus
+/* Move this down here since some C++ #include's don't like to be included
+   inside an extern &quot;C&quot; */
+extern &quot;C&quot; {
+#endif
+
+
+/* Py_ARITHMETIC_RIGHT_SHIFT
+ * C doesn't define whether a right-shift of a signed integer sign-extends
+ * or zero-fills.  Here a macro to force sign extension:
+ * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
+ *    Return I &gt;&gt; J, forcing sign extension.
+ * Requirements:
+ *    I is of basic signed type TYPE (char, short, int, long, or long long).
+ *    TYPE is one of char, short, int, long, or long long, although long long
+ *    must not be used except on platforms that support it.
+ *    J is an integer &gt;= 0 and strictly less than the number of bits in TYPE
+ *    (because C doesn't define what happens for J outside that range either).
+ * Caution:
+ *    I may be evaluated more than once.
+ */
+#ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS
+#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) \
+	((I) &lt; 0 ? ~((~(unsigned TYPE)(I)) &gt;&gt; (J)) : (I) &gt;&gt; (J))
+#else
+#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) &gt;&gt; (J))
+#endif
+
+/* Py_FORCE_EXPANSION(X)
+ * &quot;Simply&quot; returns its argument.  However, macro expansions within the
+ * argument are evaluated.  This unfortunate trickery is needed to get
+ * token-pasting to work as desired in some cases.
+ */
+#define Py_FORCE_EXPANSION(X) X
+
+/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
+ * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
+ * assert-fails if any information is lost.
+ * Caution:
+ *    VALUE may be evaluated more than once.
+ */
+#ifdef Py_DEBUG
+#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) \
+	(assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))
+#else
+#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)
+#endif
+
+/* Py_IS_NAN(X)
+ * Return 1 if float or double arg is a NaN, else 0.
+ * Caution:
+ *     X is evaluated more than once.
+ *     This may not work on all platforms.  Each platform has *some*
+ *     way to spell this, though -- override in pyconfig.h if you have
+ *     a platform where it doesn't work.
+ */
+#ifndef Py_IS_NAN
+#define Py_IS_NAN(X) ((X) != (X))
+#endif
+
+/* Py_IS_INFINITY(X)
+ * Return 1 if float or double arg is an infinity, else 0.
+ * Caution:
+ *    X is evaluated more than once.
+ *    This implementation may set the underflow flag if |X| is very small;
+ *    it really can't be implemented correctly (&amp; easily) before C99.
+ *    Override in pyconfig.h if you have a better spelling on your platform.
+ */
+#ifndef Py_IS_INFINITY
+#define Py_IS_INFINITY(X) ((X) &amp;&amp; (X)*0.5 == (X))
+#endif
+
+/* HUGE_VAL is supposed to expand to a positive double infinity.  Python
+ * uses Py_HUGE_VAL instead because some platforms are broken in this
+ * respect.  We used to embed code in pyport.h to try to worm around that,
+ * but different platforms are broken in conflicting ways.  If you're on
+ * a platform where HUGE_VAL is defined incorrectly, fiddle your Python
+ * config to #define Py_HUGE_VAL to something that works on your platform.
+ */
+#ifndef Py_HUGE_VAL
+#define Py_HUGE_VAL HUGE_VAL
+#endif
+
+/* Py_OVERFLOWED(X)
+ * Return 1 iff a libm function overflowed.  Set errno to 0 before calling
+ * a libm function, and invoke this macro after, passing the function
+ * result.
+ * Caution:
+ *    This isn't reliable.  C99 no longer requires libm to set errno under
+ *	  any exceptional condition, but does require +- HUGE_VAL return
+ *	  values on overflow.  A 754 box *probably* maps HUGE_VAL to a
+ *	  double infinity, and we're cool if that's so, unless the input
+ *	  was an infinity and an infinity is the expected result.  A C89
+ *	  system sets errno to ERANGE, so we check for that too.  We're
+ *	  out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or
+ *	  if the returned result is a NaN, or if a C89 box returns HUGE_VAL
+ *	  in non-overflow cases.
+ *    X is evaluated more than once.
+ * Some platforms have better way to spell this, so expect some #ifdef'ery.
+ *
+ * OpenBSD uses 'isinf()' because a compiler bug on that platform causes
+ * the longer macro version to be mis-compiled. This isn't optimal, and
+ * should be removed once a newer compiler is available on that platform.
+ * The system that had the failure was running OpenBSD 3.2 on Intel, with
+ * gcc 2.95.3.
+ *
+ * According to Tim's checkin, the FreeBSD systems use isinf() to work
+ * around a FPE bug on that platform.
+ */
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#define Py_OVERFLOWED(X) isinf(X)
+#else
+#define Py_OVERFLOWED(X) ((X) != 0.0 &amp;&amp; (errno == ERANGE ||    \
+					 (X) == Py_HUGE_VAL || \
+					 (X) == -Py_HUGE_VAL))
+#endif
+
+/* Py_SET_ERRNO_ON_MATH_ERROR(x)
+ * If a libm function did not set errno, but it looks like the result
+ * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
+ * to 0 before calling a libm function, and invoke this macro after,
+ * passing the function result.
+ * Caution:
+ *    This isn't reliable.  See Py_OVERFLOWED comments.
+ *    X is evaluated more than once.
+ */
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#define _Py_SET_EDOM_FOR_NAN(X) if (isnan(X)) errno = EDOM;
+#else
+#define _Py_SET_EDOM_FOR_NAN(X) ;
+#endif
+#define Py_SET_ERRNO_ON_MATH_ERROR(X) \
+	do { \
+		if (errno == 0) { \
+			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL) \
+				errno = ERANGE; \
+			else _Py_SET_EDOM_FOR_NAN(X) \
+		} \
+	} while(0)
+
+/* Py_SET_ERANGE_ON_OVERFLOW(x)
+ * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
+ */
+#define Py_SET_ERANGE_IF_OVERFLOW(X) Py_SET_ERRNO_ON_MATH_ERROR(X)
+
+/* Py_ADJUST_ERANGE1(x)
+ * Py_ADJUST_ERANGE2(x, y)
+ * Set errno to 0 before calling a libm function, and invoke one of these
+ * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
+ * for functions returning complex results).  This makes two kinds of
+ * adjustments to errno:  (A) If it looks like the platform libm set
+ * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
+ * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
+ * effect, we're trying to force a useful implementation of C89 errno
+ * behavior.
+ * Caution:
+ *    This isn't reliable.  See Py_OVERFLOWED comments.
+ *    X and Y may be evaluated more than once.
+ */
+#define Py_ADJUST_ERANGE1(X)						\
+	do {								\
+		if (errno == 0) {					\
+			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)	\
+				errno = ERANGE;				\
+		}							\
+		else if (errno == ERANGE &amp;&amp; (X) == 0.0)			\
+			errno = 0;					\
+	} while(0)
+
+#define Py_ADJUST_ERANGE2(X, Y)						\
+	do {								\
+		if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||	\
+		    (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {	\
+				if (errno == 0)				\
+					errno = ERANGE;			\
+		}							\
+		else if (errno == ERANGE)				\
+			errno = 0;					\
+	} while(0)
+
+/* Py_DEPRECATED(version)
+ * Declare a variable, type, or function deprecated.
+ * Usage:
+ *    extern int old_var Py_DEPRECATED(2.3);
+ *    typedef int T1 Py_DEPRECATED(2.4);
+ *    extern int x() Py_DEPRECATED(2.5);
+ */
+#if defined(__GNUC__) &amp;&amp; (__GNUC__ == 3) &amp;&amp; (__GNUC_MINOR__ &gt;= 1)
+#define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))
+#else
+#define Py_DEPRECATED(VERSION_UNUSED)
+#endif
+
+/**************************************************************************
+Prototypes that are missing from the standard include files on some systems
+(and possibly only some versions of such systems.)
+
+Please be conservative with adding new ones, document them and enclose them
+in platform-specific #ifdefs.
+**************************************************************************/
+
+#ifdef SOLARIS
+/* Unchecked */
+extern int gethostname(char *, int);
+#endif
+
+#ifdef __BEOS__
+/* Unchecked */
+/* It's in the libs, but not the headers... - [cjh] */
+int shutdown( int, int );
+#endif
+
+#ifdef HAVE__GETPTY
+#include &lt;sys/types.h&gt;		/* we need to import mode_t */
+extern char * _getpty(int *, int, mode_t, int);
+#endif
+
+#if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY)
+#if !defined(HAVE_PTY_H) &amp;&amp; !defined(HAVE_LIBUTIL_H)
+/* BSDI does not supply a prototype for the 'openpty' and 'forkpty'
+   functions, even though they are included in libutil. */
+#include &lt;termios.h&gt;
+extern int openpty(int *, int *, char *, struct termios *, struct winsize *);
+extern int forkpty(int *, char *, struct termios *, struct winsize *);
+#endif /* !defined(HAVE_PTY_H) &amp;&amp; !defined(HAVE_LIBUTIL_H) */
+#endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */
+
+
+/* These are pulled from various places. It isn't obvious on what platforms
+   they are necessary, nor what the exact prototype should look like (which
+   is likely to vary between platforms!) If you find you need one of these
+   declarations, please move them to a platform-specific block and include
+   proper prototypes. */
+#if 0
+
+/* From Modules/resource.c */
+extern int getrusage();
+extern int getpagesize();
+
+/* From Python/sysmodule.c and Modules/posixmodule.c */
+extern int fclose(FILE *);
+
+/* From Modules/posixmodule.c */
+extern int fdatasync(int);
+#endif /* 0 */
+
+
+/************************
+ * WRAPPER FOR &lt;math.h&gt; *
+ ************************/
+
+#ifndef HAVE_HYPOT
+extern double hypot(double, double);
+#endif
+
+
+/*******************************************************************
+On 4.4BSD-descendants, ctype functions serves the whole range of
+wchar_t character set rather than single byte code points only.
+This characteristic can break some operations of string object
+including str.upper() and str.split() on UTF-8 locales.  This
+workaround was provided by Tim Robbins of FreeBSD project.  He said
+the incompatibility will be fixed in FreeBSD 6.
+********************************************************************/
+
+#ifdef __FreeBSD__
+#include &lt;osreldate.h&gt;
+#if __FreeBSD_version &gt; 500039
+#include &lt;ctype.h&gt;
+#include &lt;wctype.h&gt;
+#undef isalnum
+#define isalnum(c) iswalnum(btowc(c))
+#undef isalpha
+#define isalpha(c) iswalpha(btowc(c))
+#undef islower
+#define islower(c) iswlower(btowc(c))
+#undef isspace
+#define isspace(c) iswspace(btowc(c))
+#undef isupper
+#define isupper(c) iswupper(btowc(c))
+#undef tolower
+#define tolower(c) towlower(btowc(c))
+#undef toupper
+#define toupper(c) towupper(btowc(c))
+#endif
+#endif
+
+
+/* Declarations for symbol visibility.
+
+  PyAPI_FUNC(type): Declares a public Python API function and return type
+  PyAPI_DATA(type): Declares public Python data and its type
+  PyMODINIT_FUNC:   A Python module init function.  If these functions are
+                    inside the Python core, they are private to the core.
+                    If in an extension module, it may be declared with
+                    external linkage depending on the platform.
+
+  As a number of platforms support/require &quot;__declspec(dllimport/dllexport)&quot;,
+  we support a HAVE_DECLSPEC_DLL macro to save duplication.
+*/
+
+/*
+  All windows ports, except cygwin, are handled in PC/pyconfig.h.
+
+  BeOS and cygwin are the only other autoconf platform requiring special
+  linkage handling and both of these use __declspec().
+*/
+#if defined(__CYGWIN__) || defined(__BEOS__)
+#	define HAVE_DECLSPEC_DLL
+#endif
+
+/* only get special linkage if built as shared or platform is Cygwin */
+#if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
+#	if defined(HAVE_DECLSPEC_DLL)
+#		ifdef Py_BUILD_CORE
+#			define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE
+#			define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE
+			/* module init functions inside the core need no external linkage */
+			/* except for Cygwin to handle embedding (FIXME: BeOS too?) */
+#			if defined(__CYGWIN__)
+#				define PyMODINIT_FUNC __declspec(dllexport) void
+#			else /* __CYGWIN__ */
+#				define PyMODINIT_FUNC void
+#			endif /* __CYGWIN__ */
+#		else /* Py_BUILD_CORE */
+			/* Building an extension module, or an embedded situation */
+			/* public Python functions and data are imported */
+			/* Under Cygwin, auto-import functions to prevent compilation */
+			/* failures similar to <A HREF="http://python.org/doc/FAQ.html#3.24">http://python.org/doc/FAQ.html#3.24</A> */
+#			if !defined(__CYGWIN__)
+#				define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
+#			endif /* !__CYGWIN__ */
+#			define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
+			/* module init functions outside the core must be exported */
+#			if defined(__cplusplus)
+#				define PyMODINIT_FUNC extern &quot;C&quot; __declspec(dllexport) void
+#			else /* __cplusplus */
+#				define PyMODINIT_FUNC __declspec(dllexport) void
+#			endif /* __cplusplus */
+#		endif /* Py_BUILD_CORE */
+#	endif /* HAVE_DECLSPEC */
+#endif /* Py_ENABLE_SHARED */
+
+/* If no external linkage macros defined by now, create defaults */
+#ifndef PyAPI_FUNC
+#	define PyAPI_FUNC(RTYPE) RTYPE
+#endif
+#ifndef PyAPI_DATA
+#	define PyAPI_DATA(RTYPE) extern RTYPE
+#endif
+#ifndef PyMODINIT_FUNC
+#	if defined(__cplusplus)
+#		define PyMODINIT_FUNC extern &quot;C&quot; void
+#	else /* __cplusplus */
+#		define PyMODINIT_FUNC void
+#	endif /* __cplusplus */
+#endif
+
+/* Deprecated DL_IMPORT and DL_EXPORT macros */
+#if defined(Py_ENABLE_SHARED) &amp;&amp; defined (HAVE_DECLSPEC_DLL)
+#	if defined(Py_BUILD_CORE)
+#		define DL_IMPORT(RTYPE) __declspec(dllexport) RTYPE
+#		define DL_EXPORT(RTYPE) __declspec(dllexport) RTYPE
+#	else
+#		define DL_IMPORT(RTYPE) __declspec(dllimport) RTYPE
+#		define DL_EXPORT(RTYPE) __declspec(dllexport) RTYPE
+#	endif
+#endif
+#ifndef DL_EXPORT
+#	define DL_EXPORT(RTYPE) RTYPE
+#endif
+#ifndef DL_IMPORT
+#	define DL_IMPORT(RTYPE) RTYPE
+#endif
+/* End of deprecated DL_* macros */
+
+/* If the fd manipulation macros aren't defined,
+   here is a set that should do the job */
+
+#if 0 /* disabled and probably obsolete */
+
+#ifndef	FD_SETSIZE
+#define	FD_SETSIZE	256
+#endif
+
+#ifndef FD_SET
+
+typedef long fd_mask;
+
+#define NFDBITS	(sizeof(fd_mask) * NBBY)	/* bits per mask */
+#ifndef howmany
+#define	howmany(x, y)	(((x)+((y)-1))/(y))
+#endif /* howmany */
+
+typedef	struct fd_set {
+	fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
+} fd_set;
+
+#define	FD_SET(n, p)	((p)-&gt;fds_bits[(n)/NFDBITS] |= (1 &lt;&lt; ((n) % NFDBITS)))
+#define	FD_CLR(n, p)	((p)-&gt;fds_bits[(n)/NFDBITS] &amp;= ~(1 &lt;&lt; ((n) % NFDBITS)))
+#define	FD_ISSET(n, p)	((p)-&gt;fds_bits[(n)/NFDBITS] &amp; (1 &lt;&lt; ((n) % NFDBITS)))
+#define FD_ZERO(p)	memset((char *)(p), '\0', sizeof(*(p)))
+
+#endif /* FD_SET */
+
+#endif /* fd manipulation macros */
+
+
+/* limits.h constants that may be missing */
+
+#ifndef INT_MAX
+#define INT_MAX 2147483647
+#endif
+
+#ifndef LONG_MAX
+#if SIZEOF_LONG == 4
+#define LONG_MAX 0X7FFFFFFFL
+#elif SIZEOF_LONG == 8
+#define LONG_MAX 0X7FFFFFFFFFFFFFFFL
+#else
+#error &quot;could not set LONG_MAX in pyport.h&quot;
+#endif
+#endif
+
+#ifndef LONG_MIN
+#define LONG_MIN (-LONG_MAX-1)
+#endif
+
+#ifndef LONG_BIT
+#define LONG_BIT (8 * SIZEOF_LONG)
+#endif
+
+#if LONG_BIT != 8 * SIZEOF_LONG
+/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
+ * 32-bit platforms using gcc.  We try to catch that here at compile-time
+ * rather than waiting for integer multiplication to trigger bogus
+ * overflows.
+ */
+#error &quot;LONG_BIT definition appears wrong for platform (bad gcc/glibc config?).&quot;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/*
+ * Hide GCC attributes from compilers that don't support them.
+ */
+#if (!defined(__GNUC__) || __GNUC__ &lt; 2 || \
+     (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 7) ) &amp;&amp; \
+    !defined(RISCOS)
+#define Py_GCC_ATTRIBUTE(x)
+#else
+#define Py_GCC_ATTRIBUTE(x) __attribute__(x)
+#endif
+
+/* Eliminate end-of-loop code not reached warnings from SunPro C
+ * when using do{...}while(0) macros
+ */
+#ifdef __SUNPRO_C
+#pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)
+#endif
+
+#endif /* Py_PYPORT_H */

Added: trunk/msvc-libs/include/pystate.h
===================================================================
--- trunk/msvc-libs/include/pystate.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pystate.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,185 @@
+
+/* Thread and interpreter state structures and their interfaces */
+
+
+#ifndef Py_PYSTATE_H
+#define Py_PYSTATE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* State shared between threads */
+
+struct _ts; /* Forward */
+struct _is; /* Forward */
+
+typedef struct _is {
+
+    struct _is *next;
+    struct _ts *tstate_head;
+
+    PyObject *modules;
+    PyObject *sysdict;
+    PyObject *builtins;
+
+    PyObject *codec_search_path;
+    PyObject *codec_search_cache;
+    PyObject *codec_error_registry;
+
+#ifdef HAVE_DLOPEN
+    int dlopenflags;
+#endif
+#ifdef WITH_TSC
+    int tscdump;
+#endif
+
+} PyInterpreterState;
+
+
+/* State unique per thread */
+
+struct _frame; /* Avoid including frameobject.h */
+
+/* Py_tracefunc return -1 when raising an exception, or 0 for success. */
+typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);
+
+/* The following values are used for 'what' for tracefunc functions: */
+#define PyTrace_CALL 0
+#define PyTrace_EXCEPTION 1
+#define PyTrace_LINE 2
+#define PyTrace_RETURN 3
+#define PyTrace_C_CALL 4
+#define PyTrace_C_EXCEPTION 5
+#define PyTrace_C_RETURN 6
+
+typedef struct _ts {
+
+    struct _ts *next;
+    PyInterpreterState *interp;
+
+    struct _frame *frame;
+    int recursion_depth;
+    int tracing;
+    int use_tracing;
+
+    Py_tracefunc c_profilefunc;
+    Py_tracefunc c_tracefunc;
+    PyObject *c_profileobj;
+    PyObject *c_traceobj;
+
+    PyObject *curexc_type;
+    PyObject *curexc_value;
+    PyObject *curexc_traceback;
+
+    PyObject *exc_type;
+    PyObject *exc_value;
+    PyObject *exc_traceback;
+
+    PyObject *dict;
+
+    /* tick_counter is incremented whenever the check_interval ticker
+     * reaches zero. The purpose is to give a useful measure of the number
+     * of interpreted bytecode instructions in a given thread.  This
+     * extremely lightweight statistic collector may be of interest to
+     * profilers (like psyco.jit()), although nothing in the core uses it.
+     */
+    int tick_counter;
+
+    int gilstate_counter;
+
+    PyObject *async_exc; /* Asynchronous exception to raise */
+    long thread_id; /* Thread id where this tstate was created */
+
+    /* XXX signal handlers should also be here */
+
+} PyThreadState;
+
+
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
+PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
+PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
+
+PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
+PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
+#ifdef WITH_THREAD
+PyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);
+#endif
+
+PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
+PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
+PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
+PyAPI_FUNC(int) PyThreadState_SetAsyncExc(long, PyObject *);
+
+
+/* Variable and macro for in-line access to current thread state */
+
+PyAPI_DATA(PyThreadState *) _PyThreadState_Current;
+
+#ifdef Py_DEBUG
+#define PyThreadState_GET() PyThreadState_Get()
+#else
+#define PyThreadState_GET() (_PyThreadState_Current)
+#endif
+
+typedef
+    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
+        PyGILState_STATE;
+
+/* Ensure that the current thread is ready to call the Python
+   C API, regardless of the current state of Python, or of its
+   thread lock.  This may be called as many times as desired
+   by a thread so long as each call is matched with a call to
+   PyGILState_Release().  In general, other thread-state APIs may
+   be used between _Ensure() and _Release() calls, so long as the
+   thread-state is restored to its previous state before the Release().
+   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
+   Py_END_ALLOW_THREADS macros are acceptable.
+
+   The return value is an opaque &quot;handle&quot; to the thread state when
+   PyGILState_Ensure() was called, and must be passed to
+   PyGILState_Release() to ensure Python is left in the same state. Even
+   though recursive calls are allowed, these handles can *not* be shared -
+   each unique call to PyGILState_Ensure must save the handle for its
+   call to PyGILState_Release.
+
+   When the function returns, the current thread will hold the GIL.
+
+   Failure is a fatal error.
+*/
+PyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);
+
+/* Release any resources previously acquired.  After this call, Python's
+   state will be the same as it was prior to the corresponding
+   PyGILState_Ensure() call (but generally this state will be unknown to
+   the caller, hence the use of the GILState API.)
+
+   Every call to PyGILState_Ensure must be matched by a call to
+   PyGILState_Release on the same thread.
+*/
+PyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);
+
+/* Helper/diagnostic function - get the current thread state for
+   this thread.  May return NULL if no GILState API has been used
+   on the current thread.  Note the main thread always has such a
+   thread-state, even if no auto-thread-state call has been made
+   on the main thread.
+*/
+PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
+
+/* Routines for advanced debuggers, requested by David Beazley.
+   Don't use unless you know what you are doing! */
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Head(void);
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Next(PyInterpreterState *);
+PyAPI_FUNC(PyThreadState *) PyInterpreterState_ThreadHead(PyInterpreterState *);
+PyAPI_FUNC(PyThreadState *) PyThreadState_Next(PyThreadState *);
+
+typedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);
+
+/* hook for PyEval_GetFrame(), requested for Psyco */
+PyAPI_DATA(PyThreadFrameGetter) _PyThreadState_GetFrame;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYSTATE_H */

Added: trunk/msvc-libs/include/pystrtod.h
===================================================================
--- trunk/msvc-libs/include/pystrtod.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pystrtod.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,18 @@
+#ifndef Py_STRTOD_H
+#define Py_STRTOD_H
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+PyAPI_FUNC(double) PyOS_ascii_strtod(const char *str, char **ptr);
+PyAPI_FUNC(double) PyOS_ascii_atof(const char *str);
+PyAPI_FUNC(char *) PyOS_ascii_formatd(char *buffer, int buf_len,  const char *format, double d);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_STRTOD_H */

Added: trunk/msvc-libs/include/pythonrun.h
===================================================================
--- trunk/msvc-libs/include/pythonrun.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pythonrun.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,152 @@
+
+/* Interfaces to parse and execute pieces of python code */
+
+#ifndef Py_PYTHONRUN_H
+#define Py_PYTHONRUN_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define PyCF_MASK (CO_FUTURE_DIVISION)
+#define PyCF_MASK_OBSOLETE (CO_GENERATOR_ALLOWED | CO_NESTED)
+#define PyCF_SOURCE_IS_UTF8  0x0100
+#define PyCF_DONT_IMPLY_DEDENT 0x0200
+
+typedef struct {
+	int cf_flags;  /* bitmask of CO_xxx flags relevant to future */
+} PyCompilerFlags;
+
+PyAPI_FUNC(void) Py_SetProgramName(char *);
+PyAPI_FUNC(char *) Py_GetProgramName(void);
+
+PyAPI_FUNC(void) Py_SetPythonHome(char *);
+PyAPI_FUNC(char *) Py_GetPythonHome(void);
+
+PyAPI_FUNC(void) Py_Initialize(void);
+PyAPI_FUNC(void) Py_InitializeEx(int);
+PyAPI_FUNC(void) Py_Finalize(void);
+PyAPI_FUNC(int) Py_IsInitialized(void);
+PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
+PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
+
+PyAPI_FUNC(int) PyRun_AnyFile(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_AnyFileEx(FILE *, const char *, int);
+
+PyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_AnyFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
+
+PyAPI_FUNC(int) PyRun_SimpleString(const char *);
+PyAPI_FUNC(int) PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_SimpleFile(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_SimpleFileEx(FILE *, const char *, int);
+PyAPI_FUNC(int) PyRun_SimpleFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_InteractiveOne(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_InteractiveOneFlags(FILE *, const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_InteractiveLoop(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_InteractiveLoopFlags(FILE *, const char *, PyCompilerFlags *);
+
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseString(const char *, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseFile(FILE *, const char *, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlags(const char *, int, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlagsFilename(const char *,
+								  const char *,
+								  int,
+								  int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseFileFlags(FILE *, const char *,
+							int, int);
+
+PyAPI_FUNC(PyObject *) PyRun_String(const char *, int, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyRun_File(FILE *, const char *, int, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyRun_FileEx(FILE *, const char *, int,
+				   PyObject *, PyObject *, int);
+PyAPI_FUNC(PyObject *) PyRun_StringFlags(const char *, int, PyObject *, PyObject *,
+					PyCompilerFlags *);
+PyAPI_FUNC(PyObject *) PyRun_FileFlags(FILE *, const char *, int, PyObject *, 
+				      PyObject *, PyCompilerFlags *);
+PyAPI_FUNC(PyObject *) PyRun_FileExFlags(FILE *, const char *, int, PyObject *, 
+					PyObject *, int, PyCompilerFlags *);
+
+PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
+PyAPI_FUNC(PyObject *) Py_CompileStringFlags(const char *, const char *, int,
+					    PyCompilerFlags *);
+PyAPI_FUNC(struct symtable *) Py_SymtableString(const char *, const char *, int);
+
+PyAPI_FUNC(void) PyErr_Print(void);
+PyAPI_FUNC(void) PyErr_PrintEx(int);
+PyAPI_FUNC(void) PyErr_Display(PyObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(int) Py_AtExit(void (*func)(void));
+
+PyAPI_FUNC(void) Py_Exit(int);
+
+PyAPI_FUNC(int) Py_FdIsInteractive(FILE *, const char *);
+
+/* Bootstrap */
+PyAPI_FUNC(int) Py_Main(int argc, char **argv);
+
+/* In getpath.c */
+PyAPI_FUNC(char *) Py_GetProgramFullPath(void);
+PyAPI_FUNC(char *) Py_GetPrefix(void);
+PyAPI_FUNC(char *) Py_GetExecPrefix(void);
+PyAPI_FUNC(char *) Py_GetPath(void);
+
+/* In their own files */
+PyAPI_FUNC(const char *) Py_GetVersion(void);
+PyAPI_FUNC(const char *) Py_GetPlatform(void);
+PyAPI_FUNC(const char *) Py_GetCopyright(void);
+PyAPI_FUNC(const char *) Py_GetCompiler(void);
+PyAPI_FUNC(const char *) Py_GetBuildInfo(void);
+
+/* Internal -- various one-time initializations */
+PyAPI_FUNC(PyObject *) _PyBuiltin_Init(void);
+PyAPI_FUNC(PyObject *) _PySys_Init(void);
+PyAPI_FUNC(void) _PyImport_Init(void);
+PyAPI_FUNC(void) _PyExc_Init(void);
+PyAPI_FUNC(void) _PyImportHooks_Init(void);
+PyAPI_FUNC(int) _PyFrame_Init(void);
+PyAPI_FUNC(int) _PyInt_Init(void);
+
+/* Various internal finalizers */
+PyAPI_FUNC(void) _PyExc_Fini(void);
+PyAPI_FUNC(void) _PyImport_Fini(void);
+PyAPI_FUNC(void) PyMethod_Fini(void);
+PyAPI_FUNC(void) PyFrame_Fini(void);
+PyAPI_FUNC(void) PyCFunction_Fini(void);
+PyAPI_FUNC(void) PyTuple_Fini(void);
+PyAPI_FUNC(void) PyList_Fini(void);
+PyAPI_FUNC(void) PyString_Fini(void);
+PyAPI_FUNC(void) PyInt_Fini(void);
+PyAPI_FUNC(void) PyFloat_Fini(void);
+PyAPI_FUNC(void) PyOS_FiniInterrupts(void);
+
+/* Stuff with no proper home (yet) */
+PyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, char *);
+PyAPI_DATA(int) (*PyOS_InputHook)(void);
+PyAPI_DATA(char) *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, char *);
+PyAPI_DATA(PyThreadState*) _PyOS_ReadlineTState;
+
+/* Stack size, in &quot;pointers&quot; (so we get extra safety margins
+   on 64-bit platforms).  On a 32-bit platform, this translates
+   to a 8k margin. */
+#define PYOS_STACK_MARGIN 2048
+
+#if defined(WIN32) &amp;&amp; !defined(MS_WIN64) &amp;&amp; defined(_MSC_VER)
+/* Enable stack checking under Microsoft C */
+#define USE_STACKCHECK
+#endif
+
+#ifdef USE_STACKCHECK
+/* Check that we aren't overflowing our stack */
+PyAPI_FUNC(int) PyOS_CheckStack(void);
+#endif
+
+/* Signals */
+typedef void (*PyOS_sighandler_t)(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYTHONRUN_H */

Added: trunk/msvc-libs/include/pythread.h
===================================================================
--- trunk/msvc-libs/include/pythread.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/pythread.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,44 @@
+
+#ifndef Py_PYTHREAD_H
+#define Py_PYTHREAD_H
+
+#define NO_EXIT_PROG		/* don't define PyThread_exit_prog() */
+				/* (the result is no use of signals on SGI) */
+
+typedef void *PyThread_type_lock;
+typedef void *PyThread_type_sema;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(void) PyThread_init_thread(void);
+PyAPI_FUNC(long) PyThread_start_new_thread(void (*)(void *), void *);
+PyAPI_FUNC(void) PyThread_exit_thread(void);
+PyAPI_FUNC(void) PyThread__PyThread_exit_thread(void);
+PyAPI_FUNC(long) PyThread_get_thread_ident(void);
+
+PyAPI_FUNC(PyThread_type_lock) PyThread_allocate_lock(void);
+PyAPI_FUNC(void) PyThread_free_lock(PyThread_type_lock);
+PyAPI_FUNC(int) PyThread_acquire_lock(PyThread_type_lock, int);
+#define WAIT_LOCK	1
+#define NOWAIT_LOCK	0
+PyAPI_FUNC(void) PyThread_release_lock(PyThread_type_lock);
+
+#ifndef NO_EXIT_PROG
+PyAPI_FUNC(void) PyThread_exit_prog(int);
+PyAPI_FUNC(void) PyThread__PyThread_exit_prog(int);
+#endif
+
+/* Thread Local Storage (TLS) API */
+PyAPI_FUNC(int) PyThread_create_key(void);
+PyAPI_FUNC(void) PyThread_delete_key(int);
+PyAPI_FUNC(int) PyThread_set_key_value(int, void *);
+PyAPI_FUNC(void *) PyThread_get_key_value(int);
+PyAPI_FUNC(void) PyThread_delete_key_value(int key);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_PYTHREAD_H */

Added: trunk/msvc-libs/include/rangeobject.h
===================================================================
--- trunk/msvc-libs/include/rangeobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/rangeobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,30 @@
+
+/* Range object interface */
+
+#ifndef Py_RANGEOBJECT_H
+#define Py_RANGEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* This is about the type 'xrange', not the built-in function range(), which
+   returns regular lists. */
+
+/*
+A range object represents an integer range.  This is an immutable object;
+a range cannot change its value after creation.
+
+Range objects behave like the corresponding tuple objects except that
+they are represented by a start, stop, and step datamembers.
+*/
+
+PyAPI_DATA(PyTypeObject) PyRange_Type;
+
+#define PyRange_Check(op) ((op)-&gt;ob_type == &amp;PyRange_Type)
+
+PyAPI_FUNC(PyObject *) PyRange_New(long, long, long, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_RANGEOBJECT_H */

Added: trunk/msvc-libs/include/setobject.h
===================================================================
--- trunk/msvc-libs/include/setobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/setobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,41 @@
+
+/* Set object interface */
+
+#ifndef Py_SETOBJECT_H
+#define Py_SETOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/*
+This data structure is shared by set and frozenset objects.
+*/
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *data;
+	long hash;	/* only used by frozenset objects */
+	PyObject *weakreflist; /* List of weak references */
+
+	/* Invariants:
+	 *     data is a dictionary whose values are all True.
+	 *     data points to the same dict for the whole life of the set.
+	 * For frozensets only:
+	 *     data is immutable.
+	 *     hash is the hash of the frozenset or -1 if not computed yet.
+	 */
+} PySetObject;
+
+PyAPI_DATA(PyTypeObject) PySet_Type;
+PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
+
+#define PyFrozenSet_CheckExact(ob) ((ob)-&gt;ob_type == &amp;PyFrozenSet_Type)
+#define PyAnySet_Check(ob) \
+	((ob)-&gt;ob_type == &amp;PySet_Type || (ob)-&gt;ob_type == &amp;PyFrozenSet_Type || \
+	  PyType_IsSubtype((ob)-&gt;ob_type, &amp;PySet_Type) || \
+	  PyType_IsSubtype((ob)-&gt;ob_type, &amp;PyFrozenSet_Type))
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SETOBJECT_H */

Added: trunk/msvc-libs/include/sliceobject.h
===================================================================
--- trunk/msvc-libs/include/sliceobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/sliceobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,42 @@
+#ifndef Py_SLICEOBJECT_H
+#define Py_SLICEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* The unique ellipsis object &quot;...&quot; */
+
+PyAPI_DATA(PyObject) _Py_EllipsisObject; /* Don't use this directly */
+
+#define Py_Ellipsis (&amp;_Py_EllipsisObject)
+
+/* Slice object interface */
+
+/*
+
+A slice object containing start, stop, and step data members (the
+names are from range).  After much talk with Guido, it was decided to
+let these be any arbitrary python type.  Py_None stands for omitted values.
+*/
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *start, *stop, *step;	/* not NULL */
+} PySliceObject;
+
+PyAPI_DATA(PyTypeObject) PySlice_Type;
+
+#define PySlice_Check(op) ((op)-&gt;ob_type == &amp;PySlice_Type)
+
+PyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,
+                                  PyObject* step);
+PyAPI_FUNC(int) PySlice_GetIndices(PySliceObject *r, int length,
+                                  int *start, int *stop, int *step);
+PyAPI_FUNC(int) PySlice_GetIndicesEx(PySliceObject *r, int length,
+				    int *start, int *stop, 
+				    int *step, int *slicelength);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SLICEOBJECT_H */

Added: trunk/msvc-libs/include/stringobject.h
===================================================================
--- trunk/msvc-libs/include/stringobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/stringobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,183 @@
+
+/* String object interface */
+
+#ifndef Py_STRINGOBJECT_H
+#define Py_STRINGOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &lt;stdarg.h&gt;
+
+/*
+Type PyStringObject represents a character string.  An extra zero byte is
+reserved at the end to ensure it is zero-terminated, but a size is
+present so strings with null bytes in them can be represented.  This
+is an immutable object type.
+
+There are functions to create new string objects, to test
+an object for string-ness, and to get the
+string value.  The latter function returns a null pointer
+if the object is not of the proper type.
+There is a variant that takes an explicit size as well as a
+variant that assumes a zero-terminated string.  Note that none of the
+functions should be applied to nil objects.
+*/
+
+/* Caching the hash (ob_shash) saves recalculation of a string's hash value.
+   Interning strings (ob_sstate) tries to ensure that only one string
+   object with a given value exists, so equality tests can be one pointer
+   comparison.  This is generally restricted to strings that &quot;look like&quot;
+   Python identifiers, although the intern() builtin can be used to force
+   interning of any string.
+   Together, these sped the interpreter by up to 20%. */
+
+typedef struct {
+    PyObject_VAR_HEAD
+    long ob_shash;
+    int ob_sstate;
+    char ob_sval[1];
+
+    /* Invariants:
+     *     ob_sval contains space for 'ob_size+1' elements.
+     *     ob_sval[ob_size] == 0.
+     *     ob_shash is the hash of the string or -1 if not computed yet.
+     *     ob_sstate != 0 iff the string object is in stringobject.c's
+     *       'interned' dictionary; in this case the two references
+     *       from 'interned' to this object are *not counted* in ob_refcnt.
+     */
+} PyStringObject;
+
+#define SSTATE_NOT_INTERNED 0
+#define SSTATE_INTERNED_MORTAL 1
+#define SSTATE_INTERNED_IMMORTAL 2
+
+PyAPI_DATA(PyTypeObject) PyBaseString_Type;
+PyAPI_DATA(PyTypeObject) PyString_Type;
+
+#define PyString_Check(op) PyObject_TypeCheck(op, &amp;PyString_Type)
+#define PyString_CheckExact(op) ((op)-&gt;ob_type == &amp;PyString_Type)
+
+PyAPI_FUNC(PyObject *) PyString_FromStringAndSize(const char *, int);
+PyAPI_FUNC(PyObject *) PyString_FromString(const char *);
+PyAPI_FUNC(PyObject *) PyString_FromFormatV(const char*, va_list)
+				Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
+PyAPI_FUNC(PyObject *) PyString_FromFormat(const char*, ...)
+				Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(int) PyString_Size(PyObject *);
+PyAPI_FUNC(char *) PyString_AsString(PyObject *);
+PyAPI_FUNC(PyObject *) PyString_Repr(PyObject *, int);
+PyAPI_FUNC(void) PyString_Concat(PyObject **, PyObject *);
+PyAPI_FUNC(void) PyString_ConcatAndDel(PyObject **, PyObject *);
+PyAPI_FUNC(int) _PyString_Resize(PyObject **, int);
+PyAPI_FUNC(int) _PyString_Eq(PyObject *, PyObject*);
+PyAPI_FUNC(PyObject *) PyString_Format(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyString_FormatLong(PyObject*, int, int,
+						  int, char**, int*);
+PyAPI_FUNC(PyObject *) PyString_DecodeEscape(const char *, int, 
+						   const char *, int,
+						   const char *);
+
+PyAPI_FUNC(void) PyString_InternInPlace(PyObject **);
+PyAPI_FUNC(void) PyString_InternImmortal(PyObject **);
+PyAPI_FUNC(PyObject *) PyString_InternFromString(const char *);
+PyAPI_FUNC(void) _Py_ReleaseInternedStrings(void);
+
+/* Use only if you know it's a string */
+#define PyString_CHECK_INTERNED(op) (((PyStringObject *)(op))-&gt;ob_sstate)
+
+/* Macro, trading safety for speed */
+#define PyString_AS_STRING(op) (((PyStringObject *)(op))-&gt;ob_sval)
+#define PyString_GET_SIZE(op)  (((PyStringObject *)(op))-&gt;ob_size)
+
+/* _PyString_Join(sep, x) is like sep.join(x).  sep must be PyStringObject*,
+   x must be an iterable object. */
+PyAPI_FUNC(PyObject *) _PyString_Join(PyObject *sep, PyObject *x);
+
+/* --- Generic Codecs ----------------------------------------------------- */
+
+/* Create an object by decoding the encoded string s of the
+   given size. */
+
+PyAPI_FUNC(PyObject*) PyString_Decode(
+    const char *s,              /* encoded string */
+    int size,                   /* size of buffer */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a char buffer of the given size and returns a 
+   Python object. */
+
+PyAPI_FUNC(PyObject*) PyString_Encode(
+    const char *s,              /* string char buffer */
+    int size,                   /* number of chars to encode */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a string object and returns the result as Python 
+   object. */
+
+PyAPI_FUNC(PyObject*) PyString_AsEncodedObject(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Encodes a string object and returns the result as Python string
+   object.   
+   
+   If the codec returns an Unicode object, the object is converted
+   back to a string using the default encoding.
+
+   DEPRECATED - use PyString_AsEncodedObject() instead. */
+
+PyAPI_FUNC(PyObject*) PyString_AsEncodedString(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Decodes a string object and returns the result as Python 
+   object. */
+
+PyAPI_FUNC(PyObject*) PyString_AsDecodedObject(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Decodes a string object and returns the result as Python string
+   object.  
+   
+   If the codec returns an Unicode object, the object is converted
+   back to a string using the default encoding.
+
+   DEPRECATED - use PyString_AsDecodedObject() instead. */
+
+PyAPI_FUNC(PyObject*) PyString_AsDecodedString(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Provides access to the internal data buffer and size of a string
+   object or the default encoded version of an Unicode object. Passing
+   NULL as *len parameter will force the string buffer to be
+   0-terminated (passing a string with embedded NULL characters will
+   cause an exception).  */
+
+PyAPI_FUNC(int) PyString_AsStringAndSize(
+    register PyObject *obj,	/* string or Unicode object */
+    register char **s,		/* pointer to buffer variable */
+    register int *len		/* pointer to length variable or NULL
+				   (only possible for 0-terminated
+				   strings) */
+    );
+    
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRINGOBJECT_H */

Added: trunk/msvc-libs/include/structmember.h
===================================================================
--- trunk/msvc-libs/include/structmember.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/structmember.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,89 @@
+#ifndef Py_STRUCTMEMBER_H
+#define Py_STRUCTMEMBER_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Interface to map C struct members to Python object attributes */
+
+#include &lt;stddef.h&gt; /* For offsetof */
+
+/* The offsetof() macro calculates the offset of a structure member
+   in its structure.  Unfortunately this cannot be written down
+   portably, hence it is provided by a Standard C header file.
+   For pre-Standard C compilers, here is a version that usually works
+   (but watch out!): */
+
+#ifndef offsetof
+#define offsetof(type, member) ( (int) &amp; ((type*)0) -&gt; member )
+#endif
+
+/* An array of memberlist structures defines the name, type and offset
+   of selected members of a C structure.  These can be read by
+   PyMember_Get() and set by PyMember_Set() (except if their READONLY flag
+   is set).  The array must be terminated with an entry whose name
+   pointer is NULL. */
+
+struct memberlist {
+	/* Obsolete version, for binary backwards compatibility */
+	char *name;
+	int type;
+	int offset;
+	int flags;
+};
+
+typedef struct PyMemberDef {
+	/* Current version, use this */
+	char *name;
+	int type;
+	int offset;
+	int flags;
+	char *doc;
+} PyMemberDef;
+
+/* Types */
+#define T_SHORT		0
+#define T_INT		1
+#define T_LONG		2
+#define T_FLOAT		3
+#define T_DOUBLE	4
+#define T_STRING	5
+#define T_OBJECT	6
+/* XXX the ordering here is weird for binary compatibility */
+#define T_CHAR		7	/* 1-character string */
+#define T_BYTE		8	/* 8-bit signed int */
+/* unsigned variants: */
+#define T_UBYTE		9
+#define T_USHORT	10
+#define T_UINT		11
+#define T_ULONG		12
+
+/* Added by Jack: strings contained in the structure */
+#define T_STRING_INPLACE	13
+
+#define T_OBJECT_EX	16	/* Like T_OBJECT, but raises AttributeError
+				   when the value is NULL, instead of
+				   converting to None. */
+
+/* Flags */
+#define READONLY	1
+#define RO		READONLY		/* Shorthand */
+#define READ_RESTRICTED	2
+#define WRITE_RESTRICTED 4
+#define RESTRICTED	(READ_RESTRICTED | WRITE_RESTRICTED)
+
+
+/* Obsolete API, for binary backwards compatibility */
+PyAPI_FUNC(PyObject *) PyMember_Get(char *, struct memberlist *, char *);
+PyAPI_FUNC(int) PyMember_Set(char *, struct memberlist *, char *, PyObject *);
+
+/* Current API, use this */
+PyAPI_FUNC(PyObject *) PyMember_GetOne(char *, struct PyMemberDef *);
+PyAPI_FUNC(int) PyMember_SetOne(char *, struct PyMemberDef *, PyObject *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRUCTMEMBER_H */

Added: trunk/msvc-libs/include/structseq.h
===================================================================
--- trunk/msvc-libs/include/structseq.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/structseq.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,41 @@
+
+/* Tuple object interface */
+
+#ifndef Py_STRUCTSEQ_H
+#define Py_STRUCTSEQ_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef struct PyStructSequence_Field {
+	char *name;
+	char *doc;
+} PyStructSequence_Field;
+
+typedef struct PyStructSequence_Desc {
+	char *name;
+	char *doc;
+	struct PyStructSequence_Field *fields;
+	int n_in_sequence;
+} PyStructSequence_Desc;
+
+extern char* PyStructSequence_UnnamedField;
+
+PyAPI_FUNC(void) PyStructSequence_InitType(PyTypeObject *type,
+					   PyStructSequence_Desc *desc);
+
+PyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);
+
+typedef struct {
+	PyObject_VAR_HEAD
+	PyObject *ob_item[1];
+} PyStructSequence;
+
+/* Macro, *only* to be used to fill in brand new objects */
+#define PyStructSequence_SET_ITEM(op, i, v) \
+	(((PyStructSequence *)(op))-&gt;ob_item[i] = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRUCTSEQ_H */

Added: trunk/msvc-libs/include/symtable.h
===================================================================
--- trunk/msvc-libs/include/symtable.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/symtable.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,102 @@
+#ifndef Py_SYMTABLE_H
+#define Py_SYMTABLE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* A symbol table is constructed each time PyNode_Compile() is
+   called.  The table walks the entire parse tree and identifies each
+   use or definition of a variable. 
+
+   The symbol table contains a dictionary for each code block in a
+   module: The symbol dictionary for the block.  They keys of these
+   dictionaries are the name of all variables used or defined in the
+   block; the integer values are used to store several flags,
+   e.g. DEF_PARAM indicates that a variable is a parameter to a
+   function. 
+*/
+
+struct _symtable_entry;
+
+struct symtable {
+	int st_pass;             /* pass == 1 or 2 */
+	const char *st_filename; /* name of file being compiled */
+	struct _symtable_entry *st_cur; /* current symbol table entry */
+	PyObject *st_symbols;    /* dictionary of symbol table entries */
+        PyObject *st_stack;      /* stack of namespace info */
+	PyObject *st_global;     /* borrowed ref to MODULE in st_symbols */
+	int st_nscopes;          /* number of scopes */
+	int st_errors;           /* number of errors */
+	char *st_private;        /* name of current class or NULL */
+	PyFutureFeatures *st_future; /* module's future features */
+};
+
+typedef struct _symtable_entry {
+	PyObject_HEAD
+	PyObject *ste_id;        /* int: key in st_symbols) */
+	PyObject *ste_symbols;   /* dict: name to flags) */
+	PyObject *ste_name;      /* string: name of scope */
+	PyObject *ste_varnames;  /* list of variable names */
+	PyObject *ste_children;  /* list of child ids */
+	int ste_type;            /* module, class, or function */
+	int ste_lineno;          /* first line of scope */
+	int ste_optimized;       /* true if namespace can't be optimized */
+	int ste_nested;          /* true if scope is nested */
+	int ste_child_free;      /* true if a child scope has free variables,
+				    including free refs to globals */
+	int ste_generator;       /* true if namespace is a generator */
+	int ste_opt_lineno;      /* lineno of last exec or import * */
+	int ste_tmpname;         /* temporary name counter */
+	struct symtable *ste_table;
+} PySymtableEntryObject;
+
+PyAPI_DATA(PyTypeObject) PySymtableEntry_Type;
+
+#define PySymtableEntry_Check(op) ((op)-&gt;ob_type == &amp;PySymtableEntry_Type)
+
+PyAPI_FUNC(PyObject *) PySymtableEntry_New(struct symtable *,
+						 char *, int, int);
+
+PyAPI_FUNC(struct symtable *) PyNode_CompileSymtable(struct _node *, const char *);
+PyAPI_FUNC(void) PySymtable_Free(struct symtable *);
+
+
+#define TOP &quot;global&quot;
+
+/* Flags for def-use information */
+
+#define DEF_GLOBAL 1           /* global stmt */
+#define DEF_LOCAL 2            /* assignment in code block */
+#define DEF_PARAM 2&lt;&lt;1         /* formal parameter */
+#define USE 2&lt;&lt;2               /* name is used */
+#define DEF_STAR 2&lt;&lt;3          /* parameter is star arg */
+#define DEF_DOUBLESTAR 2&lt;&lt;4    /* parameter is star-star arg */
+#define DEF_INTUPLE 2&lt;&lt;5       /* name defined in tuple in parameters */
+#define DEF_FREE 2&lt;&lt;6          /* name used but not defined in nested scope */
+#define DEF_FREE_GLOBAL 2&lt;&lt;7   /* free variable is actually implicit global */
+#define DEF_FREE_CLASS 2&lt;&lt;8    /* free variable from class's method */
+#define DEF_IMPORT 2&lt;&lt;9        /* assignment occurred via import */
+
+#define DEF_BOUND (DEF_LOCAL | DEF_PARAM | DEF_IMPORT)
+
+#define TYPE_FUNCTION 1
+#define TYPE_CLASS 2
+#define TYPE_MODULE 3
+
+#define LOCAL 1
+#define GLOBAL_EXPLICIT 2
+#define GLOBAL_IMPLICIT 3
+#define FREE 4
+#define CELL 5
+
+#define OPT_IMPORT_STAR 1
+#define OPT_EXEC 2
+#define OPT_BARE_EXEC 4
+
+#define GENERATOR 1
+#define GENERATOR_EXPRESSION 2
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SYMTABLE_H */

Added: trunk/msvc-libs/include/sysmodule.h
===================================================================
--- trunk/msvc-libs/include/sysmodule.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/sysmodule.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,30 @@
+
+/* System module interface */
+
+#ifndef Py_SYSMODULE_H
+#define Py_SYSMODULE_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+PyAPI_FUNC(PyObject *) PySys_GetObject(char *);
+PyAPI_FUNC(int) PySys_SetObject(char *, PyObject *);
+PyAPI_FUNC(FILE *) PySys_GetFile(char *, FILE *);
+PyAPI_FUNC(void) PySys_SetArgv(int, char **);
+PyAPI_FUNC(void) PySys_SetPath(char *);
+
+PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+
+PyAPI_DATA(PyObject *) _PySys_TraceFunc, *_PySys_ProfileFunc;
+PyAPI_DATA(int) _PySys_CheckInterval;
+
+PyAPI_FUNC(void) PySys_ResetWarnOptions(void);
+PyAPI_FUNC(void) PySys_AddWarnOption(char *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SYSMODULE_H */

Added: trunk/msvc-libs/include/timefuncs.h
===================================================================
--- trunk/msvc-libs/include/timefuncs.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/timefuncs.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,23 @@
+/*  timefuncs.h
+ */
+
+/* Utility function related to timemodule.c. */
+
+#ifndef TIMEFUNCS_H
+#define TIMEFUNCS_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/* Cast double x to time_t, but raise ValueError if x is too large
+ * to fit in a time_t.  ValueError is set on return iff the return
+ * value is (time_t)-1 and PyErr_Occurred().
+ */
+PyAPI_FUNC(time_t) _PyTime_DoubleToTimet(double x);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif  /* TIMEFUNCS_H */

Added: trunk/msvc-libs/include/token.h
===================================================================
--- trunk/msvc-libs/include/token.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/token.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,83 @@
+
+/* Token types */
+
+#ifndef Py_TOKEN_H
+#define Py_TOKEN_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define ENDMARKER	0
+#define NAME		1
+#define NUMBER		2
+#define STRING		3
+#define NEWLINE		4
+#define INDENT		5
+#define DEDENT		6
+#define LPAR		7
+#define RPAR		8
+#define LSQB		9
+#define RSQB		10
+#define COLON		11
+#define COMMA		12
+#define SEMI		13
+#define PLUS		14
+#define MINUS		15
+#define STAR		16
+#define SLASH		17
+#define VBAR		18
+#define AMPER		19
+#define LESS		20
+#define GREATER		21
+#define EQUAL		22
+#define DOT		23
+#define PERCENT		24
+#define BACKQUOTE	25
+#define LBRACE		26
+#define RBRACE		27
+#define EQEQUAL		28
+#define NOTEQUAL	29
+#define LESSEQUAL	30
+#define GREATEREQUAL	31
+#define TILDE		32
+#define CIRCUMFLEX	33
+#define LEFTSHIFT	34
+#define RIGHTSHIFT	35
+#define DOUBLESTAR	36
+#define PLUSEQUAL	37
+#define MINEQUAL	38
+#define STAREQUAL	39
+#define SLASHEQUAL	40
+#define PERCENTEQUAL	41
+#define AMPEREQUAL	42
+#define VBAREQUAL	43
+#define CIRCUMFLEXEQUAL	44
+#define LEFTSHIFTEQUAL	45
+#define RIGHTSHIFTEQUAL	46
+#define DOUBLESTAREQUAL	47
+#define DOUBLESLASH	48
+#define DOUBLESLASHEQUAL 49
+#define AT              50	
+/* Don't forget to update the table _PyParser_TokenNames in tokenizer.c! */
+#define OP		51
+#define ERRORTOKEN	52
+#define N_TOKENS	53
+
+/* Special definitions for cooperation with parser */
+
+#define NT_OFFSET		256
+
+#define ISTERMINAL(x)		((x) &lt; NT_OFFSET)
+#define ISNONTERMINAL(x)	((x) &gt;= NT_OFFSET)
+#define ISEOF(x)		((x) == ENDMARKER)
+
+
+PyAPI_DATA(char *) _PyParser_TokenNames[]; /* Token names */
+PyAPI_FUNC(int) PyToken_OneChar(int);
+PyAPI_FUNC(int) PyToken_TwoChars(int, int);
+PyAPI_FUNC(int) PyToken_ThreeChars(int, int, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TOKEN_H */

Added: trunk/msvc-libs/include/traceback.h
===================================================================
--- trunk/msvc-libs/include/traceback.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/traceback.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,30 @@
+
+#ifndef Py_TRACEBACK_H
+#define Py_TRACEBACK_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct _frame;
+
+/* Traceback interface */
+
+typedef struct _traceback {
+	PyObject_HEAD
+	struct _traceback *tb_next;
+	struct _frame *tb_frame;
+	int tb_lasti;
+	int tb_lineno;
+} PyTracebackObject;
+
+PyAPI_FUNC(int) PyTraceBack_Here(struct _frame *);
+PyAPI_FUNC(int) PyTraceBack_Print(PyObject *, PyObject *);
+
+/* Reveal traceback type so we can typecheck traceback objects */
+PyAPI_DATA(PyTypeObject) PyTraceBack_Type;
+#define PyTraceBack_Check(v) ((v)-&gt;ob_type == &amp;PyTraceBack_Type)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TRACEBACK_H */

Added: trunk/msvc-libs/include/tupleobject.h
===================================================================
--- trunk/msvc-libs/include/tupleobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/tupleobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,57 @@
+
+/* Tuple object interface */
+
+#ifndef Py_TUPLEOBJECT_H
+#define Py_TUPLEOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/*
+Another generally useful object type is a tuple of object pointers.
+For Python, this is an immutable type.  C code can change the tuple items
+(but not their number), and even use tuples are general-purpose arrays of
+object references, but in general only brand new tuples should be mutated,
+not ones that might already have been exposed to Python code.
+
+*** WARNING *** PyTuple_SetItem does not increment the new item's reference
+count, but does decrement the reference count of the item it replaces,
+if not nil.  It does *decrement* the reference count if it is *not*
+inserted in the tuple.  Similarly, PyTuple_GetItem does not increment the
+returned item's reference count.
+*/
+
+typedef struct {
+    PyObject_VAR_HEAD
+    PyObject *ob_item[1];
+
+    /* ob_item contains space for 'ob_size' elements.
+     * Items must normally not be NULL, except during construction when
+     * the tuple is not yet visible outside the function that builds it.
+     */
+} PyTupleObject;
+
+PyAPI_DATA(PyTypeObject) PyTuple_Type;
+
+#define PyTuple_Check(op) PyObject_TypeCheck(op, &amp;PyTuple_Type)
+#define PyTuple_CheckExact(op) ((op)-&gt;ob_type == &amp;PyTuple_Type)
+
+PyAPI_FUNC(PyObject *) PyTuple_New(int size);
+PyAPI_FUNC(int) PyTuple_Size(PyObject *);
+PyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, int);
+PyAPI_FUNC(int) PyTuple_SetItem(PyObject *, int, PyObject *);
+PyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, int, int);
+PyAPI_FUNC(int) _PyTuple_Resize(PyObject **, int);
+PyAPI_FUNC(PyObject *) PyTuple_Pack(int, ...);
+
+/* Macro, trading safety for speed */
+#define PyTuple_GET_ITEM(op, i) (((PyTupleObject *)(op))-&gt;ob_item[i])
+#define PyTuple_GET_SIZE(op)    (((PyTupleObject *)(op))-&gt;ob_size)
+
+/* Macro, *only* to be used to fill in brand new tuples */
+#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))-&gt;ob_item[i] = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TUPLEOBJECT_H */

Added: trunk/msvc-libs/include/ucnhash.h
===================================================================
--- trunk/msvc-libs/include/ucnhash.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/ucnhash.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,29 @@
+/* Unicode name database interface */
+
+#ifndef Py_UCNHASH_H
+#define Py_UCNHASH_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* revised ucnhash CAPI interface (exported through a PyCObject) */
+
+typedef struct {
+
+    /* Size of this struct */
+    int size;
+
+    /* Get name for a given character code.  Returns non-zero if
+       success, zero if not.  Does not set Python exceptions. */
+    int (*getname)(Py_UCS4 code, char* buffer, int buflen);
+
+    /* Get character code for a given name.  Same error handling
+       as for getname. */
+    int (*getcode)(const char* name, int namelen, Py_UCS4* code);
+
+} _PyUnicode_Name_CAPI;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_UCNHASH_H */

Added: trunk/msvc-libs/include/unicodeobject.h
===================================================================
--- trunk/msvc-libs/include/unicodeobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/unicodeobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,1196 @@
+#ifndef Py_UNICODEOBJECT_H
+#define Py_UNICODEOBJECT_H
+
+/*
+
+Unicode implementation based on original code by Fredrik Lundh,
+modified by Marc-Andre Lemburg (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">mal at lemburg.com</A>) according to the
+Unicode Integration Proposal (see file Misc/unicode.txt).
+
+Copyright (c) Corporation for National Research Initiatives.
+
+
+ Original header:
+ --------------------------------------------------------------------
+
+ * Yet another Unicode string type for Python.  This type supports the
+ * 16-bit Basic Multilingual Plane (BMP) only.
+ *
+ * Written by Fredrik Lundh, January 1999.
+ *
+ * Copyright (c) 1999 by Secret Labs AB.
+ * Copyright (c) 1999 by Fredrik Lundh.
+ *
+ * <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">fredrik at pythonware.com</A>
+ * <A HREF="http://www.pythonware.com">http://www.pythonware.com</A>
+ *
+ * --------------------------------------------------------------------
+ * This Unicode String Type is
+ * 
+ * Copyright (c) 1999 by Secret Labs AB
+ * Copyright (c) 1999 by Fredrik Lundh
+ * 
+ * By obtaining, using, and/or copying this software and/or its
+ * associated documentation, you agree that you have read, understood,
+ * and will comply with the following terms and conditions:
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * associated documentation for any purpose and without fee is hereby
+ * granted, provided that the above copyright notice appears in all
+ * copies, and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Secret Labs
+ * AB or the author not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.
+ * 
+ * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * -------------------------------------------------------------------- */
+
+#include &lt;ctype.h&gt;
+
+/* === Internal API ======================================================= */
+
+/* --- Internal Unicode Format -------------------------------------------- */
+
+#ifndef Py_USING_UNICODE
+
+#define PyUnicode_Check(op)                 0
+#define PyUnicode_CheckExact(op)            0
+
+#else
+
+/* FIXME: MvL's new implementation assumes that Py_UNICODE_SIZE is
+   properly set, but the default rules below doesn't set it.  I'll
+   sort this out some other day -- <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">fredrik at pythonware.com</A> */
+
+#ifndef Py_UNICODE_SIZE
+#error Must define Py_UNICODE_SIZE
+#endif
+
+/* Setting Py_UNICODE_WIDE enables UCS-4 storage.  Otherwise, Unicode
+   strings are stored as UCS-2 (with limited support for UTF-16) */
+
+#if Py_UNICODE_SIZE &gt;= 4
+#define Py_UNICODE_WIDE
+#endif
+
+/* Set these flags if the platform has &quot;wchar.h&quot;, &quot;wctype.h&quot; and the
+   wchar_t type is a 16-bit unsigned type */
+/* #define HAVE_WCHAR_H */
+/* #define HAVE_USABLE_WCHAR_T */
+
+/* Defaults for various platforms */
+#ifndef PY_UNICODE_TYPE
+
+/* Windows has a usable wchar_t type (unless we're using UCS-4) */
+# if defined(MS_WIN32) &amp;&amp; Py_UNICODE_SIZE == 2
+#  define HAVE_USABLE_WCHAR_T
+#  define PY_UNICODE_TYPE wchar_t
+# endif
+
+# if defined(Py_UNICODE_WIDE)
+#  define PY_UNICODE_TYPE Py_UCS4
+# endif
+
+#endif
+
+/* If the compiler provides a wchar_t type we try to support it
+   through the interface functions PyUnicode_FromWideChar() and
+   PyUnicode_AsWideChar(). */
+
+#ifdef HAVE_USABLE_WCHAR_T
+# ifndef HAVE_WCHAR_H
+#  define HAVE_WCHAR_H
+# endif
+#endif
+
+#ifdef HAVE_WCHAR_H
+/* Work around a cosmetic bug in BSDI 4.x wchar.h; thanks to Thomas Wouters */
+# ifdef _HAVE_BSDI
+#  include &lt;time.h&gt;
+# endif
+#  include &lt;wchar.h&gt;
+#endif
+
+/*
+ * Use this typedef when you need to represent a UTF-16 surrogate pair
+ * as single unsigned integer.
+ */
+#if SIZEOF_INT &gt;= 4 
+typedef unsigned int Py_UCS4; 
+#elif SIZEOF_LONG &gt;= 4
+typedef unsigned long Py_UCS4; 
+#endif
+
+typedef PY_UNICODE_TYPE Py_UNICODE;
+
+/* --- UCS-2/UCS-4 Name Mangling ------------------------------------------ */
+
+/* Unicode API names are mangled to assure that UCS-2 and UCS-4 builds
+   produce different external names and thus cause import errors in
+   case Python interpreters and extensions with mixed compiled in
+   Unicode width assumptions are combined. */
+
+#ifndef Py_UNICODE_WIDE
+
+# define PyUnicode_AsASCIIString PyUnicodeUCS2_AsASCIIString
+# define PyUnicode_AsCharmapString PyUnicodeUCS2_AsCharmapString
+# define PyUnicode_AsEncodedObject PyUnicodeUCS2_AsEncodedObject
+# define PyUnicode_AsEncodedString PyUnicodeUCS2_AsEncodedString
+# define PyUnicode_AsLatin1String PyUnicodeUCS2_AsLatin1String
+# define PyUnicode_AsRawUnicodeEscapeString PyUnicodeUCS2_AsRawUnicodeEscapeString
+# define PyUnicode_AsUTF16String PyUnicodeUCS2_AsUTF16String
+# define PyUnicode_AsUTF8String PyUnicodeUCS2_AsUTF8String
+# define PyUnicode_AsUnicode PyUnicodeUCS2_AsUnicode
+# define PyUnicode_AsUnicodeEscapeString PyUnicodeUCS2_AsUnicodeEscapeString
+# define PyUnicode_AsWideChar PyUnicodeUCS2_AsWideChar
+# define PyUnicode_Compare PyUnicodeUCS2_Compare
+# define PyUnicode_Concat PyUnicodeUCS2_Concat
+# define PyUnicode_Contains PyUnicodeUCS2_Contains
+# define PyUnicode_Count PyUnicodeUCS2_Count
+# define PyUnicode_Decode PyUnicodeUCS2_Decode
+# define PyUnicode_DecodeASCII PyUnicodeUCS2_DecodeASCII
+# define PyUnicode_DecodeCharmap PyUnicodeUCS2_DecodeCharmap
+# define PyUnicode_DecodeLatin1 PyUnicodeUCS2_DecodeLatin1
+# define PyUnicode_DecodeRawUnicodeEscape PyUnicodeUCS2_DecodeRawUnicodeEscape
+# define PyUnicode_DecodeUTF16 PyUnicodeUCS2_DecodeUTF16
+# define PyUnicode_DecodeUTF16Stateful PyUnicodeUCS2_DecodeUTF16Stateful
+# define PyUnicode_DecodeUTF8 PyUnicodeUCS2_DecodeUTF8
+# define PyUnicode_DecodeUTF8Stateful PyUnicodeUCS2_DecodeUTF8Stateful
+# define PyUnicode_DecodeUnicodeEscape PyUnicodeUCS2_DecodeUnicodeEscape
+# define PyUnicode_Encode PyUnicodeUCS2_Encode
+# define PyUnicode_EncodeASCII PyUnicodeUCS2_EncodeASCII
+# define PyUnicode_EncodeCharmap PyUnicodeUCS2_EncodeCharmap
+# define PyUnicode_EncodeDecimal PyUnicodeUCS2_EncodeDecimal
+# define PyUnicode_EncodeLatin1 PyUnicodeUCS2_EncodeLatin1
+# define PyUnicode_EncodeRawUnicodeEscape PyUnicodeUCS2_EncodeRawUnicodeEscape
+# define PyUnicode_EncodeUTF16 PyUnicodeUCS2_EncodeUTF16
+# define PyUnicode_EncodeUTF8 PyUnicodeUCS2_EncodeUTF8
+# define PyUnicode_EncodeUnicodeEscape PyUnicodeUCS2_EncodeUnicodeEscape
+# define PyUnicode_Find PyUnicodeUCS2_Find
+# define PyUnicode_Format PyUnicodeUCS2_Format
+# define PyUnicode_FromEncodedObject PyUnicodeUCS2_FromEncodedObject
+# define PyUnicode_FromObject PyUnicodeUCS2_FromObject
+# define PyUnicode_FromOrdinal PyUnicodeUCS2_FromOrdinal
+# define PyUnicode_FromUnicode PyUnicodeUCS2_FromUnicode
+# define PyUnicode_FromWideChar PyUnicodeUCS2_FromWideChar
+# define PyUnicode_GetDefaultEncoding PyUnicodeUCS2_GetDefaultEncoding
+# define PyUnicode_GetMax PyUnicodeUCS2_GetMax
+# define PyUnicode_GetSize PyUnicodeUCS2_GetSize
+# define PyUnicode_Join PyUnicodeUCS2_Join
+# define PyUnicode_Replace PyUnicodeUCS2_Replace
+# define PyUnicode_Resize PyUnicodeUCS2_Resize
+# define PyUnicode_SetDefaultEncoding PyUnicodeUCS2_SetDefaultEncoding
+# define PyUnicode_Split PyUnicodeUCS2_Split
+# define PyUnicode_RSplit PyUnicodeUCS2_RSplit
+# define PyUnicode_Splitlines PyUnicodeUCS2_Splitlines
+# define PyUnicode_Tailmatch PyUnicodeUCS2_Tailmatch
+# define PyUnicode_Translate PyUnicodeUCS2_Translate
+# define PyUnicode_TranslateCharmap PyUnicodeUCS2_TranslateCharmap
+# define _PyUnicode_AsDefaultEncodedString _PyUnicodeUCS2_AsDefaultEncodedString
+# define _PyUnicode_Fini _PyUnicodeUCS2_Fini
+# define _PyUnicode_Init _PyUnicodeUCS2_Init
+# define _PyUnicode_IsAlpha _PyUnicodeUCS2_IsAlpha
+# define _PyUnicode_IsDecimalDigit _PyUnicodeUCS2_IsDecimalDigit
+# define _PyUnicode_IsDigit _PyUnicodeUCS2_IsDigit
+# define _PyUnicode_IsLinebreak _PyUnicodeUCS2_IsLinebreak
+# define _PyUnicode_IsLowercase _PyUnicodeUCS2_IsLowercase
+# define _PyUnicode_IsNumeric _PyUnicodeUCS2_IsNumeric
+# define _PyUnicode_IsTitlecase _PyUnicodeUCS2_IsTitlecase
+# define _PyUnicode_IsUppercase _PyUnicodeUCS2_IsUppercase
+# define _PyUnicode_IsWhitespace _PyUnicodeUCS2_IsWhitespace
+# define _PyUnicode_ToDecimalDigit _PyUnicodeUCS2_ToDecimalDigit
+# define _PyUnicode_ToDigit _PyUnicodeUCS2_ToDigit
+# define _PyUnicode_ToLowercase _PyUnicodeUCS2_ToLowercase
+# define _PyUnicode_ToNumeric _PyUnicodeUCS2_ToNumeric
+# define _PyUnicode_ToTitlecase _PyUnicodeUCS2_ToTitlecase
+# define _PyUnicode_ToUppercase _PyUnicodeUCS2_ToUppercase
+
+#else
+
+# define PyUnicode_AsASCIIString PyUnicodeUCS4_AsASCIIString
+# define PyUnicode_AsCharmapString PyUnicodeUCS4_AsCharmapString
+# define PyUnicode_AsEncodedObject PyUnicodeUCS4_AsEncodedObject
+# define PyUnicode_AsEncodedString PyUnicodeUCS4_AsEncodedString
+# define PyUnicode_AsLatin1String PyUnicodeUCS4_AsLatin1String
+# define PyUnicode_AsRawUnicodeEscapeString PyUnicodeUCS4_AsRawUnicodeEscapeString
+# define PyUnicode_AsUTF16String PyUnicodeUCS4_AsUTF16String
+# define PyUnicode_AsUTF8String PyUnicodeUCS4_AsUTF8String
+# define PyUnicode_AsUnicode PyUnicodeUCS4_AsUnicode
+# define PyUnicode_AsUnicodeEscapeString PyUnicodeUCS4_AsUnicodeEscapeString
+# define PyUnicode_AsWideChar PyUnicodeUCS4_AsWideChar
+# define PyUnicode_Compare PyUnicodeUCS4_Compare
+# define PyUnicode_Concat PyUnicodeUCS4_Concat
+# define PyUnicode_Contains PyUnicodeUCS4_Contains
+# define PyUnicode_Count PyUnicodeUCS4_Count
+# define PyUnicode_Decode PyUnicodeUCS4_Decode
+# define PyUnicode_DecodeASCII PyUnicodeUCS4_DecodeASCII
+# define PyUnicode_DecodeCharmap PyUnicodeUCS4_DecodeCharmap
+# define PyUnicode_DecodeLatin1 PyUnicodeUCS4_DecodeLatin1
+# define PyUnicode_DecodeRawUnicodeEscape PyUnicodeUCS4_DecodeRawUnicodeEscape
+# define PyUnicode_DecodeUTF16 PyUnicodeUCS4_DecodeUTF16
+# define PyUnicode_DecodeUTF16Stateful PyUnicodeUCS4_DecodeUTF16Stateful
+# define PyUnicode_DecodeUTF8 PyUnicodeUCS4_DecodeUTF8
+# define PyUnicode_DecodeUTF8Stateful PyUnicodeUCS4_DecodeUTF8Stateful
+# define PyUnicode_DecodeUnicodeEscape PyUnicodeUCS4_DecodeUnicodeEscape
+# define PyUnicode_Encode PyUnicodeUCS4_Encode
+# define PyUnicode_EncodeASCII PyUnicodeUCS4_EncodeASCII
+# define PyUnicode_EncodeCharmap PyUnicodeUCS4_EncodeCharmap
+# define PyUnicode_EncodeDecimal PyUnicodeUCS4_EncodeDecimal
+# define PyUnicode_EncodeLatin1 PyUnicodeUCS4_EncodeLatin1
+# define PyUnicode_EncodeRawUnicodeEscape PyUnicodeUCS4_EncodeRawUnicodeEscape
+# define PyUnicode_EncodeUTF16 PyUnicodeUCS4_EncodeUTF16
+# define PyUnicode_EncodeUTF8 PyUnicodeUCS4_EncodeUTF8
+# define PyUnicode_EncodeUnicodeEscape PyUnicodeUCS4_EncodeUnicodeEscape
+# define PyUnicode_Find PyUnicodeUCS4_Find
+# define PyUnicode_Format PyUnicodeUCS4_Format
+# define PyUnicode_FromEncodedObject PyUnicodeUCS4_FromEncodedObject
+# define PyUnicode_FromObject PyUnicodeUCS4_FromObject
+# define PyUnicode_FromOrdinal PyUnicodeUCS4_FromOrdinal
+# define PyUnicode_FromUnicode PyUnicodeUCS4_FromUnicode
+# define PyUnicode_FromWideChar PyUnicodeUCS4_FromWideChar
+# define PyUnicode_GetDefaultEncoding PyUnicodeUCS4_GetDefaultEncoding
+# define PyUnicode_GetMax PyUnicodeUCS4_GetMax
+# define PyUnicode_GetSize PyUnicodeUCS4_GetSize
+# define PyUnicode_Join PyUnicodeUCS4_Join
+# define PyUnicode_Replace PyUnicodeUCS4_Replace
+# define PyUnicode_Resize PyUnicodeUCS4_Resize
+# define PyUnicode_SetDefaultEncoding PyUnicodeUCS4_SetDefaultEncoding
+# define PyUnicode_Split PyUnicodeUCS4_Split
+# define PyUnicode_Splitlines PyUnicodeUCS4_Splitlines
+# define PyUnicode_Tailmatch PyUnicodeUCS4_Tailmatch
+# define PyUnicode_Translate PyUnicodeUCS4_Translate
+# define PyUnicode_TranslateCharmap PyUnicodeUCS4_TranslateCharmap
+# define _PyUnicode_AsDefaultEncodedString _PyUnicodeUCS4_AsDefaultEncodedString
+# define _PyUnicode_Fini _PyUnicodeUCS4_Fini
+# define _PyUnicode_Init _PyUnicodeUCS4_Init
+# define _PyUnicode_IsAlpha _PyUnicodeUCS4_IsAlpha
+# define _PyUnicode_IsDecimalDigit _PyUnicodeUCS4_IsDecimalDigit
+# define _PyUnicode_IsDigit _PyUnicodeUCS4_IsDigit
+# define _PyUnicode_IsLinebreak _PyUnicodeUCS4_IsLinebreak
+# define _PyUnicode_IsLowercase _PyUnicodeUCS4_IsLowercase
+# define _PyUnicode_IsNumeric _PyUnicodeUCS4_IsNumeric
+# define _PyUnicode_IsTitlecase _PyUnicodeUCS4_IsTitlecase
+# define _PyUnicode_IsUppercase _PyUnicodeUCS4_IsUppercase
+# define _PyUnicode_IsWhitespace _PyUnicodeUCS4_IsWhitespace
+# define _PyUnicode_ToDecimalDigit _PyUnicodeUCS4_ToDecimalDigit
+# define _PyUnicode_ToDigit _PyUnicodeUCS4_ToDigit
+# define _PyUnicode_ToLowercase _PyUnicodeUCS4_ToLowercase
+# define _PyUnicode_ToNumeric _PyUnicodeUCS4_ToNumeric
+# define _PyUnicode_ToTitlecase _PyUnicodeUCS4_ToTitlecase
+# define _PyUnicode_ToUppercase _PyUnicodeUCS4_ToUppercase
+
+
+#endif
+
+/* --- Internal Unicode Operations ---------------------------------------- */
+
+/* If you want Python to use the compiler's wctype.h functions instead
+   of the ones supplied with Python, define WANT_WCTYPE_FUNCTIONS or
+   configure Python using --with-wctype-functions.  This reduces the
+   interpreter's code size. */
+
+#if defined(HAVE_USABLE_WCHAR_T) &amp;&amp; defined(WANT_WCTYPE_FUNCTIONS)
+
+#include &lt;wctype.h&gt;
+
+#define Py_UNICODE_ISSPACE(ch) iswspace(ch)
+
+#define Py_UNICODE_ISLOWER(ch) iswlower(ch)
+#define Py_UNICODE_ISUPPER(ch) iswupper(ch)
+#define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
+#define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)
+
+#define Py_UNICODE_TOLOWER(ch) towlower(ch)
+#define Py_UNICODE_TOUPPER(ch) towupper(ch)
+#define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)
+
+#define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
+#define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
+#define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
+
+#define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
+#define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
+#define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)
+
+#define Py_UNICODE_ISALPHA(ch) iswalpha(ch)
+
+#else
+
+#define Py_UNICODE_ISSPACE(ch) _PyUnicode_IsWhitespace(ch)
+
+#define Py_UNICODE_ISLOWER(ch) _PyUnicode_IsLowercase(ch)
+#define Py_UNICODE_ISUPPER(ch) _PyUnicode_IsUppercase(ch)
+#define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
+#define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)
+
+#define Py_UNICODE_TOLOWER(ch) _PyUnicode_ToLowercase(ch)
+#define Py_UNICODE_TOUPPER(ch) _PyUnicode_ToUppercase(ch)
+#define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)
+
+#define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
+#define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
+#define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
+
+#define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
+#define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
+#define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)
+
+#define Py_UNICODE_ISALPHA(ch) _PyUnicode_IsAlpha(ch)
+
+#endif
+
+#define Py_UNICODE_ISALNUM(ch) \
+       (Py_UNICODE_ISALPHA(ch) || \
+        Py_UNICODE_ISDECIMAL(ch) || \
+        Py_UNICODE_ISDIGIT(ch) || \
+        Py_UNICODE_ISNUMERIC(ch))
+
+#define Py_UNICODE_COPY(target, source, length)\
+    (memcpy((target), (source), (length)*sizeof(Py_UNICODE)))
+
+#define Py_UNICODE_FILL(target, value, length) do\
+    {int i; for (i = 0; i &lt; (length); i++) (target)[i] = (value);}\
+    while (0)
+
+#define Py_UNICODE_MATCH(string, offset, substring)\
+    ((*((string)-&gt;str + (offset)) == *((substring)-&gt;str)) &amp;&amp;\
+     !memcmp((string)-&gt;str + (offset), (substring)-&gt;str,\
+             (substring)-&gt;length*sizeof(Py_UNICODE)))
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* --- Unicode Type ------------------------------------------------------- */
+
+typedef struct {
+    PyObject_HEAD
+    int length;			/* Length of raw Unicode data in buffer */
+    Py_UNICODE *str;		/* Raw Unicode buffer */
+    long hash;			/* Hash value; -1 if not set */
+    PyObject *defenc;		/* (Default) Encoded version as Python
+				   string, or NULL; this is used for
+				   implementing the buffer protocol */
+} PyUnicodeObject;
+
+PyAPI_DATA(PyTypeObject) PyUnicode_Type;
+
+#define PyUnicode_Check(op) PyObject_TypeCheck(op, &amp;PyUnicode_Type)
+#define PyUnicode_CheckExact(op) ((op)-&gt;ob_type == &amp;PyUnicode_Type)
+
+/* Fast access macros */
+#define PyUnicode_GET_SIZE(op) \
+        (((PyUnicodeObject *)(op))-&gt;length)
+#define PyUnicode_GET_DATA_SIZE(op) \
+        (((PyUnicodeObject *)(op))-&gt;length * sizeof(Py_UNICODE))
+#define PyUnicode_AS_UNICODE(op) \
+        (((PyUnicodeObject *)(op))-&gt;str)
+#define PyUnicode_AS_DATA(op) \
+        ((const char *)((PyUnicodeObject *)(op))-&gt;str)
+
+/* --- Constants ---------------------------------------------------------- */
+
+/* This Unicode character will be used as replacement character during
+   decoding if the errors argument is set to &quot;replace&quot;. Note: the
+   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
+   Unicode 3.0. */
+
+#define Py_UNICODE_REPLACEMENT_CHARACTER ((Py_UNICODE) 0xFFFD)
+
+/* === Public API ========================================================= */
+
+/* --- Plain Py_UNICODE --------------------------------------------------- */
+
+/* Create a Unicode Object from the Py_UNICODE buffer u of the given
+   size. 
+
+   u may be NULL which causes the contents to be undefined. It is the
+   user's responsibility to fill in the needed data afterwards. Note
+   that modifying the Unicode object contents after construction is
+   only allowed if u was set to NULL.
+
+   The buffer is copied into the new object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromUnicode(
+    const Py_UNICODE *u,        /* Unicode buffer */
+    int size                    /* size of buffer */
+    );
+
+/* Return a read-only pointer to the Unicode object's internal
+   Py_UNICODE buffer. */
+
+PyAPI_FUNC(Py_UNICODE *) PyUnicode_AsUnicode(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Get the length of the Unicode object. */
+
+PyAPI_FUNC(int) PyUnicode_GetSize(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Get the maximum ordinal for a Unicode character. */
+PyAPI_FUNC(Py_UNICODE) PyUnicode_GetMax(void);
+
+/* Resize an already allocated Unicode object to the new size length.
+
+   *unicode is modified to point to the new (resized) object and 0
+   returned on success.
+
+   This API may only be called by the function which also called the
+   Unicode constructor. The refcount on the object must be 1. Otherwise,
+   an error is returned.
+
+   Error handling is implemented as follows: an exception is set, -1
+   is returned and *unicode left untouched.
+
+*/
+
+PyAPI_FUNC(int) PyUnicode_Resize(
+    PyObject **unicode,		/* Pointer to the Unicode object */
+    int length			/* New length */
+    );
+
+/* Coerce obj to an Unicode object and return a reference with
+   *incremented* refcount.
+
+   Coercion is done in the following way:
+
+   1. String and other char buffer compatible objects are decoded
+      under the assumptions that they contain data using the current
+      default encoding. Decoding is done in &quot;strict&quot; mode.
+
+   2. All other objects (including Unicode objects) raise an
+      exception.
+
+   The API returns NULL in case of an error. The caller is responsible
+   for decref'ing the returned objects.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
+    register PyObject *obj, 	/* Object */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Coerce obj to an Unicode object and return a reference with
+   *incremented* refcount.
+   
+   Unicode objects are passed back as-is (subclasses are converted to
+   true Unicode objects), all other objects are delegated to
+   PyUnicode_FromEncodedObject(obj, NULL, &quot;strict&quot;) which results in
+   using the default encoding as basis for decoding the object.
+
+   The API returns NULL in case of an error. The caller is responsible
+   for decref'ing the returned objects.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
+    register PyObject *obj 	/* Object */
+    );
+
+/* --- wchar_t support for platforms which support it --------------------- */
+
+#ifdef HAVE_WCHAR_H
+
+/* Create a Unicode Object from the whcar_t buffer w of the given
+   size.
+
+   The buffer is copied into the new object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
+    register const wchar_t *w,  /* wchar_t buffer */
+    int size                    /* size of buffer */
+    );
+
+/* Copies the Unicode Object contents into the wchar_t buffer w.  At
+   most size wchar_t characters are copied.
+
+   Note that the resulting wchar_t string may or may not be
+   0-terminated.  It is the responsibility of the caller to make sure
+   that the wchar_t string is 0-terminated in case this is required by
+   the application.
+
+   Returns the number of wchar_t characters copied (excluding a
+   possibly trailing 0-termination character) or -1 in case of an
+   error. */
+
+PyAPI_FUNC(int) PyUnicode_AsWideChar(
+    PyUnicodeObject *unicode,   /* Unicode object */
+    register wchar_t *w,        /* wchar_t buffer */
+    int size                    /* size of buffer */
+    );
+
+#endif
+
+/* --- Unicode ordinals --------------------------------------------------- */
+
+/* Create a Unicode Object from the given Unicode code point ordinal. 
+ 
+   The ordinal must be in range(0x10000) on narrow Python builds
+   (UCS2), and range(0x110000) on wide builds (UCS4). A ValueError is
+   raised in case it is not.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);
+
+/* === Builtin Codecs ===================================================== 
+
+   Many of these APIs take two arguments encoding and errors. These
+   parameters encoding and errors have the same semantics as the ones
+   of the builtin unicode() API. 
+
+   Setting encoding to NULL causes the default encoding to be used.
+
+   Error handling is set by errors which may also be set to NULL
+   meaning to use the default handling defined for the codec. Default
+   error handling for all builtin codecs is &quot;strict&quot; (ValueErrors are
+   raised).
+
+   The codecs all use a similar interface. Only deviation from the
+   generic ones are documented.
+
+*/
+
+/* --- Manage the default encoding ---------------------------------------- */
+
+/* Return a Python string holding the default encoded value of the
+   Unicode object. 
+
+   The resulting string is cached in the Unicode object for subsequent
+   usage by this function. The cached version is needed to implement
+   the character buffer interface and will live (at least) as long as
+   the Unicode object itself.
+
+   The refcount of the string is *not* incremented.
+
+   *** Exported for internal use by the interpreter only !!! ***
+
+*/
+
+PyAPI_FUNC(PyObject *) _PyUnicode_AsDefaultEncodedString(
+    PyObject *, const char *);
+
+/* Returns the currently active default encoding.
+
+   The default encoding is currently implemented as run-time settable
+   process global.  This may change in future versions of the
+   interpreter to become a parameter which is managed on a per-thread
+   basis.
+   
+ */
+
+PyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);
+
+/* Sets the currently active default encoding.
+
+   Returns 0 on success, -1 in case of an error.
+   
+ */
+
+PyAPI_FUNC(int) PyUnicode_SetDefaultEncoding(
+    const char *encoding	/* Encoding name in standard form */
+    );
+
+/* --- Generic Codecs ----------------------------------------------------- */
+
+/* Create a Unicode object by decoding the encoded string s of the
+   given size. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Decode(
+    const char *s,              /* encoded string */
+    int size,                   /* size of buffer */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a Py_UNICODE buffer of the given size and returns a 
+   Python string object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Encode(
+    const Py_UNICODE *s,        /* Unicode char buffer */
+    int size,                   /* number of Py_UNICODE chars to encode */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a Unicode object and returns the result as Python
+   object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(
+    PyObject *unicode,	 	/* Unicode object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Encodes a Unicode object and returns the result as Python string
+   object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(
+    PyObject *unicode,	 	/* Unicode object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-7 Codecs ------------------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(
+    const char *string, 	/* UTF-7 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF7(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    int encodeSetO,             /* force the encoder to encode characters in
+                                   Set O, as described in RFC2152 */
+    int encodeWhiteSpace,       /* force the encoder to encode space, tab,
+                                   carriage return and linefeed characters */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-8 Codecs ------------------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(
+    const char *string, 	/* UTF-8 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(
+    const char *string, 	/* UTF-8 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *consumed		/* bytes consumed */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF8(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-16 Codecs ------------------------------------------------------ */
+
+/* Decodes length bytes from a UTF-16 encoded buffer string and returns
+   the corresponding Unicode object.
+
+   errors (if non-NULL) defines the error handling. It defaults
+   to &quot;strict&quot;. 
+
+   If byteorder is non-NULL, the decoder starts decoding using the
+   given byte order:
+
+	*byteorder == -1: little endian
+	*byteorder == 0:  native order
+	*byteorder == 1:  big endian
+
+   In native mode, the first two bytes of the stream are checked for a
+   BOM mark. If found, the BOM mark is analysed, the byte order
+   adjusted and the BOM skipped.  In the other modes, no BOM mark
+   interpretation is done. After completion, *byteorder is set to the
+   current byte order at the end of input data.
+
+   If byteorder is NULL, the codec starts in native order mode.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(
+    const char *string, 	/* UTF-16 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *byteorder		/* pointer to byteorder to use
+				   0=native;-1=LE,1=BE; updated on
+				   exit */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(
+    const char *string, 	/* UTF-16 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *byteorder,		/* pointer to byteorder to use
+				   0=native;-1=LE,1=BE; updated on
+				   exit */
+    int *consumed		/* bytes consumed */
+    );
+
+/* Returns a Python string using the UTF-16 encoding in native byte
+   order. The string always starts with a BOM mark.  */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Returns a Python string object holding the UTF-16 encoded value of
+   the Unicode data.
+
+   If byteorder is not 0, output is written according to the following
+   byte order:
+
+   byteorder == -1: little endian
+   byteorder == 0:  native byte order (writes a BOM mark)
+   byteorder == 1:  big endian
+
+   If byteorder is 0, the output string will always start with the
+   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
+   prepended.
+
+   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
+   UCS-2. This trick makes it possible to add full UTF-16 capabilities
+   at a later point without compromising the APIs.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF16(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    const char *errors,		/* error handling */
+    int byteorder		/* byteorder to use 0=BOM+native;-1=LE,1=BE */
+    );
+
+/* --- Unicode-Escape Codecs ---------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(
+    const char *string, 	/* Unicode-Escape encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUnicodeEscape(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length	 		/* Number of Py_UNICODE chars to encode */
+    );
+
+/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(
+    const char *string, 	/* Raw-Unicode-Escape encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeRawUnicodeEscape(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length	 		/* Number of Py_UNICODE chars to encode */
+    );
+
+/* --- Latin-1 Codecs ----------------------------------------------------- 
+
+   Note: Latin-1 corresponds to the first 256 Unicode ordinals.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(
+    const char *string, 	/* Latin-1 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeLatin1(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- ASCII Codecs ------------------------------------------------------- 
+
+   Only 7-bit ASCII data is excepted. All other codes generate errors.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(
+    const char *string, 	/* ASCII encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeASCII(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- Character Map Codecs ----------------------------------------------- 
+
+   This codec uses mappings to encode and decode characters. 
+
+   Decoding mappings must map single string characters to single
+   Unicode characters, integers (which are then interpreted as Unicode
+   ordinals) or None (meaning &quot;undefined mapping&quot; and causing an
+   error).
+
+   Encoding mappings must map single Unicode characters to single
+   string characters, integers (which are then interpreted as Latin-1
+   ordinals) or None (meaning &quot;undefined mapping&quot; and causing an
+   error).
+
+   If a character lookup fails with a LookupError, the character is
+   copied as-is meaning that its ordinal value will be interpreted as
+   Unicode or Latin-1 ordinal resp. Because of this mappings only need
+   to contain those mappings which map characters to different code
+   points.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(
+    const char *string, 	/* Encoded string */
+    int length,	 		/* size of string */
+    PyObject *mapping,		/* character mapping 
+				   (char ordinal -&gt; unicode ordinal) */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(
+    PyObject *unicode,	 	/* Unicode object */
+    PyObject *mapping		/* character mapping 
+				   (unicode ordinal -&gt; char ordinal) */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeCharmap(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    PyObject *mapping,		/* character mapping 
+				   (unicode ordinal -&gt; char ordinal) */
+    const char *errors		/* error handling */
+    );
+
+/* Translate a Py_UNICODE buffer of the given length by applying a
+   character mapping table to it and return the resulting Unicode
+   object.
+
+   The mapping table must map Unicode ordinal integers to Unicode
+   ordinal integers or None (causing deletion of the character). 
+
+   Mapping tables may be dictionaries or sequences. Unmapped character
+   ordinals (ones which cause a LookupError) are left untouched and
+   are copied as-is.
+
+*/
+
+PyAPI_FUNC(PyObject *) PyUnicode_TranslateCharmap(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    PyObject *table,		/* Translate table */
+    const char *errors		/* error handling */
+    );
+
+#ifdef MS_WIN32
+
+/* --- MBCS codecs for Windows -------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(
+    const char *string,         /* MBCS encoded string */
+    int length,                 /* size of string */
+    const char *errors          /* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(
+    PyObject *unicode           /* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeMBCS(
+    const Py_UNICODE *data,     /* Unicode char buffer */
+    int length,                 /* Number of Py_UNICODE chars to encode */
+    const char *errors          /* error handling */
+    );
+
+#endif /* MS_WIN32 */
+
+/* --- Decimal Encoder ---------------------------------------------------- */
+
+/* Takes a Unicode string holding a decimal value and writes it into
+   an output buffer using standard ASCII digit codes.
+
+   The output buffer has to provide at least length+1 bytes of storage
+   area. The output string is 0-terminated.
+
+   The encoder converts whitespace to ' ', decimal characters to their
+   corresponding ASCII digit and all other Latin-1 characters except
+   \0 as-is. Characters outside this range (Unicode ordinals 1-256)
+   are treated as errors. This includes embedded NULL bytes.
+
+   Error handling is defined by the errors argument:
+
+      NULL or &quot;strict&quot;: raise a ValueError
+      &quot;ignore&quot;: ignore the wrong characters (these are not copied to the
+		output buffer)
+      &quot;replace&quot;: replaces illegal characters with '?'
+
+   Returns 0 on success, -1 on failure.
+
+*/
+
+PyAPI_FUNC(int) PyUnicode_EncodeDecimal(
+    Py_UNICODE *s,		/* Unicode buffer */
+    int length,			/* Number of Py_UNICODE chars to encode */
+    char *output,		/* Output buffer; must have size &gt;= length */
+    const char *errors		/* error handling */
+    );
+
+/* --- Methods &amp; Slots ----------------------------------------------------
+
+   These are capable of handling Unicode objects and strings on input
+   (we refer to them as strings in the descriptions) and return
+   Unicode objects or integers as apporpriate. */
+
+/* Concat two strings giving a new Unicode string. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Concat(
+    PyObject *left,	 	/* Left string */
+    PyObject *right	 	/* Right string */
+    );
+
+/* Split a string giving a list of Unicode strings.
+
+   If sep is NULL, splitting will be done at all whitespace
+   substrings. Otherwise, splits occur at the given separator.
+
+   At most maxsplit splits will be done. If negative, no limit is set.
+
+   Separators are not included in the resulting list.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_Split(
+    PyObject *s,		/* String to split */
+    PyObject *sep,		/* String separator */
+    int maxsplit		/* Maxsplit count */
+    );		
+
+/* Dito, but split at line breaks.
+
+   CRLF is considered to be one line break. Line breaks are not
+   included in the resulting list. */
+    
+PyAPI_FUNC(PyObject*) PyUnicode_Splitlines(
+    PyObject *s,		/* String to split */
+    int keepends		/* If true, line end markers are included */
+    );		
+
+/* Split a string giving a list of Unicode strings.
+
+   If sep is NULL, splitting will be done at all whitespace
+   substrings. Otherwise, splits occur at the given separator.
+
+   At most maxsplit splits will be done. But unlike PyUnicode_Split
+   PyUnicode_RSplit splits from the end of the string. If negative,
+   no limit is set.
+
+   Separators are not included in the resulting list.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_RSplit(
+    PyObject *s,		/* String to split */
+    PyObject *sep,		/* String separator */
+    int maxsplit		/* Maxsplit count */
+    );		
+
+/* Translate a string by applying a character mapping table to it and
+   return the resulting Unicode object.
+
+   The mapping table must map Unicode ordinal integers to Unicode
+   ordinal integers or None (causing deletion of the character). 
+
+   Mapping tables may be dictionaries or sequences. Unmapped character
+   ordinals (ones which cause a LookupError) are left untouched and
+   are copied as-is.
+
+*/
+
+PyAPI_FUNC(PyObject *) PyUnicode_Translate(
+    PyObject *str,		/* String */ 
+    PyObject *table,		/* Translate table */
+    const char *errors		/* error handling */
+    );
+
+/* Join a sequence of strings using the given separator and return
+   the resulting Unicode string. */
+    
+PyAPI_FUNC(PyObject*) PyUnicode_Join(
+    PyObject *separator, 	/* Separator string */
+    PyObject *seq	 	/* Sequence object */
+    );
+
+/* Return 1 if substr matches str[start:end] at the given tail end, 0
+   otherwise. */
+
+PyAPI_FUNC(int) PyUnicode_Tailmatch(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Prefix or Suffix string */
+    int start,			/* Start index */
+    int end,			/* Stop index */
+    int direction		/* Tail end: -1 prefix, +1 suffix */
+    );
+
+/* Return the first position of substr in str[start:end] using the
+   given search direction or -1 if not found. -2 is returned in case
+   an error occurred and an exception is set. */
+
+PyAPI_FUNC(int) PyUnicode_Find(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to find */
+    int start,			/* Start index */
+    int end,			/* Stop index */
+    int direction		/* Find direction: +1 forward, -1 backward */
+    );
+
+/* Count the number of occurrences of substr in str[start:end]. */
+
+PyAPI_FUNC(int) PyUnicode_Count(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to count */
+    int start,			/* Start index */
+    int end			/* Stop index */
+    );
+
+/* Replace at most maxcount occurrences of substr in str with replstr
+   and return the resulting Unicode object. */
+
+PyAPI_FUNC(PyObject *) PyUnicode_Replace(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to find */
+    PyObject *replstr,		/* Substring to replace */
+    int maxcount		/* Max. number of replacements to apply;
+				   -1 = all */
+    );
+
+/* Compare two strings and return -1, 0, 1 for less than, equal,
+   greater than resp. */
+
+PyAPI_FUNC(int) PyUnicode_Compare(
+    PyObject *left,		/* Left string */ 
+    PyObject *right		/* Right string */
+    );
+
+/* Apply a argument tuple or dictionary to a format string and return
+   the resulting Unicode string. */
+
+PyAPI_FUNC(PyObject *) PyUnicode_Format(
+    PyObject *format,		/* Format string */ 
+    PyObject *args		/* Argument tuple or dictionary */
+    );
+
+/* Checks whether element is contained in container and return 1/0
+   accordingly.
+
+   element has to coerce to an one element Unicode string. -1 is
+   returned in case of an error. */
+
+PyAPI_FUNC(int) PyUnicode_Contains(
+    PyObject *container,	/* Container string */ 
+    PyObject *element		/* Element string */
+    );
+
+/* Externally visible for str.strip(unicode) */
+PyAPI_FUNC(PyObject *) _PyUnicode_XStrip(
+    PyUnicodeObject *self,
+    int striptype,
+    PyObject *sepobj
+    );
+
+/* === Characters Type APIs =============================================== */
+
+/* These should not be used directly. Use the Py_UNICODE_IS* and
+   Py_UNICODE_TO* macros instead. 
+
+   These APIs are implemented in Objects/unicodectype.c.
+
+*/
+
+PyAPI_FUNC(int) _PyUnicode_IsLowercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsUppercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsTitlecase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsWhitespace(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsLinebreak(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToLowercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToUppercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToTitlecase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_ToDecimalDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_ToDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(double) _PyUnicode_ToNumeric(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsDecimalDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsNumeric(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsAlpha(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* Py_USING_UNICODE */
+#endif /* !Py_UNICODEOBJECT_H */

Added: trunk/msvc-libs/include/weakrefobject.h
===================================================================
--- trunk/msvc-libs/include/weakrefobject.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/weakrefobject.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,75 @@
+/* Weak references objects for Python. */
+
+#ifndef Py_WEAKREFOBJECT_H
+#define Py_WEAKREFOBJECT_H
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+typedef struct _PyWeakReference PyWeakReference;
+
+/* PyWeakReference is the base struct for the Python ReferenceType, ProxyType,
+ * and CallableProxyType.
+ */
+struct _PyWeakReference {
+    PyObject_HEAD
+
+    /* The object to which this is a weak reference, or Py_None if none.
+     * Note that this is a stealth reference:  wr_object's refcount is
+     * not incremented to reflect this pointer.
+     */
+    PyObject *wr_object;
+
+    /* A callable to invoke when wr_object dies, or NULL if none. */
+    PyObject *wr_callback;
+
+    /* A cache for wr_object's hash code.  As usual for hashes, this is -1
+     * if the hash code isn't known yet.
+     */
+    long hash;
+
+    /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL-
+     * terminated list of weak references to it.  These are the list pointers.
+     * If wr_object goes away, wr_object is set to Py_None, and these pointers
+     * have no meaning then.
+     */
+    PyWeakReference *wr_prev;
+    PyWeakReference *wr_next;
+};
+
+PyAPI_DATA(PyTypeObject) _PyWeakref_RefType;
+PyAPI_DATA(PyTypeObject) _PyWeakref_ProxyType;
+PyAPI_DATA(PyTypeObject) _PyWeakref_CallableProxyType;
+
+#define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &amp;_PyWeakref_RefType)
+#define PyWeakref_CheckRefExact(op) \
+        ((op)-&gt;ob_type == &amp;_PyWeakref_RefType)
+#define PyWeakref_CheckProxy(op) \
+        (((op)-&gt;ob_type == &amp;_PyWeakref_ProxyType) || \
+         ((op)-&gt;ob_type == &amp;_PyWeakref_CallableProxyType))
+
+/* This macro calls PyWeakref_CheckRef() last since that can involve a
+   function call; this makes it more likely that the function call
+   will be avoided. */
+#define PyWeakref_Check(op) \
+        (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
+
+
+PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
+                                              PyObject *callback);
+PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
+                                                PyObject *callback);
+PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+
+PyAPI_FUNC(long) _PyWeakref_GetWeakrefCount(PyWeakReference *head);
+
+PyAPI_FUNC(void) _PyWeakref_ClearRef(PyWeakReference *self);
+
+#define PyWeakref_GET_OBJECT(ref) (((PyWeakReference *)(ref))-&gt;wr_object)
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_WEAKREFOBJECT_H */

Added: trunk/msvc-libs/include/winalleg.h
===================================================================
--- trunk/msvc-libs/include/winalleg.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/winalleg.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,117 @@
+/*         ______   ___    ___
+ *        /\  _  \ /\_ \  /\_ \
+ *        \ \ \L\ \\//\ \ \//\ \      __     __   _ __   ___
+ *         \ \  __ \ \ \ \  \ \ \   /'__`\ /'_ `\/\`'__\/ __`\
+ *          \ \ \/\ \ \_\ \_ \_\ \_/\  __//\ \L\ \ \ \//\ \L\ \
+ *           \ \_\ \_\/\____\/\____\ \____\ \____ \ \_\\ \____/
+ *            \/_/\/_/\/____/\/____/\/____/\/___L\ \/_/ \/___/
+ *                                           /\____/
+ *                                           \_/__/
+ *
+ *      Windows header file for the Allegro library.
+ *
+ *      It must be included by Allegro programs that need to use
+ *      direct Win32 API calls and by Win32 programs that need to
+ *      interface with Allegro.
+ *
+ *      By Shawn Hargreaves.
+ *
+ *      See readme.txt for copyright information.
+ */
+
+
+#ifndef WIN_ALLEGRO_H
+#define WIN_ALLEGRO_H
+
+#ifndef ALLEGRO_H
+   #error Please include allegro.h before winalleg.h!
+#endif
+
+#ifdef ALLEGRO_SRC
+   #define WIN32_LEAN_AND_MEAN   /* to save compilation time */
+#endif
+
+
+
+/* bodges to avoid conflicts between Allegro and Windows */
+#define BITMAP WINDOWS_BITMAP
+
+#if (!defined SCAN_EXPORT) &amp;&amp; (!defined SCAN_DEPEND)
+   #ifdef ALLEGRO_AND_MFC
+      #ifdef DEBUGMODE
+         #define AL_ASSERT(condition)     { if (!(condition)) al_assert(__FILE__, __LINE__); }
+         #define AL_TRACE                 al_trace
+      #else
+         #define AL_ASSERT(condition)
+         #define AL_TRACE                 1 ? (void) 0 : al_trace
+      #endif
+
+      #undef TRACE
+      #undef ASSERT
+
+      #include &lt;afxwin.h&gt;
+   #else
+      #include &lt;windows.h&gt;
+   #endif
+#endif
+
+#define WINDOWS_RGB(r,g,b)  ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))&lt;&lt;8))|(((DWORD)(BYTE)(b))&lt;&lt;16)))
+
+#undef BITMAP
+#undef RGB
+
+
+
+/* Allegro's Win32 specific interface */
+#ifdef __cplusplus
+   extern &quot;C&quot; {
+#endif
+
+
+/* external graphics driver support */
+typedef struct WIN_GFX_DRIVER {
+   int has_backing_store;
+   AL_METHOD(void, switch_in, (void));
+   AL_METHOD(void, switch_out, (void));
+   AL_METHOD(void, enter_sysmode, (void));
+   AL_METHOD(void, exit_sysmode, (void));
+   AL_METHOD(void, move, (int x, int y, int w, int h));
+   AL_METHOD(void, iconify, (void));
+   AL_METHOD(void, paint, (RECT *rect));
+} WIN_GFX_DRIVER;
+
+AL_VAR(WIN_GFX_DRIVER *, win_gfx_driver);
+
+AL_FUNC(void, win_grab_input, (void));
+
+
+/* external window support */
+AL_FUNC(HWND, win_get_window, (void));
+AL_FUNC(void, win_set_window, (HWND wnd));
+AL_FUNC(void, win_set_wnd_create_proc, (AL_METHOD(HWND, proc, (WNDPROC))));
+
+
+/* GDI to DirectDraw routines */
+AL_FUNC(HDC, win_get_dc, (BITMAP *bmp));
+AL_FUNC(void, win_release_dc, (BITMAP *bmp, HDC dc));
+
+
+/* GDI routines */
+AL_FUNC(void, set_gdi_color_format, (void));
+AL_FUNC(void, set_palette_to_hdc, (HDC dc, PALETTE pal));
+AL_FUNC(HPALETTE, convert_palette_to_hpalette, (PALETTE pal));
+AL_FUNC(void, convert_hpalette_to_palette, (HPALETTE hpal, PALETTE pal));
+AL_FUNC(HBITMAP, convert_bitmap_to_hbitmap, (BITMAP *bitmap));
+AL_FUNC(BITMAP *, convert_hbitmap_to_bitmap, (HBITMAP bitmap));
+AL_FUNC(void, draw_to_hdc, (HDC dc, BITMAP *bitmap, int x, int y));
+AL_FUNC(void, blit_to_hdc, (BITMAP *bitmap, HDC dc, int src_x, int src_y, int dest_x, int dest_y, int w, int h));
+AL_FUNC(void, stretch_blit_to_hdc, (BITMAP *bitmap, HDC dc, int src_x, int src_y, int src_w, int src_h, int dest_x, int dest_y, int dest_w, int dest_h));
+AL_FUNC(void, blit_from_hdc, (HDC dc, BITMAP *bitmap, int src_x, int src_y, int dest_x, int dest_y, int w, int h));
+AL_FUNC(void, stretch_blit_from_hdc, (HDC hdc, BITMAP *bitmap, int src_x, int src_y, int src_w, int src_h, int dest_x, int dest_y, int dest_w, int dest_h));
+
+
+#ifdef __cplusplus
+   }
+#endif
+
+#endif          /* ifndef WIN_ALLEGRO_H */

Added: trunk/msvc-libs/include/zconf.h
===================================================================
--- trunk/msvc-libs/include/zconf.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/zconf.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,332 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The &quot;standard&quot; zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define alloc_func            z_alloc_func
+#  define free_func             z_free_func
+#  define in_func               z_in_func
+#  define out_func              z_out_func
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) &amp;&amp; !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) &amp;&amp; !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) &amp;&amp; !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) &amp;&amp; !defined(WIN32)
+#  if !defined(__GNUC__) &amp;&amp; !defined(__FLAT__) &amp;&amp; !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ &gt;= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) &amp;&amp; (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) &amp;&amp; !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) &amp;&amp; !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS=&quot;-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7&quot;
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 &lt;&lt; windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) &amp;&amp; (!defined(__BORLANDC__) || (__BORLANDC__ &gt;= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include &lt;windows.h&gt;
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
+#  include &lt;sys/types.h&gt; /* for off_t */
+#  include &lt;unistd.h&gt;    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include &lt;unixio.h&gt;   /* for off_t */
+#  endif
+#  define z_off_t off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus &quot;offset&quot; */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,&quot;DEIN&quot;)
+#   pragma map(deflateInit2_,&quot;DEIN2&quot;)
+#   pragma map(deflateEnd,&quot;DEEND&quot;)
+#   pragma map(deflateBound,&quot;DEBND&quot;)
+#   pragma map(inflateInit_,&quot;ININ&quot;)
+#   pragma map(inflateInit2_,&quot;ININ2&quot;)
+#   pragma map(inflateEnd,&quot;INEND&quot;)
+#   pragma map(inflateSync,&quot;INSY&quot;)
+#   pragma map(inflateSetDictionary,&quot;INSEDI&quot;)
+#   pragma map(compressBound,&quot;CMBND&quot;)
+#   pragma map(inflate_table,&quot;INTABL&quot;)
+#   pragma map(inflate_fast,&quot;INFA&quot;)
+#   pragma map(inflate_copyright,&quot;INCOPY&quot;)
+#endif
+
+#endif /* ZCONF_H */

Added: trunk/msvc-libs/include/zlib.h
===================================================================
--- trunk/msvc-libs/include/zlib.h	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/msvc-libs/include/zlib.h	2005-07-24 17:51:13 UTC (rev 171)
@@ -0,0 +1,1357 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.3, July 18th, 2005
+
+  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">jloup at gzip.org</A>          <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">madler at alumni.caltech.edu</A>
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files <A HREF="http://www.ietf.org/rfc/rfc1950.txt">http://www.ietf.org/rfc/rfc1950.txt</A>
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include &quot;zconf.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define ZLIB_VERSION &quot;1.2.3&quot;
+#define ZLIB_VERNUM 0x1230
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with &quot;gz&quot;.  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: binary or text */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+typedef struct gz_header_s {
+    int     text;       /* true if compressed data believed to be text */
+    uLong   time;       /* modification time */
+    int     xflags;     /* extra flags (not used when writing a gzip file) */
+    int     os;         /* operating system */
+    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
+    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
+    uInt    extra_max;  /* space at extra (only when reading header) */
+    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
+    uInt    name_max;   /* space at name (only when reading header) */
+    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
+    uInt    comm_max;   /* space at comment (only when reading header) */
+    int     hcrc;       /* true if there was or will be a header crc */
+    int     done;       /* true when done reading gzip header (not used
+                           when writing a gzip file) */
+} gz_header;
+
+typedef gz_header FAR *gz_headerp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_FIXED               4
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_TEXT     1
+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions &lt; 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/*
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
+  decide how much data to accumualte before producing output, in order to
+  maximize compression.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out is greater than six to avoid repeated flush markers due to
+  avail_out == 0 on return.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  the value returned by deflateBound (see below). If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm-&gt;adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update strm-&gt;data_type if it can make a good guess about
+  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+  fatal, and deflate() can be called again with more input and more output
+  space to continue compressing.
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/*
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it gets to the next deflate block boundary. When decoding the
+  zlib or gzip format, this will cause inflate() to return immediately after
+  the header and before the first block. When doing a raw inflate, inflate()
+  will go ahead and process the first block, and will return when it gets to
+  the end of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm-&gt;data_type to the
+  number of unused bits in the last byte taken from strm-&gt;next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm-&gt;next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm-&gt;adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm-&gt;adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer). It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+   determines the window size. deflate() will then generate raw deflate data
+   with no zlib header or trailer, and will not compute an adler32 check value.
+
+     windowBits can also be greater than 15 for optional gzip encoding. Add
+   16 to windowBits to write a simple gzip header and trailer around the
+   compressed data instead of a zlib wrapper. The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero),
+   no header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm-&gt;adler is a crc32 instead of an adler32.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match), or Z_RLE to limit match distances to one (run-length
+   encoding). Filtered data consists mostly of small values with a somewhat
+   random distribution. In this case, the compression algorithm is tuned to
+   compress them better. The effect of Z_FILTERED is to force more Huffman
+   coding and less string matching; it is somewhat intermediate between
+   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+   parameter only affects the compression ratio but not the correctness of the
+   compressed output even if it is not set appropriately.  Z_FIXED prevents the
+   use of dynamic Huffman codes, allowing for a simpler decoder for special
+   applications.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front. In addition, the
+   current implementation of deflate will use at most the window size minus
+   262 bytes of the provided dictionary.
+
+     Upon return of this function, strm-&gt;adler is set to the adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.) If a raw deflate was requested, then the
+   adler32 value is not computed and strm-&gt;adler is not set.
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                      int level,
+                                      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm-&gt;avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm-&gt;avail_out was zero.
+*/
+
+ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
+                                    int good_length,
+                                    int max_lazy,
+                                    int nice_length,
+                                    int max_chain));
+/*
+     Fine tune deflate's internal compression parameters.  This should only be
+   used by someone who understands the algorithm used by zlib's deflate for
+   searching for the best matching string, and even then only by the most
+   fanatic optimizer trying to squeeze out the last compressed bit for their
+   specific input data.  Read the deflate.c source code for the meaning of the
+   max_lazy, good_length, nice_length, and max_chain parameters.
+
+     deflateTune() can be called after deflateInit() or deflateInit2(), and
+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
+ */
+
+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                       uLong sourceLen));
+/*
+     deflateBound() returns an upper bound on the compressed size after
+   deflation of sourceLen bytes.  It must be called after deflateInit()
+   or deflateInit2().  This would be used to allocate an output buffer
+   for deflation in a single pass, and so would be called before deflate().
+*/
+
+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     deflatePrime() inserts bits in the deflate output stream.  The intent
+  is that this function is used to start off the deflate output with the
+  bits leftover from a previous deflate stream when appending to it.  As such,
+  this function can only be used for raw deflate, and must be used before the
+  first deflate() call after a deflateInit2() or deflateReset().  bits must be
+  less than or equal to 16, and that many of the least significant bits of
+  value will be inserted in the output.
+
+      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      deflateSetHeader() provides gzip header information for when a gzip
+   stream is requested by deflateInit2().  deflateSetHeader() may be called
+   after deflateInit2() or deflateReset() and before the first call of
+   deflate().  The text, time, os, extra field, name, and comment information
+   in the provided gz_header structure are written to the gzip header (xflag is
+   ignored -- the extra flags are set according to the compression level).  The
+   caller must assure that, if not Z_NULL, name and comment are terminated with
+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
+   available there.  If hcrc is true, a gzip header crc is included.  Note that
+   the current versions of the command-line version of gzip (up through version
+   1.3.x) do not support header crc's, and will report that it is a &quot;multi-part
+   gzip file&quot; and give up.
+
+      If deflateSetHeader is not used, the default gzip header has text false,
+   the time set to zero, and os set to 255, with no extra, name, or comment
+   fields.  The gzip header is returned to the default state by deflateReset().
+
+      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. windowBits must be greater than or equal to the windowBits value
+   provided to deflateInit2() while compressing, or it must be equal to 15 if
+   deflateInit2() was not used. If a compressed stream with a larger window
+   size is given as input, inflate() will return with the error code
+   Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+   determines the window size. inflate() will then process raw deflate data,
+   not looking for a zlib or gzip header, not generating a check value, and not
+   looking for any check values for comparison at the end of the stream. This
+   is for use with other formats that use the deflate compressed data format
+   such as zip.  Those formats provide their own check values. If a custom
+   format is developed using the raw deflate format for compressed data, it is
+   recommended that a check value such as an adler32 or a crc32 be applied to
+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+   most applications, the zlib format should be used as is. Note that comments
+   above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+     windowBits can also be greater than 15 for optional gzip decoding. Add
+   32 to windowBits to enable zlib and gzip decoding with automatic header
+   detection, or add 16 to decode only the gzip format (the zlib format will
+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm-&gt;adler is
+   a crc32 instead of an adler32.
+
+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg
+   is set to null if there is no error message.  inflateInit2 does not perform
+   any decompression apart from reading the zlib header if present: this will
+   be done by inflate(). (So next_in and avail_in may be modified, but next_out
+   and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate,
+   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by that call of inflate.
+   The compressor and decompressor must use exactly the same dictionary (see
+   deflateSetDictionary).  For raw inflate, this function can be called
+   immediately after inflateInit2() or inflateReset() and before any call of
+   inflate() to set the dictionary.  The application must insure that the
+   dictionary that was used for compression is provided.
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/*
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when randomly accessing a large stream.  The
+   first pass through the stream can periodically record the inflate state,
+   allowing restarting inflate at those points when randomly accessing the
+   stream.
+
+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     This function inserts bits in the inflate input stream.  The intent is
+  that this function is used to start inflating at a bit position in the
+  middle of a byte.  The provided bits will be used before any bytes are used
+  from next_in.  This function should only be used with raw inflate, and
+  should be used before the first inflate() call after inflateInit2() or
+  inflateReset().  bits must be less than or equal to 16, and that many of the
+  least significant bits of value will be inserted in the input.
+
+      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+      inflateGetHeader() requests that gzip header information be stored in the
+   provided gz_header structure.  inflateGetHeader() may be called after
+   inflateInit2() or inflateReset(), and before the first call of inflate().
+   As inflate() processes the gzip stream, head-&gt;done is zero until the header
+   is completed, at which time head-&gt;done is set to one.  If a zlib stream is
+   being decoded, then head-&gt;done is set to -1 to indicate that there will be
+   no gzip header information forthcoming.  Note that Z_BLOCK can be used to
+   force inflate() to return immediately after header processing is complete
+   and before any actual data is decompressed.
+
+      The text, time, xflags, and os fields are filled in with the gzip header
+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
+   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max
+   contains the maximum number of bytes to write to extra.  Once done is true,
+   extra_len contains the actual extra field length, and extra contains the
+   extra field, or that field truncated if extra_max is less than extra_len.
+   If name is not Z_NULL, then up to name_max characters are written there,
+   terminated with a zero unless the length is greater than name_max.  If
+   comment is not Z_NULL, then up to comm_max characters are written there,
+   terminated with a zero unless the length is greater than comm_max.  When
+   any of extra, name, or comment are not Z_NULL and the respective field is
+   not present in the header, then that field is set to Z_NULL to signal its
+   absence.  This allows the use of deflateSetHeader() with the returned
+   structure to duplicate the header.  However if those fields are set to
+   allocated memory, then the application will need to save those pointers
+   elsewhere so that they can be eventually freed.
+
+      If inflateGetHeader is not used, then the header information is simply
+   discarded.  The header is always checked for validity, including the header
+   CRC if present.  inflateReset() will reset the process to discard the header
+   information.  The application would need to call inflateGetHeader() again to
+   retrieve the header from the next gzip stream.
+
+      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
+                                        unsigned char FAR *window));
+
+     Initialize the internal stream state for decompression using inflateBack()
+   calls.  The fields zalloc, zfree and opaque in strm must be initialized
+   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   derived memory allocation routines are used.  windowBits is the base two
+   logarithm of the window size, in the range 8..15.  window is a caller
+   supplied buffer of that size.  Except for special applications where it is
+   assured that deflate was used with small window sizes, windowBits must be 15
+   and a 32K byte window must be supplied to be able to decompress general
+   deflate streams.
+
+     See inflateBack() for the usage of these routines.
+
+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+   be allocated, or Z_VERSION_ERROR if the version of the library does not
+   match the version of the header file.
+*/
+
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
+
+ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
+                                    in_func in, void FAR *in_desc,
+                                    out_func out, void FAR *out_desc));
+/*
+     inflateBack() does a raw inflate with a single call using a call-back
+   interface for input and output.  This is more efficient than inflate() for
+   file i/o applications in that it avoids copying between the output and the
+   sliding window by simply making the window itself the output buffer.  This
+   function trusts the application to not change the output buffer passed by
+   the output function, at least until inflateBack() returns.
+
+     inflateBackInit() must be called first to allocate the internal state
+   and to initialize the state with the user-provided window buffer.
+   inflateBack() may then be used multiple times to inflate a complete, raw
+   deflate stream with each call.  inflateBackEnd() is then called to free
+   the allocated state.
+
+     A raw deflate stream is one with no zlib or gzip header or trailer.
+   This routine would normally be used in a utility that reads zip or gzip
+   files and writes out uncompressed files.  The utility would decode the
+   header and process the trailer on its own, hence this routine expects
+   only the raw deflate stream to decompress.  This is different from the
+   normal behavior of inflate(), which expects either a zlib or gzip header and
+   trailer around the deflate stream.
+
+     inflateBack() uses two subroutines supplied by the caller that are then
+   called by inflateBack() for input and output.  inflateBack() calls those
+   routines until it reads a complete deflate stream and writes out all of the
+   uncompressed data, or until it encounters an error.  The function's
+   parameters and return types are defined above in the in_func and out_func
+   typedefs.  inflateBack() will call in(in_desc, &amp;buf) which should return the
+   number of bytes of provided input, and a pointer to that input in buf.  If
+   there is no input available, in() must return zero--buf is ignored in that
+   case--and inflateBack() will return a buffer error.  inflateBack() will call
+   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+   should return zero on success, or non-zero on failure.  If out() returns
+   non-zero, inflateBack() will return with an error.  Neither in() nor out()
+   are permitted to change the contents of the window provided to
+   inflateBackInit(), which is also the buffer that out() uses to write from.
+   The length written by out() will be at most the window size.  Any non-zero
+   amount of input may be provided by in().
+
+     For convenience, inflateBack() can be provided input on the first call by
+   setting strm-&gt;next_in and strm-&gt;avail_in.  If that input is exhausted, then
+   in() will be called.  Therefore strm-&gt;next_in must be initialized before
+   calling inflateBack().  If strm-&gt;next_in is Z_NULL, then in() will be called
+   immediately for input.  If strm-&gt;next_in is not Z_NULL, then strm-&gt;avail_in
+   must also be initialized, and then if strm-&gt;avail_in is not zero, input will
+   initially be taken from strm-&gt;next_in[0 .. strm-&gt;avail_in - 1].
+
+     The in_desc and out_desc parameters of inflateBack() is passed as the
+   first parameter of in() and out() respectively when they are called.  These
+   descriptors can be optionally used to pass any information that the caller-
+   supplied in() and out() functions need to do their job.
+
+     On return, inflateBack() will set strm-&gt;next_in and strm-&gt;avail_in to
+   pass back any unused input that was provided by the last in() call.  The
+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format
+   error in the deflate stream (in which case strm-&gt;msg is set to indicate the
+   nature of the error), or Z_STREAM_ERROR if the stream was not properly
+   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+   distinguished using strm-&gt;next_in which will be Z_NULL only if in() returned
+   an error.  If strm-&gt;next is not Z_NULL, then the Z_BUF_ERROR was due to
+   out() returning non-zero.  (in() will always be called before out(), so
+   strm-&gt;next_in is assured to be defined if out() returns non-zero.)  Note
+   that inflateBack() cannot return Z_OK.
+*/
+
+ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
+/*
+     All memory allocated by inflateBackInit() is freed.
+
+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+   state was inconsistent.
+*/
+
+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+/* Return flags indicating compile-time options.
+
+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+     1.0: size of uInt
+     3.2: size of uLong
+     5.4: size of voidpf (pointer)
+     7.6: size of z_off_t
+
+    Compiler, assembler, and debug options:
+     8: DEBUG
+     9: ASMV or ASMINF -- use ASM code
+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+     11: 0 (reserved)
+
+    One-time table building (smaller code, but not thread-safe if true):
+     12: BUILDFIXED -- build static block decoding tables when needed
+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+     14,15: 0 (reserved)
+
+    Library content (indicates missing functionality):
+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                          deflate code when not needed)
+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                    and decode gzip streams (to avoid linking crc code)
+     18-19: 0 (reserved)
+
+    Operation variations (changes in library functionality):
+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+     21: FASTEST -- deflate algorithm with only one, lowest compression level
+     22,23: 0 (reserved)
+
+    The sprintf variant used by gzprintf (zero is best):
+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+    Remainder:
+     27-31: 0 (reserved)
+ */
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least the value returned
+   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least the value returned by
+   compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+/*
+     compressBound() returns an upper bound on the compressed size after
+   compress() or compress2() on sourceLen bytes.  It would be used before
+   a compress() or compress2() call to allocate the destination buffer.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen (&quot;rb&quot; or &quot;wb&quot;) but can also include a compression level
+   (&quot;wb9&quot;) or a strategy: 'f' for filtered data as in &quot;wb6f&quot;, 'h' for
+   Huffman only compression as in &quot;wb1h&quot;, or 'R' for run-length encoding
+   as in &quot;wb1R&quot;. (See the description of deflateInit2 for more information
+   about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                   voidpc buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).  The number of
+   uncompressed bytes written is limited to 4095. The caller should assure that
+   this limit is not exceeded. If it is exceeded, then gzprintf() will return
+   return an error (0) with nothing written. In this case, there may also be a
+   buffer overflow with unpredictable consequences, which is possible only if
+   zlib was compiled with the insecure functions sprintf() or vsprintf()
+   because the secure snprintf() or vsnprintf() functions were not available.
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+/*
+      Push one character back onto the stream to be read again later.
+   Only one character of push-back is allowed.  gzungetc() returns the
+   character pushed, or -1 on failure.  gzungetc() will fail if a
+   character has been pushed but not read yet, or if c is -1. The pushed
+   character will be discarded if the stream is repositioned with gzseek()
+   or gzrewind().
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                      z_off_t offset, int whence));
+/*
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
+/*
+     Returns 1 if file is being read directly without decompression, otherwise
+   zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+/*
+     Clears the error and end-of-file flags for file. This is analogous to the
+   clearerr() function in stdio. This is useful for continuing to read a gzip
+   file that is being written concurrently.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
+                                          z_off_t len2));
+/*
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32. If buf is NULL, this function returns the required initial
+   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   performed within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
+
+/*
+     Combine two CRC-32 check values into one.  For two sequences of bytes,
+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
+   len2.
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
+                                         unsigned char FAR *window,
+                                         const char *version,
+                                         int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) &amp;&amp; !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */

Added: trunk/msvc-libs/lib/SDL.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/SDL.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/SDL_mixer.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/SDL_mixer.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/SDLmain.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/SDLmain.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/aldat.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/aldat.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/alld.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/alld.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/alld_s.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/alld_s.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/alleg.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/alleg.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/alleg_s.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/alleg_s.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/allp.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/allp.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/allp_s.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/allp_s.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/python24.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/python24.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/msvc-libs/lib/z.lib
===================================================================
(Binary files differ)


Property changes on: trunk/msvc-libs/lib/z.lib
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/source/games/ggob.cpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -631,7 +631,7 @@
     e = random() % (e + 3);
     if (e &lt; pow(2.5*base,0.4) - 1) 
       e = random() % num_enemy_types;
-    if (e &gt; sqrt(3*base) + 2) 
+    if (e &gt; sqrt( 3.0 * base) + 2) 
       e = random() % (e + 1);
     //if (e &gt; num_enemy_types * 2) e = e % num_enemy_types;
     e = e;

Modified: trunk/source/generated/tml_wrap.cpp
===================================================================
--- trunk/source/generated/tml_wrap.cpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/source/generated/tml_wrap.cpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -1,3294 +1,6832 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
- * Version 1.3.21
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-
-#ifdef __cplusplus
-template&lt;class T&gt; class SwigValueWrapper {
-    T *tt;
-public:
-    SwigValueWrapper() : tt(0) { }
-    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
-    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
-    ~SwigValueWrapper() { delete tt; } 
-    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
-    operator T&amp;() const { return *tt; }
-    T *operator&amp;() { return tt; }
-private:
-    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
-};                                                    
-#endif
-
-
-#include &quot;Python.h&quot;
-
-/*************************************************************** -*- c -*-
- * python/precommon.swg
- *
- * Rename all exported symbols from common.swg, to avoid symbol
- * clashes if multiple interpreters are included
- *
- ************************************************************************/
-
-#define SWIG_TypeRegister    SWIG_Python_TypeRegister
-#define SWIG_TypeCheck       SWIG_Python_TypeCheck
-#define SWIG_TypeCast        SWIG_Python_TypeCast
-#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
-#define SWIG_TypeName        SWIG_Python_TypeName
-#define SWIG_TypeQuery       SWIG_Python_TypeQuery
-#define SWIG_TypeClientData  SWIG_Python_TypeClientData
-#define SWIG_PackData        SWIG_Python_PackData 
-#define SWIG_UnpackData      SWIG_Python_UnpackData 
-
-
-/***********************************************************************
- * common.swg
- *
- *     This file contains generic SWIG runtime support for pointer
- *     type checking as well as a few commonly used macros to control
- *     external linkage.
- *
- * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
- *
- * Copyright (c) 1999-2000, The University of Chicago
- * 
- * This file may be freely redistributed without license or fee provided
- * this copyright message remains intact.
- ************************************************************************/
-
-#include &lt;string.h&gt;
-
-#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#  if defined(_MSC_VER) || defined(__GNUC__)
-#    if defined(STATIC_LINKED)
-#      define SWIGEXPORT(a) a
-#      define SWIGIMPORT(a) extern a
-#    else
-#      define SWIGEXPORT(a) __declspec(dllexport) a
-#      define SWIGIMPORT(a) extern a
-#    endif
-#  else
-#    if defined(__BORLANDC__)
-#      define SWIGEXPORT(a) a _export
-#      define SWIGIMPORT(a) a _export
-#    else
-#      define SWIGEXPORT(a) a
-#      define SWIGIMPORT(a) a
-#    endif
-#  endif
-#else
-#  define SWIGEXPORT(a) a
-#  define SWIGIMPORT(a) a
-#endif
-
-#ifdef SWIG_GLOBAL
-#  define SWIGRUNTIME(a) SWIGEXPORT(a)
-#else
-#  define SWIGRUNTIME(a) static a
-#endif
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-typedef void *(*swig_converter_func)(void *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-typedef struct swig_type_info {
-  const char             *name;
-  swig_converter_func     converter;
-  const char             *str;
-  void                   *clientdata;
-  swig_dycast_func        dcast;
-  struct swig_type_info  *next;
-  struct swig_type_info  *prev;
-} swig_type_info;
-
-#ifdef SWIG_NOINCLUDE
-
-SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
-SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
-SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
-SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
-SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
-SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
-SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
-SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
-SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);
-
-#else
-
-static swig_type_info *swig_type_list = 0;
-
-/* Register a type mapping with the type-checking */
-SWIGRUNTIME(swig_type_info *)
-SWIG_TypeRegister(swig_type_info *ti) {
-  swig_type_info *tc, *head, *ret, *next;
-  /* Check to see if this type has already been registered */
-  tc = swig_type_list;
-  while (tc) {
-    if (strcmp(tc-&gt;name, ti-&gt;name) == 0) {
-      /* Already exists in the table.  Just add additional types to the list */
-      if (tc-&gt;clientdata) ti-&gt;clientdata = tc-&gt;clientdata;
-      head = tc;
-      next = tc-&gt;next;
-      goto l1;
-    }
-    tc = tc-&gt;prev;
-  }
-  head = ti;
-  next = 0;
-
-  /* Place in list */
-  ti-&gt;prev = swig_type_list;
-  swig_type_list = ti;
-
-  /* Build linked lists */
-  l1:
-  ret = head;
-  tc = ti + 1;
-  /* Patch up the rest of the links */
-  while (tc-&gt;name) {
-    head-&gt;next = tc;
-    tc-&gt;prev = head;
-    head = tc;
-    tc++;
-  }
-  if (next) next-&gt;prev = head;
-  head-&gt;next = next;
-  return ret;
-}
-
-/* Check the typename */
-SWIGRUNTIME(swig_type_info *) 
-SWIG_TypeCheck(char *c, swig_type_info *ty) {
-  swig_type_info *s;
-  if (!ty) return 0;        /* Void pointer */
-  s = ty-&gt;next;             /* First element always just a name */
-  do {
-    if (strcmp(s-&gt;name,c) == 0) {
-      if (s == ty-&gt;next) return s;
-      /* Move s to the top of the linked list */
-      s-&gt;prev-&gt;next = s-&gt;next;
-      if (s-&gt;next) {
-        s-&gt;next-&gt;prev = s-&gt;prev;
-      }
-      /* Insert s as second element in the list */
-      s-&gt;next = ty-&gt;next;
-      if (ty-&gt;next) ty-&gt;next-&gt;prev = s;
-      ty-&gt;next = s;
-      s-&gt;prev = ty;
-      return s;
-    }
-    s = s-&gt;next;
-  } while (s &amp;&amp; (s != ty-&gt;next));
-  return 0;
-}
-
-/* Cast a pointer up an inheritance hierarchy */
-SWIGRUNTIME(void *) 
-SWIG_TypeCast(swig_type_info *ty, void *ptr) {
-  if ((!ty) || (!ty-&gt;converter)) return ptr;
-  return (*ty-&gt;converter)(ptr);
-}
-
-/* Dynamic pointer casting. Down an inheritance hierarchy */
-SWIGRUNTIME(swig_type_info *) 
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty-&gt;dcast) return ty;
-  while (ty &amp;&amp; (ty-&gt;dcast)) {
-    ty = (*ty-&gt;dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/* Return the name associated with this type */
-SWIGRUNTIME(const char *)
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty-&gt;name;
-}
-
-/* Search for a swig_type_info structure */
-SWIGRUNTIME(swig_type_info *)
-SWIG_TypeQuery(const char *name) {
-  swig_type_info *ty = swig_type_list;
-  while (ty) {
-    if (ty-&gt;str &amp;&amp; (strcmp(name,ty-&gt;str) == 0)) return ty;
-    if (ty-&gt;name &amp;&amp; (strcmp(name,ty-&gt;name) == 0)) return ty;
-    ty = ty-&gt;prev;
-  }
-  return 0;
-}
-
-/* Set the clientdata field for a type */
-SWIGRUNTIME(void)
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_type_info *tc, *equiv;
-  if (ti-&gt;clientdata == clientdata) return;
-  ti-&gt;clientdata = clientdata;
-  equiv = ti-&gt;next;
-  while (equiv) {
-    if (!equiv-&gt;converter) {
-      tc = swig_type_list;
-      while (tc) {
-        if ((strcmp(tc-&gt;name, equiv-&gt;name) == 0))
-          SWIG_TypeClientData(tc,clientdata);
-        tc = tc-&gt;prev;
-      }
-    }
-    equiv = equiv-&gt;next;
-  }
-}
-
-/* Pack binary data into a string */
-SWIGRUNTIME(char *)
-SWIG_PackData(char *c, void *ptr, int sz) {
-  static char hex[17] = &quot;0123456789abcdef&quot;;
-  int i;
-  unsigned char *u = (unsigned char *) ptr;
-  register unsigned char uu;
-  for (i = 0; i &lt; sz; i++,u++) {
-    uu = *u;
-    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
-    *(c++) = hex[uu &amp; 0xf];
-  }
-  return c;
-}
-
-/* Unpack binary data from a string */
-SWIGRUNTIME(char *)
-SWIG_UnpackData(char *c, void *ptr, int sz) {
-  register unsigned char uu = 0;
-  register int d;
-  unsigned char *u = (unsigned char *) ptr;
-  int i;
-  for (i = 0; i &lt; sz; i++, u++) {
-    d = *(c++);
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu = ((d - '0') &lt;&lt; 4);
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu = ((d - ('a'-10)) &lt;&lt; 4);
-    d = *(c++);
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu |= (d - '0');
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu |= (d - ('a'-10));
-    *u = uu;
-  }
-  return c;
-}
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-/***********************************************************************
- * python.swg
- *
- *     This file contains the runtime support for Python modules
- *     and includes code for managing global variables and pointer
- *     type checking.
- *
- * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
- ************************************************************************/
-
-#include &quot;Python.h&quot;
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-#define SWIG_PY_INT     1
-#define SWIG_PY_FLOAT   2
-#define SWIG_PY_STRING  3
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Flags for pointer conversion */
-
-#define SWIG_POINTER_EXCEPTION     0x1
-#define SWIG_POINTER_DISOWN        0x2
-
-/* Exception handling in wrappers */
-#define SWIG_fail   goto fail
-
-/* Constant information structure */
-typedef struct swig_const_info {
-    int type;
-    char *name;
-    long lvalue;
-    double dvalue;
-    void   *pvalue;
-    swig_type_info **ptype;
-} swig_const_info;
-
-/* Common SWIG API */
-#define SWIG_ConvertPtr(obj, pp, type, flags) \
-  SWIG_Python_ConvertPtr(obj, pp, type, flags)
-#define SWIG_NewPointerObj(p, type, flags) \
-  SWIG_Python_NewPointerObj(p, type, flags)
-#define SWIG_MustGetPtr(p, type, argnum, flags) \
-  SWIG_Python_MustGetPtr(p, type, argnum, flags)
-
-/* Python-specific SWIG API */
-#define SWIG_newvarlink() \
-  SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr) \
-  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
-  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
-#define SWIG_NewPackedObj(ptr, sz, type) \
-  SWIG_Python_NewPackedObj(ptr, sz, type)
-#define SWIG_InstallConstants(d, constants) \
-  SWIG_Python_InstallConstants(d, constants)
-
-#ifdef SWIG_NOINCLUDE
-
-SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
-SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
-SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
-SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
-SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
-SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
-SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
-SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);
-
-#else
-
-/* -----------------------------------------------------------------------------
- * global variable support code.
- * ----------------------------------------------------------------------------- */
-
-typedef struct swig_globalvar {   
-  char       *name;                  /* Name of global variable */
-  PyObject *(*get_attr)(void);       /* Return the current value */
-  int       (*set_attr)(PyObject *); /* Set the value */
-  struct swig_globalvar *next;
-} swig_globalvar;
-
-typedef struct swig_varlinkobject {
-  PyObject_HEAD
-  swig_globalvar *vars;
-} swig_varlinkobject;
-
-static PyObject *
-swig_varlink_repr(swig_varlinkobject *v) {
-  v = v;
-  return PyString_FromString(&quot;&lt;Global variables&gt;&quot;);
-}
-
-static int
-swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
-  swig_globalvar  *var;
-  flags = flags;
-  fprintf(fp,&quot;Global variables { &quot;);
-  for (var = v-&gt;vars; var; var=var-&gt;next) {
-    fprintf(fp,&quot;%s&quot;, var-&gt;name);
-    if (var-&gt;next) fprintf(fp,&quot;, &quot;);
-  }
-  fprintf(fp,&quot; }\n&quot;);
-  return 0;
-}
-
-static PyObject *
-swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-  swig_globalvar *var = v-&gt;vars;
-  while (var) {
-    if (strcmp(var-&gt;name,n) == 0) {
-      return (*var-&gt;get_attr)();
-    }
-    var = var-&gt;next;
-  }
-  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
-  return NULL;
-}
-
-static int
-swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-  swig_globalvar *var = v-&gt;vars;
-  while (var) {
-    if (strcmp(var-&gt;name,n) == 0) {
-      return (*var-&gt;set_attr)(p);
-    }
-    var = var-&gt;next;
-  }
-  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
-  return 1;
-}
-
-statichere PyTypeObject varlinktype = {
-  PyObject_HEAD_INIT(0)              
-  0,
-  (char *)&quot;swigvarlink&quot;,              /* Type name    */
-  sizeof(swig_varlinkobject),         /* Basic size   */
-  0,                                  /* Itemsize     */
-  0,                                  /* Deallocator  */ 
-  (printfunc) swig_varlink_print,     /* Print        */
-  (getattrfunc) swig_varlink_getattr, /* get attr     */
-  (setattrfunc) swig_varlink_setattr, /* Set attr     */
-  0,                                  /* tp_compare   */
-  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
-  0,                                  /* tp_as_number */
-  0,                                  /* tp_as_mapping*/
-  0,                                  /* tp_hash      */
-};
-
-/* Create a variable linking object for use later */
-SWIGRUNTIME(PyObject *)
-SWIG_Python_newvarlink(void) {
-  swig_varlinkobject *result = 0;
-  result = PyMem_NEW(swig_varlinkobject,1);
-  varlinktype.ob_type = &amp;PyType_Type;    /* Patch varlinktype into a PyType */
-  result-&gt;ob_type = &varlinktype;
-  result-&gt;vars = 0;
-  result-&gt;ob_refcnt = 0;
-  Py_XINCREF((PyObject *) result);
-  return ((PyObject*) result);
-}
-
-SWIGRUNTIME(void)
-SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-  swig_varlinkobject *v;
-  swig_globalvar *gv;
-  v= (swig_varlinkobject *) p;
-  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-  gv-&gt;name = (char *) malloc(strlen(name)+1);
-  strcpy(gv-&gt;name,name);
-  gv-&gt;get_attr = get_attr;
-  gv-&gt;set_attr = set_attr;
-  gv-&gt;next = v-&gt;vars;
-  v-&gt;vars = gv;
-}
-
-/* Convert a pointer value */
-SWIGRUNTIME(int)
-SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
-  swig_type_info *tc;
-  char  *c = 0;
-  static PyObject *SWIG_this = 0;
-  int    newref = 0;
-  PyObject  *pyobj = 0;
-
-  if (!obj) return 0;
-  if (obj == Py_None) {
-    *ptr = 0;
-    return 0;
-  }
-#ifdef SWIG_COBJECT_TYPES
-  if (!(PyCObject_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString(&quot;this&quot;);
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PyCObject_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  }  
-  *ptr = PyCObject_AsVoidPtr(obj);
-  c = (char *) PyCObject_GetDesc(obj);
-  if (newref) Py_DECREF(obj);
-  goto cobject;
-#else
-  if (!(PyString_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString(&quot;this&quot;);
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PyString_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  } 
-  c = PyString_AsString(obj);
-  /* Pointer values must start with leading underscore */
-  if (*c != '_') {
-    *ptr = (void *) 0;
-    if (strcmp(c,&quot;NULL&quot;) == 0) {
-      if (newref) { Py_DECREF(obj); }
-      return 0;
-    } else {
-      if (newref) { Py_DECREF(obj); }
-      goto type_error;
-    }
-  }
-  c++;
-  c = SWIG_UnpackData(c,ptr,sizeof(void *));
-  if (newref) { Py_DECREF(obj); }
-#endif
-
-#ifdef SWIG_COBJECT_TYPES
-cobject:
-#endif
-
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
-  }
-
-  if ((pyobj) &amp;&amp; (flags &amp; SWIG_POINTER_DISOWN)) {
-    PyObject *zero = PyInt_FromLong(0);
-    PyObject_SetAttrString(pyobj,(char*)&quot;thisown&quot;,zero);
-    Py_DECREF(zero);
-  }
-  return 0;
-
-type_error:
-  if (flags &amp; SWIG_POINTER_EXCEPTION) {
-    if (ty &amp;&amp; c) {
-      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
-      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
-      PyErr_SetString(PyExc_TypeError, temp);
-      free((char *) temp);
-    } else {
-      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
-    }
-  }
-  return -1;
-}
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME(void *)
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
-  void *result;
-  SWIG_Python_ConvertPtr(obj, &amp;result, ty, flags | SWIG_POINTER_EXCEPTION);
-  return result;
-}
-
-/* Convert a packed value value */
-SWIGRUNTIME(int)
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
-  swig_type_info *tc;
-  char  *c = 0;
-
-  if ((!obj) || (!PyString_Check(obj))) goto type_error;
-  c = PyString_AsString(obj);
-  /* Pointer values must start with leading underscore */
-  if (*c != '_') goto type_error;
-  c++;
-  c = SWIG_UnpackData(c,ptr,sz);
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-  }
-  return 0;
-
-type_error:
-
-  if (flags) {
-    if (ty &amp;&amp; c) {
-      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
-      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
-      PyErr_SetString(PyExc_TypeError, temp);
-      free((char *) temp);
-    } else {
-      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
-    }
-  }
-  return -1;
-}
-
-/* Create a new pointer object */
-SWIGRUNTIME(PyObject *)
-SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
-  PyObject *robj;
-  if (!ptr) {
-    Py_INCREF(Py_None);
-    return Py_None;
-  }
-#ifdef SWIG_COBJECT_TYPES
-  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type-&gt;name, NULL);
-#else
-  {
-    char result[1024];
-    char *r = result;
-    *(r++) = '_';
-    r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
-    strcpy(r,type-&gt;name);
-    robj = PyString_FromString(result);
-  }
-#endif
-  if (!robj || (robj == Py_None)) return robj;
-  if (type-&gt;clientdata) {
-    PyObject *inst;
-    PyObject *args = Py_BuildValue((char*)&quot;(O)&quot;, robj);
-    Py_DECREF(robj);
-    inst = PyObject_CallObject((PyObject *) type-&gt;clientdata, args);
-    Py_DECREF(args);
-    if (inst) {
-      if (own) {
-        PyObject *n = PyInt_FromLong(1);
-        PyObject_SetAttrString(inst,(char*)&quot;thisown&quot;,n);
-        Py_DECREF(n);
-      }
-      robj = inst;
-    }
-  }
-  return robj;
-}
-
-SWIGRUNTIME(PyObject *)
-SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
-  char result[1024];
-  char *r = result;
-  if ((2*sz + 1 + strlen(type-&gt;name)) &gt; 1000) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  strcpy(r,type-&gt;name);
-  return PyString_FromString(result);
-}
-
-/* Install Constants */
-SWIGRUNTIME(void)
-SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-  int i;
-  PyObject *obj;
-  for (i = 0; constants[i].type; i++) {
-    switch(constants[i].type) {
-    case SWIG_PY_INT:
-      obj = PyInt_FromLong(constants[i].lvalue);
-      break;
-    case SWIG_PY_FLOAT:
-      obj = PyFloat_FromDouble(constants[i].dvalue);
-      break;
-    case SWIG_PY_STRING:
-      obj = PyString_FromString((char *) constants[i].pvalue);
-      break;
-    case SWIG_PY_POINTER:
-      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-      break;
-    case SWIG_PY_BINARY:
-      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-      break;
-    default:
-      obj = 0;
-      break;
-    }
-    if (obj) {
-      PyDict_SetItemString(d,constants[i].name,obj);
-      Py_DECREF(obj);
-    }
-  }
-}
-
-#endif
-
-/* Contract support */
-
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define  SWIGTYPE_p_GameConfig swig_types[0] 
-#define  SWIGTYPE_p_DialogApi swig_types[1] 
-#define  SWIGTYPE_p_std__vectorTstd__string_t swig_types[2] 
-#define  SWIGTYPE_p_EventManager swig_types[3] 
-#define  SWIGTYPE_p_SoundSystem swig_types[4] 
-#define  SWIGTYPE_p_GameAction swig_types[5] 
-static swig_type_info *swig_types[7];
-
-/* -------- TYPES TABLE (END) -------- */
-
-
-/*-----------------------------------------------
-              @(target):= _tml.so
-  ------------------------------------------------*/
-#define SWIG_init    init_tml
-
-#define SWIG_name    &quot;_tml&quot;
-
-#include &quot;tml/gameaction.h&quot;
-#include &quot;tml/gamedialog.h&quot;
-#include &quot;tml/gameconfig.h&quot;
-#include &quot;tml/eventmanager.h&quot;
-#include &quot;util/sound.h&quot;
-
-
-#define  SWIG_MemoryError    1
-#define  SWIG_IOError        2
-#define  SWIG_RuntimeError   3
-#define  SWIG_IndexError     4
-#define  SWIG_TypeError      5
-#define  SWIG_DivisionByZero 6
-#define  SWIG_OverflowError  7
-#define  SWIG_SyntaxError    8
-#define  SWIG_ValueError     9
-#define  SWIG_SystemError   10
-#define  SWIG_UnknownError  99
-
-
-static void SWIG_exception_(int code, const char *msg) {
-  switch(code) {
-  case SWIG_MemoryError:
-    PyErr_SetString(PyExc_MemoryError,msg);
-    break;
-  case SWIG_IOError:
-    PyErr_SetString(PyExc_IOError,msg);
-    break;
-  case SWIG_RuntimeError:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  case SWIG_IndexError:
-    PyErr_SetString(PyExc_IndexError,msg);
-    break;
-  case SWIG_TypeError:
-    PyErr_SetString(PyExc_TypeError,msg);
-    break;
-  case SWIG_DivisionByZero:
-    PyErr_SetString(PyExc_ZeroDivisionError,msg);
-    break;
-  case SWIG_OverflowError:
-    PyErr_SetString(PyExc_OverflowError,msg);
-    break;
-  case SWIG_SyntaxError:
-    PyErr_SetString(PyExc_SyntaxError,msg);
-    break;
-  case SWIG_ValueError:
-    PyErr_SetString(PyExc_ValueError,msg);
-    break;
-  case SWIG_SystemError:
-    PyErr_SetString(PyExc_SystemError,msg);
-    break;
-  default:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  }
-}
-
-#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
-
-
-#include &lt;string&gt;
-
-
-#include &lt;string&gt;
-
-PyObject* SwigInt_FromBool(bool b) {
-    return PyInt_FromLong(b ? 1L : 0L);
-}
-double SwigNumber_Check(PyObject* o) {
-    return PyFloat_Check(o) || PyInt_Check(o) || PyLong_Check(o);
-}
-double SwigNumber_AsDouble(PyObject* o) {
-    return PyFloat_Check(o) ? PyFloat_AsDouble(o) 
-        : (PyInt_Check(o) ?   double(PyInt_AsLong(o))
-                            : double(PyLong_AsLong(o)));
-}
-PyObject* SwigString_FromString(const std::string&amp; s) {
-    return PyString_FromStringAndSize(s.data(),s.size());
-}
-std::string SwigString_AsString(PyObject* o) {
-    return std::string(PyString_AsString(o));
-}
-
-
-#include &lt;utility&gt;
-
-extern SoundSystem *tw_sound;
-extern SoundSystem *GetSoundSystem();
-
-#include &lt;vector&gt;
-#include &lt;algorithm&gt;
-#include &lt;stdexcept&gt;
-
-std::string std_vectorlstd_string_g_pop___(std::vector&lt;std::string &gt; *self){
-                if (self-&gt;size() == 0)
-                    throw std::out_of_range(&quot;pop from empty vector&quot;);
-                std::string x = self-&gt;back();
-                self-&gt;pop_back();
-                return x;
-            }
-std::string std_vectorlstd_string_g___getitem_____(std::vector&lt;std::string &gt; *self,int i){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i += size;
-                if (i&gt;=0 &amp;&amp; i&lt;size)
-                    return (*self)[i];
-                else
-                    throw std::out_of_range(&quot;vector index out of range&quot;);
-            }
-std::vector&lt;std::string &gt; std_vectorlstd_string_g___getslice_____(std::vector&lt;std::string &gt; *self,int i,int j){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i = size+i;
-                if (j&lt;0) j = size+j;
-                if (i&lt;0) i = 0;
-                if (j&gt;size) j = size;
-                std::vector&lt;std::string &gt; tmp(j-i);
-                std::copy(self-&gt;begin()+i,self-&gt;begin()+j,tmp.begin());
-                return tmp;
-            }
-void std_vectorlstd_string_g___setitem_____(std::vector&lt;std::string &gt; *self,int i,std::string x){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i+= size;
-                if (i&gt;=0 &amp;&amp; i&lt;size)
-                    (*self)[i] = x;
-                else
-                    throw std::out_of_range(&quot;vector index out of range&quot;);
-            }
-void std_vectorlstd_string_g___setslice_____(std::vector&lt;std::string &gt; *self,int i,int j,std::vector&lt;std::string &gt; const &amp;v){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i = size+i;
-                if (j&lt;0) j = size+j;
-                if (i&lt;0) i = 0;
-                if (j&gt;size) j = size;
-                if (int(v.size()) == j-i) {
-                    std::copy(v.begin(),v.end(),self-&gt;begin()+i);
-                } else {
-                    self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
-                    if (i+1 &lt;= int(self-&gt;size()))
-                        self-&gt;insert(self-&gt;begin()+i,v.begin(),v.end());
-                    else
-                        self-&gt;insert(self-&gt;end(),v.begin(),v.end());
-                }
-            }
-void std_vectorlstd_string_g___delitem_____(std::vector&lt;std::string &gt; *self,int i){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i+= size;
-                if (i&gt;=0 &amp;&amp; i&lt;size)
-                    self-&gt;erase(self-&gt;begin()+i);
-                else
-                    throw std::out_of_range(&quot;vector index out of range&quot;);
-            }
-void std_vectorlstd_string_g___delslice_____(std::vector&lt;std::string &gt; *self,int i,int j){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i = size+i;
-                if (j&lt;0) j = size+j;
-                if (i&lt;0) i = 0;
-                if (j&gt;size) j = size;
-                self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
-            }
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-static PyObject *_wrap_GameAction_clean(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_clean&quot;)) goto fail;
-    GameAction::clean();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_system(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Odd:GameAction_add_system&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    GameAction::add_system((std::string const &amp;)*arg1,arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_planet(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    std::string temp1 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOdd:GameAction_add_planet&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)GameAction::add_planet((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_orbiter_station(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    std::string *arg3 = 0 ;
-    std::string *arg4 = 0 ;
-    std::string *arg5 = 0 ;
-    std::string *arg6 = 0 ;
-    std::string *arg7 = 0 ;
-    int result;
-    std::string temp1 ;
-    std::string temp2 ;
-    std::string temp3 ;
-    std::string temp4 ;
-    std::string temp5 ;
-    std::string temp6 ;
-    std::string temp7 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    PyObject * obj5 = 0 ;
-    PyObject * obj6 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOOOO:GameAction_add_orbiter_station&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4,&amp;obj5,&amp;obj6)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj2)) {
-            temp3 = std::string(PyString_AsString(obj2),
-            PyString_Size(obj2));
-            arg3 = &amp;temp3;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj3)) {
-            temp4 = std::string(PyString_AsString(obj3),
-            PyString_Size(obj3));
-            arg4 = &amp;temp4;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj4)) {
-            temp5 = std::string(PyString_AsString(obj4),
-            PyString_Size(obj4));
-            arg5 = &amp;temp5;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj5)) {
-            temp6 = std::string(PyString_AsString(obj5),
-            PyString_Size(obj5));
-            arg6 = &amp;temp6;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj6)) {
-            temp7 = std::string(PyString_AsString(obj6),
-            PyString_Size(obj6));
-            arg7 = &amp;temp7;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)GameAction::add_orbiter_station((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,(std::string const &amp;)*arg3,(std::string const &amp;)*arg4,(std::string const &amp;)*arg5,(std::string const &amp;)*arg6,(std::string const &amp;)*arg7);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    double arg2 = (double) -1 ;
-    double arg3 = (double) -1 ;
-    double arg4 = (double) -1 ;
-    double arg5 = (double) -1 ;
-    int result;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O|dddd:GameAction_add_asteroid&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;arg4,&amp;arg5)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3,arg4,arg5);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_player(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    std::string temp1 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOdd:GameAction_add_player&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)GameAction::add_player((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_ship(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    double arg5 ;
-    int result;
-    std::string temp1 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOddd:GameAction_add_ship&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4,&amp;arg5)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)GameAction::add_ship((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4,arg5);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag__SWIG_0(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    std::string temp1 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_save_flag&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    GameAction::save_flag((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_string_flag(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string result;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_string_flag&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = GameAction::get_string_flag((std::string const &amp;)*arg1);
-    
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag__SWIG_1(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Od:GameAction_save_flag&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    GameAction::save_flag((std::string const &amp;)*arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[3];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            _v = PyString_Check(argv[0]) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
-            }
-            if (_v) {
-                return _wrap_GameAction_save_flag__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            _v = PyString_Check(argv[0]) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                _v = PyString_Check(argv[1]) ? 1 : 0;
-            }
-            if (_v) {
-                return _wrap_GameAction_save_flag__SWIG_0(self,args);
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'GameAction_save_flag'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_double_flag(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    double result;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_double_flag&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (double)GameAction::get_double_flag((std::string const &amp;)*arg1);
-    
-    resultobj = PyFloat_FromDouble(result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_ship_id(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_ship_id&quot;)) goto fail;
-    result = (double)GameAction::get_player_ship_id();
-    
-    resultobj = PyFloat_FromDouble(result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_star_system(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_star_system&quot;)) goto fail;
-    result = GameAction::get_player_star_system();
-    
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_target(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dd:GameAction_set_target&quot;,&amp;arg1,&amp;arg2)) goto fail;
-    GameAction::set_target(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_disable_weapon(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;d:GameAction_disable_weapon&quot;,&amp;arg1)) goto fail;
-    GameAction::disable_weapon(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_enable_weapon(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;d:GameAction_enable_weapon&quot;,&amp;arg1)) goto fail;
-    GameAction::enable_weapon(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_go_to_point(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dddd:GameAction_go_to_point&quot;,&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4)) goto fail;
-    result = (int)GameAction::go_to_point(arg1,arg2,arg3,arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_go_to_location(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;ddd:GameAction_go_to_location&quot;,&amp;arg1,&amp;arg2,&amp;arg3)) goto fail;
-    result = (int)GameAction::go_to_location(arg1,arg2,arg3);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_guard_location(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;ddd:GameAction_guard_location&quot;,&amp;arg1,&amp;arg2,&amp;arg3)) goto fail;
-    result = (int)GameAction::guard_location(arg1,arg2,arg3);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_guard_point(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dddd:GameAction_guard_point&quot;,&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4)) goto fail;
-    result = (int)GameAction::guard_point(arg1,arg2,arg3,arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_ship_team(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dd:GameAction_set_ship_team&quot;,&amp;arg1,&amp;arg2)) goto fail;
-    GameAction::set_ship_team(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_enemy_team(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_enemy_team&quot;)) goto fail;
-    result = (int)GameAction::get_enemy_team();
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_team(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_team&quot;)) goto fail;
-    result = (int)GameAction::get_player_team();
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_remove_location(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;d:GameAction_remove_location&quot;,&amp;arg1)) goto fail;
-    GameAction::remove_location(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_crew(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dd:GameAction_set_crew&quot;,&amp;arg1,&amp;arg2)) goto fail;
-    GameAction::set_crew(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_end_game(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_end_game&quot;)) goto fail;
-    GameAction::end_game();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_scroll_text(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_scroll_text&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1 == NULL) {
-        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    GameAction::scroll_text((std::vector&lt;std::string &gt; const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_print_message(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    int arg2 ;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GameAction_print_message&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    GameAction::print_message((std::string const &amp;)*arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GameAction(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GameAction *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GameAction&quot;)) goto fail;
-    result = (GameAction *)new GameAction();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GameAction, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GameAction(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GameAction *arg1 = (GameAction *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameAction&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GameAction,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GameAction_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GameAction, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_DialogApi_startDialog(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_startDialog&quot;)) goto fail;
-    DialogApi::startDialog();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_endDialog(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_endDialog&quot;)) goto fail;
-    DialogApi::endDialog();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_askPlayer(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_askPlayer&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1 == NULL) {
-        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
-    }
-    result = (int)DialogApi::askPlayer((std::vector&lt;std::string &gt; const &amp;)*arg1);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_showText(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    int arg2 ;
-    int arg3 ;
-    int arg4 ;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oiii:DialogApi_showText&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;arg4)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    DialogApi::showText((std::string const &amp;)*arg1,arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_showAlienPicture(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_showAlienPicture&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    DialogApi::showAlienPicture((std::string const &amp;)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_DialogApi(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    DialogApi *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_DialogApi&quot;)) goto fail;
-    result = (DialogApi *)new DialogApi();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_DialogApi, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_DialogApi(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    DialogApi *arg1 = (DialogApi *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_DialogApi&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_DialogApi,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * DialogApi_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_DialogApi, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_GameConfig_SetGameDirectory(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_SetGameDirectory&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    GameConfig::SetGameDirectory((std::string const &amp;)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameConfig_GetGameDirectory(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameConfig_GetGameDirectory&quot;)) goto fail;
-    result = GameConfig::GetGameDirectory();
-    
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameConfig_GetAbsolutePath(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string result;
-    std::string temp1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_GetAbsolutePath&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = GameConfig::GetAbsolutePath((std::string const &amp;)*arg1);
-    
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GameConfig(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GameConfig *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GameConfig&quot;)) goto fail;
-    result = (GameConfig *)new GameConfig();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GameConfig, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GameConfig(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GameConfig *arg1 = (GameConfig *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameConfig&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GameConfig,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GameConfig_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GameConfig, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_EventManager_clean(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:EventManager_clean&quot;)) goto fail;
-    EventManager::clean();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_setSingleTimeEvent(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    std::string temp2 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dO:EventManager_setSingleTimeEvent&quot;,&amp;arg1,&amp;obj1)) goto fail;
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::setSingleTimeEvent(arg1,(std::string const &amp;)*arg2);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_setRepeatableTimeEvent(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    std::string temp2 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dO:EventManager_setRepeatableTimeEvent&quot;,&amp;arg1,&amp;obj1)) goto fail;
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::setRepeatableTimeEvent(arg1,(std::string const &amp;)*arg2);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_disableEvent(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;d:EventManager_disableEvent&quot;,&amp;arg1)) goto fail;
-    EventManager::disableEvent(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_shipDeathByName(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int result;
-    std::string temp1 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathByName&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::shipDeathByName((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_shipDeathByType(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int result;
-    std::string temp1 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathByType&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        if (PyString_Check(obj0)) {
-            temp1 = std::string(PyString_AsString(obj0),
-            PyString_Size(obj0));
-            arg1 = &amp;temp1;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::shipDeathByType((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_0(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    std::string *arg5 = 0 ;
-    int result;
-    std::string temp5 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;ddddO:EventManager_distanceMoreThen&quot;,&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4,&amp;obj4)) goto fail;
-    {
-        if (PyString_Check(obj4)) {
-            temp5 = std::string(PyString_AsString(obj4),
-            PyString_Size(obj4));
-            arg5 = &amp;temp5;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen__SWIG_0(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    std::string *arg5 = 0 ;
-    int result;
-    std::string temp5 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;ddddO:EventManager_distanceLessThen&quot;,&amp;arg1,&amp;arg2,&amp;arg3,&amp;arg4,&amp;obj4)) goto fail;
-    {
-        if (PyString_Check(obj4)) {
-            temp5 = std::string(PyString_AsString(obj4),
-            PyString_Size(obj4));
-            arg5 = &amp;temp5;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_1(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    std::string *arg4 = 0 ;
-    int result;
-    std::string temp4 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dddO:EventManager_distanceMoreThen&quot;,&amp;arg1,&amp;arg2,&amp;arg3,&amp;obj3)) goto fail;
-    {
-        if (PyString_Check(obj3)) {
-            temp4 = std::string(PyString_AsString(obj3),
-            PyString_Size(obj3));
-            arg4 = &amp;temp4;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 4) {
-        int _v;
-        {
-            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
-            }
-            if (_v) {
-                {
-                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
-                }
-                if (_v) {
-                    {
-                        _v = PyString_Check(argv[3]) ? 1 : 0;
-                    }
-                    if (_v) {
-                        return _wrap_EventManager_distanceMoreThen__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        {
-            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
-            }
-            if (_v) {
-                {
-                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
-                }
-                if (_v) {
-                    {
-                        _v = (PyFloat_Check(argv[3]) || PyInt_Check(argv[3]) || PyLong_Check(argv[3])) ? 1 : 0;
-                    }
-                    if (_v) {
-                        {
-                            _v = PyString_Check(argv[4]) ? 1 : 0;
-                        }
-                        if (_v) {
-                            return _wrap_EventManager_distanceMoreThen__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'EventManager_distanceMoreThen'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen__SWIG_1(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    std::string *arg4 = 0 ;
-    int result;
-    std::string temp4 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dddO:EventManager_distanceLessThen&quot;,&amp;arg1,&amp;arg2,&amp;arg3,&amp;obj3)) goto fail;
-    {
-        if (PyString_Check(obj3)) {
-            temp4 = std::string(PyString_AsString(obj3),
-            PyString_Size(obj3));
-            arg4 = &amp;temp4;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 4) {
-        int _v;
-        {
-            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
-            }
-            if (_v) {
-                {
-                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
-                }
-                if (_v) {
-                    {
-                        _v = PyString_Check(argv[3]) ? 1 : 0;
-                    }
-                    if (_v) {
-                        return _wrap_EventManager_distanceLessThen__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        {
-            _v = (PyFloat_Check(argv[0]) || PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                _v = (PyFloat_Check(argv[1]) || PyInt_Check(argv[1]) || PyLong_Check(argv[1])) ? 1 : 0;
-            }
-            if (_v) {
-                {
-                    _v = (PyFloat_Check(argv[2]) || PyInt_Check(argv[2]) || PyLong_Check(argv[2])) ? 1 : 0;
-                }
-                if (_v) {
-                    {
-                        _v = (PyFloat_Check(argv[3]) || PyInt_Check(argv[3]) || PyLong_Check(argv[3])) ? 1 : 0;
-                    }
-                    if (_v) {
-                        {
-                            _v = PyString_Check(argv[4]) ? 1 : 0;
-                        }
-                        if (_v) {
-                            return _wrap_EventManager_distanceLessThen__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'EventManager_distanceLessThen'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_AddEventCondition(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    std::string temp2 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;dO:EventManager_AddEventCondition&quot;,&amp;arg1,&amp;obj1)) goto fail;
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    EventManager::AddEventCondition(arg1,(std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_EventManager(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EventManager *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_EventManager&quot;)) goto fail;
-    result = (EventManager *)new EventManager();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_EventManager, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_EventManager(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EventManager *arg1 = (EventManager *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_EventManager&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EventManager,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * EventManager_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_EventManager, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_new_SoundSystem(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    bool arg1 = (bool) true ;
-    SoundSystem *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;|O:new_SoundSystem&quot;,&amp;obj0)) goto fail;
-    if (obj0) {
-        arg1 = PyInt_AsLong(obj0) ? true : false;
-        if (PyErr_Occurred()) SWIG_fail;
-    }
-    result = (SoundSystem *)new SoundSystem(arg1);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SoundSystem, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_SoundSystem(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_SoundSystem&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_music(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    int arg3 = (int) -1 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO|i:SoundSystem_play_music&quot;,&amp;obj0,&amp;obj1,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1))
-        arg2 = std::string(PyString_AsString(obj1),
-        PyString_Size(obj1));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    (arg1)-&gt;play_music(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_sound(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    double arg3 = (double) -1 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO|d:SoundSystem_play_sound&quot;,&amp;obj0,&amp;obj1,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1))
-        arg2 = std::string(PyString_AsString(obj1),
-        PyString_Size(obj1));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    (arg1)-&gt;play_sound(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_stop_sound(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_stop_sound&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1))
-        arg2 = std::string(PyString_AsString(obj1),
-        PyString_Size(obj1));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    (arg1)-&gt;stop_sound(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_set_music_volume(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Od:SoundSystem_set_music_volume&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;set_music_volume(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_set_sound_volume(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Od:SoundSystem_set_sound_volume&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;set_sound_volume(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_load_music_volume(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_music_volume&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (double)(arg1)-&gt;load_music_volume();
-    
-    resultobj = PyFloat_FromDouble(result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_load_sound_volume(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_sound_volume&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (double)(arg1)-&gt;load_sound_volume();
-    
-    resultobj = PyFloat_FromDouble(result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_playing_music(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (bool)(arg1)-&gt;playing_music();
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_playing_music_file(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music_file&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SoundSystem,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (arg1)-&gt;playing_music_file();
-    
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * SoundSystem_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_SoundSystem, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static int _wrap_tw_sound_set(PyObject *_val) {
-    {
-        void *temp;
-        if ((SWIG_ConvertPtr(_val,(void **) &amp;temp, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN)) == -1) {
-            PyErr_SetString(PyExc_TypeError, &quot;C variable 'tw_sound (SoundSystem *)'&quot;);
-            return 1;
-        }
-        tw_sound = (SoundSystem *) temp;
-    }
-    return 0;
-}
-
-
-static PyObject *_wrap_tw_sound_get() {
-    PyObject *pyobj;
-    
-    pyobj = SWIG_NewPointerObj((void *) tw_sound, SWIGTYPE_p_SoundSystem, 0);
-    return pyobj;
-}
-
-
-static PyObject *_wrap_GetSoundSystem(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SoundSystem *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GetSoundSystem&quot;)) goto fail;
-    result = (SoundSystem *)GetSoundSystem();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SoundSystem, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_0(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    unsigned int arg1 = (unsigned int) 0 ;
-    std::vector&lt;std::string &gt; *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;|O:new_vectorString&quot;,&amp;obj0)) goto fail;
-    if (obj0) {
-        arg1 = (unsigned int) PyInt_AsLong(obj0);
-        if (PyErr_Occurred()) SWIG_fail;
-    }
-    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstd__string_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_1(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    unsigned int arg1 ;
-    std::string *arg2 = 0 ;
-    std::vector&lt;std::string &gt; *result;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:new_vectorString&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    arg1 = (unsigned int) PyInt_AsLong(obj0);
-    if (PyErr_Occurred()) SWIG_fail;
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1,(std::string const &amp;)*arg2);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstd__string_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_2(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = 0 ;
-    std::vector&lt;std::string &gt; *result;
-    std::vector&lt;std::string &gt; temp1 ;
-    std::vector&lt;std::string &gt; *v1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
-            unsigned int size = (PyTuple_Check(obj0) ?
-            PyTuple_Size(obj0) :
-            PyList_Size(obj0));
-            temp1 = std::vector&lt;std::string &gt;(size);
-            arg1 = &amp;temp1;
-            for (unsigned int i=0; i&lt;size; i++) {
-                PyObject* o = PySequence_GetItem(obj0,i);
-                if (PyString_Check(o)) {
-                    temp1[i] = (std::string)(\
-                    SwigString_AsString(o));
-                    Py_DECREF(o);
-                } else {
-                    Py_DECREF(o);
-                    PyErr_SetString(PyExc_TypeError,
-                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-                    SWIG_fail;
-                }
-            }
-        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
-        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
-            arg1 = v1;
-        } else {
-            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-            SWIG_fail;
-        }
-    }
-    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;((std::vector&lt;std::string &gt; const &amp;)*arg1);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstd__string_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[3];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if ((argc &gt;= 0) &amp;&amp; (argc &lt;= 1)) {
-        int _v;
-        if (argc &lt;= 0) {
-            return _wrap_new_vectorString__SWIG_0(self,args);
-        }
-        {
-            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            return _wrap_new_vectorString__SWIG_0(self,args);
-        }
-    }
-    if (argc == 1) {
-        int _v;
-        {
-            /* native sequence? */
-            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
-                unsigned int size = (PyTuple_Check(argv[0]) ?
-                PyTuple_Size(argv[0]) :
-                PyList_Size(argv[0]));
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    _v = 1;
-                } else {
-                    /* check the first element only */
-                    PyObject* o = PySequence_GetItem(argv[0],0);
-                    if (PyString_Check(o))
-                    _v = 1;
-                    else
-                    _v = 0;
-                    Py_DECREF(o);
-                }
-            } else {
-                /* wrapped vector? */
-                std::vector&lt;std::string &gt;* v;
-                if (SWIG_ConvertPtr(argv[0],(void **) &amp;v, 
-                SWIGTYPE_p_std__vectorTstd__string_t,0) != -1)
-                _v = 1;
-                else
-                _v = 0;
-            }
-        }
-        if (_v) {
-            return _wrap_new_vectorString__SWIG_2(self,args);
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                _v = PyString_Check(argv[1]) ? 1 : 0;
-            }
-            if (_v) {
-                return _wrap_new_vectorString__SWIG_1(self,args);
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'new_vectorString'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___len__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    unsigned int result;
-    std::vector&lt;std::string &gt; temp1 ;
-    std::vector&lt;std::string &gt; *v1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___len__&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
-            unsigned int size = (PyTuple_Check(obj0) ?
-            PyTuple_Size(obj0) :
-            PyList_Size(obj0));
-            temp1 = std::vector&lt;std::string &gt;(size);
-            arg1 = &amp;temp1;
-            for (unsigned int i=0; i&lt;size; i++) {
-                PyObject* o = PySequence_GetItem(obj0,i);
-                if (PyString_Check(o)) {
-                    temp1[i] = (std::string)(\
-                    SwigString_AsString(o));
-                    Py_DECREF(o);
-                } else {
-                    Py_DECREF(o);
-                    PyErr_SetString(PyExc_TypeError,
-                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-                    SWIG_fail;
-                }
-            }
-        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
-        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
-            arg1 = v1;
-        } else {
-            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-            SWIG_fail;
-        }
-    }
-    result = (unsigned int)((std::vector&lt;std::string &gt; const *)arg1)-&gt;size();
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___nonzero__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    bool result;
-    std::vector&lt;std::string &gt; temp1 ;
-    std::vector&lt;std::string &gt; *v1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___nonzero__&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
-            unsigned int size = (PyTuple_Check(obj0) ?
-            PyTuple_Size(obj0) :
-            PyList_Size(obj0));
-            temp1 = std::vector&lt;std::string &gt;(size);
-            arg1 = &amp;temp1;
-            for (unsigned int i=0; i&lt;size; i++) {
-                PyObject* o = PySequence_GetItem(obj0,i);
-                if (PyString_Check(o)) {
-                    temp1[i] = (std::string)(\
-                    SwigString_AsString(o));
-                    Py_DECREF(o);
-                } else {
-                    Py_DECREF(o);
-                    PyErr_SetString(PyExc_TypeError,
-                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-                    SWIG_fail;
-                }
-            }
-        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
-        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
-            arg1 = v1;
-        } else {
-            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-            SWIG_fail;
-        }
-    }
-    result = (bool)((std::vector&lt;std::string &gt; const *)arg1)-&gt;empty();
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_clear(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_clear&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;clear();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_append(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_append&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1))
-        arg2 = std::string(PyString_AsString(obj1),
-        PyString_Size(obj1));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    (arg1)-&gt;push_back(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_pop(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::string result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        try {
-            result = std_vectorlstd_string_g_pop___(arg1);
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___getitem__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    int arg2 ;
-    std::string result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorString___getitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        try {
-            result = std_vectorlstd_string_g___getitem_____(arg1,arg2);
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___getslice__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    int arg2 ;
-    int arg3 ;
-    std::vector&lt;std::string &gt; result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorString___getslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = std_vectorlstd_string_g___getslice_____(arg1,arg2,arg3);
-    
-    {
-        resultobj = PyTuple_New((&amp;result)-&gt;size());
-        for (unsigned int i=0; i&lt;(&amp;result)-&gt;size(); i++)
-        PyTuple_SetItem(resultobj,i,
-        SwigString_FromString(((std::vector&lt;std::string &gt; &amp;)result)[i]));
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___setitem__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    int arg2 ;
-    std::string arg3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OiO:vectorString___setitem__&quot;,&amp;obj0,&amp;arg2,&amp;obj2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj2))
-        arg3 = std::string(PyString_AsString(obj2),
-        PyString_Size(obj2));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    {
-        try {
-            std_vectorlstd_string_g___setitem_____(arg1,arg2,arg3);
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___setslice__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    int arg2 ;
-    int arg3 ;
-    std::vector&lt;std::string &gt; *arg4 = 0 ;
-    std::vector&lt;std::string &gt; temp4 ;
-    std::vector&lt;std::string &gt; *v4 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OiiO:vectorString___setslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;obj3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
-            unsigned int size = (PyTuple_Check(obj3) ?
-            PyTuple_Size(obj3) :
-            PyList_Size(obj3));
-            temp4 = std::vector&lt;std::string &gt;(size);
-            arg4 = &amp;temp4;
-            for (unsigned int i=0; i&lt;size; i++) {
-                PyObject* o = PySequence_GetItem(obj3,i);
-                if (PyString_Check(o)) {
-                    temp4[i] = (std::string)(\
-                    SwigString_AsString(o));
-                    Py_DECREF(o);
-                } else {
-                    Py_DECREF(o);
-                    PyErr_SetString(PyExc_TypeError,
-                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-                    SWIG_fail;
-                }
-            }
-        } else if (SWIG_ConvertPtr(obj3,(void **) &amp;v4, 
-        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
-            arg4 = v4;
-        } else {
-            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
-            SWIG_fail;
-        }
-    }
-    std_vectorlstd_string_g___setslice_____(arg1,arg2,arg3,(std::vector&lt;std::string &gt; const &amp;)*arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___delitem__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorString___delitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        try {
-            std_vectorlstd_string_g___delitem_____(arg1,arg2);
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___delslice__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    int arg2 ;
-    int arg3 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorString___delslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    std_vectorlstd_string_g___delslice_____(arg1,arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_vectorString(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_vectorString&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * vectorString_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_t, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyMethodDef SwigMethods[] = {
-	 { (char *)&quot;GameAction_clean&quot;, _wrap_GameAction_clean, METH_VARARGS },
-	 { (char *)&quot;GameAction_add_system&quot;, _wrap_GameAction_add_system, METH_VARARGS },
-	 { (char *)&quot;GameAction_add_planet&quot;, _wrap_GameAction_add_planet, METH_VARARGS },
-	 { (char *)&quot;GameAction_add_orbiter_station&quot;, _wrap_GameAction_add_orbiter_station, METH_VARARGS },
-	 { (char *)&quot;GameAction_add_asteroid&quot;, _wrap_GameAction_add_asteroid, METH_VARARGS },
-	 { (char *)&quot;GameAction_add_player&quot;, _wrap_GameAction_add_player, METH_VARARGS },
-	 { (char *)&quot;GameAction_add_ship&quot;, _wrap_GameAction_add_ship, METH_VARARGS },
-	 { (char *)&quot;GameAction_get_string_flag&quot;, _wrap_GameAction_get_string_flag, METH_VARARGS },
-	 { (char *)&quot;GameAction_save_flag&quot;, _wrap_GameAction_save_flag, METH_VARARGS },
-	 { (char *)&quot;GameAction_get_double_flag&quot;, _wrap_GameAction_get_double_flag, METH_VARARGS },
-	 { (char *)&quot;GameAction_get_player_ship_id&quot;, _wrap_GameAction_get_player_ship_id, METH_VARARGS },
-	 { (char *)&quot;GameAction_get_player_star_system&quot;, _wrap_GameAction_get_player_star_system, METH_VARARGS },
-	 { (char *)&quot;GameAction_set_target&quot;, _wrap_GameAction_set_target, METH_VARARGS },
-	 { (char *)&quot;GameAction_disable_weapon&quot;, _wrap_GameAction_disable_weapon, METH_VARARGS },
-	 { (char *)&quot;GameAction_enable_weapon&quot;, _wrap_GameAction_enable_weapon, METH_VARARGS },
-	 { (char *)&quot;GameAction_go_to_point&quot;, _wrap_GameAction_go_to_point, METH_VARARGS },
-	 { (char *)&quot;GameAction_go_to_location&quot;, _wrap_GameAction_go_to_location, METH_VARARGS },
-	 { (char *)&quot;GameAction_guard_location&quot;, _wrap_GameAction_guard_location, METH_VARARGS },
-	 { (char *)&quot;GameAction_guard_point&quot;, _wrap_GameAction_guard_point, METH_VARARGS },
-	 { (char *)&quot;GameAction_set_ship_team&quot;, _wrap_GameAction_set_ship_team, METH_VARARGS },
-	 { (char *)&quot;GameAction_get_enemy_team&quot;, _wrap_GameAction_get_enemy_team, METH_VARARGS },
-	 { (char *)&quot;GameAction_get_player_team&quot;, _wrap_GameAction_get_player_team, METH_VARARGS },
-	 { (char *)&quot;GameAction_remove_location&quot;, _wrap_GameAction_remove_location, METH_VARARGS },
-	 { (char *)&quot;GameAction_set_crew&quot;, _wrap_GameAction_set_crew, METH_VARARGS },
-	 { (char *)&quot;GameAction_end_game&quot;, _wrap_GameAction_end_game, METH_VARARGS },
-	 { (char *)&quot;GameAction_scroll_text&quot;, _wrap_GameAction_scroll_text, METH_VARARGS },
-	 { (char *)&quot;GameAction_print_message&quot;, _wrap_GameAction_print_message, METH_VARARGS },
-	 { (char *)&quot;new_GameAction&quot;, _wrap_new_GameAction, METH_VARARGS },
-	 { (char *)&quot;delete_GameAction&quot;, _wrap_delete_GameAction, METH_VARARGS },
-	 { (char *)&quot;GameAction_swigregister&quot;, GameAction_swigregister, METH_VARARGS },
-	 { (char *)&quot;DialogApi_startDialog&quot;, _wrap_DialogApi_startDialog, METH_VARARGS },
-	 { (char *)&quot;DialogApi_endDialog&quot;, _wrap_DialogApi_endDialog, METH_VARARGS },
-	 { (char *)&quot;DialogApi_askPlayer&quot;, _wrap_DialogApi_askPlayer, METH_VARARGS },
-	 { (char *)&quot;DialogApi_showText&quot;, _wrap_DialogApi_showText, METH_VARARGS },
-	 { (char *)&quot;DialogApi_showAlienPicture&quot;, _wrap_DialogApi_showAlienPicture, METH_VARARGS },
-	 { (char *)&quot;new_DialogApi&quot;, _wrap_new_DialogApi, METH_VARARGS },
-	 { (char *)&quot;delete_DialogApi&quot;, _wrap_delete_DialogApi, METH_VARARGS },
-	 { (char *)&quot;DialogApi_swigregister&quot;, DialogApi_swigregister, METH_VARARGS },
-	 { (char *)&quot;GameConfig_SetGameDirectory&quot;, _wrap_GameConfig_SetGameDirectory, METH_VARARGS },
-	 { (char *)&quot;GameConfig_GetGameDirectory&quot;, _wrap_GameConfig_GetGameDirectory, METH_VARARGS },
-	 { (char *)&quot;GameConfig_GetAbsolutePath&quot;, _wrap_GameConfig_GetAbsolutePath, METH_VARARGS },
-	 { (char *)&quot;new_GameConfig&quot;, _wrap_new_GameConfig, METH_VARARGS },
-	 { (char *)&quot;delete_GameConfig&quot;, _wrap_delete_GameConfig, METH_VARARGS },
-	 { (char *)&quot;GameConfig_swigregister&quot;, GameConfig_swigregister, METH_VARARGS },
-	 { (char *)&quot;EventManager_clean&quot;, _wrap_EventManager_clean, METH_VARARGS },
-	 { (char *)&quot;EventManager_setSingleTimeEvent&quot;, _wrap_EventManager_setSingleTimeEvent, METH_VARARGS },
-	 { (char *)&quot;EventManager_setRepeatableTimeEvent&quot;, _wrap_EventManager_setRepeatableTimeEvent, METH_VARARGS },
-	 { (char *)&quot;EventManager_disableEvent&quot;, _wrap_EventManager_disableEvent, METH_VARARGS },
-	 { (char *)&quot;EventManager_shipDeathByName&quot;, _wrap_EventManager_shipDeathByName, METH_VARARGS },
-	 { (char *)&quot;EventManager_shipDeathByType&quot;, _wrap_EventManager_shipDeathByType, METH_VARARGS },
-	 { (char *)&quot;EventManager_distanceMoreThen&quot;, _wrap_EventManager_distanceMoreThen, METH_VARARGS },
-	 { (char *)&quot;EventManager_distanceLessThen&quot;, _wrap_EventManager_distanceLessThen, METH_VARARGS },
-	 { (char *)&quot;EventManager_AddEventCondition&quot;, _wrap_EventManager_AddEventCondition, METH_VARARGS },
-	 { (char *)&quot;new_EventManager&quot;, _wrap_new_EventManager, METH_VARARGS },
-	 { (char *)&quot;delete_EventManager&quot;, _wrap_delete_EventManager, METH_VARARGS },
-	 { (char *)&quot;EventManager_swigregister&quot;, EventManager_swigregister, METH_VARARGS },
-	 { (char *)&quot;new_SoundSystem&quot;, _wrap_new_SoundSystem, METH_VARARGS },
-	 { (char *)&quot;delete_SoundSystem&quot;, _wrap_delete_SoundSystem, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_play_music&quot;, _wrap_SoundSystem_play_music, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_play_sound&quot;, _wrap_SoundSystem_play_sound, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_stop_sound&quot;, _wrap_SoundSystem_stop_sound, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_set_music_volume&quot;, _wrap_SoundSystem_set_music_volume, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_set_sound_volume&quot;, _wrap_SoundSystem_set_sound_volume, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_load_music_volume&quot;, _wrap_SoundSystem_load_music_volume, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_load_sound_volume&quot;, _wrap_SoundSystem_load_sound_volume, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_playing_music&quot;, _wrap_SoundSystem_playing_music, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_playing_music_file&quot;, _wrap_SoundSystem_playing_music_file, METH_VARARGS },
-	 { (char *)&quot;SoundSystem_swigregister&quot;, SoundSystem_swigregister, METH_VARARGS },
-	 { (char *)&quot;GetSoundSystem&quot;, _wrap_GetSoundSystem, METH_VARARGS },
-	 { (char *)&quot;new_vectorString&quot;, _wrap_new_vectorString, METH_VARARGS },
-	 { (char *)&quot;vectorString___len__&quot;, _wrap_vectorString___len__, METH_VARARGS },
-	 { (char *)&quot;vectorString___nonzero__&quot;, _wrap_vectorString___nonzero__, METH_VARARGS },
-	 { (char *)&quot;vectorString_clear&quot;, _wrap_vectorString_clear, METH_VARARGS },
-	 { (char *)&quot;vectorString_append&quot;, _wrap_vectorString_append, METH_VARARGS },
-	 { (char *)&quot;vectorString_pop&quot;, _wrap_vectorString_pop, METH_VARARGS },
-	 { (char *)&quot;vectorString___getitem__&quot;, _wrap_vectorString___getitem__, METH_VARARGS },
-	 { (char *)&quot;vectorString___getslice__&quot;, _wrap_vectorString___getslice__, METH_VARARGS },
-	 { (char *)&quot;vectorString___setitem__&quot;, _wrap_vectorString___setitem__, METH_VARARGS },
-	 { (char *)&quot;vectorString___setslice__&quot;, _wrap_vectorString___setslice__, METH_VARARGS },
-	 { (char *)&quot;vectorString___delitem__&quot;, _wrap_vectorString___delitem__, METH_VARARGS },
-	 { (char *)&quot;vectorString___delslice__&quot;, _wrap_vectorString___delslice__, METH_VARARGS },
-	 { (char *)&quot;delete_vectorString&quot;, _wrap_delete_vectorString, METH_VARARGS },
-	 { (char *)&quot;vectorString_swigregister&quot;, vectorString_swigregister, METH_VARARGS },
-	 { NULL, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static swig_type_info _swigt__p_GameConfig[] = {{&quot;_p_GameConfig&quot;, 0, &quot;GameConfig *&quot;, 0},{&quot;_p_GameConfig&quot;},{0}};
-static swig_type_info _swigt__p_DialogApi[] = {{&quot;_p_DialogApi&quot;, 0, &quot;DialogApi *&quot;, 0},{&quot;_p_DialogApi&quot;},{0}};
-static swig_type_info _swigt__p_std__vectorTstd__string_t[] = {{&quot;_p_std__vectorTstd__string_t&quot;, 0, &quot;std::vector&lt;std::string &gt; *&quot;, 0},{&quot;_p_std__vectorTstd__string_t&quot;},{0}};
-static swig_type_info _swigt__p_EventManager[] = {{&quot;_p_EventManager&quot;, 0, &quot;EventManager *&quot;, 0},{&quot;_p_EventManager&quot;},{0}};
-static swig_type_info _swigt__p_SoundSystem[] = {{&quot;_p_SoundSystem&quot;, 0, &quot;SoundSystem *&quot;, 0},{&quot;_p_SoundSystem&quot;},{0}};
-static swig_type_info _swigt__p_GameAction[] = {{&quot;_p_GameAction&quot;, 0, &quot;GameAction *&quot;, 0},{&quot;_p_GameAction&quot;},{0}};
-
-static swig_type_info *swig_types_initial[] = {
-_swigt__p_GameConfig, 
-_swigt__p_DialogApi, 
-_swigt__p_std__vectorTstd__string_t, 
-_swigt__p_EventManager, 
-_swigt__p_SoundSystem, 
-_swigt__p_GameAction, 
-0
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{0}};
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-#endif
-SWIGEXPORT(void) SWIG_init(void) {
-    static PyObject *SWIG_globals = 0; 
-    static int       typeinit = 0;
-    PyObject *m, *d;
-    int       i;
-    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
-    m = Py_InitModule((char *) SWIG_name, SwigMethods);
-    d = PyModule_GetDict(m);
-    
-    if (!typeinit) {
-        for (i = 0; swig_types_initial[i]; i++) {
-            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
-        }
-        typeinit = 1;
-    }
-    SWIG_InstallConstants(d,swig_const_table);
-    
-    PyDict_SetItemString(d,(char*)&quot;cvar&quot;, SWIG_globals);
-    SWIG_addvarlink(SWIG_globals,(char*)&quot;tw_sound&quot;,_wrap_tw_sound_get, _wrap_tw_sound_set);
-}
-
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
+ * Version 1.3.24
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGPYTHON
+
+#ifdef __cplusplus
+template&lt;class T&gt; class SwigValueWrapper {
+    T *tt;
+public:
+    SwigValueWrapper() : tt(0) { }
+    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
+    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
+    ~SwigValueWrapper() { delete tt; } 
+    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
+    operator T&amp;() const { return *tt; }
+    T *operator&amp;() { return tt; }
+private:
+    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
+};
+#endif
+
+
+#ifndef SWIG_TEMPLATE_DISAMBIGUATOR
+#  if defined(__SUNPRO_CC) 
+#    define SWIG_TEMPLATE_DISAMBIGUATOR template
+#  else
+#    define SWIG_TEMPLATE_DISAMBIGUATOR 
+#  endif
+#endif
+
+
+#include &lt;Python.h&gt;
+
+/***********************************************************************
+ * swigrun.swg
+ *
+ *     This file contains generic CAPI SWIG runtime support for pointer
+ *     type checking.
+ *
+ ************************************************************************/
+
+/* This should only be incremented when either the layout of swig_type_info changes,
+   or for whatever reason, the runtime changes incompatibly */
+#define SWIG_RUNTIME_VERSION &quot;1&quot;
+
+/* define SWIG_TYPE_TABLE_NAME as &quot;SWIG_TYPE_TABLE&quot; */
+#ifdef SWIG_TYPE_TABLE
+#define SWIG_QUOTE_STRING(x) #x
+#define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+#define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+#else
+#define SWIG_TYPE_TABLE_NAME
+#endif
+
+#include &lt;string.h&gt;
+
+#ifndef SWIGINLINE
+#if defined(__cplusplus) || (defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__))
+#  define SWIGINLINE inline
+#else
+#  define SWIGINLINE
+#endif
+#endif
+
+/*
+  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+  creating a static or dynamic library from the swig runtime code.
+  In 99.9% of the cases, swig just needs to declare them as 'static'.
+  
+  But only do this if is strictly necessary, ie, if you have problems
+  with your compiler or so.
+*/
+#ifndef SWIGRUNTIME
+#define SWIGRUNTIME static
+#endif
+#ifndef SWIGRUNTIMEINLINE
+#define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef void *(*swig_converter_func)(void *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+typedef struct swig_type_info {
+  const char             *name;
+  swig_converter_func     converter;
+  const char             *str;
+  void                   *clientdata;
+  swig_dycast_func        dcast;
+  struct swig_type_info  *next;
+  struct swig_type_info  *prev;
+} swig_type_info;
+
+/* 
+  Compare two type names skipping the space characters, therefore
+  &quot;char*&quot; == &quot;char *&quot; and &quot;Class&lt;int&gt;&quot; == &quot;Class&lt;int &gt;&quot;, etc.
+
+  Return 0 when the two name types are equivalent, as in
+  strncmp, but skipping ' '.
+*/
+SWIGRUNTIME int
+SWIG_TypeNameComp(const char *f1, const char *l1,
+		  const char *f2, const char *l2) {
+  for (;(f1 != l1) &amp;&amp; (f2 != l2); ++f1, ++f2) {
+    while ((*f1 == ' ') &amp;&amp; (f1 != l1)) ++f1;
+    while ((*f2 == ' ') &amp;&amp; (f2 != l2)) ++f2;
+    if (*f1 != *f2) return *f1 - *f2;
+  }
+  return (l1 - f1) - (l2 - f2);
+}
+
+/*
+  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
+*/
+SWIGRUNTIME int
+SWIG_TypeEquiv(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv &amp;&amp; *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = SWIG_TypeNameComp(nb, ne, tb, te) == 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+/*
+  Register a type mapping with the type-checking
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeRegisterTL(swig_type_info **tl, swig_type_info *ti) {
+  swig_type_info *tc, *head, *ret, *next;
+  /* Check to see if this type has already been registered */
+  tc = *tl;
+  while (tc) {
+    /* check simple type equivalence */
+    int typeequiv = (strcmp(tc-&gt;name, ti-&gt;name) == 0);   
+    /* check full type equivalence, resolving typedefs */
+    if (!typeequiv) {
+      /* only if tc is not a typedef (no '|' on it) */
+      if (tc-&gt;str &amp;&amp; ti-&gt;str &amp;&amp; !strstr(tc-&gt;str,&quot;|&quot;)) {
+	typeequiv = SWIG_TypeEquiv(ti-&gt;str,tc-&gt;str);
+      }
+    }
+    if (typeequiv) {
+      /* Already exists in the table.  Just add additional types to the list */
+      if (ti-&gt;clientdata) tc-&gt;clientdata = ti-&gt;clientdata;
+      head = tc;
+      next = tc-&gt;next;
+      goto l1;
+    }
+    tc = tc-&gt;prev;
+  }
+  head = ti;
+  next = 0;
+
+  /* Place in list */
+  ti-&gt;prev = *tl;
+  *tl = ti;
+
+  /* Build linked lists */
+  l1:
+  ret = head;
+  tc = ti + 1;
+  /* Patch up the rest of the links */
+  while (tc-&gt;name) {
+    head-&gt;next = tc;
+    tc-&gt;prev = head;
+    head = tc;
+    tc++;
+  }
+  if (next) next-&gt;prev = head;
+  head-&gt;next = next;
+
+  return ret;
+}
+
+/*
+  Check the typename
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+  swig_type_info *s;
+  if (!ty) return 0;        /* Void pointer */
+  s = ty-&gt;next;             /* First element always just a name */
+  do {
+    if (strcmp(s-&gt;name,c) == 0) {
+      if (s == ty-&gt;next) return s;
+      /* Move s to the top of the linked list */
+      s-&gt;prev-&gt;next = s-&gt;next;
+      if (s-&gt;next) {
+        s-&gt;next-&gt;prev = s-&gt;prev;
+      }
+      /* Insert s as second element in the list */
+      s-&gt;next = ty-&gt;next;
+      if (ty-&gt;next) ty-&gt;next-&gt;prev = s;
+      ty-&gt;next = s;
+      s-&gt;prev = ty;
+      return s;
+    }
+    s = s-&gt;next;
+  } while (s &amp;&amp; (s != ty-&gt;next));
+  return 0;
+}
+
+/*
+  Cast a pointer up an inheritance hierarchy
+*/
+SWIGRUNTIMEINLINE void *
+SWIG_TypeCast(swig_type_info *ty, void *ptr) {
+  return ((!ty) || (!ty-&gt;converter)) ? ptr : (*ty-&gt;converter)(ptr);
+}
+
+/* 
+   Dynamic pointer casting. Down an inheritance hierarchy
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty-&gt;dcast) return ty;
+  while (ty &amp;&amp; (ty-&gt;dcast)) {
+    ty = (*ty-&gt;dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/*
+  Return the name associated with this type
+*/
+SWIGRUNTIMEINLINE const char *
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty-&gt;name;
+}
+
+/*
+  Return the pretty name associated with this type,
+  that is an unmangled type name in a form presentable to the user.
+*/
+SWIGRUNTIME const char *
+SWIG_TypePrettyName(const swig_type_info *type) {
+  /* The &quot;str&quot; field contains the equivalent pretty names of the
+     type, separated by vertical-bar characters.  We choose
+     to print the last name, as it is often (?) the most
+     specific. */
+  if (type-&gt;str != NULL) {
+    const char *last_name = type-&gt;str;
+    const char *s;
+    for (s = type-&gt;str; *s; s++)
+      if (*s == '|') last_name = s+1;
+    return last_name;
+  }
+  else
+    return type-&gt;name;
+}
+
+/*
+  Search for a swig_type_info structure
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeQueryTL(swig_type_info *tl, const char *name) {
+  swig_type_info *ty = tl;
+  while (ty) {
+    if (ty-&gt;str &amp;&amp; (SWIG_TypeEquiv(ty-&gt;str,name))) return ty;
+    if (ty-&gt;name &amp;&amp; (strcmp(name,ty-&gt;name) == 0)) return ty;
+    ty = ty-&gt;prev;
+  }
+  return 0;
+}
+
+/* 
+   Set the clientdata field for a type
+*/
+SWIGRUNTIME void
+SWIG_TypeClientDataTL(swig_type_info *tl, swig_type_info *ti, void *clientdata) {
+  swig_type_info *tc, *equiv;
+  if (ti-&gt;clientdata) return;
+  /* if (ti-&gt;clientdata == clientdata) return; */
+  ti-&gt;clientdata = clientdata;
+  equiv = ti-&gt;next;
+  while (equiv) {
+    if (!equiv-&gt;converter) {
+      tc = tl;
+      while (tc) {
+        if ((strcmp(tc-&gt;name, equiv-&gt;name) == 0))
+          SWIG_TypeClientDataTL(tl,tc,clientdata);
+        tc = tc-&gt;prev;
+      }
+    }
+    equiv = equiv-&gt;next;
+  }
+}
+
+/* 
+   Pack binary data into a string
+*/
+SWIGRUNTIME char *
+SWIG_PackData(char *c, void *ptr, size_t sz) {
+  static char hex[17] = &quot;0123456789abcdef&quot;;
+  unsigned char *u = (unsigned char *) ptr;
+  const unsigned char *eu =  u + sz;
+  register unsigned char uu;
+  for (; u != eu; ++u) {
+    uu = *u;
+    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
+    *(c++) = hex[uu &amp; 0xf];
+  }
+  return c;
+}
+
+/* 
+   Unpack binary data from a string
+*/
+SWIGRUNTIME const char *
+SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+  register unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu =  u + sz;
+  for (; u != eu; ++u) {
+    register int d = *(c++);
+    register unsigned char uu = 0;
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu = ((d - '0') &lt;&lt; 4);
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu = ((d - ('a'-10)) &lt;&lt; 4);
+    else 
+      return (char *) 0;
+    d = *(c++);
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu |= (d - '0');
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu |= (d - ('a'-10));
+    else 
+      return (char *) 0;
+    *u = uu;
+  }
+  return c;
+}
+
+/*
+  This function will propagate the clientdata field of type to any new
+  swig_type_info structures that have been added into the list of
+  equivalent types.  It is like calling SWIG_TypeClientData(type,
+  clientdata) a second time.
+*/
+SWIGRUNTIME void
+SWIG_PropagateClientDataTL(swig_type_info *tl, swig_type_info *type) {
+  swig_type_info *equiv = type-&gt;next;
+  swig_type_info *tc;
+  if (!type-&gt;clientdata) return;
+  while (equiv) {
+    if (!equiv-&gt;converter) {
+      tc = tl;
+      while (tc) {
+        if ((strcmp(tc-&gt;name, equiv-&gt;name) == 0) &amp;&amp; !tc-&gt;clientdata)
+          SWIG_TypeClientDataTL(tl,tc, type-&gt;clientdata);
+        tc = tc-&gt;prev;
+      }
+    }
+    equiv = equiv-&gt;next;
+  }
+}
+
+/* 
+   Pack 'void *' into a string buffer.
+*/
+SWIGRUNTIME char *
+SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+  char *r = buff;
+  if ((2*sizeof(void *) + 2) &gt; bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
+  if (strlen(name) + 1 &gt; (bsz - (r - buff))) return 0;
+  strcpy(r,name);
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      *ptr = (void *) 0;
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sizeof(void *));
+}
+
+SWIGRUNTIME char *
+SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+  char *r = buff;
+  size_t lname = (name ? strlen(name) : 0);
+  if ((2*sz + 2 + lname) &gt; bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  if (lname) {
+    strncpy(r,name,lname+1);
+  } else {
+    *r = 0;
+  }
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      memset(ptr,0,sz);
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sz);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/***********************************************************************
+ * common.swg
+ *
+ *     This file contains generic SWIG runtime support for pointer
+ *     type checking as well as a few commonly used macros to control
+ *     external linkage.
+ *
+ * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
+ *
+ * Copyright (c) 1999-2000, The University of Chicago
+ * 
+ * This file may be freely redistributed without license or fee provided
+ * this copyright message remains intact.
+ ************************************************************************/
+
+
+#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#  if !defined(STATIC_LINKED)
+#    define SWIGEXPORT(a) __declspec(dllexport) a
+#  else
+#    define SWIGEXPORT(a) a
+#  endif
+#else
+#  define SWIGEXPORT(a) a
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+/*************************************************************************/
+
+
+/* The static type info list */
+
+static swig_type_info *swig_type_list = 0;
+static swig_type_info **swig_type_list_handle = &amp;swig_type_list;
+  
+
+/* Register a type mapping with the type-checking */
+static swig_type_info *
+SWIG_TypeRegister(swig_type_info *ti) {
+  return SWIG_TypeRegisterTL(swig_type_list_handle, ti);
+}
+
+/* Search for a swig_type_info structure */
+static swig_type_info *
+SWIG_TypeQuery(const char *name) {
+  return SWIG_TypeQueryTL(*swig_type_list_handle, name);
+}
+
+/* Set the clientdata field for a type */
+static void
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  SWIG_TypeClientDataTL(*swig_type_list_handle, ti, clientdata);
+}
+
+/* This function will propagate the clientdata field of type to
+* any new swig_type_info structures that have been added into the list
+* of equivalent types.  It is like calling
+* SWIG_TypeClientData(type, clientdata) a second time.
+*/
+static void
+SWIG_PropagateClientData(swig_type_info *type) {
+  SWIG_PropagateClientDataTL(*swig_type_list_handle, type);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/* -----------------------------------------------------------------------------
+ * SWIG API. Portion that goes into the runtime
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* -----------------------------------------------------------------------------
+ * for internal method declarations
+ * ----------------------------------------------------------------------------- */
+
+#ifndef SWIGINTERN
+#define SWIGINTERN static 
+#endif
+
+#ifndef SWIGINTERNSHORT
+#ifdef __cplusplus
+#define SWIGINTERNSHORT static inline 
+#else /* C case */
+#define SWIGINTERNSHORT static 
+#endif /* __cplusplus */
+#endif
+
+
+/*
+  Exception handling in wrappers
+*/
+#define SWIG_fail                goto fail
+#define SWIG_arg_fail(arg)       SWIG_Python_ArgFail(arg)
+#define SWIG_append_errmsg(msg)   SWIG_Python_AddErrMesg(msg,0)
+#define SWIG_preppend_errmsg(msg) SWIG_Python_AddErrMesg(msg,1)
+#define SWIG_type_error(type,obj) SWIG_Python_TypeError(type,obj)
+#define SWIG_null_ref(type)       SWIG_Python_NullRef(type)
+
+/*
+  Contract support
+*/
+#define SWIG_contract_assert(expr, msg) \
+ if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
+
+/* -----------------------------------------------------------------------------
+ * Constant declarations
+ * ----------------------------------------------------------------------------- */
+
+/* Constant Types */
+#define SWIG_PY_INT     1
+#define SWIG_PY_FLOAT   2
+#define SWIG_PY_STRING  3
+#define SWIG_PY_POINTER 4
+#define SWIG_PY_BINARY  5
+
+/* Constant information structure */
+typedef struct swig_const_info {
+    int type;
+    char *name;
+    long lvalue;
+    double dvalue;
+    void   *pvalue;
+    swig_type_info **ptype;
+} swig_const_info;
+
+
+/* -----------------------------------------------------------------------------
+ * Alloc. memory flags
+ * ----------------------------------------------------------------------------- */
+#define SWIG_OLDOBJ  1
+#define SWIG_NEWOBJ  SWIG_OLDOBJ + 1
+#define SWIG_PYSTR   SWIG_NEWOBJ + 1
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/***********************************************************************
+ * pyrun.swg
+ *
+ *     This file contains the runtime support for Python modules
+ *     and includes code for managing global variables and pointer
+ *     type checking.
+ *
+ * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
+ ************************************************************************/
+
+/* Common SWIG API */
+#define SWIG_ConvertPtr(obj, pp, type, flags)    SWIG_Python_ConvertPtr(obj, pp, type, flags)
+#define SWIG_NewPointerObj(p, type, flags)       SWIG_Python_NewPointerObj(p, type, flags)
+#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
+ 
+
+/* Python-specific SWIG API */
+#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags)   SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
+#define SWIG_NewPackedObj(ptr, sz, type)              SWIG_Python_NewPackedObj(ptr, sz, type)
+
+
+/* -----------------------------------------------------------------------------
+ * Pointer declarations
+ * ----------------------------------------------------------------------------- */
+/*
+  Use SWIG_NO_COBJECT_TYPES to force the use of strings to represent
+  C/C++ pointers in the python side. Very useful for debugging, but
+  not always safe.
+*/
+#if !defined(SWIG_NO_COBJECT_TYPES) &amp;&amp; !defined(SWIG_COBJECT_TYPES)
+#  define SWIG_COBJECT_TYPES
+#endif
+
+/* Flags for pointer conversion */
+#define SWIG_POINTER_EXCEPTION     0x1
+#define SWIG_POINTER_DISOWN        0x2
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Create a new pointer string 
+ * ----------------------------------------------------------------------------- */
+
+#ifndef SWIG_BUFFER_SIZE
+#define SWIG_BUFFER_SIZE 1024
+#endif
+
+#if defined(SWIG_COBJECT_TYPES)
+#if !defined(SWIG_COBJECT_PYTHON)
+/* -----------------------------------------------------------------------------
+ * Implements a simple Swig Object type, and use it instead of PyCObject
+ * ----------------------------------------------------------------------------- */
+
+typedef struct {
+  PyObject_HEAD
+  void *ptr;
+  const char *desc;
+} PySwigObject;
+
+/* Declarations for objects of type PySwigObject */
+
+SWIGRUNTIME int
+PySwigObject_print(PySwigObject *v, FILE *fp, int flags)
+{
+  char result[SWIG_BUFFER_SIZE];
+  if (SWIG_PackVoidPtr(result, v-&gt;ptr, v-&gt;desc, sizeof(result))) {
+    fputs(&quot;&lt;Swig Object at &quot;, fp); fputs(result, fp); fputs(&quot;&gt;&quot;, fp);
+    return 0; 
+  } else {
+    return 1; 
+  }
+}
+  
+SWIGRUNTIME PyObject *
+PySwigObject_repr(PySwigObject *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  return SWIG_PackVoidPtr(result, v-&gt;ptr, v-&gt;desc, sizeof(result)) ?
+    PyString_FromFormat(&quot;&lt;Swig Object at %s&gt;&quot;, result) : 0;
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_str(PySwigObject *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  return SWIG_PackVoidPtr(result, v-&gt;ptr, v-&gt;desc, sizeof(result)) ?
+    PyString_FromString(result) : 0;
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_long(PySwigObject *v)
+{
+  return PyLong_FromUnsignedLong((unsigned long) v-&gt;ptr);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_oct(PySwigObject *v)
+{
+  char buf[100];
+  unsigned long x = (unsigned long)v-&gt;ptr;
+  if (x == 0)
+    strcpy(buf, &quot;0&quot;);
+  else
+    PyOS_snprintf(buf, sizeof(buf), &quot;0%lo&quot;, x);
+  return PyString_FromString(buf);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_hex(PySwigObject *v)
+{
+  char buf[100];
+  PyOS_snprintf(buf, sizeof(buf), &quot;0x%lx&quot;, (unsigned long)v-&gt;ptr);
+  return PyString_FromString(buf);
+}
+
+SWIGRUNTIME int
+PySwigObject_compare(PySwigObject *v, PySwigObject *w)
+{
+  int c = strcmp(v-&gt;desc, w-&gt;desc);
+  if (c) {
+    return c;
+  } else {
+    void *i = v-&gt;ptr;
+    void *j = w-&gt;ptr;
+    return (i &lt; j) ? -1 : (i &gt; j) ? 1 : 0;
+  }
+}
+
+SWIGRUNTIME void
+PySwigObject_dealloc(PySwigObject *self)
+{
+  PyObject_DEL(self);
+}
+
+SWIGRUNTIME PyTypeObject*
+PySwigObject_GetType() {
+  static char PySwigObject_Type__doc__[] = 
+    &quot;Swig object carries a C/C++ instance pointer&quot;;
+  
+  static PyNumberMethods PySwigObject_as_number = {
+    (binaryfunc)0, /*nb_add*/
+    (binaryfunc)0, /*nb_subtract*/
+    (binaryfunc)0, /*nb_multiply*/
+    (binaryfunc)0, /*nb_divide*/
+    (binaryfunc)0, /*nb_remainder*/
+    (binaryfunc)0, /*nb_divmod*/
+    (ternaryfunc)0,/*nb_power*/
+    (unaryfunc)0,  /*nb_negative*/
+    (unaryfunc)0,  /*nb_positive*/
+    (unaryfunc)0,  /*nb_absolute*/
+    (inquiry)0,    /*nb_nonzero*/
+    0,		   /*nb_invert*/
+    0,		   /*nb_lshift*/
+    0,		   /*nb_rshift*/
+    0,		   /*nb_and*/
+    0,		   /*nb_xor*/
+    0,		   /*nb_or*/
+    (coercion)0,   /*nb_coerce*/
+    (unaryfunc)PySwigObject_long, /*nb_int*/
+    (unaryfunc)PySwigObject_long, /*nb_long*/
+    (unaryfunc)0,                 /*nb_float*/
+    (unaryfunc)PySwigObject_oct,  /*nb_oct*/
+    (unaryfunc)PySwigObject_hex,  /*nb_hex*/
+#if PY_VERSION_HEX &gt;= 0x02000000
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -&gt; nb_inplace_true_divide */ 
+#endif
+  };
+
+  static int type_init = 0;  
+  static PyTypeObject PySwigObject_Type;
+
+  if (!type_init) {
+    PyTypeObject tmp = {
+    PyObject_HEAD_INIT(&amp;PyType_Type)
+    0,					/*ob_size*/
+    &quot;PySwigObject&quot;,			/*tp_name*/
+    sizeof(PySwigObject),		/*tp_basicsize*/
+    0,					/*tp_itemsize*/
+    /* methods */
+    (destructor)PySwigObject_dealloc,	/*tp_dealloc*/
+    (printfunc)PySwigObject_print,	/*tp_print*/
+    (getattrfunc)0,			/*tp_getattr*/
+    (setattrfunc)0,			/*tp_setattr*/
+    (cmpfunc)PySwigObject_compare,	/*tp_compare*/
+    (reprfunc)PySwigObject_repr,	/*tp_repr*/
+    &amp;PySwigObject_as_number,	        /*tp_as_number*/
+    0,					/*tp_as_sequence*/
+    0,					/*tp_as_mapping*/
+    (hashfunc)0,			/*tp_hash*/
+    (ternaryfunc)0,			/*tp_call*/
+    (reprfunc)PySwigObject_str,		/*tp_str*/
+    /* Space for future expansion */
+    0L,0L,0L,0L,
+    PySwigObject_Type__doc__, 	        /* Documentation string */
+#if PY_VERSION_HEX &gt;= 0x02000000
+    0,                                  /* tp_traverse */
+    0,                                  /* tp_clear */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02010000
+    0,                                  /* tp_richcompare */
+    0,                                  /* tp_weaklistoffset */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02020000
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -&gt; tp_weaklist */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02030000
+    0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+    0,0,0,0                             /* tp_alloc -&gt; tp_next */
+#endif
+    };
+
+    PySwigObject_Type = tmp;
+    type_init = 1;
+  }
+
+  return &amp;PySwigObject_Type;
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_FromVoidPtrAndDesc(void *ptr, const char *desc)
+{
+  PySwigObject *self = PyObject_NEW(PySwigObject, PySwigObject_GetType());
+  if (self == NULL) return NULL;
+  self-&gt;ptr = ptr;
+  self-&gt;desc = desc;
+  return (PyObject *)self;
+}
+
+SWIGRUNTIMEINLINE void *
+PySwigObject_AsVoidPtr(PyObject *self)
+{
+  return ((PySwigObject *)self)-&gt;ptr;
+}
+
+SWIGRUNTIMEINLINE const char *
+PySwigObject_GetDesc(PyObject *self)
+{
+  return ((PySwigObject *)self)-&gt;desc;
+}
+
+SWIGRUNTIMEINLINE int
+PySwigObject_Check(PyObject *op) {
+  return ((op)-&gt;ob_type == PySwigObject_GetType()) 
+    || (strcmp((op)-&gt;ob_type-&gt;tp_name,&quot;PySwigObject&quot;) == 0);
+}
+
+/* -----------------------------------------------------------------------------
+ * Implements a simple Swig Packed type, and use it instead of string
+ * ----------------------------------------------------------------------------- */
+
+typedef struct {
+  PyObject_HEAD
+  void *pack;
+  const char *desc;
+  size_t size;
+} PySwigPacked;
+
+SWIGRUNTIME int
+PySwigPacked_print(PySwigPacked *v, FILE *fp, int flags)
+{
+  char result[SWIG_BUFFER_SIZE];
+  fputs(&quot;&lt;Swig Packed &quot;, fp); 
+  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))) {
+    fputs(&quot;at &quot;, fp); 
+    fputs(result, fp); 
+  }
+  fputs(v-&gt;desc,fp); 
+  fputs(&quot;&gt;&quot;, fp);
+  return 0; 
+}
+  
+SWIGRUNTIME PyObject *
+PySwigPacked_repr(PySwigPacked *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))) {
+    return PyString_FromFormat(&quot;&lt;Swig Packed at %s%s&gt;&quot;, result, v-&gt;desc);
+  } else {
+    return PyString_FromFormat(&quot;&lt;Swig Packed %s&gt;&quot;, v-&gt;desc);
+  }  
+}
+
+SWIGRUNTIME PyObject *
+PySwigPacked_str(PySwigPacked *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))){
+    return PyString_FromFormat(&quot;%s%s&quot;, result, v-&gt;desc);
+  } else {
+    return PyString_FromFormat(&quot;%s&quot;, v-&gt;desc);
+  }  
+}
+
+SWIGRUNTIME int
+PySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)
+{
+  int c = strcmp(v-&gt;desc, w-&gt;desc);
+  if (c) {
+    return c;
+  } else {
+    size_t i = v-&gt;size;
+    size_t j = w-&gt;size;
+    int s = (i &lt; j) ? -1 : (i &gt; j) ? 1 : 0;
+    return s ? s : strncmp((char *)v-&gt;pack, (char *)w-&gt;pack, 2*v-&gt;size);
+  }
+}
+
+SWIGRUNTIME void
+PySwigPacked_dealloc(PySwigPacked *self)
+{
+  free(self-&gt;pack);
+  PyObject_DEL(self);
+}
+
+SWIGRUNTIME PyTypeObject*
+PySwigPacked_GetType() {
+  static char PySwigPacked_Type__doc__[] = 
+    &quot;Swig object carries a C/C++ instance pointer&quot;;
+  static int type_init = 0;
+  
+  static PyTypeObject PySwigPacked_Type;
+  if (!type_init) {
+    PyTypeObject tmp = {
+    PyObject_HEAD_INIT(&amp;PyType_Type)
+    0,					/*ob_size*/
+    &quot;PySwigPacked&quot;,			/*tp_name*/
+    sizeof(PySwigPacked),		/*tp_basicsize*/
+    0,					/*tp_itemsize*/
+    /* methods */
+    (destructor)PySwigPacked_dealloc,	/*tp_dealloc*/
+    (printfunc)PySwigPacked_print,	/*tp_print*/
+    (getattrfunc)0,			/*tp_getattr*/
+    (setattrfunc)0,			/*tp_setattr*/
+    (cmpfunc)PySwigPacked_compare,	/*tp_compare*/
+    (reprfunc)PySwigPacked_repr,	/*tp_repr*/
+    0,	                                /*tp_as_number*/
+    0,					/*tp_as_sequence*/
+    0,					/*tp_as_mapping*/
+    (hashfunc)0,			/*tp_hash*/
+    (ternaryfunc)0,			/*tp_call*/
+    (reprfunc)PySwigPacked_str,		/*tp_str*/
+    /* Space for future expansion */
+    0L,0L,0L,0L,
+    PySwigPacked_Type__doc__, 	        /* Documentation string */
+#if PY_VERSION_HEX &gt;= 0x02000000
+    0,                                  /* tp_traverse */
+    0,                                  /* tp_clear */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02010000
+    0,                                  /* tp_richcompare */
+    0,                                  /* tp_weaklistoffset */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02020000         
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -&gt; tp_weaklist */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02030000
+    0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+    0,0,0,0                             /* tp_alloc -&gt; tp_next */
+#endif
+    };
+
+    PySwigPacked_Type = tmp;
+    type_init = 1;
+  }
+  
+      
+
+  return &amp;PySwigPacked_Type;
+}
+
+SWIGRUNTIME PyObject *
+PySwigPacked_FromDataAndDesc(void *ptr, size_t size, const char *desc)
+{
+  PySwigPacked *self = PyObject_NEW(PySwigPacked, PySwigPacked_GetType());
+  if (self == NULL) {
+    return NULL;
+  } else {
+    void *pack = malloc(size);
+    memcpy(pack, ptr, size);
+    self-&gt;pack = pack;
+    self-&gt;desc = desc;
+    self-&gt;size = size;
+    return (PyObject *) self;
+  }
+}
+
+SWIGRUNTIMEINLINE const char *
+PySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
+{
+  PySwigPacked *self = (PySwigPacked *)obj;
+  if (self-&gt;size != size) return 0;
+  memcpy(ptr, self-&gt;pack, size);
+  return self-&gt;desc;
+}
+
+SWIGRUNTIMEINLINE const char *
+PySwigPacked_GetDesc(PyObject *self)
+{
+  return ((PySwigPacked *)self)-&gt;desc;
+}
+
+SWIGRUNTIMEINLINE int
+PySwigPacked_Check(PyObject *op) {
+  return ((op)-&gt;ob_type == PySwigPacked_GetType()) 
+    || (strcmp((op)-&gt;ob_type-&gt;tp_name,&quot;PySwigPacked&quot;) == 0);
+}
+
+#else
+/* -----------------------------------------------------------------------------
+ * Use the old Python PyCObject instead of PySwigObject
+ * ----------------------------------------------------------------------------- */
+
+#define PySwigObject_GetDesc(obj)	           PyCObject_GetDesc(obj)
+#define PySwigObject_Check(obj)	           PyCObject_Check(obj)
+#define PySwigObject_AsVoidPtr(obj)	   PyCObject_AsVoidPtr(obj)
+#define PySwigObject_FromVoidPtrAndDesc(p, d)  PyCObject_FromVoidPtrAndDesc(p, d, NULL)
+
+#endif
+
+#endif
+
+/* -----------------------------------------------------------------------------
+ * errors manipulation
+ * ----------------------------------------------------------------------------- */
+
+SWIGRUNTIME void
+SWIG_Python_TypeError(const char *type, PyObject *obj)
+{
+  if (type) {
+#if defined(SWIG_COBJECT_TYPES)
+    if (PySwigObject_Check(obj)) {
+      const char *otype = (const char *) PySwigObject_GetDesc(obj);
+      if (otype) {
+	PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, 'PySwigObject(%s)' is received&quot;,
+		     type, otype);
+	return;
+      }
+    } else 
+#endif      
+    {
+      const char *otype = (obj ? obj-&gt;ob_type-&gt;tp_name : 0); 
+      if (otype) {
+	PyObject *str = PyObject_Str(obj);
+	const char *cstr = str ? PyString_AsString(str) : 0;
+	if (cstr) {
+	  PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, '%s(%s)' is received&quot;,
+		       type, otype, cstr);
+	} else {
+	  PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, '%s' is received&quot;,
+		       type, otype);
+	}
+	Py_DECREF(str);
+	return;
+      }
+    }   
+    PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected&quot;, type);
+  } else {
+    PyErr_Format(PyExc_TypeError, &quot;unexpected type is received&quot;);
+  }
+}
+
+SWIGRUNTIMEINLINE void
+SWIG_Python_NullRef(const char *type)
+{
+  if (type) {
+    PyErr_Format(PyExc_TypeError, &quot;null reference of type '%s' was received&quot;,type);
+  } else {
+    PyErr_Format(PyExc_TypeError, &quot;null reference was received&quot;);
+  }
+}
+
+SWIGRUNTIME int
+SWIG_Python_AddErrMesg(const char* mesg, int infront)
+{
+  if (PyErr_Occurred()) {
+    PyObject *type = 0;
+    PyObject *value = 0;
+    PyObject *traceback = 0;
+    PyErr_Fetch(&amp;type, &amp;value, &amp;traceback);
+    if (value) {
+      PyObject *old_str = PyObject_Str(value);
+      Py_XINCREF(type);
+      PyErr_Clear();
+      if (infront) {
+	PyErr_Format(type, &quot;%s %s&quot;, mesg, PyString_AsString(old_str));
+      } else {
+	PyErr_Format(type, &quot;%s %s&quot;, PyString_AsString(old_str), mesg);
+      }
+      Py_DECREF(old_str);
+    }
+    return 1;
+  } else {
+    return 0;
+  }
+}
+
+SWIGRUNTIME int
+SWIG_Python_ArgFail(int argnum)
+{
+  if (PyErr_Occurred()) {
+    /* add information about failing argument */
+    char mesg[256];
+    sprintf(mesg, &quot;argument number %d:&quot;, argnum);
+    return SWIG_Python_AddErrMesg(mesg, 1);
+  } else {
+    return 0;
+  }
+}
+
+
+/* -----------------------------------------------------------------------------
+ * pointers/data manipulation
+ * ----------------------------------------------------------------------------- */
+
+/* Convert a pointer value */
+SWIGRUNTIME int
+SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  const char *c = 0;
+  static PyObject *SWIG_this = 0;
+  int    newref = 0;
+  PyObject  *pyobj = 0;
+  void *vptr;
+  
+  if (!obj) return 0;
+  if (obj == Py_None) {
+    *ptr = 0;
+    return 0;
+  }
+
+#ifdef SWIG_COBJECT_TYPES
+  if (!(PySwigObject_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString(&quot;this&quot;);
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PySwigObject_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  }  
+  vptr = PySwigObject_AsVoidPtr(obj);
+  c = (const char *) PySwigObject_GetDesc(obj);
+  if (newref) { Py_DECREF(obj); }
+  goto type_check;
+#else
+  if (!(PyString_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString(&quot;this&quot;);
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PyString_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  } 
+  c = PyString_AS_STRING(obj);
+  /* Pointer values must start with leading underscore */
+  c = SWIG_UnpackVoidPtr(c, &amp;vptr, ty-&gt;name);
+  if (newref) { Py_DECREF(obj); }
+  if (!c) goto type_error;
+#endif
+
+type_check:
+
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+    *ptr = SWIG_TypeCast(tc,vptr);
+  } else {
+    *ptr = vptr;
+  }
+
+  if ((pyobj) &amp;&amp; (flags &amp; SWIG_POINTER_DISOWN)) {
+    PyObject_SetAttrString(pyobj,(char*)&quot;thisown&quot;,Py_False);
+  }
+  return 0;
+
+type_error:
+  PyErr_Clear();
+  if (pyobj &amp;&amp; !obj) {    
+    obj = pyobj;
+    if (PyCFunction_Check(obj)) {
+      /* here we get the method pointer for callbacks */
+      char *doc = (((PyCFunctionObject *)obj) -&gt; m_ml -&gt; ml_doc);
+      c = doc ? strstr(doc, &quot;swig_ptr: &quot;) : 0;
+      if (c) {
+	c = SWIG_UnpackVoidPtr(c + 10, &amp;vptr, ty-&gt;name);
+	if (!c) goto type_error;
+	goto type_check;
+      }
+    }
+  }
+  if (flags &amp; SWIG_POINTER_EXCEPTION) {
+    if (ty) {
+      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
+    } else {
+      SWIG_Python_TypeError(&quot;C/C++ pointer&quot;, obj);
+    }
+  }
+  return -1;
+}
+
+/* Convert a pointer value, signal an exception on a type mismatch */
+SWIGRUNTIME void *
+SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
+  void *result;
+  if (SWIG_Python_ConvertPtr(obj, &amp;result, ty, flags) == -1) {
+    PyErr_Clear();
+    if (flags &amp; SWIG_POINTER_EXCEPTION) {
+      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
+      SWIG_Python_ArgFail(argnum);
+    }
+  }
+  return result;
+}
+
+/* Convert a packed value value */
+SWIGRUNTIME int
+SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  const char *c = 0;
+
+#if defined(SWIG_COBJECT_TYPES) &amp;&amp; !defined(SWIG_COBJECT_PYTHON)
+  c = PySwigPacked_UnpackData(obj, ptr, sz);
+#else
+  if ((!obj) || (!PyString_Check(obj))) goto type_error;
+  c = PyString_AS_STRING(obj);
+  /* Pointer values must start with leading underscore */
+  c = SWIG_UnpackDataName(c, ptr, sz, ty-&gt;name);
+#endif
+  if (!c) goto type_error;
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+  }
+  return 0;
+
+type_error:
+  PyErr_Clear();
+  if (flags &amp; SWIG_POINTER_EXCEPTION) {
+    if (ty) {
+      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
+    } else {
+      SWIG_Python_TypeError(&quot;C/C++ packed data&quot;, obj);
+    }
+  }
+  return -1;
+}  
+
+/* Create a new array object */
+SWIGRUNTIME PyObject *
+SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
+  PyObject *robj = 0;
+  if (!ptr) {
+    Py_INCREF(Py_None);
+    return Py_None;
+  }
+#ifdef SWIG_COBJECT_TYPES
+  robj = PySwigObject_FromVoidPtrAndDesc((void *) ptr, (char *)type-&gt;name);
+#else
+  {
+    char result[SWIG_BUFFER_SIZE];
+    robj = SWIG_PackVoidPtr(result, ptr, type-&gt;name, sizeof(result)) ?
+      PyString_FromString(result) : 0;
+  }
+#endif
+  if (!robj || (robj == Py_None)) return robj;
+  if (type-&gt;clientdata) {
+    PyObject *inst;
+    PyObject *args = Py_BuildValue((char*)&quot;(O)&quot;, robj);
+    Py_DECREF(robj);
+    inst = PyObject_CallObject((PyObject *) type-&gt;clientdata, args);
+    Py_DECREF(args);
+    if (inst) {
+      if (own) {
+        PyObject_SetAttrString(inst,(char*)&quot;thisown&quot;,Py_True);
+      }
+      robj = inst;
+    }
+  }
+  return robj;
+}
+
+SWIGRUNTIME PyObject *
+SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
+  PyObject *robj = 0;
+  if (!ptr) {
+    Py_INCREF(Py_None);
+    return Py_None;
+  }
+#if defined(SWIG_COBJECT_TYPES) &amp;&amp; !defined(SWIG_COBJECT_PYTHON)
+  robj = PySwigPacked_FromDataAndDesc((void *) ptr, sz, (char *)type-&gt;name);
+#else
+  {
+    char result[SWIG_BUFFER_SIZE];
+    robj = SWIG_PackDataName(result, ptr, sz, type-&gt;name, sizeof(result)) ?
+      PyString_FromString(result) : 0;
+  }
+#endif
+  return robj;
+}
+
+/* -----------------------------------------------------------------------------*
+ *  Get type list 
+ * -----------------------------------------------------------------------------*/
+
+#ifdef SWIG_LINK_RUNTIME
+void *SWIG_ReturnGlobalTypeList(void *);
+#endif
+
+SWIGRUNTIME swig_type_info **
+SWIG_Python_GetTypeListHandle() {
+  static void *type_pointer = (void *)0;
+  /* first check if module already created */
+  if (!type_pointer) {
+#ifdef SWIG_LINK_RUNTIME
+    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+#else
+    type_pointer = PyCObject_Import((char*)&quot;swig_runtime_data&quot; SWIG_RUNTIME_VERSION,
+				    (char*)&quot;type_pointer&quot; SWIG_TYPE_TABLE_NAME);
+    if (PyErr_Occurred()) {
+      PyErr_Clear();
+      type_pointer = (void *)0;
+    }
+  }
+#endif
+  return (swig_type_info **) type_pointer;
+}
+
+/*
+  Search for a swig_type_info structure
+ */
+SWIGRUNTIMEINLINE swig_type_info *
+SWIG_Python_GetTypeList() {
+  swig_type_info **tlh = SWIG_Python_GetTypeListHandle();
+  return tlh ? *tlh : (swig_type_info*)0;
+}
+
+#define SWIG_Runtime_GetTypeList SWIG_Python_GetTypeList 
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define  SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t swig_types[0] 
+#define  SWIGTYPE_std__size_t swig_types[1] 
+#define  SWIGTYPE_size_t swig_types[2] 
+#define  SWIGTYPE_p_EventManager swig_types[3] 
+#define  SWIGTYPE_p_allocator_type swig_types[4] 
+#define  SWIGTYPE_p_size_type swig_types[5] 
+#define  SWIGTYPE_p_char swig_types[6] 
+#define  SWIGTYPE_p_GameConfig swig_types[7] 
+#define  SWIGTYPE_p_GameAction swig_types[8] 
+#define  SWIGTYPE_p_value_type swig_types[9] 
+#define  SWIGTYPE_p_difference_type swig_types[10] 
+#define  SWIGTYPE_std__ptrdiff_t swig_types[11] 
+#define  SWIGTYPE_ptrdiff_t swig_types[12] 
+#define  SWIGTYPE_p_DialogApi swig_types[13] 
+#define  SWIGTYPE_p_SoundSystem swig_types[14] 
+#define  SWIGTYPE_p_std__allocatorTstd__string_t swig_types[15] 
+static swig_type_info *swig_types[17];
+
+/* -------- TYPES TABLE (END) -------- */
+
+
+/*-----------------------------------------------
+              @(target):= _tml.so
+  ------------------------------------------------*/
+#define SWIG_init    init_tml
+
+#define SWIG_name    &quot;_tml&quot;
+
+#include &quot;tml/gameaction.h&quot;
+#include &quot;tml/gamedialog.h&quot;
+#include &quot;tml/gameconfig.h&quot;
+#include &quot;tml/eventmanager.h&quot;
+#include &quot;util/sound.h&quot;
+
+
+#include &lt;string&gt;
+
+
+  
+#if defined(__SUNPRO_CC) 
+#define SWIG_STD_NOASSIGN_STL
+#define SWIG_STD_NOINSERT_TEMPLATE_STL
+#endif
+
+
+
+#include &lt;string&gt;
+#include &lt;stdexcept&gt;
+
+
+#include &lt;utility&gt;
+
+
+/* returns SWIG_OLDOBJ if the input is a raw char*, SWIG_PYSTR if is a PyString */
+SWIGINTERN int
+SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize)
+{
+  static swig_type_info* pchar_info = 0;
+  char* vptr = 0;
+  if (!pchar_info) pchar_info = SWIG_TypeQuery(&quot;char *&quot;);
+  if (SWIG_ConvertPtr(obj, (void**)&amp;vptr, pchar_info, 0) != -1) {
+    if (cptr) *cptr = vptr;
+    if (psize) *psize = vptr ? (strlen(vptr) + 1) : 0;
+    return SWIG_OLDOBJ;
+  } else {
+    PyErr_Clear();
+    if (PyString_Check(obj)) {
+      if (cptr) {
+	*cptr = PyString_AS_STRING(obj);
+	if (psize) {
+	  *psize = PyString_GET_SIZE(obj) + 1;
+	}
+      }
+      return SWIG_PYSTR;
+    }
+  }
+  if (cptr) {
+    SWIG_type_error(&quot;char *&quot;, obj);
+  }
+  return 0;
+}
+
+
+  SWIGINTERN int
+    SWIG_AsPtr_std_string(PyObject* obj, std::string **val)
+    {
+      static swig_type_info* string_info = SWIG_TypeQuery(&quot;std::string *&quot;);
+      std::string *vptr;    
+      if (SWIG_ConvertPtr(obj, (void**)&amp;vptr, string_info, 0) != -1) {
+	if (val) *val = vptr;
+	return SWIG_OLDOBJ;
+      } else {
+	PyErr_Clear();
+	char* buf = 0 ; size_t size = 0;
+	if (SWIG_AsCharPtrAndSize(obj, &amp;buf, &amp;size)) {
+	  if (buf) {
+	    if (val) *val = new std::string(buf, size - 1);
+	    return SWIG_NEWOBJ;
+	  }
+	} else {
+	  PyErr_Clear();
+	}  
+	if (val) {
+	  PyErr_SetString(PyExc_TypeError,&quot;a string is expected&quot;);
+	}
+	return 0;
+      }
+    }
+
+
+SWIGINTERN int
+  SWIG_AsVal_double(PyObject *obj, double *val)
+{
+  if (PyFloat_Check(obj)) {
+    if (val) *val = PyFloat_AS_DOUBLE(obj);
+    return 1;
+  }  
+  if (PyInt_Check(obj)) {
+    if (val) *val = PyInt_AS_LONG(obj);
+    return 1;
+  }
+  if (PyLong_Check(obj)) {
+    double v = PyLong_AsDouble(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return 1;
+    } else {
+      if (!val) PyErr_Clear();
+      return 0;
+    }
+  }
+  if (val) {
+    SWIG_type_error(&quot;double&quot;, obj);
+  }
+  return 0;
+}
+
+
+SWIGINTERNSHORT double
+SWIG_As_double(PyObject* obj)
+{
+  double v;
+  if (!SWIG_AsVal_double(obj, &amp;v)) {
+    /*
+      this is needed to make valgrind/purify happier. 
+     */
+    memset((void*)&amp;v, 0, sizeof(double));
+  }
+  return v;
+}
+
+  
+SWIGINTERNSHORT int
+SWIG_Check_double(PyObject* obj)
+{
+  return SWIG_AsVal_double(obj, (double*)0);
+}
+
+
+  /*@c:\\swig\\Lib\\python\\pymacros.swg,66,SWIG_define@*/
+#define SWIG_From_int PyInt_FromLong
+/*@@*/
+
+
+SWIGINTERNSHORT PyObject *
+SWIG_FromCharArray(const char* carray, size_t size)
+{
+  if (size &gt; INT_MAX) {
+    return Py_None;    
+  } else {
+    return PyString_FromStringAndSize(carray, (int)(size));
+  }
+}
+
+
+SWIGINTERNSHORT PyObject*
+  SWIG_From_std_string(const std::string&amp; s)
+  {
+    return SWIG_FromCharArray(s.data(), s.size());
+  }
+
+
+  /*@c:\\swig\\Lib\\python\\pymacros.swg,66,SWIG_define@*/
+#define SWIG_From_double PyFloat_FromDouble
+/*@@*/
+
+
+#include &lt;limits.h&gt;
+
+
+SWIGINTERN int
+  SWIG_CheckLongInRange(long value, long min_value, long max_value,
+			const char *errmsg)
+{
+  if (value &lt; min_value) {
+    if (errmsg) {
+      PyErr_Format(PyExc_OverflowError, 
+		   &quot;value %ld is less than '%s' minimum %ld&quot;, 
+		   value, errmsg, min_value);
+    }
+    return 0;    
+  } else if (value &gt; max_value) {
+    if (errmsg) {
+      PyErr_Format(PyExc_OverflowError,
+		   &quot;value %ld is greater than '%s' maximum %ld&quot;, 
+		   value, errmsg, max_value);
+    }
+    return 0;
+  }
+  return 1;
+}
+
+
+SWIGINTERN int
+  SWIG_AsVal_long(PyObject * obj, long* val)
+{
+  if (PyInt_Check(obj)) {
+    if (val) *val = PyInt_AS_LONG(obj);
+    return 1;
+  }
+  if (PyLong_Check(obj)) {
+    long v = PyLong_AsLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return 1;
+    } else {
+      if (!val) PyErr_Clear();
+      return 0;
+    }
+  }
+  if (val) {
+    SWIG_type_error(&quot;long&quot;, obj);
+  }
+  return 0;
+ }
+
+
+#if INT_MAX != LONG_MAX
+SWIGINTERN int
+  SWIG_AsVal_int(PyObject *obj, int *val)
+{ 
+  const char* errmsg = val ? &quot;int&quot; : (char*)0;
+  long v;
+  if (SWIG_AsVal_long(obj, &amp;v)) {
+    if (SWIG_CheckLongInRange(v, INT_MIN,INT_MAX, errmsg)) {
+      if (val) *val = (int)(v);
+      return 1;
+    } else {
+      return 0;
+    }
+  } else {
+    PyErr_Clear();
+  }
+  if (val) {
+    SWIG_type_error(errmsg, obj);
+  }
+  return 0;    
+}
+#else
+SWIGINTERNSHORT int
+  SWIG_AsVal_int(PyObject *obj, int *val)
+{
+  return SWIG_AsVal_long(obj,(long*)val);
+}
+#endif
+
+
+SWIGINTERNSHORT int
+SWIG_As_int(PyObject* obj)
+{
+  int v;
+  if (!SWIG_AsVal_int(obj, &amp;v)) {
+    /*
+      this is needed to make valgrind/purify happier. 
+     */
+    memset((void*)&amp;v, 0, sizeof(int));
+  }
+  return v;
+}
+
+  
+SWIGINTERNSHORT int
+SWIG_Check_int(PyObject* obj)
+{
+  return SWIG_AsVal_int(obj, (int*)0);
+}
+
+
+SWIGINTERN int
+  SWIG_AsVal_bool(PyObject *obj, bool *val)
+{
+  if (obj == Py_True) {
+    if (val) *val = true;
+    return 1;
+  }
+  if (obj == Py_False) {
+    if (val) *val = false;
+    return 1;
+  }
+  int res = 0;
+  if (SWIG_AsVal_int(obj, &amp;res)) {    
+    if (val) *val = res ? true : false;
+    return 1;
+  } else {
+    PyErr_Clear();
+  }  
+  if (val) {
+    SWIG_type_error(&quot;bool&quot;, obj);
+  }
+  return 0;
+}
+
+
+SWIGINTERNSHORT bool
+SWIG_As_bool(PyObject* obj)
+{
+  bool v;
+  if (!SWIG_AsVal_bool(obj, &amp;v)) {
+    /*
+      this is needed to make valgrind/purify happier. 
+     */
+    memset((void*)&amp;v, 0, sizeof(bool));
+  }
+  return v;
+}
+
+  
+SWIGINTERNSHORT int
+SWIG_Check_bool(PyObject* obj)
+{
+  return SWIG_AsVal_bool(obj, (bool*)0);
+}
+
+
+SWIGINTERNSHORT PyObject*
+  SWIG_From_bool(bool value)
+{
+  PyObject *obj = value ? Py_True : Py_False;
+  Py_INCREF(obj);
+  return obj;
+}
+
+extern SoundSystem *tw_sound;
+SoundSystem *GetSoundSystem();
+
+#include &lt;iostream&gt;  
+
+
+#if PY_VERSION_HEX &lt; 0x02000000
+#define PySequence_Size PySequence_Length
+#endif
+#include &lt;stdexcept&gt;
+
+
+#define  SWIG_MemoryError    1
+#define  SWIG_IOError        2
+#define  SWIG_RuntimeError   3
+#define  SWIG_IndexError     4
+#define  SWIG_TypeError      5
+#define  SWIG_DivisionByZero 6
+#define  SWIG_OverflowError  7
+#define  SWIG_SyntaxError    8
+#define  SWIG_ValueError     9
+#define  SWIG_SystemError   10
+#define  SWIG_UnknownError  99
+
+
+static void SWIG_exception_(int code, const char *msg) {
+  switch(code) {
+  case SWIG_MemoryError:
+    PyErr_SetString(PyExc_MemoryError,msg);
+    break;
+  case SWIG_IOError:
+    PyErr_SetString(PyExc_IOError,msg);
+    break;
+  case SWIG_RuntimeError:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  case SWIG_IndexError:
+    PyErr_SetString(PyExc_IndexError,msg);
+    break;
+  case SWIG_TypeError:
+    PyErr_SetString(PyExc_TypeError,msg);
+    break;
+  case SWIG_DivisionByZero:
+    PyErr_SetString(PyExc_ZeroDivisionError,msg);
+    break;
+  case SWIG_OverflowError:
+    PyErr_SetString(PyExc_OverflowError,msg);
+    break;
+  case SWIG_SyntaxError:
+    PyErr_SetString(PyExc_SyntaxError,msg);
+    break;
+  case SWIG_ValueError:
+    PyErr_SetString(PyExc_ValueError,msg);
+    break;
+  case SWIG_SystemError:
+    PyErr_SetString(PyExc_SystemError,msg);
+    break;
+  default:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  }
+}
+
+#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
+
+
+#include &lt;stdexcept&gt;
+
+
+#include &lt;algorithm&gt;
+
+
+#include &lt;vector&gt;
+
+
+SWIGINTERN int
+  SWIG_AsVal_std_string(PyObject* obj, std::string *val)
+  {
+    std::string* s;
+    int res = SWIG_AsPtr_std_string(obj, &amp;s);
+    if (res &amp;&amp; s) {
+      if (val) *val = *s;
+      if (res == SWIG_NEWOBJ) delete s;
+      return res;
+    }
+    if (val) {
+      PyErr_SetString(PyExc_TypeError,&quot;a string is expected&quot;);
+    }
+    return 0;
+  }
+
+
+namespace swig {  
+  template &lt;class Type&gt;
+  struct noconst_traits {
+    typedef Type noconst_type;
+  };
+
+  template &lt;class Type&gt;
+  struct noconst_traits&lt;const Type&gt; {
+    typedef Type noconst_type;
+  };
+
+  /*
+    type categories
+  */
+  struct pointer_category { };  
+  struct value_category { };
+
+  /*
+    General traits that provides type_name and type_info
+  */
+  template &lt;class Type&gt; struct traits { };
+
+  template &lt;class Type&gt;
+  inline const char* type_name() {
+    return traits&lt;typename noconst_traits&lt;Type &gt;::noconst_type &gt;::type_name();
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_info {
+    static swig_type_info *type_query(std::string name) {
+      name += &quot; *&quot;;
+      return SWIG_TypeQuery(name.c_str());
+    }    
+    static swig_type_info *type_info() {
+      static swig_type_info *info = type_query(type_name&lt;Type&gt;());
+      return info;
+    }
+  };
+
+  template &lt;class Type&gt;
+  inline swig_type_info *type_info() {
+    return traits_info&lt;Type&gt;::type_info();
+  }
+
+  /*
+    Partial specialization for pointers
+  */
+  template &lt;class Type&gt; struct traits &lt;Type *&gt; {
+    typedef pointer_category category;
+    static std::string make_ptr_name(const char* name) {
+      std::string ptrname = name;
+      ptrname += &quot; *&quot;;
+      return ptrname;
+    }    
+    static const char* type_name() {
+      static std::string name = make_ptr_name(swig::type_name&lt;Type&gt;());
+      return name.c_str();
+    }
+  };
+
+  template &lt;class Type, class Category&gt; 
+  struct traits_as { };
+ 
+  template &lt;class Type, class Category&gt; 
+  struct traits_check { };
+
+}
+
+
+namespace swig {  
+  /*
+    Traits that provides the from method
+  */
+  template &lt;class Type&gt; struct traits_from_ptr {
+    static PyObject *from(Type *val, int owner = 0) {
+      return SWIG_NewPointerObj(val, type_info&lt;Type&gt;(), owner);
+    }
+  };
+
+  template &lt;class Type&gt; struct traits_from {
+    static PyObject *from(const Type&amp; val) {
+      return traits_from_ptr&lt;Type&gt;::from(new Type(val), 1);
+    }
+  };
+
+  template &lt;class Type&gt; struct traits_from&lt;Type *&gt; {
+    static PyObject *from(Type* val) {
+      return traits_from_ptr&lt;Type&gt;::from(val, 0);
+    }
+  };
+
+  template &lt;class Type&gt;
+  inline PyObject *from(const Type&amp; val) {
+    return traits_from&lt;Type&gt;::from(val);
+  }
+
+  template &lt;class Type&gt;
+  inline PyObject *from_ptr(Type* val, int owner) {
+    return traits_from_ptr&lt;Type&gt;::from(val, owner);
+  }
+
+  /*
+    Traits that provides the asval/as/check method
+  */
+  template &lt;class Type&gt;
+  struct traits_asptr {   
+    static int asptr(PyObject *obj, Type **val) {
+      Type *p;
+      int res = (SWIG_ConvertPtr(obj, (void**)&amp;p, type_info&lt;Type&gt;(), 0) != -1) 
+	? SWIG_OLDOBJ : 0;
+      if (res) {
+	if (val) {
+	  *val = p;
+	}
+      } else {
+	SWIG_type_error(type_name&lt;Type&gt;(), obj);
+      }
+      return res;
+    }
+  }; 
+
+  template &lt;class Type&gt;
+  inline int asptr(PyObject *obj, Type **vptr) {
+    return traits_asptr&lt;Type&gt;::asptr(obj, vptr);
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_asval {
+    static bool asval(PyObject *obj, Type *val) {
+      if (val) {
+	Type *p = 0;
+	int res = traits_asptr&lt;Type&gt;::asptr(obj, &amp;p);
+	if (res &amp;&amp; p) {
+	  typedef typename noconst_traits&lt;Type&gt;::noconst_type noconst_type;
+	  *(const_cast&lt;noconst_type*&gt;(val)) = *p;
+	  if (res == SWIG_NEWOBJ) delete p;
+	  return true;
+	} else {
+	  return false;
+	}
+      } else {
+	return traits_asptr&lt;Type&gt;::asptr(obj, (Type **)(0));
+      }
+    }
+  };
+
+  template &lt;class Type&gt; struct traits_asval&lt;Type*&gt; {
+    static bool asval(PyObject *obj, Type **val) {
+      if (val) {
+        typedef typename noconst_traits&lt;Type&gt;::noconst_type noconst_type;
+        noconst_type *p = 0;
+        int res = traits_asptr&lt;noconst_type&gt;::asptr(obj, &amp;p);
+        if (res) {
+          *(const_cast&lt;noconst_type**&gt;(val)) = p;
+     	  return true;
+	} else {
+	  return false;
+	}
+      } else {
+	return traits_asptr&lt;Type&gt;::asptr(obj, (Type **)(0));
+      }
+    }
+  };
+  
+  template &lt;class Type&gt;
+  inline bool asval(PyObject *obj, Type *val) {
+    return traits_asval&lt;Type&gt;::asval(obj, val);
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_as&lt;Type, value_category&gt; {
+    static Type as(PyObject *obj, bool throw_error) {
+      Type v;
+      if (!obj || !asval(obj, &amp;v)) {
+	if (!PyErr_Occurred()) {
+	  SWIG_type_error(swig::type_name&lt;Type&gt;(), obj);
+	}
+	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
+      }
+      return v;
+    }
+  };
+
+  template &lt;class Type&gt; 
+  struct traits_as&lt;Type, pointer_category&gt; {
+    static Type as(PyObject *obj, bool throw_error) {
+      Type *v = 0;      
+      int res = (obj ? traits_asptr&lt;Type&gt;::asptr(obj, &amp;v) : 0) &amp;&amp; v;
+      if (res) {
+	if (res == SWIG_NEWOBJ) {
+	  Type r(*v);
+	  delete v;
+	  return r;
+	} else {
+	  return *v;
+	}
+      } else {
+	// Uninitialized return value, no Type() constructor required.
+	static Type *v_def = (Type*) malloc(sizeof(Type));
+	if (!PyErr_Occurred()) {
+	  SWIG_type_error(swig::type_name&lt;Type&gt;(), obj);
+	}
+	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
+	memset(v_def,0,sizeof(Type));
+	return *v_def;
+      }
+    }
+  };
+
+  template &lt;class Type&gt; 
+  struct traits_as&lt;Type*, pointer_category&gt; {
+    static Type* as(PyObject *obj, bool throw_error) {
+      Type *v = 0;      
+      int res = (obj ? traits_asptr&lt;Type&gt;::asptr(obj, &amp;v) : 0);
+      if (res) {
+	return v;
+      } else {
+	if (!PyErr_Occurred()) {
+	  SWIG_type_error(swig::type_name&lt;Type&gt;(), obj);
+	}
+	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
+	return 0;
+      }
+    }
+  };
+    
+  template &lt;class Type&gt;
+  inline Type as(PyObject *obj, bool te = false) {
+    return traits_as&lt;Type, typename traits&lt;Type&gt;::category&gt;::as(obj, te);
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_check&lt;Type, value_category&gt; {
+    static bool check(PyObject *obj) {
+      return obj &amp;&amp; asval(obj, (Type *)(0));
+    }
+  };
+
+  template &lt;class Type&gt; 
+  struct traits_check&lt;Type, pointer_category&gt; {
+    static bool check(PyObject *obj) {
+      return obj &amp;&amp; asptr(obj, (Type **)(0));
+    }
+  };
+
+  template &lt;class Type&gt;
+  inline bool check(PyObject *obj) {
+    return traits_check&lt;Type, typename traits&lt;Type&gt;::category&gt;::check(obj);
+  }
+}
+
+
+namespace swig {
+  template &lt;&gt; struct traits&lt;std::string &gt; {
+    typedef value_category category;
+    static const char* type_name() { return&quot;std::string&quot;; }
+  };  
+  template &lt;&gt;  struct traits_asval&lt;std::string &gt; {   
+    typedef std::string value_type;
+    static int asval(PyObject *obj, value_type *val) { 
+      return SWIG_AsVal_std_string(obj, val);
+    }
+  };
+  template &lt;&gt;  struct traits_from&lt;std::string &gt; {
+    typedef std::string value_type;
+    static PyObject *from(const value_type&amp; val) {
+      return SWIG_From_std_string(val);
+    }
+  };
+}
+
+
+  namespace swig {
+    struct PyObject_var {
+      PyObject* ptr;
+      PyObject_var(PyObject* obj = 0) : ptr(obj) { }      
+      ~PyObject_var() { if (ptr) Py_DECREF(ptr); }      
+      operator PyObject*() { return ptr; }
+      PyObject* operator-&gt;() const { return ptr; }
+    };
+  }
+
+
+namespace swig {
+  inline size_t
+  check_index(ptrdiff_t i, size_t size, bool insert = false) {
+    if ( i &lt; 0 ) {
+      if ((size_t) (-i) &lt;= size) 
+	return (size_t) (i + size);
+    } else if ( (size_t) i &lt; size ) {
+      return (size_t) i;
+    } else if (insert &amp;&amp; ((size_t) i == size)) {
+      return size;
+    }
+    
+    throw std::out_of_range(&quot;index out of range&quot;);
+  }
+
+  inline size_t
+  slice_index(ptrdiff_t i, size_t size) {
+    if ( i &lt; 0 ) {
+      if ((size_t) (-i) &lt;= size) {
+	return (size_t) (i + size);
+      } else {
+	throw std::out_of_range(&quot;index out of range&quot;);
+      }
+    } else {
+      return ( (size_t) i &lt; size ) ? ((size_t) i) : size;
+    }
+  }
+
+  template &lt;class Sequence, class Difference&gt;
+  inline typename Sequence::iterator 
+  getpos(Sequence* self, Difference i)  {
+    typename Sequence::iterator pos = self-&gt;begin(); 
+    std::advance(pos, check_index(i,self-&gt;size()));
+    return pos;
+  }
+
+  template &lt;class Sequence, class Difference&gt;
+  inline typename Sequence::const_iterator 
+  cgetpos(const Sequence* self, Difference i)  {
+    typename Sequence::const_iterator pos = self-&gt;begin(); 
+    std::advance(pos, check_index(i,self-&gt;size()));
+    return pos;
+  }
+
+  template &lt;class Sequence, class Difference&gt;
+  inline Sequence*
+  getslice(const Sequence* self, Difference i, Difference j) { 
+    typename Sequence::size_type size = self-&gt;size();
+    typename Sequence::size_type ii = swig::check_index(i, size);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+    
+    if (jj &gt; ii) {
+      typename Sequence::const_iterator vb = self-&gt;begin();
+      typename Sequence::const_iterator ve = self-&gt;begin();
+      std::advance(vb,ii);
+      std::advance(ve,jj);
+      return new Sequence(vb, ve);
+    } else {
+      return new Sequence();
+    }
+  }
+
+  template &lt;class Sequence, class Difference, class InputSeq&gt;
+  inline void
+  setslice(Sequence* self, Difference i, Difference j, const InputSeq&amp; v) {
+    typename Sequence::size_type size = self-&gt;size();
+    typename Sequence::size_type ii = swig::check_index(i, size, true);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+    if (jj &lt; ii) jj = ii;
+    typename Sequence::iterator sb = self-&gt;begin();
+    typename InputSeq::const_iterator vmid = v.begin();
+    std::advance(sb,ii);
+    std::advance(vmid, jj - ii);
+    self-&gt;insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
+  }
+ 
+  template &lt;class Sequence, class Difference&gt;
+  inline void
+  delslice(Sequence* self, Difference i, Difference j) {
+    typename Sequence::size_type size = self-&gt;size();
+    typename Sequence::size_type ii = swig::check_index(i, size, true);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+    if (jj &gt; ii) {
+      typename Sequence::iterator sb = self-&gt;begin();
+      typename Sequence::iterator se = self-&gt;begin();
+      std::advance(sb,ii);
+      std::advance(se,jj);
+      self-&gt;erase(sb,se);
+    }
+  }
+}
+
+
+#include &lt;iterator&gt;
+namespace swig
+{
+  template &lt;class T&gt; 
+  struct PySequence_Ref
+  {
+    PySequence_Ref(PyObject* seq, int index) 
+      : _seq(seq), _index(index)
+    {
+    }
+
+    operator T () const 
+    {
+      swig::PyObject_var item = PySequence_GetItem(_seq, _index);
+      try {
+	return swig::as&lt;T&gt;(item, true);
+      } catch (std::exception&amp; e) {
+	char msg[1024];
+	sprintf(msg,&quot;in sequence element %d&quot;, _index);
+	if (!PyErr_Occurred()) {
+	  SWIG_type_error(swig::type_name&lt;T&gt;(), item);
+	}
+	SWIG_append_errmsg(msg);
+	throw;
+      }
+    }
+    
+    PySequence_Ref&amp; operator=(const T&amp; v) 
+    {
+      PySequence_SetItem(_seq, _index, swig::from&lt;T&gt;(v));
+      return *this;
+    }
+    
+  private:
+    PyObject* _seq;
+    int _index;
+  };
+
+  template &lt;class T&gt; 
+  struct PySequence_ArrowProxy 
+  {
+    PySequence_ArrowProxy(const T&amp; x): m_value(x) {}
+    const T* operator-&gt;() const { return &amp;m_value; }
+    operator const T*() const { return &amp;m_value; }
+    T m_value;
+  };    
+
+  template &lt;class T, class Reference &gt; 
+  struct PySequence_Iter
+  {
+    typedef PySequence_Iter&lt;T, Reference &gt; self;
+
+    typedef std::random_access_iterator_tag iterator_category;
+    typedef Reference reference;
+    typedef T value_type;
+    typedef T* pointer;
+    typedef int difference_type;
+
+    PySequence_Iter()
+    {
+    }
+
+    PySequence_Iter(PyObject* seq, int index)
+      : _seq(seq), _index(index)
+    {
+    }
+
+    reference operator*() const
+    { 
+      return reference(_seq, _index);
+    }
+
+    PySequence_ArrowProxy&lt;T&gt;
+    operator-&gt;() const {
+      return PySequence_ArrowProxy&lt;T&gt;(operator*());
+    }
+
+    bool operator==(const self&amp; ri) const 
+    { 
+      return (_index == ri._index) &amp;&amp; (_seq == ri._seq);
+    }
+
+    bool operator!=(const self&amp; ri) const 
+    {
+      return !(operator==(ri));
+    }    
+
+    self&amp; operator ++ ()
+    {
+      ++_index;      
+      return *this;
+    }
+
+    self&amp; operator -- ()
+    {
+      --_index;
+      return *this;
+    }
+
+    self&amp; operator += (difference_type n) 
+    {
+      _index += n;
+      return *this;
+    }
+
+    self operator +(difference_type n) const
+    {
+      return self(_seq, _index + n);
+    }
+
+    self&amp; operator -= (difference_type n) 
+    {
+      _index -= n;
+      return *this;
+    }
+
+    self operator -(difference_type n) const
+    {
+      return self(_seq, _index - n);
+    }    
+
+    difference_type operator - (const self&amp; ri) const
+    {
+      return _index - ri._index;
+    }
+
+    reference 
+    operator[](difference_type n) const 
+    { 
+      return reference(_seq, _index + n);
+    }
+
+  private:
+    PyObject* _seq;
+    int _index;
+  }; 
+
+  template &lt;class T&gt; 
+  struct PySequence_Cont
+  {
+    typedef PySequence_Ref&lt;T&gt; reference;
+    typedef const PySequence_Ref&lt;T&gt; const_reference;
+    typedef T value_type;
+    typedef T* pointer;
+    typedef int difference_type;
+    typedef int size_type;
+    typedef const pointer const_pointer;
+    typedef PySequence_Iter&lt;T, reference&gt; iterator;
+    typedef PySequence_Iter&lt;T, const_reference&gt; const_iterator;
+
+    PySequence_Cont(PyObject* seq) : _seq(0)
+    {
+      if (!PySequence_Check(seq)) {
+	throw std::invalid_argument(&quot;a sequence is expected&quot;);
+      }
+      _seq = seq;
+      Py_INCREF(_seq);
+    }
+
+    ~PySequence_Cont() 
+    {
+      if (_seq) Py_DECREF(_seq);
+    }
+
+    size_type size() const
+    {
+      return PySequence_Size(_seq);
+    }
+
+    bool empty() const
+    {
+      return size() == 0;
+    }    
+
+    iterator begin()
+    {
+      return iterator(_seq, 0);
+    }
+
+    const_iterator begin() const
+    {
+      return const_iterator(_seq, 0);
+    }
+    
+    iterator end()
+    {
+      return iterator(_seq, size());
+    }
+    
+    const_iterator end() const
+    {
+      return const_iterator(_seq, size());
+    }    
+
+    reference operator[](difference_type n) 
+    { 
+      return reference(_seq, n);
+    }
+
+    const_reference operator[](difference_type n)  const
+    { 
+      return const_reference(_seq, n);
+    }
+
+    bool check(bool set_err = true) const
+    {
+      int s = size();
+      for (int i = 0; i &lt; s; ++i) {
+	swig::PyObject_var item = PySequence_GetItem(_seq, i);
+	if (!swig::check&lt;value_type&gt;(item)) {
+	  if (set_err) {
+	    char msg[1024];
+	    sprintf(msg,&quot;in sequence element %d&quot;, i);
+	    SWIG_type_error(swig::type_name&lt;value_type&gt;(), item);
+	    SWIG_append_errmsg(msg);
+	  }
+	  return 0;
+	}
+      }
+      return 1;  
+    }
+
+  private:
+    PyObject* _seq;
+  };
+
+}
+
+
+  namespace swig {
+    template &lt;class PySeq, class Seq&gt; 
+    inline void
+    assign(const PySeq&amp; pyseq, Seq* seq) {
+#ifdef SWIG_STD_NOASSIGN_STL
+      typedef typename PySeq::value_type value_type;
+      typename PySeq::const_iterator it = pyseq.begin();
+      for (;it != pyseq.end(); ++it) {
+	seq-&gt;insert(seq-&gt;end(),(value_type)(*it));
+      }
+#else
+      seq-&gt;assign(pyseq.begin(), pyseq.end());
+#endif
+    }
+
+    template &lt;class Seq, class T = typename Seq::value_type &gt;
+    struct traits_asptr_stdseq {
+      typedef Seq sequence;
+      typedef T value_type;
+		    
+      static int asptr(PyObject *obj, sequence **seq) {
+	if (PySequence_Check(obj)) {
+	  try {
+	    PySequence_Cont&lt;value_type&gt; pyseq(obj);
+	    if (seq) {
+	      sequence *pseq = new sequence();
+	      assign(pyseq, pseq);
+	      *seq = pseq;
+	      return SWIG_NEWOBJ;
+	    } else {
+	      return pyseq.check();
+	    }
+	  } catch (std::exception&amp; e) {
+	    if (seq) {
+	      if (!PyErr_Occurred())
+		PyErr_SetString(PyExc_TypeError, e.what());
+	    }
+	    return 0;
+	  }
+	} else {
+	  sequence *p;
+	  if (SWIG_ConvertPtr(obj,(void**)&amp;p,
+			      swig::type_info&lt;sequence&gt;(),0) != -1) {
+	    if (seq) *seq = p;
+	    return 1;
+	  }
+	}
+	if (seq) {
+	  PyErr_Format(PyExc_TypeError, &quot;a %s is expected&quot;, 
+		       swig::type_name&lt;sequence&gt;());
+	}
+	return 0;	  
+      }
+    };
+
+    template &lt;class Seq, class T = typename Seq::value_type &gt;
+    struct traits_from_stdseq {
+      typedef Seq sequence;
+      typedef T value_type;
+      typedef typename Seq::size_type size_type;
+      typedef typename sequence::const_iterator const_iterator;
+
+      static PyObject *from(const sequence&amp; seq) {
+	size_type size = seq.size();
+	if (size &lt;= (size_type)INT_MAX) {
+	  PyObject *obj = PyTuple_New((int)size);
+	  int i = 0;
+	  for (const_iterator it = seq.begin();
+	       it != seq.end(); ++it, ++i) {
+	    PyTuple_SetItem(obj,i,swig::from&lt;value_type&gt;(*it));
+	  }
+	  return obj;
+	} else {
+	  PyErr_SetString(PyExc_OverflowError,
+			  &quot;sequence size not valid in python&quot;);
+	  Py_INCREF(Py_None);
+	  return Py_None;
+	}
+      }
+    };
+  }
+
+
+  namespace swig {
+    template &lt;class T&gt;
+    struct traits_asptr&lt;std::vector&lt;T&gt; &gt;  {
+      static int asptr(PyObject *obj, std::vector&lt;T&gt; **vec) {
+	return traits_asptr_stdseq&lt;std::vector&lt;T&gt; &gt;::asptr(obj, vec);
+      }
+    };
+    
+    template &lt;class T&gt;
+    struct traits_from&lt;std::vector&lt;T&gt; &gt; {
+      static PyObject *from(const std::vector&lt;T&gt;&amp; vec) {
+	return traits_from_stdseq&lt;std::vector&lt;T&gt; &gt;::from(vec);
+      }
+    };
+  }
+
+
+      namespace swig {
+	template &lt;&gt;  struct traits&lt;std::vector&lt;std::string, std::allocator&lt;std::string &gt; &gt; &gt; {
+	  typedef pointer_category category;
+	  static const char* type_name() {
+	    return &quot;std::vector&lt;&quot; &quot;std::string&quot; &quot;,&quot; &quot;std::allocator&lt;std::string &gt;&quot; &quot; &gt;&quot;;
+	  }
+	};
+      }
+    
+
+SWIGINTERNSHORT PyObject* 
+  SWIG_From_unsigned_SS_long(unsigned long value)
+{
+  return (value &gt; LONG_MAX) ?
+    PyLong_FromUnsignedLong(value) 
+    : PyInt_FromLong((long)(value)); 
+}
+
+
+SWIGINTERN int
+  SWIG_AsVal_unsigned_SS_long(PyObject *obj, unsigned long *val) 
+{
+  if (PyInt_Check(obj)) {
+    long v = PyInt_AS_LONG(obj);
+    if (v &gt;= 0) {
+      if (val) *val = v;
+      return 1;
+    }   
+  }
+  if (PyLong_Check(obj)) {
+    unsigned long v = PyLong_AsUnsignedLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return 1;
+    } else {
+      if (!val) PyErr_Clear();
+      return 0;
+    }
+  } 
+  if (val) {
+    SWIG_type_error(&quot;unsigned long&quot;, obj);
+  }
+  return 0;
+}
+
+
+SWIGINTERNSHORT unsigned long
+SWIG_As_unsigned_SS_long(PyObject* obj)
+{
+  unsigned long v;
+  if (!SWIG_AsVal_unsigned_SS_long(obj, &amp;v)) {
+    /*
+      this is needed to make valgrind/purify happier. 
+     */
+    memset((void*)&amp;v, 0, sizeof(unsigned long));
+  }
+  return v;
+}
+
+  
+SWIGINTERNSHORT int
+SWIG_Check_unsigned_SS_long(PyObject* obj)
+{
+  return SWIG_AsVal_unsigned_SS_long(obj, (unsigned long*)0);
+}
+
+static bool std_vector_Sl_std_string_Sg____nonzero__(std::vector&lt;std::string &gt; const *self){
+      return !(self-&gt;empty());
+    }
+static std::vector&lt;std::string &gt;::size_type std_vector_Sl_std_string_Sg____len__(std::vector&lt;std::string &gt; const *self){
+      return self-&gt;size();
+    }
+static std::vector&lt;std::string &gt;::value_type std_vector_Sl_std_string_Sg__pop(std::vector&lt;std::string &gt; *self){
+      if (self-&gt;size() == 0)
+	throw std::out_of_range(&quot;pop from empty container&quot;);
+      std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;::value_type x = self-&gt;back();
+      self-&gt;pop_back();
+      return x;
+    }
+
+SWIGINTERNSHORT long
+SWIG_As_long(PyObject* obj)
+{
+  long v;
+  if (!SWIG_AsVal_long(obj, &amp;v)) {
+    /*
+      this is needed to make valgrind/purify happier. 
+     */
+    memset((void*)&amp;v, 0, sizeof(long));
+  }
+  return v;
+}
+
+  
+SWIGINTERNSHORT int
+SWIG_Check_long(PyObject* obj)
+{
+  return SWIG_AsVal_long(obj, (long*)0);
+}
+
+static std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *std_vector_Sl_std_string_Sg____getslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j){
+      return swig::getslice(self, i, j);
+    }
+static void std_vector_Sl_std_string_Sg____setslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j,std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;v){
+      swig::setslice(self, i, j, v);
+    }
+static void std_vector_Sl_std_string_Sg____delslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j){
+      swig::delslice(self, i, j);
+    }
+static void std_vector_Sl_std_string_Sg____delitem__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i){
+      self-&gt;erase(swig::getpos(self,i));
+    }
+static std::vector&lt;std::string &gt;::value_type const &amp;std_vector_Sl_std_string_Sg____getitem__(std::vector&lt;std::string &gt; const *self,std::vector&lt;std::string &gt;::difference_type i){
+      return *(swig::cgetpos(self, i));
+    }
+static void std_vector_Sl_std_string_Sg____setitem__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::value_type const &amp;x){
+      *(swig::getpos(self,i)) = x;
+    }
+static void std_vector_Sl_std_string_Sg__append(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::value_type const &amp;x){
+      self-&gt;push_back(x);
+    }
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+static PyObject *_wrap_GameAction_clean(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_clean&quot;)) goto fail;
+    GameAction::clean();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_system(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    double arg2 ;
+    double arg3 ;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_add_system&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    GameAction::add_system((std::string const &amp;)*arg1,arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_planet(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    int res1 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_planet&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    result = (int)GameAction::add_planet((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_orbiter_station(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    std::string *arg3 = 0 ;
+    std::string *arg4 = 0 ;
+    std::string *arg5 = 0 ;
+    std::string *arg6 = 0 ;
+    std::string *arg7 = 0 ;
+    int result;
+    int res1 = 0 ;
+    int res2 = 0 ;
+    int res3 = 0 ;
+    int res4 = 0 ;
+    int res5 = 0 ;
+    int res6 = 0 ;
+    int res7 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    PyObject * obj5 = 0 ;
+    PyObject * obj6 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOOOO:GameAction_add_orbiter_station&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4,&amp;obj5,&amp;obj6)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+        if (!res3) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj2);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(3)) SWIG_fail;
+        arg3 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
+        if (!res4) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj3);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(4)) SWIG_fail;
+        arg4 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
+        if (!res5) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj4);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(5)) SWIG_fail;
+        arg5 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res6 = SWIG_AsPtr_std_string(obj5, &amp;ptr);
+        if (!res6) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj5);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(6)) SWIG_fail;
+        arg6 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res7 = SWIG_AsPtr_std_string(obj6, &amp;ptr);
+        if (!res7) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj6);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(7)) SWIG_fail;
+        arg7 = ptr;
+    }
+    result = (int)GameAction::add_orbiter_station((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,(std::string const &amp;)*arg3,(std::string const &amp;)*arg4,(std::string const &amp;)*arg5,(std::string const &amp;)*arg6,(std::string const &amp;)*arg7);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    if (res5 == SWIG_NEWOBJ) delete arg5;
+    if (res6 == SWIG_NEWOBJ) delete arg6;
+    if (res7 == SWIG_NEWOBJ) delete arg7;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    if (res5 == SWIG_NEWOBJ) delete arg5;
+    if (res6 == SWIG_NEWOBJ) delete arg6;
+    if (res7 == SWIG_NEWOBJ) delete arg7;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_asteroid__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    double arg2 ;
+    double arg3 ;
+    double arg4 ;
+    double arg5 ;
+    int result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    {
+        arg5 = (double)(SWIG_As_double(obj4)); 
+        if (SWIG_arg_fail(5)) SWIG_fail;
+    }
+    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3,arg4,arg5);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_asteroid__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    double arg2 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3,arg4);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_asteroid__SWIG_2(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    double arg2 ;
+    double arg3 ;
+    int result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_asteroid__SWIG_3(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    double arg2 ;
+    int result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_asteroid__SWIG_4(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    int result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_add_asteroid&quot;,&amp;obj0)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_asteroid(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[6];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 1) {
+        int _v;
+        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+        if (_v) {
+            return _wrap_GameAction_add_asteroid__SWIG_4(self,args);
+        }
+    }
+    if (argc == 2) {
+        int _v;
+        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                return _wrap_GameAction_add_asteroid__SWIG_3(self,args);
+            }
+        }
+    }
+    if (argc == 3) {
+        int _v;
+        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    return _wrap_GameAction_add_asteroid__SWIG_2(self,args);
+                }
+            }
+        }
+    }
+    if (argc == 4) {
+        int _v;
+        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    _v = SWIG_Check_double(argv[3]);
+                    if (_v) {
+                        return _wrap_GameAction_add_asteroid__SWIG_1(self,args);
+                    }
+                }
+            }
+        }
+    }
+    if (argc == 5) {
+        int _v;
+        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    _v = SWIG_Check_double(argv[3]);
+                    if (_v) {
+                        _v = SWIG_Check_double(argv[4]);
+                        if (_v) {
+                            return _wrap_GameAction_add_asteroid__SWIG_0(self,args);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'GameAction_add_asteroid'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_player(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    int res1 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_player&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    result = (int)GameAction::add_player((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_add_ship(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    double arg3 ;
+    double arg4 ;
+    double arg5 ;
+    int result;
+    int res1 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:GameAction_add_ship&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    {
+        arg5 = (double)(SWIG_As_double(obj4)); 
+        if (SWIG_arg_fail(5)) SWIG_fail;
+    }
+    result = (int)GameAction::add_ship((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4,arg5);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_save_flag__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    int res1 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_save_flag&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    GameAction::save_flag((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_get_string_flag(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_string_flag&quot;,&amp;obj0)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    result = GameAction::get_string_flag((std::string const &amp;)*arg1);
+    
+    {
+        resultobj = SWIG_From_std_string((std::string)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_save_flag__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    double arg2 ;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_save_flag&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    GameAction::save_flag((std::string const &amp;)*arg1,arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_save_flag(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[3];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 2) {
+        int _v;
+        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                return _wrap_GameAction_save_flag__SWIG_1(self,args);
+            }
+        }
+    }
+    if (argc == 2) {
+        int _v;
+        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+        if (_v) {
+            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+            if (_v) {
+                return _wrap_GameAction_save_flag__SWIG_0(self,args);
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'GameAction_save_flag'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_get_double_flag(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    double result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_double_flag&quot;,&amp;obj0)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    result = (double)GameAction::get_double_flag((std::string const &amp;)*arg1);
+    
+    {
+        resultobj = SWIG_From_double((double)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_get_player_ship_id(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_ship_id&quot;)) goto fail;
+    result = (double)GameAction::get_player_ship_id();
+    
+    {
+        resultobj = SWIG_From_double((double)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_get_player_star_system(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_star_system&quot;)) goto fail;
+    result = GameAction::get_player_star_system();
+    
+    {
+        resultobj = SWIG_From_std_string((std::string)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_set_target(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_target&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    GameAction::set_target(arg1,arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_disable_weapon(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_disable_weapon&quot;,&amp;obj0)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    GameAction::disable_weapon(arg1);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_enable_weapon(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_enable_weapon&quot;,&amp;obj0)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    GameAction::enable_weapon(arg1);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_go_to_point(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_go_to_point&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    result = (int)GameAction::go_to_point(arg1,arg2,arg3,arg4);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_go_to_location(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_go_to_location&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    result = (int)GameAction::go_to_location(arg1,arg2,arg3);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_guard_location(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_guard_location&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    result = (int)GameAction::guard_location(arg1,arg2,arg3);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_guard_point(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_guard_point&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    result = (int)GameAction::guard_point(arg1,arg2,arg3,arg4);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_set_ship_team(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_ship_team&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    GameAction::set_ship_team(arg1,arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_get_enemy_team(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    int result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_enemy_team&quot;)) goto fail;
+    result = (int)GameAction::get_enemy_team();
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_get_player_team(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    int result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_team&quot;)) goto fail;
+    result = (int)GameAction::get_player_team();
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_remove_location(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_remove_location&quot;,&amp;obj0)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    GameAction::remove_location(arg1);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_set_crew(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_crew&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    GameAction::set_crew(arg1,arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_end_game(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_end_game&quot;)) goto fail;
+    GameAction::end_game();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_scroll_text(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_scroll_text&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        if (arg1 == NULL) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    GameAction::scroll_text((std::vector&lt;std::string &gt; const &amp;)*arg1,(std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameAction_print_message(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    int arg2 ;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_print_message&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (int)(SWIG_As_int(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    GameAction::print_message((std::string const &amp;)*arg1,arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GameAction(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    GameAction *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GameAction&quot;)) goto fail;
+    result = (GameAction *)new GameAction();
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_GameAction, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GameAction(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    GameAction *arg1 = (GameAction *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameAction&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_GameAction, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GameAction_swigregister(PyObject *, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GameAction, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_DialogApi_startDialog(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_startDialog&quot;)) goto fail;
+    DialogApi::startDialog();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_endDialog(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_endDialog&quot;)) goto fail;
+    DialogApi::endDialog();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_askPlayer(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_askPlayer&quot;,&amp;obj0)) goto fail;
+    {
+        SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        if (arg1 == NULL) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    result = (int)DialogApi::askPlayer((std::vector&lt;std::string &gt; const &amp;)*arg1);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_showText(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    int arg2 ;
+    int arg3 ;
+    int arg4 ;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:DialogApi_showText&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        arg2 = (int)(SWIG_As_int(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (int)(SWIG_As_int(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (int)(SWIG_As_int(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    DialogApi::showText((std::string const &amp;)*arg1,arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_showAlienPicture(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_showAlienPicture&quot;,&amp;obj0)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    DialogApi::showAlienPicture((std::string const &amp;)*arg1);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_DialogApi(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    DialogApi *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_DialogApi&quot;)) goto fail;
+    result = (DialogApi *)new DialogApi();
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_DialogApi, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_DialogApi(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    DialogApi *arg1 = (DialogApi *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_DialogApi&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_DialogApi, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * DialogApi_swigregister(PyObject *, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_DialogApi, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GameConfig_SetGameDirectory(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_SetGameDirectory&quot;,&amp;obj0)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    GameConfig::SetGameDirectory((std::string const &amp;)*arg1);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameConfig_GetGameDirectory(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GameConfig_GetGameDirectory&quot;)) goto fail;
+    result = GameConfig::GetGameDirectory();
+    
+    {
+        resultobj = SWIG_From_std_string((std::string)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GameConfig_GetAbsolutePath(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_GetAbsolutePath&quot;,&amp;obj0)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    result = GameConfig::GetAbsolutePath((std::string const &amp;)*arg1);
+    
+    {
+        resultobj = SWIG_From_std_string((std::string)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GameConfig(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    GameConfig *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GameConfig&quot;)) goto fail;
+    result = (GameConfig *)new GameConfig();
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_GameConfig, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GameConfig(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    GameConfig *arg1 = (GameConfig *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameConfig&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_GameConfig, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GameConfig_swigregister(PyObject *, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GameConfig, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_EventManager_clean(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:EventManager_clean&quot;)) goto fail;
+    EventManager::clean();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_setSingleTimeEvent(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    std::string *arg2 = 0 ;
+    int result;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_setSingleTimeEvent&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    result = (int)EventManager::setSingleTimeEvent(arg1,(std::string const &amp;)*arg2);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_setRepeatableTimeEvent(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    std::string *arg2 = 0 ;
+    int result;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_setRepeatableTimeEvent&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    result = (int)EventManager::setRepeatableTimeEvent(arg1,(std::string const &amp;)*arg2);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_disableEvent(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:EventManager_disableEvent&quot;,&amp;obj0)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    EventManager::disableEvent(arg1);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_shipDeathByName(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    int result;
+    int res1 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathByName&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    result = (int)EventManager::shipDeathByName((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_shipDeathByType(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::string *arg1 = 0 ;
+    std::string *arg2 = 0 ;
+    int result;
+    int res1 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathByType&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    result = (int)EventManager::shipDeathByType((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    double arg4 ;
+    std::string *arg5 = 0 ;
+    int result;
+    int res5 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:EventManager_distanceMoreThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
+        if (!res5) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj4);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(5)) SWIG_fail;
+        arg5 = ptr;
+    }
+    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res5 == SWIG_NEWOBJ) delete arg5;
+    return resultobj;
+    fail:
+    if (res5 == SWIG_NEWOBJ) delete arg5;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_distanceLessThen__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    double arg4 ;
+    std::string *arg5 = 0 ;
+    int result;
+    int res5 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:EventManager_distanceLessThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        arg4 = (double)(SWIG_As_double(obj3)); 
+        if (SWIG_arg_fail(4)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
+        if (!res5) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj4);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(5)) SWIG_fail;
+        arg5 = ptr;
+    }
+    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res5 == SWIG_NEWOBJ) delete arg5;
+    return resultobj;
+    fail:
+    if (res5 == SWIG_NEWOBJ) delete arg5;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    std::string *arg4 = 0 ;
+    int result;
+    int res4 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:EventManager_distanceMoreThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
+        if (!res4) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj3);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(4)) SWIG_fail;
+        arg4 = ptr;
+    }
+    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    return resultobj;
+    fail:
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_distanceMoreThen(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[6];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 4) {
+        int _v;
+        _v = SWIG_Check_double(argv[0]);
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    _v = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+                    if (_v) {
+                        return _wrap_EventManager_distanceMoreThen__SWIG_1(self,args);
+                    }
+                }
+            }
+        }
+    }
+    if (argc == 5) {
+        int _v;
+        _v = SWIG_Check_double(argv[0]);
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    _v = SWIG_Check_double(argv[3]);
+                    if (_v) {
+                        _v = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
+                        if (_v) {
+                            return _wrap_EventManager_distanceMoreThen__SWIG_0(self,args);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'EventManager_distanceMoreThen'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_distanceLessThen__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    double arg2 ;
+    double arg3 ;
+    std::string *arg4 = 0 ;
+    int result;
+    int res4 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:EventManager_distanceLessThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
+        if (!res4) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj3);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(4)) SWIG_fail;
+        arg4 = ptr;
+    }
+    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
+    
+    {
+        resultobj = SWIG_From_int((int)(result)); 
+    }
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    return resultobj;
+    fail:
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_distanceLessThen(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[6];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 4) {
+        int _v;
+        _v = SWIG_Check_double(argv[0]);
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    _v = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+                    if (_v) {
+                        return _wrap_EventManager_distanceLessThen__SWIG_1(self,args);
+                    }
+                }
+            }
+        }
+    }
+    if (argc == 5) {
+        int _v;
+        _v = SWIG_Check_double(argv[0]);
+        if (_v) {
+            _v = SWIG_Check_double(argv[1]);
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    _v = SWIG_Check_double(argv[3]);
+                    if (_v) {
+                        _v = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
+                        if (_v) {
+                            return _wrap_EventManager_distanceLessThen__SWIG_0(self,args);
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'EventManager_distanceLessThen'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_EventManager_AddEventCondition(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    double arg1 ;
+    std::string *arg2 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_AddEventCondition&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        arg1 = (double)(SWIG_As_double(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    EventManager::AddEventCondition(arg1,(std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_EventManager(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    EventManager *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_EventManager&quot;)) goto fail;
+    result = (EventManager *)new EventManager();
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_EventManager, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_EventManager(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    EventManager *arg1 = (EventManager *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_EventManager&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_EventManager, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * EventManager_swigregister(PyObject *, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_EventManager, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_new_SoundSystem__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    bool arg1 ;
+    SoundSystem *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_SoundSystem&quot;,&amp;obj0)) goto fail;
+    {
+        arg1 = (bool)(SWIG_As_bool(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    result = (SoundSystem *)new SoundSystem(arg1);
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_SoundSystem__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_SoundSystem&quot;)) goto fail;
+    result = (SoundSystem *)new SoundSystem();
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_SoundSystem(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[2];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 1); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 0) {
+        return _wrap_new_SoundSystem__SWIG_1(self,args);
+    }
+    if (argc == 1) {
+        int _v;
+        _v = SWIG_Check_bool(argv[0]);
+        if (_v) {
+            return _wrap_new_SoundSystem__SWIG_0(self,args);
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'new_SoundSystem'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_SoundSystem(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_SoundSystem&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_play_music__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    std::string arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:SoundSystem_play_music&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::string *ptr = (std::string *)0;
+        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = *ptr;
+        if (res == SWIG_NEWOBJ) delete ptr;
+    }
+    {
+        arg3 = (int)(SWIG_As_int(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    (arg1)-&gt;play_music(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_play_music__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    std::string arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_play_music&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::string *ptr = (std::string *)0;
+        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = *ptr;
+        if (res == SWIG_NEWOBJ) delete ptr;
+    }
+    (arg1)-&gt;play_music(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_play_music(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[4];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+            if (_v) {
+                return _wrap_SoundSystem_play_music__SWIG_1(self,args);
+            }
+        }
+    }
+    if (argc == 3) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+            if (_v) {
+                _v = SWIG_Check_int(argv[2]);
+                if (_v) {
+                    return _wrap_SoundSystem_play_music__SWIG_0(self,args);
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'SoundSystem_play_music'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_play_sound__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    std::string arg2 ;
+    double arg3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:SoundSystem_play_sound&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::string *ptr = (std::string *)0;
+        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = *ptr;
+        if (res == SWIG_NEWOBJ) delete ptr;
+    }
+    {
+        arg3 = (double)(SWIG_As_double(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    (arg1)-&gt;play_sound(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_play_sound__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    std::string arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_play_sound&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::string *ptr = (std::string *)0;
+        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = *ptr;
+        if (res == SWIG_NEWOBJ) delete ptr;
+    }
+    (arg1)-&gt;play_sound(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_play_sound(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[4];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+            if (_v) {
+                return _wrap_SoundSystem_play_sound__SWIG_1(self,args);
+            }
+        }
+    }
+    if (argc == 3) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+            if (_v) {
+                _v = SWIG_Check_double(argv[2]);
+                if (_v) {
+                    return _wrap_SoundSystem_play_sound__SWIG_0(self,args);
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'SoundSystem_play_sound'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_stop_sound(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    std::string arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_stop_sound&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::string *ptr = (std::string *)0;
+        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::string&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::string&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = *ptr;
+        if (res == SWIG_NEWOBJ) delete ptr;
+    }
+    (arg1)-&gt;stop_sound(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_set_music_volume(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    double arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_set_music_volume&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    (arg1)-&gt;set_music_volume(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_set_sound_volume(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    double arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_set_sound_volume&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (double)(SWIG_As_double(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    (arg1)-&gt;set_sound_volume(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_load_music_volume(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    double result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_music_volume&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = (double)(arg1)-&gt;load_music_volume();
+    
+    {
+        resultobj = SWIG_From_double((double)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_load_sound_volume(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    double result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_sound_volume&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = (double)(arg1)-&gt;load_sound_volume();
+    
+    {
+        resultobj = SWIG_From_double((double)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_playing_music(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    bool result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = (bool)(arg1)-&gt;playing_music();
+    
+    {
+        resultobj = SWIG_From_bool((bool)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SoundSystem_playing_music_file(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *arg1 = (SoundSystem *) 0 ;
+    std::string result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music_file&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = (arg1)-&gt;playing_music_file();
+    
+    {
+        resultobj = SWIG_From_std_string((std::string)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * SoundSystem_swigregister(PyObject *, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_SoundSystem, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static int _wrap_tw_sound_set(PyObject *_val) {
+    {
+        void *temp;
+        if ((SWIG_ConvertPtr(_val, &amp;temp, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN)) == -1) {
+            SWIG_append_errmsg(&quot;C/C++ variable 'tw_sound'&quot;);
+            return 1;
+        }
+        tw_sound = (SoundSystem *) temp;
+    }
+    return 0;
+}
+
+
+static PyObject *_wrap_tw_sound_get(void) {
+    PyObject *pyobj;
+    
+    pyobj = SWIG_NewPointerObj((void *)(tw_sound), SWIGTYPE_p_SoundSystem, 0);
+    return pyobj;
+}
+
+
+static PyObject *_wrap_GetSoundSystem(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    SoundSystem *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GetSoundSystem&quot;)) goto fail;
+    result = (SoundSystem *)GetSoundSystem();
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_vectorString&quot;)) goto fail;
+    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;();
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = 0 ;
+    std::vector&lt;std::string &gt; *result;
+    int res1 = 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) goto fail;
+    {
+        std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *ptr = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)0;
+        res1 = swig::asptr(obj0, &amp;ptr);
+        if (!res1) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string &gt;&quot;, obj0);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;&quot;);
+        }
+        if (SWIG_arg_fail(1)) SWIG_fail;
+        arg1 = ptr;
+    }
+    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;((std::vector&lt;std::string &gt; const &amp;)*arg1);
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return resultobj;
+    fail:
+    if (res1 == SWIG_NEWOBJ) delete arg1;
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_empty(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    bool result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_empty&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = (bool)((std::vector&lt;std::string &gt; const *)arg1)-&gt;empty();
+    
+    {
+        resultobj = SWIG_From_bool((bool)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_size(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::size_type result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_size&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;size();
+    
+    {
+        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_clear(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_clear&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    (arg1)-&gt;clear();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_swap(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt; *arg2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_swap&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        SWIG_Python_ConvertPtr(obj1, (void **)&amp;arg2, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        if (arg2 == NULL) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    (arg1)-&gt;swap(*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_get_allocator(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    SwigValueWrapper&lt;std::allocator&lt;std::string &gt; &gt; result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_get_allocator&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;get_allocator();
+    
+    {
+        std::vector&lt;std::string &gt;::allocator_type * resultptr;
+        resultptr = new std::vector&lt;std::string &gt;::allocator_type((std::vector&lt;std::string &gt;::allocator_type &amp;)(result));
+        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_std__allocatorTstd__string_t, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString__SWIG_2(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt;::size_type arg1 ;
+    std::vector&lt;std::string &gt; *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) goto fail;
+    {
+        arg1 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1);
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_pop_back(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop_back&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    (arg1)-&gt;pop_back();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_resize__SWIG_0(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::size_type arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_resize&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    (arg1)-&gt;resize(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString__SWIG_3(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt;::size_type arg1 ;
+    std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
+    std::vector&lt;std::string &gt; *result;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:new_vectorString&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    {
+        arg1 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
+        if (SWIG_arg_fail(1)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1,(std::string const &amp;)*arg2);
+    
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[3];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 0) {
+        return _wrap_new_vectorString__SWIG_0(self,args);
+    }
+    if (argc == 1) {
+        int _v;
+        _v = SWIG_Check_unsigned_SS_long(argv[0]);
+        if (_v) {
+            return _wrap_new_vectorString__SWIG_2(self,args);
+        }
+    }
+    if (argc == 1) {
+        int _v;
+        _v = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+        if (_v) {
+            return _wrap_new_vectorString__SWIG_1(self,args);
+        }
+    }
+    if (argc == 2) {
+        int _v;
+        _v = SWIG_Check_unsigned_SS_long(argv[0]);
+        if (_v) {
+            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+            if (_v) {
+                return _wrap_new_vectorString__SWIG_3(self,args);
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'new_vectorString'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_push_back(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_push_back&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    (arg1)-&gt;push_back((std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_front(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::value_type *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_front&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;front();
+        result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
+    }
+    
+    {
+        resultobj = SWIG_From_std_string((std::string)(*result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_back(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::value_type *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_back&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;back();
+        result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
+    }
+    
+    {
+        resultobj = SWIG_From_std_string((std::string)(*result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_assign(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::size_type arg2 ;
+    std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
+    int res3 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_assign&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+        if (!res3) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj2);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
+        }
+        if (SWIG_arg_fail(3)) SWIG_fail;
+        arg3 = ptr;
+    }
+    (arg1)-&gt;assign(arg2,(std::string const &amp;)*arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    return resultobj;
+    fail:
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_resize__SWIG_1(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::size_type arg2 ;
+    std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
+    int res3 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_resize&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+        if (!res3) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj2);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
+        }
+        if (SWIG_arg_fail(3)) SWIG_fail;
+        arg3 = ptr;
+    }
+    (arg1)-&gt;resize(arg2,(std::string const &amp;)*arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    return resultobj;
+    fail:
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_resize(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[4];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            _v = SWIG_Check_unsigned_SS_long(argv[1]);
+            if (_v) {
+                return _wrap_vectorString_resize__SWIG_0(self,args);
+            }
+        }
+    }
+    if (argc == 3) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            _v = SWIG_Check_unsigned_SS_long(argv[1]);
+            if (_v) {
+                _v = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
+                if (_v) {
+                    return _wrap_vectorString_resize__SWIG_1(self,args);
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_resize'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_reserve(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::size_type arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_reserve&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    (arg1)-&gt;reserve(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_capacity(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::size_type result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_capacity&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;capacity();
+    
+    {
+        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___nonzero__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    bool result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___nonzero__&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = (bool)std_vector_Sl_std_string_Sg____nonzero__((std::vector&lt;std::string &gt; const *)arg1);
+    
+    {
+        resultobj = SWIG_From_bool((bool)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___len__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::size_type result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___len__&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    result = std_vector_Sl_std_string_Sg____len__((std::vector&lt;std::string &gt; const *)arg1);
+    
+    {
+        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_pop(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::value_type result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        try {
+            result = std_vector_Sl_std_string_Sg__pop(arg1);
+        }
+        catch (std::out_of_range&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }
+        }
+        /*@c:\\swig\\Lib\\exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
+            SWIG_exception(SWIG_SystemError, e.what() );
+        }
+        catch (...) {
+            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
+        }
+        /*@@*/
+    }
+    {
+        resultobj = SWIG_From_std_string((std::string)(result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___getslice__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::difference_type arg2 ;
+    std::vector&lt;std::string &gt;::difference_type arg3 ;
+    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___getslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        try {
+            result = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)std_vector_Sl_std_string_Sg____getslice__(arg1,arg2,arg3);
+        }
+        catch (std::out_of_range&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }
+        }
+        /*@c:\\swig\\Lib\\exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
+            SWIG_exception(SWIG_SystemError, e.what() );
+        }
+        catch (...) {
+            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
+        }
+        /*@@*/
+    }
+    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___setslice__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::difference_type arg2 ;
+    std::vector&lt;std::string &gt;::difference_type arg3 ;
+    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *arg4 = 0 ;
+    int res4 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:vectorString___setslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *ptr = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)0;
+        res4 = swig::asptr(obj3, &amp;ptr);
+        if (!res4) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;&quot;, obj3);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;&quot;);
+        }
+        if (SWIG_arg_fail(4)) SWIG_fail;
+        arg4 = ptr;
+    }
+    {
+        try {
+            std_vector_Sl_std_string_Sg____setslice__(arg1,arg2,arg3,(std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;)*arg4);
+        }
+        catch (std::out_of_range&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }
+        }
+        catch (std::invalid_argument&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_TypeError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }      
+        }
+        /*@c:\\swig\\Lib\\exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
+            SWIG_exception(SWIG_SystemError, e.what() );
+        }
+        catch (...) {
+            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
+        }
+        /*@@*/
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    return resultobj;
+    fail:
+    if (res4 == SWIG_NEWOBJ) delete arg4;
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___delslice__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::difference_type arg2 ;
+    std::vector&lt;std::string &gt;::difference_type arg3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___delslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        arg3 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj2)); 
+        if (SWIG_arg_fail(3)) SWIG_fail;
+    }
+    {
+        try {
+            std_vector_Sl_std_string_Sg____delslice__(arg1,arg2,arg3);
+        }
+        catch (std::out_of_range&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }
+        }
+        /*@c:\\swig\\Lib\\exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
+            SWIG_exception(SWIG_SystemError, e.what() );
+        }
+        catch (...) {
+            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
+        }
+        /*@@*/
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___delitem__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::difference_type arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString___delitem__&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        try {
+            std_vector_Sl_std_string_Sg____delitem__(arg1,arg2);
+        }
+        catch (std::out_of_range&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }
+        }
+        /*@c:\\swig\\Lib\\exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
+            SWIG_exception(SWIG_SystemError, e.what() );
+        }
+        catch (...) {
+            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
+        }
+        /*@@*/
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___getitem__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::difference_type arg2 ;
+    std::vector&lt;std::string &gt;::value_type *result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString___getitem__&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        try {
+            {
+                std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = std_vector_Sl_std_string_Sg____getitem__((std::vector&lt;std::string &gt; const *)arg1,arg2);
+                result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
+            }
+        }
+        catch (std::out_of_range&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }
+        }
+        /*@c:\\swig\\Lib\\exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
+            SWIG_exception(SWIG_SystemError, e.what() );
+        }
+        catch (...) {
+            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
+        }
+        /*@@*/
+    }
+    {
+        resultobj = SWIG_From_std_string((std::string)(*result)); 
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___setitem__(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::difference_type arg2 ;
+    std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
+    int res3 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___setitem__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
+        if (SWIG_arg_fail(2)) SWIG_fail;
+    }
+    {
+        std::string *ptr = (std::string *)0;
+        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+        if (!res3) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj2);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
+        }
+        if (SWIG_arg_fail(3)) SWIG_fail;
+        arg3 = ptr;
+    }
+    {
+        try {
+            std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,(std::string const &amp;)*arg3);
+        }
+        catch (std::out_of_range&amp; e) {
+            if (!PyErr_Occurred()) {
+                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+            } else {
+                SWIG_fail;
+            }
+        }
+        /*@c:\\swig\\Lib\\exception.i,336,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
+            SWIG_exception(SWIG_SystemError, e.what() );
+        }
+        catch (...) {
+            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
+        }
+        /*@@*/
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    return resultobj;
+    fail:
+    if (res3 == SWIG_NEWOBJ) delete arg3;
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_append(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
+    int res2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_append&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    {
+        std::string *ptr = (std::string *)0;
+        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+        if (!res2) {
+            if (!PyErr_Occurred())
+            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj1);
+        } else if (!ptr) {
+            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
+        }
+        if (SWIG_arg_fail(2)) SWIG_fail;
+        arg2 = ptr;
+    }
+    std_vector_Sl_std_string_Sg__append(arg1,(std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return resultobj;
+    fail:
+    if (res2 == SWIG_NEWOBJ) delete arg2;
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_vectorString(PyObject *, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_vectorString&quot;,&amp;obj0)) goto fail;
+    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
+    if (SWIG_arg_fail(1)) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * vectorString_swigregister(PyObject *, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyMethodDef SwigMethods[] = {
+	 { (char *)&quot;GameAction_clean&quot;, _wrap_GameAction_clean, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_system&quot;, _wrap_GameAction_add_system, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_planet&quot;, _wrap_GameAction_add_planet, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_orbiter_station&quot;, _wrap_GameAction_add_orbiter_station, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_asteroid&quot;, _wrap_GameAction_add_asteroid, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_player&quot;, _wrap_GameAction_add_player, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_ship&quot;, _wrap_GameAction_add_ship, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_string_flag&quot;, _wrap_GameAction_get_string_flag, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_save_flag&quot;, _wrap_GameAction_save_flag, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_double_flag&quot;, _wrap_GameAction_get_double_flag, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_player_ship_id&quot;, _wrap_GameAction_get_player_ship_id, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_player_star_system&quot;, _wrap_GameAction_get_player_star_system, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_set_target&quot;, _wrap_GameAction_set_target, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_disable_weapon&quot;, _wrap_GameAction_disable_weapon, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_enable_weapon&quot;, _wrap_GameAction_enable_weapon, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_go_to_point&quot;, _wrap_GameAction_go_to_point, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_go_to_location&quot;, _wrap_GameAction_go_to_location, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_guard_location&quot;, _wrap_GameAction_guard_location, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_guard_point&quot;, _wrap_GameAction_guard_point, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_set_ship_team&quot;, _wrap_GameAction_set_ship_team, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_enemy_team&quot;, _wrap_GameAction_get_enemy_team, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_player_team&quot;, _wrap_GameAction_get_player_team, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_remove_location&quot;, _wrap_GameAction_remove_location, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_set_crew&quot;, _wrap_GameAction_set_crew, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_end_game&quot;, _wrap_GameAction_end_game, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_scroll_text&quot;, _wrap_GameAction_scroll_text, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_print_message&quot;, _wrap_GameAction_print_message, METH_VARARGS, NULL},
+	 { (char *)&quot;new_GameAction&quot;, _wrap_new_GameAction, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_GameAction&quot;, _wrap_delete_GameAction, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_swigregister&quot;, GameAction_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_startDialog&quot;, _wrap_DialogApi_startDialog, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_endDialog&quot;, _wrap_DialogApi_endDialog, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_askPlayer&quot;, _wrap_DialogApi_askPlayer, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_showText&quot;, _wrap_DialogApi_showText, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_showAlienPicture&quot;, _wrap_DialogApi_showAlienPicture, METH_VARARGS, NULL},
+	 { (char *)&quot;new_DialogApi&quot;, _wrap_new_DialogApi, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_DialogApi&quot;, _wrap_delete_DialogApi, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_swigregister&quot;, DialogApi_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_SetGameDirectory&quot;, _wrap_GameConfig_SetGameDirectory, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_GetGameDirectory&quot;, _wrap_GameConfig_GetGameDirectory, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_GetAbsolutePath&quot;, _wrap_GameConfig_GetAbsolutePath, METH_VARARGS, NULL},
+	 { (char *)&quot;new_GameConfig&quot;, _wrap_new_GameConfig, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_GameConfig&quot;, _wrap_delete_GameConfig, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_swigregister&quot;, GameConfig_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_clean&quot;, _wrap_EventManager_clean, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_setSingleTimeEvent&quot;, _wrap_EventManager_setSingleTimeEvent, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_setRepeatableTimeEvent&quot;, _wrap_EventManager_setRepeatableTimeEvent, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_disableEvent&quot;, _wrap_EventManager_disableEvent, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_shipDeathByName&quot;, _wrap_EventManager_shipDeathByName, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_shipDeathByType&quot;, _wrap_EventManager_shipDeathByType, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_distanceMoreThen&quot;, _wrap_EventManager_distanceMoreThen, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_distanceLessThen&quot;, _wrap_EventManager_distanceLessThen, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_AddEventCondition&quot;, _wrap_EventManager_AddEventCondition, METH_VARARGS, NULL},
+	 { (char *)&quot;new_EventManager&quot;, _wrap_new_EventManager, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_EventManager&quot;, _wrap_delete_EventManager, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_swigregister&quot;, EventManager_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;new_SoundSystem&quot;, _wrap_new_SoundSystem, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_SoundSystem&quot;, _wrap_delete_SoundSystem, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_play_music&quot;, _wrap_SoundSystem_play_music, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_play_sound&quot;, _wrap_SoundSystem_play_sound, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_stop_sound&quot;, _wrap_SoundSystem_stop_sound, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_set_music_volume&quot;, _wrap_SoundSystem_set_music_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_set_sound_volume&quot;, _wrap_SoundSystem_set_sound_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_load_music_volume&quot;, _wrap_SoundSystem_load_music_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_load_sound_volume&quot;, _wrap_SoundSystem_load_sound_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_playing_music&quot;, _wrap_SoundSystem_playing_music, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_playing_music_file&quot;, _wrap_SoundSystem_playing_music_file, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_swigregister&quot;, SoundSystem_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;GetSoundSystem&quot;, _wrap_GetSoundSystem, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_empty&quot;, _wrap_vectorString_empty, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_size&quot;, _wrap_vectorString_size, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_clear&quot;, _wrap_vectorString_clear, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_swap&quot;, _wrap_vectorString_swap, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_get_allocator&quot;, _wrap_vectorString_get_allocator, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_pop_back&quot;, _wrap_vectorString_pop_back, METH_VARARGS, NULL},
+	 { (char *)&quot;new_vectorString&quot;, _wrap_new_vectorString, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_push_back&quot;, _wrap_vectorString_push_back, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_front&quot;, _wrap_vectorString_front, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_back&quot;, _wrap_vectorString_back, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_assign&quot;, _wrap_vectorString_assign, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_resize&quot;, _wrap_vectorString_resize, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_reserve&quot;, _wrap_vectorString_reserve, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_capacity&quot;, _wrap_vectorString_capacity, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___nonzero__&quot;, _wrap_vectorString___nonzero__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___len__&quot;, _wrap_vectorString___len__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_pop&quot;, _wrap_vectorString_pop, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___getslice__&quot;, _wrap_vectorString___getslice__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___setslice__&quot;, _wrap_vectorString___setslice__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___delslice__&quot;, _wrap_vectorString___delslice__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___delitem__&quot;, _wrap_vectorString___delitem__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___getitem__&quot;, _wrap_vectorString___getitem__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___setitem__&quot;, _wrap_vectorString___setitem__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_append&quot;, _wrap_vectorString_append, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_vectorString&quot;, _wrap_delete_vectorString, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_swigregister&quot;, vectorString_swigregister, METH_VARARGS, NULL},
+	 { NULL, NULL, 0, NULL }
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t[] = {{&quot;_p_std__vectorTstd__string_std__allocatorTstd__string_t_t&quot;, 0, &quot;std::vector&lt;std::string &gt; *&quot;, 0, 0, 0, 0},{&quot;_p_std__vectorTstd__string_std__allocatorTstd__string_t_t&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__std__size_t[] = {{&quot;_std__size_t&quot;, 0, &quot;std::size_t&quot;, 0, 0, 0, 0},{&quot;_std__size_t&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__size_t[] = {{&quot;_size_t&quot;, 0, &quot;size_t&quot;, 0, 0, 0, 0},{&quot;_size_t&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_EventManager[] = {{&quot;_p_EventManager&quot;, 0, &quot;EventManager *&quot;, 0, 0, 0, 0},{&quot;_p_EventManager&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_allocator_type[] = {{&quot;_p_allocator_type&quot;, 0, &quot;allocator_type *&quot;, 0, 0, 0, 0},{&quot;_p_allocator_type&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_size_type[] = {{&quot;_p_size_type&quot;, 0, &quot;size_type *&quot;, 0, 0, 0, 0},{&quot;_p_size_type&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_char[] = {{&quot;_p_char&quot;, 0, &quot;char *&quot;, 0, 0, 0, 0},{&quot;_p_char&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_GameConfig[] = {{&quot;_p_GameConfig&quot;, 0, &quot;GameConfig *&quot;, 0, 0, 0, 0},{&quot;_p_GameConfig&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_GameAction[] = {{&quot;_p_GameAction&quot;, 0, &quot;GameAction *&quot;, 0, 0, 0, 0},{&quot;_p_GameAction&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_value_type[] = {{&quot;_p_value_type&quot;, 0, &quot;value_type *&quot;, 0, 0, 0, 0},{&quot;_p_value_type&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_difference_type[] = {{&quot;_p_difference_type&quot;, 0, &quot;difference_type *&quot;, 0, 0, 0, 0},{&quot;_p_difference_type&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__std__ptrdiff_t[] = {{&quot;_std__ptrdiff_t&quot;, 0, &quot;std::ptrdiff_t&quot;, 0, 0, 0, 0},{&quot;_std__ptrdiff_t&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__ptrdiff_t[] = {{&quot;_ptrdiff_t&quot;, 0, &quot;ptrdiff_t&quot;, 0, 0, 0, 0},{&quot;_ptrdiff_t&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_DialogApi[] = {{&quot;_p_DialogApi&quot;, 0, &quot;DialogApi *&quot;, 0, 0, 0, 0},{&quot;_p_DialogApi&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_SoundSystem[] = {{&quot;_p_SoundSystem&quot;, 0, &quot;SoundSystem *&quot;, 0, 0, 0, 0},{&quot;_p_SoundSystem&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+static swig_type_info _swigt__p_std__allocatorTstd__string_t[] = {{&quot;_p_std__allocatorTstd__string_t&quot;, 0, &quot;std::allocator&lt;std::string &gt; *|std::vector&lt;std::string &gt;::allocator_type *&quot;, 0, 0, 0, 0},{&quot;_p_std__allocatorTstd__string_t&quot;, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0}};
+
+static swig_type_info *swig_types_initial[] = {
+_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 
+_swigt__std__size_t, 
+_swigt__size_t, 
+_swigt__p_EventManager, 
+_swigt__p_allocator_type, 
+_swigt__p_size_type, 
+_swigt__p_char, 
+_swigt__p_GameConfig, 
+_swigt__p_GameAction, 
+_swigt__p_value_type, 
+_swigt__p_difference_type, 
+_swigt__std__ptrdiff_t, 
+_swigt__ptrdiff_t, 
+_swigt__p_DialogApi, 
+_swigt__p_SoundSystem, 
+_swigt__p_std__allocatorTstd__string_t, 
+0
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+static swig_const_info swig_const_table[] = {
+{0, 0, 0, 0.0, 0, 0}};
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+    
+    /* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+    
+    /* -----------------------------------------------------------------------------
+     * global variable support code.
+     * ----------------------------------------------------------------------------- */
+    
+    typedef struct swig_globalvar {
+        char       *name;                  /* Name of global variable */
+        PyObject *(*get_attr)();           /* Return the current value */
+        int       (*set_attr)(PyObject *); /* Set the value */
+        struct swig_globalvar *next;
+    } swig_globalvar;
+    
+    typedef struct swig_varlinkobject {
+        PyObject_HEAD
+        swig_globalvar *vars;
+    } swig_varlinkobject;
+    
+    static PyObject *
+    swig_varlink_repr(swig_varlinkobject *v) {
+        v = v;
+        return PyString_FromString(&quot;&lt;Swig global variables&gt;&quot;);
+    }
+    
+    static int
+    swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
+        swig_globalvar  *var;
+        flags = flags;
+        fprintf(fp,&quot;Swig global variables { &quot;);
+        for (var = v-&gt;vars; var; var=var-&gt;next) {
+            fprintf(fp,&quot;%s&quot;, var-&gt;name);
+            if (var-&gt;next) fprintf(fp,&quot;, &quot;);
+        }
+        fprintf(fp,&quot; }\n&quot;);
+        return 0;
+    }
+    
+    static PyObject *
+    swig_varlink_getattr(swig_varlinkobject *v, char *n) {
+        swig_globalvar *var = v-&gt;vars;
+        while (var) {
+            if (strcmp(var-&gt;name,n) == 0) {
+                return (*var-&gt;get_attr)();
+            }
+            var = var-&gt;next;
+        }
+        PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+        return NULL;
+    }
+    
+    static int
+    swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
+        swig_globalvar *var = v-&gt;vars;
+        while (var) {
+            if (strcmp(var-&gt;name,n) == 0) {
+                return (*var-&gt;set_attr)(p);
+            }
+            var = var-&gt;next;
+        }
+        PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+        return 1;
+    }
+    
+    static PyTypeObject varlinktype = {
+        PyObject_HEAD_INIT(0)              
+        0,                                  /* Number of items in variable part (ob_size) */
+        (char *)&quot;swigvarlink&quot;,              /* Type name (tp_name) */
+        sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
+        0,                                  /* Itemsize (tp_itemsize) */
+        0,                                  /* Deallocator (tp_dealloc) */ 
+        (printfunc) swig_varlink_print,     /* Print (tp_print) */
+        (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
+        (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
+        0,                                  /* tp_compare */
+        (reprfunc) swig_varlink_repr,       /* tp_repr */
+        0,                                  /* tp_as_number */
+        0,                                  /* tp_as_sequence */
+        0,                                  /* tp_as_mapping */
+        0,                                  /* tp_hash */
+        0,                                  /* tp_call */
+        0,                                  /* tp_str */
+        0,                                  /* tp_getattro */
+        0,                                  /* tp_setattro */
+        0,                                  /* tp_as_buffer */
+        0,                                  /* tp_flags */
+        0,                                  /* tp_doc */
+#if PY_VERSION_HEX &gt;= 0x02000000
+        0,                                  /* tp_traverse */
+        0,                                  /* tp_clear */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02010000
+        0,                                  /* tp_richcompare */
+        0,                                  /* tp_weaklistoffset */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02020000
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -&gt; tp_weaklist */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02030000
+        0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+        0,0,0,0                             /* tp_alloc -&gt; tp_next */
+#endif
+    };
+    
+    /* Create a variable linking object for use later */
+    static PyObject *
+    SWIG_Python_newvarlink(void) {
+        swig_varlinkobject *result = 0;
+        result = PyMem_NEW(swig_varlinkobject,1);
+        varlinktype.ob_type = &amp;PyType_Type;    /* Patch varlinktype into a PyType */
+        result-&gt;ob_type = &varlinktype;
+        result-&gt;vars = 0;
+        result-&gt;ob_refcnt = 0;
+        Py_XINCREF((PyObject *) result);
+        return ((PyObject*) result);
+    }
+    
+    static void
+    SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+        swig_varlinkobject *v;
+        swig_globalvar *gv;
+        v= (swig_varlinkobject *) p;
+        gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+        gv-&gt;name = (char *) malloc(strlen(name)+1);
+        strcpy(gv-&gt;name,name);
+        gv-&gt;get_attr = get_attr;
+        gv-&gt;set_attr = set_attr;
+        gv-&gt;next = v-&gt;vars;
+        v-&gt;vars = gv;
+    }
+    
+    /* -----------------------------------------------------------------------------
+     * constants/methods manipulation
+     * ----------------------------------------------------------------------------- */
+    
+    /* Install Constants */
+    static void
+    SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
+        PyObject *obj = 0;
+        size_t i;
+        for (i = 0; constants[i].type; i++) {
+            switch(constants[i].type) {
+                case SWIG_PY_INT:
+                obj = PyInt_FromLong(constants[i].lvalue);
+                break;
+                case SWIG_PY_FLOAT:
+                obj = PyFloat_FromDouble(constants[i].dvalue);
+                break;
+                case SWIG_PY_STRING:
+                if (constants[i].pvalue) {
+                    obj = PyString_FromString((char *) constants[i].pvalue);
+                } else {
+                    Py_INCREF(Py_None);
+                    obj = Py_None;
+                }
+                break;
+                case SWIG_PY_POINTER:
+                obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+                break;
+                case SWIG_PY_BINARY:
+                obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+                break;
+                default:
+                obj = 0;
+                break;
+            }
+            if (obj) {
+                PyDict_SetItemString(d,constants[i].name,obj);
+                Py_DECREF(obj);
+            }
+        }
+    }
+    
+    /* -----------------------------------------------------------------------------*/
+    /* Fix SwigMethods to carry the callback ptrs when needed */
+    /* -----------------------------------------------------------------------------*/
+    
+    static void
+    SWIG_Python_FixMethods(PyMethodDef *methods,
+    swig_const_info *const_table,
+    swig_type_info **types,
+    swig_type_info **types_initial) {
+        size_t i;
+        for (i = 0; methods[i].ml_name; ++i) {
+            char *c = methods[i].ml_doc;
+            if (c &amp;&amp; (c = strstr(c, &quot;swig_ptr: &quot;))) {
+                int j;
+                swig_const_info *ci = 0;
+                char *name = c + 10;
+                for (j = 0; const_table[j].type; j++) {
+                    if (strncmp(const_table[j].name, name, 
+                    strlen(const_table[j].name)) == 0) {
+                        ci = &amp;(const_table[j]);
+                        break;
+                    }
+                }
+                if (ci) {
+                    size_t shift = (ci-&gt;ptype) - types;
+                    swig_type_info *ty = types_initial[shift];
+                    size_t ldoc = (c - methods[i].ml_doc);
+                    size_t lptr = strlen(ty-&gt;name)+2*sizeof(void*)+2;
+                    char *ndoc = (char*)malloc(ldoc + lptr + 10);
+                    char *buff = ndoc;
+                    void *ptr = (ci-&gt;type == SWIG_PY_POINTER) ? ci-&gt;pvalue: (void *)(ci-&gt;lvalue);
+                    strncpy(buff, methods[i].ml_doc, ldoc);
+                    buff += ldoc;
+                    strncpy(buff, &quot;swig_ptr: &quot;, 10);
+                    buff += 10;
+                    SWIG_PackVoidPtr(buff, ptr, ty-&gt;name, lptr);
+                    methods[i].ml_doc = ndoc;
+                }
+            }
+        }
+    }
+    
+    /* -----------------------------------------------------------------------------*
+     *  Initialize type list
+     * -----------------------------------------------------------------------------*/
+    
+#if PY_MAJOR_VERSION &lt; 2
+    /* PyModule_AddObject function was introduced in Python 2.0.  The following function
+    is copied out of Python/modsupport.c in python version 2.3.4 */
+    static int
+    PyModule_AddObject(PyObject *m, char *name, PyObject *o)
+    {
+        PyObject *dict;
+        if (!PyModule_Check(m)) {
+            PyErr_SetString(PyExc_TypeError,
+            &quot;PyModule_AddObject() needs module as first arg&quot;);
+            return -1;
+        }
+        if (!o) {
+            PyErr_SetString(PyExc_TypeError,
+            &quot;PyModule_AddObject() needs non-NULL value&quot;);
+            return -1;
+        }
+        
+        dict = PyModule_GetDict(m);
+        if (dict == NULL) {
+            /* Internal error -- modules must have a dict! */
+            PyErr_Format(PyExc_SystemError, &quot;module '%s' has no __dict__&quot;,
+            PyModule_GetName(m));
+            return -1;
+        }
+        if (PyDict_SetItemString(dict, name, o))
+        return -1;
+        Py_DECREF(o);
+        return 0;
+    }
+#endif
+    
+    static swig_type_info **
+    SWIG_Python_SetTypeListHandle(swig_type_info **type_list_handle) {
+        static PyMethodDef swig_empty_runtime_method_table[] = {
+            {
+                NULL, NULL, 0, NULL
+            } 
+        };/* Sentinel */
+        
+        PyObject *module = Py_InitModule((char*)&quot;swig_runtime_data&quot; SWIG_RUNTIME_VERSION,
+        swig_empty_runtime_method_table);
+        PyObject *pointer = PyCObject_FromVoidPtr((void *) type_list_handle, NULL);
+        if (pointer &amp;&amp; module) {
+            PyModule_AddObject(module, (char*)&quot;type_pointer&quot; SWIG_TYPE_TABLE_NAME, pointer);
+        }
+        return type_list_handle;
+    } 
+    
+    static swig_type_info **
+    SWIG_Python_LookupTypePointer(swig_type_info **type_list_handle) {
+        swig_type_info **type_pointer;
+        
+        /* first check if module already created */
+        type_pointer = SWIG_Python_GetTypeListHandle();
+        if (type_pointer) {
+            return type_pointer;
+        } else {
+            /* create a new module and variable */
+            return SWIG_Python_SetTypeListHandle(type_list_handle);
+        }
+    }
+    
+#ifdef __cplusplus
+}
+#endif
+
+/* -----------------------------------------------------------------------------*
+ *  Partial Init method
+ * -----------------------------------------------------------------------------*/
+
+#ifdef SWIG_LINK_RUNTIME
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+SWIGEXPORT(void *) SWIG_ReturnGlobalTypeList(void *);
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+SWIGEXPORT(void) SWIG_init(void) {
+    static PyObject *SWIG_globals = 0; 
+    static int       typeinit = 0;
+    PyObject *m, *d;
+    int       i;
+    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
+    
+    /* Fix SwigMethods to carry the callback ptrs when needed */
+    SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_types_initial);
+    
+    m = Py_InitModule((char *) SWIG_name, SwigMethods);
+    d = PyModule_GetDict(m);
+    
+    if (!typeinit) {
+#ifdef SWIG_LINK_RUNTIME
+        swig_type_list_handle = (swig_type_info **) SWIG_ReturnGlobalTypeList(swig_type_list_handle);
+#else
+#  ifndef SWIG_STATIC_RUNTIME
+        swig_type_list_handle = SWIG_Python_LookupTypePointer(swig_type_list_handle);
+#  endif
+#endif
+        for (i = 0; swig_types_initial[i]; i++) {
+            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
+        }
+        typeinit = 1;
+    }
+    SWIG_InstallConstants(d,swig_const_table);
+    
+    PyDict_SetItemString(d,(char*)&quot;cvar&quot;, SWIG_globals);
+    SWIG_addvarlink(SWIG_globals,(char*)&quot;tw_sound&quot;,_wrap_tw_sound_get, _wrap_tw_sound_set);
+}
+

Modified: trunk/source/libraries/agup/abitmap.c
===================================================================
--- trunk/source/libraries/agup/abitmap.c	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/source/libraries/agup/abitmap.c	2005-07-24 17:51:13 UTC (rev 171)
@@ -23,7 +23,7 @@
 #include &quot;agup.h&quot;
 #include &quot;agupitrn.h&quot;
 
-#ifdef MINGW
+#ifdef _MSC_VER
 #define snprintf _snprintf
 #endif
 
@@ -168,7 +168,7 @@
 /* Given two sizes, return an offset &lt;= 0, so when texturing the area of size1
  * with a texture of size size2, the center will be aligned.
  */
-static inline int
+static int
 centered_offset (int size1, int size2)
 {
     int center1, center2, o;
@@ -183,7 +183,7 @@
     return o;
 }
 
-static inline void
+static void
 masked_non_stretched_blit (BITMAP *s, BITMAP *d, int sx, int sy, int w, int h,
                            int dx, int dy, int _, int __)
 {
@@ -202,7 +202,7 @@
 };
 /* Draw a column of pattern pat into the bitmap bmp inside the given rectangle.
  */
-static inline void
+static void
 blit_column (BITMAP *bmp, struct ABMAP *pat, int x, int y, int w, int h, enum COLUMN_TYPE f)
 {
     int ct = bmp-&gt;ct, cb = bmp-&gt;cb;
@@ -363,7 +363,7 @@
     bmp-&gt;cb = cb;
 }
 
-static inline int
+static int
 get_state (DIALOG *d)
 {
     if (d-&gt;flags &amp; D_DISABLED)

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/source/melee/mframe.cpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -1373,7 +1373,7 @@
   presence.sort(presence_cmp);
   item.sort(presence_cmp);
 
-  std::copy(item.begin(),item.end(),back_inserter(animate_buffer));
+  std::copy(item.begin(),item.end(),std::back_inserter(animate_buffer));
   animate_buffer2 = presence;
   animate_buffer.merge(animate_buffer2,presence_cmp);
 

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/source/melee/mgame.cpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -226,7 +226,7 @@
 	    } break;
 	  }
 	std::list&lt;BaseClass*&gt;b_presence;
-	std::copy(presence.begin(),presence.end(),back_inserter(b_presence));
+	std::copy(presence.begin(),presence.end(),std::back_inserter(b_presence));
 	issue_event(b_presence, e);
 	std::list&lt;BaseClass*&gt; b_item;
 	std::copy(item.begin(),item.end(),std::back_inserter(b_item));

Modified: trunk/source/python/fileops.cpp
===================================================================
--- trunk/source/python/fileops.cpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/source/python/fileops.cpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -348,7 +348,11 @@
     char sf[16];
     
     // floats saved as strings to remain independent of architecture
+    #ifdef _MSC_VER
+    _snprintf (sf, 16, &quot;%f&quot;, f);
+    #else
     snprintf (sf, 16, &quot;%f&quot;, f);
+    #endif
     sf &gt;&gt; gfile;
     
     return f;

Modified: trunk/source/python/game.cpp
===================================================================
--- trunk/source/python/game.cpp	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/source/python/game.cpp	2005-07-24 17:51:13 UTC (rev 171)
@@ -28,7 +28,7 @@
 #include &quot;game.h&quot;
 #include &lt;stdlib.h&gt;
 #include &lt;sys/types.h&gt;
-#include &lt;dirent.h&gt;
+//#include &lt;dirent.h&gt;
 
 #include &quot;util/errors.h&quot;
 #include &quot;tml/gameconfig.h&quot;
@@ -57,6 +57,8 @@
 
 bool game::directory_exist (const std::string &amp; dirname)
 {
+  return true;
+  /*
     DIR * dir = opendir (dirname.c_str ());
 
     if (dir) 
@@ -66,6 +68,7 @@
     }
 
     return false; 
+  */
 }
 
 bool game::file_exist (const std::string &amp; fname) 

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-07-22 17:15:01 UTC (rev 170)
+++ trunk/sources.lst	2005-07-24 17:51:13 UTC (rev 171)
@@ -115,7 +115,6 @@
 source/ships/shpzeksh.cpp
 source/tests/gameconfigtest.cpp
 source/tests/testdatapath.cpp
-source/tests/TestFleetEditor.cpp
 source/tests/testmain.cpp
 source/tml/eventmanager.cpp
 source/tml/gameaction.cpp


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000116.html">[Tw-light-svn] r170 - in trunk: . source source/ais source/melee source/other
</A></li>
	<LI>Next message: <A HREF="000118.html">[Tw-light-svn] r172 - in trunk: . source/games source/melee
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#117">[ date ]</a>
              <a href="thread.html#117">[ thread ]</a>
              <a href="subject.html#117">[ subject ]</a>
              <a href="author.html#117">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
