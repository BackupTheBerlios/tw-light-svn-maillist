From yurand at sheep.berlios.de  Sun Mar  6 16:42:44 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 6 Mar 2005 16:42:44 +0100
Subject: [Tw-light-svn] r129 - trunk/source/games
Message-ID: <200503061542.j26FgiY8007080@sheep.berlios.de>

Author: yurand
Date: 2005-03-06 16:42:43 +0100 (Sun, 06 Mar 2005)
New Revision: 129

Modified:
   trunk/source/games/gamehierarchy.cpp
   trunk/source/games/gamehierarchy.h
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
Log:
Fixed gliches bug with switchng systems in GOB

Modified: trunk/source/games/gamehierarchy.cpp
===================================================================
--- trunk/source/games/gamehierarchy.cpp	2005-02-27 15:15:31 UTC (rev 128)
+++ trunk/source/games/gamehierarchy.cpp	2005-03-06 15:42:43 UTC (rev 129)
@@ -42,6 +42,7 @@
 MainGame::MainGame()
 {
   g_maingame = this;
+  _active_subgame = "";
 }
 
 void MainGame::addsubgame(Game *asubgame, const std::string& name)
@@ -59,7 +60,7 @@
 
   asubgame->init(log, "");	// all subgames share the same log (is this ok?)
 
-  subgame.insert(asubgame);
+  _subgame[name]=asubgame;
 }
 
 
@@ -67,77 +68,50 @@
 {
   STACKTRACE;
 
-  subgame.erase(g);
+  _subgame.erase(_subgame.find(g->_name));
   g->log->deinit();	// this is empty, dunno why
-  
   game = NULL;
-
   delete g;	// this _must_ be deleted completely, otherwise the gamedata aren't removed  
 }
 
 
-int MainGame::isGameDone()
-{
-  for (std::set<Game*>::iterator i = subgame.begin();
-       i!= subgame.end(); i++)
-    {
-      if ((*i)->isGameDone() != GAME_STATE_FINISHED)
-	{
-	  return GAME_STATE_PLAYING;
-	}
-    }
-  return GAME_STATE_FINISHED;
-}
-
 int MainGame::play()
 {
   STACKTRACE;
-  
+
+  // Nothing to play
+  if(!_subgame.size())
+    return GAME_STATE_FINISHED;
+
   set_resolution(window->w, window->h);
-  
   prepare();
   if (is_paused()) unpause();
   
-  
   while(isGameDone() == GAME_STATE_PLAYING)
     {
-      //unsigned int time = get_time();
-      poll_input();
-      
-      videosystem->poll_redraw();
-      
-      for (std::set<Game*>::iterator i = subgame.begin();
-	   i!= subgame.end(); i++)
+      poll_input(); 
+      videosystem->poll_redraw();     
+      if(!switch_to(_active_subgame))
 	{
-	  if ((*i)->isGameDone() != GAME_STATE_FINISHED)
-	    {
-	      (*i)->setGameDone(GAME_STATE_PLAYING);
-	    }
-	  (*i)->play();
+	  tw_error(("Unknown sybgame: " + _active_subgame).c_str());
 	}
+      (_subgame[_active_subgame])->play();
     }
   return isGameDone();
 }
 
-
-
-struct SubGameP : public std::binary_function<Game*,std::string,bool>
+void MainGame::setActiveGame(const std::string& name)
 {
-  bool operator ()(Game* g, std::string name) const
-  {
-    if(g->_name == name)
-      return true;
-    return false;
-  }
-};
+  _active_subgame = name;
+}
 
 bool MainGame::switch_to(const std::string& name)
 {
-  std::set<Game*>::iterator i = std::find_if(subgame.begin(), subgame.end(), std::bind2nd(SubGameP(), name));
-
-  if(i!=subgame.end())
+  if(_subgame.find(name)!=_subgame.end())
     {
-      (*i)->prepare();
+      setActiveGame(name);
+      (_subgame[_active_subgame])->prepare();
+      (_subgame[_active_subgame])->setGameDone(GAME_STATE_PLAYING);
       return true;
     }
   return false;

Modified: trunk/source/games/gamehierarchy.h
===================================================================
--- trunk/source/games/gamehierarchy.h	2005-02-27 15:15:31 UTC (rev 128)
+++ trunk/source/games/gamehierarchy.h	2005-03-06 15:42:43 UTC (rev 129)
@@ -19,6 +19,8 @@
 
 #include "melee/mgame.h"
 #include <set>
+#include <map>
+#include <string>
 
 #include "util/history.h"
 
@@ -113,18 +115,20 @@
 ///  other games are also running in the background). Games and their physics are independent.
 class MainGame : public Game
 {
+ protected:
+  std::string _active_subgame;
+  std::map<std::string,Game*> _subgame;
+  
+    /// Switch to subgame by name
+  bool switch_to(const std::string& name);
  public:
+  
+  MainGame();
  
-  MainGame();
-  std::set<Game*> subgame;
-  
-
-  virtual void addsubgame(Game *asubgame,  const std::string& save);
+  virtual void setActiveGame(const std::string& name);
+  virtual void addsubgame(Game *asubgame,  const std::string& name);
   virtual void removesubgame(Game* g);
-  virtual int isGameDone();
 
-  /// Switch to subgame by name
-  bool switch_to(const std::string& name);
   virtual int play();
 };
 

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-02-27 15:15:31 UTC (rev 128)
+++ trunk/source/games/ggob.cpp	2005-03-06 15:42:43 UTC (rev 129)
@@ -98,34 +98,22 @@
   GobGameBase::prepare();
   if(maingame->gobplayer._teleport)
     {
-      maingame->gobplayer.ship = 
-	create_ship(maingame->gobplayer.ship->type->id,
-		    _player_control,
-		    0,//maingame->gobplayer.ship->pos(),
-		    maingame->gobplayer.ship->get_angle(),
-		    maingame->gobplayer.team);
-      add(maingame->gobplayer.ship);
-      AddPanel();
+      ShipType* type = maingame->gobplayer.ship->type;
+      maingame->gobplayer.ship = NULL;
+      maingame->gobplayer.new_ship(type);
       add_focus(_player_control, _player_control->channel);
       maingame->gobplayer._teleport = 0;
     }
 }
 
-int GobGame::isGameDone() 
-{
-  bool done = true;
 
-  if (maingame->gobplayer.ship != NULL)
-    done = false;
-  
-  if (done) 
+void GobGame::setGameDone(int done)
+{
+  if(done == GAME_STATE_FINISHED)
     {
-      if(_game_state != GAME_STATE_FINISHED)
-	{
-	  setGameDone(GAME_STATE_FINISHED );
-	}
+      maingame->setGameDone(done);
     }
-  return GobGameBase::isGameDone();
+    return GobGameBase::setGameDone(done);
 }
 
 void GobGame::add_gobplayer(Control *control) 
@@ -166,7 +154,11 @@
       ship->state = 1;
     }
   else 
-    ship = NULL;
+    {
+      ship = NULL;
+      game->setGameDone(GAME_STATE_FINISHED);
+      tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
+    }
   return;
 }
 
@@ -397,6 +389,14 @@
 	setGameDone(GAME_STATE_SUSPENDED);
 	maingame->gobplayer._teleport = 1;
 	maingame->gobplayer.ship->die();
+	if(_name=="Arix")
+	  {
+	    maingame->setActiveGame("Beta");
+	  }
+	else
+	  {
+	    maingame->setActiveGame("Arix");
+	  }
 	return true;
       }
       break;
@@ -1029,24 +1029,6 @@
 	return;
 }
 
-
-int MainGobGame::isGameDone()
-{
-  bool done = true;
-  if (gobplayer.ship != NULL)
-    done = false;
-
-  if (done) 
-    {
-      if(_game_state != GAME_STATE_FINISHED)
-	{
-	  setGameDone(GAME_STATE_FINISHED );
-	  tw_alert("Game Over!\n\nYour ship and its contents are lost!", "Ok");
-	}
-    }
-  return Game::isGameDone();
-}
-
 void MainGobGame::init (Log *log, const std::string& save)
 {
   MainGame::init(log,save);
@@ -1055,7 +1037,6 @@
     {
       tw_error("unable to locate start.xml");
     };  
-  //  addsubgame(new GobGame, );
 }	
 
 void MainGobGame::add_gobplayer(const std::string& system)

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-02-27 15:15:31 UTC (rev 128)
+++ trunk/source/games/ggob.h	2005-03-06 15:42:43 UTC (rev 129)
@@ -93,7 +93,6 @@
   virtual void 	init (Log *log, const std::string& save);
   void add_gobplayer(const std::string& system);
  protected:
-  virtual int isGameDone();
 };
 
 typedef SubGame<MainGobGame> GobGameBase;
@@ -114,13 +113,12 @@
   virtual void AddPanel();
 
   virtual void calculate();
-  virtual int isGameDone();
+  virtual void setGameDone(int done);
   virtual void ship_died(Ship *who, SpaceLocation *source);
   virtual void preinit();
   virtual void init (Log *log, const std::string& save);
-
   virtual void play_sound (SAMPLE *sample, SpaceLocation *source, int vol = 256, int freq = 1000);
-
+  
   virtual void add_gobplayer(Control *control);
   virtual GobPlayer *get_player(SpaceLocation *what);
   int gobenemies, max_enemies;



From yurand at sheep.berlios.de  Sun Mar  6 17:30:53 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 6 Mar 2005 17:30:53 +0100
Subject: [Tw-light-svn] r130 - in trunk: gamedata/xml/GOB source/games source/melee
Message-ID: <200503061630.j26GUrAD010416@sheep.berlios.de>

Author: yurand
Date: 2005-03-06 17:30:51 +0100 (Sun, 06 Mar 2005)
New Revision: 130

Modified:
   trunk/gamedata/xml/GOB/start.xml
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee/mview.cpp
Log:
Start position moved back to planet


Modified: trunk/gamedata/xml/GOB/start.xml
===================================================================
--- trunk/gamedata/xml/GOB/start.xml	2005-03-06 15:42:43 UTC (rev 129)
+++ trunk/gamedata/xml/GOB/start.xml	2005-03-06 16:30:51 UTC (rev 130)
@@ -105,5 +105,5 @@
 	<GobAsteroid/>
       </SpaceObjects>
   </System>
-  <Player system="Arix" x="0" y="0"/>
+  <Player system="Arix" x="12400" y="12400"/>
 </GOB>
\ No newline at end of file

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-03-06 15:42:43 UTC (rev 129)
+++ trunk/source/games/ggob.cpp	2005-03-06 16:30:51 UTC (rev 130)
@@ -98,10 +98,16 @@
   GobGameBase::prepare();
   if(maingame->gobplayer._teleport)
     {
+      message.flush();
       ShipType* type = maingame->gobplayer.ship->type;
+      double crew = maingame->gobplayer.ship->crew;
       maingame->gobplayer.ship = NULL;
       maingame->gobplayer.new_ship(type);
       add_focus(_player_control, _player_control->channel);
+
+      maingame->gobplayer.ship->crew = crew;
+      maingame->gobplayer.ship->batt = 0;
+
       maingame->gobplayer._teleport = 0;
     }
 }
@@ -384,7 +390,7 @@
   STACKTRACE;
   switch (k >> 8) 
     {
-    case KEY_F6: 
+    case KEY_J: 
       {
 	setGameDone(GAME_STATE_SUSPENDED);
 	maingame->gobplayer._teleport = 1;
@@ -462,23 +468,6 @@
   }
   Ship *ship = create_ship(channel_server, enemy_types[e], "WussieBot", 
 			   random(size), random(PI2), enemy_team);
-  /*
-  if (!strcmp(enemy_types[e], "shosc")) 
-    ((ShofixtiScout*)ship)->specialDamage /= 4;
-  if (!strcmp(enemy_types[e], "zfpst")) 
-    ((ZoqFotPikStinger*)ship)->specialDamage /= 2;
-  if (!strcmp(enemy_types[e], "syrpe")) 
-    ((SyreenPenetrator*)ship)->specialDamage /= 2;
-  if (!strcmp(enemy_types[e], "dragr")) 
-    ship->special_drain *= 2;
-  if (!strcmp(enemy_types[e], "chmav")) 
-    {
-      ((ChmmrAvatar*)ship)->weaponDamage += 1;
-      ((ChmmrAvatar*)ship)->weaponDamage /= 2;
-      ((ChmmrAvatar*)ship)->specialForce *= 2;
-      ((ChmmrAvatar*)ship)->specialRange *= 2;
-    }
-  */
 
   int sb, bz;
   sb = 1 + e / 4;
@@ -1039,14 +1028,14 @@
     };  
 }	
 
-void MainGobGame::add_gobplayer(const std::string& system)
+void MainGobGame::add_gobplayer(const std::string& system, Vector2 pos)
 {
   STACKTRACE;
    switch_to(system);
    gobplayer.init(game->new_team());
    game->add_focus(gobgame->_player_control, gobgame->_player_control->channel);
    gobplayer.new_ship(shiptype("supbl"));
-
+   gobplayer.ship->translate(pos);
 }
 
 REGISTER_GAME(MainGobGame, "GOB")

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-03-06 15:42:43 UTC (rev 129)
+++ trunk/source/games/ggob.h	2005-03-06 16:30:51 UTC (rev 130)
@@ -91,7 +91,7 @@
  public:
   GobPlayer gobplayer;
   virtual void 	init (Log *log, const std::string& save);
-  void add_gobplayer(const std::string& system);
+  void add_gobplayer(const std::string& system, Vector2 pos);
  protected:
 };
 

Modified: trunk/source/melee/mview.cpp
===================================================================
--- trunk/source/melee/mview.cpp	2005-03-06 15:42:43 UTC (rev 129)
+++ trunk/source/melee/mview.cpp	2005-03-06 16:30:51 UTC (rev 130)
@@ -1,7 +1,7 @@
 /* $Id: mview.cpp,v 1.1.1.1 2004/08/01 10:21:22 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify
@@ -40,7 +40,7 @@
 int FULL_REDRAW = 0;
 int camera_hides_cloakers = 0;
 
-                              // units
+// units
 View  *space_view;
 
 Vector2 space_view_size;   // pixels (should be an integer value)
@@ -49,22 +49,24 @@
 int    space_mip_i;    // ?
 double space_mip;      // ?
 
-Vector2 space_size;         // game-pixels
+Vector2 space_size;         ///< game-pixels
 
-Vector2 space_corner = 0;       // game-pixels : uppper left corner
-Vector2 space_center_nowrap = 0;// game-pixels : center, non-wrapped
-Vector2 space_vel = 0;          // game-pixels / millisecond : center
-Vector2 space_center = 0;       // game-pixels : center
+Vector2 space_corner = 0;       ///< game-pixels : uppper left corner
+Vector2 space_center_nowrap = 0;///< game-pixels : center, non-wrapped
+Vector2 space_vel = 0;          ///< game-pixels / millisecond : center
+Vector2 space_center = 0;       ///< game-pixels : center
 
 
+message_type message;
 
-View * ViewType::create( View * old ) {
+View * ViewType::create( View * old ) 
+{
   STACKTRACE;
-	View * r = _create();
-	r->preinit();
-	r->type = this;
-	r->init ( old );
-	return r;
+  View * r = _create();
+  r->preinit();
+  r->type = this;
+  r->init ( old );
+  return r;
 }
 
 
@@ -75,414 +77,434 @@
 ViewType *viewtypelist = NULL;
 
 
-void set_view ( View * new_default ) {STACKTRACE
-	if (!new_default) {tw_error( "new default view is NULL");}
-	if (!new_default->type) {tw_error("new default view has no type info");}
-	if (_default_view) delete _default_view;
-	_default_view = new_default;
-	return;
+void set_view ( View * new_default ) 
+{
+  STACKTRACE;
+  if (!new_default) {tw_error( "new default view is NULL");}
+  if (!new_default->type) {tw_error("new default view has no type info");}
+  if (_default_view) delete _default_view;
+  _default_view = new_default;
+  return;
 }
 
 
+View *get_view ( const char *name, View *old ) 
+{
+  STACKTRACE;
+  int i;
+  if ((name == NULL) && _default_view) 
+    {
+      name = _default_view->type->name;
+    }
+  if (!old) 
+    old = _default_view;
 
-
-View *get_view ( const char *name, View *old ) {STACKTRACE
-	int i;
-	if ((name == NULL) && _default_view) {
-		name = _default_view->type->name;
-	}
-	if (!old) old = _default_view;
-
-	i = get_view_num ( name );
-	if ( i < 0 ) return NULL;
-	View *v = viewtypelist[i].create(old);
-	return v;
+  i = get_view_num ( name );
+  if ( i < 0 ) return NULL;
+  View *v = viewtypelist[i].create(old);
+  return v;
 }
 
-int get_view_num ( const char *name ) {STACKTRACE
-	int i;
-	if (!name) return -1;
-	for (i = 0; i < num_views; i += 1) {
-		if (strncmp(viewtypelist[i].name, name, 64) == 0) {
-			return i;
-		}
-	}
-	return -1;
+int get_view_num ( const char *name ) 
+{
+  STACKTRACE;
+  int i;
+  if (!name) return -1;
+  for (i = 0; i < num_views; i += 1) {
+    if (strncmp(viewtypelist[i].name, name, 64) == 0) {
+      return i;
+    }
+  }
+  return -1;
 }
 
 
-
-void View::preinit() {
+void View::preinit() 
+{
   STACKTRACE;
-	frame = NULL;
-	window = NULL;
-	type = NULL;
+  frame = NULL;
+  window = NULL;
+  type = NULL;
 }
 
-void View::refresh () { STACKTRACE
-	if (frame) frame->full_redraw = true; 
-	return; 
+void View::refresh () 
+{ 
+  STACKTRACE;
+  if (frame) 
+    frame->full_redraw = true; 
+  return; 
 }
 
-void View::prepare ( Frame *frame, int time ) {STACKTRACE
+void View::prepare ( Frame *frame, int time ) 
+{
+  STACKTRACE;
 
-	Vector2 oc = camera.pos;
-	camera.pos += camera.vel * time;
+  Vector2 oc = camera.pos;
+  camera.pos += camera.vel * time;
+  
+  frame->prepare();
+  
+  ::space_view = this;
+  
+  view_size.x = window->w;
+  view_size.y = window->h;
+  
+  ::space_view_size = view_size;
+  double tz = magnitude(view_size) / 1.41421356237309504880168872;
+  ::space_zoom = tz / camera.z;
+  ::space_mip = -log(space_zoom) / log(2.0);
+  ::space_mip_i = iround_down(::space_mip);
+  ::space_size  = view_size * space_zoom;
+  
+  ::space_corner = normalize2(camera.pos - space_size /2, map_size);
+  ::space_center = normalize2(camera.pos, map_size);
+  ::space_vel = camera.vel;
+  ::space_center_nowrap = camera.pos;
+  
+  camera.pos = oc;
+  
+  return;
+}
 
-	frame->prepare();
 
-	::space_view = this;
-
-	view_size.x = window->w;
-	view_size.y = window->h;
-
-	::space_view_size = view_size;
-	double tz = magnitude(view_size) / 1.41421356237309504880168872;
-	::space_zoom = tz / camera.z;
-	::space_mip = -log(space_zoom) / log(2.0);
-	::space_mip_i = iround_down(::space_mip);
-	::space_size  = view_size * space_zoom;
-
-	::space_corner = normalize2(camera.pos - space_size /2, map_size);
-	::space_center = normalize2(camera.pos, map_size);
-	::space_vel = camera.vel;
-	::space_center_nowrap = camera.pos;
-	
-	camera.pos = oc;
-
-	return;
+void View::animate(Game *game) 
+{
+  STACKTRACE;
+  if (FULL_REDRAW) frame->full_redraw = true;
+  frame->erase();
+  prepare(frame, 0);
+  
+  if (frame->surface) 
+    {
+      if (frame->surface) 
+	game->animate(frame);
+      message.animate(frame);
+    }
+  
+  scare_mouse();
+  frame->draw();
+  unscare_mouse();
+  return;
 }
 
-
-void View::animate(Game *game) {
+void View::config() 
+{
   STACKTRACE;
-	if (FULL_REDRAW) frame->full_redraw = true;
-	frame->erase();
-	prepare(frame, 0);
+  return;
+}
 
-	if (frame->surface) {
-		if (frame->surface) game->animate(frame);
-		message.animate(frame);
-	}
-
-	scare_mouse();
-	frame->draw();
-	unscare_mouse();
-	return;
-	}
-
-void View::config() {
+bool View::screen2game(Vector2 *_pos) 
+{
   STACKTRACE;
-	return;
-	}
-bool View::screen2game(Vector2 *_pos) {
-  STACKTRACE;
-	Vector2 pos = *_pos;
-	Vector2 opos = pos;
+  Vector2 pos = *_pos;
+  Vector2 opos = pos;
+  
+  pos.x -= window->x;
+  pos.y -= window->y;
+  
+  pos /= space_zoom;
+  
+  pos += camera.pos - space_size / 2;
+  pos = normalize (pos, map_size);
+  *_pos = pos;
+  if ((opos.x < window->x) || 
+      (opos.x >= window->x + window->w) || 
+      (opos.y < window->y) || 
+      (opos.y >= window->y + window->h))
+    return false;
+  return true;
+}
 
-	pos.x -= window->x;
-	pos.y -= window->y;
-
-	pos /= space_zoom;
-
-	pos += camera.pos - space_size / 2;
-	pos = normalize (pos, map_size);
-	*_pos = pos;
-	if ((opos.x < window->x) || 
-		(opos.x >= window->x + window->w) || 
-		(opos.y < window->y) || 
-		(opos.y >= window->y + window->h))
-		return false;
-	return true;
-	}
-double View::in_view(Vector2 pos, Vector2 size) {
+double View::in_view(Vector2 pos, Vector2 size) 
+{
   STACKTRACE;
-	pos = corner(pos, size);
-	size = size * space_zoom;
-
-	double a = size.x, b = size.y;
-	double c;
-	c = pos.x + size.x - space_view_size.x;
-	if (c > 0) a -= c;
-	c = pos.x;
-	if (c < 0) a += c;
-	if (a < 0) return 0;
-	c = pos.y + size.y - space_view_size.y;
-	if (c > 0) b -= c;
-	c = pos.y;
-	if (c < 0) b += c;
-	if (b < 0) return 0;
-	return a * b / (size.x * size.y);
+  pos = corner(pos, size);
+  size = size * space_zoom;
+  
+  double a = size.x, b = size.y;
+  double c;
+  c = pos.x + size.x - space_view_size.x;
+  if (c > 0) a -= c;
+  c = pos.x;
+  if (c < 0) a += c;
+  if (a < 0) return 0;
+  c = pos.y + size.y - space_view_size.y;
+  if (c > 0) b -= c;
+  c = pos.y;
+  if (c < 0) b += c;
+  if (b < 0) return 0;
+  return a * b / (size.x * size.y);
 }
 int View::focus(CameraPosition *pos, SpaceLocation *la, SpaceLocation *lb) {
   STACKTRACE;
-	if (!la && !lb) return 0;
-	if (!la) la = lb;
-	if (!lb) lb = la;
-	Vector2 p, p2;
-	p = la->normal_pos();
-	p2 = lb->normal_pos();
-	double c, d;
+  if (!la && !lb) return 0;
+  if (!la) la = lb;
+  if (!lb) lb = la;
+  Vector2 p, p2;
+  p = la->normal_pos();
+  p2 = lb->normal_pos();
+  double c, d;
 
-	Vector2 a = Vector2(
-		min_delta(p.x, p2.x, map_size.x),
-		min_delta(p.y, p2.y, map_size.y)
-		);
+  Vector2 a = Vector2(
+		      min_delta(p.x, p2.x, map_size.x),
+		      min_delta(p.y, p2.y, map_size.y)
+		      );
 
-	p = normalize(p-a/2, map_size);
+  p = normalize(p-a/2, map_size);
 
-	c = fabs(a.x) + 1;
-	d = fabs(a.y) + 1;
-	//if (c < d) c = d;
-	c = sqrt(c*c + d*d);
+  c = fabs(a.x) + 1;
+  d = fabs(a.y) + 1;
+  //if (c < d) c = d;
+  c = sqrt(c*c + d*d);
 
-	pos->pos = p;
-	if (lb != la) {
-		pos->z = c;
-		return 2;
-	}
-	else return 1;
+  pos->pos = p;
+  if (lb != la) {
+    pos->z = c;
+    return 2;
+  }
+  else return 1;
 }
 
 /*void View::see_also(SpaceLocation *o) {
   STACKTRACE;
-	if (!o) return;
-	double x2, y2;
-	x2 = b->normal_x();
-	y2 = b->normal_y();
-	double a, b, c, d;
-	a = min_delta(x, x2, X_MAX);
-	b = min_delta(y, y2, Y_MAX);
-	c = view_x / (fabs(a) + 1);
-	d = view_y / (fabs(b) + 1);
-	if (c > d) c = d;
-	x = normalize(x-a/2, X_MAX);
-	y = normalize(y-b/2, Y_MAX);
-	z = c;
-	return;
-	}*/
+  if (!o) return;
+  double x2, y2;
+  x2 = b->normal_x();
+  y2 = b->normal_y();
+  double a, b, c, d;
+  a = min_delta(x, x2, X_MAX);
+  b = min_delta(y, y2, Y_MAX);
+  c = view_x / (fabs(a) + 1);
+  d = view_y / (fabs(b) + 1);
+  if (c > d) c = d;
+  x = normalize(x-a/2, X_MAX);
+  y = normalize(y-b/2, Y_MAX);
+  z = c;
+  return;
+  }*/
 //make these static...
 
 void View::track (const CameraPosition &target, CameraPosition *origin) {
-	STACKTRACE
-	if (!origin) origin = &this->camera;
-	Vector2 d;
-	d = target.pos - origin->pos;
+  STACKTRACE
+    if (!origin) origin = &this->camera;
+  Vector2 d;
+  d = target.pos - origin->pos;
 
-	d = normalize2(d + map_size/2, map_size) - map_size/2;
+  d = normalize2(d + map_size/2, map_size) - map_size/2;
 
-	origin->pos += d;
-	// debug GEO.
-	// origin isn't normalized, this can grow very big. When a normalization
-	// is used, this normalization must then handle a very large value; it
-	// then encounters the limit 999. So, add a normalization ?
-	normalize(origin->pos, map_size);
+  origin->pos += d;
+  // debug GEO.
+  // origin isn't normalized, this can grow very big. When a normalization
+  // is used, this normalization must then handle a very large value; it
+  // then encounters the limit 999. So, add a normalization ?
+  normalize(origin->pos, map_size);
 
-	origin->vel = d / frame_time;
-	origin->z = target.z;
+  origin->vel = d / frame_time;
+  origin->z = target.z;
 }
 void View::track (const CameraPosition &target, double smooth_time, CameraPosition *origin) {
-	STACKTRACE
-	if (!origin) origin = &this->camera;
-	Vector2 d;
-	d.x = -min_delta( origin->pos.x, target.pos.x, map_size.x);
-	d.y = -min_delta( origin->pos.y, target.pos.y, map_size.y);
-	Vector2 dd;
-	dd = d - origin->vel * frame_time;
+  STACKTRACE
+    if (!origin) origin = &this->camera;
+  Vector2 d;
+  d.x = -min_delta( origin->pos.x, target.pos.x, map_size.x);
+  d.y = -min_delta( origin->pos.y, target.pos.y, map_size.y);
+  Vector2 dd;
+  dd = d - origin->vel * frame_time;
 
-	origin->z = target.z;
-	//if (origin->z < 100) origin->z = 100;
-	//if (origin->z > 10000) origin->z = 10000;
+  origin->z = target.z;
+  //if (origin->z < 100) origin->z = 100;
+  //if (origin->z > 10000) origin->z = 10000;
 
-/*	double r1 = (dx * dx + dy * dy) / (frame_time * frame_time);
+  /*	double r1 = (dx * dx + dy * dy) / (frame_time * frame_time);
 	double r2 = (ddx * ddx + ddy * ddy) / (frame_time * frame_time);
 
 	if ( 1 ) {
-		double d = (log(origin->z) / log(10) -2) /2;
-		d = 0.5 - 0.4 * d;
-		d = 0.5;
-		dx = origin->vx * d + dx * (1.0 - d);
-		dy = origin->vy * d + dy * (1.0 - d);
-		dx = ddx * (1.0 - d);
-		dx += origin->vx * (1.0 - d);
-		dy -= ddy * (1.0 - d);
-		dy += origin->vy * d;*/
-/*	}*/
+	double d = (log(origin->z) / log(10) -2) /2;
+	d = 0.5 - 0.4 * d;
+	d = 0.5;
+	dx = origin->vx * d + dx * (1.0 - d);
+	dy = origin->vy * d + dy * (1.0 - d);
+	dx = ddx * (1.0 - d);
+	dx += origin->vx * (1.0 - d);
+	dy -= ddy * (1.0 - d);
+	dy += origin->vy * d;*/
+  /*	}*/
 
-	origin->vel = d / frame_time;
-	origin->pos += d;
+  origin->vel = d / frame_time;
+  origin->pos += d;
 
-	// debug GEO.
-	// origin isn't normalized, this can grow very big. When a normalization
-	// is used, this normalization must then handle a very large value; it
-	// then encounters the limit 999. So, add a normalization ?
-	normalize(origin->pos, map_size);
+  // debug GEO.
+  // origin isn't normalized, this can grow very big. When a normalization
+  // is used, this normalization must then handle a very large value; it
+  // then encounters the limit 999. So, add a normalization ?
+  normalize(origin->pos, map_size);
 
-	return;
+  return;
 }
 
 void View::init(View *old) {
   STACKTRACE;
-	if (window || frame) {
-		tw_error("View::init - hmm...");
-	}
-	if (old) {
-		camera = old->camera;
-		key_zoom_in = old->key_zoom_in;
-		key_zoom_out = old->key_zoom_out;
-		key_alter1 = old->key_alter1;
-		key_alter2 = old->key_alter2;
-		frame = new Frame(1024);
-		window = frame->window;
-	}
-	else {
-		frame = new Frame(1024);
-		window = frame->window;
-		camera.pos = Vector2(0,0);
-		camera.z = 960;
-		camera.vel = Vector2(0,0);
+  if (window || frame) {
+    tw_error("View::init - hmm...");
+  }
+  if (old) {
+    camera = old->camera;
+    key_zoom_in = old->key_zoom_in;
+    key_zoom_out = old->key_zoom_out;
+    key_alter1 = old->key_alter1;
+    key_alter2 = old->key_alter2;
+    frame = new Frame(1024);
+    window = frame->window;
+  }
+  else {
+    frame = new Frame(1024);
+    window = frame->window;
+    camera.pos = Vector2(0,0);
+    camera.z = 960;
+    camera.vel = Vector2(0,0);
 
-		tw_set_config_file ( "client.ini" );
-		key_zoom_in  = name_to_key(get_config_string("View", "Key_zoomin",  "EQUALS"));
-		key_zoom_out = name_to_key(get_config_string("View", "Key_zoomout", "MINUS"));
-		key_alter1   = name_to_key(get_config_string("View", "Key_alter1",  "0"));
-		key_alter2   = name_to_key(get_config_string("View", "Key_alter2",  "BACKSLASH"));
-	}
-	window->add_callback(this);
-	//if (window->surface) ;
-	return;
+    tw_set_config_file ( "client.ini" );
+    key_zoom_in  = name_to_key(get_config_string("View", "Key_zoomin",  "EQUALS"));
+    key_zoom_out = name_to_key(get_config_string("View", "Key_zoomout", "MINUS"));
+    key_alter1   = name_to_key(get_config_string("View", "Key_alter1",  "0"));
+    key_alter2   = name_to_key(get_config_string("View", "Key_alter2",  "BACKSLASH"));
+  }
+  window->add_callback(this);
+  //if (window->surface) ;
+  return;
 }
 void View::replace ( View * v ) {STACKTRACE
-	if (frame) {
-		window->remove_callback(this);
-		delete frame;
-		frame = NULL;
-		window = NULL;
-	}
-	frame = v->frame;
-	window = frame->window;
-	view_size = v->view_size;
+				   if (frame) {
+				     window->remove_callback(this);
+				     delete frame;
+				     frame = NULL;
+				     window = NULL;
+				   }
+ frame = v->frame;
+ window = frame->window;
+ view_size = v->view_size;
 
-	window->remove_callback(v);
-	window->add_callback(this);
+ window->remove_callback(v);
+ window->add_callback(this);
 	
-	v->frame = NULL;
-	v->window = NULL;
-	delete v;
+ v->frame = NULL;
+ v->window = NULL;
+ delete v;
 
-	return;
+ return;
 }
 View::~View() {STACKTRACE
-	if (frame) {
-		window->remove_callback(this);
-		delete frame;
-	}
+		 if (frame) {
+		   window->remove_callback(this);
+		   delete frame;
+		 }
 }
 void View::calculate(Game *game) {
   STACKTRACE;}
 
 void message_type::out(char *string, int dur, int c) {
   STACKTRACE;
-	ASSERT (c < 256);
-	if (num_messages == max_messages - 1) {
-		messages[0].end_time = -1;
-		clean();
-		}
-	if (num_messages >= max_messages - 1) throw "bad dog!";
-	messages[num_messages].string = strdup(string);
-	if (game) messages[num_messages].end_time = game->game_time + dur;
-	else messages[num_messages].end_time = 0 + dur;
-	messages[num_messages].color = palette_color[c];
-	num_messages += 1;
+  ASSERT (c < 256);
+  if (num_messages == max_messages - 1) {
+    messages[0].end_time = -1;
+    clean();
+  }
+  if (num_messages >= max_messages - 1) throw "bad dog!";
+  messages[num_messages].string = strdup(string);
+  if (game) messages[num_messages].end_time = game->game_time + dur;
+  else messages[num_messages].end_time = 0 + dur;
+  messages[num_messages].color = palette_color[c];
+  num_messages += 1;
 
-	clean();
-	return;
-	}
+  clean();
+  return;
+}
 void message_type::print(int dur, int c, const char *format, ...) {
   STACKTRACE;
-	char buf[1024];
-	va_list those_dots;
-	va_start (those_dots, format);
+  char buf[1024];
+  va_list those_dots;
+  va_start (those_dots, format);
 #ifdef ALLEGRO_MSVC
-	_vsnprintf(buf, 1000, format, those_dots);
-//#elif NO_VSNPRINTF
+  _vsnprintf(buf, 1000, format, those_dots);
+  //#elif NO_VSNPRINTF
 #elif defined VSNPRINTF 
-	vsnprintf(buf, 1000, format, those_dots);
+  vsnprintf(buf, 1000, format, those_dots);
 #else 
-	vsprintf(buf, format, those_dots);
-	//vsnprintf(buf, 1000, format, those_dots); //it would be nice to use this line...
+  vsprintf(buf, format, those_dots);
+  //vsnprintf(buf, 1000, format, those_dots); //it would be nice to use this line...
 #endif
-	va_end (those_dots);
-	out(buf, dur, c);
-	return;
-	}
+  va_end (those_dots);
+  out(buf, dur, c);
+  return;
+}
 void message_type::clean() {
   STACKTRACE;
-	int kill_time;
-	if (game) kill_time = game->game_time;
-	else kill_time = 0;
-	for (int i = 0; i < num_messages; i += 1) {
-		if (messages[i].end_time <= kill_time) {
-			free (messages[i].string);
-			num_messages -= 1;
-			memmove (&messages[i], &messages[i+1], (num_messages - i) * sizeof(entry_type));
-			i -= 1;
-			}
-		}
-	return;
-	}
+  int kill_time;
+  if (game) kill_time = game->game_time;
+  else kill_time = 0;
+  for (int i = 0; i < num_messages; i += 1) {
+    if (messages[i].end_time <= kill_time) {
+      free (messages[i].string);
+      num_messages -= 1;
+      memmove (&messages[i], &messages[i+1], (num_messages - i) * sizeof(entry_type));
+      i -= 1;
+    }
+  }
+  return;
+}
 void message_type::flush() {
   STACKTRACE;
-	for (int i = 0; i < num_messages; i += 1) {
-		if (messages[i].string)
-			free (messages[i].string);
-		}
-	num_messages = ox = oy = 0;
-	return;
-	}
+  for (int i = 0; i < num_messages; i += 1) {
+    if (messages[i].string)
+      free (messages[i].string);
+  }
+  num_messages = ox = oy = 0;
+  return;
+}
 
-void message_type::animate(Frame *frame) {
+void message_type::animate(Frame *frame) 
+{
   STACKTRACE;
 
-	if (num_messages <= 0)
-		return;
+  if (num_messages <= 0)
+    return;
 
-	int i, x = 0, y = 0, tmp;
-	BITMAP *bmp;
-	if (frame) {
-		text_mode(-1);
-		bmp = frame->surface;
-		}
-	else {
-		text_mode(0);
-		videosystem->window.lock();
-		bmp = videosystem->window.surface;
-		}
-	clean();
-	if (!frame) rectfill(bmp, 0, 0, ox, oy, 0);
-	for (i = 0; i < num_messages; i += 1) {
-		textprintf(bmp, font, 0, y, messages[i].color, "%s", messages[i].string);
-		tmp = text_length(font, messages[i].string);
-		if (x < tmp) x = tmp;
-		y += text_height(font);
-		}
-	if (frame && !frame->full_redraw) frame->add_box(0, 0, x, y);	
-	if (!frame) 
-	  videosystem->window.unlock();
-	ox = x;
-	oy = y;
-	return;
-	}
-message_type message;
+  int i, x = 0, y = 0, tmp;
+  BITMAP *bmp;
+  if (frame) {
+    text_mode(-1);
+    bmp = frame->surface;
+  }
+  else {
+    text_mode(0);
+    videosystem->window.lock();
+    bmp = videosystem->window.surface;
+  }
+  clean();
+  if (!frame) rectfill(bmp, 0, 0, ox, oy, 0);
+  for (i = 0; i < num_messages; i += 1) {
+    textprintf(bmp, font, 0, y, messages[i].color, "%s", messages[i].string);
+    tmp = text_length(font, messages[i].string);
+    if (x < tmp) x = tmp;
+    y += text_height(font);
+  }
+  if (frame && !frame->full_redraw) frame->add_box(0, 0, x, y);	
+  if (!frame) 
+    videosystem->window.unlock();
+  ox = x;
+  oy = y;
+  return;
+}
 
-void View::_event( Event *e ) {
+void View::_event( Event *e ) 
+{
   STACKTRACE;
-	if ( e->type == Event::VIDEO ) {
-		const VideoEvent *ve = (const VideoEvent*) e;
-		const VideoWindow *w = ve->window;
-		if (w != window) return;
-		//if (w->surface) set_window(w->surface, w->x, w->y, w->w, w->h);
-	}
+  if ( e->type == Event::VIDEO ) {
+    const VideoEvent *ve = (const VideoEvent*) e;
+    const VideoWindow *w = ve->window;
+    if (w != window) return;
+    //if (w->surface) set_window(w->surface, w->x, w->y, w->w, w->h);
+  }
 }
 
 
@@ -491,116 +513,116 @@
 
 
 class View_Everything : public View {
-	public:
-	virtual void calculate(Game *game);
-	};
+public:
+  virtual void calculate(Game *game);
+};
 void View_Everything::calculate (Game *game) {STACKTRACE
-	double a, b, c;
-	//sqrt(view_w * view_w + view_h * view_h) / 1.41421356237309504880168872
-	c = 1.414 / magnitude(view_size);
-	a = map_size.x * view_size.x * c;
-	b = map_size.y * view_size.y * c;
-	if (b > a) a = b;
-	camera.z = a;
-	return;
-	}
+						double a, b, c;
+//sqrt(view_w * view_w + view_h * view_h) / 1.41421356237309504880168872
+ c = 1.414 / magnitude(view_size);
+ a = map_size.x * view_size.x * c;
+ b = map_size.y * view_size.y * c;
+ if (b > a) a = b;
+ camera.z = a;
+ return;
+}
 
 
 
 
 class View_Hero : public View {
-	double f;
-	double max, min;
-	public:
-	virtual void calculate(Game *game);
-	virtual void init(View *old);
-	//virtual void set_window (BITMAP *dest, int x, int y, int w, int h);
-	};
+  double f;
+  double max, min;
+public:
+  virtual void calculate(Game *game);
+  virtual void init(View *old);
+  //virtual void set_window (BITMAP *dest, int x, int y, int w, int h);
+};
 void View_Hero::init(View *old) {
   STACKTRACE;
-	View::init(old);
-	f = 0;
-	min = 30;//480;
-	max = 480000;
-	return;
-	}
+  View::init(old);
+  f = 0;
+  min = 30;//480;
+  max = 480000;
+  return;
+}
 
 void View_Hero::calculate (Game *game) {STACKTRACE
-	CameraPosition n = camera;
-	if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
-	if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
-	if (n.z < min) n.z = min;
-	if (n.z > max) n.z = max;
-	if (key_pressed(key_alter1)) f += 0.006 * frame_time;
-	else f -= 0.006 * frame_time;
-	if (f < 0) f = 0;
-	if (f > 1.2) f = 1.2;
-	SpaceLocation *c = NULL;
-	if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
-	focus ( &n, c );
-	if (c) {
-		n.pos += (f) * n.z / 4 * unit_vector(c->get_angle_ex());
-	}
-	track ( n, frame_time );
-	return;
+					  CameraPosition n = camera;
+ if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
+ if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
+ if (n.z < min) n.z = min;
+ if (n.z > max) n.z = max;
+ if (key_pressed(key_alter1)) f += 0.006 * frame_time;
+ else f -= 0.006 * frame_time;
+ if (f < 0) f = 0;
+ if (f > 1.2) f = 1.2;
+ SpaceLocation *c = NULL;
+ if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
+ focus ( &n, c );
+ if (c) {
+   n.pos += (f) * n.z / 4 * unit_vector(c->get_angle_ex());
+ }
+ track ( n, frame_time );
+ return;
 }
 
 
 
 
 class View_Enemy : public View {
-	public:
-	virtual void calculate(Game *game);
-	};
+public:
+  virtual void calculate(Game *game);
+};
 void View_Enemy::calculate (Game *game) {STACKTRACE
-	SpaceLocation *c = NULL;
-	if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
-	if (!c) return;
-	CameraPosition n = camera;
-	if (c->get_target() && !(camera_hides_cloakers && c->get_target()->isInvisible())) {
-		if (c->distance(c->get_target()) < 3000) {
-			focus(&n, c, c->get_target());
-			n.z *= 1.4;
-		}
-		else focus(&n, c);
-	}
-	else focus(&n, c);
-	if (n.z < 480) n.z = 480;
-	track(n);
-	return;
+					   SpaceLocation *c = NULL;
+ if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
+ if (!c) return;
+ CameraPosition n = camera;
+ if (c->get_target() && !(camera_hides_cloakers && c->get_target()->isInvisible())) {
+   if (c->distance(c->get_target()) < 3000) {
+     focus(&n, c, c->get_target());
+     n.z *= 1.4;
+   }
+   else focus(&n, c);
+ }
+ else focus(&n, c);
+ if (n.z < 480) n.z = 480;
+ track(n);
+ return;
 }
 
 
 
 
 class View_Enemy_Discrete : public View {
-	public:
-	virtual void calculate(Game *game);
-	};
+public:
+  virtual void calculate(Game *game);
+};
 void View_Enemy_Discrete::calculate (Game *game) {STACKTRACE
-	SpaceLocation *c = NULL;
-	if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
-	if (!c) return;
-	CameraPosition n = camera;
-	if (c->get_target() && !(camera_hides_cloakers && c->get_target()->isInvisible())) {
-		focus(&n, c, c->get_target());
-		n.z *= 1.4;
-		}
-	else
-	{
-		focus(&n, c);
-		// but, if the target is invisible, you usually want more zoom to plan where to go, right...
-		n.z = 900;
-	}
+						    SpaceLocation *c = NULL;
+ if (game->num_focuses) c = game->focus[game->focus_index]->get_focus();
+ if (!c) return;
+ CameraPosition n = camera;
+ if (c->get_target() && !(camera_hides_cloakers && c->get_target()->isInvisible())) {
+   focus(&n, c, c->get_target());
+   n.z *= 1.4;
+ }
+ else
+   {
+     focus(&n, c);
+     // but, if the target is invisible, you usually want more zoom to plan where to go, right...
+     n.z = 900;
+   }
 
-	if (n.z < 480) n.z = 480;
+ if (n.z < 480) n.z = 480;
 
 
-	double ref_size = 480;
-	n.z = ref_size * pow( 2, iround( ceil(log(n.z/ref_size) / log(2.0))) );
-	track(n);
-	return;
-	}
+ double ref_size = 480;
+ n.z = ref_size * pow( 2, iround( ceil(log(n.z/ref_size) / log(2.0))) );
+ track(n);
+ return;
+}
 
 
 
@@ -614,36 +636,36 @@
 
 
 class View_Split2a : public View {
-	double max, min;
-	enum {num_windows = 2};
-	CameraPosition cam[num_windows];
-	Frame *frames[num_windows];
-	public:
-	virtual void calculate(Game *game);
-	virtual void init(View *old);
-	virtual void animate(Game *game);
-	virtual ~View_Split2a();
-	};
+  double max, min;
+  enum {num_windows = 2};
+  CameraPosition cam[num_windows];
+  Frame *frames[num_windows];
+public:
+  virtual void calculate(Game *game);
+  virtual void init(View *old);
+  virtual void animate(Game *game);
+  virtual ~View_Split2a();
+};
 void View_Split2a::init(View *old) {
   STACKTRACE;
-	View::init(old);
+  View::init(old);
 
-	min = 480;
-	max = 4800;
+  min = 480;
+  max = 4800;
 
-	int i;
-	for (i = 0; i < num_windows; i += 1) cam[i] = camera;
-	for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
-	frames[0]->window->locate(0,0.0, 0,0, 0,0.5, 0, 1);
-	frames[1]->window->locate(0,0.5, 0,0, 0,0.5, 0, 1);
-	return;
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) cam[i] = camera;
+  for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
+  frames[0]->window->locate(0,0.0, 0,0, 0,0.5, 0, 1);
+  frames[1]->window->locate(0,0.5, 0,0, 0,0.5, 0, 1);
+  return;
+}
 View_Split2a::~View_Split2a()
 {
-	int i;
-	for (i = 0; i < num_windows; i += 1) {
-		delete frames[i];
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) {
+    delete frames[i];
+  }
 }
 void View_Split2a::animate(Game *game) 
 {
@@ -679,70 +701,70 @@
 }
 
 void View_Split2a::calculate (Game *game) {STACKTRACE
-	CameraPosition n;
-	SpaceLocation *c;
-	int i;
+					     CameraPosition n;
+ SpaceLocation *c;
+ int i;
 
-	for (i = 0; i < num_windows; i += 1) {
-		n = cam[i];
-		switch (i) {
-		case 0:
-			if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
-			if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
-			break;
-		case 1:
-			if (key_pressed(key_alter1)) n.z *= 1 + 0.002 * frame_time;
-			if (key_pressed(key_alter2)) n.z /= 1 + 0.002 * frame_time;
-			break;
-		default:
-			break;
-		}
-		if (n.z < min) n.z = min;
-		if (n.z > max) n.z = max;
-		c = NULL;
-		if (game->num_focuses > i) c = game->focus[(game->focus_index + i) % game->num_focuses]->get_focus();
-		focus ( &n, c );
-		track ( n, frame_time, &cam[i] );
-	}
+ for (i = 0; i < num_windows; i += 1) {
+   n = cam[i];
+   switch (i) {
+   case 0:
+     if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
+     if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
+     break;
+   case 1:
+     if (key_pressed(key_alter1)) n.z *= 1 + 0.002 * frame_time;
+     if (key_pressed(key_alter2)) n.z /= 1 + 0.002 * frame_time;
+     break;
+   default:
+     break;
+   }
+   if (n.z < min) n.z = min;
+   if (n.z > max) n.z = max;
+   c = NULL;
+   if (game->num_focuses > i) c = game->focus[(game->focus_index + i) % game->num_focuses]->get_focus();
+   focus ( &n, c );
+   track ( n, frame_time, &cam[i] );
+ }
 
-	camera = cam[0];
-	return;
-	}
+ camera = cam[0];
+ return;
+}
 
 
 
 
 class View_Split2b : public View {
-	double max, min;
-	enum {num_windows = 2};
-	CameraPosition cam[num_windows];
-	Frame *frames[num_windows];
-	public:
-	virtual void calculate(Game *game);
-	virtual void init(View *old);
-	virtual void animate(Game *game);
-	virtual ~View_Split2b();
-	};
+  double max, min;
+  enum {num_windows = 2};
+  CameraPosition cam[num_windows];
+  Frame *frames[num_windows];
+public:
+  virtual void calculate(Game *game);
+  virtual void init(View *old);
+  virtual void animate(Game *game);
+  virtual ~View_Split2b();
+};
 void View_Split2b::init(View *old) {
   STACKTRACE;
-	View::init(old);
+  View::init(old);
 
-	min = 480;
-	max = 4800;
+  min = 480;
+  max = 4800;
 
-	int i;
-	for (i = 0; i < num_windows; i += 1) cam[i] = camera;
-	for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
-	frames[0]->window->locate(0,0, 0,0.0, 0,1, 0, .5);
-	frames[1]->window->locate(0,0, 0,0.5, 0,1, 0, .5);
-	return;
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) cam[i] = camera;
+  for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
+  frames[0]->window->locate(0,0, 0,0.0, 0,1, 0, .5);
+  frames[1]->window->locate(0,0, 0,0.5, 0,1, 0, .5);
+  return;
+}
 View_Split2b::~View_Split2b()
 {
-	int i;
-	for (i = 0; i < num_windows; i += 1) {
-		delete frames[i];
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) {
+    delete frames[i];
+  }
 }
 void View_Split2b::animate(Game *game) 
 {
@@ -814,100 +836,100 @@
 
 
 class View_Split3 : public View {
-	double max, min;
-	enum {num_windows = 3};
-	CameraPosition cam[num_windows];
-	Frame *frames[num_windows];
-	public:
-	virtual void calculate(Game *game);
-	virtual void init(View *old);
-	virtual void animate(Game *game);
-	virtual ~View_Split3();
-	};
+  double max, min;
+  enum {num_windows = 3};
+  CameraPosition cam[num_windows];
+  Frame *frames[num_windows];
+public:
+  virtual void calculate(Game *game);
+  virtual void init(View *old);
+  virtual void animate(Game *game);
+  virtual ~View_Split3();
+};
 void View_Split3::init(View *old) {
   STACKTRACE;
-	View::init(old);
+  View::init(old);
 
-	min = 480;
-	max = 4800;
+  min = 480;
+  max = 4800;
 
-	int i;
-	for (i = 0; i < num_windows; i += 1) cam[i] = camera;
-	for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
-	frames[0]->window->locate(0,0.0/3, 0,0, 0,1/3.0, 0,1);
-	frames[1]->window->locate(0,1.0/3, 0,0, 0,1/3.0, 0,1);
-	frames[2]->window->locate(0,2.0/3, 0,0, 0,1/3.0, 0,1);
-	return;
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) cam[i] = camera;
+  for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
+  frames[0]->window->locate(0,0.0/3, 0,0, 0,1/3.0, 0,1);
+  frames[1]->window->locate(0,1.0/3, 0,0, 0,1/3.0, 0,1);
+  frames[2]->window->locate(0,2.0/3, 0,0, 0,1/3.0, 0,1);
+  return;
+}
 View_Split3::~View_Split3()
 {
-	int i;
-	for (i = 0; i < num_windows; i += 1) {
-		delete frames[i];
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) {
+    delete frames[i];
+  }
 }
 void View_Split3::animate(Game *game) {
   STACKTRACE;
-	VideoWindow *tmpw;
-	Frame *tmpf;
-	CameraPosition tmpc;
-	int i;
+  VideoWindow *tmpw;
+  Frame *tmpf;
+  CameraPosition tmpc;
+  int i;
 
-	tmpw = window;
-	tmpf = frame;
-	tmpc = camera;
-	for (i = 0; i < num_windows; i += 1) {
-		frames[i]->window->init(window);
-	}
+  tmpw = window;
+  tmpf = frame;
+  tmpc = camera;
+  for (i = 0; i < num_windows; i += 1) {
+    frames[i]->window->init(window);
+  }
 
-	for (i = 0; i < num_windows; i += 1) {
-		window = frames[i]->window;
-		frame = frames[i];
-		camera = cam[i];
-		View::animate(game);
-	}
+  for (i = 0; i < num_windows; i += 1) {
+    window = frames[i]->window;
+    frame = frames[i];
+    camera = cam[i];
+    View::animate(game);
+  }
 
-	for (i = 0; i < num_windows; i += 1) {
-		frames[i]->window->init(NULL);
-	}
+  for (i = 0; i < num_windows; i += 1) {
+    frames[i]->window->init(NULL);
+  }
 
-	frame = tmpf;
-	window = tmpw;
-	camera = tmpc;
-	view_size.x = window->w;
-	view_size.y = window->w;
+  frame = tmpf;
+  window = tmpw;
+  camera = tmpc;
+  view_size.x = window->w;
+  view_size.y = window->w;
 }
 
 void View_Split3::calculate (Game *game) {STACKTRACE
-	CameraPosition n;
-	SpaceLocation *c;
-	int i;
+					    CameraPosition n;
+ SpaceLocation *c;
+ int i;
 
-	for (i = 0; i < num_windows; i += 1) {
-		n = cam[i];
-		switch (i) {
-		case 0:
-			if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
-			if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
-			break;
-		case 1:
-			if (key_pressed(key_alter1)) n.z *= 1 + 0.002 * frame_time;
-			if (key_pressed(key_alter2)) n.z /= 1 + 0.002 * frame_time;
-			break;
-		default:
-			break;
-		}
-		if (n.z < min) n.z = min;
-		if (n.z > max) n.z = max;
-		c = NULL;
-		if (game->num_focuses > i) c = game->focus[(game->focus_index + i) % game->num_focuses]->get_focus();
-		focus ( &n, c );
-		track ( n, frame_time, &cam[i] );
-	}
+ for (i = 0; i < num_windows; i += 1) {
+   n = cam[i];
+   switch (i) {
+   case 0:
+     if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
+     if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
+     break;
+   case 1:
+     if (key_pressed(key_alter1)) n.z *= 1 + 0.002 * frame_time;
+     if (key_pressed(key_alter2)) n.z /= 1 + 0.002 * frame_time;
+     break;
+   default:
+     break;
+   }
+   if (n.z < min) n.z = min;
+   if (n.z > max) n.z = max;
+   c = NULL;
+   if (game->num_focuses > i) c = game->focus[(game->focus_index + i) % game->num_focuses]->get_focus();
+   focus ( &n, c );
+   track ( n, frame_time, &cam[i] );
+ }
 
-	camera = cam[0];
-	return;
-	}
+ camera = cam[0];
+ return;
+}
 
 
 
@@ -915,110 +937,110 @@
 
 
 class View_Split4 : public View {
-	double max, min;
-	enum {num_windows = 4};
-	CameraPosition cam[num_windows];
-	Frame *frames[num_windows];
-	public:
-	virtual void calculate(Game *game);
-	virtual void init(View *old);
-	virtual void animate(Game *game);
-	virtual ~View_Split4();
-	};
+  double max, min;
+  enum {num_windows = 4};
+  CameraPosition cam[num_windows];
+  Frame *frames[num_windows];
+public:
+  virtual void calculate(Game *game);
+  virtual void init(View *old);
+  virtual void animate(Game *game);
+  virtual ~View_Split4();
+};
 void View_Split4::init(View *old) {
   STACKTRACE;
-	View::init(old);
+  View::init(old);
 
-	min = 480;
-	max = 4800;
+  min = 480;
+  max = 4800;
 
-	int i;
-	for (i = 0; i < num_windows; i += 1) cam[i] = camera;
-	for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
-	frames[0]->window->locate(0,0.0/2, 0,0.0/2, 0,0.5, 0,0.5);
-	frames[1]->window->locate(0,1.0/2, 0,0.0/2, 0,0.5, 0,0.5);
-	frames[2]->window->locate(0,0.0/2, 0,1.0/2, 0,0.5, 0,0.5);
-	frames[3]->window->locate(0,1.0/2, 0,1.0/2, 0,0.5, 0,0.5);
-	return;
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) cam[i] = camera;
+  for (i = 0; i < num_windows; i += 1) frames[i] = new Frame(1024);
+  frames[0]->window->locate(0,0.0/2, 0,0.0/2, 0,0.5, 0,0.5);
+  frames[1]->window->locate(0,1.0/2, 0,0.0/2, 0,0.5, 0,0.5);
+  frames[2]->window->locate(0,0.0/2, 0,1.0/2, 0,0.5, 0,0.5);
+  frames[3]->window->locate(0,1.0/2, 0,1.0/2, 0,0.5, 0,0.5);
+  return;
+}
 View_Split4::~View_Split4()
 {
-	int i;
-	for (i = 0; i < num_windows; i += 1) {
-		delete frames[i];
-	}
+  int i;
+  for (i = 0; i < num_windows; i += 1) {
+    delete frames[i];
+  }
 }
 void View_Split4::animate(Game *game) {
   STACKTRACE;
-	VideoWindow *tmpw;
-	Frame *tmpf;
-	CameraPosition tmpc;
-	int i;
+  VideoWindow *tmpw;
+  Frame *tmpf;
+  CameraPosition tmpc;
+  int i;
 
-	tmpw = window;
-	tmpf = frame;
-	tmpc = camera;
-	for (i = 0; i < num_windows; i += 1) {
-		frames[i]->window->init(window);
-	}
+  tmpw = window;
+  tmpf = frame;
+  tmpc = camera;
+  for (i = 0; i < num_windows; i += 1) {
+    frames[i]->window->init(window);
+  }
 
-	for (i = 0; i < num_windows; i += 1) {
-		window = frames[i]->window;
-		frame = frames[i];
-		camera = cam[i];
-		View::animate(game);
-	}
+  for (i = 0; i < num_windows; i += 1) {
+    window = frames[i]->window;
+    frame = frames[i];
+    camera = cam[i];
+    View::animate(game);
+  }
 
-	for (i = 0; i < num_windows; i += 1) {
-		frames[i]->window->init(NULL);
-	}
+  for (i = 0; i < num_windows; i += 1) {
+    frames[i]->window->init(NULL);
+  }
 
-	frame = tmpf;
-	window = tmpw;
-	camera = tmpc;
-	view_size.x = window->w;
-	view_size.y = window->w;
+  frame = tmpf;
+  window = tmpw;
+  camera = tmpc;
+  view_size.x = window->w;
+  view_size.y = window->w;
 }
 
 void View_Split4::calculate (Game *game) {STACKTRACE
-	CameraPosition n;
-	SpaceLocation *c;
-	int i;
+					    CameraPosition n;
+ SpaceLocation *c;
+ int i;
 
-	for (i = 0; i < num_windows; i += 1) {
-		n = cam[i];
-		switch (i) {
-		case 0:
-			if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
-			if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
-			break;
-		case 1:
-			if (key_pressed(key_alter1)) n.z *= 1 + 0.002 * frame_time;
-			if (key_pressed(key_alter2)) n.z /= 1 + 0.002 * frame_time;
-			break;
-		default:
-			break;
-		}
-		if (n.z < min) n.z = min;
-		if (n.z > max) n.z = max;
-		c = NULL;
-		if (game->num_focuses > i) c = game->focus[(game->focus_index + i) % game->num_focuses]->get_focus();
-		focus ( &n, c );
-		track ( n, frame_time, &cam[i] );
-	}
+ for (i = 0; i < num_windows; i += 1) {
+   n = cam[i];
+   switch (i) {
+   case 0:
+     if (key_pressed(key_zoom_in))  n.z /= 1 + 0.002 * frame_time;
+     if (key_pressed(key_zoom_out)) n.z *= 1 + 0.002 * frame_time;
+     break;
+   case 1:
+     if (key_pressed(key_alter1)) n.z *= 1 + 0.002 * frame_time;
+     if (key_pressed(key_alter2)) n.z /= 1 + 0.002 * frame_time;
+     break;
+   default:
+     break;
+   }
+   if (n.z < min) n.z = min;
+   if (n.z > max) n.z = max;
+   c = NULL;
+   if (game->num_focuses > i) c = game->focus[(game->focus_index + i) % game->num_focuses]->get_focus();
+   focus ( &n, c );
+   track ( n, frame_time, &cam[i] );
+ }
 
-	camera = cam[0];
-	return;
-	}
+ camera = cam[0];
+ return;
+}
 
 
 
-REGISTER_VIEW ( View_Hero, "Hero" )
-REGISTER_VIEW ( View_Enemy, "Enemy" )
-REGISTER_VIEW ( View_Enemy_Discrete, "Enemy_Discrete" )
-REGISTER_VIEW ( View_Split2a, "Split_2_Horizontal" )
-REGISTER_VIEW ( View_Split2b, "Split_2_Vertical" )
-REGISTER_VIEW ( View_Split3, "Split_3_Horizontal" )
-REGISTER_VIEW ( View_Split4, "Split_4_Quad" )
-REGISTER_VIEW ( View_Everything, "Everything" )
+REGISTER_VIEW ( View_Hero, "Hero" );
+REGISTER_VIEW ( View_Enemy, "Enemy" );
+REGISTER_VIEW ( View_Enemy_Discrete, "Enemy_Discrete" );
+REGISTER_VIEW ( View_Split2a, "Split_2_Horizontal" );
+REGISTER_VIEW ( View_Split2b, "Split_2_Vertical" );
+REGISTER_VIEW ( View_Split3, "Split_3_Horizontal" );
+REGISTER_VIEW ( View_Split4, "Split_4_Quad" );
+REGISTER_VIEW ( View_Everything, "Everything" );
 



From yurand at sheep.berlios.de  Sun Mar  6 17:46:01 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 6 Mar 2005 17:46:01 +0100
Subject: [Tw-light-svn] r131 - in trunk/source: melee other
Message-ID: <200503061646.j26Gk1Sa011374@sheep.berlios.de>

Author: yurand
Date: 2005-03-06 17:45:59 +0100 (Sun, 06 Mar 2005)
New Revision: 131

Modified:
   trunk/source/melee/mgame.cpp
   trunk/source/other/dialogs.cpp
   trunk/source/other/dialogs.h
Log:
Removing incorrect items from ingame menu


Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-03-06 16:30:51 UTC (rev 130)
+++ trunk/source/melee/mgame.cpp	2005-03-06 16:45:59 UTC (rev 131)
@@ -1324,12 +1324,12 @@
     case INGAME_MENU_OPTIONS:
       handle_key(KEY_F4<<8);
       break;
-    case INGAME_MENU_FAST_FORWARD:
-      handle_key(KEY_F5<<8);
-      break;
-    case INGAME_MENU_FLET_STATUS:
-      handle_key(KEY_F6<<8);
-      break;
+      //    case INGAME_MENU_FAST_FORWARD:
+      //      handle_key(KEY_F5<<8);
+      //      break;
+      //case INGAME_MENU_FLET_STATUS:
+      //      handle_key(KEY_F6<<8);
+      //    break;
     case INGAME_MENU_CHANGE_TIC_RATE:
       handle_key(KEY_F7<<8);
       pause();

Modified: trunk/source/other/dialogs.cpp
===================================================================
--- trunk/source/other/dialogs.cpp	2005-03-06 16:30:51 UTC (rev 130)
+++ trunk/source/other/dialogs.cpp	2005-03-06 16:45:59 UTC (rev 131)
@@ -31,19 +31,17 @@
 
 DIALOG ingameMenuDialog[] =  {
   // (dialog proc)          (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
-  { d_agup_box_proc,        140,   40,   250,  430 ,  255,  0,     0,    0,       0,    0,    NULL, NULL, NULL },
+  { d_agup_box_proc,        140,   40,   250,  380,  255,  0,     0,    0,       0,    0,    NULL, NULL, NULL },
   { my_d_button_proc,       150,   50,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Help                  (F1) ", NULL, NULL },
   { my_d_button_proc,       150,   85,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Save Game             (F2) ", NULL, NULL },
   { my_d_button_proc,       150,  120,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Load Game             (F3) ", NULL, NULL },
   { my_d_button_proc,       150,  155,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Options               (F4) ", NULL, NULL },
-  { my_d_button_proc,       150,  190,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Fast Forward          (F5) ", NULL, NULL },
-  { my_d_button_proc,       150,  225,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Fleet Status          (F6) ", NULL, NULL },
-  { my_d_button_proc,       150,  260,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Change Tic Rate       (F7) ", NULL, NULL },
-  { my_d_button_proc,       150,  295,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Change Camera Mode    (F8) ", NULL, NULL },
-  { my_d_button_proc,       150,  330,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Switches Camera Focus (F11)", NULL, NULL },
-  { my_d_button_proc,       150,  365,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Displays Framerates   (F12)", NULL, NULL },
-  { my_d_button_proc,       150,  400,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Quit game", NULL, NULL },
-  { my_d_button_proc,       150,  435,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Exit Menu", NULL, NULL },
+  { my_d_button_proc,       150,  190,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Change Tic Rate       (F7) ", NULL, NULL },
+  { my_d_button_proc,       150,  225,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Change Camera Mode    (F8) ", NULL, NULL },
+  { my_d_button_proc,       150,  260,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Switches Camera Focus (F11)", NULL, NULL },
+  { my_d_button_proc,       150,  295,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Displays Framerates   (F12)", NULL, NULL },
+  { my_d_button_proc,       150,  330,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Quit game", NULL, NULL },
+  { my_d_button_proc,       150,  365,   230,   30,   255,  0,    0,    D_EXIT,  0,    0,    (char*)"Exit Menu", NULL, NULL },
   { NULL,                    0,    0,     0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL }
 };
 

Modified: trunk/source/other/dialogs.h
===================================================================
--- trunk/source/other/dialogs.h	2005-03-06 16:30:51 UTC (rev 130)
+++ trunk/source/other/dialogs.h	2005-03-06 16:45:59 UTC (rev 131)
@@ -53,8 +53,6 @@
     INGAME_MENU_SAVE,
     INGAME_MENU_LOAD,
     INGAME_MENU_OPTIONS,
-    INGAME_MENU_FAST_FORWARD,
-    INGAME_MENU_FLET_STATUS,
     INGAME_MENU_CHANGE_TIC_RATE,
     INGAME_MENU_CHANGE_CAMERA_MODE,
     INGAME_MENU_SWITCH_CAMERA_FOCUS,



From yurand at sheep.berlios.de  Mon Mar  7 15:47:16 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Mon, 7 Mar 2005 15:47:16 +0100
Subject: [Tw-light-svn] r132 - in trunk: gamedata gamedata/images gamedata/music source source/melee source/util
Message-ID: <200503071447.j27ElGN2032549@sheep.berlios.de>

Author: yurand
Date: 2005-03-07 15:47:14 +0100 (Mon, 07 Mar 2005)
New Revision: 132

Added:
   trunk/gamedata/gamedata.dat
   trunk/gamedata/images/3dlogo.jpg
   trunk/gamedata/images/background.jpg
   trunk/gamedata/images/joses_pkunk.jpg
   trunk/gamedata/music/intro.xm
   trunk/source/melee/mhelpers.h
Modified:
   trunk/source/melee/mhelpers.cpp
   trunk/source/scp.cpp
   trunk/source/scp.h
   trunk/source/util/get_time.h
Log:
Added intro


Added: trunk/gamedata/gamedata.dat
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/gamedata.dat
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/3dlogo.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/3dlogo.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/background.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/background.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/joses_pkunk.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/joses_pkunk.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/music/intro.xm
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/music/intro.xm
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2005-03-06 16:45:59 UTC (rev 131)
+++ trunk/source/melee/mhelpers.cpp	2005-03-07 14:47:14 UTC (rev 132)
@@ -31,6 +31,7 @@
 #include "melee.h"
 #include "melee/mcontrol.h"
 #include "input.h"
+#include "mhelpers.h"
 
 /*
 
@@ -604,6 +605,45 @@
 }
 
 
+///////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+void ScrollText(std::vector<std::string>& text, FONT* font, int color, const std::string& backgr)
+{
+  BITMAP* d_buf = create_bitmap(SCREEN_W, SCREEN_H);
+  clear(d_buf);
+  copy_buf();
+
+  unsigned int q = 0;
+  BITMAP* tmpB = load_bitmap(data_full_path(backgr).c_str(), NULL);
+  BITMAP* background = create_bitmap(screen->w, screen->h);
+  stretch_blit(tmpB, background, 0, 0, tmpB->w, tmpB->h, 0, 0, background->w, background->h);
+  destroy_bitmap(tmpB);
+  
+
+  while (1)
+    {
+      blit(background, d_buf, 0, 0,  0, 0, background->w, background->h);
+      for (unsigned int i = 0;i!=text.size();i++)
+	{
+	  text_mode(-1);
+	  textout_centre(d_buf, font, text[i].c_str(), screen->w/2, screen->h+40-q/3+i*30,-1);
+	}
+      copy_buf();
+      
+      HAVE_A_WAIT(30);
+      q+=2;
+      
+      if (q/3 >= text.size()*30+screen->h+140)
+	break;
+    }
+  clear(d_buf);
+  copy_buf();	
+  destroy_bitmap(d_buf);
+}
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////
 /*------------------------------
 		SC2 Unit Conversion
 ------------------------------*/

Added: trunk/source/melee/mhelpers.h
===================================================================
--- trunk/source/melee/mhelpers.h	2005-03-06 16:45:59 UTC (rev 131)
+++ trunk/source/melee/mhelpers.h	2005-03-07 14:47:14 UTC (rev 132)
@@ -0,0 +1,31 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#ifndef __TW_MHELPERS_INCLUDES__
+#define __TW_MHELPERS_INCLUDES__
+
+#include "allegro.h"
+
+#include <vector>
+#include <string>
+
+// Show scrolling text
+
+void ScrollText(std::vector<std::string>& text, FONT* font, int color, const std::string& backgr);
+
+
+#endif 
+

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-03-06 16:45:59 UTC (rev 131)
+++ trunk/source/scp.cpp	2005-03-07 14:47:14 UTC (rev 132)
@@ -60,8 +60,8 @@
 #include "melee/mcontrol.h"
 #include "melee/mcbodies.h"
 #include "melee/mgame.h"
+#include "melee/mhelpers.h"
 
-
 #include "melee/mmain.h"
 #include "melee/mnet1.h"
 #include "util/aastr.h"
@@ -69,6 +69,12 @@
 #include "melee/mfleet.h"
 
 
+
+
+DATAFILE* g_game_data = NULL;
+
+void intro();
+
 ///the server port to connect to in client mode.  
 unsigned serverPort = DEFAULT_SERVER_PORT;
 ///the server address to connect to in client mode.
@@ -741,6 +747,8 @@
     tw_error_exit("Allegro initialization failed");
   create_user_ini();
   
+  g_game_data = load_datafile(data_full_path("gamedata.dat").c_str());
+
   VideoSystem video;
   videosystem = &video;
   videosystem->preinit();
@@ -925,8 +933,16 @@
       tw_sound->set_sound_volume(tw_sound->load_sound_volume());
       tw_sound->set_music_volume(tw_sound->load_music_volume());
     
-      showLoadingScreen();
-    
+
+      // Show Intro
+      RGB tmpPal[256];
+      memcpy(tmpPal, palette_color, sizeof(RGB) * 256);
+      set_palette((const RGB*)g_game_data[TW_FONT_PALETTE].dat);
+      
+      intro();
+      videosystem->set_palette(tmpPal);
+      
+
       View *v = NULL;
       v = get_view ( get_config_string("View", "View", NULL) , NULL );
       if (!v) v = get_view ( "Hero", NULL );
@@ -1971,3 +1987,75 @@
   return 0;
 }
 
+
+//################################################################################################
+//  Intro
+
+
+
+
+
+void intro()
+{
+  BITMAP* d_buf;
+  std::vector<std::string> intro_text;
+
+  intro_text.push_back("The Ur-quan are defeated - the destruction");
+  intro_text.push_back("of the Sa-matra threw them into chaos,");
+  intro_text.push_back("making them easy prey for");
+  intro_text.push_back("the New Alliance of Free Stars.");
+  intro_text.push_back("Within weeks the NAFS forces managed");
+  intro_text.push_back("to destroy most of the fleets of the two ");
+  intro_text.push_back("races who terrorized the galaxy");
+  intro_text.push_back("for the past 20,000 years!");
+  intro_text.push_back("");
+  intro_text.push_back("Thanks to captain Zelnick, hope is given");
+  intro_text.push_back("to the entire galaxy, and especially to");
+  intro_text.push_back("the human race. Now free from their prison");
+  intro_text.push_back("under a Slaveshield it's Humanity's time");
+  intro_text.push_back("to rebuild.");
+  intro_text.push_back("");
+  intro_text.push_back("However, it seems there are more troubles");
+  intro_text.push_back("ahead. It is time for great space");
+  intro_text.push_back("exploration, colonization and piracy.");
+  intro_text.push_back("You have to live in this world,");
+  intro_text.push_back("young earth captain!!!");
+
+  d_buf = create_bitmap(SCREEN_W, SCREEN_H);
+  clear(d_buf);
+  copy_buf();
+
+  tw_sound->play_music(data_full_path("music/intro.xm"), -1);
+  clear(d_buf);
+  BITMAP* logo = load_bitmap(data_full_path("images/3dlogo.jpg").c_str(), NULL);
+  stretch_blit(logo, d_buf, 0, 0, logo->w, logo->h, 0, 0, screen->w, screen->h);
+  destroy_bitmap(logo);
+
+  textout_centre(d_buf, D_FONT_ENGLISH, "TimeWarp development team", screen->w/2, screen->h-50, -1);
+  copy_buf();
+  HAVE_A_WAIT(2500);
+ 
+  clear(d_buf);
+  textout_centre(d_buf, D_FONT_ENGLISH, "somewhat proudly", screen->w/2, screen->h/2, -1);
+  textout_centre(d_buf, D_FONT_ENGLISH, "present", screen->w/2, screen->h/2+40, -1);
+  copy_buf();
+  HAVE_A_WAIT(2500);
+  clear(d_buf);
+
+  BITMAP* pkunk = load_bitmap(data_full_path("images/joses_pkunk.jpg").c_str(), NULL);
+  blit(pkunk, d_buf, 0, 0,  (screen->w-pkunk->w)/2, 20, pkunk->w, pkunk->h);
+  textout_centre(d_buf, D_FONT_ENGLISH, "TW-Light : Legacies", screen->w/2, pkunk->h+60, -1);
+  destroy_bitmap(pkunk);
+  copy_buf();
+  HAVE_A_WAIT(2500);
+  
+  ScrollText(intro_text,  D_FONT_ENGLISH, -1, "images/background.jpg");
+
+
+  clear(d_buf);
+  copy_buf();	
+  destroy_bitmap(d_buf);
+}
+
+
+

Modified: trunk/source/scp.h
===================================================================
--- trunk/source/scp.h	2005-03-06 16:45:59 UTC (rev 131)
+++ trunk/source/scp.h	2005-03-07 14:47:14 UTC (rev 132)
@@ -48,6 +48,9 @@
 int handleSoundSliderChange(void *dp3, int d2);
 int handleMusicSliderChange(void *dp3, int d2);
 
+
+extern DATAFILE* g_game_data;
+
 extern std::string menuAccept;
 extern std::string menuFocus;
 extern std::string menuDisabled;
@@ -100,4 +103,16 @@
 std::string data_full_path(std::string path);
 std::string home_ini_full_path(std::string path);
 
+
+
+#define copy_buf() blit(d_buf, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H)
+
+// Data Define
+#define TW_FONT_ENGLISH     1
+#define TW_FONT_PALETTE     2
+
+// Data
+#define D_FONT_ENGLISH	((FONT*)g_game_data[TW_FONT_ENGLISH].dat)
+
+
 #endif // __SCP_H__

Modified: trunk/source/util/get_time.h
===================================================================
--- trunk/source/util/get_time.h	2005-03-06 16:45:59 UTC (rev 131)
+++ trunk/source/util/get_time.h	2005-03-07 14:47:14 UTC (rev 132)
@@ -16,6 +16,22 @@
 int idle ( int time ); //to yeild a number of milliseconds to the OS
 extern int _no_idle;   //to disable the above function
 
+  // wait (_d) msec until ESC pressed
+#define HAVE_A_WAIT(_d)	\
+{ \
+        int time = get_time(); \
+	while (time + _d > get_time()) \
+        {  \
+	  while (keypressed()) \
+	  { \
+	    int k = readkey(); \
+	    if(k>>8 == KEY_ESC) \
+	      return; \
+	  } \
+           idle(10); \
+        } \
+}
+
 #ifdef __cplusplus
 }
 #endif



From yurand at sheep.berlios.de  Mon Mar  7 23:10:59 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Mon, 7 Mar 2005 23:10:59 +0100
Subject: [Tw-light-svn] r133 - in trunk/source: . games melee other
Message-ID: <200503072210.j27MAxjC003412@sheep.berlios.de>

Author: yurand
Date: 2005-03-07 23:10:58 +0100 (Mon, 07 Mar 2005)
New Revision: 133

Modified:
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee/mframe.h
   trunk/source/melee/mhelpers.cpp
   trunk/source/melee/mhelpers.h
   trunk/source/melee/moptions.cpp
   trunk/source/other/dialogs.cpp
   trunk/source/other/dialogs.h
   trunk/source/scp.cpp
   trunk/source/scp.h
Log:
Slightly changed UI.
Jumping between planet is implemented as copying 
item and presence not as creating new subgames (only little proto for 
now)



Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/games/ggob.cpp	2005-03-07 22:10:58 UTC (rev 133)
@@ -122,6 +122,24 @@
     return GobGameBase::setGameDone(done);
 }
 
+
+void GobGame::switch_system(const std::string& name)
+{
+  // remove ship from current system
+  item.remove(maingame->gobplayer.ship);
+
+  // Save current game
+  _galaxy[_name] = std::pair<std::list<SpaceLocation*>, std::list<Presence*> >(item,presence);
+  
+  // Load 
+  item = _galaxy[name].first;
+  presence = _galaxy[name].second;
+  
+  // add player ship
+  item.remove(maingame->gobplayer.ship);
+  item.push_back(maingame->gobplayer.ship);
+}
+
 void GobGame::add_gobplayer(Control *control) 
 {
   STACKTRACE;
@@ -209,7 +227,6 @@
 
   enemy_team = new_team();
 	       
-   //  for (i = 0; i < 19; i += 1) add(new GobAsteroid());
 
   int server_players;
   tw_set_config_file("client.ini");
@@ -231,6 +248,9 @@
 		       0,1
 		       );
 
+  _galaxy["Arix"] = std::pair<std::list<SpaceLocation*>, std::list<Presence*> >(item,presence);
+  _galaxy["Beta"] = std::pair<std::list<SpaceLocation*>, std::list<Presence*> >(item,presence);
+
   return;
 }
 
@@ -392,6 +412,18 @@
     {
     case KEY_J: 
       {
+	if(_name=="Arix")
+	  {
+	    switch_system("Beta");
+	    _name = "Beta";
+	  }
+	else
+	  {
+	    switch_system("Arix");
+	    _name = "Arix";
+
+	  }
+	/*
 	setGameDone(GAME_STATE_SUSPENDED);
 	maingame->gobplayer._teleport = 1;
 	maingame->gobplayer.ship->die();
@@ -403,6 +435,7 @@
 	  {
 	    maingame->setActiveGame("Arix");
 	  }
+	*/
 	return true;
       }
       break;

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/games/ggob.h	2005-03-07 22:10:58 UTC (rev 133)
@@ -100,8 +100,12 @@
 /// GOB class adventure game
 class GobGame : public  GobGameBase
 {
-  //  int _player_channel;
+
+  std::map<std::string, std::pair<std::list<SpaceLocation*>, std::list<Presence*> > > _galaxy;
+
  public:
+  virtual void switch_system(const std::string& name);
+
   GobGame();
   virtual ~GobGame();
 

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/melee/mframe.h	2005-03-07 22:10:58 UTC (rev 133)
@@ -71,7 +71,6 @@
   friend struct Query;
   
   std::list<SpaceLocation*> item;
-  
   std::list<Presence*> presence;
   
   /// add space location to universe

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/melee/mhelpers.cpp	2005-03-07 22:10:58 UTC (rev 133)
@@ -608,7 +608,7 @@
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 
-void ScrollText(std::vector<std::string>& text, FONT* font, int color, const std::string& backgr)
+void ScrollText(std::vector<std::string>& text, FONT* font, int color, const std::string& backgr, const std::string& align, int speed)
 {
   BITMAP* d_buf = create_bitmap(SCREEN_W, SCREEN_H);
   clear(d_buf);
@@ -627,13 +627,30 @@
       for (unsigned int i = 0;i!=text.size();i++)
 	{
 	  text_mode(-1);
-	  textout_centre(d_buf, font, text[i].c_str(), screen->w/2, screen->h+40-q/3+i*30,-1);
+	  if(align == "c")
+	    {
+	      textout_centre(d_buf, font, text[i].c_str(), screen->w/2, screen->h+20-q/3+i*30,-1);
+	    }
+	  else if(align == "l")
+	    {
+	      textout(d_buf, font, text[i].c_str(), 30, screen->h+20-q/3+i*30,-1);
+	    }
+	  else if(align == "r")
+	    {
+	      textout_right(d_buf, font, text[i].c_str(), screen->w-30, screen->h+20-q/3+i*30,-1);
+	    }
 	}
       copy_buf();
       
-      HAVE_A_WAIT(30);
-      q+=2;
+      HAVE_A_WAIT(10);
+      q+=speed;
       
+      while (keypressed())
+	{ 
+	  int k = readkey(); 
+	  if(k>>8 == KEY_ESC) 
+	    return; 
+	} 
       if (q/3 >= text.size()*30+screen->h+140)
 	break;
     }

Modified: trunk/source/melee/mhelpers.h
===================================================================
--- trunk/source/melee/mhelpers.h	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/melee/mhelpers.h	2005-03-07 22:10:58 UTC (rev 133)
@@ -24,7 +24,7 @@
 
 // Show scrolling text
 
-void ScrollText(std::vector<std::string>& text, FONT* font, int color, const std::string& backgr);
+void ScrollText(std::vector<std::string>& text, FONT* font, int color, const std::string& backgr, const std::string& align, int speed);
 
 
 #endif 

Modified: trunk/source/melee/moptions.cpp
===================================================================
--- trunk/source/melee/moptions.cpp	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/melee/moptions.cpp	2005-03-07 22:10:58 UTC (rev 133)
@@ -107,11 +107,11 @@
 	    config_menu(game);
 	  }
 	  break;
-	case DIALOG_OPTIONS_PHYSICS: 
+	case DIALOG_OPTIONS_TEAMS: 
 	  {
-	    physics_menu(game);
+	    change_teams();
+	    videosystem->redraw();
 	  }
-	  break;
 	case DIALOG_OPTIONS_DEFAULT: 
 	  {
 	  }

Modified: trunk/source/other/dialogs.cpp
===================================================================
--- trunk/source/other/dialogs.cpp	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/other/dialogs.cpp	2005-03-07 22:10:58 UTC (rev 133)
@@ -161,12 +161,12 @@
 
 DIALOG options_dialog[] = {
   // (dialog proc)     (x)   (y)   (w)   (h)   (fg) (bg) (key) (flags)  (d1)  (d2)  (dp)
-  { d_agup_box_proc,        40,    30,  190,  190,   255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
-  { my_d_button_proc,  70,    40,  110,   40,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Done", NULL, NULL },
-  { my_d_button_proc,  50,    90,  170,   30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Video Mode", NULL, NULL },
-  { my_d_button_proc,  50,   130,  170,   30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Audio Settings", NULL, NULL },
-  { my_d_button_proc,  50,   170,  170,   30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Game && Rendering", NULL, NULL },
-//  { my_d_button_proc,  50,   210,  170,   30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Physics Settings", NULL, NULL },
+  { d_agup_box_proc,   40,    30,  190,  135,   255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { my_d_button_proc,  70,    40,  110,   20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Done", NULL, NULL },
+  { my_d_button_proc,  50,    65,  170,   20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Video Mode", NULL, NULL },
+  { my_d_button_proc,  50,    90,  170,   20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Audio Settings", NULL, NULL },
+  { my_d_button_proc,  50,   115,  170,   20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Game && Rendering", NULL, NULL },
+  { my_d_button_proc,  50,   140,  170,   20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Teams", NULL, NULL },
 //  { my_d_button_proc,  50,   250,  170,   40,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Restore Defaults", NULL, NULL },
   { d_tw_yield_proc,        0,    0,    0,    0,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
   { NULL,              0,    0,     0,    0,    255,  0,    0,    0,       1,    0,    NULL, NULL, NULL }
@@ -250,13 +250,16 @@
 
 DIALOG mainDialog[] = {
   // (dialog proc)     (x)   (y)   (w)   (h)   (fg)  (bg)  (key) (flags)  (d1)  (d2)  (dp)
-  { d_agup_shadow_box_proc, 40,   40,   180,  215,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
-  { my_d_button_proc,  45,   45,   170,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Melee" , NULL, NULL },
-  { my_d_button_proc,  45,   80,   170,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Extras" , NULL, NULL },
-  { my_d_button_proc,  45,   115,  170,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Teams" , NULL, NULL },
-  { my_d_button_proc,  45,   150,  170,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Options", NULL, NULL },
-  { my_d_button_proc,  45,   185,  170,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Help", NULL, NULL },
-  { my_d_button_proc,  45,   220,  170,  30,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Exit", NULL, NULL },
+  { d_agup_shadow_box_proc, 40,   40,   140,  230,  255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
+  { my_d_button_proc,  45,   45,   130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"New Game" , NULL, NULL },
+  { my_d_button_proc,  45,   70,   130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Load Game" , NULL, NULL },
+  { my_d_button_proc,  45,   95,  130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Melee" , NULL, NULL },
+  { my_d_button_proc,  45,   120,  130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Multiplayer", NULL, NULL },
+  { my_d_button_proc,  45,   145,  130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Extras", NULL, NULL },
+  { my_d_button_proc,  45,   170,  130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Preferences", NULL, NULL },
+  { my_d_button_proc,  45,   195,  130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Help", NULL, NULL },
+  { my_d_button_proc,  45,   220,  130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"About", NULL, NULL },
+  { my_d_button_proc,  45,   245,  130,  20,   255,  0,    0,    D_EXIT,  0,    0,    (void *)"Exit", NULL, NULL },
   { d_tw_yield_proc,   0,    0,    0,    0,    255,  0,    0,    0,       0,    0,    NULL, NULL, NULL },
   { NULL,              0,    0,    0,    0,    255,  0,    0,    0,       1,    0,    NULL, NULL, NULL }
 };

Modified: trunk/source/other/dialogs.h
===================================================================
--- trunk/source/other/dialogs.h	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/other/dialogs.h	2005-03-07 22:10:58 UTC (rev 133)
@@ -112,7 +112,7 @@
     DIALOG_OPTIONS_VIDEO,
     DIALOG_OPTIONS_AUDIO,
     DIALOG_OPTIONS_CONFIG,
-    DIALOG_OPTIONS_PHYSICS,
+    DIALOG_OPTIONS_TEAMS,
     DIALOG_OPTIONS_DEFAULT
   };
 
@@ -186,11 +186,14 @@
 enum 
   {
     MAIN_DIALOG_BOX = 0,
+    MAIN_DIALOG_NEW_GAME,
+    MAIN_DIALOG_LOAD,
     MAIN_DIALOG_MELEE,
+    MAIN_DIALOG_MULTIPLAYER,
     MAIN_DIALOG_MELEE_EXTENDED,
-    MAIN_DIALOG_TEAMS,
-    MAIN_DIALOG_OPTIONS,
+    MAIN_DIALOG_PREFERENCES,
     MAIN_DIALOG_HELP,
+    MAIN_DIALOG_ABOUT,
     MAIN_DIALOG_EXIT,
   };
 

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/scp.cpp	2005-03-07 22:10:58 UTC (rev 133)
@@ -73,7 +73,7 @@
 
 DATAFILE* g_game_data = NULL;
 
-void intro();
+void GOBIntro();
 
 ///the server port to connect to in client mode.  
 unsigned serverPort = DEFAULT_SERVER_PORT;
@@ -148,9 +148,6 @@
 ///  (SHIPVIEW dialog) You can also test key jamming from this dialog.
 void extended_menu(int i = -1);
 
-/// TEAMS dialog - from here you can select controllers for each player, and access their respective fleets. (FLEET dialog)
-void change_teams();
-
 /// FLEET dialog - manages fleet compositions for an individual player.
 ///  \param player Player index indicating which player's fleet to edit.
 void edit_fleet(int player);
@@ -690,17 +687,75 @@
 	extended_menu();
 	enable();
 	break;
-      case MAIN_DIALOG_OPTIONS:
+      case MAIN_DIALOG_PREFERENCES:
 	showTitle();
 	options_menu(NULL);
 	break;
       case MAIN_DIALOG_HELP:
 	show_file(data_full_path("ingame.txt").c_str());
 	break;
-      case MAIN_DIALOG_TEAMS:
-	change_teams();
-	showTitle();
-	break;
+      case MAIN_DIALOG_NEW_GAME:
+	{
+	  // Show Intro
+	  RGB tmpPal[256];
+	  memcpy(tmpPal, palette_color, sizeof(RGB) * 256);
+	  set_palette((const RGB*)g_game_data[TW_FONT_PALETTE].dat);
+      
+	  GOBIntro();
+	  videosystem->set_palette(tmpPal);
+
+	  disable();
+	  play_game("GOB", "", NULL);
+	  enable();
+	  break;
+	}
+	case MAIN_DIALOG_ABOUT:
+	{
+	  // Show Intro
+	  RGB tmpPal[256];
+	  memcpy(tmpPal, palette_color, sizeof(RGB) * 256);
+	  set_palette((const RGB*)g_game_data[TW_FONT_PALETTE].dat);
+
+	  std::vector<std::string> about;
+	  about.push_back("Team");
+	  about.push_back("");
+	  about.push_back("Programmers:");
+	  about.push_back("");
+	  about.push_back("  * Yura Semashko (Yurand)");
+	  about.push_back("  * Paul Forest (youBastrd)");
+	  about.push_back("");
+	  about.push_back("Content and Plot manager:");
+	  about.push_back("");
+	  about.push_back("  * Asaf Hamtzany (UAF)");
+	  about.push_back("");
+	  about.push_back("Dialog Writers");
+	  about.push_back("");
+	  about.push_back("  * Pelorki");
+	  about.push_back("");
+	  about.push_back("Graphic Designers");
+	  about.push_back("");
+	  about.push_back("  * Rick Bushie (Firehazurd)");
+	  about.push_back("");
+	  about.push_back("Music");
+	  about.push_back("");
+	  about.push_back("  * Robeter Productions (www.robeterproductions.com)");
+	  about.push_back("  * Mark Forest (Abe Froman)");
+	  about.push_back("");
+	  about.push_back("Special Thanks:");
+	  about.push_back("");
+	  about.push_back("  * Tau");
+	  about.push_back("  * GeomanNL");
+	  about.push_back("  * Officer Flubbo");
+	  about.push_back("  * Captain Maim");
+	  about.push_back("  * Jumping Peppers");
+	  about.push_back("  * Robeter Productions");
+
+	  ScrollText(about,  D_FONT_ENGLISH, -1, "images/background.jpg", "l", 3);
+
+	  videosystem->set_palette(tmpPal);
+	  videosystem->redraw();
+	  break;
+	}
       }
     } while((mainRet != MAIN_DIALOG_EXIT) && (mainRet != -1));
   
@@ -932,17 +987,8 @@
       tw_sound = &sound;
       tw_sound->set_sound_volume(tw_sound->load_sound_volume());
       tw_sound->set_music_volume(tw_sound->load_music_volume());
-    
+          
 
-      // Show Intro
-      RGB tmpPal[256];
-      memcpy(tmpPal, palette_color, sizeof(RGB) * 256);
-      set_palette((const RGB*)g_game_data[TW_FONT_PALETTE].dat);
-      
-      intro();
-      videosystem->set_palette(tmpPal);
-      
-
       View *v = NULL;
       v = get_view ( get_config_string("View", "View", NULL) , NULL );
       if (!v) v = get_view ( "Hero", NULL );
@@ -1995,7 +2041,7 @@
 
 
 
-void intro()
+void GOBIntro()
 {
   BITMAP* d_buf;
   std::vector<std::string> intro_text;
@@ -2049,7 +2095,7 @@
   copy_buf();
   HAVE_A_WAIT(2500);
   
-  ScrollText(intro_text,  D_FONT_ENGLISH, -1, "images/background.jpg");
+  ScrollText(intro_text,  D_FONT_ENGLISH, -1, "images/background.jpg", "c", 2);
 
 
   clear(d_buf);

Modified: trunk/source/scp.h
===================================================================
--- trunk/source/scp.h	2005-03-07 14:47:14 UTC (rev 132)
+++ trunk/source/scp.h	2005-03-07 22:10:58 UTC (rev 133)
@@ -28,7 +28,9 @@
 
 std::string tw_version();
 
+/// TEAMS dialog - from here you can select controllers for each player, and access their respective fleets. (FLEET dialog)
 void change_teams();
+
 void edit_fleet(int player) ;
 
 int connect_menu(VideoWindow *window, char **address, int *port) ;



From yurand at sheep.berlios.de  Tue Mar  8 00:23:02 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Tue, 8 Mar 2005 00:23:02 +0100
Subject: [Tw-light-svn] r134 - trunk/source/games
Message-ID: <200503072323.j27NN2x6008091@sheep.berlios.de>

Author: yurand
Date: 2005-03-08 00:23:00 +0100 (Tue, 08 Mar 2005)
New Revision: 134

Modified:
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
Log:
Reimplementing system jump using item vector


Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-03-07 22:10:58 UTC (rev 133)
+++ trunk/source/games/ggob.cpp	2005-03-07 23:23:00 UTC (rev 134)
@@ -96,29 +96,12 @@
 void GobGame::prepare()
 {
   GobGameBase::prepare();
-  if(maingame->gobplayer._teleport)
-    {
-      message.flush();
-      ShipType* type = maingame->gobplayer.ship->type;
-      double crew = maingame->gobplayer.ship->crew;
-      maingame->gobplayer.ship = NULL;
-      maingame->gobplayer.new_ship(type);
-      add_focus(_player_control, _player_control->channel);
-
-      maingame->gobplayer.ship->crew = crew;
-      maingame->gobplayer.ship->batt = 0;
-
-      maingame->gobplayer._teleport = 0;
-    }
 }
 
 
 void GobGame::setGameDone(int done)
 {
-  if(done == GAME_STATE_FINISHED)
-    {
-      maingame->setGameDone(done);
-    }
+
     return GobGameBase::setGameDone(done);
 }
 
@@ -126,24 +109,32 @@
 void GobGame::switch_system(const std::string& name)
 {
   // remove ship from current system
-  item.remove(maingame->gobplayer.ship);
+  item.remove(gobplayer.ship);
 
   // Save current game
-  _galaxy[_name] = std::pair<std::list<SpaceLocation*>, std::list<Presence*> >(item,presence);
+  _galaxy[_name] = item;
   
   // Load 
-  item = _galaxy[name].first;
-  presence = _galaxy[name].second;
+  if(_galaxy.find(name)!=_galaxy.end())
+    {
+      item = _galaxy[name];
+    }
+  else
+    {
+      item.clear();
+    }
   
+  _name = name;
   // add player ship
-  item.remove(maingame->gobplayer.ship);
-  item.push_back(maingame->gobplayer.ship);
+  item.remove(gobplayer.ship);
+  if(gobplayer.ship)
+    item.push_back(gobplayer.ship);
 }
 
 void GobGame::add_gobplayer(Control *control) 
 {
   STACKTRACE;
-  maingame->gobplayer.init( new_team());
+  gobplayer.init( new_team());
   add_focus(_player_control, _player_control->channel);
   return;
 }
@@ -153,7 +144,7 @@
   if (_player_panel) 
     _player_panel->die();
   _player_panel = NULL;
-  _player_panel = new ShipPanel(maingame->gobplayer.ship);
+  _player_panel = new ShipPanel(gobplayer.ship);
   _player_panel->always_redraw = true;
   _player_panel->window->init(window);
   
@@ -228,17 +219,22 @@
   enemy_team = new_team();
 	       
 
+
   int server_players;
   tw_set_config_file("client.ini");
   server_players = 1;
   log_int(channel_server, server_players);
   _player_control = create_control(channel_server, "Human", "Config0");
 
+  if(Load(data_full_path("xml/GOB/start.xml")) == 1)
+    {
+      tw_error("unable to locate start.xml");
+    };  
+
   add ( new RainbowRift() );
   
   next_add_new_enemy_time = 1000;
 
-       //  add_new_enemy();
 
   this->change_view("Hero");
   view->window->locate(
@@ -247,10 +243,6 @@
 		       0,0.9,
 		       0,1
 		       );
-
-  _galaxy["Arix"] = std::pair<std::list<SpaceLocation*>, std::list<Presence*> >(item,presence);
-  _galaxy["Beta"] = std::pair<std::list<SpaceLocation*>, std::list<Presence*> >(item,presence);
-
   return;
 }
 
@@ -318,15 +310,15 @@
 
   int i = 0;
       
-  if (maingame->gobplayer.ship) 
+  if (gobplayer.ship) 
     {
       message.print((int)msecs_per_fps, 15-i, "coordinates: %d x %d", 
-		    iround(maingame->gobplayer.ship->normal_pos().x), 
-		    iround(maingame->gobplayer.ship->normal_pos().y));
+		    iround(gobplayer.ship->normal_pos().x), 
+		    iround(gobplayer.ship->normal_pos().y));
     }
-  message.print((int)msecs_per_fps, 15-i, "starbucks: %d", maingame->gobplayer.starbucks);
-  message.print((int)msecs_per_fps, 15-i, "buckazoids: %d", maingame->gobplayer.buckazoids);
-  message.print((int)msecs_per_fps, 15-i, "kills: %d", maingame->gobplayer.kills);
+  message.print((int)msecs_per_fps, 15-i, "starbucks: %d", gobplayer.starbucks);
+  message.print((int)msecs_per_fps, 15-i, "buckazoids: %d",gobplayer.buckazoids);
+  message.print((int)msecs_per_fps, 15-i, "kills: %d", gobplayer.kills);
   
   return;
 }
@@ -400,8 +392,8 @@
 GobPlayer *GobGame::get_player(SpaceLocation *what) 
 {
   STACKTRACE;
-  if (what->get_team() == maingame->gobplayer.team) 
-    return &(maingame->gobplayer);
+  if (what->get_team() == gobplayer.team) 
+    return &(gobplayer);
   return NULL;
 }
 
@@ -415,13 +407,10 @@
 	if(_name=="Arix")
 	  {
 	    switch_system("Beta");
-	    _name = "Beta";
 	  }
 	else
 	  {
 	    switch_system("Arix");
-	    _name = "Arix";
-
 	  }
 	/*
 	setGameDone(GAME_STATE_SUSPENDED);
@@ -543,9 +532,7 @@
 
 GobPlayer::GobPlayer()
 {
-  _teleport = 0;
-  _teleport_to = "";
-
+  ship = NULL;
 }
 
 GobPlayer::~GobPlayer() 
@@ -1051,6 +1038,18 @@
 	return;
 }
 
+
+void GobGame::add_gobplayer(const std::string& system, Vector2 pos)
+{
+  STACKTRACE;
+  switch_system(system);
+  gobplayer.init(game->new_team());
+  add_focus(_player_control, _player_control->channel);
+  gobplayer.new_ship(shiptype("supbl"));
+  gobplayer.ship->translate(pos);
+}
+
+/*
 void MainGobGame::init (Log *log, const std::string& save)
 {
   MainGame::init(log,save);
@@ -1061,17 +1060,9 @@
     };  
 }	
 
-void MainGobGame::add_gobplayer(const std::string& system, Vector2 pos)
-{
-  STACKTRACE;
-   switch_to(system);
-   gobplayer.init(game->new_team());
-   game->add_focus(gobgame->_player_control, gobgame->_player_control->channel);
-   gobplayer.new_ship(shiptype("supbl"));
-   gobplayer.ship->translate(pos);
-}
+*/
 
-REGISTER_GAME(MainGobGame, "GOB")
+REGISTER_GAME(GobGame, "GOB")
 
 
 

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-03-07 22:10:58 UTC (rev 133)
+++ trunk/source/games/ggob.h	2005-03-07 23:23:00 UTC (rev 134)
@@ -60,9 +60,6 @@
   void new_ship(ShipType *type);
   int charge (char *name, int price_starbucks, int price_buckazoids) ;
   Upgrade **upgrade_list;
-
-  int _teleport;
-  std::string _teleport_to;
 } ;
 
 /// Enemy starship, reward for it
@@ -86,25 +83,33 @@
 
 /////////////////////////////////////////////////////////////////////////////////
 
+/*
 class MainGobGame : public MainGame
 {
  public:
-  GobPlayer gobplayer;
   virtual void 	init (Log *log, const std::string& save);
   void add_gobplayer(const std::string& system, Vector2 pos);
  protected:
 };
+*/
 
-typedef SubGame<MainGobGame> GobGameBase;
+//typedef SubGame<MainGame> GobGameBase;
+//typedef SubGame<MainGobGame> GobGameBase;
+typedef Game GobGameBase;
 
 /// GOB class adventure game
 class GobGame : public  GobGameBase
 {
 
-  std::map<std::string, std::pair<std::list<SpaceLocation*>, std::list<Presence*> > > _galaxy;
+  std::map<std::string, std::list<SpaceLocation*> > _galaxy;
 
  public:
+  GobPlayer gobplayer;
+
+  /// move player to system
   virtual void switch_system(const std::string& name);
+  /// Add new player to the game
+  void add_gobplayer(const std::string& system, Vector2 pos);
 
   GobGame();
   virtual ~GobGame();



From yurand at sheep.berlios.de  Tue Mar  8 15:45:31 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Tue, 8 Mar 2005 15:45:31 +0100
Subject: [Tw-light-svn] r135 - in trunk: . gamedata/xml/GOB source source/games source/melee source/other
Message-ID: <200503081445.j28EjVOo012582@sheep.berlios.de>

Author: yurand
Date: 2005-03-08 15:45:30 +0100 (Tue, 08 Mar 2005)
New Revision: 135

Added:
   trunk/source/other/starmap.cpp
   trunk/source/other/starmap.h
Modified:
   trunk/gamedata/xml/GOB/start.xml
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee.h
   trunk/source/melee/mframe.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mgame.h
   trunk/source/melee/msprite.cpp
   trunk/source/melee/mview.h
   trunk/source/other/configrw.cpp
   trunk/source/other/orbit.cpp
   trunk/sources.lst
Log:
Added simple starmap to GOB,
implementation is awfull but work.


Modified: trunk/gamedata/xml/GOB/start.xml
===================================================================
--- trunk/gamedata/xml/GOB/start.xml	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/gamedata/xml/GOB/start.xml	2005-03-08 14:45:30 UTC (rev 135)
@@ -1,5 +1,5 @@
 <GOB>
-  <System name="Arix" x="24000" y="24000">
+  <System name="Arix" x="50" y="50">
       <SpaceObjects>
 	<Planet_with_station
 	    planet_index="0"
@@ -52,7 +52,7 @@
 	<GobAsteroid/>
       </SpaceObjects>
   </System>
-  <System name="Beta" x="24000" y="24000">
+  <System name="Beta" x="100" y="100">
       <SpaceObjects>
 	<Planet_with_station
 	    planet_index="0"

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/games/ggob.cpp	2005-03-08 14:45:30 UTC (rev 135)
@@ -106,25 +106,50 @@
 }
 
 
+struct findStar : public std::binary_function<StarSystem*, std::string, bool>
+{
+  bool operator ()(StarSystem* s, std::string name) const
+  {
+    if (s->getName() == name)
+      return true;
+    return false;
+  }
+};
+
 void GobGame::switch_system(const std::string& name)
 {
+  if(name == _name)
+    return;
+
   // remove ship from current system
   item.remove(gobplayer.ship);
-
-  // Save current game
-  _galaxy[_name] = item;
   
-  // Load 
-  if(_galaxy.find(name)!=_galaxy.end())
+  std::list<StarSystem*>::iterator sNew = std::find_if(_galaxy._stars.begin(), 
+						 _galaxy._stars.end(), 
+						 std::bind2nd(findStar(), name));
+  if(sNew==_galaxy._stars.end())
     {
-      item = _galaxy[name];
+      tw_error("Star not found");
     }
-  else
+
+  std::list<StarSystem*>::iterator sOld = std::find_if(_galaxy._stars.begin(), 
+						 _galaxy._stars.end(), 
+						 std::bind2nd(findStar(), _name));
+  if(sOld==_galaxy._stars.end())
     {
-      item.clear();
+      tw_error("Star not found");
     }
+
+  // Save current star items  
+  (*sOld)->_item = item;
+
+  // Load new items
+  item = (*sNew)->_item;
   
+  // set new name
   _name = name;
+  _galaxy._playerStar = *sNew;
+
   // add player ship
   item.remove(gobplayer.ship);
   if(gobplayer.ship)
@@ -219,18 +244,23 @@
   enemy_team = new_team();
 	       
 
-
   int server_players;
   tw_set_config_file("client.ini");
   server_players = 1;
   log_int(channel_server, server_players);
   _player_control = create_control(channel_server, "Human", "Config0");
 
+  StarSystem* s = new StarSystem("FakeSystem_123", Vector2(0,0));
+  _name = "FakeSystem_123";
+  _galaxy.add(s);
   if(Load(data_full_path("xml/GOB/start.xml")) == 1)
     {
       tw_error("unable to locate start.xml");
     };  
-
+  
+  _galaxy._stars.remove(s);
+  delete s;
+  
   add ( new RainbowRift() );
   
   next_add_new_enemy_time = 1000;
@@ -412,24 +442,16 @@
 	  {
 	    switch_system("Arix");
 	  }
-	/*
-	setGameDone(GAME_STATE_SUSPENDED);
-	maingame->gobplayer._teleport = 1;
-	maingame->gobplayer.ship->die();
-	if(_name=="Arix")
-	  {
-	    maingame->setActiveGame("Beta");
-	  }
-	else
-	  {
-	    maingame->setActiveGame("Arix");
-	  }
-	*/
 	return true;
       }
       break;
-    //don't use hardwired normal keys
-            
+    case KEY_M:
+      {
+	switch_system(_galaxy.select());
+	videosystem->window.redraw();
+	return true;
+      }
+      break;
     default: 
       {
 	return GobGameBase::handle_key(k);

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/games/ggob.h	2005-03-08 14:45:30 UTC (rev 135)
@@ -24,8 +24,8 @@
 #include "melee/mcbodies.h"
 
 #include "gamehierarchy.h"
+#include "other/starmap.h"
 
-
 class Upgrade;
 class GobStation;
 
@@ -83,27 +83,15 @@
 
 /////////////////////////////////////////////////////////////////////////////////
 
-/*
-class MainGobGame : public MainGame
-{
- public:
-  virtual void 	init (Log *log, const std::string& save);
-  void add_gobplayer(const std::string& system, Vector2 pos);
- protected:
-};
-*/
-
-//typedef SubGame<MainGame> GobGameBase;
-//typedef SubGame<MainGobGame> GobGameBase;
 typedef Game GobGameBase;
 
 /// GOB class adventure game
 class GobGame : public  GobGameBase
 {
+  //  std::map<std::string, std::list<SpaceLocation*> > _galaxy;
 
-  std::map<std::string, std::list<SpaceLocation*> > _galaxy;
-
  public:
+  StarMap _galaxy;
   GobPlayer gobplayer;
 
   /// move player to system

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/melee/mframe.h	2005-03-08 14:45:30 UTC (rev 135)
@@ -20,6 +20,9 @@
 #include <list>
 #include <vector>
 
+#include "melee.h"
+#include "util/vector2.h"
+
 //debuging purposes only:
 extern int total_presences;
 

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/melee/mgame.cpp	2005-03-08 14:45:30 UTC (rev 135)
@@ -79,6 +79,13 @@
   xpl1Sprite = new SpaceSprite(&melee[MELEE_XPL1], XPL1_FRAMES,
 			       SpaceSprite::ALPHA | SpaceSprite::MASKED | 
 			       SpaceSprite::MIPMAPED);
+
+  _star = new SpaceSprite(&melee[MELEE_STAR], 1, 
+			  SpaceSprite::ALPHA | 
+			  SpaceSprite::MASKED | 
+			  SpaceSprite::IRREGULAR | 
+			  SpaceSprite::MIPMAPED
+			  );
   unload_datafile(melee);
 }
 
@@ -117,6 +124,10 @@
     {
       delete xpl1Sprite;
     }
+  if(_star)
+    {
+      delete _star;
+    }
 }
 
 

Modified: trunk/source/melee/mgame.h
===================================================================
--- trunk/source/melee/mgame.h	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/melee/mgame.h	2005-03-08 14:45:30 UTC (rev 135)
@@ -60,7 +60,7 @@
   SpaceSprite *kaboomSprite;
   SpaceSprite *panelSprite;
   SpaceSprite *xpl1Sprite;
-  
+  SpaceSprite *_star;
 };
 
 enum GameStateCode

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/melee/msprite.cpp	2005-03-08 14:45:30 UTC (rev 135)
@@ -1045,10 +1045,21 @@
 void SpaceSprite::draw(int x, int y, int index, BITMAP *surface) 
 {
   STACKTRACE;
-  draw(Vector2(x,y), Vector2(b[0][index]->w, b[0][index]->h), index, surface);
+  draw(Vector2(x,y), index, surface);
   return;
 }
 
+void SpaceSprite::draw(Vector2 pos, int index, BITMAP *surface)
+{
+  draw(pos, Vector2(b[0][index]->w, b[0][index]->h), index, surface);
+}
+
+void SpaceSprite::draw_centre(Vector2 pos, int index, BITMAP *surface)
+{
+  Vector2 correction = Vector2(b[0][index]->w/2, b[0][index]->h/2);
+  draw(pos - correction, index, surface);
+}
+
 void SpaceSprite::animate(Vector2 pos, int index, Frame *space, double scale) 
 {
   STACKTRACE;

Modified: trunk/source/melee/mview.h
===================================================================
--- trunk/source/melee/mview.h	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/melee/mview.h	2005-03-08 14:45:30 UTC (rev 135)
@@ -84,6 +84,7 @@
 View *get_view( const char *name, View *match ) ;
 int get_view_num ( const char * name );
 
+/// Visible area
 class View : public BaseClass {
 	public:
 	ViewType *type;

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/melee.h	2005-03-08 14:45:30 UTC (rev 135)
@@ -430,6 +430,7 @@
 void animate_bmp(BITMAP *bmp, Vector2 pos, Frame *space);
 
 
+/// Sprite 
 class SpaceSprite 
 {
  public:
@@ -466,7 +467,7 @@
     
     NONE = 0
   };
-  //sprite_count * rotation new images based upon sprite_count RLE_SPRITES, with gamma correction
+  ///sprite_count * rotation new images based upon sprite_count RLE_SPRITES, with gamma correction
   SpaceSprite(const DATAFILE *sprites, int sprite_count, int attributes = -1, int rotations = 1);
   SpaceSprite(BITMAP *image, int _attributes = -1);
   SpaceSprite(SpaceSprite &old);
@@ -487,10 +488,18 @@
   
   void overlay ( int index1, int index2, Surface *dest);
 
+  /// Draw sprite to frame
   void draw(Vector2 pos, Vector2 size, int index, Frame *frame) ;
+  /// Draw sprite to screen
   void draw(Vector2 pos, Vector2 size, int index, Surface *bmp) ;
+  /// Draw sprite to screen
+  void draw(Vector2 pos, int index, BITMAP *surface);
+  /// Draw sprite to screen
   void draw(int x, int y, int index, Surface *bmp) ;
 
+  /// Draw sprite to screen 
+  void draw_centre(Vector2 pos, int index, BITMAP *surface);
+  
   // added GEO
   virtual void animate(Vector2 pos, int index, Frame *space, double scale = 1);
   void animate_character(Vector2 pos, int index, int color, Frame *space, double scale = 1);

Modified: trunk/source/other/configrw.cpp
===================================================================
--- trunk/source/other/configrw.cpp	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/other/configrw.cpp	2005-03-08 14:45:30 UTC (rev 135)
@@ -1,7 +1,6 @@
-/* $Id: configrw.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/other/orbit.cpp
===================================================================
--- trunk/source/other/orbit.cpp	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/other/orbit.cpp	2005-03-08 14:45:30 UTC (rev 135)
@@ -1,7 +1,6 @@
-/* $Id: orbit.cpp,v 1.1.1.1 2004/08/01 10:21:23 Yura Exp $ */ 
 /*
 This file is part of "TW-Light" 
-                    http://timewarp.sourceforge.net/
+                    http://tw-light.berlios.de/
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Added: trunk/source/other/starmap.cpp
===================================================================
--- trunk/source/other/starmap.cpp	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/other/starmap.cpp	2005-03-08 14:45:30 UTC (rev 135)
@@ -0,0 +1,237 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include <allegro.h>
+
+#include "melee.h"
+#include "frame.h"
+#include "melee/mgame.h"
+#include "melee/mview.h"
+#include "starmap.h"
+
+#include <sstream>
+
+StarSystem::StarSystem(const std::string& name, Vector2 pos)
+  :
+  _pos(pos),
+  _name(name)
+{
+  STACKTRACE;
+}
+
+StarSystem::~StarSystem()
+{
+  STACKTRACE;
+}
+
+void StarSystem::add(SpaceLocation* l)
+{
+  STACKTRACE;
+  _item.remove(l);
+  _item.push_back(l);
+}
+
+std::string StarSystem::getName() const
+{
+  STACKTRACE;
+  return _name;
+}
+std::list<SpaceLocation*> StarSystem::getItem() const
+{
+  STACKTRACE;
+  return _item;
+}
+
+Vector2 StarSystem::pos()
+{
+  STACKTRACE;
+  return _pos;
+}
+
+StarMap::StarMap()
+{
+  STACKTRACE;
+  _selectedStar = NULL;
+  _targetStar = NULL;
+}
+
+StarMap::~StarMap()
+{
+  STACKTRACE;
+}
+
+void StarMap::add(StarSystem* s)
+{
+  STACKTRACE;
+  _stars.remove(s);
+  _stars.push_back(s);
+}
+
+void StarMap::redraw()
+{
+  STACKTRACE;
+  scare_mouse();
+
+  BITMAP* starmap = create_bitmap(game->view->frame->window->w,
+				  game->view->frame->window->h);   
+ 
+  BITMAP* starArea = create_sub_bitmap(starmap, 0, 0,  starmap->w, starmap->h-100);
+  BITMAP* textArea = create_sub_bitmap(starmap, 0, starmap->h-100, starmap->w, 100);
+
+
+  clear_to_color(starArea, makecol(256/3, 0, 0));
+
+  for(std::list<StarSystem*>::iterator i = _stars.begin(); i!= _stars.end(); i++)
+    {
+      Vector2 pos = (*i)->pos();
+      game->meleedata._star->draw_centre(pos, 0, starArea);
+      int color = palette_color[15];
+      if(*i == _playerStar)
+	{
+	  color = palette_color[1];
+	}
+      else if(*i == _targetStar)
+	{
+	  color = palette_color[8];
+	}
+      textout_centre(starArea, font, ((*i)->getName()).c_str(), (int)pos.x, (int)pos.y-15, color);
+    }
+  
+  // Draw path to target star
+  if(_targetStar)
+    {
+      line(starArea, 
+	   (int)_playerStar->pos().x, (int)_playerStar->pos().y, 
+	   (int)_targetStar->pos().x, (int)_targetStar->pos().y, 
+	   palette_color[15]);
+    }
+
+  // Draw help text
+  if(_targetStar)
+    {
+      std::ostringstream st;
+      st<<"Jump to "<<_targetStar->getName()<<" distance: "<< (_targetStar->pos()-_playerStar->pos()).abs();
+      st<<" Press 'j' to jump ";
+      _text = st.str();
+    }
+  else if(_selectedStar)
+    {
+      std::ostringstream st;
+      st<<_selectedStar->getName()<<" distance: "<< (_selectedStar->pos()-_playerStar->pos()).abs();
+      _text = st.str();
+    }
+  else
+    {
+      _text = "";
+    }
+  textout_centre(textArea, font, _text.c_str(), textArea->w/2, textArea->h/2, -1);
+
+  blit(starmap, 
+       game->view->frame->window->surface, 
+       0, 0, 
+       game->view->frame->window->x, 
+       game->view->frame->window->y, 
+       starmap->w, starmap->h);
+
+  destroy_bitmap(textArea);
+  destroy_bitmap(starArea);
+  destroy_bitmap(starmap);
+  unscare_mouse();
+}
+
+static bool minRangeToMouseCmp(StarSystem* s1, StarSystem* s2)
+{
+  Vector2 mouse_pos(mouse_x, mouse_y);
+  if( (mouse_pos - s1->pos()).abs() < (mouse_pos - s2->pos()).abs() )
+    {
+      return true;
+    }
+  return false;
+}
+
+StarSystem* StarMap::nearStar()
+{
+  Vector2 mouse_pos(mouse_x, mouse_y);
+  std::list<StarSystem*>::iterator i = std::min_element(_stars.begin(), _stars.end(), minRangeToMouseCmp);
+  if(i!= _stars.end())
+    {
+      if((mouse_pos - (*i)->pos()).abs()<25)
+	{
+	  return *i;
+	}
+    }
+  return NULL;
+}
+
+std::string StarMap::select()
+{
+  STACKTRACE;
+  _text = "";
+  _selectedStar = NULL;
+  game->pause();
+  std::string ret = game->_name;
+  show_mouse(game->view->frame->window->surface);
+  redraw();
+   while(1)
+     {
+       poll_mouse();
+       StarSystem* near = nearStar();
+       if(  _selectedStar != near)
+	 {
+	   _selectedStar = near;
+	   redraw();
+	 }
+       
+       if(_targetStar)
+	 {
+	   if (keypressed())
+	     {
+	       int k = readkey();
+	       if(k>>8 == KEY_J) 
+		 {
+		   ret = _targetStar->getName();
+		   _targetStar = NULL;
+		   break;
+		 }
+	       else if(k>>8 == KEY_ESC) 
+		 {
+		   break;
+		 }
+	     }
+	 }
+       if(mouse_b & 1 && _selectedStar != _playerStar)
+	 {
+	   _targetStar = _selectedStar;
+	   redraw();
+	 }
+       else
+       if (mouse_b & 2)
+	 {
+	   if(_targetStar)
+	     {
+	       _targetStar = NULL;
+	       _selectedStar = NULL;
+	       _text = "";
+	       redraw();
+	     }
+	 }
+     };
+  
+  show_mouse(NULL);
+  game->unpause();
+  return ret;
+}
+

Added: trunk/source/other/starmap.h
===================================================================
--- trunk/source/other/starmap.h	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/source/other/starmap.h	2005-03-08 14:45:30 UTC (rev 135)
@@ -0,0 +1,70 @@
+/*
+This file is part of "TW-Light" 
+                    http://tw-light.berlios.de/
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+
+#ifndef __TW_STARMAP_INCLUDES__
+#define __TW_STARMAP_INCLUDES__
+
+#include "melee/mframe.h"
+
+#include <list>
+#include <string>
+#include <map>
+
+class SpaceLocation;
+
+class StarSystem
+{  
+  /// Star coord
+  Vector2 _pos;
+  /// name
+  std::string _name;
+ public:
+  StarSystem(const std::string& name, Vector2 pos);
+  virtual ~StarSystem();
+
+  /// SpaceObjects in system
+  std::list<SpaceLocation*> _item;
+
+  virtual void add(SpaceLocation* l);
+  std::string getName() const;
+  std::list<SpaceLocation*> getItem() const;
+  Vector2 pos();
+};
+
+class StarMap
+{
+
+  std::string _text;
+  StarSystem* nearStar();
+  StarSystem* _selectedStar;
+  StarSystem* _targetStar;
+ public:
+  StarMap();
+  virtual ~StarMap();
+
+  /// star where player stay
+  StarSystem* _playerStar;
+  /// StarSystem List
+  std::list<StarSystem*> _stars;
+
+  virtual void add(StarSystem* s);
+  virtual void redraw();
+  virtual std::string select();
+};
+
+#endif
+

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-03-07 23:23:00 UTC (rev 134)
+++ trunk/sources.lst	2005-03-08 14:45:30 UTC (rev 135)
@@ -55,6 +55,7 @@
 source/other/planet3d.cpp
 source/other/radar.cpp
 source/other/dialogs.cpp
+source/other/starmap.cpp
 source/ships/shptauar.cpp
 source/ships/shpbogce.cpp
 source/ships/shpaktgu.cpp



From yurand at sheep.berlios.de  Sat Mar 12 20:13:02 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 12 Mar 2005 20:13:02 +0100
Subject: [Tw-light-svn] r136 - in trunk: . gamedata gamedata/python mingw-libs/include mingw-libs/lib source source/games source/generated source/melee source/other source/python source/util
Message-ID: <200503121913.j2CJD2Dw026348@sheep.berlios.de>

Author: yurand
Date: 2005-03-12 20:12:58 +0100 (Sat, 12 Mar 2005)
New Revision: 136

Added:
   trunk/gamedata/python/
   trunk/gamedata/python/ggob.py
   trunk/gamedata/python/start.py
   trunk/mingw-libs/include/Python.h
   trunk/mingw-libs/include/abstract.h
   trunk/mingw-libs/include/bitset.h
   trunk/mingw-libs/include/boolobject.h
   trunk/mingw-libs/include/bufferobject.h
   trunk/mingw-libs/include/cStringIO.h
   trunk/mingw-libs/include/cellobject.h
   trunk/mingw-libs/include/ceval.h
   trunk/mingw-libs/include/classobject.h
   trunk/mingw-libs/include/cobject.h
   trunk/mingw-libs/include/codecs.h
   trunk/mingw-libs/include/compile.h
   trunk/mingw-libs/include/complexobject.h
   trunk/mingw-libs/include/datetime.h
   trunk/mingw-libs/include/descrobject.h
   trunk/mingw-libs/include/dictobject.h
   trunk/mingw-libs/include/enumobject.h
   trunk/mingw-libs/include/errcode.h
   trunk/mingw-libs/include/eval.h
   trunk/mingw-libs/include/fileobject.h
   trunk/mingw-libs/include/floatobject.h
   trunk/mingw-libs/include/frameobject.h
   trunk/mingw-libs/include/funcobject.h
   trunk/mingw-libs/include/genobject.h
   trunk/mingw-libs/include/graminit.h
   trunk/mingw-libs/include/grammar.h
   trunk/mingw-libs/include/import.h
   trunk/mingw-libs/include/intobject.h
   trunk/mingw-libs/include/intrcheck.h
   trunk/mingw-libs/include/iterobject.h
   trunk/mingw-libs/include/listobject.h
   trunk/mingw-libs/include/longintrepr.h
   trunk/mingw-libs/include/longobject.h
   trunk/mingw-libs/include/marshal.h
   trunk/mingw-libs/include/metagrammar.h
   trunk/mingw-libs/include/methodobject.h
   trunk/mingw-libs/include/modsupport.h
   trunk/mingw-libs/include/moduleobject.h
   trunk/mingw-libs/include/node.h
   trunk/mingw-libs/include/object.h
   trunk/mingw-libs/include/objimpl.h
   trunk/mingw-libs/include/opcode.h
   trunk/mingw-libs/include/osdefs.h
   trunk/mingw-libs/include/parsetok.h
   trunk/mingw-libs/include/patchlevel.h
   trunk/mingw-libs/include/pgen.h
   trunk/mingw-libs/include/pgenheaders.h
   trunk/mingw-libs/include/py_curses.h
   trunk/mingw-libs/include/pyconfig.h
   trunk/mingw-libs/include/pydebug.h
   trunk/mingw-libs/include/pyerrors.h
   trunk/mingw-libs/include/pyfpe.h
   trunk/mingw-libs/include/pygetopt.h
   trunk/mingw-libs/include/pymactoolbox.h
   trunk/mingw-libs/include/pymem.h
   trunk/mingw-libs/include/pyport.h
   trunk/mingw-libs/include/pystate.h
   trunk/mingw-libs/include/pystrtod.h
   trunk/mingw-libs/include/pythonrun.h
   trunk/mingw-libs/include/pythread.h
   trunk/mingw-libs/include/rangeobject.h
   trunk/mingw-libs/include/setobject.h
   trunk/mingw-libs/include/sliceobject.h
   trunk/mingw-libs/include/stringobject.h
   trunk/mingw-libs/include/structmember.h
   trunk/mingw-libs/include/structseq.h
   trunk/mingw-libs/include/symtable.h
   trunk/mingw-libs/include/sysmodule.h
   trunk/mingw-libs/include/timefuncs.h
   trunk/mingw-libs/include/token.h
   trunk/mingw-libs/include/traceback.h
   trunk/mingw-libs/include/tupleobject.h
   trunk/mingw-libs/include/ucnhash.h
   trunk/mingw-libs/include/unicodeobject.h
   trunk/mingw-libs/include/weakrefobject.h
   trunk/mingw-libs/include/zconf.h
   trunk/mingw-libs/include/zlib.h
   trunk/mingw-libs/lib/libpython24.a
   trunk/mingw-libs/lib/libz.a
   trunk/python24.dll
   trunk/source/generated/
   trunk/source/generated/ggob.py
   trunk/source/generated/ggob_wrap.cpp
   trunk/source/python/
   trunk/source/python/fileops.cpp
   trunk/source/python/fileops.h
   trunk/source/python/game.cpp
   trunk/source/python/game.h
   trunk/source/python/python_class.cpp
   trunk/source/python/python_class.h
   trunk/source/python/types.h
Removed:
   trunk/gamedata/xml/
   trunk/gamedata/xslt/
Modified:
   trunk/makefile
   trunk/source/games/ggob.cpp
   trunk/source/games/ggob.h
   trunk/source/melee.h
   trunk/source/melee/mframe.cpp
   trunk/source/melee/mframe.h
   trunk/source/melee/mgame.cpp
   trunk/source/melee/mhelpers.cpp
   trunk/source/melee/mitems.cpp
   trunk/source/melee/msprite.cpp
   trunk/source/other/starmap.cpp
   trunk/source/scp.cpp
   trunk/source/util/vector2.h
   trunk/sources.lst
Log:
Python support added


Added: trunk/gamedata/python/ggob.py
===================================================================
--- trunk/gamedata/python/ggob.py	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/gamedata/python/ggob.py	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,380 @@
+# This file was created automatically by SWIG.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _ggob
+
+def _swig_setattr(self,class_type,name,value):
+    if (name == "this"):
+        if isinstance(value, class_type):
+            self.__dict__[name] = value.this
+            if hasattr(value,"thisown"): self.__dict__["thisown"] = value.thisown
+            del value.thisown
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    self.__dict__[name] = value
+
+def _swig_getattr(self,class_type,name):
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class pair(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, pair, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, pair, name)
+    def __repr__(self):
+        return "<C pair instance at %s>" % (self.this,)
+    __swig_setmethods__["id"] = _ggob.pair_id_set
+    __swig_getmethods__["id"] = _ggob.pair_id_get
+    if _newclass:id = property(_ggob.pair_id_get, _ggob.pair_id_set)
+    __swig_setmethods__["value"] = _ggob.pair_value_set
+    __swig_getmethods__["value"] = _ggob.pair_value_get
+    if _newclass:value = property(_ggob.pair_value_get, _ggob.pair_value_set)
+    def __init__(self, *args):
+        _swig_setattr(self, pair, 'this', _ggob.new_pair(*args))
+        _swig_setattr(self, pair, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_pair):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class pairPtr(pair):
+    def __init__(self, this):
+        _swig_setattr(self, pair, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, pair, 'thisown', 0)
+        _swig_setattr(self, pair,self.__class__,pair)
+_ggob.pair_swigregister(pairPtr)
+
+class GobPlayer(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobPlayer, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobPlayer, name)
+    def __repr__(self):
+        return "<C GobPlayer instance at %s>" % (self.this,)
+    def __init__(self, *args):
+        _swig_setattr(self, GobPlayer, 'this', _ggob.new_GobPlayer(*args))
+        _swig_setattr(self, GobPlayer, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobPlayer):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__["ship"] = _ggob.GobPlayer_ship_set
+    __swig_getmethods__["ship"] = _ggob.GobPlayer_ship_get
+    if _newclass:ship = property(_ggob.GobPlayer_ship_get, _ggob.GobPlayer_ship_set)
+    __swig_setmethods__["pair_list"] = _ggob.GobPlayer_pair_list_set
+    __swig_getmethods__["pair_list"] = _ggob.GobPlayer_pair_list_get
+    if _newclass:pair_list = property(_ggob.GobPlayer_pair_list_get, _ggob.GobPlayer_pair_list_set)
+    __swig_setmethods__["num_pairs"] = _ggob.GobPlayer_num_pairs_set
+    __swig_getmethods__["num_pairs"] = _ggob.GobPlayer_num_pairs_get
+    if _newclass:num_pairs = property(_ggob.GobPlayer_num_pairs_get, _ggob.GobPlayer_num_pairs_set)
+    def _add_pair(*args): return _ggob.GobPlayer__add_pair(*args)
+    def _get_pair(*args): return _ggob.GobPlayer__get_pair(*args)
+    def write_pair(*args): return _ggob.GobPlayer_write_pair(*args)
+    def read_pair(*args): return _ggob.GobPlayer_read_pair(*args)
+    __swig_setmethods__["total"] = _ggob.GobPlayer_total_set
+    __swig_getmethods__["total"] = _ggob.GobPlayer_total_get
+    if _newclass:total = property(_ggob.GobPlayer_total_get, _ggob.GobPlayer_total_set)
+    __swig_setmethods__["starbucks"] = _ggob.GobPlayer_starbucks_set
+    __swig_getmethods__["starbucks"] = _ggob.GobPlayer_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobPlayer_starbucks_get, _ggob.GobPlayer_starbucks_set)
+    __swig_setmethods__["buckazoids"] = _ggob.GobPlayer_buckazoids_set
+    __swig_getmethods__["buckazoids"] = _ggob.GobPlayer_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobPlayer_buckazoids_get, _ggob.GobPlayer_buckazoids_set)
+    __swig_setmethods__["kills"] = _ggob.GobPlayer_kills_set
+    __swig_getmethods__["kills"] = _ggob.GobPlayer_kills_get
+    if _newclass:kills = property(_ggob.GobPlayer_kills_get, _ggob.GobPlayer_kills_set)
+    __swig_setmethods__["value_starbucks"] = _ggob.GobPlayer_value_starbucks_set
+    __swig_getmethods__["value_starbucks"] = _ggob.GobPlayer_value_starbucks_get
+    if _newclass:value_starbucks = property(_ggob.GobPlayer_value_starbucks_get, _ggob.GobPlayer_value_starbucks_set)
+    __swig_setmethods__["value_buckazoids"] = _ggob.GobPlayer_value_buckazoids_set
+    __swig_getmethods__["value_buckazoids"] = _ggob.GobPlayer_value_buckazoids_get
+    if _newclass:value_buckazoids = property(_ggob.GobPlayer_value_buckazoids_get, _ggob.GobPlayer_value_buckazoids_set)
+    __swig_setmethods__["team"] = _ggob.GobPlayer_team_set
+    __swig_getmethods__["team"] = _ggob.GobPlayer_team_get
+    if _newclass:team = property(_ggob.GobPlayer_team_get, _ggob.GobPlayer_team_set)
+    def init(*args): return _ggob.GobPlayer_init(*args)
+    def died(*args): return _ggob.GobPlayer_died(*args)
+    def new_ship(*args): return _ggob.GobPlayer_new_ship(*args)
+    def charge(*args): return _ggob.GobPlayer_charge(*args)
+    __swig_setmethods__["upgrade_list"] = _ggob.GobPlayer_upgrade_list_set
+    __swig_getmethods__["upgrade_list"] = _ggob.GobPlayer_upgrade_list_get
+    if _newclass:upgrade_list = property(_ggob.GobPlayer_upgrade_list_get, _ggob.GobPlayer_upgrade_list_set)
+
+class GobPlayerPtr(GobPlayer):
+    def __init__(self, this):
+        _swig_setattr(self, GobPlayer, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobPlayer, 'thisown', 0)
+        _swig_setattr(self, GobPlayer,self.__class__,GobPlayer)
+_ggob.GobPlayer_swigregister(GobPlayerPtr)
+
+class GobEnemy(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobEnemy, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobEnemy, name)
+    def __repr__(self):
+        return "<C GobEnemy instance at %s>" % (self.this,)
+    __swig_setmethods__["ship"] = _ggob.GobEnemy_ship_set
+    __swig_getmethods__["ship"] = _ggob.GobEnemy_ship_get
+    if _newclass:ship = property(_ggob.GobEnemy_ship_get, _ggob.GobEnemy_ship_set)
+    __swig_setmethods__["starbucks"] = _ggob.GobEnemy_starbucks_set
+    __swig_getmethods__["starbucks"] = _ggob.GobEnemy_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobEnemy_starbucks_get, _ggob.GobEnemy_starbucks_set)
+    __swig_setmethods__["buckazoids"] = _ggob.GobEnemy_buckazoids_set
+    __swig_getmethods__["buckazoids"] = _ggob.GobEnemy_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobEnemy_buckazoids_get, _ggob.GobEnemy_buckazoids_set)
+    def init(*args): return _ggob.GobEnemy_init(*args)
+    def died(*args): return _ggob.GobEnemy_died(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobEnemy, 'this', _ggob.new_GobEnemy(*args))
+        _swig_setattr(self, GobEnemy, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobEnemy):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobEnemyPtr(GobEnemy):
+    def __init__(self, this):
+        _swig_setattr(self, GobEnemy, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobEnemy, 'thisown', 0)
+        _swig_setattr(self, GobEnemy,self.__class__,GobEnemy)
+_ggob.GobEnemy_swigregister(GobEnemyPtr)
+
+class GobAsteroid(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobAsteroid, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobAsteroid, name)
+    def __repr__(self):
+        return "<C GobAsteroid instance at %s>" % (self.this,)
+    def handle_damage(*args): return _ggob.GobAsteroid_handle_damage(*args)
+    def death(*args): return _ggob.GobAsteroid_death(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobAsteroid, 'this', _ggob.new_GobAsteroid(*args))
+        _swig_setattr(self, GobAsteroid, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobAsteroid):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobAsteroidPtr(GobAsteroid):
+    def __init__(self, this):
+        _swig_setattr(self, GobAsteroid, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobAsteroid, 'thisown', 0)
+        _swig_setattr(self, GobAsteroid,self.__class__,GobAsteroid)
+_ggob.GobAsteroid_swigregister(GobAsteroidPtr)
+
+class GobGame(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobGame, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobGame, name)
+    def __repr__(self):
+        return "<C GobGame instance at %s>" % (self.this,)
+    __swig_setmethods__["_galaxy"] = _ggob.GobGame__galaxy_set
+    __swig_getmethods__["_galaxy"] = _ggob.GobGame__galaxy_get
+    if _newclass:_galaxy = property(_ggob.GobGame__galaxy_get, _ggob.GobGame__galaxy_set)
+    __swig_setmethods__["gobplayer"] = _ggob.GobGame_gobplayer_set
+    __swig_getmethods__["gobplayer"] = _ggob.GobGame_gobplayer_get
+    if _newclass:gobplayer = property(_ggob.GobGame_gobplayer_get, _ggob.GobGame_gobplayer_set)
+    def switch_system(*args): return _ggob.GobGame_switch_system(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobGame, 'this', _ggob.new_GobGame(*args))
+        _swig_setattr(self, GobGame, 'thisown', 1)
+    __swig_getmethods__["get_this"] = lambda x: _ggob.GobGame_get_this
+    if _newclass:get_this = staticmethod(_ggob.GobGame_get_this)
+    def __del__(self, destroy=_ggob.delete_GobGame):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__["_player_panel"] = _ggob.GobGame__player_panel_set
+    __swig_getmethods__["_player_panel"] = _ggob.GobGame__player_panel_get
+    if _newclass:_player_panel = property(_ggob.GobGame__player_panel_get, _ggob.GobGame__player_panel_set)
+    __swig_setmethods__["_player_control"] = _ggob.GobGame__player_control_set
+    __swig_getmethods__["_player_control"] = _ggob.GobGame__player_control_get
+    if _newclass:_player_control = property(_ggob.GobGame__player_control_get, _ggob.GobGame__player_control_set)
+    __swig_setmethods__["enemy_team"] = _ggob.GobGame_enemy_team_set
+    __swig_getmethods__["enemy_team"] = _ggob.GobGame_enemy_team_get
+    if _newclass:enemy_team = property(_ggob.GobGame_enemy_team_get, _ggob.GobGame_enemy_team_set)
+    def AddPanel(*args): return _ggob.GobGame_AddPanel(*args)
+    def calculate(*args): return _ggob.GobGame_calculate(*args)
+    def setGameDone(*args): return _ggob.GobGame_setGameDone(*args)
+    def ship_died(*args): return _ggob.GobGame_ship_died(*args)
+    def preinit(*args): return _ggob.GobGame_preinit(*args)
+    def init(*args): return _ggob.GobGame_init(*args)
+    def play_sound(*args): return _ggob.GobGame_play_sound(*args)
+    def add_gobplayer(*args): return _ggob.GobGame_add_gobplayer(*args)
+    def get_player(*args): return _ggob.GobGame_get_player(*args)
+    __swig_setmethods__["gobenemies"] = _ggob.GobGame_gobenemies_set
+    __swig_getmethods__["gobenemies"] = _ggob.GobGame_gobenemies_get
+    if _newclass:gobenemies = property(_ggob.GobGame_gobenemies_get, _ggob.GobGame_gobenemies_set)
+    __swig_setmethods__["max_enemies"] = _ggob.GobGame_max_enemies_set
+    __swig_getmethods__["max_enemies"] = _ggob.GobGame_max_enemies_get
+    if _newclass:max_enemies = property(_ggob.GobGame_max_enemies_get, _ggob.GobGame_max_enemies_set)
+    __swig_setmethods__["gobenemy"] = _ggob.GobGame_gobenemy_set
+    __swig_getmethods__["gobenemy"] = _ggob.GobGame_gobenemy_get
+    if _newclass:gobenemy = property(_ggob.GobGame_gobenemy_get, _ggob.GobGame_gobenemy_set)
+    def get_enemy_index(*args): return _ggob.GobGame_get_enemy_index(*args)
+    def prepare(*args): return _ggob.GobGame_prepare(*args)
+    def fps(*args): return _ggob.GobGame_fps(*args)
+    def add_new_enemy(*args): return _ggob.GobGame_add_new_enemy(*args)
+    def add_stars(*args): return _ggob.GobGame_add_stars(*args)
+    def add_asteroid(*args): return _ggob.GobGame_add_asteroid(*args)
+    def add_system(*args): return _ggob.GobGame_add_system(*args)
+    def add_player(*args): return _ggob.GobGame_add_player(*args)
+    __swig_setmethods__["next_add_new_enemy_time"] = _ggob.GobGame_next_add_new_enemy_time_set
+    __swig_getmethods__["next_add_new_enemy_time"] = _ggob.GobGame_next_add_new_enemy_time_get
+    if _newclass:next_add_new_enemy_time = property(_ggob.GobGame_next_add_new_enemy_time_get, _ggob.GobGame_next_add_new_enemy_time_set)
+    __swig_setmethods__["defenderSprite"] = _ggob.GobGame_defenderSprite_set
+    __swig_getmethods__["defenderSprite"] = _ggob.GobGame_defenderSprite_get
+    if _newclass:defenderSprite = property(_ggob.GobGame_defenderSprite_get, _ggob.GobGame_defenderSprite_set)
+    __swig_setmethods__["num_planets"] = _ggob.GobGame_num_planets_set
+    __swig_getmethods__["num_planets"] = _ggob.GobGame_num_planets_get
+    if _newclass:num_planets = property(_ggob.GobGame_num_planets_get, _ggob.GobGame_num_planets_set)
+    __swig_setmethods__["planet"] = _ggob.GobGame_planet_set
+    __swig_getmethods__["planet"] = _ggob.GobGame_planet_get
+    if _newclass:planet = property(_ggob.GobGame_planet_get, _ggob.GobGame_planet_set)
+    __swig_setmethods__["station"] = _ggob.GobGame_station_set
+    __swig_getmethods__["station"] = _ggob.GobGame_station_get
+    if _newclass:station = property(_ggob.GobGame_station_get, _ggob.GobGame_station_set)
+    def add_planet_and_station(*args): return _ggob.GobGame_add_planet_and_station(*args)
+
+class GobGamePtr(GobGame):
+    def __init__(self, this):
+        _swig_setattr(self, GobGame, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobGame, 'thisown', 0)
+        _swig_setattr(self, GobGame,self.__class__,GobGame)
+_ggob.GobGame_swigregister(GobGamePtr)
+
+GobGame_get_this = _ggob.GobGame_get_this
+
+class GobStation(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobStation, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobStation, name)
+    def __repr__(self):
+        return "<C GobStation instance at %s>" % (self.this,)
+    __swig_setmethods__["_build_type"] = _ggob.GobStation__build_type_set
+    __swig_getmethods__["_build_type"] = _ggob.GobStation__build_type_get
+    if _newclass:_build_type = property(_ggob.GobStation__build_type_get, _ggob.GobStation__build_type_set)
+    __swig_setmethods__["_background_pic"] = _ggob.GobStation__background_pic_set
+    __swig_getmethods__["_background_pic"] = _ggob.GobStation__background_pic_get
+    if _newclass:_background_pic = property(_ggob.GobStation__background_pic_get, _ggob.GobStation__background_pic_set)
+    def __init__(self, *args):
+        _swig_setattr(self, GobStation, 'this', _ggob.new_GobStation(*args))
+        _swig_setattr(self, GobStation, 'thisown', 1)
+    def buy_new_ship_menu(*args): return _ggob.GobStation_buy_new_ship_menu(*args)
+    def inflict_damage(*args): return _ggob.GobStation_inflict_damage(*args)
+    def station_screen(*args): return _ggob.GobStation_station_screen(*args)
+    def upgrade_menu(*args): return _ggob.GobStation_upgrade_menu(*args)
+    def __del__(self, destroy=_ggob.delete_GobStation):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobStationPtr(GobStation):
+    def __init__(self, this):
+        _swig_setattr(self, GobStation, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobStation, 'thisown', 0)
+        _swig_setattr(self, GobStation,self.__class__,GobStation)
+_ggob.GobStation_swigregister(GobStationPtr)
+
+class Upgrade(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, Upgrade, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, Upgrade, name)
+    def __init__(self): raise RuntimeError, "No constructor defined"
+    def __repr__(self):
+        return "<C Upgrade instance at %s>" % (self.this,)
+    active = _ggob.Upgrade_active
+    inactive = _ggob.Upgrade_inactive
+    __swig_setmethods__["name"] = _ggob.Upgrade_name_set
+    __swig_getmethods__["name"] = _ggob.Upgrade_name_get
+    if _newclass:name = property(_ggob.Upgrade_name_get, _ggob.Upgrade_name_set)
+    __swig_setmethods__["starbucks"] = _ggob.Upgrade_starbucks_set
+    __swig_getmethods__["starbucks"] = _ggob.Upgrade_starbucks_get
+    if _newclass:starbucks = property(_ggob.Upgrade_starbucks_get, _ggob.Upgrade_starbucks_set)
+    __swig_setmethods__["buckazoids"] = _ggob.Upgrade_buckazoids_set
+    __swig_getmethods__["buckazoids"] = _ggob.Upgrade_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.Upgrade_buckazoids_get, _ggob.Upgrade_buckazoids_set)
+    __swig_setmethods__["status"] = _ggob.Upgrade_status_set
+    __swig_getmethods__["status"] = _ggob.Upgrade_status_get
+    if _newclass:status = property(_ggob.Upgrade_status_get, _ggob.Upgrade_status_set)
+    __swig_setmethods__["num"] = _ggob.Upgrade_num_set
+    __swig_getmethods__["num"] = _ggob.Upgrade_num_get
+    if _newclass:num = property(_ggob.Upgrade_num_get, _ggob.Upgrade_num_set)
+    __swig_setmethods__["index"] = _ggob.Upgrade_index_set
+    __swig_getmethods__["index"] = _ggob.Upgrade_index_get
+    if _newclass:index = property(_ggob.Upgrade_index_get, _ggob.Upgrade_index_set)
+    def update(*args): return _ggob.Upgrade_update(*args)
+    def execute(*args): return _ggob.Upgrade_execute(*args)
+    def charge(*args): return _ggob.Upgrade_charge(*args)
+    def clear(*args): return _ggob.Upgrade_clear(*args)
+    def duplicate(*args): return _ggob.Upgrade_duplicate(*args)
+    def __del__(self, destroy=_ggob.delete_Upgrade):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class UpgradePtr(Upgrade):
+    def __init__(self, this):
+        _swig_setattr(self, Upgrade, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, Upgrade, 'thisown', 0)
+        _swig_setattr(self, Upgrade,self.__class__,Upgrade)
+_ggob.Upgrade_swigregister(UpgradePtr)
+
+class RainbowRift(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, RainbowRift, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, RainbowRift, name)
+    def __repr__(self):
+        return "<C RainbowRift instance at %s>" % (self.this,)
+    n = _ggob.RainbowRift_n
+    __swig_setmethods__["p"] = _ggob.RainbowRift_p_set
+    __swig_getmethods__["p"] = _ggob.RainbowRift_p_get
+    if _newclass:p = property(_ggob.RainbowRift_p_get, _ggob.RainbowRift_p_set)
+    __swig_setmethods__["c"] = _ggob.RainbowRift_c_set
+    __swig_getmethods__["c"] = _ggob.RainbowRift_c_get
+    if _newclass:c = property(_ggob.RainbowRift_c_get, _ggob.RainbowRift_c_set)
+    __swig_setmethods__["next_time"] = _ggob.RainbowRift_next_time_set
+    __swig_getmethods__["next_time"] = _ggob.RainbowRift_next_time_get
+    if _newclass:next_time = property(_ggob.RainbowRift_next_time_get, _ggob.RainbowRift_next_time_set)
+    __swig_setmethods__["next_time2"] = _ggob.RainbowRift_next_time2_set
+    __swig_getmethods__["next_time2"] = _ggob.RainbowRift_next_time2_get
+    if _newclass:next_time2 = property(_ggob.RainbowRift_next_time2_get, _ggob.RainbowRift_next_time2_set)
+    def __init__(self, *args):
+        _swig_setattr(self, RainbowRift, 'this', _ggob.new_RainbowRift(*args))
+        _swig_setattr(self, RainbowRift, 'thisown', 1)
+    def animate(*args): return _ggob.RainbowRift_animate(*args)
+    def calculate(*args): return _ggob.RainbowRift_calculate(*args)
+    def squiggle(*args): return _ggob.RainbowRift_squiggle(*args)
+    def __del__(self, destroy=_ggob.delete_RainbowRift):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class RainbowRiftPtr(RainbowRift):
+    def __init__(self, this):
+        _swig_setattr(self, RainbowRift, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, RainbowRift, 'thisown', 0)
+        _swig_setattr(self, RainbowRift,self.__class__,RainbowRift)
+_ggob.RainbowRift_swigregister(RainbowRiftPtr)
+
+

Added: trunk/gamedata/python/start.py
===================================================================
--- trunk/gamedata/python/start.py	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/gamedata/python/start.py	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,34 @@
+import ggob
+
+game = ggob.GobGame.get_this()
+
+# System Arix
+game.add_system('Arix', 50, 50)
+game.prepare()
+
+game.add_planet_and_station(0, 'gob.dat', 'station0sprite', 'gob.dat#station0picture.bmp', 'supbl')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'orzne')
+game.add_planet_and_station(2, 'gob.dat', 'station2sprite', 'gob.dat#station2picture.bmp', 'kohma')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'utwju')
+
+game.add_new_enemy()
+
+for i in xrange(10):
+    game.add_asteroid()
+
+# System Beta
+game.add_system('Beta', 100, 100)
+game.prepare()
+
+game.add_stars()
+game.add_planet_and_station(0, 'gob.dat', 'station0sprite', 'gob.dat#station0picture.bmp', 'supbl')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'orzne')
+game.add_planet_and_station(2, 'gob.dat', 'station2sprite', 'gob.dat#station2picture.bmp', 'kohma')
+game.add_planet_and_station(1, 'gob.dat', 'station1sprite', 'gob.dat#station1picture.bmp', 'utwju')
+
+game.add_new_enemy()
+
+for i in xrange(10):
+    game.add_asteroid()
+
+game.add_player('Arix', 12400, 12400)

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/makefile	2005-03-12 19:12:58 UTC (rev 136)
@@ -55,7 +55,8 @@
 ifdef debug
 DATAPATH=gamedata
 else
-DATAPATH=/usr/local/share/games/tw-light
+#DATAPATH=/usr/local/share/games/tw-light
+DATAPATH=gamedata
 endif
 endif
 endif
@@ -80,11 +81,10 @@
         source/other source/ships source/sc1ships source/sc2ships \
         source/util source/libraries/alogg \
         source/libraries/jpgalleg source/libraries/jgmod source/libraries/cppunit \
-        source/libraries/raknet \
-        source/libraries/lua source/libraries/lua/lib 
+        source/libraries/raknet source/python source/generated 
 
 #FILELIST := ${shell find source -type f "(" -name "*.c" -o -name "*.cpp" ")"}
-FILELIST= ${shell cat sources.lst}
+FILELIST= ${shell cat sources.lst} 
 
 BASE_NAMES = $(basename $(notdir $(FILELIST)))
 POBJS = $(addsuffix .o,$(BASE_NAMES))
@@ -116,18 +116,18 @@
 	OBJDIR := ${addsuffix -win32,$(OBJDIR)}
 	NAME := ${addsuffix .exe,$(NAME)}
 	CFLAGS += -DWIN32 -I mingw-libs/include -I mingw-libs/include/SDL 
-	LIBS += -L mingw-libs/lib -lalleg -lwinmm -lws2_32 -lSDL -lSDLmain 
+	LIBS += -L mingw-libs/lib -lalleg -lwinmm -lws2_32 -lSDL -lSDLmain -lpython24 -lz 
 else
 	TIMESTAMP = ${shell LC_TIME="POSIX" date +%c}
 	EXPDIR=tw-light-$(PRODUCTVERSION)r$(SVNVERSION)
 	CFLAGS += -DLINUX
-	INCLUDES := ${shell allegro-config --cflags} ${shell sdl-config --cflags} ${shell xslt-config --cflags} ${shell xmlwrapp-config --cflags} 
+	INCLUDES := ${shell allegro-config --cflags} ${shell sdl-config --cflags} 
 	CFLAGS += $(INCLUDES)
-	LIBS_CONFIG := ${shell allegro-config --libs} -pthread ${shell sdl-config --libs} ${shell xslt-config --libs}  ${shell xmlwrapp-config --libs} 
-	LIBS += $(LIBS_CONFIG)
+	LIBS_CONFIG := ${shell allegro-config --libs} -pthread ${shell sdl-config --libs} ${shell python-config} 
+	LIBS += $(LIBS_CONFIG) -lc -lXt -L/usr/X11R6/lib -lX11 -lm -lz
 endif
 
-CFLAGS += -I./source -I./source/libraries -I./source/libraries/lua
+CFLAGS += -I./source -I./source/libraries -I/usr/include/python2.3
 
 ifdef TEST
 
@@ -169,6 +169,12 @@
 	$(LD) $(CFLAGS) $(SUBSYSTEM) -o $@ $(OBJDIR)/*.o $(LIBS) 
 	./$(NAME) -test
 
+
+source/generated/ggob_wrap.cpp: source/games/ggob.i source/games/ggob.h
+	swig -c++ -python -o source/generated/ggob_wrap.cpp source/games/ggob.i
+	cp source/generated/ggob.py $(DATAPATH)/python/
+
+
 $(OBJDIR)/%.o: %.cpp
 	$(CX) -MMD $(CFLAGS) -c $< -o $@
 
@@ -178,6 +184,7 @@
 $(OBJDIR)/winicon.o: tw-light.rc tw-light.ico
 	$(RC) tw-light.rc -o $(OBJDIR)/winicon.o
 
+
 clean:
 	$(RM) $(OBJDIR)/*.o
 	$(RM) $(OBJDIR)/*.d

Added: trunk/mingw-libs/include/Python.h
===================================================================
--- trunk/mingw-libs/include/Python.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/Python.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,171 @@
+#ifndef Py_PYTHON_H
+#define Py_PYTHON_H
+/* Since this is a "meta-include" file, no #ifdef __cplusplus / extern "C" { */
+
+/* Include nearly all Python header files */
+
+#include "patchlevel.h"
+#include "pyconfig.h"
+
+/* Cyclic gc is always enabled, starting with release 2.3a1.  Supply the
+ * old symbol for the benefit of extension modules written before then
+ * that may be conditionalizing on it.  The core doesn't use it anymore.
+ */
+#ifndef WITH_CYCLE_GC
+#define WITH_CYCLE_GC 1
+#endif
+
+#include <limits.h>
+
+#ifndef UCHAR_MAX
+#error "Something's broken.  UCHAR_MAX should be defined in limits.h."
+#endif
+
+#if UCHAR_MAX != 255
+#error "Python's source code assumes C's unsigned char is an 8-bit type."
+#endif
+
+#if defined(__sgi) && defined(WITH_THREAD) && !defined(_SGI_MP_SOURCE)
+#define _SGI_MP_SOURCE
+#endif
+
+#include <stdio.h>
+#ifndef NULL
+#   error "Python.h requires that stdio.h define NULL."
+#endif
+
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+/* For uintptr_t, intptr_t */
+#ifdef HAVE_STDDEF_H
+#include <stddef.h>
+#endif
+
+/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
+ * compiler command line when building Python in release mode; else
+ * assert() calls won't be removed.
+ */
+#include <assert.h>
+
+#include "pyport.h"
+
+/* pyconfig.h or pyport.h may or may not define DL_IMPORT */
+#ifndef DL_IMPORT	/* declarations for DLL import/export */
+#define DL_IMPORT(RTYPE) RTYPE
+#endif
+#ifndef DL_EXPORT	/* declarations for DLL import/export */
+#define DL_EXPORT(RTYPE) RTYPE
+#endif
+
+/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.
+ *  PYMALLOC_DEBUG is in error if pymalloc is not in use.
+ */
+#if defined(Py_DEBUG) && defined(WITH_PYMALLOC) && !defined(PYMALLOC_DEBUG)
+#define PYMALLOC_DEBUG
+#endif
+#if defined(PYMALLOC_DEBUG) && !defined(WITH_PYMALLOC)
+#error "PYMALLOC_DEBUG requires WITH_PYMALLOC"
+#endif
+#include "pymem.h"
+
+#include "object.h"
+#include "objimpl.h"
+
+#include "pydebug.h"
+
+#include "unicodeobject.h"
+#include "intobject.h"
+#include "boolobject.h"
+#include "longobject.h"
+#include "floatobject.h"
+#ifndef WITHOUT_COMPLEX
+#include "complexobject.h"
+#endif
+#include "rangeobject.h"
+#include "stringobject.h"
+#include "bufferobject.h"
+#include "tupleobject.h"
+#include "listobject.h"
+#include "dictobject.h"
+#include "enumobject.h"
+#include "setobject.h"
+#include "methodobject.h"
+#include "moduleobject.h"
+#include "funcobject.h"
+#include "classobject.h"
+#include "fileobject.h"
+#include "cobject.h"
+#include "traceback.h"
+#include "sliceobject.h"
+#include "cellobject.h"
+#include "iterobject.h"
+#include "genobject.h"
+#include "descrobject.h"
+#include "weakrefobject.h"
+
+#include "codecs.h"
+#include "pyerrors.h"
+
+#include "pystate.h"
+
+#include "modsupport.h"
+#include "pythonrun.h"
+#include "ceval.h"
+#include "sysmodule.h"
+#include "intrcheck.h"
+#include "import.h"
+
+#include "abstract.h"
+
+#include "compile.h"
+#include "eval.h"
+
+#include "pystrtod.h"
+
+/* _Py_Mangle is defined in compile.c */
+PyAPI_FUNC(int) _Py_Mangle(char *p, char *name, \
+				 char *buffer, size_t maxlen);
+
+/* PyArg_GetInt is deprecated and should not be used, use PyArg_Parse(). */
+#define PyArg_GetInt(v, a)	PyArg_Parse((v), "i", (a))
+
+/* PyArg_NoArgs should not be necessary.
+   Set ml_flags in the PyMethodDef to METH_NOARGS. */
+#define PyArg_NoArgs(v)		PyArg_Parse(v, "")
+
+/* Convert a possibly signed character to a nonnegative int */
+/* XXX This assumes characters are 8 bits wide */
+#ifdef __CHAR_UNSIGNED__
+#define Py_CHARMASK(c)		(c)
+#else
+#define Py_CHARMASK(c)		((c) & 0xff)
+#endif
+
+#include "pyfpe.h"
+
+/* These definitions must match corresponding definitions in graminit.h.
+   There's code in compile.c that checks that they are the same. */
+#define Py_single_input 256
+#define Py_file_input 257
+#define Py_eval_input 258
+
+#ifdef HAVE_PTH
+/* GNU pth user-space thread support */
+#include <pth.h>
+#endif
+
+/* Define macros for inline documentation. */
+#define PyDoc_VAR(name) static char name[]
+#define PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)
+#ifdef WITH_DOC_STRINGS
+#define PyDoc_STR(str) str
+#else
+#define PyDoc_STR(str) ""
+#endif
+
+#endif /* !Py_PYTHON_H */

Added: trunk/mingw-libs/include/abstract.h
===================================================================
--- trunk/mingw-libs/include/abstract.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/abstract.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,1223 @@
+#ifndef Py_ABSTRACTOBJECT_H
+#define Py_ABSTRACTOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Abstract Object Interface (many thanks to Jim Fulton) */
+
+/*
+   PROPOSAL: A Generic Python Object Interface for Python C Modules
+
+Problem
+
+  Python modules written in C that must access Python objects must do
+  so through routines whose interfaces are described by a set of
+  include files.  Unfortunately, these routines vary according to the
+  object accessed.  To use these routines, the C programmer must check
+  the type of the object being used and must call a routine based on
+  the object type.  For example, to access an element of a sequence,
+  the programmer must determine whether the sequence is a list or a
+  tuple:
+
+    if(is_tupleobject(o))
+      e=gettupleitem(o,i)
+    else if(is_listitem(o))
+      e=getlistitem(o,i)
+
+  If the programmer wants to get an item from another type of object
+  that provides sequence behavior, there is no clear way to do it
+  correctly.  
+
+  The persistent programmer may peruse object.h and find that the
+  _typeobject structure provides a means of invoking up to (currently
+  about) 41 special operators.  So, for example, a routine can get an
+  item from any object that provides sequence behavior. However, to
+  use this mechanism, the programmer must make their code dependent on
+  the current Python implementation.
+
+  Also, certain semantics, especially memory management semantics, may
+  differ by the type of object being used.  Unfortunately, these
+  semantics are not clearly described in the current include files.
+  An abstract interface providing more consistent semantics is needed. 
+
+Proposal
+
+  I propose the creation of a standard interface (with an associated
+  library of routines and/or macros) for generically obtaining the
+  services of Python objects.  This proposal can be viewed as one
+  components of a Python C interface consisting of several components.
+
+  From the viewpoint of C access to Python services, we have (as
+  suggested by Guido in off-line discussions):
+
+  - "Very high level layer": two or three functions that let you exec or
+    eval arbitrary Python code given as a string in a module whose name is
+    given, passing C values in and getting C values out using
+    mkvalue/getargs style format strings.  This does not require the user
+    to declare any variables of type "PyObject *".  This should be enough
+    to write a simple application that gets Python code from the user,
+    execs it, and returns the output or errors.  (Error handling must also
+    be part of this API.)
+
+  - "Abstract objects layer": which is the subject of this proposal.
+    It has many functions operating on objects, and lest you do many
+    things from C that you can also write in Python, without going
+    through the Python parser.
+
+  - "Concrete objects layer": This is the public type-dependent
+    interface provided by the standard built-in types, such as floats,
+    strings, and lists.  This interface exists and is currently
+    documented by the collection of include files provided with the
+    Python distributions.
+
+  From the point of view of Python accessing services provided by C
+  modules: 
+
+  - "Python module interface": this interface consist of the basic
+    routines used to define modules and their members.  Most of the
+    current extensions-writing guide deals with this interface.
+
+  - "Built-in object interface": this is the interface that a new
+    built-in type must provide and the mechanisms and rules that a
+    developer of a new built-in type must use and follow.
+
+  This proposal is a "first-cut" that is intended to spur
+  discussion. See especially the lists of notes.
+
+  The Python C object interface will provide four protocols: object,
+  numeric, sequence, and mapping.  Each protocol consists of a
+  collection of related operations.  If an operation that is not
+  provided by a particular type is invoked, then a standard exception,
+  NotImplementedError is raised with a operation name as an argument.
+  In addition, for convenience this interface defines a set of
+  constructors for building objects of built-in types.  This is needed
+  so new objects can be returned from C functions that otherwise treat
+  objects generically.
+
+Memory Management
+
+  For all of the functions described in this proposal, if a function
+  retains a reference to a Python object passed as an argument, then the
+  function will increase the reference count of the object.  It is
+  unnecessary for the caller to increase the reference count of an
+  argument in anticipation of the object's retention.
+
+  All Python objects returned from functions should be treated as new
+  objects.  Functions that return objects assume that the caller will
+  retain a reference and the reference count of the object has already
+  been incremented to account for this fact.  A caller that does not
+  retain a reference to an object that is returned from a function
+  must decrement the reference count of the object (using
+  DECREF(object)) to prevent memory leaks.
+
+  Note that the behavior mentioned here is different from the current
+  behavior for some objects (e.g. lists and tuples) when certain
+  type-specific routines are called directly (e.g. setlistitem).  The
+  proposed abstraction layer will provide a consistent memory
+  management interface, correcting for inconsistent behavior for some
+  built-in types.
+
+Protocols
+
+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/
+
+/*  Object Protocol: */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Print(PyObject *o, FILE *fp, int flags);
+
+         Print an object, o, on file, fp.  Returns -1 on
+	 error.  The flags argument is used to enable certain printing
+	 options. The only option currently supported is Py_Print_RAW. 
+
+         (What should be said about Py_Print_RAW?)	
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_HasAttrString(PyObject *o, char *attr_name);
+
+         Returns 1 if o has the attribute attr_name, and 0 otherwise.
+	 This is equivalent to the Python expression:
+	 hasattr(o,attr_name). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject* PyObject_GetAttrString(PyObject *o, char *attr_name);
+
+	 Retrieve an attributed named attr_name form object o.
+	 Returns the attribute value on success, or NULL on failure.
+	 This is the equivalent of the Python expression: o.attr_name.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_HasAttr(PyObject *o, PyObject *attr_name);
+
+         Returns 1 if o has the attribute attr_name, and 0 otherwise.
+	 This is equivalent to the Python expression:
+	 hasattr(o,attr_name). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);
+
+	 Retrieve an attributed named attr_name form object o.
+	 Returns the attribute value on success, or NULL on failure.
+	 This is the equivalent of the Python expression: o.attr_name.
+
+       */
+
+
+     /* Implemented elsewhere:
+
+     int PyObject_SetAttrString(PyObject *o, char *attr_name, PyObject *v);
+
+	 Set the value of the attribute named attr_name, for object o,
+	 to the value, v. Returns -1 on failure.  This is
+	 the equivalent of the Python statement: o.attr_name=v.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);
+
+	 Set the value of the attribute named attr_name, for object o,
+	 to the value, v. Returns -1 on failure.  This is
+	 the equivalent of the Python statement: o.attr_name=v.
+
+       */
+
+     /* implemented as a macro:
+
+     int PyObject_DelAttrString(PyObject *o, char *attr_name);
+
+	 Delete attribute named attr_name, for object o. Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: del o.attr_name.
+
+       */
+#define  PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A),NULL)
+
+     /* implemented as a macro:
+
+     int PyObject_DelAttr(PyObject *o, PyObject *attr_name);
+
+	 Delete attribute named attr_name, for object o. Returns -1
+	 on failure.  This is the equivalent of the Python
+	 statement: del o.attr_name.
+
+       */
+#define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A),NULL)
+
+     PyAPI_FUNC(int) PyObject_Cmp(PyObject *o1, PyObject *o2, int *result);
+
+       /*
+	 Compare the values of o1 and o2 using a routine provided by
+	 o1, if one exists, otherwise with a routine provided by o2.
+	 The result of the comparison is returned in result.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: result=cmp(o1,o2).
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Compare(PyObject *o1, PyObject *o2);
+
+	 Compare the values of o1 and o2 using a routine provided by
+	 o1, if one exists, otherwise with a routine provided by o2.
+	 Returns the result of the comparison on success.  On error,
+	 the value returned is undefined. This is equivalent to the
+	 Python expression: cmp(o1,o2).
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Repr(PyObject *o);
+
+	 Compute the string representation of object, o.  Returns the
+	 string representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: repr(o).
+
+	 Called by the repr() built-in function and by reverse quotes.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Str(PyObject *o);
+
+	 Compute the string representation of object, o.  Returns the
+	 string representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: str(o).)
+
+	 Called by the str() built-in function and by the print
+	 statement.
+
+       */
+
+     /* Implemented elsewhere:
+
+     PyObject *PyObject_Unicode(PyObject *o);
+
+	 Compute the unicode representation of object, o.  Returns the
+	 unicode representation on success, NULL on failure.  This is
+	 the equivalent of the Python expression: unistr(o).)
+
+	 Called by the unistr() built-in function.
+
+       */
+
+     PyAPI_FUNC(int) PyCallable_Check(PyObject *o);
+
+       /*
+	 Determine if the object, o, is callable.  Return 1 if the
+	 object is callable and 0 otherwise.
+
+	 This function always succeeds.
+
+       */
+
+
+
+     PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable_object,
+					 PyObject *args, PyObject *kw);
+
+       /*
+	 Call a callable Python object, callable_object, with
+	 arguments and keywords arguments.  The 'args' argument can not be
+	 NULL, but the 'kw' argument can be NULL.
+
+       */
+     
+     PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable_object,
+                                               PyObject *args);
+
+       /*
+	 Call a callable Python object, callable_object, with
+	 arguments given by the tuple, args.  If no arguments are
+	 needed, then args may be NULL.  Returns the result of the
+	 call on success, or NULL on failure.  This is the equivalent
+	 of the Python expression: apply(o,args).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable_object,
+                                                 char *format, ...);
+
+       /*
+	 Call a callable Python object, callable_object, with a
+	 variable number of C arguments. The C arguments are described
+	 using a mkvalue-style format string. The format may be NULL,
+	 indicating that no arguments are provided.  Returns the
+	 result of the call on success, or NULL on failure.  This is
+	 the equivalent of the Python expression: apply(o,args).
+
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *o, char *m,
+                                               char *format, ...);
+
+       /*
+	 Call the method named m of object o with a variable number of
+	 C arguments.  The C arguments are described by a mkvalue
+	 format string.  The format may be NULL, indicating that no
+	 arguments are provided. Returns the result of the call on
+	 success, or NULL on failure.  This is the equivalent of the
+	 Python expression: o.method(args).
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
+                                                        ...);
+
+       /*
+	 Call a callable Python object, callable_object, with a
+	 variable number of C arguments.  The C arguments are provided
+	 as PyObject * values, terminated by a NULL.  Returns the
+	 result of the call on success, or NULL on failure.  This is
+	 the equivalent of the Python expression: apply(o,args).
+       */
+
+
+     PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(PyObject *o,
+                                                      PyObject *m, ...);
+
+       /*
+	 Call the method named m of object o with a variable number of
+	 C arguments.  The C arguments are provided as PyObject *
+	 values, terminated by NULL.  Returns the result of the call
+	 on success, or NULL on failure.  This is the equivalent of
+	 the Python expression: o.method(args).
+       */
+
+
+     /* Implemented elsewhere:
+
+     long PyObject_Hash(PyObject *o);
+
+         Compute and return the hash, hash_value, of an object, o.  On
+	 failure, return -1.  This is the equivalent of the Python
+	 expression: hash(o).
+
+       */
+
+
+     /* Implemented elsewhere:
+
+     int PyObject_IsTrue(PyObject *o);
+
+	 Returns 1 if the object, o, is considered to be true, 0 if o is
+	 considered to be false and -1 on failure. This is equivalent to the
+	 Python expression: not not o
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyObject_Not(PyObject *o);
+
+	 Returns 0 if the object, o, is considered to be true, 1 if o is
+	 considered to be false and -1 on failure. This is equivalent to the
+	 Python expression: not o
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
+
+       /*
+	 On success, returns a type object corresponding to the object
+	 type of object o. On failure, returns NULL.  This is
+	 equivalent to the Python expression: type(o).
+       */
+
+     PyAPI_FUNC(int) PyObject_Size(PyObject *o);
+
+       /*
+         Return the size of object o.  If the object, o, provides
+	 both sequence and mapping protocols, the sequence size is
+	 returned. On error, -1 is returned.  This is the equivalent
+	 to the Python expression: len(o).
+
+       */
+
+       /* For DLL compatibility */
+#undef PyObject_Length
+     PyAPI_FUNC(int) PyObject_Length(PyObject *o);
+#define PyObject_Length PyObject_Size
+
+
+     PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
+
+       /*
+	 Return element of o corresponding to the object, key, or NULL
+	 on failure. This is the equivalent of the Python expression:
+	 o[key].
+
+       */
+
+     PyAPI_FUNC(int) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);
+
+       /*
+	 Map the object, key, to the value, v.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[key]=v.
+       */
+
+     PyAPI_FUNC(int) PyObject_DelItemString(PyObject *o, char *key);
+
+       /*
+         Remove the mapping for object, key, from the object *o.
+         Returns -1 on failure.  This is equivalent to
+         the Python statement: del o[key].
+       */
+
+     PyAPI_FUNC(int) PyObject_DelItem(PyObject *o, PyObject *key);
+
+       /*
+	 Delete the mapping for key from *o.  Returns -1 on failure.
+	 This is the equivalent of the Python statement: del o[key].
+       */
+
+     PyAPI_FUNC(int) PyObject_AsCharBuffer(PyObject *obj,
+					  const char **buffer,
+					  int *buffer_len);
+
+       /* 
+	  Takes an arbitrary object which must support the (character,
+	  single segment) buffer interface and returns a pointer to a
+	  read-only memory location useable as character based input
+	  for subsequent processing.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurs. Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+     PyAPI_FUNC(int) PyObject_CheckReadBuffer(PyObject *obj);
+
+      /*  
+	  Checks whether an arbitrary object supports the (character,
+	  single segment) buffer interface.  Returns 1 on success, 0
+	  on failure.
+
+      */
+
+     PyAPI_FUNC(int) PyObject_AsReadBuffer(PyObject *obj,
+					  const void **buffer,
+					  int *buffer_len);
+
+       /* 
+	  Same as PyObject_AsCharBuffer() except that this API expects
+	  (readable, single segment) buffer interface and returns a
+	  pointer to a read-only memory location which can contain
+	  arbitrary data.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurrs.  Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+     PyAPI_FUNC(int) PyObject_AsWriteBuffer(PyObject *obj,
+					   void **buffer,
+					   int *buffer_len);
+
+       /* 
+	  Takes an arbitrary object which must support the (writeable,
+	  single segment) buffer interface and returns a pointer to a
+	  writeable memory location in buffer of size buffer_len.
+
+	  0 is returned on success.  buffer and buffer_len are only
+	  set in case no error occurrs. Otherwise, -1 is returned and
+	  an exception set.
+
+       */
+
+/* Iterators */
+
+     PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
+     /* Takes an object and returns an iterator for it.
+        This is typically a new iterator but if the argument
+	is an iterator, this returns itself. */
+
+#define PyIter_Check(obj) \
+    (PyType_HasFeature((obj)->ob_type, Py_TPFLAGS_HAVE_ITER) && \
+     (obj)->ob_type->tp_iternext != NULL)
+
+     PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
+     /* Takes an iterator object and calls its tp_iternext slot,
+	returning the next value.  If the iterator is exhausted,
+	this returns NULL without setting an exception.
+	NULL with an exception means an error occurred. */
+
+/*  Number Protocol:*/
+
+     PyAPI_FUNC(int) PyNumber_Check(PyObject *o);
+
+       /*
+         Returns 1 if the object, o, provides numeric protocols, and
+	 false otherwise. 
+
+	 This function always succeeds.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of adding o1 and o2, or null on failure.
+	 This is the equivalent of the Python expression: o1+o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of subtracting o2 from o1, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1-o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of multiplying o1 and o2, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1*o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Divide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2, or null on failure.
+	 This is the equivalent of the Python expression: o1/o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving an integral result,
+	 or null on failure.
+	 This is the equivalent of the Python expression: o1//o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving a float result,
+	 or null on failure.
+	 This is the equivalent of the Python expression: o1/o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the remainder of dividing o1 by o2, or null on
+	 failure.  This is the equivalent of the Python expression:
+	 o1%o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
+
+       /*
+	 See the built-in function divmod.  Returns NULL on failure.
+	 This is the equivalent of the Python expression:
+	 divmod(o1,o2).
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
+                                          PyObject *o3);
+
+       /*
+	 See the built-in function pow.  Returns NULL on failure.
+	 This is the equivalent of the Python expression:
+	 pow(o1,o2,o3), where o3 is optional.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
+
+       /*
+	 Returns the negation of o on success, or null on failure.
+	 This is the equivalent of the Python expression: -o.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
+
+       /*
+         Returns the (what?) of o on success, or NULL on failure.
+	 This is the equivalent of the Python expression: +o.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
+
+       /*
+	 Returns the absolute value of o, or null on failure.  This is
+	 the equivalent of the Python expression: abs(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
+
+       /*
+	 Returns the bitwise negation of o on success, or NULL on
+	 failure.  This is the equivalent of the Python expression:
+	 ~o.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of left shifting o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1 << o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of right shifting o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1 >> o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise and of o1 and o2 on success, or
+	 NULL on failure. This is the equivalent of the Python
+	 expression: o1&o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the bitwise exclusive or of o1 by o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1^o2.
+
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise or on o1 and o2 on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: o1|o2.
+
+       */
+
+     /* Implemented elsewhere:
+
+     int PyNumber_Coerce(PyObject **p1, PyObject **p2);
+
+	 This function takes the addresses of two variables of type
+	 PyObject*.
+
+	 If the objects pointed to by *p1 and *p2 have the same type,
+	 increment their reference count and return 0 (success).
+	 If the objects can be converted to a common numeric type,
+	 replace *p1 and *p2 by their converted value (with 'new'
+	 reference counts), and return 0.
+	 If no conversion is possible, or if some other error occurs,
+	 return -1 (failure) and don't increment the reference counts.
+	 The call PyNumber_Coerce(&o1, &o2) is equivalent to the Python
+	 statement o1, o2 = coerce(o1, o2).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Int(PyObject *o);
+
+       /*
+	 Returns the o converted to an integer object on success, or
+	 NULL on failure.  This is the equivalent of the Python
+	 expression: int(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
+
+       /*
+	 Returns the o converted to a long integer object on success,
+	 or NULL on failure.  This is the equivalent of the Python
+	 expression: long(o).
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
+
+       /*
+	 Returns the o converted to a float object on success, or NULL
+	 on failure.  This is the equivalent of the Python expression:
+	 float(o).
+       */
+	 
+/*  In-place variants of (some of) the above number protocol functions */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of adding o2 to o1, possibly in-place, or null
+	 on failure.  This is the equivalent of the Python expression:
+	 o1 += o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of subtracting o2 from o1, possibly in-place or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 -= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of multiplying o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 *= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceDivide(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2, possibly in-place, or null
+	 on failure.  This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
+						       PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving an integral result,
+	 possibly in-place, or null on failure.
+	 This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
+						      PyObject *o2);
+
+       /*
+	 Returns the result of dividing o1 by o2 giving a float result,
+	 possibly in-place, or null on failure.
+	 This is the equivalent of the Python expression:
+	 o1 /= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the remainder of dividing o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 %= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
+     						 PyObject *o3);
+
+       /*
+	 Returns the result of raising o1 to the power of o2, possibly
+	 in-place, or null on failure.  This is the equivalent of the Python
+	 expression: o1 **= o2, or pow(o1, o2, o3) if o3 is present.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of left shifting o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 <<= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of right shifting o1 by o2, possibly in-place or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 >>= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise and of o1 and o2, possibly in-place,
+	 or null on failure. This is the equivalent of the Python
+	 expression: o1 &= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the bitwise exclusive or of o1 by o2, possibly in-place, or
+	 null on failure.  This is the equivalent of the Python expression:
+	 o1 ^= o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
+
+       /*
+	 Returns the result of bitwise or of o1 and o2, possibly in-place,
+	 or null on failure.  This is the equivalent of the Python
+	 expression: o1 |= o2.
+
+       */
+
+
+/*  Sequence protocol:*/
+
+     PyAPI_FUNC(int) PySequence_Check(PyObject *o);
+
+       /*
+         Return 1 if the object provides sequence protocol, and zero
+	 otherwise.  
+
+	 This function always succeeds.
+
+       */
+
+     PyAPI_FUNC(int) PySequence_Size(PyObject *o);
+
+       /*
+         Return the size of sequence object o, or -1 on failure.
+
+       */
+
+       /* For DLL compatibility */
+#undef PySequence_Length
+     PyAPI_FUNC(int) PySequence_Length(PyObject *o);
+#define PySequence_Length PySequence_Size
+
+
+     PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
+
+       /*
+	 Return the concatenation of o1 and o2 on success, and NULL on
+	 failure.   This is the equivalent of the Python
+	 expression: o1+o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, int count);
+
+       /*
+	 Return the result of repeating sequence object o count times,
+	 or NULL on failure.  This is the equivalent of the Python
+	 expression: o1*count.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, int i);
+
+       /*
+	 Return the ith element of o, or NULL on failure. This is the
+	 equivalent of the Python expression: o[i].
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, int i1, int i2);
+
+       /*
+	 Return the slice of sequence object o between i1 and i2, or
+	 NULL on failure. This is the equivalent of the Python
+	 expression: o[i1:i2].
+
+       */
+
+     PyAPI_FUNC(int) PySequence_SetItem(PyObject *o, int i, PyObject *v);
+
+       /*
+	 Assign object v to the ith element of o.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[i]=v.
+
+       */
+
+     PyAPI_FUNC(int) PySequence_DelItem(PyObject *o, int i);
+
+       /*
+	 Delete the ith element of object v.  Returns
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: del o[i].
+       */
+
+     PyAPI_FUNC(int) PySequence_SetSlice(PyObject *o, int i1, int i2,
+                                        PyObject *v);
+
+       /*
+         Assign the sequence object, v, to the slice in sequence
+	 object, o, from i1 to i2.  Returns -1 on failure. This is the
+	 equivalent of the Python statement: o[i1:i2]=v.
+       */
+
+     PyAPI_FUNC(int) PySequence_DelSlice(PyObject *o, int i1, int i2);
+
+       /*
+	 Delete the slice in sequence object, o, from i1 to i2.
+	 Returns -1 on failure. This is the equivalent of the Python
+	 statement: del o[i1:i2].
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
+
+       /*
+	 Returns the sequence, o, as a tuple on success, and NULL on failure.
+	 This is equivalent to the Python expression: tuple(o)
+       */
+
+
+     PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
+       /*
+	 Returns the sequence, o, as a list on success, and NULL on failure.
+	 This is equivalent to the Python expression: list(o)
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
+       /*
+         Returns the sequence, o, as a tuple, unless it's already a
+         tuple or list.  Use PySequence_Fast_GET_ITEM to access the
+         members of this list, and PySequence_Fast_GET_SIZE to get its length.
+
+         Returns NULL on failure.  If the object does not support iteration,
+         raises a TypeError exception with m as the message text.
+       */
+
+#define PySequence_Fast_GET_SIZE(o) \
+	(PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
+       /*
+	 Return the size of o, assuming that o was returned by
+         PySequence_Fast and is not NULL.
+       */
+
+#define PySequence_Fast_GET_ITEM(o, i)\
+     (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
+       /*
+	 Return the ith element of o, assuming that o was returned by
+         PySequence_Fast, and that i is within bounds.
+       */
+
+#define PySequence_ITEM(o, i)\
+	( o->ob_type->tp_as_sequence->sq_item(o, i) )
+       /* Assume tp_as_sequence and sq_item exist and that i does not
+	  need to be corrected for a negative index
+       */     
+
+#define PySequence_Fast_ITEMS(sf) \
+	(PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item \
+			  : ((PyTupleObject *)(sf))->ob_item)
+	/* Return a pointer to the underlying item array for
+           an object retured by PySequence_Fast */
+
+     PyAPI_FUNC(int) PySequence_Count(PyObject *o, PyObject *value);
+
+       /*
+         Return the number of occurrences on value on o, that is,
+	 return the number of keys for which o[key]==value.  On
+	 failure, return -1.  This is equivalent to the Python
+	 expression: o.count(value).
+       */
+
+     PyAPI_FUNC(int) PySequence_Contains(PyObject *seq, PyObject *ob);
+       /*
+         Return -1 if error; 1 if ob in seq; 0 if ob not in seq.
+         Use __contains__ if possible, else _PySequence_IterSearch().
+       */
+
+#define PY_ITERSEARCH_COUNT    1
+#define PY_ITERSEARCH_INDEX    2
+#define PY_ITERSEARCH_CONTAINS 3
+     PyAPI_FUNC(int) _PySequence_IterSearch(PyObject *seq, PyObject *obj,
+     		    int operation);
+	/*
+	  Iterate over seq.  Result depends on the operation:
+	  PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
+	  	error.
+	  PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
+	  	obj in seq; set ValueError and return -1 if none found;
+	  	also return -1 on error.
+	  PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
+	  	error.
+	*/
+
+/* For DLL-level backwards compatibility */
+#undef PySequence_In
+     PyAPI_FUNC(int) PySequence_In(PyObject *o, PyObject *value);
+
+/* For source-level backwards compatibility */
+#define PySequence_In PySequence_Contains
+
+       /*
+	 Determine if o contains value.  If an item in o is equal to
+	 X, return 1, otherwise return 0.  On error, return -1.  This
+	 is equivalent to the Python expression: value in o.
+       */
+
+     PyAPI_FUNC(int) PySequence_Index(PyObject *o, PyObject *value);
+
+       /*
+	 Return the first index for which o[i]=value.  On error,
+	 return -1.    This is equivalent to the Python
+	 expression: o.index(value).
+       */
+
+/* In-place versions of some of the above Sequence functions. */
+
+     PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
+
+       /*
+	 Append o2 to o1, in-place when possible. Return the resulting
+	 object, which could be o1, or NULL on failure.  This is the
+	 equivalent of the Python expression: o1 += o2.
+
+       */
+
+     PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, int count);
+
+       /*
+	 Repeat o1 by count, in-place when possible. Return the resulting
+	 object, which could be o1, or NULL on failure.  This is the
+	 equivalent of the Python expression: o1 *= count.
+
+       */
+
+/*  Mapping protocol:*/
+
+     PyAPI_FUNC(int) PyMapping_Check(PyObject *o);
+
+       /*
+         Return 1 if the object provides mapping protocol, and zero
+	 otherwise.  
+
+	 This function always succeeds.
+       */
+
+     PyAPI_FUNC(int) PyMapping_Size(PyObject *o);
+
+       /*
+         Returns the number of keys in object o on success, and -1 on
+	 failure.  For objects that do not provide sequence protocol,
+	 this is equivalent to the Python expression: len(o).
+       */
+
+       /* For DLL compatibility */
+#undef PyMapping_Length
+     PyAPI_FUNC(int) PyMapping_Length(PyObject *o);
+#define PyMapping_Length PyMapping_Size
+
+
+     /* implemented as a macro:
+
+     int PyMapping_DelItemString(PyObject *o, char *key);
+
+	 Remove the mapping for object, key, from the object *o.
+	 Returns -1 on failure.  This is equivalent to
+	 the Python statement: del o[key].
+       */
+#define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))
+
+     /* implemented as a macro:
+
+     int PyMapping_DelItem(PyObject *o, PyObject *key);
+
+	 Remove the mapping for object, key, from the object *o.
+	 Returns -1 on failure.  This is equivalent to
+	 the Python statement: del o[key].
+       */
+#define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))
+
+     PyAPI_FUNC(int) PyMapping_HasKeyString(PyObject *o, char *key);
+
+       /*
+	 On success, return 1 if the mapping object has the key, key,
+	 and 0 otherwise.  This is equivalent to the Python expression:
+	 o.has_key(key). 
+
+	 This function always succeeds.
+       */
+
+     PyAPI_FUNC(int) PyMapping_HasKey(PyObject *o, PyObject *key);
+
+       /*
+	 Return 1 if the mapping object has the key, key,
+	 and 0 otherwise.  This is equivalent to the Python expression:
+	 o.has_key(key). 
+
+	 This function always succeeds.
+
+       */
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Keys(PyObject *o);
+
+         On success, return a list of the keys in object o.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.keys().
+       */
+#define PyMapping_Keys(O) PyObject_CallMethod(O,"keys",NULL)
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Values(PyObject *o);
+
+         On success, return a list of the values in object o.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.values().
+       */
+#define PyMapping_Values(O) PyObject_CallMethod(O,"values",NULL)
+
+     /* Implemented as macro:
+
+     PyObject *PyMapping_Items(PyObject *o);
+
+         On success, return a list of the items in object o, where
+	 each item is a tuple containing a key-value pair.  On
+	 failure, return NULL. This is equivalent to the Python
+	 expression: o.items().
+
+       */
+#define PyMapping_Items(O) PyObject_CallMethod(O,"items",NULL)
+
+     PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o, char *key);
+
+       /*
+	 Return element of o corresponding to the object, key, or NULL
+	 on failure. This is the equivalent of the Python expression:
+	 o[key].
+       */
+
+     PyAPI_FUNC(int) PyMapping_SetItemString(PyObject *o, char *key,
+                                            PyObject *value);
+
+       /*
+	 Map the object, key, to the value, v.  Returns 
+	 -1 on failure.  This is the equivalent of the Python
+	 statement: o[key]=v.
+      */
+
+
+PyAPI_FUNC(int) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);
+      /* isinstance(object, typeorclass) */
+
+PyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
+      /* issubclass(object, typeorclass) */
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* Py_ABSTRACTOBJECT_H */

Added: trunk/mingw-libs/include/bitset.h
===================================================================
--- trunk/mingw-libs/include/bitset.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/bitset.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,32 @@
+
+#ifndef Py_BITSET_H
+#define Py_BITSET_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Bitset interface */
+
+#define BYTE		char
+
+typedef BYTE *bitset;
+
+bitset newbitset(int nbits);
+void delbitset(bitset bs);
+#define testbit(ss, ibit) (((ss)[BIT2BYTE(ibit)] & BIT2MASK(ibit)) != 0)
+int addbit(bitset bs, int ibit); /* Returns 0 if already set */
+int samebitset(bitset bs1, bitset bs2, int nbits);
+void mergebitset(bitset bs1, bitset bs2, int nbits);
+
+#define BITSPERBYTE	(8*sizeof(BYTE))
+#define NBYTES(nbits)	(((nbits) + BITSPERBYTE - 1) / BITSPERBYTE)
+
+#define BIT2BYTE(ibit)	((ibit) / BITSPERBYTE)
+#define BIT2SHIFT(ibit)	((ibit) % BITSPERBYTE)
+#define BIT2MASK(ibit)	(1 << BIT2SHIFT(ibit))
+#define BYTE2BIT(ibyte)	((ibyte) * BITSPERBYTE)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BITSET_H */

Added: trunk/mingw-libs/include/boolobject.h
===================================================================
--- trunk/mingw-libs/include/boolobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/boolobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,36 @@
+/* Boolean object interface */
+
+#ifndef Py_BOOLOBJECT_H
+#define Py_BOOLOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef PyIntObject PyBoolObject;
+
+PyAPI_DATA(PyTypeObject) PyBool_Type;
+
+#define PyBool_Check(x) ((x)->ob_type == &PyBool_Type)
+
+/* Py_False and Py_True are the only two bools in existence.
+Don't forget to apply Py_INCREF() when returning either!!! */
+
+/* Don't use these directly */
+PyAPI_DATA(PyIntObject) _Py_ZeroStruct, _Py_TrueStruct;
+
+/* Use these macros */
+#define Py_False ((PyObject *) &_Py_ZeroStruct)
+#define Py_True ((PyObject *) &_Py_TrueStruct)
+
+/* Macros for returning Py_True or Py_False, respectively */
+#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
+#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False
+
+/* Function to return a bool from a C long */
+PyAPI_FUNC(PyObject *) PyBool_FromLong(long);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BOOLOBJECT_H */

Added: trunk/mingw-libs/include/bufferobject.h
===================================================================
--- trunk/mingw-libs/include/bufferobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/bufferobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,33 @@
+
+/* Buffer object interface */
+
+/* Note: the object's structure is private */
+
+#ifndef Py_BUFFEROBJECT_H
+#define Py_BUFFEROBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+PyAPI_DATA(PyTypeObject) PyBuffer_Type;
+
+#define PyBuffer_Check(op) ((op)->ob_type == &PyBuffer_Type)
+
+#define Py_END_OF_BUFFER	(-1)
+
+PyAPI_FUNC(PyObject *) PyBuffer_FromObject(PyObject *base,
+                                                 int offset, int size);
+PyAPI_FUNC(PyObject *) PyBuffer_FromReadWriteObject(PyObject *base,
+                                                          int offset,
+                                                          int size);
+
+PyAPI_FUNC(PyObject *) PyBuffer_FromMemory(void *ptr, int size);
+PyAPI_FUNC(PyObject *) PyBuffer_FromReadWriteMemory(void *ptr, int size);
+
+PyAPI_FUNC(PyObject *) PyBuffer_New(int size);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BUFFEROBJECT_H */

Added: trunk/mingw-libs/include/cStringIO.h
===================================================================
--- trunk/mingw-libs/include/cStringIO.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/cStringIO.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,70 @@
+#ifndef Py_CSTRINGIO_H
+#define Py_CSTRINGIO_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+
+  This header provides access to cStringIO objects from C.
+  Functions are provided for calling cStringIO objects and
+  macros are provided for testing whether you have cStringIO 
+  objects.
+
+  Before calling any of the functions or macros, you must initialize
+  the routines with:
+
+    PycString_IMPORT
+
+  This would typically be done in your init function.
+
+*/
+#define PycString_IMPORT \
+  PycStringIO = (struct PycStringIO_CAPI*)PyCObject_Import("cStringIO", \
+                                                           "cStringIO_CAPI")
+
+/* Basic functions to manipulate cStringIO objects from C */
+
+static struct PycStringIO_CAPI {
+  
+ /* Read a string from an input object.  If the last argument
+    is -1, the remainder will be read.
+    */
+  int(*cread)(PyObject *, char **, int);
+
+ /* Read a line from an input object.  Returns the length of the read
+    line as an int and a pointer inside the object buffer as char** (so
+    the caller doesn't have to provide its own buffer as destination).
+    */
+  int(*creadline)(PyObject *, char **);
+
+  /* Write a string to an output object*/
+  int(*cwrite)(PyObject *, char *, int);
+
+  /* Get the output object as a Python string (returns new reference). */
+  PyObject *(*cgetvalue)(PyObject *);
+
+  /* Create a new output object */
+  PyObject *(*NewOutput)(int);
+
+  /* Create an input object from a Python string
+     (copies the Python string reference).
+     */
+  PyObject *(*NewInput)(PyObject *);
+
+  /* The Python types for cStringIO input and output objects.
+     Note that you can do input on an output object.
+     */
+  PyTypeObject *InputType, *OutputType;
+
+} *PycStringIO;
+
+/* These can be used to test if you have one */
+#define PycStringIO_InputCheck(O) \
+  ((O)->ob_type==PycStringIO->InputType)
+#define PycStringIO_OutputCheck(O) \
+  ((O)->ob_type==PycStringIO->OutputType)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CSTRINGIO_H */

Added: trunk/mingw-libs/include/cellobject.h
===================================================================
--- trunk/mingw-libs/include/cellobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/cellobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,28 @@
+/* Cell object interface */
+
+#ifndef Py_CELLOBJECT_H
+#define Py_CELLOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *ob_ref;	/* Content of the cell or NULL when empty */
+} PyCellObject;
+
+PyAPI_DATA(PyTypeObject) PyCell_Type;
+
+#define PyCell_Check(op) ((op)->ob_type == &PyCell_Type)
+
+PyAPI_FUNC(PyObject *) PyCell_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyCell_Get(PyObject *);
+PyAPI_FUNC(int) PyCell_Set(PyObject *, PyObject *);
+
+#define PyCell_GET(op) (((PyCellObject *)(op))->ob_ref)
+#define PyCell_SET(op, v) (((PyCellObject *)(op))->ob_ref = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TUPLEOBJECT_H */

Added: trunk/mingw-libs/include/ceval.h
===================================================================
--- trunk/mingw-libs/include/ceval.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/ceval.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,154 @@
+#ifndef Py_CEVAL_H
+#define Py_CEVAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Interface to random parts in ceval.c */
+
+PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
+	PyObject *, PyObject *, PyObject *);
+
+/* DLL-level Backwards compatibility: */
+#undef PyEval_CallObject
+PyAPI_FUNC(PyObject *) PyEval_CallObject(PyObject *, PyObject *);
+
+/* Inline this */
+#define PyEval_CallObject(func,arg) \
+        PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)
+
+PyAPI_FUNC(PyObject *) PyEval_CallFunction(PyObject *obj, char *format, ...);
+PyAPI_FUNC(PyObject *) PyEval_CallMethod(PyObject *obj,
+                                        char *methodname, char *format, ...);
+
+PyAPI_FUNC(void) PyEval_SetProfile(Py_tracefunc, PyObject *);
+PyAPI_FUNC(void) PyEval_SetTrace(Py_tracefunc, PyObject *);
+
+struct _frame; /* Avoid including frameobject.h */
+
+PyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);
+PyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);
+PyAPI_FUNC(PyObject *) PyEval_GetLocals(void);
+PyAPI_FUNC(struct _frame *) PyEval_GetFrame(void);
+PyAPI_FUNC(int) PyEval_GetRestricted(void);
+
+/* Look at the current frame's (if any) code's co_flags, and turn on
+   the corresponding compiler flags in cf->cf_flags.  Return 1 if any
+   flag was set, else return 0. */
+PyAPI_FUNC(int) PyEval_MergeCompilerFlags(PyCompilerFlags *cf);
+
+PyAPI_FUNC(int) Py_FlushLine(void);
+
+PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
+PyAPI_FUNC(int) Py_MakePendingCalls(void);
+
+/* Protection against deeply nested recursive calls */
+PyAPI_FUNC(void) Py_SetRecursionLimit(int);
+PyAPI_FUNC(int) Py_GetRecursionLimit(void);
+
+#define Py_EnterRecursiveCall(where)                                    \
+	    (_Py_MakeRecCheck(PyThreadState_GET()->recursion_depth) &&  \
+	     _Py_CheckRecursiveCall(where))
+#define Py_LeaveRecursiveCall()				\
+	    (--PyThreadState_GET()->recursion_depth)
+PyAPI_FUNC(int) _Py_CheckRecursiveCall(char *where);
+PyAPI_DATA(int) _Py_CheckRecursionLimit;
+#ifdef USE_STACKCHECK
+#  define _Py_MakeRecCheck(x)  (++(x) > --_Py_CheckRecursionLimit)
+#else
+#  define _Py_MakeRecCheck(x)  (++(x) > _Py_CheckRecursionLimit)
+#endif
+
+PyAPI_FUNC(char *) PyEval_GetFuncName(PyObject *);
+PyAPI_FUNC(char *) PyEval_GetFuncDesc(PyObject *);
+
+PyAPI_FUNC(PyObject *) PyEval_GetCallStats(PyObject *);
+PyAPI_FUNC(PyObject *) PyEval_EvalFrame(struct _frame *);
+
+/* this used to be handled on a per-thread basis - now just two globals */
+PyAPI_DATA(volatile int) _Py_Ticker;
+PyAPI_DATA(int) _Py_CheckInterval;
+
+/* Interface for threads.
+
+   A module that plans to do a blocking system call (or something else
+   that lasts a long time and doesn't touch Python data) can allow other
+   threads to run as follows:
+
+	...preparations here...
+	Py_BEGIN_ALLOW_THREADS
+	...blocking system call here...
+	Py_END_ALLOW_THREADS
+	...interpret result here...
+
+   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
+   {}-surrounded block.
+   To leave the block in the middle (e.g., with return), you must insert
+   a line containing Py_BLOCK_THREADS before the return, e.g.
+
+	if (...premature_exit...) {
+		Py_BLOCK_THREADS
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+
+   An alternative is:
+
+	Py_BLOCK_THREADS
+	if (...premature_exit...) {
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+	Py_UNBLOCK_THREADS
+
+   For convenience, that the value of 'errno' is restored across
+   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.
+
+   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
+   Py_END_ALLOW_THREADS!!!
+
+   The function PyEval_InitThreads() should be called only from
+   initthread() in "threadmodule.c".
+
+   Note that not yet all candidates have been converted to use this
+   mechanism!
+*/
+
+PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
+PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
+
+#ifdef WITH_THREAD
+
+PyAPI_FUNC(int)  PyEval_ThreadsInitialized(void);
+PyAPI_FUNC(void) PyEval_InitThreads(void);
+PyAPI_FUNC(void) PyEval_AcquireLock(void);
+PyAPI_FUNC(void) PyEval_ReleaseLock(void);
+PyAPI_FUNC(void) PyEval_AcquireThread(PyThreadState *tstate);
+PyAPI_FUNC(void) PyEval_ReleaseThread(PyThreadState *tstate);
+PyAPI_FUNC(void) PyEval_ReInitThreads(void);
+
+#define Py_BEGIN_ALLOW_THREADS { \
+			PyThreadState *_save; \
+			_save = PyEval_SaveThread();
+#define Py_BLOCK_THREADS	PyEval_RestoreThread(_save);
+#define Py_UNBLOCK_THREADS	_save = PyEval_SaveThread();
+#define Py_END_ALLOW_THREADS	PyEval_RestoreThread(_save); \
+		 }
+
+#else /* !WITH_THREAD */
+
+#define Py_BEGIN_ALLOW_THREADS {
+#define Py_BLOCK_THREADS
+#define Py_UNBLOCK_THREADS
+#define Py_END_ALLOW_THREADS }
+
+#endif /* !WITH_THREAD */
+
+PyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, int *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CEVAL_H */

Added: trunk/mingw-libs/include/classobject.h
===================================================================
--- trunk/mingw-libs/include/classobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/classobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,81 @@
+
+/* Class object interface */
+
+/* Revealing some structures (not for general use) */
+
+#ifndef Py_CLASSOBJECT_H
+#define Py_CLASSOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    PyObject	*cl_bases;	/* A tuple of class objects */
+    PyObject	*cl_dict;	/* A dictionary */
+    PyObject	*cl_name;	/* A string */
+    /* The following three are functions or NULL */
+    PyObject	*cl_getattr;
+    PyObject	*cl_setattr;
+    PyObject	*cl_delattr;
+} PyClassObject;
+
+typedef struct {
+    PyObject_HEAD
+    PyClassObject *in_class;	/* The class object */
+    PyObject	  *in_dict;	/* A dictionary */
+    PyObject	  *in_weakreflist; /* List of weak references */
+} PyInstanceObject;
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *im_func;   /* The callable object implementing the method */
+    PyObject *im_self;   /* The instance it is bound to, or NULL */
+    PyObject *im_class;  /* The class that asked for the method */
+    PyObject *im_weakreflist; /* List of weak references */
+} PyMethodObject;
+
+PyAPI_DATA(PyTypeObject) PyClass_Type, PyInstance_Type, PyMethod_Type;
+
+#define PyClass_Check(op) ((op)->ob_type == &PyClass_Type)
+#define PyInstance_Check(op) ((op)->ob_type == &PyInstance_Type)
+#define PyMethod_Check(op) ((op)->ob_type == &PyMethod_Type)
+
+PyAPI_FUNC(PyObject *) PyClass_New(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyInstance_New(PyObject *, PyObject *,
+                                            PyObject *);
+PyAPI_FUNC(PyObject *) PyInstance_NewRaw(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_New(PyObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(PyObject *) PyMethod_Function(PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_Self(PyObject *);
+PyAPI_FUNC(PyObject *) PyMethod_Class(PyObject *);
+
+/* Look up attribute with name (a string) on instance object pinst, using
+ * only the instance and base class dicts.  If a descriptor is found in
+ * a class dict, the descriptor is returned without calling it.
+ * Returns NULL if nothing found, else a borrowed reference to the
+ * value associated with name in the dict in which name was found.
+ * The point of this routine is that it never calls arbitrary Python
+ * code, so is always "safe":  all it does is dict lookups.  The function
+ * can't fail, never sets an exception, and NULL is not an error (it just
+ * means "not found").
+ */
+PyAPI_FUNC(PyObject *) _PyInstance_Lookup(PyObject *pinst, PyObject *name);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyMethod_GET_FUNCTION(meth) \
+        (((PyMethodObject *)meth) -> im_func)
+#define PyMethod_GET_SELF(meth) \
+	(((PyMethodObject *)meth) -> im_self)
+#define PyMethod_GET_CLASS(meth) \
+	(((PyMethodObject *)meth) -> im_class)
+
+PyAPI_FUNC(int) PyClass_IsSubclass(PyObject *, PyObject *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CLASSOBJECT_H */

Added: trunk/mingw-libs/include/cobject.h
===================================================================
--- trunk/mingw-libs/include/cobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/cobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,54 @@
+
+/* C objects to be exported from one extension module to another.
+ 
+   C objects are used for communication between extension modules.
+   They provide a way for an extension module to export a C interface
+   to other extension modules, so that extension modules can use the
+   Python import mechanism to link to one another.
+
+*/
+
+#ifndef Py_COBJECT_H
+#define Py_COBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyCObject_Type;
+
+#define PyCObject_Check(op) ((op)->ob_type == &PyCObject_Type)
+
+/* Create a PyCObject from a pointer to a C object and an optional
+   destructor function.  If the second argument is non-null, then it
+   will be called with the first argument if and when the PyCObject is
+   destroyed.
+
+*/
+PyAPI_FUNC(PyObject *) PyCObject_FromVoidPtr(
+	void *cobj, void (*destruct)(void*));
+
+
+/* Create a PyCObject from a pointer to a C object, a description object,
+   and an optional destructor function.  If the third argument is non-null,
+   then it will be called with the first and second arguments if and when 
+   the PyCObject is destroyed.
+*/
+PyAPI_FUNC(PyObject *) PyCObject_FromVoidPtrAndDesc(
+	void *cobj, void *desc, void (*destruct)(void*,void*));
+
+/* Retrieve a pointer to a C object from a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_AsVoidPtr(PyObject *);
+
+/* Retrieve a pointer to a description object from a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_GetDesc(PyObject *);
+
+/* Import a pointer to a C object from a module using a PyCObject. */
+PyAPI_FUNC(void *) PyCObject_Import(char *module_name, char *cobject_name);
+
+/* Modify a C object. Fails (==0) if object has a destructor. */
+PyAPI_FUNC(int) PyCObject_SetVoidPtr(PyObject *self, void *cobj);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COBJECT_H */

Added: trunk/mingw-libs/include/codecs.h
===================================================================
--- trunk/mingw-libs/include/codecs.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/codecs.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,153 @@
+#ifndef Py_CODECREGISTRY_H
+#define Py_CODECREGISTRY_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ------------------------------------------------------------------------
+
+   Python Codec Registry and support functions
+
+
+Written by Marc-Andre Lemburg (mal at lemburg.com).
+
+Copyright (c) Corporation for National Research Initiatives.
+
+   ------------------------------------------------------------------------ */
+
+/* Register a new codec search function.
+
+   As side effect, this tries to load the encodings package, if not
+   yet done, to make sure that it is always first in the list of
+   search functions.
+
+   The search_function's refcount is incremented by this function. */
+
+PyAPI_FUNC(int) PyCodec_Register(
+       PyObject *search_function
+       );
+
+/* Codec register lookup API.
+
+   Looks up the given encoding and returns a tuple (encoder, decoder,
+   stream reader, stream writer) of functions which implement the
+   different aspects of processing the encoding.
+
+   The encoding string is looked up converted to all lower-case
+   characters. This makes encodings looked up through this mechanism
+   effectively case-insensitive.
+
+   If no codec is found, a KeyError is set and NULL returned. 
+
+   As side effect, this tries to load the encodings package, if not
+   yet done. This is part of the lazy load strategy for the encodings
+   package.
+
+ */
+
+PyAPI_FUNC(PyObject *) _PyCodec_Lookup(
+       const char *encoding
+       );
+
+/* Generic codec based encoding API.
+
+   object is passed through the encoder function found for the given
+   encoding using the error handling method defined by errors. errors
+   may be NULL to use the default method defined for the codec.
+   
+   Raises a LookupError in case no encoder can be found.
+
+ */
+
+PyAPI_FUNC(PyObject *) PyCodec_Encode(
+       PyObject *object,
+       const char *encoding,
+       const char *errors
+       );
+
+/* Generic codec based decoding API.
+
+   object is passed through the decoder function found for the given
+   encoding using the error handling method defined by errors. errors
+   may be NULL to use the default method defined for the codec.
+   
+   Raises a LookupError in case no encoder can be found.
+
+ */
+
+PyAPI_FUNC(PyObject *) PyCodec_Decode(
+       PyObject *object,
+       const char *encoding,
+       const char *errors
+       );
+
+/* --- Codec Lookup APIs -------------------------------------------------- 
+
+   All APIs return a codec object with incremented refcount and are
+   based on _PyCodec_Lookup().  The same comments w/r to the encoding
+   name also apply to these APIs.
+
+*/
+
+/* Get an encoder function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_Encoder(
+       const char *encoding
+       );
+
+/* Get a decoder function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_Decoder(
+       const char *encoding
+       );
+
+/* Get a StreamReader factory function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_StreamReader(
+       const char *encoding,
+       PyObject *stream,
+       const char *errors
+       );
+
+/* Get a StreamWriter factory function for the given encoding. */
+
+PyAPI_FUNC(PyObject *) PyCodec_StreamWriter(
+       const char *encoding,
+       PyObject *stream,
+       const char *errors
+       );
+
+/* Unicode encoding error handling callback registry API */
+
+/* Register the error handling callback function error under the name
+   name. This function will be called by the codec when it encounters
+   unencodable characters/undecodable bytes and doesn't know the
+   callback name, when name is specified as the error parameter
+   in the call to the encode/decode function.
+   Return 0 on success, -1 on error */
+PyAPI_FUNC(int) PyCodec_RegisterError(const char *name, PyObject *error);
+
+/* Lookup the error handling callback function registered under the
+   name error. As a special case NULL can be passed, in which case
+   the error handling callback for "strict" will be returned. */
+PyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);
+
+/* raise exc as an exception */
+PyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);
+
+/* ignore the unicode error, skipping the faulty input */
+PyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);
+
+/* replace the unicode error with ? or U+FFFD */
+PyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);
+
+/* replace the unicode encode error with XML character references */
+PyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
+
+/* replace the unicode encode error with backslash escapes (\x, \u and \U) */
+PyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CODECREGISTRY_H */

Added: trunk/mingw-libs/include/compile.h
===================================================================
--- trunk/mingw-libs/include/compile.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/compile.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,87 @@
+
+/* Definitions for bytecode */
+
+#ifndef Py_COMPILE_H
+#define Py_COMPILE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Bytecode object */
+typedef struct {
+    PyObject_HEAD
+    int co_argcount;		/* #arguments, except *args */
+    int co_nlocals;		/* #local variables */
+    int co_stacksize;		/* #entries needed for evaluation stack */
+    int co_flags;		/* CO_..., see below */
+    PyObject *co_code;		/* instruction opcodes */
+    PyObject *co_consts;	/* list (constants used) */
+    PyObject *co_names;		/* list of strings (names used) */
+    PyObject *co_varnames;	/* tuple of strings (local variable names) */
+    PyObject *co_freevars;	/* tuple of strings (free variable names) */
+    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
+    /* The rest doesn't count for hash/cmp */
+    PyObject *co_filename;	/* string (where it was loaded from) */
+    PyObject *co_name;		/* string (name, for reference) */
+    int co_firstlineno;		/* first source line number */
+    PyObject *co_lnotab;	/* string (encoding addr<->lineno mapping) */
+} PyCodeObject;
+
+/* Masks for co_flags above */
+#define CO_OPTIMIZED	0x0001
+#define CO_NEWLOCALS	0x0002
+#define CO_VARARGS	0x0004
+#define CO_VARKEYWORDS	0x0008
+#define CO_NESTED       0x0010
+#define CO_GENERATOR    0x0020
+/* The CO_NOFREE flag is set if there are no free or cell variables.
+   This information is redundant, but it allows a single flag test
+   to determine whether there is any extra work to be done when the
+   call frame it setup.
+*/
+#define CO_NOFREE       0x0040
+/* XXX Temporary hack.  Until generators are a permanent part of the
+   language, we need a way for a code object to record that generators
+   were *possible* when it was compiled.  This is so code dynamically
+   compiled *by* a code object knows whether to allow yield stmts.  In
+   effect, this passes on the "from __future__ import generators" state
+   in effect when the code block was compiled. */
+#define CO_GENERATOR_ALLOWED    0x1000 /* no longer used in an essential way */
+#define CO_FUTURE_DIVISION    	0x2000
+
+PyAPI_DATA(PyTypeObject) PyCode_Type;
+
+#define PyCode_Check(op) ((op)->ob_type == &PyCode_Type)
+#define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)->co_freevars))
+
+#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */
+
+/* Public interface */
+struct _node; /* Declare the existence of this type */
+PyAPI_FUNC(PyCodeObject *) PyNode_Compile(struct _node *, const char *);
+PyAPI_FUNC(PyCodeObject *) PyCode_New(
+	int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
+	PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *); 
+        /* same as struct above */
+PyAPI_FUNC(int) PyCode_Addr2Line(PyCodeObject *, int);
+
+/* Future feature support */
+
+typedef struct {
+    int ff_found_docstring;
+    int ff_last_lineno;
+    int ff_features;
+} PyFutureFeatures;
+
+PyAPI_FUNC(PyFutureFeatures *) PyNode_Future(struct _node *, const char *);
+PyAPI_FUNC(PyCodeObject *) PyNode_CompileFlags(struct _node *, const char *,
+					      PyCompilerFlags *);
+
+#define FUTURE_NESTED_SCOPES "nested_scopes"
+#define FUTURE_GENERATORS "generators"
+#define FUTURE_DIVISION "division"
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COMPILE_H */

Added: trunk/mingw-libs/include/complexobject.h
===================================================================
--- trunk/mingw-libs/include/complexobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/complexobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,58 @@
+/* Complex number structure */
+
+#ifndef Py_COMPLEXOBJECT_H
+#define Py_COMPLEXOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    double real;
+    double imag;
+} Py_complex;
+
+/* Operations on complex numbers from complexmodule.c */
+
+#define c_sum _Py_c_sum
+#define c_diff _Py_c_diff
+#define c_neg _Py_c_neg
+#define c_prod _Py_c_prod
+#define c_quot _Py_c_quot
+#define c_pow _Py_c_pow
+
+PyAPI_FUNC(Py_complex) c_sum(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_diff(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_neg(Py_complex);
+PyAPI_FUNC(Py_complex) c_prod(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_quot(Py_complex, Py_complex);
+PyAPI_FUNC(Py_complex) c_pow(Py_complex, Py_complex);
+
+
+/* Complex object interface */
+
+/*
+PyComplexObject represents a complex number with double-precision
+real and imaginary parts.
+*/
+
+typedef struct {
+    PyObject_HEAD
+    Py_complex cval;
+} PyComplexObject;     
+
+PyAPI_DATA(PyTypeObject) PyComplex_Type;
+
+#define PyComplex_Check(op) PyObject_TypeCheck(op, &PyComplex_Type)
+#define PyComplex_CheckExact(op) ((op)->ob_type == &PyComplex_Type)
+
+PyAPI_FUNC(PyObject *) PyComplex_FromCComplex(Py_complex);
+PyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);
+
+PyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);
+PyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);
+PyAPI_FUNC(Py_complex) PyComplex_AsCComplex(PyObject *op);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_COMPLEXOBJECT_H */

Added: trunk/mingw-libs/include/datetime.h
===================================================================
--- trunk/mingw-libs/include/datetime.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/datetime.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,245 @@
+/*  datetime.h
+ */
+
+#ifndef DATETIME_H
+#define DATETIME_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Fields are packed into successive bytes, each viewed as unsigned and
+ * big-endian, unless otherwise noted:
+ *
+ * byte offset
+ *  0 		year     2 bytes, 1-9999
+ *  2		month    1 byte, 1-12
+ *  3 		day      1 byte, 1-31
+ *  4		hour     1 byte, 0-23
+ *  5 		minute   1 byte, 0-59
+ *  6 		second   1 byte, 0-59
+ *  7 		usecond  3 bytes, 0-999999
+ * 10
+ */
+
+/* # of bytes for year, month, and day. */
+#define _PyDateTime_DATE_DATASIZE 4
+
+/* # of bytes for hour, minute, second, and usecond. */
+#define _PyDateTime_TIME_DATASIZE 6
+
+/* # of bytes for year, month, day, hour, minute, second, and usecond. */
+#define _PyDateTime_DATETIME_DATASIZE 10
+
+
+typedef struct
+{
+	PyObject_HEAD
+	long hashcode;		/* -1 when unknown */
+	int days;		/* -MAX_DELTA_DAYS <= days <= MAX_DELTA_DAYS */
+	int seconds;		/* 0 <= seconds < 24*3600 is invariant */
+	int microseconds;	/* 0 <= microseconds < 1000000 is invariant */
+} PyDateTime_Delta;
+
+typedef struct
+{
+	PyObject_HEAD		/* a pure abstract base clase */
+} PyDateTime_TZInfo;
+
+
+/* The datetime and time types have hashcodes, and an optional tzinfo member,
+ * present if and only if hastzinfo is true.
+ */
+#define _PyTZINFO_HEAD		\
+	PyObject_HEAD		\
+	long hashcode;		\
+	char hastzinfo;		/* boolean flag */
+
+/* No _PyDateTime_BaseTZInfo is allocated; it's just to have something
+ * convenient to cast to, when getting at the hastzinfo member of objects
+ * starting with _PyTZINFO_HEAD.
+ */
+typedef struct
+{
+	_PyTZINFO_HEAD
+} _PyDateTime_BaseTZInfo;
+
+/* All time objects are of PyDateTime_TimeType, but that can be allocated
+ * in two ways, with or without a tzinfo member.  Without is the same as
+ * tzinfo == None, but consumes less memory.  _PyDateTime_BaseTime is an
+ * internal struct used to allocate the right amount of space for the
+ * "without" case.
+ */
+#define _PyDateTime_TIMEHEAD	\
+	_PyTZINFO_HEAD		\
+	unsigned char data[_PyDateTime_TIME_DATASIZE];
+
+typedef struct
+{
+	_PyDateTime_TIMEHEAD
+} _PyDateTime_BaseTime;		/* hastzinfo false */
+
+typedef struct
+{
+	_PyDateTime_TIMEHEAD
+	PyObject *tzinfo;
+} PyDateTime_Time;		/* hastzinfo true */
+
+
+/* All datetime objects are of PyDateTime_DateTimeType, but that can be
+ * allocated in two ways too, just like for time objects above.  In addition,
+ * the plain date type is a base class for datetime, so it must also have
+ * a hastzinfo member (although it's unused there).
+ */
+typedef struct
+{
+	_PyTZINFO_HEAD
+	unsigned char data[_PyDateTime_DATE_DATASIZE];
+} PyDateTime_Date;
+
+#define _PyDateTime_DATETIMEHEAD	\
+	_PyTZINFO_HEAD			\
+	unsigned char data[_PyDateTime_DATETIME_DATASIZE];
+
+typedef struct
+{
+	_PyDateTime_DATETIMEHEAD
+} _PyDateTime_BaseDateTime;	/* hastzinfo false */
+
+typedef struct
+{
+	_PyDateTime_DATETIMEHEAD
+	PyObject *tzinfo;
+} PyDateTime_DateTime;		/* hastzinfo true */
+
+
+/* Apply for date and datetime instances. */
+#define PyDateTime_GET_YEAR(o)     ((((PyDateTime_Date*)o)->data[0] << 8) | \
+                                     ((PyDateTime_Date*)o)->data[1])
+#define PyDateTime_GET_MONTH(o)    (((PyDateTime_Date*)o)->data[2])
+#define PyDateTime_GET_DAY(o)      (((PyDateTime_Date*)o)->data[3])
+
+#define PyDateTime_DATE_GET_HOUR(o)        (((PyDateTime_DateTime*)o)->data[4])
+#define PyDateTime_DATE_GET_MINUTE(o)      (((PyDateTime_DateTime*)o)->data[5])
+#define PyDateTime_DATE_GET_SECOND(o)      (((PyDateTime_DateTime*)o)->data[6])
+#define PyDateTime_DATE_GET_MICROSECOND(o) 		\
+	((((PyDateTime_DateTime*)o)->data[7] << 16) |	\
+         (((PyDateTime_DateTime*)o)->data[8] << 8)  |	\
+          ((PyDateTime_DateTime*)o)->data[9])
+
+/* Apply for time instances. */
+#define PyDateTime_TIME_GET_HOUR(o)        (((PyDateTime_Time*)o)->data[0])
+#define PyDateTime_TIME_GET_MINUTE(o)      (((PyDateTime_Time*)o)->data[1])
+#define PyDateTime_TIME_GET_SECOND(o)      (((PyDateTime_Time*)o)->data[2])
+#define PyDateTime_TIME_GET_MICROSECOND(o) 		\
+	((((PyDateTime_Time*)o)->data[3] << 16) |	\
+         (((PyDateTime_Time*)o)->data[4] << 8)  |	\
+          ((PyDateTime_Time*)o)->data[5])
+
+
+/* Define structure for C API. */
+typedef struct {
+    /* type objects */
+    PyTypeObject *DateType;
+    PyTypeObject *DateTimeType;
+    PyTypeObject *TimeType;
+    PyTypeObject *DeltaType;
+    PyTypeObject *TZInfoType;
+
+    /* constructors */
+    PyObject *(*Date_FromDate)(int, int, int, PyTypeObject*);
+    PyObject *(*DateTime_FromDateAndTime)(int, int, int, int, int, int, int,
+            PyObject*, PyTypeObject*);
+    PyObject *(*Time_FromTime)(int, int, int, int, PyObject*, PyTypeObject*);
+    PyObject *(*Delta_FromDelta)(int, int, int, int, PyTypeObject*);
+
+    /* constructors for the DB API */
+    PyObject *(*DateTime_FromTimestamp)(PyObject*, PyObject*, PyObject*);
+    PyObject *(*Date_FromTimestamp)(PyObject*, PyObject*);
+
+} PyDateTime_CAPI;
+
+
+/* "magic" constant used to partially protect against developer mistakes. */
+#define DATETIME_API_MAGIC 0x414548d5
+
+#ifdef Py_BUILD_CORE
+
+/* Macros for type checking when building the Python core. */
+#define PyDate_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateType)
+#define PyDate_CheckExact(op) ((op)->ob_type == &PyDateTime_DateType)
+
+#define PyDateTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateTimeType)
+#define PyDateTime_CheckExact(op) ((op)->ob_type == &PyDateTime_DateTimeType)
+
+#define PyTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_TimeType)
+#define PyTime_CheckExact(op) ((op)->ob_type == &PyDateTime_TimeType)
+
+#define PyDelta_Check(op) PyObject_TypeCheck(op, &PyDateTime_DeltaType)
+#define PyDelta_CheckExact(op) ((op)->ob_type == &PyDateTime_DeltaType)
+
+#define PyTZInfo_Check(op) PyObject_TypeCheck(op, &PyDateTime_TZInfoType)
+#define PyTZInfo_CheckExact(op) ((op)->ob_type == &PyDateTime_TZInfoType)
+
+#else
+
+/* Define global variable for the C API and a macro for setting it. */
+static PyDateTime_CAPI *PyDateTimeAPI;
+
+#define PyDateTime_IMPORT \
+        PyDateTimeAPI = (PyDateTime_CAPI*) PyCObject_Import("datetime", \
+                                                            "datetime_CAPI")
+
+/* This macro would be used if PyCObject_ImportEx() was created.
+#define PyDateTime_IMPORT \
+        PyDateTimeAPI = (PyDateTime_CAPI*) PyCObject_ImportEx("datetime", \
+                                                            "datetime_CAPI", \
+                                                            DATETIME_API_MAGIC)
+*/
+
+/* Macros for type checking when not building the Python core. */
+#define PyDate_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DateType)
+#define PyDate_CheckExact(op) ((op)->ob_type == PyDateTimeAPI->DateType)
+
+#define PyDateTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DateTimeType)
+#define PyDateTime_CheckExact(op) ((op)->ob_type == PyDateTimeAPI->DateTimeType)
+
+#define PyTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->TimeType)
+#define PyTime_CheckExact(op) ((op)->ob_type == PyDateTimeAPI->TimeType)
+
+#define PyDelta_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DeltaType)
+#define PyDelta_CheckExact(op) ((op)->ob_type == PyDateTimeAPI->DeltaType)
+
+#define PyTZInfo_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->TZInfoType)
+#define PyTZInfo_CheckExact(op) ((op)->ob_type == PyDateTimeAPI->TZInfoType)
+
+/* Macros for accessing constructors in a simplified fashion. */
+#define PyDate_FromDate(year, month, day) \
+	PyDateTimeAPI->Date_FromDate(year, month, day, PyDateTimeAPI->DateType)
+
+#define PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, usec) \
+	PyDateTimeAPI->DateTime_FromDateAndTime(year, month, day, hour, \
+		min, sec, usec, Py_None, PyDateTimeAPI->DateTimeType)
+
+#define PyTime_FromTime(hour, minute, second, usecond) \
+	PyDateTimeAPI->Time_FromTime(hour, minute, second, usecond, \
+		Py_None, PyDateTimeAPI->TimeType)
+
+#define PyDelta_FromDSU(days, seconds, useconds) \
+	PyDateTimeAPI->Delta_FromDelta(days, seconds, useconds, 1, \
+		PyDateTimeAPI->DeltaType)
+
+/* Macros supporting the DB API. */
+#define PyDateTime_FromTimestamp(args) \
+	PyDateTimeAPI->DateTime_FromTimestamp( \
+		(PyObject*) (PyDateTimeAPI->DateTimeType), args, NULL)
+
+#define PyDate_FromTimestamp(args) \
+	PyDateTimeAPI->Date_FromTimestamp( \
+		(PyObject*) (PyDateTimeAPI->DateType), args)
+
+#endif	/* Py_BUILD_CORE */
+
+#ifdef __cplusplus
+}
+#endif
+#endif

Added: trunk/mingw-libs/include/descrobject.h
===================================================================
--- trunk/mingw-libs/include/descrobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/descrobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,91 @@
+/* Descriptors */
+#ifndef Py_DESCROBJECT_H
+#define Py_DESCROBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef PyObject *(*getter)(PyObject *, void *);
+typedef int (*setter)(PyObject *, PyObject *, void *);
+
+typedef struct PyGetSetDef {
+	char *name;
+	getter get;
+	setter set;
+	char *doc;
+	void *closure;
+} PyGetSetDef;
+
+typedef PyObject *(*wrapperfunc)(PyObject *self, PyObject *args,
+				 void *wrapped);
+
+typedef PyObject *(*wrapperfunc_kwds)(PyObject *self, PyObject *args,
+				      void *wrapped, PyObject *kwds);
+
+struct wrapperbase {
+	char *name;
+	int offset;
+	void *function;
+	wrapperfunc wrapper;
+	char *doc;
+	int flags;
+	PyObject *name_strobj;
+};
+
+/* Flags for above struct */
+#define PyWrapperFlag_KEYWORDS 1 /* wrapper function takes keyword args */
+
+/* Various kinds of descriptor objects */
+
+#define PyDescr_COMMON \
+	PyObject_HEAD \
+	PyTypeObject *d_type; \
+	PyObject *d_name
+
+typedef struct {
+	PyDescr_COMMON;
+} PyDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	PyMethodDef *d_method;
+} PyMethodDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	struct PyMemberDef *d_member;
+} PyMemberDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	PyGetSetDef *d_getset;
+} PyGetSetDescrObject;
+
+typedef struct {
+	PyDescr_COMMON;
+	struct wrapperbase *d_base;
+	void *d_wrapped; /* This can be any function pointer */
+} PyWrapperDescrObject;
+
+PyAPI_DATA(PyTypeObject) PyWrapperDescr_Type;
+
+PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *,
+					       struct PyMemberDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *,
+					       struct PyGetSetDef *);
+PyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,
+						struct wrapperbase *, void *);
+#define PyDescr_IsData(d) ((d)->ob_type->tp_descr_set != NULL)
+
+PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);
+
+
+PyAPI_DATA(PyTypeObject) PyProperty_Type;
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_DESCROBJECT_H */
+

Added: trunk/mingw-libs/include/dictobject.h
===================================================================
--- trunk/mingw-libs/include/dictobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/dictobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,134 @@
+#ifndef Py_DICTOBJECT_H
+#define Py_DICTOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Dictionary object type -- mapping from hashable object to object */
+
+/* The distribution includes a separate file, Objects/dictnotes.txt,
+   describing explorations into dictionary design and optimization.  
+   It covers typical dictionary use patterns, the parameters for
+   tuning dictionaries, and several ideas for possible optimizations.
+*/
+
+/*
+There are three kinds of slots in the table:
+
+1. Unused.  me_key == me_value == NULL
+   Does not hold an active (key, value) pair now and never did.  Unused can
+   transition to Active upon key insertion.  This is the only case in which
+   me_key is NULL, and is each slot's initial state.
+
+2. Active.  me_key != NULL and me_key != dummy and me_value != NULL
+   Holds an active (key, value) pair.  Active can transition to Dummy upon
+   key deletion.  This is the only case in which me_value != NULL.
+
+3. Dummy.  me_key == dummy and me_value == NULL
+   Previously held an active (key, value) pair, but that was deleted and an
+   active pair has not yet overwritten the slot.  Dummy can transition to
+   Active upon key insertion.  Dummy slots cannot be made Unused again
+   (cannot have me_key set to NULL), else the probe sequence in case of
+   collision would have no way to know they were once active.
+
+Note: .popitem() abuses the me_hash field of an Unused or Dummy slot to
+hold a search finger.  The me_hash field of Unused or Dummy slots has no
+meaning otherwise.
+*/
+
+/* PyDict_MINSIZE is the minimum size of a dictionary.  This many slots are
+ * allocated directly in the dict object (in the ma_smalltable member).
+ * It must be a power of 2, and at least 4.  8 allows dicts with no more
+ * than 5 active entries to live in ma_smalltable (and so avoid an
+ * additional malloc); instrumentation suggested this suffices for the
+ * majority of dicts (consisting mostly of usually-small instance dicts and
+ * usually-small dicts created to pass keyword arguments).
+ */
+#define PyDict_MINSIZE 8
+
+typedef struct {
+	long me_hash;      /* cached hash code of me_key */
+	PyObject *me_key;
+	PyObject *me_value;
+} PyDictEntry;
+
+/*
+To ensure the lookup algorithm terminates, there must be at least one Unused
+slot (NULL key) in the table.
+The value ma_fill is the number of non-NULL keys (sum of Active and Dummy);
+ma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL
+values == the number of Active items).
+To avoid slowing down lookups on a near-full table, we resize the table when
+it's two-thirds full.
+*/
+typedef struct _dictobject PyDictObject;
+struct _dictobject {
+	PyObject_HEAD
+	int ma_fill;  /* # Active + # Dummy */
+	int ma_used;  /* # Active */
+
+	/* The table contains ma_mask + 1 slots, and that's a power of 2.
+	 * We store the mask instead of the size because the mask is more
+	 * frequently needed.
+	 */
+	int ma_mask;
+
+	/* ma_table points to ma_smalltable for small tables, else to
+	 * additional malloc'ed memory.  ma_table is never NULL!  This rule
+	 * saves repeated runtime null-tests in the workhorse getitem and
+	 * setitem calls.
+	 */
+	PyDictEntry *ma_table;
+	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
+	PyDictEntry ma_smalltable[PyDict_MINSIZE];
+};
+
+PyAPI_DATA(PyTypeObject) PyDict_Type;
+
+#define PyDict_Check(op) PyObject_TypeCheck(op, &PyDict_Type)
+#define PyDict_CheckExact(op) ((op)->ob_type == &PyDict_Type)
+
+PyAPI_FUNC(PyObject *) PyDict_New(void);
+PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
+PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Next(
+	PyObject *mp, int *pos, PyObject **key, PyObject **value);
+PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Size(PyObject *mp);
+PyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);
+PyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);
+
+/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
+PyAPI_FUNC(int) PyDict_Update(PyObject *mp, PyObject *other);
+
+/* PyDict_Merge updates/merges from a mapping object (an object that
+   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
+   the last occurrence of a key wins, else the first.  The Python
+   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
+*/
+PyAPI_FUNC(int) PyDict_Merge(PyObject *mp,
+				   PyObject *other,
+				   int override);
+
+/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
+   iterable objects of length 2.  If override is true, the last occurrence
+   of a key wins, else the first.  The Python dict constructor dict(seq2)
+   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
+*/
+PyAPI_FUNC(int) PyDict_MergeFromSeq2(PyObject *d,
+					   PyObject *seq2,
+					   int override);
+
+PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
+PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_DICTOBJECT_H */

Added: trunk/mingw-libs/include/enumobject.h
===================================================================
--- trunk/mingw-libs/include/enumobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/enumobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,17 @@
+#ifndef Py_ENUMOBJECT_H
+#define Py_ENUMOBJECT_H
+
+/* Enumerate Object */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyEnum_Type;
+PyAPI_DATA(PyTypeObject) PyReversed_Type;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_ENUMOBJECT_H */

Added: trunk/mingw-libs/include/errcode.h
===================================================================
--- trunk/mingw-libs/include/errcode.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/errcode.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,35 @@
+#ifndef Py_ERRCODE_H
+#define Py_ERRCODE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Error codes passed around between file input, tokenizer, parser and
+   interpreter.  This is necessary so we can turn them into Python
+   exceptions at a higher level.  Note that some errors have a
+   slightly different meaning when passed from the tokenizer to the
+   parser than when passed from the parser to the interpreter; e.g.
+   the parser only returns E_EOF when it hits EOF immediately, and it
+   never returns E_OK. */
+
+#define E_OK		10	/* No error */
+#define E_EOF		11	/* End Of File */
+#define E_INTR		12	/* Interrupted */
+#define E_TOKEN		13	/* Bad token */
+#define E_SYNTAX	14	/* Syntax error */
+#define E_NOMEM		15	/* Ran out of memory */
+#define E_DONE		16	/* Parsing complete */
+#define E_ERROR		17	/* Execution error */
+#define E_TABSPACE	18	/* Inconsistent mixing of tabs and spaces */
+#define E_OVERFLOW      19	/* Node had too many children */
+#define E_TOODEEP	20	/* Too many indentation levels */
+#define E_DEDENT	21	/* No matching outer block for dedent */
+#define E_DECODE	22	/* Error in decoding into Unicode */
+#define E_EOFS		23	/* EOF in triple-quoted string */
+#define E_EOLS		24	/* EOL in single-quoted string */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ERRCODE_H */

Added: trunk/mingw-libs/include/eval.h
===================================================================
--- trunk/mingw-libs/include/eval.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/eval.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,25 @@
+
+/* Interface to execute compiled code */
+
+#ifndef Py_EVAL_H
+#define Py_EVAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyCodeObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyCodeObject *co,
+					PyObject *globals,
+					PyObject *locals,
+					PyObject **args, int argc,
+					PyObject **kwds, int kwdc,
+					PyObject **defs, int defc,
+					PyObject *closure);
+
+PyAPI_FUNC(PyObject *) _PyEval_CallTracing(PyObject *func, PyObject *args);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_EVAL_H */

Added: trunk/mingw-libs/include/fileobject.h
===================================================================
--- trunk/mingw-libs/include/fileobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/fileobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,63 @@
+
+/* File object interface */
+
+#ifndef Py_FILEOBJECT_H
+#define Py_FILEOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+	PyObject_HEAD
+	FILE *f_fp;
+	PyObject *f_name;
+	PyObject *f_mode;
+	int (*f_close)(FILE *);
+	int f_softspace;	/* Flag used by 'print' command */
+	int f_binary;		/* Flag which indicates whether the file is 
+				   open in binary (1) or text (0) mode */
+	char* f_buf;		/* Allocated readahead buffer */
+	char* f_bufend;		/* Points after last occupied position */
+	char* f_bufptr;		/* Current buffer position */
+	char *f_setbuf;		/* Buffer for setbuf(3) and setvbuf(3) */
+	int f_univ_newline;	/* Handle any newline convention */
+	int f_newlinetypes;	/* Types of newlines seen */
+	int f_skipnextlf;	/* Skip next \n */
+	PyObject *f_encoding;
+	PyObject *weakreflist; /* List of weak references */
+} PyFileObject;
+
+PyAPI_DATA(PyTypeObject) PyFile_Type;
+
+#define PyFile_Check(op) PyObject_TypeCheck(op, &PyFile_Type)
+#define PyFile_CheckExact(op) ((op)->ob_type == &PyFile_Type)
+
+PyAPI_FUNC(PyObject *) PyFile_FromString(char *, char *);
+PyAPI_FUNC(void) PyFile_SetBufSize(PyObject *, int);
+PyAPI_FUNC(int) PyFile_SetEncoding(PyObject *, const char *);
+PyAPI_FUNC(PyObject *) PyFile_FromFile(FILE *, char *, char *,
+                                             int (*)(FILE *));
+PyAPI_FUNC(FILE *) PyFile_AsFile(PyObject *);
+PyAPI_FUNC(PyObject *) PyFile_Name(PyObject *);
+PyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);
+PyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);
+PyAPI_FUNC(int) PyFile_SoftSpace(PyObject *, int);
+PyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);
+PyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);
+
+/* The default encoding used by the platform file system APIs
+   If non-NULL, this is different than the default encoding for strings
+*/
+PyAPI_DATA(const char *) Py_FileSystemDefaultEncoding;
+
+/* Routines to replace fread() and fgets() which accept any of \r, \n
+   or \r\n as line terminators.
+*/
+#define PY_STDIOTEXTMODE "b"
+char *Py_UniversalNewlineFgets(char *, int, FILE*, PyObject *);
+size_t Py_UniversalNewlineFread(char *, size_t, FILE *, PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FILEOBJECT_H */

Added: trunk/mingw-libs/include/floatobject.h
===================================================================
--- trunk/mingw-libs/include/floatobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/floatobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,95 @@
+
+/* Float object interface */
+
+/*
+PyFloatObject represents a (double precision) floating point number.
+*/
+
+#ifndef Py_FLOATOBJECT_H
+#define Py_FLOATOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    double ob_fval;
+} PyFloatObject;
+
+PyAPI_DATA(PyTypeObject) PyFloat_Type;
+
+#define PyFloat_Check(op) PyObject_TypeCheck(op, &PyFloat_Type)
+#define PyFloat_CheckExact(op) ((op)->ob_type == &PyFloat_Type)
+
+/* Return Python float from string PyObject.  Second argument ignored on
+   input, and, if non-NULL, NULL is stored into *junk (this tried to serve a
+   purpose once but can't be made to work as intended). */
+PyAPI_FUNC(PyObject *) PyFloat_FromString(PyObject*, char** junk);
+
+/* Return Python float from C double. */
+PyAPI_FUNC(PyObject *) PyFloat_FromDouble(double);
+
+/* Extract C double from Python float.  The macro version trades safety for
+   speed. */
+PyAPI_FUNC(double) PyFloat_AsDouble(PyObject *);
+#define PyFloat_AS_DOUBLE(op) (((PyFloatObject *)(op))->ob_fval)
+
+/* Write repr(v) into the char buffer argument, followed by null byte.  The
+   buffer must be "big enough"; >= 100 is very safe.
+   PyFloat_AsReprString(buf, x) strives to print enough digits so that
+   PyFloat_FromString(buf) then reproduces x exactly. */
+PyAPI_FUNC(void) PyFloat_AsReprString(char*, PyFloatObject *v);
+
+/* Write str(v) into the char buffer argument, followed by null byte.  The
+   buffer must be "big enough"; >= 100 is very safe.  Note that it's
+   unusual to be able to get back the float you started with from
+   PyFloat_AsString's result -- use PyFloat_AsReprString() if you want to
+   preserve precision across conversions. */
+PyAPI_FUNC(void) PyFloat_AsString(char*, PyFloatObject *v);
+
+/* _PyFloat_{Pack,Unpack}{4,8}
+ *
+ * The struct and pickle (at least) modules need an efficient platform-
+ * independent way to store floating-point values as byte strings.
+ * The Pack routines produce a string from a C double, and the Unpack
+ * routines produce a C double from such a string.  The suffix (4 or 8)
+ * specifies the number of bytes in the string.
+ *
+ * Excepting NaNs and infinities (which aren't handled correctly), the 4-
+ * byte format is identical to the IEEE-754 single precision format, and
+ * the 8-byte format to the IEEE-754 double precision format.  On non-
+ * IEEE platforms with more precision, or larger dynamic range, than
+ * 754 supports, not all values can be packed; on non-IEEE platforms with
+ * less precision, or smaller dynamic range, not all values can be
+ * unpacked.  What happens in such cases is partly accidental (alas).
+ */
+
+/* The pack routines write 4 or 8 bytes, starting at p.  le is a bool
+ * argument, true if you want the string in little-endian format (exponent
+ * last, at p+3 or p+7), false if you want big-endian format (exponent
+ * first, at p).
+ * Return value:  0 if all is OK, -1 if error (and an exception is
+ * set, most likely OverflowError).
+ * Bug:  What this does is undefined if x is a NaN or infinity.
+ * Bug:  -0.0 and +0.0 produce the same string.
+ */
+PyAPI_FUNC(int) _PyFloat_Pack4(double x, unsigned char *p, int le);
+PyAPI_FUNC(int) _PyFloat_Pack8(double x, unsigned char *p, int le);
+
+/* The unpack routines read 4 or 8 bytes, starting at p.  le is a bool
+ * argument, true if the string is in little-endian format (exponent
+ * last, at p+3 or p+7), false if big-endian (exponent first, at p).
+ * Return value:  The unpacked double.  On error, this is -1.0 and
+ * PyErr_Occurred() is true (and an exception is set, most likely
+ * OverflowError).
+ * Bug:  What this does is undefined if the string represents a NaN or
+ * infinity.
+ */
+PyAPI_FUNC(double) _PyFloat_Unpack4(const unsigned char *p, int le);
+PyAPI_FUNC(double) _PyFloat_Unpack8(const unsigned char *p, int le);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FLOATOBJECT_H */

Added: trunk/mingw-libs/include/frameobject.h
===================================================================
--- trunk/mingw-libs/include/frameobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/frameobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,76 @@
+
+/* Frame object interface */
+
+#ifndef Py_FRAMEOBJECT_H
+#define Py_FRAMEOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    int b_type;			/* what kind of block this is */
+    int b_handler;		/* where to jump to find handler */
+    int b_level;		/* value stack level to pop to */
+} PyTryBlock;
+
+typedef struct _frame {
+    PyObject_VAR_HEAD
+    struct _frame *f_back;	/* previous frame, or NULL */
+    PyCodeObject *f_code;	/* code segment */
+    PyObject *f_builtins;	/* builtin symbol table (PyDictObject) */
+    PyObject *f_globals;	/* global symbol table (PyDictObject) */
+    PyObject *f_locals;		/* local symbol table (any mapping) */
+    PyObject **f_valuestack;	/* points after the last local */
+    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.
+       Frame evaluation usually NULLs it, but a frame that yields sets it
+       to the current stack top. */
+    PyObject **f_stacktop;
+    PyObject *f_trace;		/* Trace function */
+    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;
+    PyThreadState *f_tstate;
+    int f_lasti;		/* Last instruction if called */
+    /* As of 2.3 f_lineno is only valid when tracing is active (i.e. when
+       f_trace is set) -- at other times use PyCode_Addr2Line instead. */
+    int f_lineno;		/* Current line number */
+    int f_restricted;		/* Flag set if restricted operations
+				   in this scope */
+    int f_iblock;		/* index in f_blockstack */
+    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
+    int f_nlocals;		/* number of locals */
+    int f_ncells;
+    int f_nfreevars;
+    int f_stacksize;		/* size of value stack */
+    PyObject *f_localsplus[1];	/* locals+stack, dynamically sized */
+} PyFrameObject;
+
+
+/* Standard object interface */
+
+PyAPI_DATA(PyTypeObject) PyFrame_Type;
+
+#define PyFrame_Check(op) ((op)->ob_type == &PyFrame_Type)
+
+PyAPI_FUNC(PyFrameObject *) PyFrame_New(PyThreadState *, PyCodeObject *,
+                                       PyObject *, PyObject *);
+
+
+/* The rest of the interface is specific for frame objects */
+
+/* Block management functions */
+
+PyAPI_FUNC(void) PyFrame_BlockSetup(PyFrameObject *, int, int, int);
+PyAPI_FUNC(PyTryBlock *) PyFrame_BlockPop(PyFrameObject *);
+
+/* Extend the value stack */
+
+PyAPI_FUNC(PyObject **) PyFrame_ExtendStack(PyFrameObject *, int, int);
+
+/* Conversions between "fast locals" and locals in dictionary */
+
+PyAPI_FUNC(void) PyFrame_LocalsToFast(PyFrameObject *, int);
+PyAPI_FUNC(void) PyFrame_FastToLocals(PyFrameObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FRAMEOBJECT_H */

Added: trunk/mingw-libs/include/funcobject.h
===================================================================
--- trunk/mingw-libs/include/funcobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/funcobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,76 @@
+
+/* Function object interface */
+
+#ifndef Py_FUNCOBJECT_H
+#define Py_FUNCOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Function objects and code objects should not be confused with each other:
+ *
+ * Function objects are created by the execution of the 'def' statement.
+ * They reference a code object in their func_code attribute, which is a
+ * purely syntactic object, i.e. nothing more than a compiled version of some
+ * source code lines.  There is one code object per source code "fragment",
+ * but each code object can be referenced by zero or many function objects
+ * depending only on how many times the 'def' statement in the source was
+ * executed so far.
+ */
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *func_code;	/* A code object */
+    PyObject *func_globals;	/* A dictionary (other mappings won't do) */
+    PyObject *func_defaults;	/* NULL or a tuple */
+    PyObject *func_closure;	/* NULL or a tuple of cell objects */
+    PyObject *func_doc;		/* The __doc__ attribute, can be anything */
+    PyObject *func_name;	/* The __name__ attribute, a string object */
+    PyObject *func_dict;	/* The __dict__ attribute, a dict or NULL */
+    PyObject *func_weakreflist;	/* List of weak references */
+    PyObject *func_module;	/* The __module__ attribute, can be anything */
+
+    /* Invariant:
+     *     func_closure contains the bindings for func_code->co_freevars, so
+     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
+     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
+     */
+} PyFunctionObject;
+
+PyAPI_DATA(PyTypeObject) PyFunction_Type;
+
+#define PyFunction_Check(op) ((op)->ob_type == &PyFunction_Type)
+
+PyAPI_FUNC(PyObject *) PyFunction_New(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetCode(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetGlobals(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);
+PyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyFunction_GET_CODE(func) \
+        (((PyFunctionObject *)func) -> func_code)
+#define PyFunction_GET_GLOBALS(func) \
+	(((PyFunctionObject *)func) -> func_globals)
+#define PyFunction_GET_MODULE(func) \
+	(((PyFunctionObject *)func) -> func_module)
+#define PyFunction_GET_DEFAULTS(func) \
+	(((PyFunctionObject *)func) -> func_defaults)
+#define PyFunction_GET_CLOSURE(func) \
+	(((PyFunctionObject *)func) -> func_closure)
+
+/* The classmethod and staticmethod types lives here, too */
+PyAPI_DATA(PyTypeObject) PyClassMethod_Type;
+PyAPI_DATA(PyTypeObject) PyStaticMethod_Type;
+
+PyAPI_FUNC(PyObject *) PyClassMethod_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyStaticMethod_New(PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_FUNCOBJECT_H */

Added: trunk/mingw-libs/include/genobject.h
===================================================================
--- trunk/mingw-libs/include/genobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/genobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,35 @@
+
+/* Generator object interface */
+
+#ifndef Py_GENOBJECT_H
+#define Py_GENOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct _frame; /* Avoid including frameobject.h */
+
+typedef struct {
+	PyObject_HEAD
+	/* The gi_ prefix is intended to remind of generator-iterator. */
+
+	struct _frame *gi_frame;
+
+	/* True if generator is being executed. */
+	int gi_running;
+
+	/* List of weak reference. */
+	PyObject *gi_weakreflist;
+} PyGenObject;
+
+PyAPI_DATA(PyTypeObject) PyGen_Type;
+
+#define PyGen_Check(op) PyObject_TypeCheck(op, &PyGen_Type)
+#define PyGen_CheckExact(op) ((op)->ob_type == &PyGen_Type)
+
+PyAPI_FUNC(PyObject *) PyGen_New(struct _frame *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_GENOBJECT_H */

Added: trunk/mingw-libs/include/graminit.h
===================================================================
--- trunk/mingw-libs/include/graminit.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/graminit.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,78 @@
+#define single_input 256
+#define file_input 257
+#define eval_input 258
+#define decorator 259
+#define decorators 260
+#define funcdef 261
+#define parameters 262
+#define varargslist 263
+#define fpdef 264
+#define fplist 265
+#define stmt 266
+#define simple_stmt 267
+#define small_stmt 268
+#define expr_stmt 269
+#define augassign 270
+#define print_stmt 271
+#define del_stmt 272
+#define pass_stmt 273
+#define flow_stmt 274
+#define break_stmt 275
+#define continue_stmt 276
+#define return_stmt 277
+#define yield_stmt 278
+#define raise_stmt 279
+#define import_stmt 280
+#define import_name 281
+#define import_from 282
+#define import_as_name 283
+#define dotted_as_name 284
+#define import_as_names 285
+#define dotted_as_names 286
+#define dotted_name 287
+#define global_stmt 288
+#define exec_stmt 289
+#define assert_stmt 290
+#define compound_stmt 291
+#define if_stmt 292
+#define while_stmt 293
+#define for_stmt 294
+#define try_stmt 295
+#define except_clause 296
+#define suite 297
+#define test 298
+#define and_test 299
+#define not_test 300
+#define comparison 301
+#define comp_op 302
+#define expr 303
+#define xor_expr 304
+#define and_expr 305
+#define shift_expr 306
+#define arith_expr 307
+#define term 308
+#define factor 309
+#define power 310
+#define atom 311
+#define listmaker 312
+#define testlist_gexp 313
+#define lambdef 314
+#define trailer 315
+#define subscriptlist 316
+#define subscript 317
+#define sliceop 318
+#define exprlist 319
+#define testlist 320
+#define testlist_safe 321
+#define dictmaker 322
+#define classdef 323
+#define arglist 324
+#define argument 325
+#define list_iter 326
+#define list_for 327
+#define list_if 328
+#define gen_iter 329
+#define gen_for 330
+#define gen_if 331
+#define testlist1 332
+#define encoding_decl 333

Added: trunk/mingw-libs/include/grammar.h
===================================================================
--- trunk/mingw-libs/include/grammar.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/grammar.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,93 @@
+
+/* Grammar interface */
+
+#ifndef Py_GRAMMAR_H
+#define Py_GRAMMAR_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "bitset.h" /* Sigh... */
+
+/* A label of an arc */
+
+typedef struct {
+    int		 lb_type;
+    char	*lb_str;
+} label;
+
+#define EMPTY 0		/* Label number 0 is by definition the empty label */
+
+/* A list of labels */
+
+typedef struct {
+    int		 ll_nlabels;
+    label	*ll_label;
+} labellist;
+
+/* An arc from one state to another */
+
+typedef struct {
+    short	a_lbl;		/* Label of this arc */
+    short	a_arrow;	/* State where this arc goes to */
+} arc;
+
+/* A state in a DFA */
+
+typedef struct {
+    int		 s_narcs;
+    arc		*s_arc;		/* Array of arcs */
+	
+    /* Optional accelerators */
+    int		 s_lower;	/* Lowest label index */
+    int		 s_upper;	/* Highest label index */
+    int		*s_accel;	/* Accelerator */
+    int		 s_accept;	/* Nonzero for accepting state */
+} state;
+
+/* A DFA */
+
+typedef struct {
+    int		 d_type;	/* Non-terminal this represents */
+    char	*d_name;	/* For printing */
+    int		 d_initial;	/* Initial state */
+    int		 d_nstates;
+    state	*d_state;	/* Array of states */
+    bitset	 d_first;
+} dfa;
+
+/* A grammar */
+
+typedef struct {
+    int		 g_ndfas;
+    dfa		*g_dfa;		/* Array of DFAs */
+    labellist	 g_ll;
+    int		 g_start;	/* Start symbol of the grammar */
+    int		 g_accel;	/* Set if accelerators present */
+} grammar;
+
+/* FUNCTIONS */
+
+grammar *newgrammar(int start);
+dfa *adddfa(grammar *g, int type, char *name);
+int addstate(dfa *d);
+void addarc(dfa *d, int from, int to, int lbl);
+dfa *PyGrammar_FindDFA(grammar *g, int type);
+
+int addlabel(labellist *ll, int type, char *str);
+int findlabel(labellist *ll, int type, char *str);
+char *PyGrammar_LabelRepr(label *lb);
+void translatelabels(grammar *g);
+
+void addfirstsets(grammar *g);
+
+void PyGrammar_AddAccelerators(grammar *g);
+void PyGrammar_RemoveAccelerators(grammar *);
+
+void printgrammar(grammar *g, FILE *fp);
+void printnonterminals(grammar *g, FILE *fp);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_GRAMMAR_H */

Added: trunk/mingw-libs/include/import.h
===================================================================
--- trunk/mingw-libs/include/import.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/import.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,55 @@
+
+/* Module definition and import interface */
+
+#ifndef Py_IMPORT_H
+#define Py_IMPORT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_FUNC(long) PyImport_GetMagicNumber(void);
+PyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(char *name, PyObject *co);
+PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(
+	char *name, PyObject *co, char *pathname);
+PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
+PyAPI_FUNC(PyObject *) PyImport_AddModule(char *name);
+PyAPI_FUNC(PyObject *) PyImport_ImportModule(char *name);
+PyAPI_FUNC(PyObject *) PyImport_ImportModuleEx(
+	char *name, PyObject *globals, PyObject *locals, PyObject *fromlist);
+PyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);
+PyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);
+PyAPI_FUNC(void) PyImport_Cleanup(void);
+PyAPI_FUNC(int) PyImport_ImportFrozenModule(char *);
+
+PyAPI_FUNC(struct filedescr *) _PyImport_FindModule(
+	const char *, PyObject *, char *, size_t, FILE **, PyObject **);
+PyAPI_FUNC(int) _PyImport_IsScript(struct filedescr *);
+
+PyAPI_FUNC(PyObject *)_PyImport_FindExtension(char *, char *);
+PyAPI_FUNC(PyObject *)_PyImport_FixupExtension(char *, char *);
+
+struct _inittab {
+    char *name;
+    void (*initfunc)(void);
+};
+
+PyAPI_DATA(struct _inittab *) PyImport_Inittab;
+
+PyAPI_FUNC(int) PyImport_AppendInittab(char *name, void (*initfunc)(void));
+PyAPI_FUNC(int) PyImport_ExtendInittab(struct _inittab *newtab);
+
+struct _frozen {
+    char *name;
+    unsigned char *code;
+    int size;
+};
+
+/* Embedding apps may change this pointer to point to their favorite
+   collection of frozen modules: */
+
+PyAPI_DATA(struct _frozen *) PyImport_FrozenModules;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_IMPORT_H */

Added: trunk/mingw-libs/include/intobject.h
===================================================================
--- trunk/mingw-libs/include/intobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/intobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,61 @@
+
+/* Integer object interface */
+
+/*
+PyIntObject represents a (long) integer.  This is an immutable object;
+an integer cannot change its value after creation.
+
+There are functions to create new integer objects, to test an object
+for integer-ness, and to get the integer value.  The latter functions
+returns -1 and sets errno to EBADF if the object is not an PyIntObject.
+None of the functions should be applied to nil objects.
+
+The type PyIntObject is (unfortunately) exposed here so we can declare
+_Py_TrueStruct and _Py_ZeroStruct in boolobject.h; don't use this.
+*/
+
+#ifndef Py_INTOBJECT_H
+#define Py_INTOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    PyObject_HEAD
+    long ob_ival;
+} PyIntObject;
+
+PyAPI_DATA(PyTypeObject) PyInt_Type;
+
+#define PyInt_Check(op) PyObject_TypeCheck(op, &PyInt_Type)
+#define PyInt_CheckExact(op) ((op)->ob_type == &PyInt_Type)
+
+PyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyInt_FromUnicode(Py_UNICODE*, int, int);
+#endif
+PyAPI_FUNC(PyObject *) PyInt_FromLong(long);
+PyAPI_FUNC(long) PyInt_AsLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyInt_AsUnsignedLongMask(PyObject *);
+#ifdef HAVE_LONG_LONG
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyInt_AsUnsignedLongLongMask(PyObject *);
+#endif
+
+PyAPI_FUNC(long) PyInt_GetMax(void);
+
+/* Macro, trading safety for speed */
+#define PyInt_AS_LONG(op) (((PyIntObject *)(op))->ob_ival)
+
+/* These aren't really part of the Int object, but they're handy; the protos
+ * are necessary for systems that need the magic of PyAPI_FUNC and that want
+ * to have stropmodule as a dynamically loaded module instead of building it
+ * into the main Python shared library/DLL.  Guido thinks I'm weird for
+ * building it this way.  :-)  [cjh]
+ */
+PyAPI_FUNC(unsigned long) PyOS_strtoul(char *, char **, int);
+PyAPI_FUNC(long) PyOS_strtol(char *, char **, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_INTOBJECT_H */

Added: trunk/mingw-libs/include/intrcheck.h
===================================================================
--- trunk/mingw-libs/include/intrcheck.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/intrcheck.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,15 @@
+
+#ifndef Py_INTRCHECK_H
+#define Py_INTRCHECK_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_FUNC(int) PyOS_InterruptOccurred(void);
+PyAPI_FUNC(void) PyOS_InitInterrupts(void);
+PyAPI_FUNC(void) PyOS_AfterFork(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_INTRCHECK_H */

Added: trunk/mingw-libs/include/iterobject.h
===================================================================
--- trunk/mingw-libs/include/iterobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/iterobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,23 @@
+#ifndef Py_ITEROBJECT_H
+#define Py_ITEROBJECT_H
+/* Iterators (the basic kind, over a sequence) */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_DATA(PyTypeObject) PySeqIter_Type;
+
+#define PySeqIter_Check(op) ((op)->ob_type == &PySeqIter_Type)
+
+PyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);
+
+PyAPI_DATA(PyTypeObject) PyCallIter_Type;
+
+#define PyCallIter_Check(op) ((op)->ob_type == &PyCallIter_Type)
+
+PyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ITEROBJECT_H */
+

Added: trunk/mingw-libs/include/listobject.h
===================================================================
--- trunk/mingw-libs/include/listobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/listobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,67 @@
+
+/* List object interface */
+
+/*
+Another generally useful object type is an list of object pointers.
+This is a mutable type: the list items can be changed, and items can be
+added or removed.  Out-of-range indices or non-list objects are ignored.
+
+*** WARNING *** PyList_SetItem does not increment the new item's reference
+count, but does decrement the reference count of the item it replaces,
+if not nil.  It does *decrement* the reference count if it is *not*
+inserted in the list.  Similarly, PyList_GetItem does not increment the
+returned item's reference count.
+*/
+
+#ifndef Py_LISTOBJECT_H
+#define Py_LISTOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    PyObject_VAR_HEAD
+    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
+    PyObject **ob_item;
+
+    /* ob_item contains space for 'allocated' elements.  The number
+     * currently in use is ob_size.
+     * Invariants:
+     *     0 <= ob_size <= allocated
+     *     len(list) == ob_size
+     *     ob_item == NULL implies ob_size == allocated == 0
+     * list.sort() temporarily sets allocated to -1 to detect mutations.
+     *
+     * Items must normally not be NULL, except during construction when
+     * the list is not yet visible outside the function that builds it.
+     */
+    int allocated;
+} PyListObject;
+
+PyAPI_DATA(PyTypeObject) PyList_Type;
+
+#define PyList_Check(op) PyObject_TypeCheck(op, &PyList_Type)
+#define PyList_CheckExact(op) ((op)->ob_type == &PyList_Type)
+
+PyAPI_FUNC(PyObject *) PyList_New(int size);
+PyAPI_FUNC(int) PyList_Size(PyObject *);
+PyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, int);
+PyAPI_FUNC(int) PyList_SetItem(PyObject *, int, PyObject *);
+PyAPI_FUNC(int) PyList_Insert(PyObject *, int, PyObject *);
+PyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, int, int);
+PyAPI_FUNC(int) PyList_SetSlice(PyObject *, int, int, PyObject *);
+PyAPI_FUNC(int) PyList_Sort(PyObject *);
+PyAPI_FUNC(int) PyList_Reverse(PyObject *);
+PyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);
+PyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);
+
+/* Macro, trading safety for speed */
+#define PyList_GET_ITEM(op, i) (((PyListObject *)(op))->ob_item[i])
+#define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))->ob_item[i] = (v))
+#define PyList_GET_SIZE(op)    (((PyListObject *)(op))->ob_size)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LISTOBJECT_H */

Added: trunk/mingw-libs/include/longintrepr.h
===================================================================
--- trunk/mingw-libs/include/longintrepr.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/longintrepr.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,63 @@
+#ifndef Py_LONGINTREPR_H
+#define Py_LONGINTREPR_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* This is published for the benefit of "friend" marshal.c only. */
+
+/* Parameters of the long integer representation.
+   These shouldn't have to be changed as C should guarantee that a short
+   contains at least 16 bits, but it's made changeable anyway.
+   Note: 'digit' should be able to hold 2*MASK+1, and 'twodigits'
+   should be able to hold the intermediate results in 'mul'
+   (at most (BASE-1)*(2*BASE+1) == MASK*(2*MASK+3)).
+   Also, x_sub assumes that 'digit' is an unsigned type, and overflow
+   is handled by taking the result mod 2**N for some N > SHIFT.
+   And, at some places it is assumed that MASK fits in an int, as well.
+   long_pow() requires that SHIFT be divisible by 5. */
+
+typedef unsigned short digit;
+typedef unsigned int wdigit; /* digit widened to parameter size */
+#define BASE_TWODIGITS_TYPE long
+typedef unsigned BASE_TWODIGITS_TYPE twodigits;
+typedef BASE_TWODIGITS_TYPE stwodigits; /* signed variant of twodigits */
+
+#define SHIFT	15
+#define BASE	((digit)1 << SHIFT)
+#define MASK	((int)(BASE - 1))
+
+#if SHIFT % 5 != 0
+#error "longobject.c requires that SHIFT be divisible by 5"
+#endif
+
+/* Long integer representation.
+   The absolute value of a number is equal to
+   	SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)
+   Negative numbers are represented with ob_size < 0;
+   zero is represented by ob_size == 0.
+   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant
+   digit) is never zero.  Also, in all cases, for all valid i,
+   	0 <= ob_digit[i] <= MASK.
+   The allocation function takes care of allocating extra memory
+   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.
+
+   CAUTION:  Generic code manipulating subtypes of PyVarObject has to
+   aware that longs abuse  ob_size's sign bit.
+*/
+
+struct _longobject {
+	PyObject_VAR_HEAD
+	digit ob_digit[1];
+};
+
+PyAPI_FUNC(PyLongObject *) _PyLong_New(int);
+
+/* Return a copy of src. */
+PyAPI_FUNC(PyObject *) _PyLong_Copy(PyLongObject *src);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LONGINTREPR_H */

Added: trunk/mingw-libs/include/longobject.h
===================================================================
--- trunk/mingw-libs/include/longobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/longobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,108 @@
+#ifndef Py_LONGOBJECT_H
+#define Py_LONGOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Long (arbitrary precision) integer object interface */
+
+typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */
+
+PyAPI_DATA(PyTypeObject) PyLong_Type;
+
+#define PyLong_Check(op) PyObject_TypeCheck(op, &PyLong_Type)
+#define PyLong_CheckExact(op) ((op)->ob_type == &PyLong_Type)
+
+PyAPI_FUNC(PyObject *) PyLong_FromLong(long);
+PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);
+PyAPI_FUNC(PyObject *) PyLong_FromDouble(double);
+PyAPI_FUNC(long) PyLong_AsLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLong(PyObject *);
+PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLongMask(PyObject *);
+
+/* _PyLong_AsScaledDouble returns a double x and an exponent e such that
+   the true value is approximately equal to x * 2**(SHIFT*e).  e is >= 0.
+   x is 0.0 if and only if the input is 0 (in which case, e and x are both
+   zeroes).  Overflow is impossible.  Note that the exponent returned must
+   be multiplied by SHIFT!  There may not be enough room in an int to store
+   e*SHIFT directly. */
+PyAPI_FUNC(double) _PyLong_AsScaledDouble(PyObject *vv, int *e);
+
+PyAPI_FUNC(double) PyLong_AsDouble(PyObject *);
+PyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);
+PyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);
+
+#ifdef HAVE_LONG_LONG
+PyAPI_FUNC(PyObject *) PyLong_FromLongLong(PY_LONG_LONG);
+PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned PY_LONG_LONG);
+PyAPI_FUNC(PY_LONG_LONG) PyLong_AsLongLong(PyObject *);
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyLong_AsUnsignedLongLong(PyObject *);
+PyAPI_FUNC(unsigned PY_LONG_LONG) PyLong_AsUnsignedLongLongMask(PyObject *);
+#endif /* HAVE_LONG_LONG */
+
+PyAPI_FUNC(PyObject *) PyLong_FromString(char *, char **, int);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyLong_FromUnicode(Py_UNICODE*, int, int);
+#endif
+
+/* _PyLong_Sign.  Return 0 if v is 0, -1 if v < 0, +1 if v > 0.
+   v must not be NULL, and must be a normalized long.
+   There are no error cases.
+*/
+PyAPI_FUNC(int) _PyLong_Sign(PyObject *v);
+
+
+/* _PyLong_NumBits.  Return the number of bits needed to represent the
+   absolute value of a long.  For example, this returns 1 for 1 and -1, 2
+   for 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.
+   v must not be NULL, and must be a normalized long.
+   (size_t)-1 is returned and OverflowError set if the true result doesn't
+   fit in a size_t.
+*/
+PyAPI_FUNC(size_t) _PyLong_NumBits(PyObject *v);
+
+/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
+   base 256, and return a Python long with the same numeric value.
+   If n is 0, the integer is 0.  Else:
+   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;
+   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the
+   LSB.
+   If is_signed is 0/false, view the bytes as a non-negative integer.
+   If is_signed is 1/true, view the bytes as a 2's-complement integer,
+   non-negative if bit 0x80 of the MSB is clear, negative if set.
+   Error returns:
+   + Return NULL with the appropriate exception set if there's not
+     enough memory to create the Python long.
+*/
+PyAPI_FUNC(PyObject *) _PyLong_FromByteArray(
+	const unsigned char* bytes, size_t n,
+	int little_endian, int is_signed);
+
+/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long
+   v to a base-256 integer, stored in array bytes.  Normally return 0,
+   return -1 on error.
+   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at
+   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and
+   the LSB at bytes[n-1].
+   If is_signed is 0/false, it's an error if v < 0; else (v >= 0) n bytes
+   are filled and there's nothing special about bit 0x80 of the MSB.
+   If is_signed is 1/true, bytes is filled with the 2's-complement
+   representation of v's value.  Bit 0x80 of the MSB is the sign bit.
+   Error returns (-1):
+   + is_signed is 0 and v < 0.  TypeError is set in this case, and bytes
+     isn't altered.
+   + n isn't big enough to hold the full mathematical value of v.  For
+     example, if is_signed is 0 and there are more digits in the v than
+     fit in n; or if is_signed is 1, v < 0, and n is just 1 bit shy of
+     being large enough to hold a sign bit.  OverflowError is set in this
+     case, but bytes holds the least-signficant n bytes of the true value.
+*/
+PyAPI_FUNC(int) _PyLong_AsByteArray(PyLongObject* v,
+	unsigned char* bytes, size_t n,
+	int little_endian, int is_signed);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LONGOBJECT_H */

Added: trunk/mingw-libs/include/marshal.h
===================================================================
--- trunk/mingw-libs/include/marshal.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/marshal.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,25 @@
+
+/* Interface for marshal.c */
+
+#ifndef Py_MARSHAL_H
+#define Py_MARSHAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define Py_MARSHAL_VERSION 1
+
+PyAPI_FUNC(void) PyMarshal_WriteLongToFile(long, FILE *, int);
+PyAPI_FUNC(void) PyMarshal_WriteObjectToFile(PyObject *, FILE *, int);
+PyAPI_FUNC(PyObject *) PyMarshal_WriteObjectToString(PyObject *, int);
+
+PyAPI_FUNC(long) PyMarshal_ReadLongFromFile(FILE *);
+PyAPI_FUNC(int) PyMarshal_ReadShortFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadLastObjectFromFile(FILE *);
+PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromString(char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MARSHAL_H */

Added: trunk/mingw-libs/include/metagrammar.h
===================================================================
--- trunk/mingw-libs/include/metagrammar.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/metagrammar.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,18 @@
+#ifndef Py_METAGRAMMAR_H
+#define Py_METAGRAMMAR_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define MSTART 256
+#define RULE 257
+#define RHS 258
+#define ALT 259
+#define ITEM 260
+#define ATOM 261
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_METAGRAMMAR_H */

Added: trunk/mingw-libs/include/methodobject.h
===================================================================
--- trunk/mingw-libs/include/methodobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/methodobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,91 @@
+
+/* Method object interface */
+
+#ifndef Py_METHODOBJECT_H
+#define Py_METHODOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This is about the type 'builtin_function_or_method',
+   not Python methods in user-defined classes.  See classobject.h
+   for the latter. */
+
+PyAPI_DATA(PyTypeObject) PyCFunction_Type;
+
+#define PyCFunction_Check(op) ((op)->ob_type == &PyCFunction_Type)
+
+typedef PyObject *(*PyCFunction)(PyObject *, PyObject *);
+typedef PyObject *(*PyCFunctionWithKeywords)(PyObject *, PyObject *,
+					     PyObject *);
+typedef PyObject *(*PyNoArgsFunction)(PyObject *);
+
+PyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);
+PyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);
+PyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);
+
+/* Macros for direct access to these values. Type checks are *not*
+   done, so use with care. */
+#define PyCFunction_GET_FUNCTION(func) \
+        (((PyCFunctionObject *)func) -> m_ml -> ml_meth)
+#define PyCFunction_GET_SELF(func) \
+	(((PyCFunctionObject *)func) -> m_self)
+#define PyCFunction_GET_FLAGS(func) \
+	(((PyCFunctionObject *)func) -> m_ml -> ml_flags)
+PyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
+
+struct PyMethodDef {
+    char	*ml_name;	/* The name of the built-in function/method */
+    PyCFunction  ml_meth;	/* The C function that implements it */
+    int		 ml_flags;	/* Combination of METH_xxx flags, which mostly
+				   describe the args expected by the C func */
+    char	*ml_doc;	/* The __doc__ attribute, or NULL */
+};
+typedef struct PyMethodDef PyMethodDef;
+
+PyAPI_FUNC(PyObject *) Py_FindMethod(PyMethodDef[], PyObject *, char *);
+
+#define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
+PyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *, 
+					 PyObject *);
+
+/* Flag passed to newmethodobject */
+#define METH_OLDARGS  0x0000
+#define METH_VARARGS  0x0001
+#define METH_KEYWORDS 0x0002
+/* METH_NOARGS and METH_O must not be combined with the flags above. */
+#define METH_NOARGS   0x0004
+#define METH_O        0x0008
+
+/* METH_CLASS and METH_STATIC are a little different; these control
+   the construction of methods for a class.  These cannot be used for
+   functions in modules. */
+#define METH_CLASS    0x0010
+#define METH_STATIC   0x0020
+
+/* METH_COEXIST allows a method to be entered eventhough a slot has
+   already filled the entry.  When defined, the flag allows a separate
+   method, "__contains__" for example, to coexist with a defined 
+   slot like sq_contains. */
+
+#define METH_COEXIST   0x0040
+
+typedef struct PyMethodChain {
+    PyMethodDef *methods;		/* Methods of this type */
+    struct PyMethodChain *link;	/* NULL or base type */
+} PyMethodChain;
+
+PyAPI_FUNC(PyObject *) Py_FindMethodInChain(PyMethodChain *, PyObject *,
+                                                  char *);
+
+typedef struct {
+    PyObject_HEAD
+    PyMethodDef *m_ml; /* Description of the C function to call */
+    PyObject    *m_self; /* Passed as 'self' arg to the C func, can be NULL */
+    PyObject    *m_module; /* The __module__ attribute, can be anything */
+} PyCFunctionObject;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_METHODOBJECT_H */

Added: trunk/mingw-libs/include/modsupport.h
===================================================================
--- trunk/mingw-libs/include/modsupport.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/modsupport.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,103 @@
+
+#ifndef Py_MODSUPPORT_H
+#define Py_MODSUPPORT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Module support interface */
+
+#include <stdarg.h>
+
+PyAPI_FUNC(int) PyArg_Parse(PyObject *, char *, ...);
+PyAPI_FUNC(int) PyArg_ParseTuple(PyObject *, char *, ...);
+PyAPI_FUNC(int) PyArg_ParseTupleAndKeywords(PyObject *, PyObject *,
+                                                  char *, char **, ...);
+PyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, char *, int, int, ...);
+PyAPI_FUNC(PyObject *) Py_BuildValue(char *, ...);
+
+PyAPI_FUNC(int) PyArg_VaParse(PyObject *, char *, va_list);
+PyAPI_FUNC(int) PyArg_VaParseTupleAndKeywords(PyObject *, PyObject *,
+                                                  char *, char **, va_list);
+PyAPI_FUNC(PyObject *) Py_VaBuildValue(char *, va_list);
+
+PyAPI_FUNC(int) PyModule_AddObject(PyObject *, char *, PyObject *);
+PyAPI_FUNC(int) PyModule_AddIntConstant(PyObject *, char *, long);
+PyAPI_FUNC(int) PyModule_AddStringConstant(PyObject *, char *, char *);
+
+#define PYTHON_API_VERSION 1012
+#define PYTHON_API_STRING "1012"
+/* The API version is maintained (independently from the Python version)
+   so we can detect mismatches between the interpreter and dynamically
+   loaded modules.  These are diagnosed by an error message but
+   the module is still loaded (because the mismatch can only be tested
+   after loading the module).  The error message is intended to
+   explain the core dump a few seconds later.
+
+   The symbol PYTHON_API_STRING defines the same value as a string
+   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***
+
+   Please add a line or two to the top of this log for each API
+   version change:
+
+   19-Aug-2002  GvR	1012	Changes to string object struct for
+   				interning changes, saving 3 bytes.
+
+   17-Jul-2001	GvR	1011	Descr-branch, just to be on the safe side
+
+   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
+                                PyFrame_New(); Python 2.1a2
+
+   14-Mar-2000  GvR     1009    Unicode API added
+
+   3-Jan-1999	GvR	1007	Decided to change back!  (Don't reuse 1008!)
+
+   3-Dec-1998	GvR	1008	Python 1.5.2b1
+
+   18-Jan-1997	GvR	1007	string interning and other speedups
+
+   11-Oct-1996	GvR	renamed Py_Ellipses to Py_Ellipsis :-(
+
+   30-Jul-1996	GvR	Slice and ellipses syntax added
+
+   23-Jul-1996	GvR	For 1.4 -- better safe than sorry this time :-)
+
+   7-Nov-1995	GvR	Keyword arguments (should've been done at 1.3 :-( )
+
+   10-Jan-1995	GvR	Renamed globals to new naming scheme
+
+   9-Jan-1995	GvR	Initial version (incompatible with older API)
+*/
+
+#ifdef MS_WINDOWS
+/* Special defines for Windows versions used to live here.  Things
+   have changed, and the "Version" is now in a global string variable.
+   Reason for this is that this for easier branding of a "custom DLL"
+   without actually needing a recompile.  */
+#endif /* MS_WINDOWS */
+
+#ifdef Py_TRACE_REFS
+/* When we are tracing reference counts, rename Py_InitModule4 so
+   modules compiled with incompatible settings will generate a
+   link-time error. */
+#define Py_InitModule4 Py_InitModule4TraceRefs
+#endif
+
+PyAPI_FUNC(PyObject *) Py_InitModule4(char *name, PyMethodDef *methods,
+                                            char *doc, PyObject *self,
+                                            int apiver);
+
+#define Py_InitModule(name, methods) \
+	Py_InitModule4(name, methods, (char *)NULL, (PyObject *)NULL, \
+		       PYTHON_API_VERSION)
+
+#define Py_InitModule3(name, methods, doc) \
+	Py_InitModule4(name, methods, doc, (PyObject *)NULL, \
+		       PYTHON_API_VERSION)
+
+PyAPI_DATA(char *) _Py_PackageContext;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MODSUPPORT_H */

Added: trunk/mingw-libs/include/moduleobject.h
===================================================================
--- trunk/mingw-libs/include/moduleobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/moduleobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,24 @@
+
+/* Module object interface */
+
+#ifndef Py_MODULEOBJECT_H
+#define Py_MODULEOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_DATA(PyTypeObject) PyModule_Type;
+
+#define PyModule_Check(op) PyObject_TypeCheck(op, &PyModule_Type)
+#define PyModule_CheckExact(op) ((op)->ob_type == &PyModule_Type)
+
+PyAPI_FUNC(PyObject *) PyModule_New(char *);
+PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
+PyAPI_FUNC(char *) PyModule_GetName(PyObject *);
+PyAPI_FUNC(char *) PyModule_GetFilename(PyObject *);
+PyAPI_FUNC(void) _PyModule_Clear(PyObject *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MODULEOBJECT_H */

Added: trunk/mingw-libs/include/node.h
===================================================================
--- trunk/mingw-libs/include/node.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/node.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,39 @@
+
+/* Parse tree node interface */
+
+#ifndef Py_NODE_H
+#define Py_NODE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _node {
+    short		n_type;
+    char		*n_str;
+    int			n_lineno;
+    int			n_nchildren;
+    struct _node	*n_child;
+} node;
+
+PyAPI_FUNC(node *) PyNode_New(int type);
+PyAPI_FUNC(int) PyNode_AddChild(node *n, int type,
+                                      char *str, int lineno);
+PyAPI_FUNC(void) PyNode_Free(node *n);
+
+/* Node access functions */
+#define NCH(n)		((n)->n_nchildren)
+	
+#define CHILD(n, i)	(&(n)->n_child[i])
+#define RCHILD(n, i)	(CHILD(n, NCH(n) + i))
+#define TYPE(n)		((n)->n_type)
+#define STR(n)		((n)->n_str)
+
+/* Assert that the type of a node is what we expect */
+#define REQ(n, type) assert(TYPE(n) == (type))
+
+PyAPI_FUNC(void) PyNode_ListTree(node *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_NODE_H */

Added: trunk/mingw-libs/include/object.h
===================================================================
--- trunk/mingw-libs/include/object.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/object.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,807 @@
+#ifndef Py_OBJECT_H
+#define Py_OBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Object and type object interface */
+
+/*
+Objects are structures allocated on the heap.  Special rules apply to
+the use of objects to ensure they are properly garbage-collected.
+Objects are never allocated statically or on the stack; they must be
+accessed through special macros and functions only.  (Type objects are
+exceptions to the first rule; the standard types are represented by
+statically initialized type objects, although work on type/class unification
+for Python 2.2 made it possible to have heap-allocated type objects too).
+
+An object has a 'reference count' that is increased or decreased when a
+pointer to the object is copied or deleted; when the reference count
+reaches zero there are no references to the object left and it can be
+removed from the heap.
+
+An object has a 'type' that determines what it represents and what kind
+of data it contains.  An object's type is fixed when it is created.
+Types themselves are represented as objects; an object contains a
+pointer to the corresponding type object.  The type itself has a type
+pointer pointing to the object representing the type 'type', which
+contains a pointer to itself!).
+
+Objects do not float around in memory; once allocated an object keeps
+the same size and address.  Objects that must hold variable-size data
+can contain pointers to variable-size parts of the object.  Not all
+objects of the same type have the same size; but the size cannot change
+after allocation.  (These restrictions are made so a reference to an
+object can be simply a pointer -- moving an object would require
+updating all the pointers, and changing an object's size would require
+moving it if there was another object right next to it.)
+
+Objects are always accessed through pointers of the type 'PyObject *'.
+The type 'PyObject' is a structure that only contains the reference count
+and the type pointer.  The actual memory allocated for an object
+contains other data that can only be accessed after casting the pointer
+to a pointer to a longer structure type.  This longer type must start
+with the reference count and type fields; the macro PyObject_HEAD should be
+used for this (to accommodate for future changes).  The implementation
+of a particular object type can cast the object pointer to the proper
+type and back.
+
+A standard interface exists for objects that contain an array of items
+whose size is determined when the object is allocated.
+*/
+
+/* Py_DEBUG implies Py_TRACE_REFS. */
+#if defined(Py_DEBUG) && !defined(Py_TRACE_REFS)
+#define Py_TRACE_REFS
+#endif
+
+/* Py_TRACE_REFS implies Py_REF_DEBUG. */
+#if defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG)
+#define Py_REF_DEBUG
+#endif
+
+#ifdef Py_TRACE_REFS
+/* Define pointers to support a doubly-linked list of all live heap objects. */
+#define _PyObject_HEAD_EXTRA		\
+	struct _object *_ob_next;	\
+	struct _object *_ob_prev;
+
+#define _PyObject_EXTRA_INIT 0, 0,
+
+#else
+#define _PyObject_HEAD_EXTRA
+#define _PyObject_EXTRA_INIT
+#endif
+
+/* PyObject_HEAD defines the initial segment of every PyObject. */
+#define PyObject_HEAD			\
+	_PyObject_HEAD_EXTRA		\
+	int ob_refcnt;			\
+	struct _typeobject *ob_type;
+
+#define PyObject_HEAD_INIT(type)	\
+	_PyObject_EXTRA_INIT		\
+	1, type,
+
+/* PyObject_VAR_HEAD defines the initial segment of all variable-size
+ * container objects.  These end with a declaration of an array with 1
+ * element, but enough space is malloc'ed so that the array actually
+ * has room for ob_size elements.  Note that ob_size is an element count,
+ * not necessarily a byte count.
+ */
+#define PyObject_VAR_HEAD		\
+	PyObject_HEAD			\
+	int ob_size; /* Number of items in variable part */
+
+/* Nothing is actually declared to be a PyObject, but every pointer to
+ * a Python object can be cast to a PyObject*.  This is inheritance built
+ * by hand.  Similarly every pointer to a variable-size Python object can,
+ * in addition, be cast to PyVarObject*.
+ */
+typedef struct _object {
+	PyObject_HEAD
+} PyObject;
+
+typedef struct {
+	PyObject_VAR_HEAD
+} PyVarObject;
+
+
+/*
+Type objects contain a string containing the type name (to help somewhat
+in debugging), the allocation parameters (see PyObject_New() and
+PyObject_NewVar()),
+and methods for accessing objects of the type.  Methods are optional, a
+nil pointer meaning that particular kind of access is not available for
+this type.  The Py_DECREF() macro uses the tp_dealloc method without
+checking for a nil pointer; it should always be implemented except if
+the implementation can guarantee that the reference count will never
+reach zero (e.g., for statically allocated type objects).
+
+NB: the methods for certain type groups are now contained in separate
+method blocks.
+*/
+
+typedef PyObject * (*unaryfunc)(PyObject *);
+typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
+typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
+typedef int (*inquiry)(PyObject *);
+typedef int (*coercion)(PyObject **, PyObject **);
+typedef PyObject *(*intargfunc)(PyObject *, int);
+typedef PyObject *(*intintargfunc)(PyObject *, int, int);
+typedef int(*intobjargproc)(PyObject *, int, PyObject *);
+typedef int(*intintobjargproc)(PyObject *, int, int, PyObject *);
+typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);
+typedef int (*getreadbufferproc)(PyObject *, int, void **);
+typedef int (*getwritebufferproc)(PyObject *, int, void **);
+typedef int (*getsegcountproc)(PyObject *, int *);
+typedef int (*getcharbufferproc)(PyObject *, int, const char **);
+typedef int (*objobjproc)(PyObject *, PyObject *);
+typedef int (*visitproc)(PyObject *, void *);
+typedef int (*traverseproc)(PyObject *, visitproc, void *);
+
+typedef struct {
+	/* For numbers without flag bit Py_TPFLAGS_CHECKTYPES set, all
+	   arguments are guaranteed to be of the object's type (modulo
+	   coercion hacks -- i.e. if the type's coercion function
+	   returns other types, then these are allowed as well).  Numbers that
+	   have the Py_TPFLAGS_CHECKTYPES flag bit set should check *both*
+	   arguments for proper type and implement the necessary conversions
+	   in the slot functions themselves. */
+
+	binaryfunc nb_add;
+	binaryfunc nb_subtract;
+	binaryfunc nb_multiply;
+	binaryfunc nb_divide;
+	binaryfunc nb_remainder;
+	binaryfunc nb_divmod;
+	ternaryfunc nb_power;
+	unaryfunc nb_negative;
+	unaryfunc nb_positive;
+	unaryfunc nb_absolute;
+	inquiry nb_nonzero;
+	unaryfunc nb_invert;
+	binaryfunc nb_lshift;
+	binaryfunc nb_rshift;
+	binaryfunc nb_and;
+	binaryfunc nb_xor;
+	binaryfunc nb_or;
+	coercion nb_coerce;
+	unaryfunc nb_int;
+	unaryfunc nb_long;
+	unaryfunc nb_float;
+	unaryfunc nb_oct;
+	unaryfunc nb_hex;
+	/* Added in release 2.0 */
+	binaryfunc nb_inplace_add;
+	binaryfunc nb_inplace_subtract;
+	binaryfunc nb_inplace_multiply;
+	binaryfunc nb_inplace_divide;
+	binaryfunc nb_inplace_remainder;
+	ternaryfunc nb_inplace_power;
+	binaryfunc nb_inplace_lshift;
+	binaryfunc nb_inplace_rshift;
+	binaryfunc nb_inplace_and;
+	binaryfunc nb_inplace_xor;
+	binaryfunc nb_inplace_or;
+
+	/* Added in release 2.2 */
+	/* The following require the Py_TPFLAGS_HAVE_CLASS flag */
+	binaryfunc nb_floor_divide;
+	binaryfunc nb_true_divide;
+	binaryfunc nb_inplace_floor_divide;
+	binaryfunc nb_inplace_true_divide;
+} PyNumberMethods;
+
+typedef struct {
+	inquiry sq_length;
+	binaryfunc sq_concat;
+	intargfunc sq_repeat;
+	intargfunc sq_item;
+	intintargfunc sq_slice;
+	intobjargproc sq_ass_item;
+	intintobjargproc sq_ass_slice;
+	objobjproc sq_contains;
+	/* Added in release 2.0 */
+	binaryfunc sq_inplace_concat;
+	intargfunc sq_inplace_repeat;
+} PySequenceMethods;
+
+typedef struct {
+	inquiry mp_length;
+	binaryfunc mp_subscript;
+	objobjargproc mp_ass_subscript;
+} PyMappingMethods;
+
+typedef struct {
+	getreadbufferproc bf_getreadbuffer;
+	getwritebufferproc bf_getwritebuffer;
+	getsegcountproc bf_getsegcount;
+	getcharbufferproc bf_getcharbuffer;
+} PyBufferProcs;
+
+
+typedef void (*freefunc)(void *);
+typedef void (*destructor)(PyObject *);
+typedef int (*printfunc)(PyObject *, FILE *, int);
+typedef PyObject *(*getattrfunc)(PyObject *, char *);
+typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
+typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
+typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
+typedef int (*cmpfunc)(PyObject *, PyObject *);
+typedef PyObject *(*reprfunc)(PyObject *);
+typedef long (*hashfunc)(PyObject *);
+typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
+typedef PyObject *(*getiterfunc) (PyObject *);
+typedef PyObject *(*iternextfunc) (PyObject *);
+typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
+typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
+typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
+typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
+typedef PyObject *(*allocfunc)(struct _typeobject *, int);
+
+typedef struct _typeobject {
+	PyObject_VAR_HEAD
+	char *tp_name; /* For printing, in format "<module>.<name>" */
+	int tp_basicsize, tp_itemsize; /* For allocation */
+
+	/* Methods to implement standard operations */
+
+	destructor tp_dealloc;
+	printfunc tp_print;
+	getattrfunc tp_getattr;
+	setattrfunc tp_setattr;
+	cmpfunc tp_compare;
+	reprfunc tp_repr;
+
+	/* Method suites for standard classes */
+
+	PyNumberMethods *tp_as_number;
+	PySequenceMethods *tp_as_sequence;
+	PyMappingMethods *tp_as_mapping;
+
+	/* More standard operations (here for binary compatibility) */
+
+	hashfunc tp_hash;
+	ternaryfunc tp_call;
+	reprfunc tp_str;
+	getattrofunc tp_getattro;
+	setattrofunc tp_setattro;
+
+	/* Functions to access object as input/output buffer */
+	PyBufferProcs *tp_as_buffer;
+
+	/* Flags to define presence of optional/expanded features */
+	long tp_flags;
+
+	char *tp_doc; /* Documentation string */
+
+	/* Assigned meaning in release 2.0 */
+	/* call function for all accessible objects */
+	traverseproc tp_traverse;
+
+	/* delete references to contained objects */
+	inquiry tp_clear;
+
+	/* Assigned meaning in release 2.1 */
+	/* rich comparisons */
+	richcmpfunc tp_richcompare;
+
+	/* weak reference enabler */
+	long tp_weaklistoffset;
+
+	/* Added in release 2.2 */
+	/* Iterators */
+	getiterfunc tp_iter;
+	iternextfunc tp_iternext;
+
+	/* Attribute descriptor and subclassing stuff */
+	struct PyMethodDef *tp_methods;
+	struct PyMemberDef *tp_members;
+	struct PyGetSetDef *tp_getset;
+	struct _typeobject *tp_base;
+	PyObject *tp_dict;
+	descrgetfunc tp_descr_get;
+	descrsetfunc tp_descr_set;
+	long tp_dictoffset;
+	initproc tp_init;
+	allocfunc tp_alloc;
+	newfunc tp_new;
+	freefunc tp_free; /* Low-level free-memory routine */
+	inquiry tp_is_gc; /* For PyObject_IS_GC */
+	PyObject *tp_bases;
+	PyObject *tp_mro; /* method resolution order */
+	PyObject *tp_cache;
+	PyObject *tp_subclasses;
+	PyObject *tp_weaklist;
+	destructor tp_del;
+
+#ifdef COUNT_ALLOCS
+	/* these must be last and never explicitly initialized */
+	int tp_allocs;
+	int tp_frees;
+	int tp_maxalloc;
+	struct _typeobject *tp_next;
+#endif
+} PyTypeObject;
+
+
+/* The *real* layout of a type object when allocated on the heap */
+typedef struct _heaptypeobject {
+	/* Note: there's a dependency on the order of these members
+	   in slotptr() in typeobject.c . */
+	PyTypeObject type;
+	PyNumberMethods as_number;
+	PyMappingMethods as_mapping;
+	PySequenceMethods as_sequence; /* as_sequence comes after as_mapping,
+					  so that the mapping wins when both
+					  the mapping and the sequence define
+					  a given operator (e.g. __getitem__).
+					  see add_operators() in typeobject.c . */
+	PyBufferProcs as_buffer;
+	PyObject *name, *slots;
+	/* here are optional user slots, followed by the members. */
+} PyHeapTypeObject;
+
+/* access macro to the members which are floating "behind" the object */
+#define PyHeapType_GET_MEMBERS(etype) \
+    ((PyMemberDef *)(((char *)etype) + (etype)->type.ob_type->tp_basicsize))
+
+
+/* Generic type check */
+PyAPI_FUNC(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);
+#define PyObject_TypeCheck(ob, tp) \
+	((ob)->ob_type == (tp) || PyType_IsSubtype((ob)->ob_type, (tp)))
+
+PyAPI_DATA(PyTypeObject) PyType_Type; /* built-in 'type' */
+PyAPI_DATA(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */
+PyAPI_DATA(PyTypeObject) PySuper_Type; /* built-in 'super' */
+
+#define PyType_Check(op) PyObject_TypeCheck(op, &PyType_Type)
+#define PyType_CheckExact(op) ((op)->ob_type == &PyType_Type)
+
+PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
+PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, int);
+PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
+					       PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyType_Lookup(PyTypeObject *, PyObject *);
+
+/* Generic operations on objects */
+PyAPI_FUNC(int) PyObject_Print(PyObject *, FILE *, int);
+PyAPI_FUNC(void) _PyObject_Dump(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
+#ifdef Py_USING_UNICODE
+PyAPI_FUNC(PyObject *) PyObject_Unicode(PyObject *);
+#endif
+PyAPI_FUNC(int) PyObject_Compare(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
+PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
+PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, char *);
+PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, char *, PyObject *);
+PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, char *);
+PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject **) _PyObject_GetDictPtr(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
+PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
+					      PyObject *, PyObject *);
+PyAPI_FUNC(long) PyObject_Hash(PyObject *);
+PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
+PyAPI_FUNC(int) PyObject_Not(PyObject *);
+PyAPI_FUNC(int) PyCallable_Check(PyObject *);
+PyAPI_FUNC(int) PyNumber_Coerce(PyObject **, PyObject **);
+PyAPI_FUNC(int) PyNumber_CoerceEx(PyObject **, PyObject **);
+
+PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
+
+/* A slot function whose address we need to compare */
+extern int _PyObject_SlotCompare(PyObject *, PyObject *);
+
+
+/* PyObject_Dir(obj) acts like Python __builtin__.dir(obj), returning a
+   list of strings.  PyObject_Dir(NULL) is like __builtin__.dir(),
+   returning the names of the current locals.  In this case, if there are
+   no current locals, NULL is returned, and PyErr_Occurred() is false.
+*/
+PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
+
+
+/* Helpers for printing recursive container types */
+PyAPI_FUNC(int) Py_ReprEnter(PyObject *);
+PyAPI_FUNC(void) Py_ReprLeave(PyObject *);
+
+/* Helpers for hash functions */
+PyAPI_FUNC(long) _Py_HashDouble(double);
+PyAPI_FUNC(long) _Py_HashPointer(void*);
+
+/* Helper for passing objects to printf and the like */
+#define PyObject_REPR(obj) PyString_AS_STRING(PyObject_Repr(obj))
+
+/* Flag bits for printing: */
+#define Py_PRINT_RAW	1	/* No string quotes etc. */
+
+/*
+`Type flags (tp_flags)
+
+These flags are used to extend the type structure in a backwards-compatible
+fashion. Extensions can use the flags to indicate (and test) when a given
+type structure contains a new feature. The Python core will use these when
+introducing new functionality between major revisions (to avoid mid-version
+changes in the PYTHON_API_VERSION).
+
+Arbitration of the flag bit positions will need to be coordinated among
+all extension writers who publically release their extensions (this will
+be fewer than you might expect!)..
+
+Python 1.5.2 introduced the bf_getcharbuffer slot into PyBufferProcs.
+
+Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.
+
+Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
+given type object has a specified feature.
+*/
+
+/* PyBufferProcs contains bf_getcharbuffer */
+#define Py_TPFLAGS_HAVE_GETCHARBUFFER  (1L<<0)
+
+/* PySequenceMethods contains sq_contains */
+#define Py_TPFLAGS_HAVE_SEQUENCE_IN (1L<<1)
+
+/* This is here for backwards compatibility.  Extensions that use the old GC
+ * API will still compile but the objects will not be tracked by the GC. */
+#define Py_TPFLAGS_GC 0 /* used to be (1L<<2) */
+
+/* PySequenceMethods and PyNumberMethods contain in-place operators */
+#define Py_TPFLAGS_HAVE_INPLACEOPS (1L<<3)
+
+/* PyNumberMethods do their own coercion */
+#define Py_TPFLAGS_CHECKTYPES (1L<<4)
+
+/* tp_richcompare is defined */
+#define Py_TPFLAGS_HAVE_RICHCOMPARE (1L<<5)
+
+/* Objects which are weakly referencable if their tp_weaklistoffset is >0 */
+#define Py_TPFLAGS_HAVE_WEAKREFS (1L<<6)
+
+/* tp_iter is defined */
+#define Py_TPFLAGS_HAVE_ITER (1L<<7)
+
+/* New members introduced by Python 2.2 exist */
+#define Py_TPFLAGS_HAVE_CLASS (1L<<8)
+
+/* Set if the type object is dynamically allocated */
+#define Py_TPFLAGS_HEAPTYPE (1L<<9)
+
+/* Set if the type allows subclassing */
+#define Py_TPFLAGS_BASETYPE (1L<<10)
+
+/* Set if the type is 'ready' -- fully initialized */
+#define Py_TPFLAGS_READY (1L<<12)
+
+/* Set while the type is being 'readied', to prevent recursive ready calls */
+#define Py_TPFLAGS_READYING (1L<<13)
+
+/* Objects support garbage collection (see objimp.h) */
+#define Py_TPFLAGS_HAVE_GC (1L<<14)
+
+/* These two bits are preserved for Stackless Python, next after this is 16 */
+#ifdef STACKLESS
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3L<<15)
+#else
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
+#endif
+
+#define Py_TPFLAGS_DEFAULT  ( \
+                             Py_TPFLAGS_HAVE_GETCHARBUFFER | \
+                             Py_TPFLAGS_HAVE_SEQUENCE_IN | \
+                             Py_TPFLAGS_HAVE_INPLACEOPS | \
+                             Py_TPFLAGS_HAVE_RICHCOMPARE | \
+                             Py_TPFLAGS_HAVE_WEAKREFS | \
+                             Py_TPFLAGS_HAVE_ITER | \
+                             Py_TPFLAGS_HAVE_CLASS | \
+                             Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
+                            0)
+
+#define PyType_HasFeature(t,f)  (((t)->tp_flags & (f)) != 0)
+
+
+/*
+The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
+reference counts.  Py_DECREF calls the object's deallocator function when
+the refcount falls to 0; for
+objects that don't contain references to other objects or heap memory
+this can be the standard function free().  Both macros can be used
+wherever a void expression is allowed.  The argument must not be a
+NIL pointer.  If it may be NIL, use Py_XINCREF/Py_XDECREF instead.
+The macro _Py_NewReference(op) initialize reference counts to 1, and
+in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
+bookkeeping appropriate to the special build.
+
+We assume that the reference count field can never overflow; this can
+be proven when the size of the field is the same as the pointer size, so
+we ignore the possibility.  Provided a C int is at least 32 bits (which
+is implicitly assumed in many parts of this code), that's enough for
+about 2**31 references to an object.
+
+XXX The following became out of date in Python 2.2, but I'm not sure
+XXX what the full truth is now.  Certainly, heap-allocated type objects
+XXX can and should be deallocated.
+Type objects should never be deallocated; the type pointer in an object
+is not considered to be a reference to the type object, to save
+complications in the deallocation function.  (This is actually a
+decision that's up to the implementer of each new type so if you want,
+you can count such references to the type object.)
+
+*** WARNING*** The Py_DECREF macro must have a side-effect-free argument
+since it may evaluate its argument multiple times.  (The alternative
+would be to mace it a proper function or assign it to a global temporary
+variable first, both of which are slower; and in a multi-threaded
+environment the global variable trick is not safe.)
+*/
+
+/* First define a pile of simple helper macros, one set per special
+ * build symbol.  These either expand to the obvious things, or to
+ * nothing at all when the special mode isn't in effect.  The main
+ * macros can later be defined just once then, yet expand to different
+ * things depending on which special build options are and aren't in effect.
+ * Trust me <wink>:  while painful, this is 20x easier to understand than,
+ * e.g, defining _Py_NewReference five different times in a maze of nested
+ * #ifdefs (we used to do that -- it was impenetrable).
+ */
+#ifdef Py_REF_DEBUG
+PyAPI_DATA(long) _Py_RefTotal;
+PyAPI_FUNC(void) _Py_NegativeRefcount(const char *fname,
+					    int lineno, PyObject *op);
+#define _Py_INC_REFTOTAL	_Py_RefTotal++
+#define _Py_DEC_REFTOTAL	_Py_RefTotal--
+#define _Py_REF_DEBUG_COMMA	,
+#define _Py_CHECK_REFCNT(OP)					\
+{	if ((OP)->ob_refcnt < 0)				\
+		_Py_NegativeRefcount(__FILE__, __LINE__,	\
+				     (PyObject *)(OP));		\
+}
+#else
+#define _Py_INC_REFTOTAL
+#define _Py_DEC_REFTOTAL
+#define _Py_REF_DEBUG_COMMA
+#define _Py_CHECK_REFCNT(OP)	/* a semicolon */;
+#endif /* Py_REF_DEBUG */
+
+#ifdef COUNT_ALLOCS
+PyAPI_FUNC(void) inc_count(PyTypeObject *);
+#define _Py_INC_TPALLOCS(OP)	inc_count((OP)->ob_type)
+#define _Py_INC_TPFREES(OP)	(OP)->ob_type->tp_frees++
+#define _Py_DEC_TPFREES(OP)	(OP)->ob_type->tp_frees--
+#define _Py_COUNT_ALLOCS_COMMA	,
+#else
+#define _Py_INC_TPALLOCS(OP)
+#define _Py_INC_TPFREES(OP)
+#define _Py_DEC_TPFREES(OP)
+#define _Py_COUNT_ALLOCS_COMMA
+#endif /* COUNT_ALLOCS */
+
+#ifdef Py_TRACE_REFS
+/* Py_TRACE_REFS is such major surgery that we call external routines. */
+PyAPI_FUNC(void) _Py_NewReference(PyObject *);
+PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
+PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
+PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
+PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
+PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
+
+#else
+/* Without Py_TRACE_REFS, there's little enough to do that we expand code
+ * inline.
+ */
+#define _Py_NewReference(op) (				\
+	_Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA	\
+	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA		\
+	(op)->ob_refcnt = 1)
+
+#define _Py_ForgetReference(op) _Py_INC_TPFREES(op)
+
+#define _Py_Dealloc(op) (				\
+	_Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA	\
+	(*(op)->ob_type->tp_dealloc)((PyObject *)(op)))
+#endif /* !Py_TRACE_REFS */
+
+#define Py_INCREF(op) (				\
+	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
+	(op)->ob_refcnt++)
+
+#define Py_DECREF(op)					\
+	if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
+	    --(op)->ob_refcnt != 0)			\
+		_Py_CHECK_REFCNT(op)			\
+	else						\
+		_Py_Dealloc((PyObject *)(op))
+
+#define Py_CLEAR(op)				\
+        do {                            	\
+                if (op) {			\
+                        PyObject *tmp = (PyObject *)(op);	\
+                        (op) = NULL;		\
+                        Py_DECREF(tmp);		\
+                }				\
+        } while (0)
+
+/* Macros to use in case the object pointer may be NULL: */
+#define Py_XINCREF(op) if ((op) == NULL) ; else Py_INCREF(op)
+#define Py_XDECREF(op) if ((op) == NULL) ; else Py_DECREF(op)
+
+/*
+These are provided as conveniences to Python runtime embedders, so that
+they can have object code that is not dependent on Python compilation flags.
+*/
+PyAPI_FUNC(void) Py_IncRef(PyObject *);
+PyAPI_FUNC(void) Py_DecRef(PyObject *);
+
+/*
+_Py_NoneStruct is an object of undefined type which can be used in contexts
+where NULL (nil) is not suitable (since NULL often means 'error').
+
+Don't forget to apply Py_INCREF() when returning this value!!!
+*/
+PyAPI_DATA(PyObject) _Py_NoneStruct; /* Don't use this directly */
+#define Py_None (&_Py_NoneStruct)
+
+/* Macro for returning Py_None from a function */
+#define Py_RETURN_NONE return Py_INCREF(Py_None), Py_None
+
+/*
+Py_NotImplemented is a singleton used to signal that an operation is
+not implemented for a given type combination.
+*/
+PyAPI_DATA(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */
+#define Py_NotImplemented (&_Py_NotImplementedStruct)
+
+/* Rich comparison opcodes */
+#define Py_LT 0
+#define Py_LE 1
+#define Py_EQ 2
+#define Py_NE 3
+#define Py_GT 4
+#define Py_GE 5
+
+/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.
+ * Defined in object.c.
+ */
+PyAPI_DATA(int) _Py_SwappedOp[];
+
+/*
+Define staticforward and statichere for source compatibility with old
+C extensions.
+
+The staticforward define was needed to support certain broken C
+compilers (notably SCO ODT 3.0, perhaps early AIX as well) botched the
+static keyword when it was used with a forward declaration of a static
+initialized structure.  Standard C allows the forward declaration with
+static, and we've decided to stop catering to broken C compilers.
+(In fact, we expect that the compilers are all fixed eight years later.)
+*/
+
+#define staticforward static
+#define statichere static
+
+
+/*
+More conventions
+================
+
+Argument Checking
+-----------------
+
+Functions that take objects as arguments normally don't check for nil
+arguments, but they do check the type of the argument, and return an
+error if the function doesn't apply to the type.
+
+Failure Modes
+-------------
+
+Functions may fail for a variety of reasons, including running out of
+memory.  This is communicated to the caller in two ways: an error string
+is set (see errors.h), and the function result differs: functions that
+normally return a pointer return NULL for failure, functions returning
+an integer return -1 (which could be a legal return value too!), and
+other functions return 0 for success and -1 for failure.
+Callers should always check for errors before using the result.  If
+an error was set, the caller must either explicitly clear it, or pass
+the error on to its caller.
+
+Reference Counts
+----------------
+
+It takes a while to get used to the proper usage of reference counts.
+
+Functions that create an object set the reference count to 1; such new
+objects must be stored somewhere or destroyed again with Py_DECREF().
+Some functions that 'store' objects, such as PyTuple_SetItem() and
+PyList_SetItem(),
+don't increment the reference count of the object, since the most
+frequent use is to store a fresh object.  Functions that 'retrieve'
+objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
+don't increment
+the reference count, since most frequently the object is only looked at
+quickly.  Thus, to retrieve an object and store it again, the caller
+must call Py_INCREF() explicitly.
+
+NOTE: functions that 'consume' a reference count, like
+PyList_SetItem(), consume the reference even if the object wasn't
+successfully stored, to simplify error handling.
+
+It seems attractive to make other functions that take an object as
+argument consume a reference count; however, this may quickly get
+confusing (even the current practice is already confusing).  Consider
+it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
+times.
+*/
+
+
+/* Trashcan mechanism, thanks to Christian Tismer.
+
+When deallocating a container object, it's possible to trigger an unbounded
+chain of deallocations, as each Py_DECREF in turn drops the refcount on "the
+next" object in the chain to 0.  This can easily lead to stack faults, and
+especially in threads (which typically have less stack space to work with).
+
+A container object that participates in cyclic gc can avoid this by
+bracketing the body of its tp_dealloc function with a pair of macros:
+
+static void
+mytype_dealloc(mytype *p)
+{
+        ... declarations go here ...
+
+ 	PyObject_GC_UnTrack(p);	   // must untrack first
+	Py_TRASHCAN_SAFE_BEGIN(p)
+	... The body of the deallocator goes here, including all calls ...
+	... to Py_DECREF on contained objects.                         ...
+	Py_TRASHCAN_SAFE_END(p)
+}
+
+CAUTION:  Never return from the middle of the body!  If the body needs to
+"get out early", put a label immediately before the Py_TRASHCAN_SAFE_END
+call, and goto it.  Else the call-depth counter (see below) will stay
+above 0 forever, and the trashcan will never get emptied.
+
+How it works:  The BEGIN macro increments a call-depth counter.  So long
+as this counter is small, the body of the deallocator is run directly without
+further ado.  But if the counter gets large, it instead adds p to a list of
+objects to be deallocated later, skips the body of the deallocator, and
+resumes execution after the END macro.  The tp_dealloc routine then returns
+without deallocating anything (and so unbounded call-stack depth is avoided).
+
+When the call stack finishes unwinding again, code generated by the END macro
+notices this, and calls another routine to deallocate all the objects that
+may have been added to the list of deferred deallocations.  In effect, a
+chain of N deallocations is broken into N / PyTrash_UNWIND_LEVEL pieces,
+with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
+*/
+
+PyAPI_FUNC(void) _PyTrash_deposit_object(PyObject*);
+PyAPI_FUNC(void) _PyTrash_destroy_chain(void);
+PyAPI_DATA(int) _PyTrash_delete_nesting;
+PyAPI_DATA(PyObject *) _PyTrash_delete_later;
+
+#define PyTrash_UNWIND_LEVEL 50
+
+#define Py_TRASHCAN_SAFE_BEGIN(op) \
+	if (_PyTrash_delete_nesting < PyTrash_UNWIND_LEVEL) { \
+		++_PyTrash_delete_nesting;
+		/* The body of the deallocator is here. */
+#define Py_TRASHCAN_SAFE_END(op) \
+		--_PyTrash_delete_nesting; \
+		if (_PyTrash_delete_later && _PyTrash_delete_nesting <= 0) \
+			_PyTrash_destroy_chain(); \
+	} \
+	else \
+		_PyTrash_deposit_object((PyObject*)op);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OBJECT_H */

Added: trunk/mingw-libs/include/objimpl.h
===================================================================
--- trunk/mingw-libs/include/objimpl.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/objimpl.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,340 @@
+/* The PyObject_ memory family:  high-level object memory interfaces.
+   See pymem.h for the low-level PyMem_ family.
+*/
+
+#ifndef Py_OBJIMPL_H
+#define Py_OBJIMPL_H
+
+#include "pymem.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* BEWARE:
+
+   Each interface exports both functions and macros.  Extension modules should
+   use the functions, to ensure binary compatibility across Python versions.
+   Because the Python implementation is free to change internal details, and
+   the macros may (or may not) expose details for speed, if you do use the
+   macros you must recompile your extensions with each Python release.
+
+   Never mix calls to PyObject_ memory functions with calls to the platform
+   malloc/realloc/ calloc/free, or with calls to PyMem_.
+*/
+
+/*
+Functions and macros for modules that implement new object types.
+
+ - PyObject_New(type, typeobj) allocates memory for a new object of the given
+   type, and initializes part of it.  'type' must be the C structure type used
+   to represent the object, and 'typeobj' the address of the corresponding
+   type object.  Reference count and type pointer are filled in; the rest of
+   the bytes of the object are *undefined*!  The resulting expression type is
+   'type *'.  The size of the object is determined by the tp_basicsize field
+   of the type object.
+
+ - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
+   object with room for n items.  In addition to the refcount and type pointer
+   fields, this also fills in the ob_size field.
+
+ - PyObject_Del(op) releases the memory allocated for an object.  It does not
+   run a destructor -- it only frees the memory.  PyObject_Free is identical.
+
+ - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
+   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
+   new object (allocated by an arbitrary allocator), and initialize its object
+   header fields.
+
+Note that objects created with PyObject_{New, NewVar} are allocated using the
+specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
+enabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG
+is also #defined.
+
+In case a specific form of memory management is needed (for example, if you
+must use the platform malloc heap(s), or shared memory, or C++ local storage or
+operator new), you must first allocate the object with your custom allocator,
+then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
+specific fields:  reference count, type pointer, possibly others.  You should
+be aware that Python no control over these objects because they don't
+cooperate with the Python memory manager.  Such objects may not be eligible
+for automatic garbage collection and you have to make sure that they are
+released accordingly whenever their destructor gets called (cf. the specific
+form of memory management you're using).
+
+Unless you have specific memory management requirements, use
+PyObject_{New, NewVar, Del}.
+*/
+
+/*
+ * Raw object memory interface
+ * ===========================
+ */
+
+/* Functions to call the same malloc/realloc/free as used by Python's
+   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
+   the platform malloc/realloc/free.  The Python object allocator is
+   designed for fast, cache-conscious allocation of many "small" objects,
+   and with low hidden memory overhead.
+
+   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.
+
+   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
+   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
+   at p.
+
+   Returned pointers must be checked for NULL explicitly; no action is
+   performed on failure other than to return NULL (no warning it printed, no
+   exception is set, etc).
+
+   For allocating objects, use PyObject_{New, NewVar} instead whenever
+   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
+   so that you can exploit Python's small-block allocator for non-object
+   uses.  If you must use these routines to allocate object memory, make sure
+   the object gets initialized via PyObject_{Init, InitVar} after obtaining
+   the raw memory.
+*/
+PyAPI_FUNC(void *) PyObject_Malloc(size_t);
+PyAPI_FUNC(void *) PyObject_Realloc(void *, size_t);
+PyAPI_FUNC(void) PyObject_Free(void *);
+
+
+/* Macros */
+#ifdef WITH_PYMALLOC
+#ifdef PYMALLOC_DEBUG
+PyAPI_FUNC(void *) _PyObject_DebugMalloc(size_t nbytes);
+PyAPI_FUNC(void *) _PyObject_DebugRealloc(void *p, size_t nbytes);
+PyAPI_FUNC(void) _PyObject_DebugFree(void *p);
+PyAPI_FUNC(void) _PyObject_DebugDumpAddress(const void *p);
+PyAPI_FUNC(void) _PyObject_DebugCheckAddress(const void *p);
+PyAPI_FUNC(void) _PyObject_DebugMallocStats(void);
+#define PyObject_MALLOC		_PyObject_DebugMalloc
+#define PyObject_Malloc		_PyObject_DebugMalloc
+#define PyObject_REALLOC	_PyObject_DebugRealloc
+#define PyObject_Realloc	_PyObject_DebugRealloc
+#define PyObject_FREE		_PyObject_DebugFree
+#define PyObject_Free		_PyObject_DebugFree
+
+#else	/* WITH_PYMALLOC && ! PYMALLOC_DEBUG */
+#define PyObject_MALLOC		PyObject_Malloc
+#define PyObject_REALLOC	PyObject_Realloc
+#define PyObject_FREE		PyObject_Free
+#endif
+
+#else	/* ! WITH_PYMALLOC */
+#define PyObject_MALLOC		PyMem_MALLOC
+#define PyObject_REALLOC	PyMem_REALLOC
+/* This is an odd one!  For backward compatability with old extensions, the
+   PyMem "release memory" functions have to invoke the object allocator's
+   free() function.  When pymalloc isn't enabled, that leaves us using
+   the platform free(). */
+#define PyObject_FREE		free
+
+#endif	/* WITH_PYMALLOC */
+
+#define PyObject_Del		PyObject_Free
+#define PyObject_DEL		PyObject_FREE
+
+/* for source compatibility with 2.2 */
+#define _PyObject_Del		PyObject_Free
+
+/*
+ * Generic object allocator interface
+ * ==================================
+ */
+
+/* Functions */
+PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
+                                                 PyTypeObject *, int);
+PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, int);
+
+#define PyObject_New(type, typeobj) \
+		( (type *) _PyObject_New(typeobj) )
+#define PyObject_NewVar(type, typeobj, n) \
+		( (type *) _PyObject_NewVar((typeobj), (n)) )
+
+/* Macros trading binary compatibility for speed. See also pymem.h.
+   Note that these macros expect non-NULL object pointers.*/
+#define PyObject_INIT(op, typeobj) \
+	( (op)->ob_type = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
+#define PyObject_INIT_VAR(op, typeobj, size) \
+	( (op)->ob_size = (size), PyObject_INIT((op), (typeobj)) )
+
+#define _PyObject_SIZE(typeobj) ( (typeobj)->tp_basicsize )
+
+/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
+   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
+   value is rounded up to the closest multiple of sizeof(void *), in order to
+   ensure that pointer fields at the end of the object are correctly aligned
+   for the platform (this is of special importance for subclasses of, e.g.,
+   str or long, so that pointers can be stored after the embedded data).
+
+   Note that there's no memory wastage in doing this, as malloc has to
+   return (at worst) pointer-aligned memory anyway.
+*/
+#if ((SIZEOF_VOID_P - 1) & SIZEOF_VOID_P) != 0
+#   error "_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2"
+#endif
+
+#define _PyObject_VAR_SIZE(typeobj, nitems)	\
+	(size_t)				\
+	( ( (typeobj)->tp_basicsize +		\
+	    (nitems)*(typeobj)->tp_itemsize +	\
+	    (SIZEOF_VOID_P - 1)			\
+	  ) & ~(SIZEOF_VOID_P - 1)		\
+	)
+
+#define PyObject_NEW(type, typeobj) \
+( (type *) PyObject_Init( \
+	(PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )
+
+#define PyObject_NEW_VAR(type, typeobj, n) \
+( (type *) PyObject_InitVar( \
+      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\
+      (typeobj), (n)) )
+
+/* This example code implements an object constructor with a custom
+   allocator, where PyObject_New is inlined, and shows the important
+   distinction between two steps (at least):
+       1) the actual allocation of the object storage;
+       2) the initialization of the Python specific fields
+          in this storage with PyObject_{Init, InitVar}.
+
+   PyObject *
+   YourObject_New(...)
+   {
+       PyObject *op;
+
+       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));
+       if (op == NULL)
+           return PyErr_NoMemory();
+
+       PyObject_Init(op, &YourTypeStruct);
+
+       op->ob_field = value;
+       ...
+       return op;
+   }
+
+   Note that in C++, the use of the new operator usually implies that
+   the 1st step is performed automatically for you, so in a C++ class
+   constructor you would start directly with PyObject_Init/InitVar
+*/
+
+/*
+ * Garbage Collection Support
+ * ==========================
+ */
+
+/* C equivalent of gc.collect(). */
+long PyGC_Collect(void);
+
+/* Test if a type has a GC head */
+#define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)
+
+/* Test if an object has a GC head */
+#define PyObject_IS_GC(o) (PyType_IS_GC((o)->ob_type) && \
+	((o)->ob_type->tp_is_gc == NULL || (o)->ob_type->tp_is_gc(o)))
+
+PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, int);
+#define PyObject_GC_Resize(type, op, n) \
+		( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )
+
+/* for source compatibility with 2.2 */
+#define _PyObject_GC_Del PyObject_GC_Del
+
+/* GC information is stored BEFORE the object structure. */
+typedef union _gc_head {
+	struct {
+		union _gc_head *gc_next;
+		union _gc_head *gc_prev;
+		int gc_refs;
+	} gc;
+	long double dummy;  /* force worst-case alignment */
+} PyGC_Head;
+
+extern PyGC_Head *_PyGC_generation0;
+
+#define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)
+
+#define _PyGC_REFS_UNTRACKED			(-2)
+#define _PyGC_REFS_REACHABLE			(-3)
+#define _PyGC_REFS_TENTATIVELY_UNREACHABLE	(-4)
+
+/* Tell the GC to track this object.  NB: While the object is tracked the
+ * collector it must be safe to call the ob_traverse method. */
+#define _PyObject_GC_TRACK(o) do { \
+	PyGC_Head *g = _Py_AS_GC(o); \
+	if (g->gc.gc_refs != _PyGC_REFS_UNTRACKED) \
+		Py_FatalError("GC object already tracked"); \
+	g->gc.gc_refs = _PyGC_REFS_REACHABLE; \
+	g->gc.gc_next = _PyGC_generation0; \
+	g->gc.gc_prev = _PyGC_generation0->gc.gc_prev; \
+	g->gc.gc_prev->gc.gc_next = g; \
+	_PyGC_generation0->gc.gc_prev = g; \
+    } while (0);
+
+/* Tell the GC to stop tracking this object.
+ * gc_next doesn't need to be set to NULL, but doing so is a good
+ * way to provoke memory errors if calling code is confused.
+ */
+#define _PyObject_GC_UNTRACK(o) do { \
+	PyGC_Head *g = _Py_AS_GC(o); \
+	assert(g->gc.gc_refs != _PyGC_REFS_UNTRACKED); \
+	g->gc.gc_refs = _PyGC_REFS_UNTRACKED; \
+	g->gc.gc_prev->gc.gc_next = g->gc.gc_next; \
+	g->gc.gc_next->gc.gc_prev = g->gc.gc_prev; \
+	g->gc.gc_next = NULL; \
+    } while (0);
+
+PyAPI_FUNC(PyObject *) _PyObject_GC_Malloc(size_t);
+PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
+PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, int);
+PyAPI_FUNC(void) PyObject_GC_Track(void *);
+PyAPI_FUNC(void) PyObject_GC_UnTrack(void *);
+PyAPI_FUNC(void) PyObject_GC_Del(void *);
+
+#define PyObject_GC_New(type, typeobj) \
+		( (type *) _PyObject_GC_New(typeobj) )
+#define PyObject_GC_NewVar(type, typeobj, n) \
+		( (type *) _PyObject_GC_NewVar((typeobj), (n)) )
+
+
+/* Utility macro to help write tp_traverse functions.
+ * To use this macro, the tp_traverse function must name its arguments
+ * "visit" and "arg".  This is intended to keep tp_traverse functions
+ * looking as much alike as possible.
+ */
+#define Py_VISIT(op)					\
+        do { 						\
+                if (op) {				\
+                        int vret = visit((op), arg);	\
+                        if (vret)			\
+                                return vret;		\
+                }					\
+        } while (0)
+
+/* This is here for the sake of backwards compatibility.  Extensions that
+ * use the old GC API will still compile but the objects will not be
+ * tracked by the GC. */
+#define PyGC_HEAD_SIZE 0
+#define PyObject_GC_Init(op)
+#define PyObject_GC_Fini(op)
+#define PyObject_AS_GC(op) (op)
+#define PyObject_FROM_GC(op) (op)
+
+
+/* Test if a type supports weak references */
+#define PyType_SUPPORTS_WEAKREFS(t) \
+        (PyType_HasFeature((t), Py_TPFLAGS_HAVE_WEAKREFS) \
+         && ((t)->tp_weaklistoffset > 0))
+
+#define PyObject_GET_WEAKREFS_LISTPTR(o) \
+	((PyObject **) (((char *) (o)) + (o)->ob_type->tp_weaklistoffset))
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OBJIMPL_H */

Added: trunk/mingw-libs/include/opcode.h
===================================================================
--- trunk/mingw-libs/include/opcode.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/opcode.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,153 @@
+#ifndef Py_OPCODE_H
+#define Py_OPCODE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Instruction opcodes for compiled code */
+
+#define STOP_CODE	0
+#define POP_TOP		1
+#define ROT_TWO		2
+#define ROT_THREE	3
+#define DUP_TOP		4
+#define ROT_FOUR	5
+#define NOP		9
+
+#define UNARY_POSITIVE	10
+#define UNARY_NEGATIVE	11
+#define UNARY_NOT	12
+#define UNARY_CONVERT	13
+
+#define UNARY_INVERT	15
+
+#define LIST_APPEND	18
+#define BINARY_POWER	19
+
+#define BINARY_MULTIPLY	20
+#define BINARY_DIVIDE	21
+#define BINARY_MODULO	22
+#define BINARY_ADD	23
+#define BINARY_SUBTRACT	24
+#define BINARY_SUBSCR	25
+#define BINARY_FLOOR_DIVIDE 26
+#define BINARY_TRUE_DIVIDE 27
+#define INPLACE_FLOOR_DIVIDE 28
+#define INPLACE_TRUE_DIVIDE 29
+
+#define SLICE		30
+/* Also uses 31-33 */
+
+#define STORE_SLICE	40
+/* Also uses 41-43 */
+
+#define DELETE_SLICE	50
+/* Also uses 51-53 */
+
+#define INPLACE_ADD	55
+#define INPLACE_SUBTRACT	56
+#define INPLACE_MULTIPLY	57
+#define INPLACE_DIVIDE	58
+#define INPLACE_MODULO	59
+#define STORE_SUBSCR	60
+#define DELETE_SUBSCR	61
+
+#define BINARY_LSHIFT	62
+#define BINARY_RSHIFT	63
+#define BINARY_AND	64
+#define BINARY_XOR	65
+#define BINARY_OR	66
+#define INPLACE_POWER	67
+#define GET_ITER	68
+
+#define PRINT_EXPR	70
+#define PRINT_ITEM	71
+#define PRINT_NEWLINE	72
+#define PRINT_ITEM_TO   73
+#define PRINT_NEWLINE_TO 74
+#define INPLACE_LSHIFT	75
+#define INPLACE_RSHIFT	76
+#define INPLACE_AND	77
+#define INPLACE_XOR	78
+#define INPLACE_OR	79
+#define BREAK_LOOP	80
+
+#define LOAD_LOCALS	82
+#define RETURN_VALUE	83
+#define IMPORT_STAR	84
+#define EXEC_STMT	85
+#define YIELD_VALUE	86
+
+#define POP_BLOCK	87
+#define END_FINALLY	88
+#define BUILD_CLASS	89
+
+#define HAVE_ARGUMENT	90	/* Opcodes from here have an argument: */
+
+#define STORE_NAME	90	/* Index in name list */
+#define DELETE_NAME	91	/* "" */
+#define UNPACK_SEQUENCE	92	/* Number of sequence items */
+#define FOR_ITER	93
+
+#define STORE_ATTR	95	/* Index in name list */
+#define DELETE_ATTR	96	/* "" */
+#define STORE_GLOBAL	97	/* "" */
+#define DELETE_GLOBAL	98	/* "" */
+#define DUP_TOPX	99	/* number of items to duplicate */
+#define LOAD_CONST	100	/* Index in const list */
+#define LOAD_NAME	101	/* Index in name list */
+#define BUILD_TUPLE	102	/* Number of tuple items */
+#define BUILD_LIST	103	/* Number of list items */
+#define BUILD_MAP	104	/* Always zero for now */
+#define LOAD_ATTR	105	/* Index in name list */
+#define COMPARE_OP	106	/* Comparison operator */
+#define IMPORT_NAME	107	/* Index in name list */
+#define IMPORT_FROM	108	/* Index in name list */
+
+#define JUMP_FORWARD	110	/* Number of bytes to skip */
+#define JUMP_IF_FALSE	111	/* "" */
+#define JUMP_IF_TRUE	112	/* "" */
+#define JUMP_ABSOLUTE	113	/* Target byte offset from beginning of code */
+
+#define LOAD_GLOBAL	116	/* Index in name list */
+
+#define CONTINUE_LOOP	119	/* Start of loop (absolute) */
+#define SETUP_LOOP	120	/* Target address (absolute) */
+#define SETUP_EXCEPT	121	/* "" */
+#define SETUP_FINALLY	122	/* "" */
+
+#define LOAD_FAST	124	/* Local variable number */
+#define STORE_FAST	125	/* Local variable number */
+#define DELETE_FAST	126	/* Local variable number */
+
+#define RAISE_VARARGS	130	/* Number of raise arguments (1, 2 or 3) */
+/* CALL_FUNCTION_XXX opcodes defined below depend on this definition */
+#define CALL_FUNCTION	131	/* #args + (#kwargs<<8) */
+#define MAKE_FUNCTION	132	/* #defaults */
+#define BUILD_SLICE 	133	/* Number of items */
+
+#define MAKE_CLOSURE    134     /* #free vars */
+#define LOAD_CLOSURE    135     /* Load free variable from closure */
+#define LOAD_DEREF      136     /* Load and dereference from closure cell */ 
+#define STORE_DEREF     137     /* Store into cell */ 
+
+/* The next 3 opcodes must be contiguous and satisfy
+   (CALL_FUNCTION_VAR - CALL_FUNCTION) & 3 == 1  */
+#define CALL_FUNCTION_VAR          140	/* #args + (#kwargs<<8) */
+#define CALL_FUNCTION_KW           141	/* #args + (#kwargs<<8) */
+#define CALL_FUNCTION_VAR_KW       142	/* #args + (#kwargs<<8) */
+
+/* Support for opargs more than 16 bits long */
+#define EXTENDED_ARG  143
+
+
+enum cmp_op {PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE, PyCmp_GT=Py_GT, PyCmp_GE=Py_GE,
+	     PyCmp_IN, PyCmp_NOT_IN, PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD};
+
+#define HAS_ARG(op) ((op) >= HAVE_ARGUMENT)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OPCODE_H */

Added: trunk/mingw-libs/include/osdefs.h
===================================================================
--- trunk/mingw-libs/include/osdefs.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/osdefs.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,51 @@
+#ifndef Py_OSDEFS_H
+#define Py_OSDEFS_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Operating system dependencies */
+
+/* Mod by chrish: QNX has WATCOM, but isn't DOS */
+#if !defined(__QNX__)
+#if defined(MS_WINDOWS) || defined(__BORLANDC__) || defined(__WATCOMC__) || defined(__DJGPP__) || defined(PYOS_OS2)
+#if defined(PYOS_OS2) && defined(PYCC_GCC)
+#define MAXPATHLEN 260
+#define SEP '/'
+#define ALTSEP '\\'
+#else
+#define SEP '\\'
+#define ALTSEP '/'
+#define MAXPATHLEN 256
+#endif
+#define DELIM ';'
+#endif
+#endif
+
+#ifdef RISCOS
+#define SEP '.'
+#define MAXPATHLEN 256
+#define DELIM ','
+#endif
+
+
+/* Filename separator */
+#ifndef SEP
+#define SEP '/'
+#endif
+
+/* Max pathname length */
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
+/* Search path entry delimiter */
+#ifndef DELIM
+#define DELIM ':'
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_OSDEFS_H */

Added: trunk/mingw-libs/include/parsetok.h
===================================================================
--- trunk/mingw-libs/include/parsetok.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/parsetok.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,48 @@
+
+/* Parser-tokenizer link interface */
+
+#ifndef Py_PARSETOK_H
+#define Py_PARSETOK_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct {
+    int error;
+    const char *filename;
+    int lineno;
+    int offset;
+    char *text;
+    int token;
+    int expected;
+} perrdetail;
+
+#if 0
+#define PyPARSE_YIELD_IS_KEYWORD	0x0001
+#endif
+
+#define PyPARSE_DONT_IMPLY_DEDENT	0x0002
+
+PyAPI_FUNC(node *) PyParser_ParseString(const char *, grammar *, int,
+                                              perrdetail *);
+PyAPI_FUNC(node *) PyParser_ParseFile (FILE *, const char *, grammar *, int,
+                                             char *, char *, perrdetail *);
+
+PyAPI_FUNC(node *) PyParser_ParseStringFlags(const char *, grammar *, int,
+                                              perrdetail *, int);
+PyAPI_FUNC(node *) PyParser_ParseFileFlags(FILE *, const char *, grammar *,
+						 int, char *, char *,
+						 perrdetail *, int);
+
+PyAPI_FUNC(node *) PyParser_ParseStringFlagsFilename(const char *,
+					      const char *,
+					      grammar *, int,
+                                              perrdetail *, int);
+
+/* Note that he following function is defined in pythonrun.c not parsetok.c. */
+PyAPI_FUNC(void) PyParser_SetError(perrdetail *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PARSETOK_H */

Added: trunk/mingw-libs/include/patchlevel.h
===================================================================
--- trunk/mingw-libs/include/patchlevel.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/patchlevel.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,37 @@
+
+/* Newfangled version identification scheme.
+
+   This scheme was added in Python 1.5.2b2; before that time, only PATCHLEVEL
+   was available.  To test for presence of the scheme, test for
+   defined(PY_MAJOR_VERSION).
+
+   When the major or minor version changes, the VERSION variable in
+   configure.in must also be changed.
+
+   There is also (independent) API version information in modsupport.h.
+*/
+
+/* Values for PY_RELEASE_LEVEL */
+#define PY_RELEASE_LEVEL_ALPHA	0xA
+#define PY_RELEASE_LEVEL_BETA	0xB
+#define PY_RELEASE_LEVEL_GAMMA	0xC     /* For release candidates */
+#define PY_RELEASE_LEVEL_FINAL	0xF	/* Serial should be 0 here */
+					/* Higher for patch releases */
+
+/* Version parsed out into numeric values */
+#define PY_MAJOR_VERSION	2
+#define PY_MINOR_VERSION	4
+#define PY_MICRO_VERSION	0
+#define PY_RELEASE_LEVEL	PY_RELEASE_LEVEL_FINAL
+#define PY_RELEASE_SERIAL	0
+
+/* Version as a string */
+#define PY_VERSION		"2.4"
+
+/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
+   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX >= ... */
+#define PY_VERSION_HEX ((PY_MAJOR_VERSION << 24) | \
+			(PY_MINOR_VERSION << 16) | \
+			(PY_MICRO_VERSION <<  8) | \
+			(PY_RELEASE_LEVEL <<  4) | \
+			(PY_RELEASE_SERIAL << 0))

Added: trunk/mingw-libs/include/pgen.h
===================================================================
--- trunk/mingw-libs/include/pgen.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pgen.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,18 @@
+#ifndef Py_PGEN_H
+#define Py_PGEN_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Parser generator interface */
+
+extern grammar *meta_grammar(void);
+
+struct _node;
+extern grammar *pgen(struct _node *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PGEN_H */

Added: trunk/mingw-libs/include/pgenheaders.h
===================================================================
--- trunk/mingw-libs/include/pgenheaders.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pgenheaders.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,42 @@
+#ifndef Py_PGENHEADERS_H
+#define Py_PGENHEADERS_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Include files and extern declarations used by most of the parser. */
+
+#include "Python.h"
+
+PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+
+#define addarc _Py_addarc
+#define addbit _Py_addbit
+#define adddfa _Py_adddfa
+#define addfirstsets _Py_addfirstsets
+#define addlabel _Py_addlabel
+#define addstate _Py_addstate
+#define delbitset _Py_delbitset
+#define dumptree _Py_dumptree
+#define findlabel _Py_findlabel
+#define mergebitset _Py_mergebitset
+#define meta_grammar _Py_meta_grammar
+#define newbitset _Py_newbitset
+#define newgrammar _Py_newgrammar
+#define pgen _Py_pgen
+#define printgrammar _Py_printgrammar
+#define printnonterminals _Py_printnonterminals
+#define printtree _Py_printtree
+#define samebitset _Py_samebitset
+#define showtree _Py_showtree
+#define tok_dump _Py_tok_dump
+#define translatelabels _Py_translatelabels
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PGENHEADERS_H */

Added: trunk/mingw-libs/include/py_curses.h
===================================================================
--- trunk/mingw-libs/include/py_curses.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/py_curses.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,176 @@
+
+#ifndef Py_CURSES_H
+#define Py_CURSES_H
+
+#ifdef __APPLE__
+/*
+** On Mac OS X 10.2 [n]curses.h and stdlib.h use different guards
+** against multiple definition of wchar_t.
+*/
+#ifdef	_BSD_WCHAR_T_DEFINED_
+#define _WCHAR_T
+#endif
+#endif
+
+#ifdef __FreeBSD__
+/*
+** On FreeBSD, [n]curses.h and stdlib.h/wchar.h use different guards
+** against multiple definition of wchar_t and wint_t.
+*/
+#ifdef	_XOPEN_SOURCE_EXTENDED
+#ifndef __FreeBSD_version
+#include <osreldate.h>
+#endif
+#if __FreeBSD_version >= 500000
+#ifndef __wchar_t
+#define __wchar_t
+#endif
+#ifndef __wint_t
+#define __wint_t
+#endif
+#else
+#ifndef _WCHAR_T
+#define _WCHAR_T
+#endif
+#ifndef _WINT_T
+#define _WINT_T
+#endif
+#endif
+#endif
+#endif
+
+#ifdef HAVE_NCURSES_H
+#include <ncurses.h>
+#else
+#include <curses.h>
+#ifdef HAVE_TERM_H
+/* for tigetstr, which is not declared in SysV curses */
+#include <term.h>
+#endif
+#endif
+
+#ifdef HAVE_NCURSES_H
+/* configure was checking <curses.h>, but we will
+   use <ncurses.h>, which has all these features. */
+#ifndef WINDOW_HAS_FLAGS
+#define WINDOW_HAS_FLAGS 1
+#endif
+#ifndef MVWDELCH_IS_EXPRESSION
+#define MVWDELCH_IS_EXPRESSION 1
+#endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PyCurses_API_pointers 4
+
+/* Type declarations */
+
+typedef struct {
+	PyObject_HEAD
+	WINDOW *win;
+} PyCursesWindowObject;
+
+#define PyCursesWindow_Check(v)	 ((v)->ob_type == &PyCursesWindow_Type)
+
+#ifdef CURSES_MODULE
+/* This section is used when compiling _cursesmodule.c */
+
+#else
+/* This section is used in modules that use the _cursesmodule API */
+
+static void **PyCurses_API;
+
+#define PyCursesWindow_Type (*(PyTypeObject *) PyCurses_API[0])
+#define PyCursesSetupTermCalled  {if (! ((int (*)(void))PyCurses_API[1]) () ) return NULL;}
+#define PyCursesInitialised      {if (! ((int (*)(void))PyCurses_API[2]) () ) return NULL;}
+#define PyCursesInitialisedColor {if (! ((int (*)(void))PyCurses_API[3]) () ) return NULL;}
+
+#define import_curses() \
+{ \
+  PyObject *module = PyImport_ImportModule("_curses"); \
+  if (module != NULL) { \
+    PyObject *module_dict = PyModule_GetDict(module); \
+    PyObject *c_api_object = PyDict_GetItemString(module_dict, "_C_API"); \
+    if (PyCObject_Check(c_api_object)) { \
+      PyCurses_API = (void **)PyCObject_AsVoidPtr(c_api_object); \
+    } \
+  } \
+}
+#endif
+
+/* general error messages */
+static char *catchall_ERR  = "curses function returned ERR";
+static char *catchall_NULL = "curses function returned NULL";
+
+/* Function Prototype Macros - They are ugly but very, very useful. ;-)
+
+   X - function name
+   TYPE - parameter Type
+   ERGSTR - format string for construction of the return value
+   PARSESTR - format string for argument parsing
+   */
+
+#define NoArgNoReturnFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  return PyCursesCheckERR(X(), # X); }
+
+#define NoArgOrFlagNoReturnFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self, PyObject *args) \
+{ \
+  int flag = 0; \
+  PyCursesInitialised \
+  switch(PyTuple_Size(args)) { \
+  case 0: \
+    return PyCursesCheckERR(X(), # X); \
+  case 1: \
+    if (!PyArg_ParseTuple(args, "i;True(1) or False(0)", &flag)) return NULL; \
+    if (flag) return PyCursesCheckERR(X(), # X); \
+    else return PyCursesCheckERR(no ## X (), # X); \
+  default: \
+    PyErr_SetString(PyExc_TypeError, # X " requires 0 or 1 arguments"); \
+    return NULL; } }
+
+#define NoArgReturnIntFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+ PyCursesInitialised \
+ return PyInt_FromLong((long) X()); }
+
+
+#define NoArgReturnStringFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  return PyString_FromString(X()); }
+
+#define NoArgTrueFalseFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  if (X () == FALSE) { \
+    Py_INCREF(Py_False); \
+    return Py_False; \
+  } \
+  Py_INCREF(Py_True); \
+  return Py_True; }
+
+#define NoArgNoReturnVoidFunction(X) \
+static PyObject *PyCurses_ ## X (PyObject *self) \
+{ \
+  PyCursesInitialised \
+  X(); \
+  Py_INCREF(Py_None); \
+  return Py_None; }
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !defined(Py_CURSES_H) */
+
+

Added: trunk/mingw-libs/include/pyconfig.h
===================================================================
--- trunk/mingw-libs/include/pyconfig.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyconfig.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,565 @@
+#ifndef Py_CONFIG_H
+#define Py_CONFIG_H
+
+/* pyconfig.h.  NOT Generated automatically by configure.
+
+This is a manually maintained version used for the Watcom,
+Borland and Microsoft Visual C++ compilers.  It is a
+standard part of the Python distribution.
+
+WINDOWS DEFINES:
+The code specific to Windows should be wrapped around one of
+the following #defines
+
+MS_WIN64 - Code specific to the MS Win64 API
+MS_WIN32 - Code specific to the MS Win32 (and Win64) API (obsolete, this covers all supported APIs)
+MS_WINDOWS - Code specific to Windows, but all versions.
+Py_ENABLE_SHARED - Code if the Python core is built as a DLL.
+
+Also note that neither "_M_IX86" or "_MSC_VER" should be used for
+any purpose other than "Windows Intel x86 specific" and "Microsoft
+compiler specific".  Therefore, these should be very rare.
+
+
+NOTE: The following symbols are deprecated:
+NT, WIN32, USE_DL_EXPORT, USE_DL_IMPORT, DL_EXPORT, DL_IMPORT
+MS_CORE_DLL.
+
+*/
+
+#include <io.h>
+#define HAVE_SYS_UTIME_H
+#define HAVE_HYPOT
+#define HAVE_TEMPNAM
+#define HAVE_TMPFILE
+#define HAVE_TMPNAM
+#define HAVE_CLOCK
+#define HAVE_STRFTIME
+#define HAVE_STRERROR
+#define DONT_HAVE_SIG_ALARM
+#define DONT_HAVE_SIG_PAUSE
+#define LONG_BIT	32
+#define WORD_BIT 32
+#define PREFIX ""
+#define EXEC_PREFIX ""
+
+#define MS_WIN32 /* only support win32 and greater. */
+#define MS_WINDOWS
+#ifndef PYTHONPATH
+#	define PYTHONPATH ".\\DLLs;.\\lib;.\\lib\\plat-win;.\\lib\\lib-tk"
+#endif
+#define NT_THREADS
+#define WITH_THREAD
+#ifndef NETSCAPE_PI
+#define USE_SOCKET
+#endif
+
+/* Compiler specific defines */
+
+/* ------------------------------------------------------------------------*/
+/* Microsoft C defines _MSC_VER */
+#ifdef _MSC_VER
+
+/* We want COMPILER to expand to a string containing _MSC_VER's *value*.
+ * This is horridly tricky, because the stringization operator only works
+ * on macro arguments, and doesn't evaluate macros passed *as* arguments.
+ * Attempts simpler than the following appear doomed to produce "_MSC_VER"
+ * literally in the string.
+ */
+#define _Py_PASTE_VERSION(SUFFIX) \
+	("[MSC v." _Py_STRINGIZE(_MSC_VER) " " SUFFIX "]")
+/* e.g., this produces, after compile-time string catenation,
+ * 	("[MSC v.1200 32 bit (Intel)]")
+ *
+ * _Py_STRINGIZE(_MSC_VER) expands to
+ * _Py_STRINGIZE1((_MSC_VER)) expands to
+ * _Py_STRINGIZE2(_MSC_VER) but as this call is the result of token-pasting
+ *      it's scanned again for macros and so further expands to (under MSVC 6)
+ * _Py_STRINGIZE2(1200) which then expands to
+ * "1200"
+ */
+#define _Py_STRINGIZE(X) _Py_STRINGIZE1((X))
+#define _Py_STRINGIZE1(X) _Py_STRINGIZE2 ## X
+#define _Py_STRINGIZE2(X) #X
+
+/* MSVC defines _WINxx to differentiate the windows platform types
+
+   Note that for compatibility reasons _WIN32 is defined on Win32
+   *and* on Win64. For the same reasons, in Python, MS_WIN32 is
+   defined on Win32 *and* Win64. Win32 only code must therefore be
+   guarded as follows:
+   	#if defined(MS_WIN32) && !defined(MS_WIN64)
+*/
+#ifdef _WIN64
+#define MS_WIN64
+#endif
+
+/* set the COMPILER */
+#ifdef MS_WIN64
+#ifdef _M_IX86
+#define COMPILER _Py_PASTE_VERSION("64 bit (Intel)")
+#elif defined(_M_IA64)
+#define COMPILER _Py_PASTE_VERSION("64 bit (Itanium)")
+#elif defined(_M_AMD64)
+#define COMPILER _Py_PASTE_VERSION("64 bit (AMD64)")
+#else
+#define COMPILER _Py_PASTE_VERSION("64 bit (Unknown)")
+#endif
+#endif /* MS_WIN64 */
+
+#if defined(MS_WIN32) && !defined(MS_WIN64)
+#ifdef _M_IX86
+#define COMPILER _Py_PASTE_VERSION("32 bit (Intel)")
+#else
+#define COMPILER _Py_PASTE_VERSION("32 bit (Unknown)")
+#endif
+#endif /* MS_WIN32 && !MS_WIN64 */
+
+typedef int pid_t;
+#define hypot _hypot
+
+#include <float.h>
+#define Py_IS_NAN _isnan
+#define Py_IS_INFINITY(X) (!_finite(X) && !_isnan(X))
+
+#endif /* _MSC_VER */
+
+/* define some ANSI types that are not defined in earlier Win headers */
+#if defined(_MSC_VER) && _MSC_VER >= 1200
+/* This file only exists in VC 6.0 or higher */
+#include <basetsd.h>
+#endif
+
+/* ------------------------------------------------------------------------*/
+/* The Borland compiler defines __BORLANDC__ */
+/* XXX These defines are likely incomplete, but should be easy to fix. */
+#ifdef __BORLANDC__
+#define COMPILER "[Borland]"
+
+#ifdef _WIN32
+/* tested with BCC 5.5 (__BORLANDC__ >= 0x0550)
+ */
+
+typedef int pid_t;
+/* BCC55 seems to understand __declspec(dllimport), it is used in its
+   own header files (winnt.h, ...) - so we can do nothing and get the default*/
+
+#undef HAVE_SYS_UTIME_H
+#define HAVE_UTIME_H
+#define HAVE_DIRENT_H
+
+/* rename a few functions for the Borland compiler */
+#include <io.h>
+#define _chsize chsize
+#define _setmode setmode
+
+#else /* !_WIN32 */
+#error "Only Win32 and later are supported"
+#endif /* !_WIN32 */
+
+#endif /* BORLANDC */
+
+/* ------------------------------------------------------------------------*/
+/* egcs/gnu-win32 defines __GNUC__ and _WIN32 */
+#if defined(__GNUC__) && defined(_WIN32)
+/* XXX These defines are likely incomplete, but should be easy to fix.
+   They should be complete enough to build extension modules. */
+/* Suggested by Rene Liebscher <R.Liebscher at gmx.de> to avoid a GCC 2.91.*
+   bug that requires structure imports.  More recent versions of the
+   compiler don't exhibit this bug.
+*/
+#if (__GNUC__==2) && (__GNUC_MINOR__<=91)
+#warning "Please use an up-to-date version of gcc! (>2.91 recommended)"
+#endif
+
+#define COMPILER "[gcc]"
+#define hypot _hypot
+#define PY_LONG_LONG long long
+#endif /* GNUC */
+
+/* ------------------------------------------------------------------------*/
+/* lcc-win32 defines __LCC__ */
+#if defined(__LCC__)
+/* XXX These defines are likely incomplete, but should be easy to fix.
+   They should be complete enough to build extension modules. */
+
+#define COMPILER "[lcc-win32]"
+typedef int pid_t;
+/* __declspec() is supported here too - do nothing to get the defaults */
+
+#endif /* LCC */
+
+/* ------------------------------------------------------------------------*/
+/* End of compilers - finish up */
+
+#ifndef NO_STDIO_H
+#	include <stdio.h>
+#endif
+
+/* 64 bit ints are usually spelt __int64 unless compiler has overridden */
+#define HAVE_LONG_LONG 1
+#ifndef PY_LONG_LONG
+#	define PY_LONG_LONG __int64
+#endif
+
+/* For Windows the Python core is in a DLL by default.  Test
+Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
+#if !defined(MS_NO_COREDLL) && !defined(Py_NO_ENABLE_SHARED)
+#	define Py_ENABLE_SHARED 1 /* standard symbol for shared library */
+#	define MS_COREDLL	/* deprecated old symbol */
+#endif /* !MS_NO_COREDLL && ... */
+
+/* Deprecated USE_DL_EXPORT macro - please use Py_BUILD_CORE */
+#ifdef USE_DL_EXPORT
+#	define Py_BUILD_CORE
+#endif /* USE_DL_EXPORT */
+
+/*  All windows compilers that use this header support __declspec */
+#define HAVE_DECLSPEC_DLL
+
+/* For an MSVC DLL, we can nominate the .lib files used by extensions */
+#ifdef MS_COREDLL
+#	ifndef Py_BUILD_CORE /* not building the core - must be an ext */
+#		if defined(_MSC_VER)
+			/* So MSVC users need not specify the .lib file in
+			their Makefile (other compilers are generally
+			taken care of by distutils.) */
+#			ifdef _DEBUG
+#				pragma comment(lib,"python24_d.lib")
+#			else
+#				pragma comment(lib,"python24.lib")
+#			endif /* _DEBUG */
+#		endif /* _MSC_VER */
+#	endif /* Py_BUILD_CORE */
+#endif /* MS_COREDLL */
+
+#if defined(MS_WIN64)
+/* maintain "win32" sys.platform for backward compatibility of Python code,
+   the Win64 API should be close enough to the Win32 API to make this
+   preferable */
+#	define PLATFORM "win32"
+#	define SIZEOF_VOID_P 8
+#	define SIZEOF_TIME_T 8
+#	define SIZEOF_OFF_T 4
+#	define SIZEOF_FPOS_T 8
+#	define SIZEOF_HKEY 8
+/* configure.in defines HAVE_LARGEFILE_SUPPORT iff HAVE_LONG_LONG,
+   sizeof(off_t) > sizeof(long), and sizeof(PY_LONG_LONG) >= sizeof(off_t).
+   On Win64 the second condition is not true, but if fpos_t replaces off_t
+   then this is true. The uses of HAVE_LARGEFILE_SUPPORT imply that Win64
+   should define this. */
+#	define HAVE_LARGEFILE_SUPPORT
+#elif defined(MS_WIN32)
+#	define PLATFORM "win32"
+#	define HAVE_LARGEFILE_SUPPORT
+#	define SIZEOF_VOID_P 4
+#	define SIZEOF_TIME_T 4
+#	define SIZEOF_OFF_T 4
+#	define SIZEOF_FPOS_T 8
+#	define SIZEOF_HKEY 4
+#endif
+
+#ifdef _DEBUG
+#	define Py_DEBUG
+#endif
+
+
+#ifdef MS_WIN32
+
+#define SIZEOF_SHORT 2
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+#define SIZEOF_LONG_LONG 8
+
+/* VC 7.1 has them and VC 6.0 does not.  VC 6.0 has a version number of 1200.
+   If some compiler does not provide them, modify the #if appropriately. */
+#if defined(_MSC_VER)
+#if _MSC_VER > 1200
+#define HAVE_UINTPTR_T 1
+#define HAVE_INTPTR_T 1
+#endif  /* _MSC_VER > 1200  */ 
+#endif  /* _MSC_VER */
+
+#endif
+
+/* Fairly standard from here! */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define to empty if the keyword does not work.  */
+/* #define const  */
+
+/* Define if you have dirent.h.  */
+/* #define DIRENT 1 */
+
+/* Define to the type of elements in the array set by `getgroups'.
+   Usually this is either `int' or `gid_t'.  */
+/* #undef GETGROUPS_T */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef gid_t */
+
+/* Define if your struct tm has tm_zone.  */
+/* #undef HAVE_TM_ZONE */
+
+/* Define if you don't have tm_zone but do have the external array
+   tzname.  */
+#define HAVE_TZNAME
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef mode_t */
+
+/* Define if you don't have dirent.h, but have ndir.h.  */
+/* #undef NDIR */
+
+/* Define to `long' if <sys/types.h> doesn't define.  */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef pid_t */
+
+/* Define if the system does not provide POSIX.1 features except
+   with this defined.  */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+/* #undef size_t */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#if _MSC_VER + 0 >= 1300
+/* VC.NET typedefs socklen_t in ws2tcpip.h. */
+#else
+#define socklen_t int
+#endif
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Define if you don't have dirent.h, but have sys/dir.h.  */
+/* #undef SYSDIR */
+
+/* Define if you don't have dirent.h, but have sys/ndir.h.  */
+/* #undef SYSNDIR */
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+/* #undef TIME_WITH_SYS_TIME */
+
+/* Define if your <sys/time.h> declares struct tm.  */
+/* #define TM_IN_SYS_TIME 1 */
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+/* #undef uid_t */
+
+/* Define if the closedir function returns void instead of int.  */
+/* #undef VOID_CLOSEDIR */
+
+/* Define if getpgrp() must be called as getpgrp(0)
+   and (consequently) setpgrp() as setpgrp(0, 0). */
+/* #undef GETPGRP_HAVE_ARGS */
+
+/* Define this if your time.h defines altzone */
+/* #define HAVE_ALTZONE */
+
+/* Define if you have the putenv function.  */
+#define HAVE_PUTENV
+
+/* Define if your compiler supports function prototypes */
+#define HAVE_PROTOTYPES
+
+/* Define if  you can safely include both <sys/select.h> and <sys/time.h>
+   (which you can't on SCO ODT 3.0). */
+/* #undef SYS_SELECT_WITH_SYS_TIME */
+
+/* Define if you want documentation strings in extension modules */
+#define WITH_DOC_STRINGS 1
+
+/* Define if you want to compile in rudimentary thread support */
+/* #undef WITH_THREAD */
+
+/* Define if you want to use the GNU readline library */
+/* #define WITH_READLINE 1 */
+
+/* Define if you want to have a Unicode type. */
+#define Py_USING_UNICODE
+
+/* Define as the integral type used for Unicode representation. */
+#define PY_UNICODE_TYPE unsigned short
+
+/* Define as the size of the unicode type. */
+#define Py_UNICODE_SIZE SIZEOF_SHORT
+
+/* Define if you have a useable wchar_t type defined in wchar.h; useable
+   means wchar_t must be 16-bit unsigned type. (see
+   Include/unicodeobject.h). */
+#if Py_UNICODE_SIZE == 2
+#define HAVE_USABLE_WCHAR_T
+
+/* Define to indicate that the Python Unicode representation can be passed
+   as-is to Win32 Wide API.  */
+#define Py_WIN_WIDE_FILENAMES
+#endif
+
+/* Use Python's own small-block memory-allocator. */
+#define WITH_PYMALLOC 1
+
+/* Define if you have clock.  */
+/* #define HAVE_CLOCK */
+
+/* Define when any dynamic module loading is enabled */
+#define HAVE_DYNAMIC_LOADING
+
+/* Define if you have ftime.  */
+#define HAVE_FTIME
+
+/* Define if you have getpeername.  */
+#define HAVE_GETPEERNAME
+
+/* Define if you have getpgrp.  */
+/* #undef HAVE_GETPGRP */
+
+/* Define if you have getpid.  */
+#define HAVE_GETPID
+
+/* Define if you have gettimeofday.  */
+/* #undef HAVE_GETTIMEOFDAY */
+
+/* Define if you have getwd.  */
+/* #undef HAVE_GETWD */
+
+/* Define if you have lstat.  */
+/* #undef HAVE_LSTAT */
+
+/* Define if you have the mktime function.  */
+#define HAVE_MKTIME
+
+/* Define if you have nice.  */
+/* #undef HAVE_NICE */
+
+/* Define if you have readlink.  */
+/* #undef HAVE_READLINK */
+
+/* Define if you have select.  */
+/* #undef HAVE_SELECT */
+
+/* Define if you have setpgid.  */
+/* #undef HAVE_SETPGID */
+
+/* Define if you have setpgrp.  */
+/* #undef HAVE_SETPGRP */
+
+/* Define if you have setsid.  */
+/* #undef HAVE_SETSID */
+
+/* Define if you have setvbuf.  */
+#define HAVE_SETVBUF
+
+/* Define if you have siginterrupt.  */
+/* #undef HAVE_SIGINTERRUPT */
+
+/* Define if you have symlink.  */
+/* #undef HAVE_SYMLINK */
+
+/* Define if you have tcgetpgrp.  */
+/* #undef HAVE_TCGETPGRP */
+
+/* Define if you have tcsetpgrp.  */
+/* #undef HAVE_TCSETPGRP */
+
+/* Define if you have times.  */
+/* #undef HAVE_TIMES */
+
+/* Define if you have uname.  */
+/* #undef HAVE_UNAME */
+
+/* Define if you have waitpid.  */
+/* #undef HAVE_WAITPID */
+
+/* Define to 1 if you have the `wcscoll' function. */
+#define HAVE_WCSCOLL 1
+
+/* Define if you have the <dlfcn.h> header file.  */
+/* #undef HAVE_DLFCN_H */
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <stdarg.h> prototypes.  */
+#define HAVE_STDARG_PROTOTYPES
+
+/* Define if you have the <stddef.h> header file.  */
+#define HAVE_STDDEF_H 1
+
+/* Define if you have the <sys/audioio.h> header file.  */
+/* #undef HAVE_SYS_AUDIOIO_H */
+
+/* Define if you have the <sys/param.h> header file.  */
+/* #define HAVE_SYS_PARAM_H 1 */
+
+/* Define if you have the <sys/select.h> header file.  */
+/* #define HAVE_SYS_SELECT_H 1 */
+
+/* Define if you have the <sys/time.h> header file.  */
+/* #define HAVE_SYS_TIME_H 1 */
+
+/* Define if you have the <sys/times.h> header file.  */
+/* #define HAVE_SYS_TIMES_H 1 */
+
+/* Define if you have the <sys/un.h> header file.  */
+/* #define HAVE_SYS_UN_H 1 */
+
+/* Define if you have the <sys/utime.h> header file.  */
+/* #define HAVE_SYS_UTIME_H 1 */
+
+/* Define if you have the <sys/utsname.h> header file.  */
+/* #define HAVE_SYS_UTSNAME_H 1 */
+
+/* Define if you have the <thread.h> header file.  */
+/* #undef HAVE_THREAD_H */
+
+/* Define if you have the <unistd.h> header file.  */
+/* #define HAVE_UNISTD_H 1 */
+
+/* Define if you have the <utime.h> header file.  */
+/* #define HAVE_UTIME_H 1 */
+
+/* Define if the compiler provides a wchar.h header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define if you have the dl library (-ldl).  */
+/* #undef HAVE_LIBDL */
+
+/* Define if you have the mpc library (-lmpc).  */
+/* #undef HAVE_LIBMPC */
+
+/* Define if you have the nsl library (-lnsl).  */
+#define HAVE_LIBNSL 1
+
+/* Define if you have the seq library (-lseq).  */
+/* #undef HAVE_LIBSEQ */
+
+/* Define if you have the socket library (-lsocket).  */
+#define HAVE_LIBSOCKET 1
+
+/* Define if you have the sun library (-lsun).  */
+/* #undef HAVE_LIBSUN */
+
+/* Define if you have the termcap library (-ltermcap).  */
+/* #undef HAVE_LIBTERMCAP */
+
+/* Define if you have the termlib library (-ltermlib).  */
+/* #undef HAVE_LIBTERMLIB */
+
+/* Define if you have the thread library (-lthread).  */
+/* #undef HAVE_LIBTHREAD */
+#endif /* !Py_CONFIG_H */

Added: trunk/mingw-libs/include/pydebug.h
===================================================================
--- trunk/mingw-libs/include/pydebug.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pydebug.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,34 @@
+
+#ifndef Py_PYDEBUG_H
+#define Py_PYDEBUG_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_DATA(int) Py_DebugFlag;
+PyAPI_DATA(int) Py_VerboseFlag;
+PyAPI_DATA(int) Py_InteractiveFlag;
+PyAPI_DATA(int) Py_OptimizeFlag;
+PyAPI_DATA(int) Py_NoSiteFlag;
+PyAPI_DATA(int) Py_UseClassExceptionsFlag;
+PyAPI_DATA(int) Py_FrozenFlag;
+PyAPI_DATA(int) Py_TabcheckFlag;
+PyAPI_DATA(int) Py_UnicodeFlag;
+PyAPI_DATA(int) Py_IgnoreEnvironmentFlag;
+PyAPI_DATA(int) Py_DivisionWarningFlag;
+/* _XXX Py_QnewFlag should go away in 3.0.  It's true iff -Qnew is passed,
+  on the command line, and is used in 2.2 by ceval.c to make all "/" divisions
+  true divisions (which they will be in 3.0). */
+PyAPI_DATA(int) _Py_QnewFlag;
+
+/* this is a wrapper around getenv() that pays attention to
+   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like
+   PYTHONPATH and PYTHONHOME from the environment */
+#define Py_GETENV(s) (Py_IgnoreEnvironmentFlag ? NULL : getenv(s))
+
+PyAPI_FUNC(void) Py_FatalError(const char *message);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYDEBUG_H */

Added: trunk/mingw-libs/include/pyerrors.h
===================================================================
--- trunk/mingw-libs/include/pyerrors.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyerrors.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,234 @@
+#ifndef Py_ERRORS_H
+#define Py_ERRORS_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Error handling definitions */
+
+PyAPI_FUNC(void) PyErr_SetNone(PyObject *);
+PyAPI_FUNC(void) PyErr_SetObject(PyObject *, PyObject *);
+PyAPI_FUNC(void) PyErr_SetString(PyObject *, const char *);
+PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
+PyAPI_FUNC(void) PyErr_Clear(void);
+PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
+PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
+
+/* Error testing and normalization */
+PyAPI_FUNC(int) PyErr_GivenExceptionMatches(PyObject *, PyObject *);
+PyAPI_FUNC(int) PyErr_ExceptionMatches(PyObject *);
+PyAPI_FUNC(void) PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);
+
+
+/* Predefined exceptions */
+
+PyAPI_DATA(PyObject *) PyExc_Exception;
+PyAPI_DATA(PyObject *) PyExc_StopIteration;
+PyAPI_DATA(PyObject *) PyExc_StandardError;
+PyAPI_DATA(PyObject *) PyExc_ArithmeticError;
+PyAPI_DATA(PyObject *) PyExc_LookupError;
+
+PyAPI_DATA(PyObject *) PyExc_AssertionError;
+PyAPI_DATA(PyObject *) PyExc_AttributeError;
+PyAPI_DATA(PyObject *) PyExc_EOFError;
+PyAPI_DATA(PyObject *) PyExc_FloatingPointError;
+PyAPI_DATA(PyObject *) PyExc_EnvironmentError;
+PyAPI_DATA(PyObject *) PyExc_IOError;
+PyAPI_DATA(PyObject *) PyExc_OSError;
+PyAPI_DATA(PyObject *) PyExc_ImportError;
+PyAPI_DATA(PyObject *) PyExc_IndexError;
+PyAPI_DATA(PyObject *) PyExc_KeyError;
+PyAPI_DATA(PyObject *) PyExc_KeyboardInterrupt;
+PyAPI_DATA(PyObject *) PyExc_MemoryError;
+PyAPI_DATA(PyObject *) PyExc_NameError;
+PyAPI_DATA(PyObject *) PyExc_OverflowError;
+PyAPI_DATA(PyObject *) PyExc_RuntimeError;
+PyAPI_DATA(PyObject *) PyExc_NotImplementedError;
+PyAPI_DATA(PyObject *) PyExc_SyntaxError;
+PyAPI_DATA(PyObject *) PyExc_IndentationError;
+PyAPI_DATA(PyObject *) PyExc_TabError;
+PyAPI_DATA(PyObject *) PyExc_ReferenceError;
+PyAPI_DATA(PyObject *) PyExc_SystemError;
+PyAPI_DATA(PyObject *) PyExc_SystemExit;
+PyAPI_DATA(PyObject *) PyExc_TypeError;
+PyAPI_DATA(PyObject *) PyExc_UnboundLocalError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeEncodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeDecodeError;
+PyAPI_DATA(PyObject *) PyExc_UnicodeTranslateError;
+PyAPI_DATA(PyObject *) PyExc_ValueError;
+PyAPI_DATA(PyObject *) PyExc_ZeroDivisionError;
+#ifdef MS_WINDOWS
+PyAPI_DATA(PyObject *) PyExc_WindowsError;
+#endif
+#ifdef __VMS
+PyAPI_DATA(PyObject *) PyExc_VMSError;
+#endif
+
+PyAPI_DATA(PyObject *) PyExc_MemoryErrorInst;
+
+/* Predefined warning categories */
+PyAPI_DATA(PyObject *) PyExc_Warning;
+PyAPI_DATA(PyObject *) PyExc_UserWarning;
+PyAPI_DATA(PyObject *) PyExc_DeprecationWarning;
+PyAPI_DATA(PyObject *) PyExc_PendingDeprecationWarning;
+PyAPI_DATA(PyObject *) PyExc_SyntaxWarning;
+/* PyExc_OverflowWarning will go away for Python 2.5 */
+PyAPI_DATA(PyObject *) PyExc_OverflowWarning;
+PyAPI_DATA(PyObject *) PyExc_RuntimeWarning;
+PyAPI_DATA(PyObject *) PyExc_FutureWarning;
+
+
+/* Convenience functions */
+
+PyAPI_FUNC(int) PyErr_BadArgument(void);
+PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
+	PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(PyObject *, char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithUnicodeFilename(
+	PyObject *, Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+
+PyAPI_FUNC(PyObject *) PyErr_Format(PyObject *, const char *, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 2, 3)));
+
+#ifdef MS_WINDOWS
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilenameObject(
+	int, const char *);
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
+	int, const char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithUnicodeFilename(
+	int, const Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
+	PyObject *,int, PyObject *);
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
+	PyObject *,int, const char *);
+#ifdef Py_WIN_WIDE_FILENAMES
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithUnicodeFilename(
+	PyObject *,int, const Py_UNICODE *);
+#endif /* Py_WIN_WIDE_FILENAMES */
+PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
+#endif /* MS_WINDOWS */
+
+/* Export the old function so that the existing API remains available: */
+PyAPI_FUNC(void) PyErr_BadInternalCall(void);
+PyAPI_FUNC(void) _PyErr_BadInternalCall(char *filename, int lineno);
+/* Mask the old API with a call to the new API for code compiled under
+   Python 2.0: */
+#define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)
+
+/* Function to create a new exception */
+PyAPI_FUNC(PyObject *) PyErr_NewException(char *name, PyObject *base,
+                                         PyObject *dict);
+PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);
+
+/* Issue a warning or exception */
+PyAPI_FUNC(int) PyErr_Warn(PyObject *, char *);
+PyAPI_FUNC(int) PyErr_WarnExplicit(PyObject *, const char *,
+				   const char *, int, 
+				   const char *, PyObject *);
+
+/* In sigcheck.c or signalmodule.c */
+PyAPI_FUNC(int) PyErr_CheckSignals(void);
+PyAPI_FUNC(void) PyErr_SetInterrupt(void);
+
+/* Support for adding program text to SyntaxErrors */
+PyAPI_FUNC(void) PyErr_SyntaxLocation(const char *, int);
+PyAPI_FUNC(PyObject *) PyErr_ProgramText(const char *, int);
+
+#ifdef Py_USING_UNICODE
+/* The following functions are used to create and modify unicode
+   exceptions from C */
+
+/* create a UnicodeDecodeError object */
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
+	const char *, const char *, int, int, int, const char *);
+
+/* create a UnicodeEncodeError object */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_Create(
+	const char *, const Py_UNICODE *, int, int, int, const char *);
+
+/* create a UnicodeTranslateError object */
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_Create(
+	const Py_UNICODE *, int, int, int, const char *);
+
+/* get the encoding attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);
+
+/* get the object attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);
+
+/* get the value of the start attribute (the int * may not be NULL)
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_GetStart(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_GetStart(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_GetStart(PyObject *, int *);
+
+/* assign a new value to the start attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetStart(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetStart(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetStart(PyObject *, int);
+
+/* get the value of the end attribute (the int *may not be NULL)
+ return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_GetEnd(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_GetEnd(PyObject *, int *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_GetEnd(PyObject *, int *);
+
+/* assign a new value to the end attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetEnd(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetEnd(PyObject *, int);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, int);
+
+/* get the value of the reason attribute */
+PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
+PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);
+
+/* assign a new value to the reason attribute
+   return 0 on success, -1 on failure */
+PyAPI_FUNC(int) PyUnicodeEncodeError_SetReason(
+	PyObject *, const char *);
+PyAPI_FUNC(int) PyUnicodeDecodeError_SetReason(
+	PyObject *, const char *);
+PyAPI_FUNC(int) PyUnicodeTranslateError_SetReason(
+	PyObject *, const char *);
+#endif
+
+
+/* These APIs aren't really part of the error implementation, but
+   often needed to format error messages; the native C lib APIs are
+   not available on all platforms, which is why we provide emulations
+   for those platforms in Python/mysnprintf.c,
+   WARNING:  The return value of snprintf varies across platforms; do
+   not rely on any particular behavior; eventually the C99 defn may
+   be reliable.
+*/
+#if defined(MS_WIN32) && !defined(HAVE_SNPRINTF)
+# define HAVE_SNPRINTF
+# define snprintf _snprintf
+# define vsnprintf _vsnprintf
+#endif
+
+#include <stdarg.h>
+PyAPI_FUNC(int) PyOS_snprintf(char *str, size_t size, const char  *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 3, 4)));
+PyAPI_FUNC(int) PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)
+			Py_GCC_ATTRIBUTE((format(printf, 3, 0)));
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_ERRORS_H */

Added: trunk/mingw-libs/include/pyfpe.h
===================================================================
--- trunk/mingw-libs/include/pyfpe.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyfpe.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,176 @@
+#ifndef Py_PYFPE_H
+#define Py_PYFPE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*
+     ---------------------------------------------------------------------  
+    /                       Copyright (c) 1996.                           \ 
+   |          The Regents of the University of California.                 |
+   |                        All rights reserved.                           |
+   |                                                                       |
+   |   Permission to use, copy, modify, and distribute this software for   |
+   |   any purpose without fee is hereby granted, provided that this en-   |
+   |   tire notice is included in all copies of any software which is or   |
+   |   includes  a  copy  or  modification  of  this software and in all   |
+   |   copies of the supporting documentation for such software.           |
+   |                                                                       |
+   |   This  work was produced at the University of California, Lawrence   |
+   |   Livermore National Laboratory under  contract  no.  W-7405-ENG-48   |
+   |   between  the  U.S.  Department  of  Energy and The Regents of the   |
+   |   University of California for the operation of UC LLNL.              |
+   |                                                                       |
+   |                              DISCLAIMER                               |
+   |                                                                       |
+   |   This  software was prepared as an account of work sponsored by an   |
+   |   agency of the United States Government. Neither the United States   |
+   |   Government  nor the University of California nor any of their em-   |
+   |   ployees, makes any warranty, express or implied, or  assumes  any   |
+   |   liability  or  responsibility  for the accuracy, completeness, or   |
+   |   usefulness of any information,  apparatus,  product,  or  process   |
+   |   disclosed,   or  represents  that  its  use  would  not  infringe   |
+   |   privately-owned rights. Reference herein to any specific  commer-   |
+   |   cial  products,  process,  or  service  by trade name, trademark,   |
+   |   manufacturer, or otherwise, does not  necessarily  constitute  or   |
+   |   imply  its endorsement, recommendation, or favoring by the United   |
+   |   States Government or the University of California. The views  and   |
+   |   opinions  of authors expressed herein do not necessarily state or   |
+   |   reflect those of the United States Government or  the  University   |
+   |   of  California,  and shall not be used for advertising or product   |
+    \  endorsement purposes.                                              / 
+     ---------------------------------------------------------------------  
+*/
+
+/*
+ *       Define macros for handling SIGFPE.
+ *       Lee Busby, LLNL, November, 1996
+ *       busby1 at llnl.gov
+ * 
+ *********************************************
+ * Overview of the system for handling SIGFPE:
+ * 
+ * This file (Include/pyfpe.h) defines a couple of "wrapper" macros for
+ * insertion into your Python C code of choice. Their proper use is
+ * discussed below. The file Python/pyfpe.c defines a pair of global
+ * variables PyFPE_jbuf and PyFPE_counter which are used by the signal
+ * handler for SIGFPE to decide if a particular exception was protected
+ * by the macros. The signal handler itself, and code for enabling the
+ * generation of SIGFPE in the first place, is in a (new) Python module
+ * named fpectl. This module is standard in every respect. It can be loaded
+ * either statically or dynamically as you choose, and like any other
+ * Python module, has no effect until you import it.
+ * 
+ * In the general case, there are three steps toward handling SIGFPE in any
+ * Python code:
+ * 
+ * 1) Add the *_PROTECT macros to your C code as required to protect
+ *    dangerous floating point sections.
+ * 
+ * 2) Turn on the inclusion of the code by adding the ``--with-fpectl''
+ *    flag at the time you run configure.  If the fpectl or other modules
+ *    which use the *_PROTECT macros are to be dynamically loaded, be
+ *    sure they are compiled with WANT_SIGFPE_HANDLER defined.
+ * 
+ * 3) When python is built and running, import fpectl, and execute
+ *    fpectl.turnon_sigfpe(). This sets up the signal handler and enables
+ *    generation of SIGFPE whenever an exception occurs. From this point
+ *    on, any properly trapped SIGFPE should result in the Python
+ *    FloatingPointError exception.
+ * 
+ * Step 1 has been done already for the Python kernel code, and should be
+ * done soon for the NumPy array package.  Step 2 is usually done once at
+ * python install time. Python's behavior with respect to SIGFPE is not
+ * changed unless you also do step 3. Thus you can control this new
+ * facility at compile time, or run time, or both.
+ * 
+ ******************************** 
+ * Using the macros in your code:
+ * 
+ * static PyObject *foobar(PyObject *self,PyObject *args)
+ * {
+ *     ....
+ *     PyFPE_START_PROTECT("Error in foobar", return 0)
+ *     result = dangerous_op(somearg1, somearg2, ...);
+ *     PyFPE_END_PROTECT(result)
+ *     ....
+ * }
+ * 
+ * If a floating point error occurs in dangerous_op, foobar returns 0 (NULL),
+ * after setting the associated value of the FloatingPointError exception to
+ * "Error in foobar". ``Dangerous_op'' can be a single operation, or a block
+ * of code, function calls, or any combination, so long as no alternate
+ * return is possible before the PyFPE_END_PROTECT macro is reached.
+ * 
+ * The macros can only be used in a function context where an error return
+ * can be recognized as signaling a Python exception. (Generally, most
+ * functions that return a PyObject * will qualify.)
+ * 
+ * Guido's original design suggestion for PyFPE_START_PROTECT and
+ * PyFPE_END_PROTECT had them open and close a local block, with a locally
+ * defined jmp_buf and jmp_buf pointer. This would allow recursive nesting
+ * of the macros. The Ansi C standard makes it clear that such local
+ * variables need to be declared with the "volatile" type qualifier to keep
+ * setjmp from corrupting their values. Some current implementations seem
+ * to be more restrictive. For example, the HPUX man page for setjmp says
+ * 
+ *   Upon the return from a setjmp() call caused by a longjmp(), the
+ *   values of any non-static local variables belonging to the routine
+ *   from which setjmp() was called are undefined. Code which depends on
+ *   such values is not guaranteed to be portable.
+ * 
+ * I therefore decided on a more limited form of nesting, using a counter
+ * variable (PyFPE_counter) to keep track of any recursion.  If an exception
+ * occurs in an ``inner'' pair of macros, the return will apparently
+ * come from the outermost level.
+ * 
+ */
+
+#ifdef WANT_SIGFPE_HANDLER
+#include <signal.h>
+#include <setjmp.h>
+#include <math.h>
+extern jmp_buf PyFPE_jbuf;
+extern int PyFPE_counter;
+extern double PyFPE_dummy(void *);
+
+#define PyFPE_START_PROTECT(err_string, leave_stmt) \
+if (!PyFPE_counter++ && setjmp(PyFPE_jbuf)) { \
+	PyErr_SetString(PyExc_FloatingPointError, err_string); \
+	PyFPE_counter = 0; \
+	leave_stmt; \
+}
+
+/*
+ * This (following) is a heck of a way to decrement a counter. However,
+ * unless the macro argument is provided, code optimizers will sometimes move
+ * this statement so that it gets executed *before* the unsafe expression
+ * which we're trying to protect.  That pretty well messes things up,
+ * of course.
+ * 
+ * If the expression(s) you're trying to protect don't happen to return a
+ * value, you will need to manufacture a dummy result just to preserve the
+ * correct ordering of statements.  Note that the macro passes the address
+ * of its argument (so you need to give it something which is addressable).
+ * If your expression returns multiple results, pass the last such result
+ * to PyFPE_END_PROTECT.
+ * 
+ * Note that PyFPE_dummy returns a double, which is cast to int.
+ * This seeming insanity is to tickle the Floating Point Unit (FPU).
+ * If an exception has occurred in a preceding floating point operation,
+ * some architectures (notably Intel 80x86) will not deliver the interrupt
+ * until the *next* floating point operation.  This is painful if you've
+ * already decremented PyFPE_counter.
+ */
+#define PyFPE_END_PROTECT(v) PyFPE_counter -= (int)PyFPE_dummy(&(v));
+
+#else
+
+#define PyFPE_START_PROTECT(err_string, leave_stmt)
+#define PyFPE_END_PROTECT(v)
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYFPE_H */

Added: trunk/mingw-libs/include/pygetopt.h
===================================================================
--- trunk/mingw-libs/include/pygetopt.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pygetopt.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,17 @@
+
+#ifndef Py_PYGETOPT_H
+#define Py_PYGETOPT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_DATA(int) _PyOS_opterr;
+PyAPI_DATA(int) _PyOS_optind;
+PyAPI_DATA(char *) _PyOS_optarg;
+
+PyAPI_FUNC(int) _PyOS_GetOpt(int argc, char **argv, char *optstring);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYGETOPT_H */

Added: trunk/mingw-libs/include/pymactoolbox.h
===================================================================
--- trunk/mingw-libs/include/pymactoolbox.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pymactoolbox.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,189 @@
+/*
+** pymactoolbox.h - globals defined in mactoolboxglue.c
+*/
+#ifndef Py_PYMACTOOLBOX_H
+#define Py_PYMACTOOLBOX_H
+#ifdef __cplusplus
+	extern "C" {
+#endif
+
+#include <Carbon/Carbon.h>
+#include <QuickTime/QuickTime.h>
+
+/*
+** Helper routines for error codes and such.
+*/
+char *PyMac_StrError(int);			/* strerror with mac errors */
+extern PyObject *PyMac_OSErrException;		/* Exception for OSErr */
+PyObject *PyMac_GetOSErrException(void);	/* Initialize & return it */
+PyObject *PyErr_Mac(PyObject *, int);		/* Exception with a mac error */
+PyObject *PyMac_Error(OSErr);			/* Uses PyMac_GetOSErrException */
+extern OSErr PyMac_GetFullPathname(FSSpec *, char *, int); /* convert
+							      fsspec->path */
+/*
+** These conversion routines are defined in mactoolboxglue.c itself.
+*/
+int PyMac_GetOSType(PyObject *, OSType *);	/* argument parser for OSType */
+PyObject *PyMac_BuildOSType(OSType);		/* Convert OSType to PyObject */
+
+PyObject *PyMac_BuildNumVersion(NumVersion);/* Convert NumVersion to PyObject */
+
+int PyMac_GetStr255(PyObject *, Str255);	/* argument parser for Str255 */
+PyObject *PyMac_BuildStr255(Str255);		/* Convert Str255 to PyObject */
+PyObject *PyMac_BuildOptStr255(Str255);		/* Convert Str255 to PyObject,
+						   NULL to None */
+
+int PyMac_GetRect(PyObject *, Rect *);		/* argument parser for Rect */
+PyObject *PyMac_BuildRect(Rect *);		/* Convert Rect to PyObject */
+
+int PyMac_GetPoint(PyObject *, Point *);	/* argument parser for Point */
+PyObject *PyMac_BuildPoint(Point);		/* Convert Point to PyObject */
+
+int PyMac_GetEventRecord(PyObject *, EventRecord *); /* argument parser for
+							EventRecord */
+PyObject *PyMac_BuildEventRecord(EventRecord *); /* Convert EventRecord to
+						    PyObject */
+
+int PyMac_GetFixed(PyObject *, Fixed *);	/* argument parser for Fixed */
+PyObject *PyMac_BuildFixed(Fixed);		/* Convert Fixed to PyObject */
+int PyMac_Getwide(PyObject *, wide *);		/* argument parser for wide */
+PyObject *PyMac_Buildwide(wide *);		/* Convert wide to PyObject */
+
+/*
+** The rest of the routines are implemented by extension modules. If they are
+** dynamically loaded mactoolboxglue will contain a stub implementation of the
+** routine, which imports the module, whereupon the module's init routine will
+** communicate the routine pointer back to the stub.
+** If USE_TOOLBOX_OBJECT_GLUE is not defined there is no glue code, and the
+** extension modules simply declare the routine. This is the case for static
+** builds (and could be the case for MacPython CFM builds, because CFM extension
+** modules can reference each other without problems).
+*/
+
+#ifdef USE_TOOLBOX_OBJECT_GLUE
+/*
+** These macros are used in the module init code. If we use toolbox object glue
+** it sets the function pointer to point to the real function.
+*/
+#define PyMac_INIT_TOOLBOX_OBJECT_NEW(object, rtn) { \
+	extern PyObject *(*PyMacGluePtr_##rtn)(object); \
+	PyMacGluePtr_##rtn = _##rtn; \
+}
+#define PyMac_INIT_TOOLBOX_OBJECT_CONVERT(object, rtn) { \
+	extern int (*PyMacGluePtr_##rtn)(PyObject *, object *); \
+	PyMacGluePtr_##rtn = _##rtn; \
+}
+#else
+/*
+** If we don't use toolbox object glue the init macros are empty. Moreover, we define
+** _xxx_New to be the same as xxx_New, and the code in mactoolboxglue isn't included.
+*/
+#define PyMac_INIT_TOOLBOX_OBJECT_NEW(object, rtn)
+#define PyMac_INIT_TOOLBOX_OBJECT_CONVERT(object, rtn)
+#endif /* USE_TOOLBOX_OBJECT_GLUE */
+
+/* macfs exports */
+int PyMac_GetFSSpec(PyObject *, FSSpec *);	/* argument parser for FSSpec */
+PyObject *PyMac_BuildFSSpec(FSSpec *);		/* Convert FSSpec to PyObject */
+
+int PyMac_GetFSRef(PyObject *, FSRef *);	/* argument parser for FSRef */
+PyObject *PyMac_BuildFSRef(FSRef *);		/* Convert FSRef to PyObject */
+
+/* AE exports */
+extern PyObject *AEDesc_New(AppleEvent *); /* XXXX Why passed by address?? */
+extern PyObject *AEDesc_NewBorrowed(AppleEvent *);
+extern int AEDesc_Convert(PyObject *, AppleEvent *);
+
+/* Cm exports */
+extern PyObject *CmpObj_New(Component);
+extern int CmpObj_Convert(PyObject *, Component *);
+extern PyObject *CmpInstObj_New(ComponentInstance);
+extern int CmpInstObj_Convert(PyObject *, ComponentInstance *);
+
+/* Ctl exports */
+extern PyObject *CtlObj_New(ControlHandle);
+extern int CtlObj_Convert(PyObject *, ControlHandle *);
+
+/* Dlg exports */
+extern PyObject *DlgObj_New(DialogPtr);
+extern int DlgObj_Convert(PyObject *, DialogPtr *);
+extern PyObject *DlgObj_WhichDialog(DialogPtr);
+
+/* Drag exports */
+extern PyObject *DragObj_New(DragReference);
+extern int DragObj_Convert(PyObject *, DragReference *);
+
+/* List exports */
+extern PyObject *ListObj_New(ListHandle);
+extern int ListObj_Convert(PyObject *, ListHandle *);
+
+/* Menu exports */
+extern PyObject *MenuObj_New(MenuHandle);
+extern int MenuObj_Convert(PyObject *, MenuHandle *);
+
+/* Qd exports */
+extern PyObject *GrafObj_New(GrafPtr);
+extern int GrafObj_Convert(PyObject *, GrafPtr *);
+extern PyObject *BMObj_New(BitMapPtr);
+extern int BMObj_Convert(PyObject *, BitMapPtr *);
+extern PyObject *QdRGB_New(RGBColor *);
+extern int QdRGB_Convert(PyObject *, RGBColor *);
+
+/* Qdoffs exports */
+extern PyObject *GWorldObj_New(GWorldPtr);
+extern int GWorldObj_Convert(PyObject *, GWorldPtr *);
+
+/* Qt exports */
+extern PyObject *TrackObj_New(Track);
+extern int TrackObj_Convert(PyObject *, Track *);
+extern PyObject *MovieObj_New(Movie);
+extern int MovieObj_Convert(PyObject *, Movie *);
+extern PyObject *MovieCtlObj_New(MovieController);
+extern int MovieCtlObj_Convert(PyObject *, MovieController *);
+extern PyObject *TimeBaseObj_New(TimeBase);
+extern int TimeBaseObj_Convert(PyObject *, TimeBase *);
+extern PyObject *UserDataObj_New(UserData);
+extern int UserDataObj_Convert(PyObject *, UserData *);
+extern PyObject *MediaObj_New(Media);
+extern int MediaObj_Convert(PyObject *, Media *);
+
+/* Res exports */
+extern PyObject *ResObj_New(Handle);
+extern int ResObj_Convert(PyObject *, Handle *);
+extern PyObject *OptResObj_New(Handle);
+extern int OptResObj_Convert(PyObject *, Handle *);
+
+/* TE exports */
+extern PyObject *TEObj_New(TEHandle);
+extern int TEObj_Convert(PyObject *, TEHandle *);
+
+/* Win exports */
+extern PyObject *WinObj_New(WindowPtr);
+extern int WinObj_Convert(PyObject *, WindowPtr *);
+extern PyObject *WinObj_WhichWindow(WindowPtr);
+
+/* CF exports */
+extern PyObject *CFObj_New(CFTypeRef);
+extern int CFObj_Convert(PyObject *, CFTypeRef *);
+extern PyObject *CFTypeRefObj_New(CFTypeRef);
+extern int CFTypeRefObj_Convert(PyObject *, CFTypeRef *);
+extern PyObject *CFStringRefObj_New(CFStringRef);
+extern int CFStringRefObj_Convert(PyObject *, CFStringRef *);
+extern PyObject *CFMutableStringRefObj_New(CFMutableStringRef);
+extern int CFMutableStringRefObj_Convert(PyObject *, CFMutableStringRef *);
+extern PyObject *CFArrayRefObj_New(CFArrayRef);
+extern int CFArrayRefObj_Convert(PyObject *, CFArrayRef *);
+extern PyObject *CFMutableArrayRefObj_New(CFMutableArrayRef);
+extern int CFMutableArrayRefObj_Convert(PyObject *, CFMutableArrayRef *);
+extern PyObject *CFDictionaryRefObj_New(CFDictionaryRef);
+extern int CFDictionaryRefObj_Convert(PyObject *, CFDictionaryRef *);
+extern PyObject *CFMutableDictionaryRefObj_New(CFMutableDictionaryRef);
+extern int CFMutableDictionaryRefObj_Convert(PyObject *, CFMutableDictionaryRef *);
+extern PyObject *CFURLRefObj_New(CFURLRef);
+extern int CFURLRefObj_Convert(PyObject *, CFURLRef *);
+extern int OptionalCFURLRefObj_Convert(PyObject *, CFURLRef *);
+
+#ifdef __cplusplus
+	}
+#endif
+#endif

Added: trunk/mingw-libs/include/pymem.h
===================================================================
--- trunk/mingw-libs/include/pymem.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pymem.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,108 @@
+/* The PyMem_ family:  low-level memory allocation interfaces.
+   See objimpl.h for the PyObject_ memory family.
+*/
+
+#ifndef Py_PYMEM_H
+#define Py_PYMEM_H
+
+#include "pyport.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* BEWARE:
+
+   Each interface exports both functions and macros.  Extension modules should
+   use the functions, to ensure binary compatibility across Python versions.
+   Because the Python implementation is free to change internal details, and
+   the macros may (or may not) expose details for speed, if you do use the
+   macros you must recompile your extensions with each Python release.
+
+   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
+   calloc/free.  For example, on Windows different DLLs may end up using
+   different heaps, and if you use PyMem_Malloc you'll get the memory from the
+   heap used by the Python DLL; it could be a disaster if you free()'ed that
+   directly in your own extension.  Using PyMem_Free instead ensures Python
+   can return the memory to the proper heap.  As another example, in
+   PYMALLOC_DEBUG mode, Python wraps all calls to all PyMem_ and PyObject_
+   memory functions in special debugging wrappers that add additional
+   debugging info to dynamic memory blocks.  The system routines have no idea
+   what to do with that stuff, and the Python wrappers have no idea what to do
+   with raw blocks obtained directly by the system routines then.
+*/
+
+/*
+ * Raw memory interface
+ * ====================
+ */
+
+/* Functions
+
+   Functions supplying platform-independent semantics for malloc/realloc/
+   free.  These functions make sure that allocating 0 bytes returns a distinct
+   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
+   may be returned), even if the platform malloc and realloc don't.
+   Returned pointers must be checked for NULL explicitly.  No action is
+   performed on failure (no exception is set, no warning is printed, etc).
+*/
+
+PyAPI_FUNC(void *) PyMem_Malloc(size_t);
+PyAPI_FUNC(void *) PyMem_Realloc(void *, size_t);
+PyAPI_FUNC(void) PyMem_Free(void *);
+
+/* Starting from Python 1.6, the wrappers Py_{Malloc,Realloc,Free} are
+   no longer supported. They used to call PyErr_NoMemory() on failure. */
+
+/* Macros. */
+#ifdef PYMALLOC_DEBUG
+/* Redirect all memory operations to Python's debugging allocator. */
+#define PyMem_MALLOC		PyObject_MALLOC
+#define PyMem_REALLOC		PyObject_REALLOC
+
+#else	/* ! PYMALLOC_DEBUG */
+
+/* PyMem_MALLOC(0) means malloc(1). Some systems would return NULL
+   for malloc(0), which would be treated as an error. Some platforms
+   would return a pointer with no memory behind it, which would break
+   pymalloc. To solve these problems, allocate an extra byte. */
+#define PyMem_MALLOC(n)         malloc((n) ? (n) : 1)
+#define PyMem_REALLOC(p, n)     realloc((p), (n) ? (n) : 1)
+
+#endif	/* PYMALLOC_DEBUG */
+
+/* In order to avoid breaking old code mixing PyObject_{New, NEW} with
+   PyMem_{Del, DEL} and PyMem_{Free, FREE}, the PyMem "release memory"
+   functions have to be redirected to the object deallocator. */
+#define PyMem_FREE           	PyObject_FREE
+
+/*
+ * Type-oriented memory interface
+ * ==============================
+ *
+ * These are carried along for historical reasons.  There's rarely a good
+ * reason to use them anymore (you can just as easily do the multiply and
+ * cast yourself).
+ */
+
+#define PyMem_New(type, n) \
+	( (type *) PyMem_Malloc((n) * sizeof(type)) )
+#define PyMem_NEW(type, n) \
+	( (type *) PyMem_MALLOC((n) * sizeof(type)) )
+
+#define PyMem_Resize(p, type, n) \
+	( (p) = (type *) PyMem_Realloc((p), (n) * sizeof(type)) )
+#define PyMem_RESIZE(p, type, n) \
+	( (p) = (type *) PyMem_REALLOC((p), (n) * sizeof(type)) )
+
+/* In order to avoid breaking old code mixing PyObject_{New, NEW} with
+   PyMem_{Del, DEL} and PyMem_{Free, FREE}, the PyMem "release memory"
+   functions have to be redirected to the object deallocator. */
+#define PyMem_Del		PyObject_Free
+#define PyMem_DEL		PyObject_FREE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_PYMEM_H */

Added: trunk/mingw-libs/include/pyport.h
===================================================================
--- trunk/mingw-libs/include/pyport.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pyport.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,637 @@
+#ifndef Py_PYPORT_H
+#define Py_PYPORT_H
+
+#include "pyconfig.h" /* include for defines */
+
+/**************************************************************************
+Symbols and macros to supply platform-independent interfaces to basic
+C language & library operations whose spellings vary across platforms.
+
+Please try to make documentation here as clear as possible:  by definition,
+the stuff here is trying to illuminate C's darkest corners.
+
+Config #defines referenced here:
+
+SIGNED_RIGHT_SHIFT_ZERO_FILLS
+Meaning:  To be defined iff i>>j does not extend the sign bit when i is a
+          signed integral type and i < 0.
+Used in:  Py_ARITHMETIC_RIGHT_SHIFT
+
+Py_DEBUG
+Meaning:  Extra checks compiled in for debug mode.
+Used in:  Py_SAFE_DOWNCAST
+
+HAVE_UINTPTR_T
+Meaning:  The C9X type uintptr_t is supported by the compiler
+Used in:  Py_uintptr_t
+
+HAVE_LONG_LONG
+Meaning:  The compiler supports the C type "long long"
+Used in:  PY_LONG_LONG
+
+**************************************************************************/
+
+
+/* For backward compatibility only. Obsolete, do not use. */
+#ifdef HAVE_PROTOTYPES
+#define Py_PROTO(x) x
+#else
+#define Py_PROTO(x) ()
+#endif
+#ifndef Py_FPROTO
+#define Py_FPROTO(x) Py_PROTO(x)
+#endif
+
+/* typedefs for some C9X-defined synonyms for integral types.
+ *
+ * The names in Python are exactly the same as the C9X names, except with a
+ * Py_ prefix.  Until C9X is universally implemented, this is the only way
+ * to ensure that Python gets reliable names that don't conflict with names
+ * in non-Python code that are playing their own tricks to define the C9X
+ * names.
+ *
+ * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
+ * integral synonyms.  Only define the ones we actually need.
+ */
+
+#ifdef HAVE_LONG_LONG
+#ifndef PY_LONG_LONG
+#define PY_LONG_LONG long long
+#endif
+#endif /* HAVE_LONG_LONG */
+
+/* uintptr_t is the C9X name for an unsigned integral type such that a
+ * legitimate void* can be cast to uintptr_t and then back to void* again
+ * without loss of information.  Similarly for intptr_t, wrt a signed
+ * integral type.
+ */
+#ifdef HAVE_UINTPTR_T
+typedef uintptr_t	Py_uintptr_t;
+typedef intptr_t	Py_intptr_t;
+
+#elif SIZEOF_VOID_P <= SIZEOF_INT
+typedef unsigned int	Py_uintptr_t;
+typedef int		Py_intptr_t;
+
+#elif SIZEOF_VOID_P <= SIZEOF_LONG
+typedef unsigned long	Py_uintptr_t;
+typedef long		Py_intptr_t;
+
+#elif defined(HAVE_LONG_LONG) && (SIZEOF_VOID_P <= SIZEOF_LONG_LONG)
+typedef unsigned PY_LONG_LONG	Py_uintptr_t;
+typedef PY_LONG_LONG		Py_intptr_t;
+
+#else
+#   error "Python needs a typedef for Py_uintptr_t in pyport.h."
+#endif /* HAVE_UINTPTR_T */
+
+#include <stdlib.h>
+
+#include <math.h> /* Moved here from the math section, before extern "C" */
+
+/********************************************
+ * WRAPPER FOR <time.h> and/or <sys/time.h> *
+ ********************************************/
+
+#ifdef TIME_WITH_SYS_TIME
+#include <sys/time.h>
+#include <time.h>
+#else /* !TIME_WITH_SYS_TIME */
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#else /* !HAVE_SYS_TIME_H */
+#include <time.h>
+#endif /* !HAVE_SYS_TIME_H */
+#endif /* !TIME_WITH_SYS_TIME */
+
+
+/******************************
+ * WRAPPER FOR <sys/select.h> *
+ ******************************/
+
+/* NB caller must include <sys/types.h> */
+
+#ifdef HAVE_SYS_SELECT_H
+
+#include <sys/select.h>
+
+#endif /* !HAVE_SYS_SELECT_H */
+
+/*******************************
+ * stat() and fstat() fiddling *
+ *******************************/
+
+/* We expect that stat and fstat exist on most systems.
+ *  It's confirmed on Unix, Mac and Windows.
+ *  If you don't have them, add
+ *      #define DONT_HAVE_STAT
+ * and/or
+ *      #define DONT_HAVE_FSTAT
+ * to your pyconfig.h. Python code beyond this should check HAVE_STAT and
+ * HAVE_FSTAT instead.
+ * Also
+ *      #define DONT_HAVE_SYS_STAT_H
+ * if <sys/stat.h> doesn't exist on your platform, and
+ *      #define HAVE_STAT_H
+ * if <stat.h> does (don't look at me -- ths mess is inherited).
+ */
+#ifndef DONT_HAVE_STAT
+#define HAVE_STAT
+#endif
+
+#ifndef DONT_HAVE_FSTAT
+#define HAVE_FSTAT
+#endif
+
+#ifdef RISCOS
+#include <sys/types.h>
+#include "unixstuff.h"
+#endif
+
+#ifndef DONT_HAVE_SYS_STAT_H
+#if defined(PYOS_OS2) && defined(PYCC_GCC)
+#include <sys/types.h>
+#endif
+#include <sys/stat.h>
+#elif defined(HAVE_STAT_H)
+#include <stat.h>
+#endif
+
+#if defined(PYCC_VACPP)
+/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */
+#define S_IFMT (S_IFDIR|S_IFCHR|S_IFREG)
+#endif
+
+#ifndef S_ISREG
+#define S_ISREG(x) (((x) & S_IFMT) == S_IFREG)
+#endif
+
+#ifndef S_ISDIR
+#define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)
+#endif
+
+
+#ifdef __cplusplus
+/* Move this down here since some C++ #include's don't like to be included
+   inside an extern "C" */
+extern "C" {
+#endif
+
+
+/* Py_ARITHMETIC_RIGHT_SHIFT
+ * C doesn't define whether a right-shift of a signed integer sign-extends
+ * or zero-fills.  Here a macro to force sign extension:
+ * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
+ *    Return I >> J, forcing sign extension.
+ * Requirements:
+ *    I is of basic signed type TYPE (char, short, int, long, or long long).
+ *    TYPE is one of char, short, int, long, or long long, although long long
+ *    must not be used except on platforms that support it.
+ *    J is an integer >= 0 and strictly less than the number of bits in TYPE
+ *    (because C doesn't define what happens for J outside that range either).
+ * Caution:
+ *    I may be evaluated more than once.
+ */
+#ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS
+#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) \
+	((I) < 0 ? ~((~(unsigned TYPE)(I)) >> (J)) : (I) >> (J))
+#else
+#define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) >> (J))
+#endif
+
+/* Py_FORCE_EXPANSION(X)
+ * "Simply" returns its argument.  However, macro expansions within the
+ * argument are evaluated.  This unfortunate trickery is needed to get
+ * token-pasting to work as desired in some cases.
+ */
+#define Py_FORCE_EXPANSION(X) X
+
+/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
+ * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
+ * assert-fails if any information is lost.
+ * Caution:
+ *    VALUE may be evaluated more than once.
+ */
+#ifdef Py_DEBUG
+#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) \
+	(assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))
+#else
+#define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)
+#endif
+
+/* Py_IS_NAN(X)
+ * Return 1 if float or double arg is a NaN, else 0.
+ * Caution:
+ *     X is evaluated more than once.
+ *     This may not work on all platforms.  Each platform has *some*
+ *     way to spell this, though -- override in pyconfig.h if you have
+ *     a platform where it doesn't work.
+ */
+#ifndef Py_IS_NAN
+#define Py_IS_NAN(X) ((X) != (X))
+#endif
+
+/* Py_IS_INFINITY(X)
+ * Return 1 if float or double arg is an infinity, else 0.
+ * Caution:
+ *    X is evaluated more than once.
+ *    This implementation may set the underflow flag if |X| is very small;
+ *    it really can't be implemented correctly (& easily) before C99.
+ *    Override in pyconfig.h if you have a better spelling on your platform.
+ */
+#ifndef Py_IS_INFINITY
+#define Py_IS_INFINITY(X) ((X) && (X)*0.5 == (X))
+#endif
+
+/* HUGE_VAL is supposed to expand to a positive double infinity.  Python
+ * uses Py_HUGE_VAL instead because some platforms are broken in this
+ * respect.  We used to embed code in pyport.h to try to worm around that,
+ * but different platforms are broken in conflicting ways.  If you're on
+ * a platform where HUGE_VAL is defined incorrectly, fiddle your Python
+ * config to #define Py_HUGE_VAL to something that works on your platform.
+ */
+#ifndef Py_HUGE_VAL
+#define Py_HUGE_VAL HUGE_VAL
+#endif
+
+/* Py_OVERFLOWED(X)
+ * Return 1 iff a libm function overflowed.  Set errno to 0 before calling
+ * a libm function, and invoke this macro after, passing the function
+ * result.
+ * Caution:
+ *    This isn't reliable.  C99 no longer requires libm to set errno under
+ *	  any exceptional condition, but does require +- HUGE_VAL return
+ *	  values on overflow.  A 754 box *probably* maps HUGE_VAL to a
+ *	  double infinity, and we're cool if that's so, unless the input
+ *	  was an infinity and an infinity is the expected result.  A C89
+ *	  system sets errno to ERANGE, so we check for that too.  We're
+ *	  out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or
+ *	  if the returned result is a NaN, or if a C89 box returns HUGE_VAL
+ *	  in non-overflow cases.
+ *    X is evaluated more than once.
+ * Some platforms have better way to spell this, so expect some #ifdef'ery.
+ *
+ * OpenBSD uses 'isinf()' because a compiler bug on that platform causes
+ * the longer macro version to be mis-compiled. This isn't optimal, and
+ * should be removed once a newer compiler is available on that platform.
+ * The system that had the failure was running OpenBSD 3.2 on Intel, with
+ * gcc 2.95.3.
+ *
+ * According to Tim's checkin, the FreeBSD systems use isinf() to work
+ * around a FPE bug on that platform.
+ */
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#define Py_OVERFLOWED(X) isinf(X)
+#else
+#define Py_OVERFLOWED(X) ((X) != 0.0 && (errno == ERANGE ||    \
+					 (X) == Py_HUGE_VAL || \
+					 (X) == -Py_HUGE_VAL))
+#endif
+
+/* Py_SET_ERRNO_ON_MATH_ERROR(x)
+ * If a libm function did not set errno, but it looks like the result
+ * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
+ * to 0 before calling a libm function, and invoke this macro after,
+ * passing the function result.
+ * Caution:
+ *    This isn't reliable.  See Py_OVERFLOWED comments.
+ *    X is evaluated more than once.
+ */
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#define _Py_SET_EDOM_FOR_NAN(X) if (isnan(X)) errno = EDOM;
+#else
+#define _Py_SET_EDOM_FOR_NAN(X) ;
+#endif
+#define Py_SET_ERRNO_ON_MATH_ERROR(X) \
+	do { \
+		if (errno == 0) { \
+			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL) \
+				errno = ERANGE; \
+			else _Py_SET_EDOM_FOR_NAN(X) \
+		} \
+	} while(0)
+
+/* Py_SET_ERANGE_ON_OVERFLOW(x)
+ * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
+ */
+#define Py_SET_ERANGE_IF_OVERFLOW(X) Py_SET_ERRNO_ON_MATH_ERROR(X)
+
+/* Py_ADJUST_ERANGE1(x)
+ * Py_ADJUST_ERANGE2(x, y)
+ * Set errno to 0 before calling a libm function, and invoke one of these
+ * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
+ * for functions returning complex results).  This makes two kinds of
+ * adjustments to errno:  (A) If it looks like the platform libm set
+ * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
+ * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
+ * effect, we're trying to force a useful implementation of C89 errno
+ * behavior.
+ * Caution:
+ *    This isn't reliable.  See Py_OVERFLOWED comments.
+ *    X and Y may be evaluated more than once.
+ */
+#define Py_ADJUST_ERANGE1(X)						\
+	do {								\
+		if (errno == 0) {					\
+			if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)	\
+				errno = ERANGE;				\
+		}							\
+		else if (errno == ERANGE && (X) == 0.0)			\
+			errno = 0;					\
+	} while(0)
+
+#define Py_ADJUST_ERANGE2(X, Y)						\
+	do {								\
+		if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||	\
+		    (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {	\
+				if (errno == 0)				\
+					errno = ERANGE;			\
+		}							\
+		else if (errno == ERANGE)				\
+			errno = 0;					\
+	} while(0)
+
+/* Py_DEPRECATED(version)
+ * Declare a variable, type, or function deprecated.
+ * Usage:
+ *    extern int old_var Py_DEPRECATED(2.3);
+ *    typedef int T1 Py_DEPRECATED(2.4);
+ *    extern int x() Py_DEPRECATED(2.5);
+ */
+#if defined(__GNUC__) && (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)
+#define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))
+#else
+#define Py_DEPRECATED(VERSION_UNUSED)
+#endif
+
+/**************************************************************************
+Prototypes that are missing from the standard include files on some systems
+(and possibly only some versions of such systems.)
+
+Please be conservative with adding new ones, document them and enclose them
+in platform-specific #ifdefs.
+**************************************************************************/
+
+#ifdef SOLARIS
+/* Unchecked */
+extern int gethostname(char *, int);
+#endif
+
+#ifdef __BEOS__
+/* Unchecked */
+/* It's in the libs, but not the headers... - [cjh] */
+int shutdown( int, int );
+#endif
+
+#ifdef HAVE__GETPTY
+#include <sys/types.h>		/* we need to import mode_t */
+extern char * _getpty(int *, int, mode_t, int);
+#endif
+
+#if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY)
+#if !defined(HAVE_PTY_H) && !defined(HAVE_LIBUTIL_H)
+/* BSDI does not supply a prototype for the 'openpty' and 'forkpty'
+   functions, even though they are included in libutil. */
+#include <termios.h>
+extern int openpty(int *, int *, char *, struct termios *, struct winsize *);
+extern int forkpty(int *, char *, struct termios *, struct winsize *);
+#endif /* !defined(HAVE_PTY_H) && !defined(HAVE_LIBUTIL_H) */
+#endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */
+
+
+/* These are pulled from various places. It isn't obvious on what platforms
+   they are necessary, nor what the exact prototype should look like (which
+   is likely to vary between platforms!) If you find you need one of these
+   declarations, please move them to a platform-specific block and include
+   proper prototypes. */
+#if 0
+
+/* From Modules/resource.c */
+extern int getrusage();
+extern int getpagesize();
+
+/* From Python/sysmodule.c and Modules/posixmodule.c */
+extern int fclose(FILE *);
+
+/* From Modules/posixmodule.c */
+extern int fdatasync(int);
+#endif /* 0 */
+
+
+/************************
+ * WRAPPER FOR <math.h> *
+ ************************/
+
+#ifndef HAVE_HYPOT
+extern double hypot(double, double);
+#endif
+
+
+/*******************************************************************
+On 4.4BSD-descendants, ctype functions serves the whole range of
+wchar_t character set rather than single byte code points only.
+This characteristic can break some operations of string object
+including str.upper() and str.split() on UTF-8 locales.  This
+workaround was provided by Tim Robbins of FreeBSD project.  He said
+the incompatibility will be fixed in FreeBSD 6.
+********************************************************************/
+
+#ifdef __FreeBSD__
+#include <osreldate.h>
+#if __FreeBSD_version > 500039
+#include <ctype.h>
+#include <wctype.h>
+#undef isalnum
+#define isalnum(c) iswalnum(btowc(c))
+#undef isalpha
+#define isalpha(c) iswalpha(btowc(c))
+#undef islower
+#define islower(c) iswlower(btowc(c))
+#undef isspace
+#define isspace(c) iswspace(btowc(c))
+#undef isupper
+#define isupper(c) iswupper(btowc(c))
+#undef tolower
+#define tolower(c) towlower(btowc(c))
+#undef toupper
+#define toupper(c) towupper(btowc(c))
+#endif
+#endif
+
+
+/* Declarations for symbol visibility.
+
+  PyAPI_FUNC(type): Declares a public Python API function and return type
+  PyAPI_DATA(type): Declares public Python data and its type
+  PyMODINIT_FUNC:   A Python module init function.  If these functions are
+                    inside the Python core, they are private to the core.
+                    If in an extension module, it may be declared with
+                    external linkage depending on the platform.
+
+  As a number of platforms support/require "__declspec(dllimport/dllexport)",
+  we support a HAVE_DECLSPEC_DLL macro to save duplication.
+*/
+
+/*
+  All windows ports, except cygwin, are handled in PC/pyconfig.h.
+
+  BeOS and cygwin are the only other autoconf platform requiring special
+  linkage handling and both of these use __declspec().
+*/
+#if defined(__CYGWIN__) || defined(__BEOS__)
+#	define HAVE_DECLSPEC_DLL
+#endif
+
+/* only get special linkage if built as shared or platform is Cygwin */
+#if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
+#	if defined(HAVE_DECLSPEC_DLL)
+#		ifdef Py_BUILD_CORE
+#			define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE
+#			define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE
+			/* module init functions inside the core need no external linkage */
+			/* except for Cygwin to handle embedding (FIXME: BeOS too?) */
+#			if defined(__CYGWIN__)
+#				define PyMODINIT_FUNC __declspec(dllexport) void
+#			else /* __CYGWIN__ */
+#				define PyMODINIT_FUNC void
+#			endif /* __CYGWIN__ */
+#		else /* Py_BUILD_CORE */
+			/* Building an extension module, or an embedded situation */
+			/* public Python functions and data are imported */
+			/* Under Cygwin, auto-import functions to prevent compilation */
+			/* failures similar to http://python.org/doc/FAQ.html#3.24 */
+#			if !defined(__CYGWIN__)
+#				define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
+#			endif /* !__CYGWIN__ */
+#			define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
+			/* module init functions outside the core must be exported */
+#			if defined(__cplusplus)
+#				define PyMODINIT_FUNC extern "C" __declspec(dllexport) void
+#			else /* __cplusplus */
+#				define PyMODINIT_FUNC __declspec(dllexport) void
+#			endif /* __cplusplus */
+#		endif /* Py_BUILD_CORE */
+#	endif /* HAVE_DECLSPEC */
+#endif /* Py_ENABLE_SHARED */
+
+/* If no external linkage macros defined by now, create defaults */
+#ifndef PyAPI_FUNC
+#	define PyAPI_FUNC(RTYPE) RTYPE
+#endif
+#ifndef PyAPI_DATA
+#	define PyAPI_DATA(RTYPE) extern RTYPE
+#endif
+#ifndef PyMODINIT_FUNC
+#	if defined(__cplusplus)
+#		define PyMODINIT_FUNC extern "C" void
+#	else /* __cplusplus */
+#		define PyMODINIT_FUNC void
+#	endif /* __cplusplus */
+#endif
+
+/* Deprecated DL_IMPORT and DL_EXPORT macros */
+#if defined(Py_ENABLE_SHARED) && defined (HAVE_DECLSPEC_DLL)
+#	if defined(Py_BUILD_CORE)
+#		define DL_IMPORT(RTYPE) __declspec(dllexport) RTYPE
+#		define DL_EXPORT(RTYPE) __declspec(dllexport) RTYPE
+#	else
+#		define DL_IMPORT(RTYPE) __declspec(dllimport) RTYPE
+#		define DL_EXPORT(RTYPE) __declspec(dllexport) RTYPE
+#	endif
+#endif
+#ifndef DL_EXPORT
+#	define DL_EXPORT(RTYPE) RTYPE
+#endif
+#ifndef DL_IMPORT
+#	define DL_IMPORT(RTYPE) RTYPE
+#endif
+/* End of deprecated DL_* macros */
+
+/* If the fd manipulation macros aren't defined,
+   here is a set that should do the job */
+
+#if 0 /* disabled and probably obsolete */
+
+#ifndef	FD_SETSIZE
+#define	FD_SETSIZE	256
+#endif
+
+#ifndef FD_SET
+
+typedef long fd_mask;
+
+#define NFDBITS	(sizeof(fd_mask) * NBBY)	/* bits per mask */
+#ifndef howmany
+#define	howmany(x, y)	(((x)+((y)-1))/(y))
+#endif /* howmany */
+
+typedef	struct fd_set {
+	fd_mask	fds_bits[howmany(FD_SETSIZE, NFDBITS)];
+} fd_set;
+
+#define	FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
+#define	FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
+#define	FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
+#define FD_ZERO(p)	memset((char *)(p), '\0', sizeof(*(p)))
+
+#endif /* FD_SET */
+
+#endif /* fd manipulation macros */
+
+
+/* limits.h constants that may be missing */
+
+#ifndef INT_MAX
+#define INT_MAX 2147483647
+#endif
+
+#ifndef LONG_MAX
+#if SIZEOF_LONG == 4
+#define LONG_MAX 0X7FFFFFFFL
+#elif SIZEOF_LONG == 8
+#define LONG_MAX 0X7FFFFFFFFFFFFFFFL
+#else
+#error "could not set LONG_MAX in pyport.h"
+#endif
+#endif
+
+#ifndef LONG_MIN
+#define LONG_MIN (-LONG_MAX-1)
+#endif
+
+#ifndef LONG_BIT
+#define LONG_BIT (8 * SIZEOF_LONG)
+#endif
+
+#if LONG_BIT != 8 * SIZEOF_LONG
+/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
+ * 32-bit platforms using gcc.  We try to catch that here at compile-time
+ * rather than waiting for integer multiplication to trigger bogus
+ * overflows.
+ */
+#error "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/*
+ * Hide GCC attributes from compilers that don't support them.
+ */
+#if (!defined(__GNUC__) || __GNUC__ < 2 || \
+     (__GNUC__ == 2 && __GNUC_MINOR__ < 7) ) && \
+    !defined(RISCOS)
+#define Py_GCC_ATTRIBUTE(x)
+#else
+#define Py_GCC_ATTRIBUTE(x) __attribute__(x)
+#endif
+
+/* Eliminate end-of-loop code not reached warnings from SunPro C
+ * when using do{...}while(0) macros
+ */
+#ifdef __SUNPRO_C
+#pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)
+#endif
+
+#endif /* Py_PYPORT_H */

Added: trunk/mingw-libs/include/pystate.h
===================================================================
--- trunk/mingw-libs/include/pystate.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pystate.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,185 @@
+
+/* Thread and interpreter state structures and their interfaces */
+
+
+#ifndef Py_PYSTATE_H
+#define Py_PYSTATE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* State shared between threads */
+
+struct _ts; /* Forward */
+struct _is; /* Forward */
+
+typedef struct _is {
+
+    struct _is *next;
+    struct _ts *tstate_head;
+
+    PyObject *modules;
+    PyObject *sysdict;
+    PyObject *builtins;
+
+    PyObject *codec_search_path;
+    PyObject *codec_search_cache;
+    PyObject *codec_error_registry;
+
+#ifdef HAVE_DLOPEN
+    int dlopenflags;
+#endif
+#ifdef WITH_TSC
+    int tscdump;
+#endif
+
+} PyInterpreterState;
+
+
+/* State unique per thread */
+
+struct _frame; /* Avoid including frameobject.h */
+
+/* Py_tracefunc return -1 when raising an exception, or 0 for success. */
+typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);
+
+/* The following values are used for 'what' for tracefunc functions: */
+#define PyTrace_CALL 0
+#define PyTrace_EXCEPTION 1
+#define PyTrace_LINE 2
+#define PyTrace_RETURN 3
+#define PyTrace_C_CALL 4
+#define PyTrace_C_EXCEPTION 5
+#define PyTrace_C_RETURN 6
+
+typedef struct _ts {
+
+    struct _ts *next;
+    PyInterpreterState *interp;
+
+    struct _frame *frame;
+    int recursion_depth;
+    int tracing;
+    int use_tracing;
+
+    Py_tracefunc c_profilefunc;
+    Py_tracefunc c_tracefunc;
+    PyObject *c_profileobj;
+    PyObject *c_traceobj;
+
+    PyObject *curexc_type;
+    PyObject *curexc_value;
+    PyObject *curexc_traceback;
+
+    PyObject *exc_type;
+    PyObject *exc_value;
+    PyObject *exc_traceback;
+
+    PyObject *dict;
+
+    /* tick_counter is incremented whenever the check_interval ticker
+     * reaches zero. The purpose is to give a useful measure of the number
+     * of interpreted bytecode instructions in a given thread.  This
+     * extremely lightweight statistic collector may be of interest to
+     * profilers (like psyco.jit()), although nothing in the core uses it.
+     */
+    int tick_counter;
+
+    int gilstate_counter;
+
+    PyObject *async_exc; /* Asynchronous exception to raise */
+    long thread_id; /* Thread id where this tstate was created */
+
+    /* XXX signal handlers should also be here */
+
+} PyThreadState;
+
+
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
+PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
+PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
+
+PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
+PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
+#ifdef WITH_THREAD
+PyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);
+#endif
+
+PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
+PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
+PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
+PyAPI_FUNC(int) PyThreadState_SetAsyncExc(long, PyObject *);
+
+
+/* Variable and macro for in-line access to current thread state */
+
+PyAPI_DATA(PyThreadState *) _PyThreadState_Current;
+
+#ifdef Py_DEBUG
+#define PyThreadState_GET() PyThreadState_Get()
+#else
+#define PyThreadState_GET() (_PyThreadState_Current)
+#endif
+
+typedef
+    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
+        PyGILState_STATE;
+
+/* Ensure that the current thread is ready to call the Python
+   C API, regardless of the current state of Python, or of its
+   thread lock.  This may be called as many times as desired
+   by a thread so long as each call is matched with a call to
+   PyGILState_Release().  In general, other thread-state APIs may
+   be used between _Ensure() and _Release() calls, so long as the
+   thread-state is restored to its previous state before the Release().
+   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
+   Py_END_ALLOW_THREADS macros are acceptable.
+
+   The return value is an opaque "handle" to the thread state when
+   PyGILState_Ensure() was called, and must be passed to
+   PyGILState_Release() to ensure Python is left in the same state. Even
+   though recursive calls are allowed, these handles can *not* be shared -
+   each unique call to PyGILState_Ensure must save the handle for its
+   call to PyGILState_Release.
+
+   When the function returns, the current thread will hold the GIL.
+
+   Failure is a fatal error.
+*/
+PyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);
+
+/* Release any resources previously acquired.  After this call, Python's
+   state will be the same as it was prior to the corresponding
+   PyGILState_Ensure() call (but generally this state will be unknown to
+   the caller, hence the use of the GILState API.)
+
+   Every call to PyGILState_Ensure must be matched by a call to
+   PyGILState_Release on the same thread.
+*/
+PyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);
+
+/* Helper/diagnostic function - get the current thread state for
+   this thread.  May return NULL if no GILState API has been used
+   on the current thread.  Note the main thread always has such a
+   thread-state, even if no auto-thread-state call has been made
+   on the main thread.
+*/
+PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
+
+/* Routines for advanced debuggers, requested by David Beazley.
+   Don't use unless you know what you are doing! */
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Head(void);
+PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Next(PyInterpreterState *);
+PyAPI_FUNC(PyThreadState *) PyInterpreterState_ThreadHead(PyInterpreterState *);
+PyAPI_FUNC(PyThreadState *) PyThreadState_Next(PyThreadState *);
+
+typedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);
+
+/* hook for PyEval_GetFrame(), requested for Psyco */
+PyAPI_DATA(PyThreadFrameGetter) _PyThreadState_GetFrame;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYSTATE_H */

Added: trunk/mingw-libs/include/pystrtod.h
===================================================================
--- trunk/mingw-libs/include/pystrtod.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pystrtod.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,18 @@
+#ifndef Py_STRTOD_H
+#define Py_STRTOD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+PyAPI_FUNC(double) PyOS_ascii_strtod(const char *str, char **ptr);
+PyAPI_FUNC(double) PyOS_ascii_atof(const char *str);
+PyAPI_FUNC(char *) PyOS_ascii_formatd(char *buffer, int buf_len,  const char *format, double d);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_STRTOD_H */

Added: trunk/mingw-libs/include/pythonrun.h
===================================================================
--- trunk/mingw-libs/include/pythonrun.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pythonrun.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,152 @@
+
+/* Interfaces to parse and execute pieces of python code */
+
+#ifndef Py_PYTHONRUN_H
+#define Py_PYTHONRUN_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PyCF_MASK (CO_FUTURE_DIVISION)
+#define PyCF_MASK_OBSOLETE (CO_GENERATOR_ALLOWED | CO_NESTED)
+#define PyCF_SOURCE_IS_UTF8  0x0100
+#define PyCF_DONT_IMPLY_DEDENT 0x0200
+
+typedef struct {
+	int cf_flags;  /* bitmask of CO_xxx flags relevant to future */
+} PyCompilerFlags;
+
+PyAPI_FUNC(void) Py_SetProgramName(char *);
+PyAPI_FUNC(char *) Py_GetProgramName(void);
+
+PyAPI_FUNC(void) Py_SetPythonHome(char *);
+PyAPI_FUNC(char *) Py_GetPythonHome(void);
+
+PyAPI_FUNC(void) Py_Initialize(void);
+PyAPI_FUNC(void) Py_InitializeEx(int);
+PyAPI_FUNC(void) Py_Finalize(void);
+PyAPI_FUNC(int) Py_IsInitialized(void);
+PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
+PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
+
+PyAPI_FUNC(int) PyRun_AnyFile(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_AnyFileEx(FILE *, const char *, int);
+
+PyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_AnyFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
+
+PyAPI_FUNC(int) PyRun_SimpleString(const char *);
+PyAPI_FUNC(int) PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_SimpleFile(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_SimpleFileEx(FILE *, const char *, int);
+PyAPI_FUNC(int) PyRun_SimpleFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_InteractiveOne(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_InteractiveOneFlags(FILE *, const char *, PyCompilerFlags *);
+PyAPI_FUNC(int) PyRun_InteractiveLoop(FILE *, const char *);
+PyAPI_FUNC(int) PyRun_InteractiveLoopFlags(FILE *, const char *, PyCompilerFlags *);
+
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseString(const char *, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseFile(FILE *, const char *, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlags(const char *, int, int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlagsFilename(const char *,
+								  const char *,
+								  int,
+								  int);
+PyAPI_FUNC(struct _node *) PyParser_SimpleParseFileFlags(FILE *, const char *,
+							int, int);
+
+PyAPI_FUNC(PyObject *) PyRun_String(const char *, int, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyRun_File(FILE *, const char *, int, PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyRun_FileEx(FILE *, const char *, int,
+				   PyObject *, PyObject *, int);
+PyAPI_FUNC(PyObject *) PyRun_StringFlags(const char *, int, PyObject *, PyObject *,
+					PyCompilerFlags *);
+PyAPI_FUNC(PyObject *) PyRun_FileFlags(FILE *, const char *, int, PyObject *, 
+				      PyObject *, PyCompilerFlags *);
+PyAPI_FUNC(PyObject *) PyRun_FileExFlags(FILE *, const char *, int, PyObject *, 
+					PyObject *, int, PyCompilerFlags *);
+
+PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
+PyAPI_FUNC(PyObject *) Py_CompileStringFlags(const char *, const char *, int,
+					    PyCompilerFlags *);
+PyAPI_FUNC(struct symtable *) Py_SymtableString(const char *, const char *, int);
+
+PyAPI_FUNC(void) PyErr_Print(void);
+PyAPI_FUNC(void) PyErr_PrintEx(int);
+PyAPI_FUNC(void) PyErr_Display(PyObject *, PyObject *, PyObject *);
+
+PyAPI_FUNC(int) Py_AtExit(void (*func)(void));
+
+PyAPI_FUNC(void) Py_Exit(int);
+
+PyAPI_FUNC(int) Py_FdIsInteractive(FILE *, const char *);
+
+/* Bootstrap */
+PyAPI_FUNC(int) Py_Main(int argc, char **argv);
+
+/* In getpath.c */
+PyAPI_FUNC(char *) Py_GetProgramFullPath(void);
+PyAPI_FUNC(char *) Py_GetPrefix(void);
+PyAPI_FUNC(char *) Py_GetExecPrefix(void);
+PyAPI_FUNC(char *) Py_GetPath(void);
+
+/* In their own files */
+PyAPI_FUNC(const char *) Py_GetVersion(void);
+PyAPI_FUNC(const char *) Py_GetPlatform(void);
+PyAPI_FUNC(const char *) Py_GetCopyright(void);
+PyAPI_FUNC(const char *) Py_GetCompiler(void);
+PyAPI_FUNC(const char *) Py_GetBuildInfo(void);
+
+/* Internal -- various one-time initializations */
+PyAPI_FUNC(PyObject *) _PyBuiltin_Init(void);
+PyAPI_FUNC(PyObject *) _PySys_Init(void);
+PyAPI_FUNC(void) _PyImport_Init(void);
+PyAPI_FUNC(void) _PyExc_Init(void);
+PyAPI_FUNC(void) _PyImportHooks_Init(void);
+PyAPI_FUNC(int) _PyFrame_Init(void);
+PyAPI_FUNC(int) _PyInt_Init(void);
+
+/* Various internal finalizers */
+PyAPI_FUNC(void) _PyExc_Fini(void);
+PyAPI_FUNC(void) _PyImport_Fini(void);
+PyAPI_FUNC(void) PyMethod_Fini(void);
+PyAPI_FUNC(void) PyFrame_Fini(void);
+PyAPI_FUNC(void) PyCFunction_Fini(void);
+PyAPI_FUNC(void) PyTuple_Fini(void);
+PyAPI_FUNC(void) PyList_Fini(void);
+PyAPI_FUNC(void) PyString_Fini(void);
+PyAPI_FUNC(void) PyInt_Fini(void);
+PyAPI_FUNC(void) PyFloat_Fini(void);
+PyAPI_FUNC(void) PyOS_FiniInterrupts(void);
+
+/* Stuff with no proper home (yet) */
+PyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, char *);
+PyAPI_DATA(int) (*PyOS_InputHook)(void);
+PyAPI_DATA(char) *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, char *);
+PyAPI_DATA(PyThreadState*) _PyOS_ReadlineTState;
+
+/* Stack size, in "pointers" (so we get extra safety margins
+   on 64-bit platforms).  On a 32-bit platform, this translates
+   to a 8k margin. */
+#define PYOS_STACK_MARGIN 2048
+
+#if defined(WIN32) && !defined(MS_WIN64) && defined(_MSC_VER)
+/* Enable stack checking under Microsoft C */
+#define USE_STACKCHECK
+#endif
+
+#ifdef USE_STACKCHECK
+/* Check that we aren't overflowing our stack */
+PyAPI_FUNC(int) PyOS_CheckStack(void);
+#endif
+
+/* Signals */
+typedef void (*PyOS_sighandler_t)(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYTHONRUN_H */

Added: trunk/mingw-libs/include/pythread.h
===================================================================
--- trunk/mingw-libs/include/pythread.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/pythread.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,44 @@
+
+#ifndef Py_PYTHREAD_H
+#define Py_PYTHREAD_H
+
+#define NO_EXIT_PROG		/* don't define PyThread_exit_prog() */
+				/* (the result is no use of signals on SGI) */
+
+typedef void *PyThread_type_lock;
+typedef void *PyThread_type_sema;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_FUNC(void) PyThread_init_thread(void);
+PyAPI_FUNC(long) PyThread_start_new_thread(void (*)(void *), void *);
+PyAPI_FUNC(void) PyThread_exit_thread(void);
+PyAPI_FUNC(void) PyThread__PyThread_exit_thread(void);
+PyAPI_FUNC(long) PyThread_get_thread_ident(void);
+
+PyAPI_FUNC(PyThread_type_lock) PyThread_allocate_lock(void);
+PyAPI_FUNC(void) PyThread_free_lock(PyThread_type_lock);
+PyAPI_FUNC(int) PyThread_acquire_lock(PyThread_type_lock, int);
+#define WAIT_LOCK	1
+#define NOWAIT_LOCK	0
+PyAPI_FUNC(void) PyThread_release_lock(PyThread_type_lock);
+
+#ifndef NO_EXIT_PROG
+PyAPI_FUNC(void) PyThread_exit_prog(int);
+PyAPI_FUNC(void) PyThread__PyThread_exit_prog(int);
+#endif
+
+/* Thread Local Storage (TLS) API */
+PyAPI_FUNC(int) PyThread_create_key(void);
+PyAPI_FUNC(void) PyThread_delete_key(int);
+PyAPI_FUNC(int) PyThread_set_key_value(int, void *);
+PyAPI_FUNC(void *) PyThread_get_key_value(int);
+PyAPI_FUNC(void) PyThread_delete_key_value(int key);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !Py_PYTHREAD_H */

Added: trunk/mingw-libs/include/rangeobject.h
===================================================================
--- trunk/mingw-libs/include/rangeobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/rangeobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,30 @@
+
+/* Range object interface */
+
+#ifndef Py_RANGEOBJECT_H
+#define Py_RANGEOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This is about the type 'xrange', not the built-in function range(), which
+   returns regular lists. */
+
+/*
+A range object represents an integer range.  This is an immutable object;
+a range cannot change its value after creation.
+
+Range objects behave like the corresponding tuple objects except that
+they are represented by a start, stop, and step datamembers.
+*/
+
+PyAPI_DATA(PyTypeObject) PyRange_Type;
+
+#define PyRange_Check(op) ((op)->ob_type == &PyRange_Type)
+
+PyAPI_FUNC(PyObject *) PyRange_New(long, long, long, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_RANGEOBJECT_H */

Added: trunk/mingw-libs/include/setobject.h
===================================================================
--- trunk/mingw-libs/include/setobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/setobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,41 @@
+
+/* Set object interface */
+
+#ifndef Py_SETOBJECT_H
+#define Py_SETOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+This data structure is shared by set and frozenset objects.
+*/
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *data;
+	long hash;	/* only used by frozenset objects */
+	PyObject *weakreflist; /* List of weak references */
+
+	/* Invariants:
+	 *     data is a dictionary whose values are all True.
+	 *     data points to the same dict for the whole life of the set.
+	 * For frozensets only:
+	 *     data is immutable.
+	 *     hash is the hash of the frozenset or -1 if not computed yet.
+	 */
+} PySetObject;
+
+PyAPI_DATA(PyTypeObject) PySet_Type;
+PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
+
+#define PyFrozenSet_CheckExact(ob) ((ob)->ob_type == &PyFrozenSet_Type)
+#define PyAnySet_Check(ob) \
+	((ob)->ob_type == &PySet_Type || (ob)->ob_type == &PyFrozenSet_Type || \
+	  PyType_IsSubtype((ob)->ob_type, &PySet_Type) || \
+	  PyType_IsSubtype((ob)->ob_type, &PyFrozenSet_Type))
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SETOBJECT_H */

Added: trunk/mingw-libs/include/sliceobject.h
===================================================================
--- trunk/mingw-libs/include/sliceobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/sliceobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,42 @@
+#ifndef Py_SLICEOBJECT_H
+#define Py_SLICEOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The unique ellipsis object "..." */
+
+PyAPI_DATA(PyObject) _Py_EllipsisObject; /* Don't use this directly */
+
+#define Py_Ellipsis (&_Py_EllipsisObject)
+
+/* Slice object interface */
+
+/*
+
+A slice object containing start, stop, and step data members (the
+names are from range).  After much talk with Guido, it was decided to
+let these be any arbitrary python type.  Py_None stands for omitted values.
+*/
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *start, *stop, *step;	/* not NULL */
+} PySliceObject;
+
+PyAPI_DATA(PyTypeObject) PySlice_Type;
+
+#define PySlice_Check(op) ((op)->ob_type == &PySlice_Type)
+
+PyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,
+                                  PyObject* step);
+PyAPI_FUNC(int) PySlice_GetIndices(PySliceObject *r, int length,
+                                  int *start, int *stop, int *step);
+PyAPI_FUNC(int) PySlice_GetIndicesEx(PySliceObject *r, int length,
+				    int *start, int *stop, 
+				    int *step, int *slicelength);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SLICEOBJECT_H */

Added: trunk/mingw-libs/include/stringobject.h
===================================================================
--- trunk/mingw-libs/include/stringobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/stringobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,183 @@
+
+/* String object interface */
+
+#ifndef Py_STRINGOBJECT_H
+#define Py_STRINGOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdarg.h>
+
+/*
+Type PyStringObject represents a character string.  An extra zero byte is
+reserved at the end to ensure it is zero-terminated, but a size is
+present so strings with null bytes in them can be represented.  This
+is an immutable object type.
+
+There are functions to create new string objects, to test
+an object for string-ness, and to get the
+string value.  The latter function returns a null pointer
+if the object is not of the proper type.
+There is a variant that takes an explicit size as well as a
+variant that assumes a zero-terminated string.  Note that none of the
+functions should be applied to nil objects.
+*/
+
+/* Caching the hash (ob_shash) saves recalculation of a string's hash value.
+   Interning strings (ob_sstate) tries to ensure that only one string
+   object with a given value exists, so equality tests can be one pointer
+   comparison.  This is generally restricted to strings that "look like"
+   Python identifiers, although the intern() builtin can be used to force
+   interning of any string.
+   Together, these sped the interpreter by up to 20%. */
+
+typedef struct {
+    PyObject_VAR_HEAD
+    long ob_shash;
+    int ob_sstate;
+    char ob_sval[1];
+
+    /* Invariants:
+     *     ob_sval contains space for 'ob_size+1' elements.
+     *     ob_sval[ob_size] == 0.
+     *     ob_shash is the hash of the string or -1 if not computed yet.
+     *     ob_sstate != 0 iff the string object is in stringobject.c's
+     *       'interned' dictionary; in this case the two references
+     *       from 'interned' to this object are *not counted* in ob_refcnt.
+     */
+} PyStringObject;
+
+#define SSTATE_NOT_INTERNED 0
+#define SSTATE_INTERNED_MORTAL 1
+#define SSTATE_INTERNED_IMMORTAL 2
+
+PyAPI_DATA(PyTypeObject) PyBaseString_Type;
+PyAPI_DATA(PyTypeObject) PyString_Type;
+
+#define PyString_Check(op) PyObject_TypeCheck(op, &PyString_Type)
+#define PyString_CheckExact(op) ((op)->ob_type == &PyString_Type)
+
+PyAPI_FUNC(PyObject *) PyString_FromStringAndSize(const char *, int);
+PyAPI_FUNC(PyObject *) PyString_FromString(const char *);
+PyAPI_FUNC(PyObject *) PyString_FromFormatV(const char*, va_list)
+				Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
+PyAPI_FUNC(PyObject *) PyString_FromFormat(const char*, ...)
+				Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(int) PyString_Size(PyObject *);
+PyAPI_FUNC(char *) PyString_AsString(PyObject *);
+PyAPI_FUNC(PyObject *) PyString_Repr(PyObject *, int);
+PyAPI_FUNC(void) PyString_Concat(PyObject **, PyObject *);
+PyAPI_FUNC(void) PyString_ConcatAndDel(PyObject **, PyObject *);
+PyAPI_FUNC(int) _PyString_Resize(PyObject **, int);
+PyAPI_FUNC(int) _PyString_Eq(PyObject *, PyObject*);
+PyAPI_FUNC(PyObject *) PyString_Format(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) _PyString_FormatLong(PyObject*, int, int,
+						  int, char**, int*);
+PyAPI_FUNC(PyObject *) PyString_DecodeEscape(const char *, int, 
+						   const char *, int,
+						   const char *);
+
+PyAPI_FUNC(void) PyString_InternInPlace(PyObject **);
+PyAPI_FUNC(void) PyString_InternImmortal(PyObject **);
+PyAPI_FUNC(PyObject *) PyString_InternFromString(const char *);
+PyAPI_FUNC(void) _Py_ReleaseInternedStrings(void);
+
+/* Use only if you know it's a string */
+#define PyString_CHECK_INTERNED(op) (((PyStringObject *)(op))->ob_sstate)
+
+/* Macro, trading safety for speed */
+#define PyString_AS_STRING(op) (((PyStringObject *)(op))->ob_sval)
+#define PyString_GET_SIZE(op)  (((PyStringObject *)(op))->ob_size)
+
+/* _PyString_Join(sep, x) is like sep.join(x).  sep must be PyStringObject*,
+   x must be an iterable object. */
+PyAPI_FUNC(PyObject *) _PyString_Join(PyObject *sep, PyObject *x);
+
+/* --- Generic Codecs ----------------------------------------------------- */
+
+/* Create an object by decoding the encoded string s of the
+   given size. */
+
+PyAPI_FUNC(PyObject*) PyString_Decode(
+    const char *s,              /* encoded string */
+    int size,                   /* size of buffer */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a char buffer of the given size and returns a 
+   Python object. */
+
+PyAPI_FUNC(PyObject*) PyString_Encode(
+    const char *s,              /* string char buffer */
+    int size,                   /* number of chars to encode */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a string object and returns the result as Python 
+   object. */
+
+PyAPI_FUNC(PyObject*) PyString_AsEncodedObject(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Encodes a string object and returns the result as Python string
+   object.   
+   
+   If the codec returns an Unicode object, the object is converted
+   back to a string using the default encoding.
+
+   DEPRECATED - use PyString_AsEncodedObject() instead. */
+
+PyAPI_FUNC(PyObject*) PyString_AsEncodedString(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Decodes a string object and returns the result as Python 
+   object. */
+
+PyAPI_FUNC(PyObject*) PyString_AsDecodedObject(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Decodes a string object and returns the result as Python string
+   object.  
+   
+   If the codec returns an Unicode object, the object is converted
+   back to a string using the default encoding.
+
+   DEPRECATED - use PyString_AsDecodedObject() instead. */
+
+PyAPI_FUNC(PyObject*) PyString_AsDecodedString(
+    PyObject *str,	 	/* string object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Provides access to the internal data buffer and size of a string
+   object or the default encoded version of an Unicode object. Passing
+   NULL as *len parameter will force the string buffer to be
+   0-terminated (passing a string with embedded NULL characters will
+   cause an exception).  */
+
+PyAPI_FUNC(int) PyString_AsStringAndSize(
+    register PyObject *obj,	/* string or Unicode object */
+    register char **s,		/* pointer to buffer variable */
+    register int *len		/* pointer to length variable or NULL
+				   (only possible for 0-terminated
+				   strings) */
+    );
+    
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRINGOBJECT_H */

Added: trunk/mingw-libs/include/structmember.h
===================================================================
--- trunk/mingw-libs/include/structmember.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/structmember.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,89 @@
+#ifndef Py_STRUCTMEMBER_H
+#define Py_STRUCTMEMBER_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Interface to map C struct members to Python object attributes */
+
+#include <stddef.h> /* For offsetof */
+
+/* The offsetof() macro calculates the offset of a structure member
+   in its structure.  Unfortunately this cannot be written down
+   portably, hence it is provided by a Standard C header file.
+   For pre-Standard C compilers, here is a version that usually works
+   (but watch out!): */
+
+#ifndef offsetof
+#define offsetof(type, member) ( (int) & ((type*)0) -> member )
+#endif
+
+/* An array of memberlist structures defines the name, type and offset
+   of selected members of a C structure.  These can be read by
+   PyMember_Get() and set by PyMember_Set() (except if their READONLY flag
+   is set).  The array must be terminated with an entry whose name
+   pointer is NULL. */
+
+struct memberlist {
+	/* Obsolete version, for binary backwards compatibility */
+	char *name;
+	int type;
+	int offset;
+	int flags;
+};
+
+typedef struct PyMemberDef {
+	/* Current version, use this */
+	char *name;
+	int type;
+	int offset;
+	int flags;
+	char *doc;
+} PyMemberDef;
+
+/* Types */
+#define T_SHORT		0
+#define T_INT		1
+#define T_LONG		2
+#define T_FLOAT		3
+#define T_DOUBLE	4
+#define T_STRING	5
+#define T_OBJECT	6
+/* XXX the ordering here is weird for binary compatibility */
+#define T_CHAR		7	/* 1-character string */
+#define T_BYTE		8	/* 8-bit signed int */
+/* unsigned variants: */
+#define T_UBYTE		9
+#define T_USHORT	10
+#define T_UINT		11
+#define T_ULONG		12
+
+/* Added by Jack: strings contained in the structure */
+#define T_STRING_INPLACE	13
+
+#define T_OBJECT_EX	16	/* Like T_OBJECT, but raises AttributeError
+				   when the value is NULL, instead of
+				   converting to None. */
+
+/* Flags */
+#define READONLY	1
+#define RO		READONLY		/* Shorthand */
+#define READ_RESTRICTED	2
+#define WRITE_RESTRICTED 4
+#define RESTRICTED	(READ_RESTRICTED | WRITE_RESTRICTED)
+
+
+/* Obsolete API, for binary backwards compatibility */
+PyAPI_FUNC(PyObject *) PyMember_Get(char *, struct memberlist *, char *);
+PyAPI_FUNC(int) PyMember_Set(char *, struct memberlist *, char *, PyObject *);
+
+/* Current API, use this */
+PyAPI_FUNC(PyObject *) PyMember_GetOne(char *, struct PyMemberDef *);
+PyAPI_FUNC(int) PyMember_SetOne(char *, struct PyMemberDef *, PyObject *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRUCTMEMBER_H */

Added: trunk/mingw-libs/include/structseq.h
===================================================================
--- trunk/mingw-libs/include/structseq.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/structseq.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,41 @@
+
+/* Tuple object interface */
+
+#ifndef Py_STRUCTSEQ_H
+#define Py_STRUCTSEQ_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct PyStructSequence_Field {
+	char *name;
+	char *doc;
+} PyStructSequence_Field;
+
+typedef struct PyStructSequence_Desc {
+	char *name;
+	char *doc;
+	struct PyStructSequence_Field *fields;
+	int n_in_sequence;
+} PyStructSequence_Desc;
+
+extern char* PyStructSequence_UnnamedField;
+
+PyAPI_FUNC(void) PyStructSequence_InitType(PyTypeObject *type,
+					   PyStructSequence_Desc *desc);
+
+PyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);
+
+typedef struct {
+	PyObject_VAR_HEAD
+	PyObject *ob_item[1];
+} PyStructSequence;
+
+/* Macro, *only* to be used to fill in brand new objects */
+#define PyStructSequence_SET_ITEM(op, i, v) \
+	(((PyStructSequence *)(op))->ob_item[i] = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_STRUCTSEQ_H */

Added: trunk/mingw-libs/include/symtable.h
===================================================================
--- trunk/mingw-libs/include/symtable.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/symtable.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,102 @@
+#ifndef Py_SYMTABLE_H
+#define Py_SYMTABLE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* A symbol table is constructed each time PyNode_Compile() is
+   called.  The table walks the entire parse tree and identifies each
+   use or definition of a variable. 
+
+   The symbol table contains a dictionary for each code block in a
+   module: The symbol dictionary for the block.  They keys of these
+   dictionaries are the name of all variables used or defined in the
+   block; the integer values are used to store several flags,
+   e.g. DEF_PARAM indicates that a variable is a parameter to a
+   function. 
+*/
+
+struct _symtable_entry;
+
+struct symtable {
+	int st_pass;             /* pass == 1 or 2 */
+	const char *st_filename; /* name of file being compiled */
+	struct _symtable_entry *st_cur; /* current symbol table entry */
+	PyObject *st_symbols;    /* dictionary of symbol table entries */
+        PyObject *st_stack;      /* stack of namespace info */
+	PyObject *st_global;     /* borrowed ref to MODULE in st_symbols */
+	int st_nscopes;          /* number of scopes */
+	int st_errors;           /* number of errors */
+	char *st_private;        /* name of current class or NULL */
+	PyFutureFeatures *st_future; /* module's future features */
+};
+
+typedef struct _symtable_entry {
+	PyObject_HEAD
+	PyObject *ste_id;        /* int: key in st_symbols) */
+	PyObject *ste_symbols;   /* dict: name to flags) */
+	PyObject *ste_name;      /* string: name of scope */
+	PyObject *ste_varnames;  /* list of variable names */
+	PyObject *ste_children;  /* list of child ids */
+	int ste_type;            /* module, class, or function */
+	int ste_lineno;          /* first line of scope */
+	int ste_optimized;       /* true if namespace can't be optimized */
+	int ste_nested;          /* true if scope is nested */
+	int ste_child_free;      /* true if a child scope has free variables,
+				    including free refs to globals */
+	int ste_generator;       /* true if namespace is a generator */
+	int ste_opt_lineno;      /* lineno of last exec or import * */
+	int ste_tmpname;         /* temporary name counter */
+	struct symtable *ste_table;
+} PySymtableEntryObject;
+
+PyAPI_DATA(PyTypeObject) PySymtableEntry_Type;
+
+#define PySymtableEntry_Check(op) ((op)->ob_type == &PySymtableEntry_Type)
+
+PyAPI_FUNC(PyObject *) PySymtableEntry_New(struct symtable *,
+						 char *, int, int);
+
+PyAPI_FUNC(struct symtable *) PyNode_CompileSymtable(struct _node *, const char *);
+PyAPI_FUNC(void) PySymtable_Free(struct symtable *);
+
+
+#define TOP "global"
+
+/* Flags for def-use information */
+
+#define DEF_GLOBAL 1           /* global stmt */
+#define DEF_LOCAL 2            /* assignment in code block */
+#define DEF_PARAM 2<<1         /* formal parameter */
+#define USE 2<<2               /* name is used */
+#define DEF_STAR 2<<3          /* parameter is star arg */
+#define DEF_DOUBLESTAR 2<<4    /* parameter is star-star arg */
+#define DEF_INTUPLE 2<<5       /* name defined in tuple in parameters */
+#define DEF_FREE 2<<6          /* name used but not defined in nested scope */
+#define DEF_FREE_GLOBAL 2<<7   /* free variable is actually implicit global */
+#define DEF_FREE_CLASS 2<<8    /* free variable from class's method */
+#define DEF_IMPORT 2<<9        /* assignment occurred via import */
+
+#define DEF_BOUND (DEF_LOCAL | DEF_PARAM | DEF_IMPORT)
+
+#define TYPE_FUNCTION 1
+#define TYPE_CLASS 2
+#define TYPE_MODULE 3
+
+#define LOCAL 1
+#define GLOBAL_EXPLICIT 2
+#define GLOBAL_IMPLICIT 3
+#define FREE 4
+#define CELL 5
+
+#define OPT_IMPORT_STAR 1
+#define OPT_EXEC 2
+#define OPT_BARE_EXEC 4
+
+#define GENERATOR 1
+#define GENERATOR_EXPRESSION 2
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SYMTABLE_H */

Added: trunk/mingw-libs/include/sysmodule.h
===================================================================
--- trunk/mingw-libs/include/sysmodule.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/sysmodule.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,30 @@
+
+/* System module interface */
+
+#ifndef Py_SYSMODULE_H
+#define Py_SYSMODULE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+PyAPI_FUNC(PyObject *) PySys_GetObject(char *);
+PyAPI_FUNC(int) PySys_SetObject(char *, PyObject *);
+PyAPI_FUNC(FILE *) PySys_GetFile(char *, FILE *);
+PyAPI_FUNC(void) PySys_SetArgv(int, char **);
+PyAPI_FUNC(void) PySys_SetPath(char *);
+
+PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
+			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+
+PyAPI_DATA(PyObject *) _PySys_TraceFunc, *_PySys_ProfileFunc;
+PyAPI_DATA(int) _PySys_CheckInterval;
+
+PyAPI_FUNC(void) PySys_ResetWarnOptions(void);
+PyAPI_FUNC(void) PySys_AddWarnOption(char *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_SYSMODULE_H */

Added: trunk/mingw-libs/include/timefuncs.h
===================================================================
--- trunk/mingw-libs/include/timefuncs.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/timefuncs.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,23 @@
+/*  timefuncs.h
+ */
+
+/* Utility function related to timemodule.c. */
+
+#ifndef TIMEFUNCS_H
+#define TIMEFUNCS_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Cast double x to time_t, but raise ValueError if x is too large
+ * to fit in a time_t.  ValueError is set on return iff the return
+ * value is (time_t)-1 and PyErr_Occurred().
+ */
+PyAPI_FUNC(time_t) _PyTime_DoubleToTimet(double x);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif  /* TIMEFUNCS_H */

Added: trunk/mingw-libs/include/token.h
===================================================================
--- trunk/mingw-libs/include/token.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/token.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,83 @@
+
+/* Token types */
+
+#ifndef Py_TOKEN_H
+#define Py_TOKEN_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ENDMARKER	0
+#define NAME		1
+#define NUMBER		2
+#define STRING		3
+#define NEWLINE		4
+#define INDENT		5
+#define DEDENT		6
+#define LPAR		7
+#define RPAR		8
+#define LSQB		9
+#define RSQB		10
+#define COLON		11
+#define COMMA		12
+#define SEMI		13
+#define PLUS		14
+#define MINUS		15
+#define STAR		16
+#define SLASH		17
+#define VBAR		18
+#define AMPER		19
+#define LESS		20
+#define GREATER		21
+#define EQUAL		22
+#define DOT		23
+#define PERCENT		24
+#define BACKQUOTE	25
+#define LBRACE		26
+#define RBRACE		27
+#define EQEQUAL		28
+#define NOTEQUAL	29
+#define LESSEQUAL	30
+#define GREATEREQUAL	31
+#define TILDE		32
+#define CIRCUMFLEX	33
+#define LEFTSHIFT	34
+#define RIGHTSHIFT	35
+#define DOUBLESTAR	36
+#define PLUSEQUAL	37
+#define MINEQUAL	38
+#define STAREQUAL	39
+#define SLASHEQUAL	40
+#define PERCENTEQUAL	41
+#define AMPEREQUAL	42
+#define VBAREQUAL	43
+#define CIRCUMFLEXEQUAL	44
+#define LEFTSHIFTEQUAL	45
+#define RIGHTSHIFTEQUAL	46
+#define DOUBLESTAREQUAL	47
+#define DOUBLESLASH	48
+#define DOUBLESLASHEQUAL 49
+#define AT              50	
+/* Don't forget to update the table _PyParser_TokenNames in tokenizer.c! */
+#define OP		51
+#define ERRORTOKEN	52
+#define N_TOKENS	53
+
+/* Special definitions for cooperation with parser */
+
+#define NT_OFFSET		256
+
+#define ISTERMINAL(x)		((x) < NT_OFFSET)
+#define ISNONTERMINAL(x)	((x) >= NT_OFFSET)
+#define ISEOF(x)		((x) == ENDMARKER)
+
+
+PyAPI_DATA(char *) _PyParser_TokenNames[]; /* Token names */
+PyAPI_FUNC(int) PyToken_OneChar(int);
+PyAPI_FUNC(int) PyToken_TwoChars(int, int);
+PyAPI_FUNC(int) PyToken_ThreeChars(int, int, int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TOKEN_H */

Added: trunk/mingw-libs/include/traceback.h
===================================================================
--- trunk/mingw-libs/include/traceback.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/traceback.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,30 @@
+
+#ifndef Py_TRACEBACK_H
+#define Py_TRACEBACK_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct _frame;
+
+/* Traceback interface */
+
+typedef struct _traceback {
+	PyObject_HEAD
+	struct _traceback *tb_next;
+	struct _frame *tb_frame;
+	int tb_lasti;
+	int tb_lineno;
+} PyTracebackObject;
+
+PyAPI_FUNC(int) PyTraceBack_Here(struct _frame *);
+PyAPI_FUNC(int) PyTraceBack_Print(PyObject *, PyObject *);
+
+/* Reveal traceback type so we can typecheck traceback objects */
+PyAPI_DATA(PyTypeObject) PyTraceBack_Type;
+#define PyTraceBack_Check(v) ((v)->ob_type == &PyTraceBack_Type)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TRACEBACK_H */

Added: trunk/mingw-libs/include/tupleobject.h
===================================================================
--- trunk/mingw-libs/include/tupleobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/tupleobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,57 @@
+
+/* Tuple object interface */
+
+#ifndef Py_TUPLEOBJECT_H
+#define Py_TUPLEOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+Another generally useful object type is a tuple of object pointers.
+For Python, this is an immutable type.  C code can change the tuple items
+(but not their number), and even use tuples are general-purpose arrays of
+object references, but in general only brand new tuples should be mutated,
+not ones that might already have been exposed to Python code.
+
+*** WARNING *** PyTuple_SetItem does not increment the new item's reference
+count, but does decrement the reference count of the item it replaces,
+if not nil.  It does *decrement* the reference count if it is *not*
+inserted in the tuple.  Similarly, PyTuple_GetItem does not increment the
+returned item's reference count.
+*/
+
+typedef struct {
+    PyObject_VAR_HEAD
+    PyObject *ob_item[1];
+
+    /* ob_item contains space for 'ob_size' elements.
+     * Items must normally not be NULL, except during construction when
+     * the tuple is not yet visible outside the function that builds it.
+     */
+} PyTupleObject;
+
+PyAPI_DATA(PyTypeObject) PyTuple_Type;
+
+#define PyTuple_Check(op) PyObject_TypeCheck(op, &PyTuple_Type)
+#define PyTuple_CheckExact(op) ((op)->ob_type == &PyTuple_Type)
+
+PyAPI_FUNC(PyObject *) PyTuple_New(int size);
+PyAPI_FUNC(int) PyTuple_Size(PyObject *);
+PyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, int);
+PyAPI_FUNC(int) PyTuple_SetItem(PyObject *, int, PyObject *);
+PyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, int, int);
+PyAPI_FUNC(int) _PyTuple_Resize(PyObject **, int);
+PyAPI_FUNC(PyObject *) PyTuple_Pack(int, ...);
+
+/* Macro, trading safety for speed */
+#define PyTuple_GET_ITEM(op, i) (((PyTupleObject *)(op))->ob_item[i])
+#define PyTuple_GET_SIZE(op)    (((PyTupleObject *)(op))->ob_size)
+
+/* Macro, *only* to be used to fill in brand new tuples */
+#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))->ob_item[i] = v)
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_TUPLEOBJECT_H */

Added: trunk/mingw-libs/include/ucnhash.h
===================================================================
--- trunk/mingw-libs/include/ucnhash.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/ucnhash.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,29 @@
+/* Unicode name database interface */
+
+#ifndef Py_UCNHASH_H
+#define Py_UCNHASH_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* revised ucnhash CAPI interface (exported through a PyCObject) */
+
+typedef struct {
+
+    /* Size of this struct */
+    int size;
+
+    /* Get name for a given character code.  Returns non-zero if
+       success, zero if not.  Does not set Python exceptions. */
+    int (*getname)(Py_UCS4 code, char* buffer, int buflen);
+
+    /* Get character code for a given name.  Same error handling
+       as for getname. */
+    int (*getcode)(const char* name, int namelen, Py_UCS4* code);
+
+} _PyUnicode_Name_CAPI;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_UCNHASH_H */

Added: trunk/mingw-libs/include/unicodeobject.h
===================================================================
--- trunk/mingw-libs/include/unicodeobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/unicodeobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,1196 @@
+#ifndef Py_UNICODEOBJECT_H
+#define Py_UNICODEOBJECT_H
+
+/*
+
+Unicode implementation based on original code by Fredrik Lundh,
+modified by Marc-Andre Lemburg (mal at lemburg.com) according to the
+Unicode Integration Proposal (see file Misc/unicode.txt).
+
+Copyright (c) Corporation for National Research Initiatives.
+
+
+ Original header:
+ --------------------------------------------------------------------
+
+ * Yet another Unicode string type for Python.  This type supports the
+ * 16-bit Basic Multilingual Plane (BMP) only.
+ *
+ * Written by Fredrik Lundh, January 1999.
+ *
+ * Copyright (c) 1999 by Secret Labs AB.
+ * Copyright (c) 1999 by Fredrik Lundh.
+ *
+ * fredrik at pythonware.com
+ * http://www.pythonware.com
+ *
+ * --------------------------------------------------------------------
+ * This Unicode String Type is
+ * 
+ * Copyright (c) 1999 by Secret Labs AB
+ * Copyright (c) 1999 by Fredrik Lundh
+ * 
+ * By obtaining, using, and/or copying this software and/or its
+ * associated documentation, you agree that you have read, understood,
+ * and will comply with the following terms and conditions:
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * associated documentation for any purpose and without fee is hereby
+ * granted, provided that the above copyright notice appears in all
+ * copies, and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Secret Labs
+ * AB or the author not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.
+ * 
+ * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
+ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * -------------------------------------------------------------------- */
+
+#include <ctype.h>
+
+/* === Internal API ======================================================= */
+
+/* --- Internal Unicode Format -------------------------------------------- */
+
+#ifndef Py_USING_UNICODE
+
+#define PyUnicode_Check(op)                 0
+#define PyUnicode_CheckExact(op)            0
+
+#else
+
+/* FIXME: MvL's new implementation assumes that Py_UNICODE_SIZE is
+   properly set, but the default rules below doesn't set it.  I'll
+   sort this out some other day -- fredrik at pythonware.com */
+
+#ifndef Py_UNICODE_SIZE
+#error Must define Py_UNICODE_SIZE
+#endif
+
+/* Setting Py_UNICODE_WIDE enables UCS-4 storage.  Otherwise, Unicode
+   strings are stored as UCS-2 (with limited support for UTF-16) */
+
+#if Py_UNICODE_SIZE >= 4
+#define Py_UNICODE_WIDE
+#endif
+
+/* Set these flags if the platform has "wchar.h", "wctype.h" and the
+   wchar_t type is a 16-bit unsigned type */
+/* #define HAVE_WCHAR_H */
+/* #define HAVE_USABLE_WCHAR_T */
+
+/* Defaults for various platforms */
+#ifndef PY_UNICODE_TYPE
+
+/* Windows has a usable wchar_t type (unless we're using UCS-4) */
+# if defined(MS_WIN32) && Py_UNICODE_SIZE == 2
+#  define HAVE_USABLE_WCHAR_T
+#  define PY_UNICODE_TYPE wchar_t
+# endif
+
+# if defined(Py_UNICODE_WIDE)
+#  define PY_UNICODE_TYPE Py_UCS4
+# endif
+
+#endif
+
+/* If the compiler provides a wchar_t type we try to support it
+   through the interface functions PyUnicode_FromWideChar() and
+   PyUnicode_AsWideChar(). */
+
+#ifdef HAVE_USABLE_WCHAR_T
+# ifndef HAVE_WCHAR_H
+#  define HAVE_WCHAR_H
+# endif
+#endif
+
+#ifdef HAVE_WCHAR_H
+/* Work around a cosmetic bug in BSDI 4.x wchar.h; thanks to Thomas Wouters */
+# ifdef _HAVE_BSDI
+#  include <time.h>
+# endif
+#  include <wchar.h>
+#endif
+
+/*
+ * Use this typedef when you need to represent a UTF-16 surrogate pair
+ * as single unsigned integer.
+ */
+#if SIZEOF_INT >= 4 
+typedef unsigned int Py_UCS4; 
+#elif SIZEOF_LONG >= 4
+typedef unsigned long Py_UCS4; 
+#endif
+
+typedef PY_UNICODE_TYPE Py_UNICODE;
+
+/* --- UCS-2/UCS-4 Name Mangling ------------------------------------------ */
+
+/* Unicode API names are mangled to assure that UCS-2 and UCS-4 builds
+   produce different external names and thus cause import errors in
+   case Python interpreters and extensions with mixed compiled in
+   Unicode width assumptions are combined. */
+
+#ifndef Py_UNICODE_WIDE
+
+# define PyUnicode_AsASCIIString PyUnicodeUCS2_AsASCIIString
+# define PyUnicode_AsCharmapString PyUnicodeUCS2_AsCharmapString
+# define PyUnicode_AsEncodedObject PyUnicodeUCS2_AsEncodedObject
+# define PyUnicode_AsEncodedString PyUnicodeUCS2_AsEncodedString
+# define PyUnicode_AsLatin1String PyUnicodeUCS2_AsLatin1String
+# define PyUnicode_AsRawUnicodeEscapeString PyUnicodeUCS2_AsRawUnicodeEscapeString
+# define PyUnicode_AsUTF16String PyUnicodeUCS2_AsUTF16String
+# define PyUnicode_AsUTF8String PyUnicodeUCS2_AsUTF8String
+# define PyUnicode_AsUnicode PyUnicodeUCS2_AsUnicode
+# define PyUnicode_AsUnicodeEscapeString PyUnicodeUCS2_AsUnicodeEscapeString
+# define PyUnicode_AsWideChar PyUnicodeUCS2_AsWideChar
+# define PyUnicode_Compare PyUnicodeUCS2_Compare
+# define PyUnicode_Concat PyUnicodeUCS2_Concat
+# define PyUnicode_Contains PyUnicodeUCS2_Contains
+# define PyUnicode_Count PyUnicodeUCS2_Count
+# define PyUnicode_Decode PyUnicodeUCS2_Decode
+# define PyUnicode_DecodeASCII PyUnicodeUCS2_DecodeASCII
+# define PyUnicode_DecodeCharmap PyUnicodeUCS2_DecodeCharmap
+# define PyUnicode_DecodeLatin1 PyUnicodeUCS2_DecodeLatin1
+# define PyUnicode_DecodeRawUnicodeEscape PyUnicodeUCS2_DecodeRawUnicodeEscape
+# define PyUnicode_DecodeUTF16 PyUnicodeUCS2_DecodeUTF16
+# define PyUnicode_DecodeUTF16Stateful PyUnicodeUCS2_DecodeUTF16Stateful
+# define PyUnicode_DecodeUTF8 PyUnicodeUCS2_DecodeUTF8
+# define PyUnicode_DecodeUTF8Stateful PyUnicodeUCS2_DecodeUTF8Stateful
+# define PyUnicode_DecodeUnicodeEscape PyUnicodeUCS2_DecodeUnicodeEscape
+# define PyUnicode_Encode PyUnicodeUCS2_Encode
+# define PyUnicode_EncodeASCII PyUnicodeUCS2_EncodeASCII
+# define PyUnicode_EncodeCharmap PyUnicodeUCS2_EncodeCharmap
+# define PyUnicode_EncodeDecimal PyUnicodeUCS2_EncodeDecimal
+# define PyUnicode_EncodeLatin1 PyUnicodeUCS2_EncodeLatin1
+# define PyUnicode_EncodeRawUnicodeEscape PyUnicodeUCS2_EncodeRawUnicodeEscape
+# define PyUnicode_EncodeUTF16 PyUnicodeUCS2_EncodeUTF16
+# define PyUnicode_EncodeUTF8 PyUnicodeUCS2_EncodeUTF8
+# define PyUnicode_EncodeUnicodeEscape PyUnicodeUCS2_EncodeUnicodeEscape
+# define PyUnicode_Find PyUnicodeUCS2_Find
+# define PyUnicode_Format PyUnicodeUCS2_Format
+# define PyUnicode_FromEncodedObject PyUnicodeUCS2_FromEncodedObject
+# define PyUnicode_FromObject PyUnicodeUCS2_FromObject
+# define PyUnicode_FromOrdinal PyUnicodeUCS2_FromOrdinal
+# define PyUnicode_FromUnicode PyUnicodeUCS2_FromUnicode
+# define PyUnicode_FromWideChar PyUnicodeUCS2_FromWideChar
+# define PyUnicode_GetDefaultEncoding PyUnicodeUCS2_GetDefaultEncoding
+# define PyUnicode_GetMax PyUnicodeUCS2_GetMax
+# define PyUnicode_GetSize PyUnicodeUCS2_GetSize
+# define PyUnicode_Join PyUnicodeUCS2_Join
+# define PyUnicode_Replace PyUnicodeUCS2_Replace
+# define PyUnicode_Resize PyUnicodeUCS2_Resize
+# define PyUnicode_SetDefaultEncoding PyUnicodeUCS2_SetDefaultEncoding
+# define PyUnicode_Split PyUnicodeUCS2_Split
+# define PyUnicode_RSplit PyUnicodeUCS2_RSplit
+# define PyUnicode_Splitlines PyUnicodeUCS2_Splitlines
+# define PyUnicode_Tailmatch PyUnicodeUCS2_Tailmatch
+# define PyUnicode_Translate PyUnicodeUCS2_Translate
+# define PyUnicode_TranslateCharmap PyUnicodeUCS2_TranslateCharmap
+# define _PyUnicode_AsDefaultEncodedString _PyUnicodeUCS2_AsDefaultEncodedString
+# define _PyUnicode_Fini _PyUnicodeUCS2_Fini
+# define _PyUnicode_Init _PyUnicodeUCS2_Init
+# define _PyUnicode_IsAlpha _PyUnicodeUCS2_IsAlpha
+# define _PyUnicode_IsDecimalDigit _PyUnicodeUCS2_IsDecimalDigit
+# define _PyUnicode_IsDigit _PyUnicodeUCS2_IsDigit
+# define _PyUnicode_IsLinebreak _PyUnicodeUCS2_IsLinebreak
+# define _PyUnicode_IsLowercase _PyUnicodeUCS2_IsLowercase
+# define _PyUnicode_IsNumeric _PyUnicodeUCS2_IsNumeric
+# define _PyUnicode_IsTitlecase _PyUnicodeUCS2_IsTitlecase
+# define _PyUnicode_IsUppercase _PyUnicodeUCS2_IsUppercase
+# define _PyUnicode_IsWhitespace _PyUnicodeUCS2_IsWhitespace
+# define _PyUnicode_ToDecimalDigit _PyUnicodeUCS2_ToDecimalDigit
+# define _PyUnicode_ToDigit _PyUnicodeUCS2_ToDigit
+# define _PyUnicode_ToLowercase _PyUnicodeUCS2_ToLowercase
+# define _PyUnicode_ToNumeric _PyUnicodeUCS2_ToNumeric
+# define _PyUnicode_ToTitlecase _PyUnicodeUCS2_ToTitlecase
+# define _PyUnicode_ToUppercase _PyUnicodeUCS2_ToUppercase
+
+#else
+
+# define PyUnicode_AsASCIIString PyUnicodeUCS4_AsASCIIString
+# define PyUnicode_AsCharmapString PyUnicodeUCS4_AsCharmapString
+# define PyUnicode_AsEncodedObject PyUnicodeUCS4_AsEncodedObject
+# define PyUnicode_AsEncodedString PyUnicodeUCS4_AsEncodedString
+# define PyUnicode_AsLatin1String PyUnicodeUCS4_AsLatin1String
+# define PyUnicode_AsRawUnicodeEscapeString PyUnicodeUCS4_AsRawUnicodeEscapeString
+# define PyUnicode_AsUTF16String PyUnicodeUCS4_AsUTF16String
+# define PyUnicode_AsUTF8String PyUnicodeUCS4_AsUTF8String
+# define PyUnicode_AsUnicode PyUnicodeUCS4_AsUnicode
+# define PyUnicode_AsUnicodeEscapeString PyUnicodeUCS4_AsUnicodeEscapeString
+# define PyUnicode_AsWideChar PyUnicodeUCS4_AsWideChar
+# define PyUnicode_Compare PyUnicodeUCS4_Compare
+# define PyUnicode_Concat PyUnicodeUCS4_Concat
+# define PyUnicode_Contains PyUnicodeUCS4_Contains
+# define PyUnicode_Count PyUnicodeUCS4_Count
+# define PyUnicode_Decode PyUnicodeUCS4_Decode
+# define PyUnicode_DecodeASCII PyUnicodeUCS4_DecodeASCII
+# define PyUnicode_DecodeCharmap PyUnicodeUCS4_DecodeCharmap
+# define PyUnicode_DecodeLatin1 PyUnicodeUCS4_DecodeLatin1
+# define PyUnicode_DecodeRawUnicodeEscape PyUnicodeUCS4_DecodeRawUnicodeEscape
+# define PyUnicode_DecodeUTF16 PyUnicodeUCS4_DecodeUTF16
+# define PyUnicode_DecodeUTF16Stateful PyUnicodeUCS4_DecodeUTF16Stateful
+# define PyUnicode_DecodeUTF8 PyUnicodeUCS4_DecodeUTF8
+# define PyUnicode_DecodeUTF8Stateful PyUnicodeUCS4_DecodeUTF8Stateful
+# define PyUnicode_DecodeUnicodeEscape PyUnicodeUCS4_DecodeUnicodeEscape
+# define PyUnicode_Encode PyUnicodeUCS4_Encode
+# define PyUnicode_EncodeASCII PyUnicodeUCS4_EncodeASCII
+# define PyUnicode_EncodeCharmap PyUnicodeUCS4_EncodeCharmap
+# define PyUnicode_EncodeDecimal PyUnicodeUCS4_EncodeDecimal
+# define PyUnicode_EncodeLatin1 PyUnicodeUCS4_EncodeLatin1
+# define PyUnicode_EncodeRawUnicodeEscape PyUnicodeUCS4_EncodeRawUnicodeEscape
+# define PyUnicode_EncodeUTF16 PyUnicodeUCS4_EncodeUTF16
+# define PyUnicode_EncodeUTF8 PyUnicodeUCS4_EncodeUTF8
+# define PyUnicode_EncodeUnicodeEscape PyUnicodeUCS4_EncodeUnicodeEscape
+# define PyUnicode_Find PyUnicodeUCS4_Find
+# define PyUnicode_Format PyUnicodeUCS4_Format
+# define PyUnicode_FromEncodedObject PyUnicodeUCS4_FromEncodedObject
+# define PyUnicode_FromObject PyUnicodeUCS4_FromObject
+# define PyUnicode_FromOrdinal PyUnicodeUCS4_FromOrdinal
+# define PyUnicode_FromUnicode PyUnicodeUCS4_FromUnicode
+# define PyUnicode_FromWideChar PyUnicodeUCS4_FromWideChar
+# define PyUnicode_GetDefaultEncoding PyUnicodeUCS4_GetDefaultEncoding
+# define PyUnicode_GetMax PyUnicodeUCS4_GetMax
+# define PyUnicode_GetSize PyUnicodeUCS4_GetSize
+# define PyUnicode_Join PyUnicodeUCS4_Join
+# define PyUnicode_Replace PyUnicodeUCS4_Replace
+# define PyUnicode_Resize PyUnicodeUCS4_Resize
+# define PyUnicode_SetDefaultEncoding PyUnicodeUCS4_SetDefaultEncoding
+# define PyUnicode_Split PyUnicodeUCS4_Split
+# define PyUnicode_Splitlines PyUnicodeUCS4_Splitlines
+# define PyUnicode_Tailmatch PyUnicodeUCS4_Tailmatch
+# define PyUnicode_Translate PyUnicodeUCS4_Translate
+# define PyUnicode_TranslateCharmap PyUnicodeUCS4_TranslateCharmap
+# define _PyUnicode_AsDefaultEncodedString _PyUnicodeUCS4_AsDefaultEncodedString
+# define _PyUnicode_Fini _PyUnicodeUCS4_Fini
+# define _PyUnicode_Init _PyUnicodeUCS4_Init
+# define _PyUnicode_IsAlpha _PyUnicodeUCS4_IsAlpha
+# define _PyUnicode_IsDecimalDigit _PyUnicodeUCS4_IsDecimalDigit
+# define _PyUnicode_IsDigit _PyUnicodeUCS4_IsDigit
+# define _PyUnicode_IsLinebreak _PyUnicodeUCS4_IsLinebreak
+# define _PyUnicode_IsLowercase _PyUnicodeUCS4_IsLowercase
+# define _PyUnicode_IsNumeric _PyUnicodeUCS4_IsNumeric
+# define _PyUnicode_IsTitlecase _PyUnicodeUCS4_IsTitlecase
+# define _PyUnicode_IsUppercase _PyUnicodeUCS4_IsUppercase
+# define _PyUnicode_IsWhitespace _PyUnicodeUCS4_IsWhitespace
+# define _PyUnicode_ToDecimalDigit _PyUnicodeUCS4_ToDecimalDigit
+# define _PyUnicode_ToDigit _PyUnicodeUCS4_ToDigit
+# define _PyUnicode_ToLowercase _PyUnicodeUCS4_ToLowercase
+# define _PyUnicode_ToNumeric _PyUnicodeUCS4_ToNumeric
+# define _PyUnicode_ToTitlecase _PyUnicodeUCS4_ToTitlecase
+# define _PyUnicode_ToUppercase _PyUnicodeUCS4_ToUppercase
+
+
+#endif
+
+/* --- Internal Unicode Operations ---------------------------------------- */
+
+/* If you want Python to use the compiler's wctype.h functions instead
+   of the ones supplied with Python, define WANT_WCTYPE_FUNCTIONS or
+   configure Python using --with-wctype-functions.  This reduces the
+   interpreter's code size. */
+
+#if defined(HAVE_USABLE_WCHAR_T) && defined(WANT_WCTYPE_FUNCTIONS)
+
+#include <wctype.h>
+
+#define Py_UNICODE_ISSPACE(ch) iswspace(ch)
+
+#define Py_UNICODE_ISLOWER(ch) iswlower(ch)
+#define Py_UNICODE_ISUPPER(ch) iswupper(ch)
+#define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
+#define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)
+
+#define Py_UNICODE_TOLOWER(ch) towlower(ch)
+#define Py_UNICODE_TOUPPER(ch) towupper(ch)
+#define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)
+
+#define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
+#define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
+#define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
+
+#define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
+#define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
+#define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)
+
+#define Py_UNICODE_ISALPHA(ch) iswalpha(ch)
+
+#else
+
+#define Py_UNICODE_ISSPACE(ch) _PyUnicode_IsWhitespace(ch)
+
+#define Py_UNICODE_ISLOWER(ch) _PyUnicode_IsLowercase(ch)
+#define Py_UNICODE_ISUPPER(ch) _PyUnicode_IsUppercase(ch)
+#define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
+#define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)
+
+#define Py_UNICODE_TOLOWER(ch) _PyUnicode_ToLowercase(ch)
+#define Py_UNICODE_TOUPPER(ch) _PyUnicode_ToUppercase(ch)
+#define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)
+
+#define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
+#define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
+#define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
+
+#define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
+#define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
+#define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)
+
+#define Py_UNICODE_ISALPHA(ch) _PyUnicode_IsAlpha(ch)
+
+#endif
+
+#define Py_UNICODE_ISALNUM(ch) \
+       (Py_UNICODE_ISALPHA(ch) || \
+        Py_UNICODE_ISDECIMAL(ch) || \
+        Py_UNICODE_ISDIGIT(ch) || \
+        Py_UNICODE_ISNUMERIC(ch))
+
+#define Py_UNICODE_COPY(target, source, length)\
+    (memcpy((target), (source), (length)*sizeof(Py_UNICODE)))
+
+#define Py_UNICODE_FILL(target, value, length) do\
+    {int i; for (i = 0; i < (length); i++) (target)[i] = (value);}\
+    while (0)
+
+#define Py_UNICODE_MATCH(string, offset, substring)\
+    ((*((string)->str + (offset)) == *((substring)->str)) &&\
+     !memcmp((string)->str + (offset), (substring)->str,\
+             (substring)->length*sizeof(Py_UNICODE)))
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --- Unicode Type ------------------------------------------------------- */
+
+typedef struct {
+    PyObject_HEAD
+    int length;			/* Length of raw Unicode data in buffer */
+    Py_UNICODE *str;		/* Raw Unicode buffer */
+    long hash;			/* Hash value; -1 if not set */
+    PyObject *defenc;		/* (Default) Encoded version as Python
+				   string, or NULL; this is used for
+				   implementing the buffer protocol */
+} PyUnicodeObject;
+
+PyAPI_DATA(PyTypeObject) PyUnicode_Type;
+
+#define PyUnicode_Check(op) PyObject_TypeCheck(op, &PyUnicode_Type)
+#define PyUnicode_CheckExact(op) ((op)->ob_type == &PyUnicode_Type)
+
+/* Fast access macros */
+#define PyUnicode_GET_SIZE(op) \
+        (((PyUnicodeObject *)(op))->length)
+#define PyUnicode_GET_DATA_SIZE(op) \
+        (((PyUnicodeObject *)(op))->length * sizeof(Py_UNICODE))
+#define PyUnicode_AS_UNICODE(op) \
+        (((PyUnicodeObject *)(op))->str)
+#define PyUnicode_AS_DATA(op) \
+        ((const char *)((PyUnicodeObject *)(op))->str)
+
+/* --- Constants ---------------------------------------------------------- */
+
+/* This Unicode character will be used as replacement character during
+   decoding if the errors argument is set to "replace". Note: the
+   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
+   Unicode 3.0. */
+
+#define Py_UNICODE_REPLACEMENT_CHARACTER ((Py_UNICODE) 0xFFFD)
+
+/* === Public API ========================================================= */
+
+/* --- Plain Py_UNICODE --------------------------------------------------- */
+
+/* Create a Unicode Object from the Py_UNICODE buffer u of the given
+   size. 
+
+   u may be NULL which causes the contents to be undefined. It is the
+   user's responsibility to fill in the needed data afterwards. Note
+   that modifying the Unicode object contents after construction is
+   only allowed if u was set to NULL.
+
+   The buffer is copied into the new object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromUnicode(
+    const Py_UNICODE *u,        /* Unicode buffer */
+    int size                    /* size of buffer */
+    );
+
+/* Return a read-only pointer to the Unicode object's internal
+   Py_UNICODE buffer. */
+
+PyAPI_FUNC(Py_UNICODE *) PyUnicode_AsUnicode(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Get the length of the Unicode object. */
+
+PyAPI_FUNC(int) PyUnicode_GetSize(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Get the maximum ordinal for a Unicode character. */
+PyAPI_FUNC(Py_UNICODE) PyUnicode_GetMax(void);
+
+/* Resize an already allocated Unicode object to the new size length.
+
+   *unicode is modified to point to the new (resized) object and 0
+   returned on success.
+
+   This API may only be called by the function which also called the
+   Unicode constructor. The refcount on the object must be 1. Otherwise,
+   an error is returned.
+
+   Error handling is implemented as follows: an exception is set, -1
+   is returned and *unicode left untouched.
+
+*/
+
+PyAPI_FUNC(int) PyUnicode_Resize(
+    PyObject **unicode,		/* Pointer to the Unicode object */
+    int length			/* New length */
+    );
+
+/* Coerce obj to an Unicode object and return a reference with
+   *incremented* refcount.
+
+   Coercion is done in the following way:
+
+   1. String and other char buffer compatible objects are decoded
+      under the assumptions that they contain data using the current
+      default encoding. Decoding is done in "strict" mode.
+
+   2. All other objects (including Unicode objects) raise an
+      exception.
+
+   The API returns NULL in case of an error. The caller is responsible
+   for decref'ing the returned objects.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
+    register PyObject *obj, 	/* Object */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Coerce obj to an Unicode object and return a reference with
+   *incremented* refcount.
+   
+   Unicode objects are passed back as-is (subclasses are converted to
+   true Unicode objects), all other objects are delegated to
+   PyUnicode_FromEncodedObject(obj, NULL, "strict") which results in
+   using the default encoding as basis for decoding the object.
+
+   The API returns NULL in case of an error. The caller is responsible
+   for decref'ing the returned objects.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
+    register PyObject *obj 	/* Object */
+    );
+
+/* --- wchar_t support for platforms which support it --------------------- */
+
+#ifdef HAVE_WCHAR_H
+
+/* Create a Unicode Object from the whcar_t buffer w of the given
+   size.
+
+   The buffer is copied into the new object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
+    register const wchar_t *w,  /* wchar_t buffer */
+    int size                    /* size of buffer */
+    );
+
+/* Copies the Unicode Object contents into the wchar_t buffer w.  At
+   most size wchar_t characters are copied.
+
+   Note that the resulting wchar_t string may or may not be
+   0-terminated.  It is the responsibility of the caller to make sure
+   that the wchar_t string is 0-terminated in case this is required by
+   the application.
+
+   Returns the number of wchar_t characters copied (excluding a
+   possibly trailing 0-termination character) or -1 in case of an
+   error. */
+
+PyAPI_FUNC(int) PyUnicode_AsWideChar(
+    PyUnicodeObject *unicode,   /* Unicode object */
+    register wchar_t *w,        /* wchar_t buffer */
+    int size                    /* size of buffer */
+    );
+
+#endif
+
+/* --- Unicode ordinals --------------------------------------------------- */
+
+/* Create a Unicode Object from the given Unicode code point ordinal. 
+ 
+   The ordinal must be in range(0x10000) on narrow Python builds
+   (UCS2), and range(0x110000) on wide builds (UCS4). A ValueError is
+   raised in case it is not.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);
+
+/* === Builtin Codecs ===================================================== 
+
+   Many of these APIs take two arguments encoding and errors. These
+   parameters encoding and errors have the same semantics as the ones
+   of the builtin unicode() API. 
+
+   Setting encoding to NULL causes the default encoding to be used.
+
+   Error handling is set by errors which may also be set to NULL
+   meaning to use the default handling defined for the codec. Default
+   error handling for all builtin codecs is "strict" (ValueErrors are
+   raised).
+
+   The codecs all use a similar interface. Only deviation from the
+   generic ones are documented.
+
+*/
+
+/* --- Manage the default encoding ---------------------------------------- */
+
+/* Return a Python string holding the default encoded value of the
+   Unicode object. 
+
+   The resulting string is cached in the Unicode object for subsequent
+   usage by this function. The cached version is needed to implement
+   the character buffer interface and will live (at least) as long as
+   the Unicode object itself.
+
+   The refcount of the string is *not* incremented.
+
+   *** Exported for internal use by the interpreter only !!! ***
+
+*/
+
+PyAPI_FUNC(PyObject *) _PyUnicode_AsDefaultEncodedString(
+    PyObject *, const char *);
+
+/* Returns the currently active default encoding.
+
+   The default encoding is currently implemented as run-time settable
+   process global.  This may change in future versions of the
+   interpreter to become a parameter which is managed on a per-thread
+   basis.
+   
+ */
+
+PyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);
+
+/* Sets the currently active default encoding.
+
+   Returns 0 on success, -1 in case of an error.
+   
+ */
+
+PyAPI_FUNC(int) PyUnicode_SetDefaultEncoding(
+    const char *encoding	/* Encoding name in standard form */
+    );
+
+/* --- Generic Codecs ----------------------------------------------------- */
+
+/* Create a Unicode object by decoding the encoded string s of the
+   given size. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Decode(
+    const char *s,              /* encoded string */
+    int size,                   /* size of buffer */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a Py_UNICODE buffer of the given size and returns a 
+   Python string object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Encode(
+    const Py_UNICODE *s,        /* Unicode char buffer */
+    int size,                   /* number of Py_UNICODE chars to encode */
+    const char *encoding,       /* encoding */
+    const char *errors          /* error handling */
+    );
+
+/* Encodes a Unicode object and returns the result as Python
+   object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(
+    PyObject *unicode,	 	/* Unicode object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* Encodes a Unicode object and returns the result as Python string
+   object. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(
+    PyObject *unicode,	 	/* Unicode object */
+    const char *encoding,	/* encoding */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-7 Codecs ------------------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(
+    const char *string, 	/* UTF-7 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF7(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    int encodeSetO,             /* force the encoder to encode characters in
+                                   Set O, as described in RFC2152 */
+    int encodeWhiteSpace,       /* force the encoder to encode space, tab,
+                                   carriage return and linefeed characters */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-8 Codecs ------------------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(
+    const char *string, 	/* UTF-8 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(
+    const char *string, 	/* UTF-8 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *consumed		/* bytes consumed */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF8(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- UTF-16 Codecs ------------------------------------------------------ */
+
+/* Decodes length bytes from a UTF-16 encoded buffer string and returns
+   the corresponding Unicode object.
+
+   errors (if non-NULL) defines the error handling. It defaults
+   to "strict". 
+
+   If byteorder is non-NULL, the decoder starts decoding using the
+   given byte order:
+
+	*byteorder == -1: little endian
+	*byteorder == 0:  native order
+	*byteorder == 1:  big endian
+
+   In native mode, the first two bytes of the stream are checked for a
+   BOM mark. If found, the BOM mark is analysed, the byte order
+   adjusted and the BOM skipped.  In the other modes, no BOM mark
+   interpretation is done. After completion, *byteorder is set to the
+   current byte order at the end of input data.
+
+   If byteorder is NULL, the codec starts in native order mode.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(
+    const char *string, 	/* UTF-16 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *byteorder		/* pointer to byteorder to use
+				   0=native;-1=LE,1=BE; updated on
+				   exit */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(
+    const char *string, 	/* UTF-16 encoded string */
+    int length,	 		/* size of string */
+    const char *errors,		/* error handling */
+    int *byteorder,		/* pointer to byteorder to use
+				   0=native;-1=LE,1=BE; updated on
+				   exit */
+    int *consumed		/* bytes consumed */
+    );
+
+/* Returns a Python string using the UTF-16 encoding in native byte
+   order. The string always starts with a BOM mark.  */
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+/* Returns a Python string object holding the UTF-16 encoded value of
+   the Unicode data.
+
+   If byteorder is not 0, output is written according to the following
+   byte order:
+
+   byteorder == -1: little endian
+   byteorder == 0:  native byte order (writes a BOM mark)
+   byteorder == 1:  big endian
+
+   If byteorder is 0, the output string will always start with the
+   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
+   prepended.
+
+   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
+   UCS-2. This trick makes it possible to add full UTF-16 capabilities
+   at a later point without compromising the APIs.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUTF16(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* number of Py_UNICODE chars to encode */
+    const char *errors,		/* error handling */
+    int byteorder		/* byteorder to use 0=BOM+native;-1=LE,1=BE */
+    );
+
+/* --- Unicode-Escape Codecs ---------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(
+    const char *string, 	/* Unicode-Escape encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeUnicodeEscape(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length	 		/* Number of Py_UNICODE chars to encode */
+    );
+
+/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(
+    const char *string, 	/* Raw-Unicode-Escape encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeRawUnicodeEscape(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length	 		/* Number of Py_UNICODE chars to encode */
+    );
+
+/* --- Latin-1 Codecs ----------------------------------------------------- 
+
+   Note: Latin-1 corresponds to the first 256 Unicode ordinals.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(
+    const char *string, 	/* Latin-1 encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeLatin1(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- ASCII Codecs ------------------------------------------------------- 
+
+   Only 7-bit ASCII data is excepted. All other codes generate errors.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(
+    const char *string, 	/* ASCII encoded string */
+    int length,	 		/* size of string */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(
+    PyObject *unicode	 	/* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeASCII(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    const char *errors		/* error handling */
+    );
+
+/* --- Character Map Codecs ----------------------------------------------- 
+
+   This codec uses mappings to encode and decode characters. 
+
+   Decoding mappings must map single string characters to single
+   Unicode characters, integers (which are then interpreted as Unicode
+   ordinals) or None (meaning "undefined mapping" and causing an
+   error).
+
+   Encoding mappings must map single Unicode characters to single
+   string characters, integers (which are then interpreted as Latin-1
+   ordinals) or None (meaning "undefined mapping" and causing an
+   error).
+
+   If a character lookup fails with a LookupError, the character is
+   copied as-is meaning that its ordinal value will be interpreted as
+   Unicode or Latin-1 ordinal resp. Because of this mappings only need
+   to contain those mappings which map characters to different code
+   points.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(
+    const char *string, 	/* Encoded string */
+    int length,	 		/* size of string */
+    PyObject *mapping,		/* character mapping 
+				   (char ordinal -> unicode ordinal) */
+    const char *errors		/* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(
+    PyObject *unicode,	 	/* Unicode object */
+    PyObject *mapping		/* character mapping 
+				   (unicode ordinal -> char ordinal) */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeCharmap(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    PyObject *mapping,		/* character mapping 
+				   (unicode ordinal -> char ordinal) */
+    const char *errors		/* error handling */
+    );
+
+/* Translate a Py_UNICODE buffer of the given length by applying a
+   character mapping table to it and return the resulting Unicode
+   object.
+
+   The mapping table must map Unicode ordinal integers to Unicode
+   ordinal integers or None (causing deletion of the character). 
+
+   Mapping tables may be dictionaries or sequences. Unmapped character
+   ordinals (ones which cause a LookupError) are left untouched and
+   are copied as-is.
+
+*/
+
+PyAPI_FUNC(PyObject *) PyUnicode_TranslateCharmap(
+    const Py_UNICODE *data, 	/* Unicode char buffer */
+    int length,	 		/* Number of Py_UNICODE chars to encode */
+    PyObject *table,		/* Translate table */
+    const char *errors		/* error handling */
+    );
+
+#ifdef MS_WIN32
+
+/* --- MBCS codecs for Windows -------------------------------------------- */
+
+PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(
+    const char *string,         /* MBCS encoded string */
+    int length,                 /* size of string */
+    const char *errors          /* error handling */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(
+    PyObject *unicode           /* Unicode object */
+    );
+
+PyAPI_FUNC(PyObject*) PyUnicode_EncodeMBCS(
+    const Py_UNICODE *data,     /* Unicode char buffer */
+    int length,                 /* Number of Py_UNICODE chars to encode */
+    const char *errors          /* error handling */
+    );
+
+#endif /* MS_WIN32 */
+
+/* --- Decimal Encoder ---------------------------------------------------- */
+
+/* Takes a Unicode string holding a decimal value and writes it into
+   an output buffer using standard ASCII digit codes.
+
+   The output buffer has to provide at least length+1 bytes of storage
+   area. The output string is 0-terminated.
+
+   The encoder converts whitespace to ' ', decimal characters to their
+   corresponding ASCII digit and all other Latin-1 characters except
+   \0 as-is. Characters outside this range (Unicode ordinals 1-256)
+   are treated as errors. This includes embedded NULL bytes.
+
+   Error handling is defined by the errors argument:
+
+      NULL or "strict": raise a ValueError
+      "ignore": ignore the wrong characters (these are not copied to the
+		output buffer)
+      "replace": replaces illegal characters with '?'
+
+   Returns 0 on success, -1 on failure.
+
+*/
+
+PyAPI_FUNC(int) PyUnicode_EncodeDecimal(
+    Py_UNICODE *s,		/* Unicode buffer */
+    int length,			/* Number of Py_UNICODE chars to encode */
+    char *output,		/* Output buffer; must have size >= length */
+    const char *errors		/* error handling */
+    );
+
+/* --- Methods & Slots ----------------------------------------------------
+
+   These are capable of handling Unicode objects and strings on input
+   (we refer to them as strings in the descriptions) and return
+   Unicode objects or integers as apporpriate. */
+
+/* Concat two strings giving a new Unicode string. */
+
+PyAPI_FUNC(PyObject*) PyUnicode_Concat(
+    PyObject *left,	 	/* Left string */
+    PyObject *right	 	/* Right string */
+    );
+
+/* Split a string giving a list of Unicode strings.
+
+   If sep is NULL, splitting will be done at all whitespace
+   substrings. Otherwise, splits occur at the given separator.
+
+   At most maxsplit splits will be done. If negative, no limit is set.
+
+   Separators are not included in the resulting list.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_Split(
+    PyObject *s,		/* String to split */
+    PyObject *sep,		/* String separator */
+    int maxsplit		/* Maxsplit count */
+    );		
+
+/* Dito, but split at line breaks.
+
+   CRLF is considered to be one line break. Line breaks are not
+   included in the resulting list. */
+    
+PyAPI_FUNC(PyObject*) PyUnicode_Splitlines(
+    PyObject *s,		/* String to split */
+    int keepends		/* If true, line end markers are included */
+    );		
+
+/* Split a string giving a list of Unicode strings.
+
+   If sep is NULL, splitting will be done at all whitespace
+   substrings. Otherwise, splits occur at the given separator.
+
+   At most maxsplit splits will be done. But unlike PyUnicode_Split
+   PyUnicode_RSplit splits from the end of the string. If negative,
+   no limit is set.
+
+   Separators are not included in the resulting list.
+
+*/
+
+PyAPI_FUNC(PyObject*) PyUnicode_RSplit(
+    PyObject *s,		/* String to split */
+    PyObject *sep,		/* String separator */
+    int maxsplit		/* Maxsplit count */
+    );		
+
+/* Translate a string by applying a character mapping table to it and
+   return the resulting Unicode object.
+
+   The mapping table must map Unicode ordinal integers to Unicode
+   ordinal integers or None (causing deletion of the character). 
+
+   Mapping tables may be dictionaries or sequences. Unmapped character
+   ordinals (ones which cause a LookupError) are left untouched and
+   are copied as-is.
+
+*/
+
+PyAPI_FUNC(PyObject *) PyUnicode_Translate(
+    PyObject *str,		/* String */ 
+    PyObject *table,		/* Translate table */
+    const char *errors		/* error handling */
+    );
+
+/* Join a sequence of strings using the given separator and return
+   the resulting Unicode string. */
+    
+PyAPI_FUNC(PyObject*) PyUnicode_Join(
+    PyObject *separator, 	/* Separator string */
+    PyObject *seq	 	/* Sequence object */
+    );
+
+/* Return 1 if substr matches str[start:end] at the given tail end, 0
+   otherwise. */
+
+PyAPI_FUNC(int) PyUnicode_Tailmatch(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Prefix or Suffix string */
+    int start,			/* Start index */
+    int end,			/* Stop index */
+    int direction		/* Tail end: -1 prefix, +1 suffix */
+    );
+
+/* Return the first position of substr in str[start:end] using the
+   given search direction or -1 if not found. -2 is returned in case
+   an error occurred and an exception is set. */
+
+PyAPI_FUNC(int) PyUnicode_Find(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to find */
+    int start,			/* Start index */
+    int end,			/* Stop index */
+    int direction		/* Find direction: +1 forward, -1 backward */
+    );
+
+/* Count the number of occurrences of substr in str[start:end]. */
+
+PyAPI_FUNC(int) PyUnicode_Count(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to count */
+    int start,			/* Start index */
+    int end			/* Stop index */
+    );
+
+/* Replace at most maxcount occurrences of substr in str with replstr
+   and return the resulting Unicode object. */
+
+PyAPI_FUNC(PyObject *) PyUnicode_Replace(
+    PyObject *str,		/* String */ 
+    PyObject *substr,		/* Substring to find */
+    PyObject *replstr,		/* Substring to replace */
+    int maxcount		/* Max. number of replacements to apply;
+				   -1 = all */
+    );
+
+/* Compare two strings and return -1, 0, 1 for less than, equal,
+   greater than resp. */
+
+PyAPI_FUNC(int) PyUnicode_Compare(
+    PyObject *left,		/* Left string */ 
+    PyObject *right		/* Right string */
+    );
+
+/* Apply a argument tuple or dictionary to a format string and return
+   the resulting Unicode string. */
+
+PyAPI_FUNC(PyObject *) PyUnicode_Format(
+    PyObject *format,		/* Format string */ 
+    PyObject *args		/* Argument tuple or dictionary */
+    );
+
+/* Checks whether element is contained in container and return 1/0
+   accordingly.
+
+   element has to coerce to an one element Unicode string. -1 is
+   returned in case of an error. */
+
+PyAPI_FUNC(int) PyUnicode_Contains(
+    PyObject *container,	/* Container string */ 
+    PyObject *element		/* Element string */
+    );
+
+/* Externally visible for str.strip(unicode) */
+PyAPI_FUNC(PyObject *) _PyUnicode_XStrip(
+    PyUnicodeObject *self,
+    int striptype,
+    PyObject *sepobj
+    );
+
+/* === Characters Type APIs =============================================== */
+
+/* These should not be used directly. Use the Py_UNICODE_IS* and
+   Py_UNICODE_TO* macros instead. 
+
+   These APIs are implemented in Objects/unicodectype.c.
+
+*/
+
+PyAPI_FUNC(int) _PyUnicode_IsLowercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsUppercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsTitlecase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsWhitespace(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsLinebreak(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToLowercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToUppercase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(Py_UNICODE) _PyUnicode_ToTitlecase(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_ToDecimalDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_ToDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(double) _PyUnicode_ToNumeric(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsDecimalDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsDigit(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsNumeric(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+PyAPI_FUNC(int) _PyUnicode_IsAlpha(
+    Py_UNICODE ch 	/* Unicode character */
+    );
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* Py_USING_UNICODE */
+#endif /* !Py_UNICODEOBJECT_H */

Added: trunk/mingw-libs/include/weakrefobject.h
===================================================================
--- trunk/mingw-libs/include/weakrefobject.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/weakrefobject.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,75 @@
+/* Weak references objects for Python. */
+
+#ifndef Py_WEAKREFOBJECT_H
+#define Py_WEAKREFOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef struct _PyWeakReference PyWeakReference;
+
+/* PyWeakReference is the base struct for the Python ReferenceType, ProxyType,
+ * and CallableProxyType.
+ */
+struct _PyWeakReference {
+    PyObject_HEAD
+
+    /* The object to which this is a weak reference, or Py_None if none.
+     * Note that this is a stealth reference:  wr_object's refcount is
+     * not incremented to reflect this pointer.
+     */
+    PyObject *wr_object;
+
+    /* A callable to invoke when wr_object dies, or NULL if none. */
+    PyObject *wr_callback;
+
+    /* A cache for wr_object's hash code.  As usual for hashes, this is -1
+     * if the hash code isn't known yet.
+     */
+    long hash;
+
+    /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL-
+     * terminated list of weak references to it.  These are the list pointers.
+     * If wr_object goes away, wr_object is set to Py_None, and these pointers
+     * have no meaning then.
+     */
+    PyWeakReference *wr_prev;
+    PyWeakReference *wr_next;
+};
+
+PyAPI_DATA(PyTypeObject) _PyWeakref_RefType;
+PyAPI_DATA(PyTypeObject) _PyWeakref_ProxyType;
+PyAPI_DATA(PyTypeObject) _PyWeakref_CallableProxyType;
+
+#define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &_PyWeakref_RefType)
+#define PyWeakref_CheckRefExact(op) \
+        ((op)->ob_type == &_PyWeakref_RefType)
+#define PyWeakref_CheckProxy(op) \
+        (((op)->ob_type == &_PyWeakref_ProxyType) || \
+         ((op)->ob_type == &_PyWeakref_CallableProxyType))
+
+/* This macro calls PyWeakref_CheckRef() last since that can involve a
+   function call; this makes it more likely that the function call
+   will be avoided. */
+#define PyWeakref_Check(op) \
+        (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
+
+
+PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
+                                              PyObject *callback);
+PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
+                                                PyObject *callback);
+PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+
+PyAPI_FUNC(long) _PyWeakref_GetWeakrefCount(PyWeakReference *head);
+
+PyAPI_FUNC(void) _PyWeakref_ClearRef(PyWeakReference *self);
+
+#define PyWeakref_GET_OBJECT(ref) (((PyWeakReference *)(ref))->wr_object)
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_WEAKREFOBJECT_H */

Added: trunk/mingw-libs/include/zconf.h
===================================================================
--- trunk/mingw-libs/include/zconf.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/zconf.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,326 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2004 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_          z_deflateInit_
+#  define deflate               z_deflate
+#  define deflateEnd            z_deflateEnd
+#  define inflateInit_          z_inflateInit_
+#  define inflate               z_inflate
+#  define inflateEnd            z_inflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateCopy           z_deflateCopy
+#  define deflateReset          z_deflateReset
+#  define deflateParams         z_deflateParams
+#  define deflateBound          z_deflateBound
+#  define deflatePrime          z_deflatePrime
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateCopy           z_inflateCopy
+#  define inflateReset          z_inflateReset
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define uncompress            z_uncompress
+#  define adler32               z_adler32
+#  define crc32                 z_crc32
+#  define get_crc_table         z_get_crc_table
+#  define zError                z_zError
+
+#  define Byte                  z_Byte
+#  define uInt                  z_uInt
+#  define uLong                 z_uLong
+#  define Bytef                 z_Bytef
+#  define charf                 z_charf
+#  define intf                  z_intf
+#  define uIntf                 z_uIntf
+#  define uLongf                z_uLongf
+#  define voidpf                z_voidpf
+#  define voidp                 z_voidp
+#endif
+
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) && !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#  define WIN32
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
+#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ >= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#if 1           /* HAVE_UNISTD_H -- this line is updated by ./configure */
+#  include <sys/types.h> /* for off_t */
+#  include <unistd.h>    /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include <unixio.h>   /* for off_t */
+#  endif
+#  define z_off_t off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#  ifdef FAR
+#    undef FAR
+#  endif
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(deflateBound,"DEBND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(compressBound,"CMBND")
+#   pragma map(inflate_table,"INTABL")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_copyright,"INCOPY")
+#endif
+
+#endif /* ZCONF_H */

Added: trunk/mingw-libs/include/zlib.h
===================================================================
--- trunk/mingw-libs/include/zlib.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/mingw-libs/include/zlib.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,1200 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.2, October 3rd, 2004
+
+  Copyright (C) 1995-2004 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup at gzip.org          madler at alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.2.2"
+#define ZLIB_VERNUM 0x1220
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with "gz".  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+     This library can optionally read and write gzip streams in memory as well.
+
+     The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: ascii or binary */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/*
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  the compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out is greater than six to avoid repeated flush markers due to
+  avail_out == 0 on return.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  the value returned by deflateBound (see below). If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm->adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update data_type if it can make a good guess about
+  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+  fatal, and deflate() can be called again with more input and more output
+  space to continue compressing.
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/*
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
+  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
+  if and when it get to the next deflate block boundary. When decoding the zlib
+  or gzip format, this will cause inflate() to return immediately after the
+  header and before the first block. When doing a raw inflate, inflate() will
+  go ahead and process the first block, and will return when it gets to the end
+  of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm->data_type to the
+  number of unused bits in the last byte taken from strm->next_in, plus 64
+  if inflate() is currently decoding the last block in the deflate stream,
+  plus 128 if inflate() returned immediately after decoding an end-of-block
+  code or decoding the complete header up to just before the first byte of the
+  deflate stream. The end-of-block will not be indicated until all of the
+  uncompressed data from that block has been written to strm->next_out.  The
+  number of unused bits may in general be greater than seven, except when
+  bit 7 of data_type is set, in which case the number of unused bits will be
+  less than eight.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster approach
+  may be used for the single inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call. So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm->adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm->adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below. At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically.  Any information
+  contained in the gzip header is not retained, so applications that need that
+  information should instead use raw inflate, see inflateInit2() below, or
+  inflateBack() and perform their own processing of the gzip header and
+  trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing. If Z_DATA_ERROR is returned, the application may then
+  call inflateSync() to look for a good compression block if a partial recovery
+  of the data is desired.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer). It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
+   determines the window size. deflate() will then generate raw deflate data
+   with no zlib header or trailer, and will not compute an adler32 check value.
+
+     windowBits can also be greater than 15 for optional gzip encoding. Add
+   16 to windowBits to write a simple gzip header and trailer around the
+   compressed data instead of a zlib wrapper. The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero),
+   no header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match), or Z_RLE to limit match distances to one (run-length
+   encoding). Filtered data consists mostly of small values with a somewhat
+   random distribution. In this case, the compression algorithm is tuned to
+   compress them better. The effect of Z_FILTERED is to force more Huffman
+   coding and less string matching; it is somewhat intermediate between
+   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
+   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
+   parameter only affects the compression ratio but not the correctness of the
+   compressed output even if it is not set appropriately.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front.
+
+     Upon return of this function, strm->adler is set to the adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.) If a raw deflate was requested, then the
+   adler32 value is not computed and strm->adler is not set.
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                      int level,
+                                      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                       uLong sourceLen));
+/*
+     deflateBound() returns an upper bound on the compressed size after
+   deflation of sourceLen bytes.  It must be called after deflateInit()
+   or deflateInit2().  This would be used to allocate an output buffer
+   for deflation in a single pass, and so would be called before deflate().
+*/
+
+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     deflatePrime() inserts bits in the deflate output stream.  The intent
+  is that this function is used to start off the deflate output with the
+  bits leftover from a previous deflate stream when appending to it.  As such,
+  this function can only be used for raw deflate, and must be used before the
+  first deflate() call after a deflateInit2() or deflateReset().  bits must be
+  less than or equal to 16, and that many of the least significant bits of
+  value will be inserted in the output.
+
+      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. windowBits must be greater than or equal to the windowBits value
+   provided to deflateInit2() while compressing, or it must be equal to 15 if
+   deflateInit2() was not used. If a compressed stream with a larger window
+   size is given as input, inflate() will return with the error code
+   Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
+   determines the window size. inflate() will then process raw deflate data,
+   not looking for a zlib or gzip header, not generating a check value, and not
+   looking for any check values for comparison at the end of the stream. This
+   is for use with other formats that use the deflate compressed data format
+   such as zip.  Those formats provide their own check values. If a custom
+   format is developed using the raw deflate format for compressed data, it is
+   recommended that a check value such as an adler32 or a crc32 be applied to
+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+   most applications, the zlib format should be used as is. Note that comments
+   above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+     windowBits can also be greater than 15 for optional gzip decoding. Add
+   32 to windowBits to enable zlib and gzip decoding with automatic header
+   detection, or add 16 to decode only the gzip format (the zlib format will
+   return a Z_DATA_ERROR.  If a gzip stream is being decoded, strm->adler is
+   a crc32 instead of an adler32.
+
+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
+   memLevel). msg is set to null if there is no error message.  inflateInit2
+   does not perform any decompression apart from reading the zlib header if
+   present: this will be done by inflate(). (So next_in and avail_in may be
+   modified, but next_out and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate
+   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by this call of
+   inflate. The compressor and decompressor must use exactly the same
+   dictionary (see deflateSetDictionary).
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/*
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when randomly accessing a large stream.  The
+   first pass through the stream can periodically record the inflate state,
+   allowing restarting inflate at those points when randomly accessing the
+   stream.
+
+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateBackInit OF((z_stream FAR *strm, int windowBits,
+                                        unsigned char FAR *window));
+
+     Initialize the internal stream state for decompression using inflateBack()
+   calls.  The fields zalloc, zfree and opaque in strm must be initialized
+   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   derived memory allocation routines are used.  windowBits is the base two
+   logarithm of the window size, in the range 8..15.  window is a caller
+   supplied buffer of that size.  Except for special applications where it is
+   assured that deflate was used with small window sizes, windowBits must be 15
+   and a 32K byte window must be supplied to be able to decompress general
+   deflate streams.
+
+     See inflateBack() for the usage of these routines.
+
+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
+   be allocated, or Z_VERSION_ERROR if the version of the library does not
+   match the version of the header file.
+*/
+
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
+
+ZEXTERN int ZEXPORT inflateBack OF((z_stream FAR *strm,
+                                    in_func in, void FAR *in_desc,
+                                    out_func out, void FAR *out_desc));
+/*
+     inflateBack() does a raw inflate with a single call using a call-back
+   interface for input and output.  This is more efficient than inflate() for
+   file i/o applications in that it avoids copying between the output and the
+   sliding window by simply making the window itself the output buffer.  This
+   function trusts the application to not change the output buffer passed by
+   the output function, at least until inflateBack() returns.
+
+     inflateBackInit() must be called first to allocate the internal state
+   and to initialize the state with the user-provided window buffer.
+   inflateBack() may then be used multiple times to inflate a complete, raw
+   deflate stream with each call.  inflateBackEnd() is then called to free
+   the allocated state.
+
+     A raw deflate stream is one with no zlib or gzip header or trailer.
+   This routine would normally be used in a utility that reads zip or gzip
+   files and writes out uncompressed files.  The utility would decode the
+   header and process the trailer on its own, hence this routine expects
+   only the raw deflate stream to decompress.  This is different from the
+   normal behavior of inflate(), which expects either a zlib or gzip header and
+   trailer around the deflate stream.
+
+     inflateBack() uses two subroutines supplied by the caller that are then
+   called by inflateBack() for input and output.  inflateBack() calls those
+   routines until it reads a complete deflate stream and writes out all of the
+   uncompressed data, or until it encounters an error.  The function's
+   parameters and return types are defined above in the in_func and out_func
+   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
+   number of bytes of provided input, and a pointer to that input in buf.  If
+   there is no input available, in() must return zero--buf is ignored in that
+   case--and inflateBack() will return a buffer error.  inflateBack() will call
+   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+   should return zero on success, or non-zero on failure.  If out() returns
+   non-zero, inflateBack() will return with an error.  Neither in() nor out()
+   are permitted to change the contents of the window provided to
+   inflateBackInit(), which is also the buffer that out() uses to write from.
+   The length written by out() will be at most the window size.  Any non-zero
+   amount of input may be provided by in().
+
+     For convenience, inflateBack() can be provided input on the first call by
+   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
+   in() will be called.  Therefore strm->next_in must be initialized before
+   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
+   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
+   must also be initialized, and then if strm->avail_in is not zero, input will
+   initially be taken from strm->next_in[0 .. strm->avail_in - 1].
+
+     The in_desc and out_desc parameters of inflateBack() is passed as the
+   first parameter of in() and out() respectively when they are called.  These
+   descriptors can be optionally used to pass any information that the caller-
+   supplied in() and out() functions need to do their job.
+
+     On return, inflateBack() will set strm->next_in and strm->avail_in to
+   pass back any unused input that was provided by the last in() call.  The
+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format
+   error in the deflate stream (in which case strm->msg is set to indicate the
+   nature of the error), or Z_STREAM_ERROR if the stream was not properly
+   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
+   distinguished using strm->next_in which will be Z_NULL only if in() returned
+   an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
+   out() returning non-zero.  (in() will always be called before out(), so
+   strm->next_in is assured to be defined if out() returns non-zero.)  Note
+   that inflateBack() cannot return Z_OK.
+*/
+
+ZEXTERN int ZEXPORT inflateBackEnd OF((z_stream FAR *strm));
+/*
+     All memory allocated by inflateBackInit() is freed.
+
+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+   state was inconsistent.
+*/
+
+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+/* Return flags indicating compile-time options.
+
+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+     1.0: size of uInt
+     3.2: size of uLong
+     5.4: size of voidpf (pointer)
+     7.6: size of z_off_t
+
+    Compiler, assembler, and debug options:
+     8: DEBUG
+     9: ASMV or ASMINF -- use ASM code
+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+     11: 0 (reserved)
+
+    One-time table building (smaller code, but not thread-safe if true):
+     12: BUILDFIXED -- build static block decoding tables when needed
+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+     14,15: 0 (reserved)
+
+    Library content (indicates missing functionality):
+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                          deflate code when not needed)
+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                    and decode gzip streams (to avoid linking crc code)
+     18-19: 0 (reserved)
+
+    Operation variations (changes in library functionality):
+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+     21: FASTEST -- deflate algorithm with only one, lowest compression level
+     22,23: 0 (reserved)
+
+    The sprintf variant used by gzprintf (zero is best):
+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+    Remainder:
+     27-31: 0 (reserved)
+ */
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least the value returned
+   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least the value returned by
+   compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+/*
+     compressBound() returns an upper bound on the compressed size after
+   compress() or compress2() on sourceLen bytes.  It would be used before
+   a compress() or compress2() call to allocate the destination buffer.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+   Huffman only compression as in "wb1h", or 'R' for run-length encoding
+   as in "wb1R". (See the description of deflateInit2 for more information
+   about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
+                                   voidpc buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).  The number of
+   uncompressed bytes written is limited to 4095. The caller should assure that
+   this limit is not exceeded. If it is exceeded, then gzprintf() will return
+   return an error (0) with nothing written. In this case, there may also be a
+   buffer overflow with unpredictable consequences, which is possible only if
+   zlib was compiled with the insecure functions sprintf() or vsprintf()
+   because the secure snprintf() or vsnprintf() functions were not available.
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+/*
+      Push one character back onto the stream to be read again later.
+   Only one character of push-back is allowed.  gzungetc() returns the
+   character pushed, or -1 on failure.  gzungetc() will fail if a
+   character has been pushed but not read yet, or if c is -1. The pushed
+   character will be discarded if the stream is repositioned with gzseek()
+   or gzrewind().
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+                                      z_off_t offset, int whence));
+/*
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+/*
+     Clears the error and end-of-file flags for file. This is analogous to the
+   clearerr() function in stdio. This is useful for continuing to read a gzip
+   file that is being written concurrently.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running crc with the bytes buf[0..len-1] and return the updated
+   crc. If buf is NULL, this function returns the required initial value
+   for the crc. Pre- and post-conditioning (one's complement) is performed
+   within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_stream FAR *strm, int windowBits,
+                                         unsigned char FAR *window,
+                                         const char *version,
+                                         int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+        ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */

Added: trunk/mingw-libs/lib/libpython24.a
===================================================================
(Binary files differ)


Property changes on: trunk/mingw-libs/lib/libpython24.a
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/mingw-libs/lib/libz.a
===================================================================
(Binary files differ)


Property changes on: trunk/mingw-libs/lib/libz.a
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/python24.dll
===================================================================
(Binary files differ)


Property changes on: trunk/python24.dll
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/source/games/ggob.cpp
===================================================================
--- trunk/source/games/ggob.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/games/ggob.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -47,6 +47,8 @@
 #include "other/dialogs.h"
 #include "other/twconfig.h"
 
+#include "python/python_class.h"
+
 #define gobgame ((GobGame*)game)
 
 ////////////////////////////////////////////////////////////////////////
@@ -253,10 +255,15 @@
   StarSystem* s = new StarSystem("FakeSystem_123", Vector2(0,0));
   _name = "FakeSystem_123";
   _galaxy.add(s);
+
+  /*
   if(Load(data_full_path("xml/GOB/start.xml")) == 1)
     {
       tw_error("unable to locate start.xml");
     };  
+  */
+
+  python::exec_file("start");
   
   _galaxy._stars.remove(s);
   delete s;
@@ -530,6 +537,24 @@
   return;
 }
 
+void GobGame::add_stars()
+{
+  add(new Stars());
+}
+void GobGame::add_asteroid()
+{
+  add(new GobAsteroid());
+}
+void GobGame::add_system(std::string name, int x, int y)
+{
+  _galaxy.add(new StarSystem(name,Vector2(x,y)));
+  gobgame->switch_system(name);
+}
+void GobGame::add_player(std::string system, int x, int y)
+{
+  add_gobplayer(system, Vector2(x,y));
+}
+
 void GobEnemy::init(Ship *ship, int kill_starbucks, int kill_buckazoids) 
 {
   STACKTRACE;
@@ -589,7 +614,7 @@
   return;
 }
 
-GobPlayer::pair *GobPlayer::_get_pair(const char *id) 
+pair *GobPlayer::_get_pair(const char *id) 
 {
   STACKTRACE;
   if (!pair_list) 

Modified: trunk/source/games/ggob.h
===================================================================
--- trunk/source/games/ggob.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/games/ggob.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -29,6 +29,12 @@
 class Upgrade;
 class GobStation;
 
+struct pair 
+{
+  char *id;
+  int value;
+};
+
 /// Player possession (ship, money, upgrades)
 class GobPlayer 
 {
@@ -37,11 +43,6 @@
   ~GobPlayer()
 ;
   Ship *ship;
-  struct pair 
-  {
-    char *id;
-    int value;
-  };
   pair *pair_list;
   int num_pairs;
   void _add_pair(const char *id, int value);
@@ -100,6 +101,7 @@
   void add_gobplayer(const std::string& system, Vector2 pos);
 
   GobGame();
+  static GobGame* get_this() {return gobgame;}
   virtual ~GobGame();
 
   ShipPanel *_player_panel;
@@ -126,8 +128,14 @@
   //	protected:
   virtual void fps ();
   
+
+  // For Python interface
   void add_new_enemy();
-  
+  void add_stars();
+  void add_asteroid();
+  void add_system(std::string name, int x, int y);;
+  void add_player(std::string name, int x, int y);
+ 
   int next_add_new_enemy_time;
   
   SpaceSprite *defenderSprite;

Added: trunk/source/generated/ggob.py
===================================================================
--- trunk/source/generated/ggob.py	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/generated/ggob.py	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,380 @@
+# This file was created automatically by SWIG.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _ggob
+
+def _swig_setattr(self,class_type,name,value):
+    if (name == "this"):
+        if isinstance(value, class_type):
+            self.__dict__[name] = value.this
+            if hasattr(value,"thisown"): self.__dict__["thisown"] = value.thisown
+            del value.thisown
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    self.__dict__[name] = value
+
+def _swig_getattr(self,class_type,name):
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class pair(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, pair, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, pair, name)
+    def __repr__(self):
+        return "<C pair instance at %s>" % (self.this,)
+    __swig_setmethods__["id"] = _ggob.pair_id_set
+    __swig_getmethods__["id"] = _ggob.pair_id_get
+    if _newclass:id = property(_ggob.pair_id_get, _ggob.pair_id_set)
+    __swig_setmethods__["value"] = _ggob.pair_value_set
+    __swig_getmethods__["value"] = _ggob.pair_value_get
+    if _newclass:value = property(_ggob.pair_value_get, _ggob.pair_value_set)
+    def __init__(self, *args):
+        _swig_setattr(self, pair, 'this', _ggob.new_pair(*args))
+        _swig_setattr(self, pair, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_pair):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class pairPtr(pair):
+    def __init__(self, this):
+        _swig_setattr(self, pair, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, pair, 'thisown', 0)
+        _swig_setattr(self, pair,self.__class__,pair)
+_ggob.pair_swigregister(pairPtr)
+
+class GobPlayer(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobPlayer, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobPlayer, name)
+    def __repr__(self):
+        return "<C GobPlayer instance at %s>" % (self.this,)
+    def __init__(self, *args):
+        _swig_setattr(self, GobPlayer, 'this', _ggob.new_GobPlayer(*args))
+        _swig_setattr(self, GobPlayer, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobPlayer):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__["ship"] = _ggob.GobPlayer_ship_set
+    __swig_getmethods__["ship"] = _ggob.GobPlayer_ship_get
+    if _newclass:ship = property(_ggob.GobPlayer_ship_get, _ggob.GobPlayer_ship_set)
+    __swig_setmethods__["pair_list"] = _ggob.GobPlayer_pair_list_set
+    __swig_getmethods__["pair_list"] = _ggob.GobPlayer_pair_list_get
+    if _newclass:pair_list = property(_ggob.GobPlayer_pair_list_get, _ggob.GobPlayer_pair_list_set)
+    __swig_setmethods__["num_pairs"] = _ggob.GobPlayer_num_pairs_set
+    __swig_getmethods__["num_pairs"] = _ggob.GobPlayer_num_pairs_get
+    if _newclass:num_pairs = property(_ggob.GobPlayer_num_pairs_get, _ggob.GobPlayer_num_pairs_set)
+    def _add_pair(*args): return _ggob.GobPlayer__add_pair(*args)
+    def _get_pair(*args): return _ggob.GobPlayer__get_pair(*args)
+    def write_pair(*args): return _ggob.GobPlayer_write_pair(*args)
+    def read_pair(*args): return _ggob.GobPlayer_read_pair(*args)
+    __swig_setmethods__["total"] = _ggob.GobPlayer_total_set
+    __swig_getmethods__["total"] = _ggob.GobPlayer_total_get
+    if _newclass:total = property(_ggob.GobPlayer_total_get, _ggob.GobPlayer_total_set)
+    __swig_setmethods__["starbucks"] = _ggob.GobPlayer_starbucks_set
+    __swig_getmethods__["starbucks"] = _ggob.GobPlayer_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobPlayer_starbucks_get, _ggob.GobPlayer_starbucks_set)
+    __swig_setmethods__["buckazoids"] = _ggob.GobPlayer_buckazoids_set
+    __swig_getmethods__["buckazoids"] = _ggob.GobPlayer_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobPlayer_buckazoids_get, _ggob.GobPlayer_buckazoids_set)
+    __swig_setmethods__["kills"] = _ggob.GobPlayer_kills_set
+    __swig_getmethods__["kills"] = _ggob.GobPlayer_kills_get
+    if _newclass:kills = property(_ggob.GobPlayer_kills_get, _ggob.GobPlayer_kills_set)
+    __swig_setmethods__["value_starbucks"] = _ggob.GobPlayer_value_starbucks_set
+    __swig_getmethods__["value_starbucks"] = _ggob.GobPlayer_value_starbucks_get
+    if _newclass:value_starbucks = property(_ggob.GobPlayer_value_starbucks_get, _ggob.GobPlayer_value_starbucks_set)
+    __swig_setmethods__["value_buckazoids"] = _ggob.GobPlayer_value_buckazoids_set
+    __swig_getmethods__["value_buckazoids"] = _ggob.GobPlayer_value_buckazoids_get
+    if _newclass:value_buckazoids = property(_ggob.GobPlayer_value_buckazoids_get, _ggob.GobPlayer_value_buckazoids_set)
+    __swig_setmethods__["team"] = _ggob.GobPlayer_team_set
+    __swig_getmethods__["team"] = _ggob.GobPlayer_team_get
+    if _newclass:team = property(_ggob.GobPlayer_team_get, _ggob.GobPlayer_team_set)
+    def init(*args): return _ggob.GobPlayer_init(*args)
+    def died(*args): return _ggob.GobPlayer_died(*args)
+    def new_ship(*args): return _ggob.GobPlayer_new_ship(*args)
+    def charge(*args): return _ggob.GobPlayer_charge(*args)
+    __swig_setmethods__["upgrade_list"] = _ggob.GobPlayer_upgrade_list_set
+    __swig_getmethods__["upgrade_list"] = _ggob.GobPlayer_upgrade_list_get
+    if _newclass:upgrade_list = property(_ggob.GobPlayer_upgrade_list_get, _ggob.GobPlayer_upgrade_list_set)
+
+class GobPlayerPtr(GobPlayer):
+    def __init__(self, this):
+        _swig_setattr(self, GobPlayer, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobPlayer, 'thisown', 0)
+        _swig_setattr(self, GobPlayer,self.__class__,GobPlayer)
+_ggob.GobPlayer_swigregister(GobPlayerPtr)
+
+class GobEnemy(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobEnemy, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobEnemy, name)
+    def __repr__(self):
+        return "<C GobEnemy instance at %s>" % (self.this,)
+    __swig_setmethods__["ship"] = _ggob.GobEnemy_ship_set
+    __swig_getmethods__["ship"] = _ggob.GobEnemy_ship_get
+    if _newclass:ship = property(_ggob.GobEnemy_ship_get, _ggob.GobEnemy_ship_set)
+    __swig_setmethods__["starbucks"] = _ggob.GobEnemy_starbucks_set
+    __swig_getmethods__["starbucks"] = _ggob.GobEnemy_starbucks_get
+    if _newclass:starbucks = property(_ggob.GobEnemy_starbucks_get, _ggob.GobEnemy_starbucks_set)
+    __swig_setmethods__["buckazoids"] = _ggob.GobEnemy_buckazoids_set
+    __swig_getmethods__["buckazoids"] = _ggob.GobEnemy_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.GobEnemy_buckazoids_get, _ggob.GobEnemy_buckazoids_set)
+    def init(*args): return _ggob.GobEnemy_init(*args)
+    def died(*args): return _ggob.GobEnemy_died(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobEnemy, 'this', _ggob.new_GobEnemy(*args))
+        _swig_setattr(self, GobEnemy, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobEnemy):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobEnemyPtr(GobEnemy):
+    def __init__(self, this):
+        _swig_setattr(self, GobEnemy, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobEnemy, 'thisown', 0)
+        _swig_setattr(self, GobEnemy,self.__class__,GobEnemy)
+_ggob.GobEnemy_swigregister(GobEnemyPtr)
+
+class GobAsteroid(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobAsteroid, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobAsteroid, name)
+    def __repr__(self):
+        return "<C GobAsteroid instance at %s>" % (self.this,)
+    def handle_damage(*args): return _ggob.GobAsteroid_handle_damage(*args)
+    def death(*args): return _ggob.GobAsteroid_death(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobAsteroid, 'this', _ggob.new_GobAsteroid(*args))
+        _swig_setattr(self, GobAsteroid, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_GobAsteroid):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobAsteroidPtr(GobAsteroid):
+    def __init__(self, this):
+        _swig_setattr(self, GobAsteroid, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobAsteroid, 'thisown', 0)
+        _swig_setattr(self, GobAsteroid,self.__class__,GobAsteroid)
+_ggob.GobAsteroid_swigregister(GobAsteroidPtr)
+
+class GobGame(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobGame, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobGame, name)
+    def __repr__(self):
+        return "<C GobGame instance at %s>" % (self.this,)
+    __swig_setmethods__["_galaxy"] = _ggob.GobGame__galaxy_set
+    __swig_getmethods__["_galaxy"] = _ggob.GobGame__galaxy_get
+    if _newclass:_galaxy = property(_ggob.GobGame__galaxy_get, _ggob.GobGame__galaxy_set)
+    __swig_setmethods__["gobplayer"] = _ggob.GobGame_gobplayer_set
+    __swig_getmethods__["gobplayer"] = _ggob.GobGame_gobplayer_get
+    if _newclass:gobplayer = property(_ggob.GobGame_gobplayer_get, _ggob.GobGame_gobplayer_set)
+    def switch_system(*args): return _ggob.GobGame_switch_system(*args)
+    def __init__(self, *args):
+        _swig_setattr(self, GobGame, 'this', _ggob.new_GobGame(*args))
+        _swig_setattr(self, GobGame, 'thisown', 1)
+    __swig_getmethods__["get_this"] = lambda x: _ggob.GobGame_get_this
+    if _newclass:get_this = staticmethod(_ggob.GobGame_get_this)
+    def __del__(self, destroy=_ggob.delete_GobGame):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+    __swig_setmethods__["_player_panel"] = _ggob.GobGame__player_panel_set
+    __swig_getmethods__["_player_panel"] = _ggob.GobGame__player_panel_get
+    if _newclass:_player_panel = property(_ggob.GobGame__player_panel_get, _ggob.GobGame__player_panel_set)
+    __swig_setmethods__["_player_control"] = _ggob.GobGame__player_control_set
+    __swig_getmethods__["_player_control"] = _ggob.GobGame__player_control_get
+    if _newclass:_player_control = property(_ggob.GobGame__player_control_get, _ggob.GobGame__player_control_set)
+    __swig_setmethods__["enemy_team"] = _ggob.GobGame_enemy_team_set
+    __swig_getmethods__["enemy_team"] = _ggob.GobGame_enemy_team_get
+    if _newclass:enemy_team = property(_ggob.GobGame_enemy_team_get, _ggob.GobGame_enemy_team_set)
+    def AddPanel(*args): return _ggob.GobGame_AddPanel(*args)
+    def calculate(*args): return _ggob.GobGame_calculate(*args)
+    def setGameDone(*args): return _ggob.GobGame_setGameDone(*args)
+    def ship_died(*args): return _ggob.GobGame_ship_died(*args)
+    def preinit(*args): return _ggob.GobGame_preinit(*args)
+    def init(*args): return _ggob.GobGame_init(*args)
+    def play_sound(*args): return _ggob.GobGame_play_sound(*args)
+    def add_gobplayer(*args): return _ggob.GobGame_add_gobplayer(*args)
+    def get_player(*args): return _ggob.GobGame_get_player(*args)
+    __swig_setmethods__["gobenemies"] = _ggob.GobGame_gobenemies_set
+    __swig_getmethods__["gobenemies"] = _ggob.GobGame_gobenemies_get
+    if _newclass:gobenemies = property(_ggob.GobGame_gobenemies_get, _ggob.GobGame_gobenemies_set)
+    __swig_setmethods__["max_enemies"] = _ggob.GobGame_max_enemies_set
+    __swig_getmethods__["max_enemies"] = _ggob.GobGame_max_enemies_get
+    if _newclass:max_enemies = property(_ggob.GobGame_max_enemies_get, _ggob.GobGame_max_enemies_set)
+    __swig_setmethods__["gobenemy"] = _ggob.GobGame_gobenemy_set
+    __swig_getmethods__["gobenemy"] = _ggob.GobGame_gobenemy_get
+    if _newclass:gobenemy = property(_ggob.GobGame_gobenemy_get, _ggob.GobGame_gobenemy_set)
+    def get_enemy_index(*args): return _ggob.GobGame_get_enemy_index(*args)
+    def prepare(*args): return _ggob.GobGame_prepare(*args)
+    def fps(*args): return _ggob.GobGame_fps(*args)
+    def add_new_enemy(*args): return _ggob.GobGame_add_new_enemy(*args)
+    def add_stars(*args): return _ggob.GobGame_add_stars(*args)
+    def add_asteroid(*args): return _ggob.GobGame_add_asteroid(*args)
+    def add_system(*args): return _ggob.GobGame_add_system(*args)
+    def add_player(*args): return _ggob.GobGame_add_player(*args)
+    __swig_setmethods__["next_add_new_enemy_time"] = _ggob.GobGame_next_add_new_enemy_time_set
+    __swig_getmethods__["next_add_new_enemy_time"] = _ggob.GobGame_next_add_new_enemy_time_get
+    if _newclass:next_add_new_enemy_time = property(_ggob.GobGame_next_add_new_enemy_time_get, _ggob.GobGame_next_add_new_enemy_time_set)
+    __swig_setmethods__["defenderSprite"] = _ggob.GobGame_defenderSprite_set
+    __swig_getmethods__["defenderSprite"] = _ggob.GobGame_defenderSprite_get
+    if _newclass:defenderSprite = property(_ggob.GobGame_defenderSprite_get, _ggob.GobGame_defenderSprite_set)
+    __swig_setmethods__["num_planets"] = _ggob.GobGame_num_planets_set
+    __swig_getmethods__["num_planets"] = _ggob.GobGame_num_planets_get
+    if _newclass:num_planets = property(_ggob.GobGame_num_planets_get, _ggob.GobGame_num_planets_set)
+    __swig_setmethods__["planet"] = _ggob.GobGame_planet_set
+    __swig_getmethods__["planet"] = _ggob.GobGame_planet_get
+    if _newclass:planet = property(_ggob.GobGame_planet_get, _ggob.GobGame_planet_set)
+    __swig_setmethods__["station"] = _ggob.GobGame_station_set
+    __swig_getmethods__["station"] = _ggob.GobGame_station_get
+    if _newclass:station = property(_ggob.GobGame_station_get, _ggob.GobGame_station_set)
+    def add_planet_and_station(*args): return _ggob.GobGame_add_planet_and_station(*args)
+
+class GobGamePtr(GobGame):
+    def __init__(self, this):
+        _swig_setattr(self, GobGame, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobGame, 'thisown', 0)
+        _swig_setattr(self, GobGame,self.__class__,GobGame)
+_ggob.GobGame_swigregister(GobGamePtr)
+
+GobGame_get_this = _ggob.GobGame_get_this
+
+class GobStation(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GobStation, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GobStation, name)
+    def __repr__(self):
+        return "<C GobStation instance at %s>" % (self.this,)
+    __swig_setmethods__["_build_type"] = _ggob.GobStation__build_type_set
+    __swig_getmethods__["_build_type"] = _ggob.GobStation__build_type_get
+    if _newclass:_build_type = property(_ggob.GobStation__build_type_get, _ggob.GobStation__build_type_set)
+    __swig_setmethods__["_background_pic"] = _ggob.GobStation__background_pic_set
+    __swig_getmethods__["_background_pic"] = _ggob.GobStation__background_pic_get
+    if _newclass:_background_pic = property(_ggob.GobStation__background_pic_get, _ggob.GobStation__background_pic_set)
+    def __init__(self, *args):
+        _swig_setattr(self, GobStation, 'this', _ggob.new_GobStation(*args))
+        _swig_setattr(self, GobStation, 'thisown', 1)
+    def buy_new_ship_menu(*args): return _ggob.GobStation_buy_new_ship_menu(*args)
+    def inflict_damage(*args): return _ggob.GobStation_inflict_damage(*args)
+    def station_screen(*args): return _ggob.GobStation_station_screen(*args)
+    def upgrade_menu(*args): return _ggob.GobStation_upgrade_menu(*args)
+    def __del__(self, destroy=_ggob.delete_GobStation):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class GobStationPtr(GobStation):
+    def __init__(self, this):
+        _swig_setattr(self, GobStation, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, GobStation, 'thisown', 0)
+        _swig_setattr(self, GobStation,self.__class__,GobStation)
+_ggob.GobStation_swigregister(GobStationPtr)
+
+class Upgrade(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, Upgrade, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, Upgrade, name)
+    def __init__(self): raise RuntimeError, "No constructor defined"
+    def __repr__(self):
+        return "<C Upgrade instance at %s>" % (self.this,)
+    active = _ggob.Upgrade_active
+    inactive = _ggob.Upgrade_inactive
+    __swig_setmethods__["name"] = _ggob.Upgrade_name_set
+    __swig_getmethods__["name"] = _ggob.Upgrade_name_get
+    if _newclass:name = property(_ggob.Upgrade_name_get, _ggob.Upgrade_name_set)
+    __swig_setmethods__["starbucks"] = _ggob.Upgrade_starbucks_set
+    __swig_getmethods__["starbucks"] = _ggob.Upgrade_starbucks_get
+    if _newclass:starbucks = property(_ggob.Upgrade_starbucks_get, _ggob.Upgrade_starbucks_set)
+    __swig_setmethods__["buckazoids"] = _ggob.Upgrade_buckazoids_set
+    __swig_getmethods__["buckazoids"] = _ggob.Upgrade_buckazoids_get
+    if _newclass:buckazoids = property(_ggob.Upgrade_buckazoids_get, _ggob.Upgrade_buckazoids_set)
+    __swig_setmethods__["status"] = _ggob.Upgrade_status_set
+    __swig_getmethods__["status"] = _ggob.Upgrade_status_get
+    if _newclass:status = property(_ggob.Upgrade_status_get, _ggob.Upgrade_status_set)
+    __swig_setmethods__["num"] = _ggob.Upgrade_num_set
+    __swig_getmethods__["num"] = _ggob.Upgrade_num_get
+    if _newclass:num = property(_ggob.Upgrade_num_get, _ggob.Upgrade_num_set)
+    __swig_setmethods__["index"] = _ggob.Upgrade_index_set
+    __swig_getmethods__["index"] = _ggob.Upgrade_index_get
+    if _newclass:index = property(_ggob.Upgrade_index_get, _ggob.Upgrade_index_set)
+    def update(*args): return _ggob.Upgrade_update(*args)
+    def execute(*args): return _ggob.Upgrade_execute(*args)
+    def charge(*args): return _ggob.Upgrade_charge(*args)
+    def clear(*args): return _ggob.Upgrade_clear(*args)
+    def duplicate(*args): return _ggob.Upgrade_duplicate(*args)
+    def __del__(self, destroy=_ggob.delete_Upgrade):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class UpgradePtr(Upgrade):
+    def __init__(self, this):
+        _swig_setattr(self, Upgrade, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, Upgrade, 'thisown', 0)
+        _swig_setattr(self, Upgrade,self.__class__,Upgrade)
+_ggob.Upgrade_swigregister(UpgradePtr)
+
+class RainbowRift(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, RainbowRift, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, RainbowRift, name)
+    def __repr__(self):
+        return "<C RainbowRift instance at %s>" % (self.this,)
+    n = _ggob.RainbowRift_n
+    __swig_setmethods__["p"] = _ggob.RainbowRift_p_set
+    __swig_getmethods__["p"] = _ggob.RainbowRift_p_get
+    if _newclass:p = property(_ggob.RainbowRift_p_get, _ggob.RainbowRift_p_set)
+    __swig_setmethods__["c"] = _ggob.RainbowRift_c_set
+    __swig_getmethods__["c"] = _ggob.RainbowRift_c_get
+    if _newclass:c = property(_ggob.RainbowRift_c_get, _ggob.RainbowRift_c_set)
+    __swig_setmethods__["next_time"] = _ggob.RainbowRift_next_time_set
+    __swig_getmethods__["next_time"] = _ggob.RainbowRift_next_time_get
+    if _newclass:next_time = property(_ggob.RainbowRift_next_time_get, _ggob.RainbowRift_next_time_set)
+    __swig_setmethods__["next_time2"] = _ggob.RainbowRift_next_time2_set
+    __swig_getmethods__["next_time2"] = _ggob.RainbowRift_next_time2_get
+    if _newclass:next_time2 = property(_ggob.RainbowRift_next_time2_get, _ggob.RainbowRift_next_time2_set)
+    def __init__(self, *args):
+        _swig_setattr(self, RainbowRift, 'this', _ggob.new_RainbowRift(*args))
+        _swig_setattr(self, RainbowRift, 'thisown', 1)
+    def animate(*args): return _ggob.RainbowRift_animate(*args)
+    def calculate(*args): return _ggob.RainbowRift_calculate(*args)
+    def squiggle(*args): return _ggob.RainbowRift_squiggle(*args)
+    def __del__(self, destroy=_ggob.delete_RainbowRift):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class RainbowRiftPtr(RainbowRift):
+    def __init__(self, this):
+        _swig_setattr(self, RainbowRift, 'this', this)
+        if not hasattr(self,"thisown"): _swig_setattr(self, RainbowRift, 'thisown', 0)
+        _swig_setattr(self, RainbowRift,self.__class__,RainbowRift)
+_ggob.RainbowRift_swigregister(RainbowRiftPtr)
+
+

Added: trunk/source/generated/ggob_wrap.cpp
===================================================================
--- trunk/source/generated/ggob_wrap.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/generated/ggob_wrap.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,3875 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (http://www.swig.org).
+ * Version 1.3.21
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGPYTHON
+
+#ifdef __cplusplus
+template<class T> class SwigValueWrapper {
+    T *tt;
+public:
+    SwigValueWrapper() : tt(0) { }
+    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
+    SwigValueWrapper(const T& t) : tt(new T(t)) { }
+    ~SwigValueWrapper() { delete tt; } 
+    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
+    operator T&() const { return *tt; }
+    T *operator&() { return tt; }
+private:
+    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
+};                                                    
+#endif
+
+
+#include "Python.h"
+
+/*************************************************************** -*- c -*-
+ * python/precommon.swg
+ *
+ * Rename all exported symbols from common.swg, to avoid symbol
+ * clashes if multiple interpreters are included
+ *
+ ************************************************************************/
+
+#define SWIG_TypeRegister    SWIG_Python_TypeRegister
+#define SWIG_TypeCheck       SWIG_Python_TypeCheck
+#define SWIG_TypeCast        SWIG_Python_TypeCast
+#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
+#define SWIG_TypeName        SWIG_Python_TypeName
+#define SWIG_TypeQuery       SWIG_Python_TypeQuery
+#define SWIG_TypeClientData  SWIG_Python_TypeClientData
+#define SWIG_PackData        SWIG_Python_PackData 
+#define SWIG_UnpackData      SWIG_Python_UnpackData 
+
+
+/***********************************************************************
+ * common.swg
+ *
+ *     This file contains generic SWIG runtime support for pointer
+ *     type checking as well as a few commonly used macros to control
+ *     external linkage.
+ *
+ * Author : David Beazley (beazley at cs.uchicago.edu)
+ *
+ * Copyright (c) 1999-2000, The University of Chicago
+ * 
+ * This file may be freely redistributed without license or fee provided
+ * this copyright message remains intact.
+ ************************************************************************/
+
+#include <string.h>
+
+#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#  if defined(_MSC_VER) || defined(__GNUC__)
+#    if defined(STATIC_LINKED)
+#      define SWIGEXPORT(a) a
+#      define SWIGIMPORT(a) extern a
+#    else
+#      define SWIGEXPORT(a) __declspec(dllexport) a
+#      define SWIGIMPORT(a) extern a
+#    endif
+#  else
+#    if defined(__BORLANDC__)
+#      define SWIGEXPORT(a) a _export
+#      define SWIGIMPORT(a) a _export
+#    else
+#      define SWIGEXPORT(a) a
+#      define SWIGIMPORT(a) a
+#    endif
+#  endif
+#else
+#  define SWIGEXPORT(a) a
+#  define SWIGIMPORT(a) a
+#endif
+
+#ifdef SWIG_GLOBAL
+#  define SWIGRUNTIME(a) SWIGEXPORT(a)
+#else
+#  define SWIGRUNTIME(a) static a
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *(*swig_converter_func)(void *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+typedef struct swig_type_info {
+  const char             *name;
+  swig_converter_func     converter;
+  const char             *str;
+  void                   *clientdata;
+  swig_dycast_func        dcast;
+  struct swig_type_info  *next;
+  struct swig_type_info  *prev;
+} swig_type_info;
+
+#ifdef SWIG_NOINCLUDE
+
+SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
+SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
+SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
+SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
+SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
+SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);
+
+#else
+
+static swig_type_info *swig_type_list = 0;
+
+/* Register a type mapping with the type-checking */
+SWIGRUNTIME(swig_type_info *)
+SWIG_TypeRegister(swig_type_info *ti) {
+  swig_type_info *tc, *head, *ret, *next;
+  /* Check to see if this type has already been registered */
+  tc = swig_type_list;
+  while (tc) {
+    if (strcmp(tc->name, ti->name) == 0) {
+      /* Already exists in the table.  Just add additional types to the list */
+      if (tc->clientdata) ti->clientdata = tc->clientdata;
+      head = tc;
+      next = tc->next;
+      goto l1;
+    }
+    tc = tc->prev;
+  }
+  head = ti;
+  next = 0;
+
+  /* Place in list */
+  ti->prev = swig_type_list;
+  swig_type_list = ti;
+
+  /* Build linked lists */
+  l1:
+  ret = head;
+  tc = ti + 1;
+  /* Patch up the rest of the links */
+  while (tc->name) {
+    head->next = tc;
+    tc->prev = head;
+    head = tc;
+    tc++;
+  }
+  if (next) next->prev = head;
+  head->next = next;
+  return ret;
+}
+
+/* Check the typename */
+SWIGRUNTIME(swig_type_info *) 
+SWIG_TypeCheck(char *c, swig_type_info *ty) {
+  swig_type_info *s;
+  if (!ty) return 0;        /* Void pointer */
+  s = ty->next;             /* First element always just a name */
+  do {
+    if (strcmp(s->name,c) == 0) {
+      if (s == ty->next) return s;
+      /* Move s to the top of the linked list */
+      s->prev->next = s->next;
+      if (s->next) {
+        s->next->prev = s->prev;
+      }
+      /* Insert s as second element in the list */
+      s->next = ty->next;
+      if (ty->next) ty->next->prev = s;
+      ty->next = s;
+      s->prev = ty;
+      return s;
+    }
+    s = s->next;
+  } while (s && (s != ty->next));
+  return 0;
+}
+
+/* Cast a pointer up an inheritance hierarchy */
+SWIGRUNTIME(void *) 
+SWIG_TypeCast(swig_type_info *ty, void *ptr) {
+  if ((!ty) || (!ty->converter)) return ptr;
+  return (*ty->converter)(ptr);
+}
+
+/* Dynamic pointer casting. Down an inheritance hierarchy */
+SWIGRUNTIME(swig_type_info *) 
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty->dcast) return ty;
+  while (ty && (ty->dcast)) {
+    ty = (*ty->dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/* Return the name associated with this type */
+SWIGRUNTIME(const char *)
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty->name;
+}
+
+/* Search for a swig_type_info structure */
+SWIGRUNTIME(swig_type_info *)
+SWIG_TypeQuery(const char *name) {
+  swig_type_info *ty = swig_type_list;
+  while (ty) {
+    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
+    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
+    ty = ty->prev;
+  }
+  return 0;
+}
+
+/* Set the clientdata field for a type */
+SWIGRUNTIME(void)
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_type_info *tc, *equiv;
+  if (ti->clientdata == clientdata) return;
+  ti->clientdata = clientdata;
+  equiv = ti->next;
+  while (equiv) {
+    if (!equiv->converter) {
+      tc = swig_type_list;
+      while (tc) {
+        if ((strcmp(tc->name, equiv->name) == 0))
+          SWIG_TypeClientData(tc,clientdata);
+        tc = tc->prev;
+      }
+    }
+    equiv = equiv->next;
+  }
+}
+
+/* Pack binary data into a string */
+SWIGRUNTIME(char *)
+SWIG_PackData(char *c, void *ptr, int sz) {
+  static char hex[17] = "0123456789abcdef";
+  int i;
+  unsigned char *u = (unsigned char *) ptr;
+  register unsigned char uu;
+  for (i = 0; i < sz; i++,u++) {
+    uu = *u;
+    *(c++) = hex[(uu & 0xf0) >> 4];
+    *(c++) = hex[uu & 0xf];
+  }
+  return c;
+}
+
+/* Unpack binary data from a string */
+SWIGRUNTIME(char *)
+SWIG_UnpackData(char *c, void *ptr, int sz) {
+  register unsigned char uu = 0;
+  register int d;
+  unsigned char *u = (unsigned char *) ptr;
+  int i;
+  for (i = 0; i < sz; i++, u++) {
+    d = *(c++);
+    if ((d >= '0') && (d <= '9'))
+      uu = ((d - '0') << 4);
+    else if ((d >= 'a') && (d <= 'f'))
+      uu = ((d - ('a'-10)) << 4);
+    d = *(c++);
+    if ((d >= '0') && (d <= '9'))
+      uu |= (d - '0');
+    else if ((d >= 'a') && (d <= 'f'))
+      uu |= (d - ('a'-10));
+    *u = uu;
+  }
+  return c;
+}
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/***********************************************************************
+ * python.swg
+ *
+ *     This file contains the runtime support for Python modules
+ *     and includes code for managing global variables and pointer
+ *     type checking.
+ *
+ * Author : David Beazley (beazley at cs.uchicago.edu)
+ ************************************************************************/
+
+#include "Python.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SWIG_PY_INT     1
+#define SWIG_PY_FLOAT   2
+#define SWIG_PY_STRING  3
+#define SWIG_PY_POINTER 4
+#define SWIG_PY_BINARY  5
+
+/* Flags for pointer conversion */
+
+#define SWIG_POINTER_EXCEPTION     0x1
+#define SWIG_POINTER_DISOWN        0x2
+
+/* Exception handling in wrappers */
+#define SWIG_fail   goto fail
+
+/* Constant information structure */
+typedef struct swig_const_info {
+    int type;
+    char *name;
+    long lvalue;
+    double dvalue;
+    void   *pvalue;
+    swig_type_info **ptype;
+} swig_const_info;
+
+/* Common SWIG API */
+#define SWIG_ConvertPtr(obj, pp, type, flags) \
+  SWIG_Python_ConvertPtr(obj, pp, type, flags)
+#define SWIG_NewPointerObj(p, type, flags) \
+  SWIG_Python_NewPointerObj(p, type, flags)
+#define SWIG_MustGetPtr(p, type, argnum, flags) \
+  SWIG_Python_MustGetPtr(p, type, argnum, flags)
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink() \
+  SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr) \
+  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
+  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
+#define SWIG_NewPackedObj(ptr, sz, type) \
+  SWIG_Python_NewPackedObj(ptr, sz, type)
+#define SWIG_InstallConstants(d, constants) \
+  SWIG_Python_InstallConstants(d, constants)
+
+#ifdef SWIG_NOINCLUDE
+
+SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
+SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
+SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
+SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
+SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);
+
+#else
+
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+static PyObject *
+swig_varlink_repr(swig_varlinkobject *v) {
+  v = v;
+  return PyString_FromString("<Global variables>");
+}
+
+static int
+swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
+  swig_globalvar  *var;
+  flags = flags;
+  fprintf(fp,"Global variables { ");
+  for (var = v->vars; var; var=var->next) {
+    fprintf(fp,"%s", var->name);
+    if (var->next) fprintf(fp,", ");
+  }
+  fprintf(fp," }\n");
+  return 0;
+}
+
+static PyObject *
+swig_varlink_getattr(swig_varlinkobject *v, char *n) {
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      return (*var->get_attr)();
+    }
+    var = var->next;
+  }
+  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
+  return NULL;
+}
+
+static int
+swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
+  swig_globalvar *var = v->vars;
+  while (var) {
+    if (strcmp(var->name,n) == 0) {
+      return (*var->set_attr)(p);
+    }
+    var = var->next;
+  }
+  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
+  return 1;
+}
+
+statichere PyTypeObject varlinktype = {
+  PyObject_HEAD_INIT(0)              
+  0,
+  (char *)"swigvarlink",              /* Type name    */
+  sizeof(swig_varlinkobject),         /* Basic size   */
+  0,                                  /* Itemsize     */
+  0,                                  /* Deallocator  */ 
+  (printfunc) swig_varlink_print,     /* Print        */
+  (getattrfunc) swig_varlink_getattr, /* get attr     */
+  (setattrfunc) swig_varlink_setattr, /* Set attr     */
+  0,                                  /* tp_compare   */
+  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
+  0,                                  /* tp_as_number */
+  0,                                  /* tp_as_mapping*/
+  0,                                  /* tp_hash      */
+};
+
+/* Create a variable linking object for use later */
+SWIGRUNTIME(PyObject *)
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = 0;
+  result = PyMem_NEW(swig_varlinkobject,1);
+  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
+  result->ob_type = &varlinktype;
+  result->vars = 0;
+  result->ob_refcnt = 0;
+  Py_XINCREF((PyObject *) result);
+  return ((PyObject*) result);
+}
+
+SWIGRUNTIME(void)
+SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v;
+  swig_globalvar *gv;
+  v= (swig_varlinkobject *) p;
+  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  gv->name = (char *) malloc(strlen(name)+1);
+  strcpy(gv->name,name);
+  gv->get_attr = get_attr;
+  gv->set_attr = set_attr;
+  gv->next = v->vars;
+  v->vars = gv;
+}
+
+/* Convert a pointer value */
+SWIGRUNTIME(int)
+SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  char  *c = 0;
+  static PyObject *SWIG_this = 0;
+  int    newref = 0;
+  PyObject  *pyobj = 0;
+
+  if (!obj) return 0;
+  if (obj == Py_None) {
+    *ptr = 0;
+    return 0;
+  }
+#ifdef SWIG_COBJECT_TYPES
+  if (!(PyCObject_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString("this");
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PyCObject_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  }  
+  *ptr = PyCObject_AsVoidPtr(obj);
+  c = (char *) PyCObject_GetDesc(obj);
+  if (newref) Py_DECREF(obj);
+  goto cobject;
+#else
+  if (!(PyString_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString("this");
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PyString_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  } 
+  c = PyString_AsString(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') {
+    *ptr = (void *) 0;
+    if (strcmp(c,"NULL") == 0) {
+      if (newref) { Py_DECREF(obj); }
+      return 0;
+    } else {
+      if (newref) { Py_DECREF(obj); }
+      goto type_error;
+    }
+  }
+  c++;
+  c = SWIG_UnpackData(c,ptr,sizeof(void *));
+  if (newref) { Py_DECREF(obj); }
+#endif
+
+#ifdef SWIG_COBJECT_TYPES
+cobject:
+#endif
+
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
+  }
+
+  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
+    PyObject *zero = PyInt_FromLong(0);
+    PyObject_SetAttrString(pyobj,(char*)"thisown",zero);
+    Py_DECREF(zero);
+  }
+  return 0;
+
+type_error:
+  if (flags & SWIG_POINTER_EXCEPTION) {
+    if (ty && c) {
+      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
+      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
+      PyErr_SetString(PyExc_TypeError, temp);
+      free((char *) temp);
+    } else {
+      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
+    }
+  }
+  return -1;
+}
+
+/* Convert a pointer value, signal an exception on a type mismatch */
+SWIGRUNTIME(void *)
+SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
+  void *result;
+  SWIG_Python_ConvertPtr(obj, &result, ty, flags | SWIG_POINTER_EXCEPTION);
+  return result;
+}
+
+/* Convert a packed value value */
+SWIGRUNTIME(int)
+SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  char  *c = 0;
+
+  if ((!obj) || (!PyString_Check(obj))) goto type_error;
+  c = PyString_AsString(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') goto type_error;
+  c++;
+  c = SWIG_UnpackData(c,ptr,sz);
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+  }
+  return 0;
+
+type_error:
+
+  if (flags) {
+    if (ty && c) {
+      char *temp = (char *) malloc(64+strlen(ty->name)+strlen(c));
+      sprintf(temp,"Type error. Got %s, expected %s", c, ty->name);
+      PyErr_SetString(PyExc_TypeError, temp);
+      free((char *) temp);
+    } else {
+      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
+    }
+  }
+  return -1;
+}
+
+/* Create a new pointer object */
+SWIGRUNTIME(PyObject *)
+SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
+  PyObject *robj;
+  if (!ptr) {
+    Py_INCREF(Py_None);
+    return Py_None;
+  }
+#ifdef SWIG_COBJECT_TYPES
+  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
+#else
+  {
+    char result[1024];
+    char *r = result;
+    *(r++) = '_';
+    r = SWIG_PackData(r,&ptr,sizeof(void *));
+    strcpy(r,type->name);
+    robj = PyString_FromString(result);
+  }
+#endif
+  if (!robj || (robj == Py_None)) return robj;
+  if (type->clientdata) {
+    PyObject *inst;
+    PyObject *args = Py_BuildValue((char*)"(O)", robj);
+    Py_DECREF(robj);
+    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
+    Py_DECREF(args);
+    if (inst) {
+      if (own) {
+        PyObject *n = PyInt_FromLong(1);
+        PyObject_SetAttrString(inst,(char*)"thisown",n);
+        Py_DECREF(n);
+      }
+      robj = inst;
+    }
+  }
+  return robj;
+}
+
+SWIGRUNTIME(PyObject *)
+SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+  char result[1024];
+  char *r = result;
+  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  strcpy(r,type->name);
+  return PyString_FromString(result);
+}
+
+/* Install Constants */
+SWIGRUNTIME(void)
+SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
+  int i;
+  PyObject *obj;
+  for (i = 0; constants[i].type; i++) {
+    switch(constants[i].type) {
+    case SWIG_PY_INT:
+      obj = PyInt_FromLong(constants[i].lvalue);
+      break;
+    case SWIG_PY_FLOAT:
+      obj = PyFloat_FromDouble(constants[i].dvalue);
+      break;
+    case SWIG_PY_STRING:
+      obj = PyString_FromString((char *) constants[i].pvalue);
+      break;
+    case SWIG_PY_POINTER:
+      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+      break;
+    case SWIG_PY_BINARY:
+      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+      break;
+    default:
+      obj = 0;
+      break;
+    }
+    if (obj) {
+      PyDict_SetItemString(d,constants[i].name,obj);
+      Py_DECREF(obj);
+    }
+  }
+}
+
+#endif
+
+/* Contract support */
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define  SWIGTYPE_p_GobPlayer swig_types[0] 
+#define  SWIGTYPE_p_p_Upgrade swig_types[1] 
+#define  SWIGTYPE_p_SpaceLocation swig_types[2] 
+#define  SWIGTYPE_p_p_GobStation swig_types[3] 
+#define  SWIGTYPE_p_GobStation swig_types[4] 
+#define  SWIGTYPE_p_Upgrade swig_types[5] 
+#define  SWIGTYPE_p_RGB swig_types[6] 
+#define  SWIGTYPE_p_Log swig_types[7] 
+#define  SWIGTYPE_p_StarMap swig_types[8] 
+#define  SWIGTYPE_p_float swig_types[9] 
+#define  SWIGTYPE_p_GobAsteroid swig_types[10] 
+#define  SWIGTYPE_p_TeamCode swig_types[11] 
+#define  SWIGTYPE_p_GobEnemy swig_types[12] 
+#define  SWIGTYPE_p_p_GobEnemy swig_types[13] 
+#define  SWIGTYPE_p_p_Planet swig_types[14] 
+#define  SWIGTYPE_p_RainbowRift swig_types[15] 
+#define  SWIGTYPE_p_GobGame swig_types[16] 
+#define  SWIGTYPE_p_Vector2 swig_types[17] 
+#define  SWIGTYPE_p_std__string swig_types[18] 
+#define  SWIGTYPE_p_pair swig_types[19] 
+#define  SWIGTYPE_p_SpaceSprite swig_types[20] 
+#define  SWIGTYPE_p_Control swig_types[21] 
+#define  SWIGTYPE_p_SpaceObject swig_types[22] 
+#define  SWIGTYPE_p_Frame swig_types[23] 
+#define  SWIGTYPE_p_ShipPanel swig_types[24] 
+#define  SWIGTYPE_p_SAMPLE swig_types[25] 
+#define  SWIGTYPE_p_ShipType swig_types[26] 
+#define  SWIGTYPE_p_Ship swig_types[27] 
+static swig_type_info *swig_types[29];
+
+/* -------- TYPES TABLE (END) -------- */
+
+
+/*-----------------------------------------------
+              @(target):= _ggob.so
+  ------------------------------------------------*/
+#define SWIG_init    init_ggob
+
+#define SWIG_name    "_ggob"
+
+#include "games/ggob.h"
+
+
+#define  SWIG_MemoryError    1
+#define  SWIG_IOError        2
+#define  SWIG_RuntimeError   3
+#define  SWIG_IndexError     4
+#define  SWIG_TypeError      5
+#define  SWIG_DivisionByZero 6
+#define  SWIG_OverflowError  7
+#define  SWIG_SyntaxError    8
+#define  SWIG_ValueError     9
+#define  SWIG_SystemError   10
+#define  SWIG_UnknownError  99
+
+
+static void SWIG_exception_(int code, const char *msg) {
+  switch(code) {
+  case SWIG_MemoryError:
+    PyErr_SetString(PyExc_MemoryError,msg);
+    break;
+  case SWIG_IOError:
+    PyErr_SetString(PyExc_IOError,msg);
+    break;
+  case SWIG_RuntimeError:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  case SWIG_IndexError:
+    PyErr_SetString(PyExc_IndexError,msg);
+    break;
+  case SWIG_TypeError:
+    PyErr_SetString(PyExc_TypeError,msg);
+    break;
+  case SWIG_DivisionByZero:
+    PyErr_SetString(PyExc_ZeroDivisionError,msg);
+    break;
+  case SWIG_OverflowError:
+    PyErr_SetString(PyExc_OverflowError,msg);
+    break;
+  case SWIG_SyntaxError:
+    PyErr_SetString(PyExc_SyntaxError,msg);
+    break;
+  case SWIG_ValueError:
+    PyErr_SetString(PyExc_ValueError,msg);
+    break;
+  case SWIG_SystemError:
+    PyErr_SetString(PyExc_SystemError,msg);
+    break;
+  default:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  }
+}
+
+#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
+
+
+#include <string>
+
+
+#include <string>
+
+PyObject* SwigInt_FromBool(bool b) {
+    return PyInt_FromLong(b ? 1L : 0L);
+}
+double SwigNumber_Check(PyObject* o) {
+    return PyFloat_Check(o) || PyInt_Check(o) || PyLong_Check(o);
+}
+double SwigNumber_AsDouble(PyObject* o) {
+    return PyFloat_Check(o) ? PyFloat_AsDouble(o) 
+        : (PyInt_Check(o) ?   double(PyInt_AsLong(o))
+                            : double(PyLong_AsLong(o)));
+}
+PyObject* SwigString_FromString(const std::string& s) {
+    return PyString_FromStringAndSize(s.data(),s.size());
+}
+std::string SwigString_AsString(PyObject* o) {
+    return std::string(PyString_AsString(o));
+}
+
+
+#include <utility>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+static PyObject *_wrap_pair_id_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    char *arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Os:pair_id_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (arg1->id) delete [] arg1->id;
+        if (arg2) {
+            arg1->id = (char *) (new char[strlen(arg2)+1]);
+            strcpy((char *) arg1->id,arg2);
+        } else {
+            arg1->id = 0;
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_id_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    char *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:pair_id_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (char *) ((arg1)->id);
+    
+    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_value_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:pair_value_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->value = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_value_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:pair_value_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->value);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)":new_pair")) goto fail;
+    result = (pair *)new pair();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_pair",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * pair_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_pair, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyObject *_wrap_new_GobPlayer(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)":new_GobPlayer")) goto fail;
+    result = (GobPlayer *)new GobPlayer();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobPlayer(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_GobPlayer",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_ship_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobPlayer_ship_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)->ship = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_ship_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Ship *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_ship_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Ship *) ((arg1)->ship);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_pair_list_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    pair *arg2 = (pair *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobPlayer_pair_list_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)->pair_list = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_pair_list_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    pair *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_pair_list_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (pair *) ((arg1)->pair_list);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_num_pairs_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobPlayer_num_pairs_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->num_pairs = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_num_pairs_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_num_pairs_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->num_pairs);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer__add_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Osi:GobPlayer__add_pair",&obj0,&arg2,&arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->_add_pair((char const *)arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer__get_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    pair *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Os:GobPlayer__get_pair",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (pair *)(arg1)->_get_pair((char const *)arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_write_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Osi:GobPlayer_write_pair",&obj0,&arg2,&arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->write_pair((char const *)arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_read_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Os:GobPlayer_read_pair",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)->read_pair((char const *)arg2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_total_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobPlayer_total_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->total = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_total_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_total_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->total);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobPlayer_starbucks_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_starbucks_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobPlayer_buckazoids_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_buckazoids_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_kills_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobPlayer_kills_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->kills = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_kills_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_kills_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->kills);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobPlayer_value_starbucks_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->value_starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_value_starbucks_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->value_starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobPlayer_value_buckazoids_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->value_buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_value_buckazoids_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->value_buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_team_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobPlayer_team_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)->team = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_team_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_team_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)->team);
+    
+    {
+        TeamCode * resultptr;
+        resultptr = new TeamCode((TeamCode &) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobPlayer_init",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    (arg1)->init(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobPlayer_died",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->died(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_new_ship(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    ShipType *arg2 = (ShipType *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobPlayer_new_ship",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ShipType,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->new_ship(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_charge(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    int arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Osii:GobPlayer_charge",&obj0,&arg2,&arg3,&arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)->charge(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_upgrade_list_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Upgrade **arg2 = (Upgrade **) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobPlayer_upgrade_list_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->upgrade_list = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_upgrade_list_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Upgrade **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobPlayer_upgrade_list_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Upgrade **) ((arg1)->upgrade_list);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Upgrade, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobPlayer_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobPlayer, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyObject *_wrap_GobEnemy_ship_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobEnemy_ship_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)->ship = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_ship_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobEnemy_ship_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Ship *) ((arg1)->ship);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobEnemy_starbucks_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobEnemy_starbucks_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobEnemy_buckazoids_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobEnemy_buckazoids_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOii:GobEnemy_init",&obj0,&obj1,&arg3,&arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->init(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobEnemy_died",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->died(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobEnemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)":new_GobEnemy")) goto fail;
+    result = (GobEnemy *)new GobEnemy();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobEnemy, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobEnemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_GobEnemy",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobEnemy_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobEnemy, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyObject *_wrap_GobAsteroid_handle_damage(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOdd:GobAsteroid_handle_damage",&obj0,&obj1,&arg3,&arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)->handle_damage(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobAsteroid_death(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobAsteroid_death",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->death();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobAsteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)":new_GobAsteroid")) goto fail;
+    result = (GobAsteroid *)new GobAsteroid();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobAsteroid, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobAsteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_GobAsteroid",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobAsteroid_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobAsteroid, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyObject *_wrap_GobGame__galaxy_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    StarMap arg2 ;
+    StarMap *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame__galaxy_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_StarMap,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)->_galaxy = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__galaxy_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    StarMap result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame__galaxy_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)->_galaxy);
+    
+    {
+        StarMap * resultptr;
+        resultptr = new StarMap((StarMap &) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_StarMap, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobplayer_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_gobplayer_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->gobplayer = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobplayer_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobPlayer *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_gobplayer_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobPlayer *)& ((arg1)->gobplayer);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_switch_system(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string *arg2 = 0 ;
+    std::string temp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_switch_system",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, "string expected");
+        }
+    }
+    (arg1)->switch_system((std::string const &)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer__SWIG_0(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string *arg2 = 0 ;
+    Vector2 arg3 ;
+    std::string temp2 ;
+    Vector2 *argp3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOO:GobGame_add_gobplayer",&obj0,&obj1,&obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, "string expected");
+        }
+    }
+    if ((SWIG_ConvertPtr(obj2,(void **) &argp3, SWIGTYPE_p_Vector2,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg3 = *argp3; 
+    (arg1)->add_gobplayer((std::string const &)*arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobGame(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)":new_GobGame")) goto fail;
+    result = (GobGame *)new GobGame();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_this(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)":GobGame_get_this")) goto fail;
+    result = (GobGame *)GobGame::get_this();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobGame(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_GobGame",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_panel_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    ShipPanel *arg2 = (ShipPanel *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame__player_panel_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ShipPanel,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)->_player_panel = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_panel_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    ShipPanel *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame__player_panel_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (ShipPanel *) ((arg1)->_player_panel);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ShipPanel, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_control_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *arg2 = (Control *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame__player_control_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)->_player_control = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_control_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame__player_control_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Control *) ((arg1)->_player_control);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Control, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_enemy_team_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_enemy_team_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)->enemy_team = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_enemy_team_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    TeamCode result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_enemy_team_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)->enemy_team);
+    
+    {
+        TeamCode * resultptr;
+        resultptr = new TeamCode((TeamCode &) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_AddPanel(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_AddPanel",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->AddPanel();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_calculate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_calculate",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->calculate();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_setGameDone(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobGame_setGameDone",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->setGameDone(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_ship_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOO:GobGame_ship_died",&obj0,&obj1,&obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->ship_died(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_preinit(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_preinit",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->preinit();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Log *arg2 = (Log *) 0 ;
+    std::string *arg3 = 0 ;
+    std::string temp3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOO:GobGame_init",&obj0,&obj1,&obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Log,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2)) {
+            temp3 = std::string(PyString_AsString(obj2),
+            PyString_Size(obj2));
+            arg3 = &temp3;
+        } else {
+            SWIG_exception(SWIG_TypeError, "string expected");
+        }
+    }
+    (arg1)->init(arg2,(std::string const &)*arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_play_sound(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SAMPLE *arg2 = (SAMPLE *) 0 ;
+    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
+    int arg4 = (int) 256 ;
+    int arg5 = (int) 1000 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOO|ii:GobGame_play_sound",&obj0,&obj1,&obj2,&arg4,&arg5)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SAMPLE,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->play_sound(arg2,arg3,arg4,arg5);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer__SWIG_1(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *arg2 = (Control *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_add_gobplayer",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->add_gobplayer(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[4];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii < argc) && (ii < 3); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GobGame, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            {
+                void *ptr;
+                if (SWIG_ConvertPtr(argv[1], (void **) &ptr, SWIGTYPE_p_Control, 0) == -1) {
+                    _v = 0;
+                    PyErr_Clear();
+                } else {
+                    _v = 1;
+                }
+            }
+            if (_v) {
+                return _wrap_GobGame_add_gobplayer__SWIG_1(self,args);
+            }
+        }
+    }
+    if (argc == 3) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], (void **) &ptr, SWIGTYPE_p_GobGame, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            {
+                _v = PyString_Check(argv[1]) ? 1 : 0;
+            }
+            if (_v) {
+                {
+                    void *ptr;
+                    if (SWIG_ConvertPtr(argv[2], (void **) &ptr, SWIGTYPE_p_Vector2, 0) == -1) {
+                        _v = 0;
+                        PyErr_Clear();
+                    } else {
+                        _v = 1;
+                    }
+                }
+                if (_v) {
+                    return _wrap_GobGame_add_gobplayer__SWIG_0(self,args);
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_TypeError,"No matching function for overloaded 'GobGame_add_gobplayer'");
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_player(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    GobPlayer *result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_get_player",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobPlayer *)(arg1)->get_player(arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemies_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobGame_gobenemies_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->gobenemies = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemies_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_gobenemies_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->gobenemies);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_max_enemies_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobGame_max_enemies_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->max_enemies = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_max_enemies_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_max_enemies_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->max_enemies);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemy_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobEnemy **arg2 = (GobEnemy **) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_gobenemy_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->gobenemy = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemy_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobEnemy **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_gobenemy_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobEnemy **) ((arg1)->gobenemy);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobEnemy, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_enemy_index(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_get_enemy_index",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)->get_enemy_index(arg2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_prepare(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_prepare",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->prepare();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_fps(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_fps",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->fps();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_new_enemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_add_new_enemy",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->add_new_enemy();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_stars(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_add_stars",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->add_stars();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_asteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_add_asteroid",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->add_asteroid();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_system(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string arg2 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOii:GobGame_add_system",&obj0,&obj1,&arg3,&arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1))
+        arg2 = std::string(PyString_AsString(obj1),
+        PyString_Size(obj1));
+        else
+        SWIG_exception(SWIG_TypeError, "string expected");
+    }
+    (arg1)->add_system(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_player(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string arg2 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOii:GobGame_add_player",&obj0,&obj1,&arg3,&arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1))
+        arg2 = std::string(PyString_AsString(obj1),
+        PyString_Size(obj1));
+        else
+        SWIG_exception(SWIG_TypeError, "string expected");
+    }
+    (arg1)->add_player(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_next_add_new_enemy_time_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobGame_next_add_new_enemy_time_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->next_add_new_enemy_time = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_next_add_new_enemy_time_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_next_add_new_enemy_time_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->next_add_new_enemy_time);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_defenderSprite_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceSprite *arg2 = (SpaceSprite *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_defenderSprite_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)->defenderSprite = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_defenderSprite_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceSprite *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_defenderSprite_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (SpaceSprite *) ((arg1)->defenderSprite);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SpaceSprite, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_num_planets_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:GobGame_num_planets_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->num_planets = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_num_planets_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_num_planets_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->num_planets);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_planet_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Planet **arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_planet_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_p_Planet,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        Planet * *b = (Planet * *) arg1->planet;
+        for (ii = 0; ii < 16; ii++) b[ii] = *((Planet * *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_planet_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Planet **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_planet_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Planet **)(Planet **) ((arg1)->planet);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Planet, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_station_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobStation **arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobGame_station_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        GobStation * *b = (GobStation * *) arg1->station;
+        for (ii = 0; ii < 16; ii++) b[ii] = *((GobStation * *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_station_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobStation **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobGame_station_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobStation **)(GobStation **) ((arg1)->station);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobStation, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_planet_and_station(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    std::string arg3 ;
+    std::string arg4 ;
+    std::string arg5 ;
+    std::string arg6 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    PyObject * obj5 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OiOOOO:GobGame_add_planet_and_station",&obj0,&arg2,&obj2,&obj3,&obj4,&obj5)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2))
+        arg3 = std::string(PyString_AsString(obj2),
+        PyString_Size(obj2));
+        else
+        SWIG_exception(SWIG_TypeError, "string expected");
+    }
+    {
+        if (PyString_Check(obj3))
+        arg4 = std::string(PyString_AsString(obj3),
+        PyString_Size(obj3));
+        else
+        SWIG_exception(SWIG_TypeError, "string expected");
+    }
+    {
+        if (PyString_Check(obj4))
+        arg5 = std::string(PyString_AsString(obj4),
+        PyString_Size(obj4));
+        else
+        SWIG_exception(SWIG_TypeError, "string expected");
+    }
+    {
+        if (PyString_Check(obj5))
+        arg6 = std::string(PyString_AsString(obj5),
+        PyString_Size(obj5));
+        else
+        SWIG_exception(SWIG_TypeError, "string expected");
+    }
+    (arg1)->add_planet_and_station(arg2,arg3,arg4,arg5,arg6);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobGame_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobGame, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyObject *_wrap_GobStation__build_type_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *arg2 = (std::string *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobStation__build_type_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->_build_type = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__build_type_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobStation__build_type_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::string *)& ((arg1)->_build_type);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__background_pic_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *arg2 = (std::string *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobStation__background_pic_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->_background_pic = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__background_pic_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:GobStation__background_pic_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::string *)& ((arg1)->_background_pic);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobStation(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SpaceSprite *arg1 = (SpaceSprite *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    std::string *arg3 = 0 ;
+    std::string *arg4 = 0 ;
+    GobStation *result;
+    std::string temp3 ;
+    std::string temp4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOOO:new_GobStation",&obj0,&obj1,&obj2,&obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2)) {
+            temp3 = std::string(PyString_AsString(obj2),
+            PyString_Size(obj2));
+            arg3 = &temp3;
+        } else {
+            SWIG_exception(SWIG_TypeError, "string expected");
+        }
+    }
+    {
+        if (PyString_Check(obj3)) {
+            temp4 = std::string(PyString_AsString(obj3),
+            PyString_Size(obj3));
+            arg4 = &temp4;
+        } else {
+            SWIG_exception(SWIG_TypeError, "string expected");
+        }
+    }
+    result = (GobStation *)new GobStation(arg1,arg2,(std::string const &)*arg3,(std::string const &)*arg4);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobStation, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_buy_new_ship_menu(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobStation_buy_new_ship_menu",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->buy_new_ship_menu(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_inflict_damage(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    SpaceObject *arg2 = (SpaceObject *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobStation_inflict_damage",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_SpaceObject,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->inflict_damage(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_station_screen(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:GobStation_station_screen",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->station_screen(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_upgrade_menu(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobStation *arg2 = (GobStation *) 0 ;
+    GobPlayer *arg3 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOO:GobStation_upgrade_menu",&obj0,&obj1,&obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->upgrade_menu(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobStation(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_GobStation",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobStation_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobStation, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyObject *_wrap_Upgrade_name_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    char *arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Os:Upgrade_name_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (arg1->name) delete [] arg1->name;
+        if (arg2) {
+            arg1->name = (char *) (new char[strlen(arg2)+1]);
+            strcpy((char *) arg1->name,arg2);
+        } else {
+            arg1->name = 0;
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_name_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    char *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:Upgrade_name_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (char *) ((arg1)->name);
+    
+    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:Upgrade_starbucks_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:Upgrade_starbucks_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:Upgrade_buckazoids_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:Upgrade_buckazoids_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_status_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:Upgrade_status_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->status = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_status_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:Upgrade_status_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->status);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_num_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:Upgrade_num_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->num = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_num_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:Upgrade_num_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->num);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_index_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:Upgrade_index_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->index = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_index_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:Upgrade_index_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->index);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_update(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    GobStation *arg3 = (GobStation *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    bool result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOOO:Upgrade_update",&obj0,&obj1,&obj2,&obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (bool)(arg1)->update(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_execute(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    GobStation *arg3 = (GobStation *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOOO:Upgrade_execute",&obj0,&obj1,&obj2,&obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->execute(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_charge(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:Upgrade_charge",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->charge(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_clear(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    Ship *arg3 = (Ship *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OOOO:Upgrade_clear",&obj0,&obj1,&obj2,&obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->clear(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_duplicate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Upgrade *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:Upgrade_duplicate",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Upgrade *)(arg1)->duplicate();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Upgrade, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_Upgrade(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_Upgrade",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * Upgrade_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_Upgrade, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyObject *_wrap_RainbowRift_p_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    float *arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:RainbowRift_p_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_float,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        float *b = (float *) arg1->p;
+        for (ii = 0; ii < RainbowRift::n*6+2; ii++) b[ii] = *((float *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_p_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    float *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:RainbowRift_p_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (float *)(float *) ((arg1)->p);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_c_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    RGB *arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:RainbowRift_c_set",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_RGB,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        RGB *b = (RGB *) arg1->c;
+        for (ii = 0; ii < RainbowRift::n; ii++) b[ii] = *((RGB *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_c_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    RGB *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:RainbowRift_c_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (RGB *)(RGB *) ((arg1)->c);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RGB, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:RainbowRift_next_time_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->next_time = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:RainbowRift_next_time_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->next_time);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time2_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"Oi:RainbowRift_next_time2_set",&obj0,&arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)->next_time2 = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time2_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:RainbowRift_next_time2_get",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)->next_time2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_RainbowRift(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)":new_RainbowRift")) goto fail;
+    result = (RainbowRift *)new RainbowRift();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RainbowRift, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_animate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    Frame *arg2 = (Frame *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"OO:RainbowRift_animate",&obj0,&obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_Frame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->animate(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_calculate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:RainbowRift_calculate",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->calculate();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_squiggle(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:RainbowRift_squiggle",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)->squiggle();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_RainbowRift(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)"O:delete_RainbowRift",&obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * RainbowRift_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_RainbowRift, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)"");
+}
+static PyMethodDef SwigMethods[] = {
+	 { (char *)"pair_id_set", _wrap_pair_id_set, METH_VARARGS },
+	 { (char *)"pair_id_get", _wrap_pair_id_get, METH_VARARGS },
+	 { (char *)"pair_value_set", _wrap_pair_value_set, METH_VARARGS },
+	 { (char *)"pair_value_get", _wrap_pair_value_get, METH_VARARGS },
+	 { (char *)"new_pair", _wrap_new_pair, METH_VARARGS },
+	 { (char *)"delete_pair", _wrap_delete_pair, METH_VARARGS },
+	 { (char *)"pair_swigregister", pair_swigregister, METH_VARARGS },
+	 { (char *)"new_GobPlayer", _wrap_new_GobPlayer, METH_VARARGS },
+	 { (char *)"delete_GobPlayer", _wrap_delete_GobPlayer, METH_VARARGS },
+	 { (char *)"GobPlayer_ship_set", _wrap_GobPlayer_ship_set, METH_VARARGS },
+	 { (char *)"GobPlayer_ship_get", _wrap_GobPlayer_ship_get, METH_VARARGS },
+	 { (char *)"GobPlayer_pair_list_set", _wrap_GobPlayer_pair_list_set, METH_VARARGS },
+	 { (char *)"GobPlayer_pair_list_get", _wrap_GobPlayer_pair_list_get, METH_VARARGS },
+	 { (char *)"GobPlayer_num_pairs_set", _wrap_GobPlayer_num_pairs_set, METH_VARARGS },
+	 { (char *)"GobPlayer_num_pairs_get", _wrap_GobPlayer_num_pairs_get, METH_VARARGS },
+	 { (char *)"GobPlayer__add_pair", _wrap_GobPlayer__add_pair, METH_VARARGS },
+	 { (char *)"GobPlayer__get_pair", _wrap_GobPlayer__get_pair, METH_VARARGS },
+	 { (char *)"GobPlayer_write_pair", _wrap_GobPlayer_write_pair, METH_VARARGS },
+	 { (char *)"GobPlayer_read_pair", _wrap_GobPlayer_read_pair, METH_VARARGS },
+	 { (char *)"GobPlayer_total_set", _wrap_GobPlayer_total_set, METH_VARARGS },
+	 { (char *)"GobPlayer_total_get", _wrap_GobPlayer_total_get, METH_VARARGS },
+	 { (char *)"GobPlayer_starbucks_set", _wrap_GobPlayer_starbucks_set, METH_VARARGS },
+	 { (char *)"GobPlayer_starbucks_get", _wrap_GobPlayer_starbucks_get, METH_VARARGS },
+	 { (char *)"GobPlayer_buckazoids_set", _wrap_GobPlayer_buckazoids_set, METH_VARARGS },
+	 { (char *)"GobPlayer_buckazoids_get", _wrap_GobPlayer_buckazoids_get, METH_VARARGS },
+	 { (char *)"GobPlayer_kills_set", _wrap_GobPlayer_kills_set, METH_VARARGS },
+	 { (char *)"GobPlayer_kills_get", _wrap_GobPlayer_kills_get, METH_VARARGS },
+	 { (char *)"GobPlayer_value_starbucks_set", _wrap_GobPlayer_value_starbucks_set, METH_VARARGS },
+	 { (char *)"GobPlayer_value_starbucks_get", _wrap_GobPlayer_value_starbucks_get, METH_VARARGS },
+	 { (char *)"GobPlayer_value_buckazoids_set", _wrap_GobPlayer_value_buckazoids_set, METH_VARARGS },
+	 { (char *)"GobPlayer_value_buckazoids_get", _wrap_GobPlayer_value_buckazoids_get, METH_VARARGS },
+	 { (char *)"GobPlayer_team_set", _wrap_GobPlayer_team_set, METH_VARARGS },
+	 { (char *)"GobPlayer_team_get", _wrap_GobPlayer_team_get, METH_VARARGS },
+	 { (char *)"GobPlayer_init", _wrap_GobPlayer_init, METH_VARARGS },
+	 { (char *)"GobPlayer_died", _wrap_GobPlayer_died, METH_VARARGS },
+	 { (char *)"GobPlayer_new_ship", _wrap_GobPlayer_new_ship, METH_VARARGS },
+	 { (char *)"GobPlayer_charge", _wrap_GobPlayer_charge, METH_VARARGS },
+	 { (char *)"GobPlayer_upgrade_list_set", _wrap_GobPlayer_upgrade_list_set, METH_VARARGS },
+	 { (char *)"GobPlayer_upgrade_list_get", _wrap_GobPlayer_upgrade_list_get, METH_VARARGS },
+	 { (char *)"GobPlayer_swigregister", GobPlayer_swigregister, METH_VARARGS },
+	 { (char *)"GobEnemy_ship_set", _wrap_GobEnemy_ship_set, METH_VARARGS },
+	 { (char *)"GobEnemy_ship_get", _wrap_GobEnemy_ship_get, METH_VARARGS },
+	 { (char *)"GobEnemy_starbucks_set", _wrap_GobEnemy_starbucks_set, METH_VARARGS },
+	 { (char *)"GobEnemy_starbucks_get", _wrap_GobEnemy_starbucks_get, METH_VARARGS },
+	 { (char *)"GobEnemy_buckazoids_set", _wrap_GobEnemy_buckazoids_set, METH_VARARGS },
+	 { (char *)"GobEnemy_buckazoids_get", _wrap_GobEnemy_buckazoids_get, METH_VARARGS },
+	 { (char *)"GobEnemy_init", _wrap_GobEnemy_init, METH_VARARGS },
+	 { (char *)"GobEnemy_died", _wrap_GobEnemy_died, METH_VARARGS },
+	 { (char *)"new_GobEnemy", _wrap_new_GobEnemy, METH_VARARGS },
+	 { (char *)"delete_GobEnemy", _wrap_delete_GobEnemy, METH_VARARGS },
+	 { (char *)"GobEnemy_swigregister", GobEnemy_swigregister, METH_VARARGS },
+	 { (char *)"GobAsteroid_handle_damage", _wrap_GobAsteroid_handle_damage, METH_VARARGS },
+	 { (char *)"GobAsteroid_death", _wrap_GobAsteroid_death, METH_VARARGS },
+	 { (char *)"new_GobAsteroid", _wrap_new_GobAsteroid, METH_VARARGS },
+	 { (char *)"delete_GobAsteroid", _wrap_delete_GobAsteroid, METH_VARARGS },
+	 { (char *)"GobAsteroid_swigregister", GobAsteroid_swigregister, METH_VARARGS },
+	 { (char *)"GobGame__galaxy_set", _wrap_GobGame__galaxy_set, METH_VARARGS },
+	 { (char *)"GobGame__galaxy_get", _wrap_GobGame__galaxy_get, METH_VARARGS },
+	 { (char *)"GobGame_gobplayer_set", _wrap_GobGame_gobplayer_set, METH_VARARGS },
+	 { (char *)"GobGame_gobplayer_get", _wrap_GobGame_gobplayer_get, METH_VARARGS },
+	 { (char *)"GobGame_switch_system", _wrap_GobGame_switch_system, METH_VARARGS },
+	 { (char *)"new_GobGame", _wrap_new_GobGame, METH_VARARGS },
+	 { (char *)"GobGame_get_this", _wrap_GobGame_get_this, METH_VARARGS },
+	 { (char *)"delete_GobGame", _wrap_delete_GobGame, METH_VARARGS },
+	 { (char *)"GobGame__player_panel_set", _wrap_GobGame__player_panel_set, METH_VARARGS },
+	 { (char *)"GobGame__player_panel_get", _wrap_GobGame__player_panel_get, METH_VARARGS },
+	 { (char *)"GobGame__player_control_set", _wrap_GobGame__player_control_set, METH_VARARGS },
+	 { (char *)"GobGame__player_control_get", _wrap_GobGame__player_control_get, METH_VARARGS },
+	 { (char *)"GobGame_enemy_team_set", _wrap_GobGame_enemy_team_set, METH_VARARGS },
+	 { (char *)"GobGame_enemy_team_get", _wrap_GobGame_enemy_team_get, METH_VARARGS },
+	 { (char *)"GobGame_AddPanel", _wrap_GobGame_AddPanel, METH_VARARGS },
+	 { (char *)"GobGame_calculate", _wrap_GobGame_calculate, METH_VARARGS },
+	 { (char *)"GobGame_setGameDone", _wrap_GobGame_setGameDone, METH_VARARGS },
+	 { (char *)"GobGame_ship_died", _wrap_GobGame_ship_died, METH_VARARGS },
+	 { (char *)"GobGame_preinit", _wrap_GobGame_preinit, METH_VARARGS },
+	 { (char *)"GobGame_init", _wrap_GobGame_init, METH_VARARGS },
+	 { (char *)"GobGame_play_sound", _wrap_GobGame_play_sound, METH_VARARGS },
+	 { (char *)"GobGame_add_gobplayer", _wrap_GobGame_add_gobplayer, METH_VARARGS },
+	 { (char *)"GobGame_get_player", _wrap_GobGame_get_player, METH_VARARGS },
+	 { (char *)"GobGame_gobenemies_set", _wrap_GobGame_gobenemies_set, METH_VARARGS },
+	 { (char *)"GobGame_gobenemies_get", _wrap_GobGame_gobenemies_get, METH_VARARGS },
+	 { (char *)"GobGame_max_enemies_set", _wrap_GobGame_max_enemies_set, METH_VARARGS },
+	 { (char *)"GobGame_max_enemies_get", _wrap_GobGame_max_enemies_get, METH_VARARGS },
+	 { (char *)"GobGame_gobenemy_set", _wrap_GobGame_gobenemy_set, METH_VARARGS },
+	 { (char *)"GobGame_gobenemy_get", _wrap_GobGame_gobenemy_get, METH_VARARGS },
+	 { (char *)"GobGame_get_enemy_index", _wrap_GobGame_get_enemy_index, METH_VARARGS },
+	 { (char *)"GobGame_prepare", _wrap_GobGame_prepare, METH_VARARGS },
+	 { (char *)"GobGame_fps", _wrap_GobGame_fps, METH_VARARGS },
+	 { (char *)"GobGame_add_new_enemy", _wrap_GobGame_add_new_enemy, METH_VARARGS },
+	 { (char *)"GobGame_add_stars", _wrap_GobGame_add_stars, METH_VARARGS },
+	 { (char *)"GobGame_add_asteroid", _wrap_GobGame_add_asteroid, METH_VARARGS },
+	 { (char *)"GobGame_add_system", _wrap_GobGame_add_system, METH_VARARGS },
+	 { (char *)"GobGame_add_player", _wrap_GobGame_add_player, METH_VARARGS },
+	 { (char *)"GobGame_next_add_new_enemy_time_set", _wrap_GobGame_next_add_new_enemy_time_set, METH_VARARGS },
+	 { (char *)"GobGame_next_add_new_enemy_time_get", _wrap_GobGame_next_add_new_enemy_time_get, METH_VARARGS },
+	 { (char *)"GobGame_defenderSprite_set", _wrap_GobGame_defenderSprite_set, METH_VARARGS },
+	 { (char *)"GobGame_defenderSprite_get", _wrap_GobGame_defenderSprite_get, METH_VARARGS },
+	 { (char *)"GobGame_num_planets_set", _wrap_GobGame_num_planets_set, METH_VARARGS },
+	 { (char *)"GobGame_num_planets_get", _wrap_GobGame_num_planets_get, METH_VARARGS },
+	 { (char *)"GobGame_planet_set", _wrap_GobGame_planet_set, METH_VARARGS },
+	 { (char *)"GobGame_planet_get", _wrap_GobGame_planet_get, METH_VARARGS },
+	 { (char *)"GobGame_station_set", _wrap_GobGame_station_set, METH_VARARGS },
+	 { (char *)"GobGame_station_get", _wrap_GobGame_station_get, METH_VARARGS },
+	 { (char *)"GobGame_add_planet_and_station", _wrap_GobGame_add_planet_and_station, METH_VARARGS },
+	 { (char *)"GobGame_swigregister", GobGame_swigregister, METH_VARARGS },
+	 { (char *)"GobStation__build_type_set", _wrap_GobStation__build_type_set, METH_VARARGS },
+	 { (char *)"GobStation__build_type_get", _wrap_GobStation__build_type_get, METH_VARARGS },
+	 { (char *)"GobStation__background_pic_set", _wrap_GobStation__background_pic_set, METH_VARARGS },
+	 { (char *)"GobStation__background_pic_get", _wrap_GobStation__background_pic_get, METH_VARARGS },
+	 { (char *)"new_GobStation", _wrap_new_GobStation, METH_VARARGS },
+	 { (char *)"GobStation_buy_new_ship_menu", _wrap_GobStation_buy_new_ship_menu, METH_VARARGS },
+	 { (char *)"GobStation_inflict_damage", _wrap_GobStation_inflict_damage, METH_VARARGS },
+	 { (char *)"GobStation_station_screen", _wrap_GobStation_station_screen, METH_VARARGS },
+	 { (char *)"GobStation_upgrade_menu", _wrap_GobStation_upgrade_menu, METH_VARARGS },
+	 { (char *)"delete_GobStation", _wrap_delete_GobStation, METH_VARARGS },
+	 { (char *)"GobStation_swigregister", GobStation_swigregister, METH_VARARGS },
+	 { (char *)"Upgrade_name_set", _wrap_Upgrade_name_set, METH_VARARGS },
+	 { (char *)"Upgrade_name_get", _wrap_Upgrade_name_get, METH_VARARGS },
+	 { (char *)"Upgrade_starbucks_set", _wrap_Upgrade_starbucks_set, METH_VARARGS },
+	 { (char *)"Upgrade_starbucks_get", _wrap_Upgrade_starbucks_get, METH_VARARGS },
+	 { (char *)"Upgrade_buckazoids_set", _wrap_Upgrade_buckazoids_set, METH_VARARGS },
+	 { (char *)"Upgrade_buckazoids_get", _wrap_Upgrade_buckazoids_get, METH_VARARGS },
+	 { (char *)"Upgrade_status_set", _wrap_Upgrade_status_set, METH_VARARGS },
+	 { (char *)"Upgrade_status_get", _wrap_Upgrade_status_get, METH_VARARGS },
+	 { (char *)"Upgrade_num_set", _wrap_Upgrade_num_set, METH_VARARGS },
+	 { (char *)"Upgrade_num_get", _wrap_Upgrade_num_get, METH_VARARGS },
+	 { (char *)"Upgrade_index_set", _wrap_Upgrade_index_set, METH_VARARGS },
+	 { (char *)"Upgrade_index_get", _wrap_Upgrade_index_get, METH_VARARGS },
+	 { (char *)"Upgrade_update", _wrap_Upgrade_update, METH_VARARGS },
+	 { (char *)"Upgrade_execute", _wrap_Upgrade_execute, METH_VARARGS },
+	 { (char *)"Upgrade_charge", _wrap_Upgrade_charge, METH_VARARGS },
+	 { (char *)"Upgrade_clear", _wrap_Upgrade_clear, METH_VARARGS },
+	 { (char *)"Upgrade_duplicate", _wrap_Upgrade_duplicate, METH_VARARGS },
+	 { (char *)"delete_Upgrade", _wrap_delete_Upgrade, METH_VARARGS },
+	 { (char *)"Upgrade_swigregister", Upgrade_swigregister, METH_VARARGS },
+	 { (char *)"RainbowRift_p_set", _wrap_RainbowRift_p_set, METH_VARARGS },
+	 { (char *)"RainbowRift_p_get", _wrap_RainbowRift_p_get, METH_VARARGS },
+	 { (char *)"RainbowRift_c_set", _wrap_RainbowRift_c_set, METH_VARARGS },
+	 { (char *)"RainbowRift_c_get", _wrap_RainbowRift_c_get, METH_VARARGS },
+	 { (char *)"RainbowRift_next_time_set", _wrap_RainbowRift_next_time_set, METH_VARARGS },
+	 { (char *)"RainbowRift_next_time_get", _wrap_RainbowRift_next_time_get, METH_VARARGS },
+	 { (char *)"RainbowRift_next_time2_set", _wrap_RainbowRift_next_time2_set, METH_VARARGS },
+	 { (char *)"RainbowRift_next_time2_get", _wrap_RainbowRift_next_time2_get, METH_VARARGS },
+	 { (char *)"new_RainbowRift", _wrap_new_RainbowRift, METH_VARARGS },
+	 { (char *)"RainbowRift_animate", _wrap_RainbowRift_animate, METH_VARARGS },
+	 { (char *)"RainbowRift_calculate", _wrap_RainbowRift_calculate, METH_VARARGS },
+	 { (char *)"RainbowRift_squiggle", _wrap_RainbowRift_squiggle, METH_VARARGS },
+	 { (char *)"delete_RainbowRift", _wrap_delete_RainbowRift, METH_VARARGS },
+	 { (char *)"RainbowRift_swigregister", RainbowRift_swigregister, METH_VARARGS },
+	 { NULL, NULL }
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static void *_p_RainbowRiftTo_p_SpaceLocation(void *x) {
+    return (void *)((SpaceLocation *)  ((RainbowRift *) x));
+}
+static swig_type_info _swigt__p_GobPlayer[] = {{"_p_GobPlayer", 0, "GobPlayer *", 0},{"_p_GobPlayer"},{0}};
+static swig_type_info _swigt__p_p_Upgrade[] = {{"_p_p_Upgrade", 0, "Upgrade **", 0},{"_p_p_Upgrade"},{0}};
+static swig_type_info _swigt__p_SpaceLocation[] = {{"_p_SpaceLocation", 0, "SpaceLocation *", 0},{"_p_SpaceLocation"},{"_p_RainbowRift", _p_RainbowRiftTo_p_SpaceLocation},{0}};
+static swig_type_info _swigt__p_p_GobStation[] = {{"_p_p_GobStation", 0, "GobStation **", 0},{"_p_p_GobStation"},{0}};
+static swig_type_info _swigt__p_GobStation[] = {{"_p_GobStation", 0, "GobStation *", 0},{"_p_GobStation"},{0}};
+static swig_type_info _swigt__p_Upgrade[] = {{"_p_Upgrade", 0, "Upgrade *", 0},{"_p_Upgrade"},{0}};
+static swig_type_info _swigt__p_RGB[] = {{"_p_RGB", 0, "RGB *", 0},{"_p_RGB"},{0}};
+static swig_type_info _swigt__p_Log[] = {{"_p_Log", 0, "Log *", 0},{"_p_Log"},{0}};
+static swig_type_info _swigt__p_StarMap[] = {{"_p_StarMap", 0, "StarMap *", 0},{"_p_StarMap"},{0}};
+static swig_type_info _swigt__p_float[] = {{"_p_float", 0, "float *", 0},{"_p_float"},{0}};
+static swig_type_info _swigt__p_GobAsteroid[] = {{"_p_GobAsteroid", 0, "GobAsteroid *", 0},{"_p_GobAsteroid"},{0}};
+static swig_type_info _swigt__p_TeamCode[] = {{"_p_TeamCode", 0, "TeamCode *", 0},{"_p_TeamCode"},{0}};
+static swig_type_info _swigt__p_GobEnemy[] = {{"_p_GobEnemy", 0, "GobEnemy *", 0},{"_p_GobEnemy"},{0}};
+static swig_type_info _swigt__p_p_GobEnemy[] = {{"_p_p_GobEnemy", 0, "GobEnemy **", 0},{"_p_p_GobEnemy"},{0}};
+static swig_type_info _swigt__p_p_Planet[] = {{"_p_p_Planet", 0, "Planet **", 0},{"_p_p_Planet"},{0}};
+static swig_type_info _swigt__p_RainbowRift[] = {{"_p_RainbowRift", 0, "RainbowRift *", 0},{"_p_RainbowRift"},{0}};
+static swig_type_info _swigt__p_GobGame[] = {{"_p_GobGame", 0, "GobGame *", 0},{"_p_GobGame"},{0}};
+static swig_type_info _swigt__p_Vector2[] = {{"_p_Vector2", 0, "Vector2 *", 0},{"_p_Vector2"},{0}};
+static swig_type_info _swigt__p_std__string[] = {{"_p_std__string", 0, "std::string *", 0},{"_p_std__string"},{0}};
+static swig_type_info _swigt__p_pair[] = {{"_p_pair", 0, "pair *", 0},{"_p_pair"},{0}};
+static swig_type_info _swigt__p_SpaceSprite[] = {{"_p_SpaceSprite", 0, "SpaceSprite *", 0},{"_p_SpaceSprite"},{0}};
+static swig_type_info _swigt__p_Control[] = {{"_p_Control", 0, "Control *", 0},{"_p_Control"},{0}};
+static swig_type_info _swigt__p_SpaceObject[] = {{"_p_SpaceObject", 0, "SpaceObject *", 0},{"_p_SpaceObject"},{0}};
+static swig_type_info _swigt__p_Frame[] = {{"_p_Frame", 0, "Frame *", 0},{"_p_Frame"},{0}};
+static swig_type_info _swigt__p_ShipPanel[] = {{"_p_ShipPanel", 0, "ShipPanel *", 0},{"_p_ShipPanel"},{0}};
+static swig_type_info _swigt__p_SAMPLE[] = {{"_p_SAMPLE", 0, "SAMPLE *", 0},{"_p_SAMPLE"},{0}};
+static swig_type_info _swigt__p_ShipType[] = {{"_p_ShipType", 0, "ShipType *", 0},{"_p_ShipType"},{0}};
+static swig_type_info _swigt__p_Ship[] = {{"_p_Ship", 0, "Ship *", 0},{"_p_Ship"},{0}};
+
+static swig_type_info *swig_types_initial[] = {
+_swigt__p_GobPlayer, 
+_swigt__p_p_Upgrade, 
+_swigt__p_SpaceLocation, 
+_swigt__p_p_GobStation, 
+_swigt__p_GobStation, 
+_swigt__p_Upgrade, 
+_swigt__p_RGB, 
+_swigt__p_Log, 
+_swigt__p_StarMap, 
+_swigt__p_float, 
+_swigt__p_GobAsteroid, 
+_swigt__p_TeamCode, 
+_swigt__p_GobEnemy, 
+_swigt__p_p_GobEnemy, 
+_swigt__p_p_Planet, 
+_swigt__p_RainbowRift, 
+_swigt__p_GobGame, 
+_swigt__p_Vector2, 
+_swigt__p_std__string, 
+_swigt__p_pair, 
+_swigt__p_SpaceSprite, 
+_swigt__p_Control, 
+_swigt__p_SpaceObject, 
+_swigt__p_Frame, 
+_swigt__p_ShipPanel, 
+_swigt__p_SAMPLE, 
+_swigt__p_ShipType, 
+_swigt__p_Ship, 
+0
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+static swig_const_info swig_const_table[] = {
+{ SWIG_PY_INT,     (char *)"Upgrade_active", (long) Upgrade::active, 0, 0, 0},
+{ SWIG_PY_INT,     (char *)"Upgrade_inactive", (long) Upgrade::inactive, 0, 0, 0},
+{ SWIG_PY_INT,     (char *)"RainbowRift_n", (long) RainbowRift::n, 0, 0, 0},
+{0}};
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __cplusplus
+extern "C"
+#endif
+SWIGEXPORT(void) SWIG_init(void) {
+    static PyObject *SWIG_globals = 0; 
+    static int       typeinit = 0;
+    PyObject *m, *d;
+    int       i;
+    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
+    m = Py_InitModule((char *) SWIG_name, SwigMethods);
+    d = PyModule_GetDict(m);
+    
+    if (!typeinit) {
+        for (i = 0; swig_types_initial[i]; i++) {
+            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
+        }
+        typeinit = 1;
+    }
+    SWIG_InstallConstants(d,swig_const_table);
+    
+}
+

Modified: trunk/source/melee/mframe.cpp
===================================================================
--- trunk/source/melee/mframe.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mframe.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -1270,6 +1270,7 @@
   else
     return false;
 }
+
 void Physics::animate (Frame *frame) {
   STACKTRACE;
   
@@ -1279,7 +1280,7 @@
 
   presence.sort(presence_cmp);
   item.sort(presence_cmp);
-  
+
   std::copy(item.begin(),item.end(),back_inserter(animate_buffer));
   animate_buffer2 = presence;
   animate_buffer.merge(animate_buffer2,presence_cmp);
@@ -1289,7 +1290,10 @@
   aa_set_background ( back );
   for(std::list<Presence*>::iterator i=animate_buffer.begin();i!=animate_buffer.end();i++)
     {
-      if ((*i)->exists()) (*i)->animate(frame);
+      if ((*i)->exists()) 
+	{
+	  (*i)->animate(frame);
+	}
     }
   return;
 }

Modified: trunk/source/melee/mframe.h
===================================================================
--- trunk/source/melee/mframe.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mframe.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -134,7 +134,7 @@
   virtual void ship_died(Ship *who, SpaceLocation *source);
 };
 
-/// \brief Any item in the game
+/// \brief Any item in the game without location
 class Presence : public BaseClass 
 { 
   friend class Physics;

Modified: trunk/source/melee/mgame.cpp
===================================================================
--- trunk/source/melee/mgame.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mgame.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -46,7 +46,6 @@
 
 #include "other/twconfig.h"
 #include "other/dialogs.h"
-#include "xslt/twexslt.h"
 
 int random_seed[2];
 
@@ -860,7 +859,6 @@
   indteamtoggle = 0;
   indhealthtoggle = 0;
   _targrettrack = 0;
-  indhealthtoggle = ~indhealthtoggle;
 }
 
 void Game::init(Log *_log, const std::string& save) 
@@ -1368,21 +1366,6 @@
 
 int Game::Load(std::string xml)
 {
-  if(!exists(xml.c_str()))
-    return 1;
-
-  // parse the input XML document
-  xml::tree_parser parser(xml.c_str());
-  xml::document &doc = parser.get_document();
-  
-  // parse the stylesheet
-  xslt::stylesheet style(data_full_path("xslt/load.xsl").c_str());
-  
-  // transform the XML document using the stylesheet
-  //xml::document &result = style.apply(doc);
-  style.apply(doc);
-
-  //  std::cout << result;
   return 0;
 }
 

Modified: trunk/source/melee/mhelpers.cpp
===================================================================
--- trunk/source/melee/mhelpers.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mhelpers.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -610,6 +610,7 @@
 
 void ScrollText(std::vector<std::string>& text, FONT* font, int color, const std::string& backgr, const std::string& align, int speed)
 {
+  STACKTRACE;
   BITMAP* d_buf = create_bitmap(SCREEN_W, SCREEN_H);
   clear(d_buf);
   copy_buf();

Modified: trunk/source/melee/mitems.cpp
===================================================================
--- trunk/source/melee/mitems.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/mitems.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -44,7 +44,6 @@
 		state = 0;
 		return;
 	}
-
 }
 
 

Modified: trunk/source/melee/msprite.cpp
===================================================================
--- trunk/source/melee/msprite.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee/msprite.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -1026,6 +1026,34 @@
       iy = iround_down(pos.y);
       iw = iround_up(pos.x+size.x) + 1 - ix;
       ih = iround_up(pos.y+size.y) + 1 - iy;
+      ///////////////////////////////////////////////////////////////////////////////////
+      /*
+      BITMAP* blt;
+      int key = (int)size.abs()*1000 + index;
+      std::map<int,BITMAP*>::iterator i = _cache.find(key);
+      if(i!= _cache.end())
+	{
+	  blt = (*i).second;
+	}
+      else
+	{
+	  blt = create_bitmap(size.x, size.y);
+          clear_to_color(blt, bitmap_mask_color(blt));
+	  stretch_blit(bmp, blt, 0, 0, bmp->w,bmp->h, 
+			  0, 0, size.x, size.y);
+	  _cache[key] = blt;
+	}
+      draw_sprite(frame->surface, blt, pos.x, pos.y);
+      if(_cache.size()>128)
+	{
+	  for(std::map<int,BITMAP*>::iterator i = _cache.begin(); i!= _cache.end(); i++)
+	    {
+	      destroy_bitmap((*i).second);
+	    }
+	  _cache.clear();
+	}
+      */
+      ///////////////////////////////////////////////////////////////////////////////////
       aa_stretch_blit(bmp, frame->surface, 0,0,bmp->w,bmp->h, 
 		      pos.x, pos.y, size.x, size.y);
     }
@@ -1035,8 +1063,9 @@
       iy = iround(pos.y);
       iw = iround(size.x);
       ih = iround(size.y);
+     
       aa_stretch_blit(bmp, frame->surface, 0,0,bmp->w,bmp->h, 
-		      ix, iy, iw, ih);
+      		      ix, iy, iw, ih);
     }
   frame->add_box(ix, iy, iw, ih);
   return;

Modified: trunk/source/melee.h
===================================================================
--- trunk/source/melee.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/melee.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -30,6 +30,7 @@
 #include <list>
 #include <string>
 #include <vector>
+#include <map>
 
 #ifndef PI
 #	define PI 3.14159265358979323846
@@ -430,6 +431,7 @@
 void animate_bmp(BITMAP *bmp, Vector2 pos, Frame *space);
 
 
+
 /// Sprite 
 class SpaceSprite 
 {
@@ -446,6 +448,10 @@
   struct PMASK **m;
   Surface **b[MAX_MIP_LEVELS];
 
+  
+  /// (int)size.abs()*1000 + index  - key for bitmap
+  std::map<int,BITMAP*> _cache;
+
   int references;
   char *attributes;
   enum 

Modified: trunk/source/other/starmap.cpp
===================================================================
--- trunk/source/other/starmap.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/other/starmap.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -224,7 +224,6 @@
 	     {
 	       _targetStar = NULL;
 	       _selectedStar = NULL;
-	       _text = "";
 	       redraw();
 	     }
 	 }

Added: trunk/source/python/fileops.cpp
===================================================================
--- trunk/source/python/fileops.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/fileops.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,400 @@
+/*
+   $Id: fileops.cc,v 1.13 2003/01/24 22:15:43 ksterker Exp $
+
+   Copyright (C) 1999/2000/2001/2002/2003 Alexandre Courbot
+   Part of the Adonthell Project http://adonthell.linuxgames.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+
+/**
+ * @file   fileops.cc
+ * @author Alexandre Courbot <alexandrecourbot at linuxgames.com>
+ * 
+ * @brief  Defines the igzstream, ogzstream and fileops classes.
+ * 
+ */
+
+#include <stdio.h>
+#include <iostream>
+#include <SDL/SDL_endian.h>
+#include "fileops.h"
+
+
+using namespace std;
+
+
+gz_file::gz_file ()
+{
+    opened = false;
+}
+
+gz_file::gz_file (const string & fname, gz_type t)
+{
+    opened = false;
+    open (fname, t);
+}
+
+gz_file::~gz_file ()
+{
+    if (is_open ()) gzclose (file);
+}
+
+bool gz_file::open (const string & fname, gz_type t)
+{
+    if (t == READ) file = gzopen (fname.c_str (),"rb6");
+    else file = gzopen (fname.c_str (),"wb6");
+    if (!file) return false;
+    opened = true;
+    return true;
+}
+
+void gz_file::close ()
+{
+    if (is_open ()) gzclose (file);
+    opened = false;
+}
+
+igzstream::igzstream () : gz_file ()
+{
+}
+
+igzstream::igzstream (const string & fname) : gz_file (fname, READ)
+{
+}
+
+igzstream::~igzstream ()
+{
+}
+
+bool igzstream::open (const string & fname)
+{
+    return gz_file::open (fname, READ);
+}
+
+/// Reads a boolean.
+bool& operator << (bool& n, igzstream& gfile)
+{
+    u_int8 b;
+    gzread (gfile.file, &b, sizeof (b));
+    return (n = b);
+}
+
+/// Reads a boolean.
+bool igzstream::get_bool ()
+{
+    u_int8 b;
+    gzread (file, &b, sizeof (b));
+    return b;
+}
+
+/// Reads a char.
+char& operator << (char& n, igzstream& gfile)
+{
+    gzread (gfile.file, &n, sizeof (n));
+    return n;
+}
+
+/// Read a block of size chars
+void igzstream::get_block (void * to, u_int32 size)
+{
+    gzread (file, to, size); 
+}
+
+/// Reads a u_int8.
+u_int8& operator << (u_int8& n, igzstream& gfile)
+{
+    gzread(gfile.file, &n, sizeof (n));
+    return n;
+}
+
+/// Reads a u_int8.
+u_int8 igzstream::get_uint8 ()
+{
+    u_int8 n;
+    gzread (file, &n, sizeof (n));
+    return n;
+}
+
+/// Reads a s_int8.
+s_int8& operator << (s_int8& n, igzstream& gfile)
+{
+    gzread(gfile.file, &n, sizeof (n));
+    return n;
+}
+
+/// Reads a s_int8.
+s_int8 igzstream::get_sint8 ()
+{
+    s_int8 n;
+    gzread (file, &n, sizeof (n));
+    return n;
+}
+
+/// Reads a u_int16.
+u_int16& operator << (u_int16& n, igzstream& gfile)
+{
+    gzread(gfile.file, &n, sizeof (n));
+    n = SDL_SwapLE16(n);
+    return n;
+}
+
+/// Reads a u_int16.
+u_int16 igzstream::get_uint16 ()
+{
+    u_int16 n;
+    gzread (file, &n, sizeof (n));
+    return SDL_SwapLE16(n);
+}
+
+/// Reads a s_int16.
+s_int16& operator << (s_int16& n, igzstream& gfile)
+{
+    gzread(gfile.file, &n, sizeof (n));
+    n = SDL_SwapLE16(n);
+    return n;
+}
+
+/// Reads a s_int16.
+s_int16 igzstream::get_sint16 ()
+{
+    s_int16 n;
+    gzread (file, &n, sizeof (n));
+    return SDL_SwapLE16(n);
+}
+
+/// Reads a u_int32.
+u_int32& operator << (u_int32& n, igzstream& gfile)
+{
+    gzread(gfile.file, &n, sizeof (n));
+    n = SDL_SwapLE32(n);
+    return n;
+}
+
+/// Reads a u_int32.
+u_int32 igzstream::get_uint32 ()
+{
+    u_int32 n;
+    gzread (file, &n, sizeof (n));
+    return SDL_SwapLE32(n);
+}
+
+/// Reads a s_int32.
+s_int32& operator << (s_int32& n, igzstream& gfile)
+{
+    gzread(gfile.file, &n, sizeof (n));
+    n = SDL_SwapLE32(n);
+    return n;
+}
+
+/// Reads a s_int32.
+s_int32 igzstream::get_sint32 ()
+{
+    s_int32 n;
+    gzread (file, &n, sizeof (n));
+    return SDL_SwapLE32(n);
+}
+
+/// Reads a string.
+string& operator << (string& s, igzstream& gfile)
+{
+    u_int16 strl;
+    char c;
+    s = ""; 
+    strl << gfile;
+    while (strl)
+    {
+	c << gfile;
+	s += c;
+	strl --;
+    }
+    return s;
+}
+
+/// Reads a string.
+string igzstream::get_string ()
+{
+    string s;
+    s << *this;
+    return s;
+}
+
+/// Reads a float.
+float& operator << (float& f, igzstream& gfile)
+{
+    string sf;
+    sf << gfile;
+    
+    // floats saved as strings to remain independent of architecture
+    sscanf (sf.c_str (), "%f", &f);
+    
+    return f;
+}
+
+/// Reads a float.
+float igzstream::get_float ()
+{
+    float f;
+    f << *this;
+    return f;
+}
+
+
+ogzstream::ogzstream () : gz_file ()
+{
+}
+
+ogzstream::ogzstream (const string & fname) : gz_file (fname, WRITE)
+{
+}
+
+ogzstream::~ogzstream ()
+{
+}
+
+bool ogzstream::open (const string & fname)
+{
+    return gz_file::open (fname, WRITE);
+}
+
+void ogzstream::put_block (void * to, u_int32 size)
+{
+    gzwrite (file, to, size); 
+}
+
+/// Writes a boolean.
+const bool& operator >> (const bool& n, ogzstream& gfile)
+{
+    u_int8 b = n;
+    gzwrite (gfile.file, &b, sizeof (b));
+    return n;
+}
+
+/// Writes a char.
+const char& operator >> (const char& n, ogzstream& gfile)
+{
+    gzwrite (gfile.file, (char *) &n, sizeof (n));
+    return n;
+}
+
+/// Writes a u_int8.
+const u_int8& operator >> (const u_int8& n, ogzstream& gfile)
+{
+    gzwrite(gfile.file, (u_int8 *) &n, sizeof (n));
+    return n;
+}
+
+/// Writes a s_int8.
+const s_int8& operator >> (const s_int8& n, ogzstream& gfile)
+{
+    gzwrite(gfile.file, (s_int8 *) &n, sizeof (n));
+    return n;
+}
+
+/// Writes a u_int16.
+const u_int16& operator >> (const u_int16& n, ogzstream& gfile)
+{
+    u_int16 s = SDL_SwapLE16(n);
+    gzwrite(gfile.file, (u_int16 *) &s, sizeof (n));
+    return n;
+}
+
+/// Writes a s_int16.
+const s_int16& operator >> (const s_int16& n, ogzstream& gfile)
+{
+    s_int16 s = SDL_SwapLE16(n);
+    gzwrite(gfile.file, (s_int16 *) &s, sizeof (n));
+    return n;
+}
+
+/// Writes a u_int32.
+const u_int32& operator >> (const u_int32& n, ogzstream& gfile)
+{
+    u_int32 s = SDL_SwapLE32(n);
+    gzwrite(gfile.file, (u_int32 *) &s, sizeof (n));
+    return n;
+}
+
+/// Writes a s_int32.
+const s_int32& operator >> (const s_int32& n, ogzstream& gfile)
+{
+    s_int32 s = SDL_SwapLE32(n);
+    gzwrite(gfile.file, (s_int32 *) &s, sizeof (n));
+    return n;
+}
+
+/// Writes a string.
+string& operator >> (const string& s, ogzstream& gfile)
+{
+    u_int16 strl = s.length ();
+    string::iterator i; 
+    strl >>  gfile;
+    
+    for (i = ((string&) s).begin (); i != ((string&) s).end (); i++) 
+        (*i) >>  gfile;
+    return (string&) s;
+}
+
+/// Writes a float.
+const float& operator >> (const float& f, ogzstream& gfile)
+{
+    char sf[16];
+    
+    // floats saved as strings to remain independent of architecture
+    snprintf (sf, 16, "%f", f);
+    sf >> gfile;
+    
+    return f;
+}
+
+void fileops::put_version (ogzstream& file, u_int16 version)
+{
+    char c = 'v'; 
+    c >> file;
+    version >> file; 
+}
+
+// read version info from file and check whether we can handle it
+bool fileops::get_version (igzstream& file, u_int16 min, u_int16 max, string name)
+{
+    char vinfo;
+    u_int16 version;
+
+    vinfo << file;
+
+    if (name == "") name = "<unknown>";
+
+    // file contains no version info
+    if (vinfo != 'v')
+    {
+        cerr << "Version information missing in file \"" << name << endl;
+        cerr << "You should get a more recent data package.\n";
+        return false;
+    }
+    
+    // check whether file has the version we expect
+    version << file;
+
+    if (version < min || version > max)
+    {
+        cerr << "File \"" << name << "\" has\nversion number " << version << ", ";
+        cerr <<  "but I was expecting " << min << " <= version <= " << max << endl;
+	
+        // file is newer than code
+        if (version > max)
+            cerr << "You should get an up-to-date version of this program.\n\n";
+        // file is older than code
+        else
+            cerr << "You should probably get a more recent data package.\n";
+
+        return false;
+    } 
+    return true;
+}

Added: trunk/source/python/fileops.h
===================================================================
--- trunk/source/python/fileops.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/fileops.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,338 @@
+/*
+   $Id: fileops.h,v 1.17 2003/01/20 20:18:43 ksterker Exp $
+
+   Copyright (C) 2001/2003 Alexandre Courbot
+   Part of the Adonthell Project http://adonthell.linuxgames.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+
+/**
+ * @file   fileops.h
+ * @author Alexandre Courbot <alexandrecourbot at linuxgames.com>
+ * 
+ * @brief  Declares the igzstream, ogzstream and fileops classes.
+ * 
+ */
+
+
+
+
+#ifndef FILEOPS_H_
+#define FILEOPS_H_
+
+#include <zlib.h>
+#include <string>
+#include "types.h"
+
+
+#ifndef SWIG
+//using namespace std; 
+#endif
+
+
+/**
+ * Enumeration to know whether a file is read or write opened.
+ * 
+ */ 
+typedef enum { READ, WRITE } gz_type;
+
+
+/**
+ * Base class for igzstream and ogzstream.
+ * 
+ */ 
+class gz_file
+{
+public:
+    /** 
+     * Default constructor.
+     * 
+     */
+    gz_file ();
+
+#ifndef SWIG
+    /** 
+     * 
+     * 
+     * @param fname name of the file to open.
+     * @param t access (READ or WRITE).
+     */
+    gz_file (const std::string & fname, gz_type t);
+#endif
+
+    /** 
+     * Destructor.
+     * 
+     */
+    virtual ~gz_file ();
+    
+    /** 
+     * Opens a file.
+     * 
+     * @param fname name of the file to open.
+     * @param t access (READ or WRITE).
+     * 
+     * @return true if succeed, false otherwise.
+     */
+    bool open (const std::string & fname, gz_type t);
+
+    /** 
+     * Close the file that was opened.
+     * 
+     */
+    void close ();
+
+    /** 
+     * Returns whether the file is opened or not.
+     * 
+     * 
+     * @return true if the file is opened, false otherwise.
+     */
+    bool is_open () { return opened; }
+
+    /** 
+     * Returns whether the file is at it's end or not.
+     * 
+     * 
+     * @return true if the end of file is reached, else otherwise.
+     */
+    bool eof () 
+    {
+        return gzeof (file); 
+    }
+    
+protected:
+    /** 
+     * The actual gzFile.
+     * 
+     */ 
+    gzFile file;
+
+private:
+    /// NEVER pass this by value.
+    gz_file (gz_file& src); 
+    
+    /// Opened or not?
+    bool opened; 
+};
+
+
+/** 
+ * Class to read data from a Gzip compressed file.
+ */ 
+class igzstream : public gz_file
+{
+public:
+    /**
+     * Default constructor.
+     * 
+     */ 
+    igzstream ();
+
+#ifndef SWIG
+    /** 
+     * Opens a file for read access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     */ 
+    igzstream (const std::string & fname);
+#endif
+    
+    /**
+     * Destructor.
+     * 
+     */ 
+    ~igzstream ();
+
+    /** 
+     * Opens a file for read access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     * @return true if succeed, false otherwise.
+     */
+    bool open (const std::string & fname);
+
+    /** 
+     * Reads a block of bytes from the file.
+     * 
+     * @param to pointer to the buffer where to read.
+     * @param size number of bytes to read.
+     */
+    void get_block (void * to, u_int32 size); 
+
+#ifndef SWIG
+    /// Reads a boolean.
+    friend bool& operator << (bool& n, igzstream& gfile);
+
+    /// Reads a char.
+    friend char& operator << (char& n, igzstream& gfile);
+
+    /// Reads a u_int8.
+    friend u_int8& operator << (u_int8& n, igzstream& gfile);
+
+    /// Reads a s_int8.
+    friend s_int8& operator << (s_int8& n, igzstream& gfile);
+
+    /// Reads a u_int16.
+    friend u_int16& operator << (u_int16& n, igzstream& gfile);
+
+    /// Reads a s_int16.
+    friend s_int16& operator << (s_int16& n, igzstream& gfile);
+
+    /// Reads a u_int32.
+    friend u_int32& operator << (u_int32& n, igzstream& gfile);
+
+    /// Reads a s_int32.
+    friend s_int32& operator << (s_int32& n, igzstream& gfile);
+
+    /// Reads a string.
+    friend std::string& operator << (std::string& s, igzstream& gfile);
+    
+    /// Reads a float.
+    friend float& operator << (float& s, igzstream& gfile);
+#endif
+
+    bool get_bool ();
+    u_int8 get_uint8 ();
+    s_int8 get_sint8 ();
+    u_int16 get_uint16 ();
+    s_int16 get_sint16 ();
+    u_int32 get_uint32 ();
+    s_int32 get_sint32 ();
+    std::string get_string ();
+    float get_float ();
+
+private:
+    /// NEVER pass this by value.
+    igzstream (igzstream& src);  
+};
+
+/** 
+ * Class to write data from a Gzip compressed file.
+ */ 
+class ogzstream : public gz_file
+{
+public:
+    /**
+     * Default constructor.
+     * 
+     */ 
+    ogzstream ();
+
+#ifndef SWIG
+    /** 
+     * Opens a file for write access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     */ 
+    ogzstream (const std::string & fname);
+#endif
+    
+    /**
+     * Destructor.
+     * 
+     */
+    ~ogzstream ();
+
+    /** 
+     * Opens a file for write access.
+     * 
+     * @param fname name of the file to open.
+     * 
+     * @return true if succeed, false otherwise.
+     */
+    bool open (const std::string & fname);
+
+    /** 
+     * Writes a block of bytes to the file.
+     * 
+     * @param to pointer to the buffer to write.
+     * @param size number of bytes to write.
+     */
+    void put_block (void * to, u_int32 size); 
+
+#ifndef SWIG
+    /// Writes a boolean.
+    friend const bool& operator >> (const bool& n, ogzstream& gfile);
+
+    /// Writes a char.
+    friend const char& operator >> (const char& n, ogzstream& gfile);
+
+    /// Writes a u_int8.
+    friend const u_int8& operator >> (const u_int8& n, ogzstream& gfile);
+
+    /// Writes a s_int8.
+    friend const s_int8& operator >> (const s_int8& n, ogzstream& gfile);
+
+    /// Writes a u_int16.
+    friend const u_int16& operator >> (const u_int16& n, ogzstream& gfile);
+
+    /// Writes a s_int16.
+    friend const s_int16& operator >> (const s_int16& n, ogzstream& gfile);
+
+    /// Writes a u_int32.
+    friend const u_int32& operator >> (const u_int32& n, ogzstream& gfile);
+
+    /// Writes a s_int32.
+    friend const s_int32& operator >> (const s_int32& n, ogzstream& gfile);
+
+    /// Writes a string.
+    friend std::string& operator >> (const std::string& s, ogzstream& gfile);
+    
+    /// Writes a float.
+    friend const float& operator >> (const float& s, ogzstream& gfile);
+#endif
+
+    void put_bool (const bool &n)         { n >> *this; }
+    void put_uint8 (const u_int8 &n)      { n >> *this; }
+    void put_sint8 (const s_int8 &n)      { n >> *this; }
+    void put_uint16 (const u_int16 &n)    { n >> *this; }
+    void put_sint16 (const s_int16 &n)    { n >> *this; }
+    void put_uint32 (const u_int32 &n)    { n >> *this; }
+    void put_sint32 (const s_int32 &n)    { n >> *this; }
+    void put_string (const std::string& s)     { s >> *this; }
+    void put_float (const float &n)       { n >> *this; }
+    
+private:
+    /// NEVER pass this by value.
+    ogzstream (ogzstream& src);   
+};
+
+/// File version control class.
+class fileops
+{
+public:
+    /** 
+     * Sets the version number of a file.
+     * 
+     * @param file file where to write the version number.
+     * @param version version number to write.
+     */
+    static void put_version (ogzstream& file, u_int16 version);  // Set version of a file
+
+    /** 
+     * 
+     * 
+     * @param file file to check version.
+     * @param min minimum expected version number.
+     * @param max maximum expected version number.
+     * @param name filename of the passed file.
+     * 
+     * @return true if 
+     */
+    static bool get_version (igzstream& file, u_int16 min, u_int16 max, std::string name); // Check version
+};
+
+
+#endif // __FILEOPS_H__

Added: trunk/source/python/game.cpp
===================================================================
--- trunk/source/python/game.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/game.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,122 @@
+/*
+   $Id: game.cc,v 1.28 2003/02/20 17:27:41 ksterker Exp $
+
+   Copyright (C) 1999/2000/2001/2002 Kai Sterker <kaisterker at linuxgames.com>
+   Copyright (C) 2002 Alexandre Courbot <alexandrecourbot at linuxgames.com>
+   Part of the Adonthell Project http://adonthell.linuxgames.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+/**
+ * @file   game.cc
+ * @author Kai Sterker <kaisterker at linuxgames.com>
+ * @author Alexandre Courbot <alexandrecourbot at linuxgames.com>
+ * 
+ * @brief  Defines the game class.
+ * 
+ * 
+ */
+
+
+#include "game.h"
+#include <stdlib.h>
+#include <sys/types.h>
+#include <dirent.h>
+
+
+std::string game::User_data_dir; 
+std::string game::Global_data_dir; 
+std::string game::Game_data_dir; 
+
+
+void game::init (std::string game_dir) 
+{
+    Global_data_dir = game_dir;
+#ifndef SINGLE_DIR_INST
+    User_data_dir = getenv ("HOME");
+    User_data_dir += "/.adonthell";
+#else
+    User_data_dir = Global_data_dir;
+#endif
+}
+
+void game::set_game_data_dir(std::string game_dir)
+{
+    Game_data_dir = game_dir;
+}
+
+bool game::directory_exist (const std::string & dirname)
+{
+    DIR * dir = opendir (dirname.c_str ());
+
+    if (dir) 
+    {
+        closedir (dir);
+        return true; 
+    }
+
+    return false; 
+}
+
+bool game::file_exist (const std::string & fname) 
+{
+    FILE * file = fopen (fname.c_str (), "r");
+
+    if (file) 
+    {
+        fclose (file);
+        return true; 
+    }
+
+    return false; 
+}
+
+std::string game::find_file (const std::string & fname) 
+{
+    std::string ret;
+
+    // If the name is already absolute, no need to search...
+    if (fname[0] == '/') return fname; 
+    
+    // First check in the current game directory
+    if ((ret = game_data_dir () + "/") != "/" && file_exist (ret + fname))
+        ret += fname; 
+    // Then check the global data directory
+    else if (file_exist ((ret = global_data_dir () + "/") + fname)) 
+        ret += fname;
+    // Finally, try the user data directory
+    else if (file_exist ((ret = user_data_dir () + "/") + fname))
+        ret += fname;
+    // Nothing found! So bad...
+    else ret = "";
+
+    return ret; 
+}
+
+std::string game::find_directory (const std::string & dirname) 
+{
+    std::string ret;
+
+    // If the name is already absolute, no need to search...
+    if (dirname[0] == '/') return dirname; 
+
+    // First check in the current game directory
+    if ((ret = game_data_dir () + "/") != "/" && directory_exist (ret + dirname))
+        ret += dirname; 
+    // Then check the global data directory
+    else if (directory_exist ((ret = global_data_dir () + "/") + dirname)) 
+        ret += dirname;
+    // Finally, try the user data directory
+    else if (directory_exist ((ret = user_data_dir () + "/") + dirname))
+        ret += dirname;
+    // Nothing found! So bad...
+    else ret = "";
+
+    return ret; 
+}

Added: trunk/source/python/game.h
===================================================================
--- trunk/source/python/game.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/game.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,138 @@
+/*
+   $Id: game.h,v 1.25 2002/04/27 17:00:19 gnurou Exp $
+
+   Copyright (C) 1999/2000/2001 Kai Sterker <kaisterker at linuxgames.com>
+   Copyright (C) 2002 Alexandre Courbot <alexandrecourbot at linuxgames.com>
+   Part of the Adonthell Project http://adonthell.linuxgames.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+/**
+ * @file   game.h
+ * @author Kai Sterker <kaisterker at linuxgames.com>
+ * @author Alexandre Courbot <alexandrecourbot at linuxgames.com>
+ * 
+ * @brief  Declares the game class.
+ * 
+ * 
+ */
+
+
+
+#ifndef GAME_H__
+#define GAME_H__
+
+
+#include <string>
+#include "types.h"
+
+#ifndef SWIG 
+//using std::string; 
+#endif
+
+/**
+ * Holds information about global settings.
+ *
+ * This static class should be the first to be initialised in your application,
+ * because many others depends on it's correct settings.
+ * 
+ */
+class game
+{
+public:
+    static std::string User_data_dir;
+    static std::string Global_data_dir;
+    static std::string Game_data_dir; 
+
+
+    /** 
+     * Initialise the game framework.
+     * 
+     * @param game_dir Global data directory.
+     */
+    static void init (std::string game_dir); 
+
+    /** 
+     * Specify an additional data directory containing game data.
+     * 
+     * @param game_dir Game data directory.
+     */
+    static void set_game_data_dir (std::string game_dir); 
+    
+    /** 
+     * Returns the absolute path to the user data directory (usually ~/.adonthell).
+     * 
+     * 
+     * @return user data directory
+     */
+    static std::string user_data_dir ()
+    {
+        return User_data_dir; 
+    }
+
+    /** 
+     * Returns the absolute path to the global data directory.
+     * 
+     * 
+     * @return global data directory
+     */
+    static std::string global_data_dir ()
+    {
+        return Global_data_dir; 
+    }
+
+    /** 
+     * Returns the absolute path to the current game's directory (if any).
+     * 
+     * 
+     * @return current game data directory, or empty string if none set.
+     */
+    static std::string game_data_dir ()
+    {
+        return Game_data_dir; 
+    }
+
+    /** 
+     * Finds a file in the directories hierarchy, starting searching from
+     * game_data_dir(), then global_data_dir() and finally user_data_dir().
+     *
+     * If a matching file is found, the full absolute path is returned, else
+     * an empty string "" is returned. If the path was already absolute, it is
+     * returned immediatly.
+     * 
+     * @param fname name of the find to search for.
+     * 
+     * @return complete absolute path to the file if found, passed string if the given
+     *         path was already absolute, or "" if the file wasn't found.
+     */
+    static std::string find_file (const std::string & fname);
+
+    /** 
+     * Finds a directory in the directories hierarchy, starting searching from
+     * game_data_dir(), then global_data_dir() and finally user_data_dir().
+     *
+     * If a matching directory is found, the full absolute path is returned, else
+     * an empty string "" is returned. If the path was already absolute, it is
+     * returned immediatly.
+     * 
+     * @param fname name of the find to search for.
+     * 
+     * @return complete absolute path to the directory if found, passed string if the given
+     *         path was already absolute, or "" if the directory wasn't found.
+     */
+    static std::string find_directory (const std::string & dirname); 
+    
+private:
+    static bool directory_exist (const std::string & dirname); 
+    static bool file_exist (const std::string & fname); 
+};
+
+
+#endif // GAME_H__

Added: trunk/source/python/python_class.cpp
===================================================================
--- trunk/source/python/python_class.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/python_class.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,226 @@
+/*
+   $Id: python_class.cc,v 1.10 2003/02/20 21:03:11 ksterker Exp $
+
+   Copyright (C) 2001 Kai Sterker <kaisterker at linuxgames.com>
+   Part of the Adonthell Project http://adonthell.linuxgames.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+/**
+ * @file   python_class.cc
+ * @author Kai Sterker <kaisterker at linuxgames.com>
+ * 
+ * @brief  Declares the python class.
+ * 
+ * 
+ */
+
+#include "python_class.h"
+#include "game.h"
+#include <iostream> 
+
+//using namespace std;
+
+PyObject * data::globals;
+PyObject * python::module;
+
+/*
+ * Start Python
+ */
+void python::init ()
+{
+    Py_Initialize ();
+}
+
+void python::cleanup () 
+{
+    // Cleanup the global namespace of python interpreter
+    // Note that we don't have to DECREF data::globals, because they're a
+    // borrowed reference of py_module.
+    Py_XDECREF (module);
+    Py_Finalize ();
+}
+
+/*
+ * Insert a string into the module search path.
+ */
+void python::insert_path( char *name )
+{
+    char buf[256];
+    
+    sprintf ( buf, "import sys ; sys.path.insert(0, \"%s\")", name );
+    PyRun_SimpleString ( buf );
+}
+
+/*
+ * Some convenience functions
+ */
+
+/*
+ * Executes the Python statements in the string
+ */
+void python::exec_string(char * s)
+{
+    PyRun_SimpleString(s);
+}
+
+/*
+ * Execute the file given by 'filename'
+ */
+bool python::exec_file (std::string filename)
+{
+    PyObject *mod = python::import_module (filename);
+ 
+    if (!mod)
+    {
+        std::cerr << "exec_file: " << filename << " load failed: " << std::endl;
+        show_traceback ();
+
+        return false;
+    }
+
+    Py_DECREF (mod); 
+
+    return true; 
+}
+
+/*
+ * Dump any error information to stderr
+ */
+void python::show_traceback(void)
+{
+    if ( PyErr_Occurred() )
+    {
+        PyErr_Print();
+        fflush (stderr);
+    }
+}
+
+/* Import a module, return module ptr */
+PyObject *python::import_module (std::string filename)
+{
+    PyObject *result = PyImport_ImportModule ((char *) filename.c_str ());
+    
+#ifdef PY_DEBUG
+    show_traceback ();
+#endif
+    return result;
+}
+
+// Make a C++ instance available to Python
+PyObject *python::pass_instance (void *instance, const char *class_name)
+{
+    char class_ptr[256];
+    char class_addr[256];
+    char *buffer = class_addr;
+
+    // Construct the python shadow class matching the "instance" class 
+    strcat (strcpy (class_ptr, class_name), "Ptr");
+    
+    // Construct SWIG's representation of the "instance" pointer
+    *(buffer++) = '_';
+    buffer = ptr_to_string (buffer, &instance, sizeof (void *));
+    strcpy (buffer, "_p_");
+    strcpy (buffer+3, class_name);
+
+    // Now create the Python object corresponding to "instance"
+    PyObject *cls = PyDict_GetItemString (data::globals, class_ptr);
+    PyObject *arg = Py_BuildValue ("(s)", class_addr);
+    PyObject *res = PyObject_CallObject (cls, arg);
+    
+#ifdef PY_DEBUG
+    show_traceback ();
+#endif
+
+    // Clean up
+    Py_DECREF (arg);
+    
+    // Voila: "res" is 'identical' to "instance" :)
+    return res;
+}
+
+// Convert a pointer to a string (like SWIG 1.3.7 does)
+char *python::ptr_to_string (char *c, void *ptr, int sz)
+{
+    static char hex[17] = "0123456789abcdef";
+    int i;
+    unsigned char *u = (unsigned char *) ptr;
+    register unsigned char uu;
+
+    for (i = 0; i < sz; i++,u++)
+    {
+        uu = *u;
+        *(c++) = hex[(uu & 0xf0) >> 4];
+        *(c++) = hex[uu & 0xf];
+    }
+
+    return c;
+}
+
+PyObject * python::get_tuple (igzstream & file)
+{
+    PyObject * tuple; 
+    u_int32 l;
+    l << file;
+
+    tuple = PyTuple_New (l);
+
+    for (u_int32 i = 0; i < l; i++) 
+    {
+        std::string ms;
+        u_int32 j;
+        char c;
+        
+        c << file;
+        switch (c) 
+        {
+            case 's':
+                ms << file;
+                // Stolen reference
+                PyTuple_SetItem (tuple, i, PyString_FromString (ms.c_str ()));
+                break;
+                
+            case 'i':
+                j << file;
+                // Stolen reference
+                PyTuple_SetItem (tuple, i, PyInt_FromLong (j));
+                break; 
+        }
+    }
+    return tuple; 
+}
+
+void python::put_tuple (PyObject * tuple, ogzstream & file)
+{
+    u_int32 l = PyTuple_Size (tuple);
+    l >> file;
+    for (u_int32 i = 0; i < l; i++) 
+    {
+        // Borrowed reference
+        PyObject * item = PyTuple_GetItem (tuple, i);
+        
+        // Check for the type of this object
+        // String?
+        if (PyString_Check (item)) 
+        {
+            's' >> file;
+            char * s = PyString_AsString (item); 
+            std::string (s) >> file;
+        }
+        
+        // Integer?
+        else if (PyInt_Check (item)) 
+        {
+            'i' >> file;
+            u_int32 li = PyInt_AsLong (item); 
+            li >> file;
+        }
+    }
+}

Added: trunk/source/python/python_class.h
===================================================================
--- trunk/source/python/python_class.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/python_class.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,146 @@
+/*
+   $Id: python_class.h,v 1.9 2003/02/23 23:14:34 ksterker Exp $
+
+   Copyright (C) 2001 Kai Sterker <kaisterker at linuxgames.com>
+   Part of the Adonthell Project http://adonthell.linuxgames.com
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+
+   See the COPYING file for more details.
+*/
+
+
+/**
+ * @file   python_class.h
+ * @author Kai Sterker <kaisterker at linuxgames.com>
+ * 
+ * @brief  Defines the python class. This file is named this way
+ *         so it doesn't conflicts with Python.h Python's include
+ *         file on non-case aware systems.
+ * 
+ * 
+ */
+ 
+
+#ifndef PYTHON_CLASS_H__
+#define PYTHON_CLASS_H__
+
+#include "Python.h"
+#include "compile.h"
+#include "eval.h"
+#include "node.h"
+#include "fileops.h"
+
+/**
+ * Grant simplified access to the Python interpreter.
+ * 
+ */ 
+class python
+{  
+public:
+    /** 
+     * Initialise Python and insert the Adonthell include paths.
+     * 
+     * 
+     * @return true in case of success, false otherwise.
+     */
+    static void init ();
+
+    /**
+     * Cleanup Python.
+     * 
+     */ 
+    static void cleanup (); 
+
+    /** 
+     * Adds a directory to Python's include path.
+     * 
+     * @param name directory to add to Python's include path.
+     */
+    static void insert_path( char * name);
+    
+    /** 
+     * Execute Python statements contained in a string.
+     * 
+     * @param s string containing Python statements to execute.
+     */
+    static void exec_string(char * s);
+    
+    /** 
+     * Executes a Python script.
+     * 
+     * @param filename name of the file to execute.
+     * 
+     * @return true in case of success, false otherwise.
+     */ 
+    static bool exec_file (std::string filename);
+    
+    /** 
+     * Imports a Python module.
+     * 
+     * @param filename file name of the module to import.
+     * 
+     * @return pointer to the imported module.
+     */
+    static PyObject *import_module (std::string filename);
+    
+    /** 
+     * Dumps any error information to stderr.
+     * 
+     */
+    static void show_traceback( void );
+    
+    /** 
+     * Magic function that makes any C object available to Python!
+     * 
+     * @param instance pointer to the instance to pass.
+     * @param class_name name of the class of the passed instance.
+     * 
+     * @return pointer to the passed %object.
+     */
+    static PyObject *pass_instance (void* instance, const char* class_name);
+
+    /** 
+     * Loads a Python tuple previously saved with put_tuple ().
+     * 
+     * @param file Opened file where to load the tuple from.
+     * 
+     * @return Restored Python tuple.
+     */
+    static PyObject * get_tuple (igzstream & file); 
+
+    /** 
+     * Save a Python tuple into a file.
+     *
+     * @warning The Python tuple MUST ONLY be composed of Python strings
+     * or integers!
+     * 
+     * @param tuple Python tuple to save.
+     * @param file Opened file where to save the tuple to.
+     */
+    static void put_tuple (PyObject * tuple, ogzstream & file);  
+
+    static PyObject *module;
+private:
+    /**
+     * Convert a Pointer to a String, like SWIG 1.3.7+ does
+     *
+     */
+    static char *python::ptr_to_string (char *c, void *ptr, int sz);
+};
+
+#ifndef SWIG
+namespace data
+{
+    /**
+     * Global namespace to use in scripts.
+     * 
+     */ 
+    extern PyObject *globals;
+}
+#endif
+
+#endif // PYTHON_CLASS_H__

Added: trunk/source/python/types.h
===================================================================
--- trunk/source/python/types.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/python/types.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -0,0 +1,55 @@
+// $Id: types.h,v 1.16 2002/04/25 15:34:11 gnurou Exp $
+/*
+   Copyright (C) 1999/2000/2001 Alexandre Courbot.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.
+   See the COPYING file for more details.
+
+ */
+
+
+/** @file types.h
+ *  @author Alexandre Courbot <alexandrecourbot at linuxgames.com>
+ *  @brief Declares some basic types.
+ */ 
+
+ 
+#ifndef TYPES_H__
+#define TYPES_H__
+
+#include "SDL.h"
+
+// We should put ifdefs here to put the correct int values accordingly to the system type
+
+
+/// 8 bits long unsigned integer
+#define u_int8 unsigned char
+
+/// 16 bits long unsigned integer
+#define u_int16 unsigned short
+
+/// 32 bits long unsigned integer
+#define u_int32 unsigned int
+
+/// 8 bits long signed integer
+#define s_int8 signed char
+
+/// 16 bits long signed integer
+#define s_int16 signed short
+
+/// 32 bits long signed integer
+#define s_int32 signed int
+
+
+/* 
+typedef Uint8 u_int8;
+typedef Uint16 u_int16;
+typedef Uint32 u_int32;
+typedef Sint8 s_int8;
+typedef Sint16 s_int16;
+typedef Sint32 s_int32;
+*/ 
+#endif

Modified: trunk/source/scp.cpp
===================================================================
--- trunk/source/scp.cpp	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/scp.cpp	2005-03-12 19:12:58 UTC (rev 136)
@@ -36,13 +36,17 @@
 
 #include "tests/testmain.h"
 
-#include <xsltwrapp/xsltwrapp.h>
-
 // standard includes
 #include <iostream>
 #include <exception>
-#include "xslt/twexslt.h"
 
+
+
+extern "C"
+{
+  void init_ggob(void);
+}
+
 #ifdef ALLEGRO_MSVC
 #pragma warning (disable:4786)
 #endif
@@ -69,6 +73,8 @@
 #include "melee/mfleet.h"
 
 
+#include <Python.h>
+#include "python/python_class.h"
 
 
 DATAFILE* g_game_data = NULL;
@@ -104,6 +110,7 @@
   f = pack_fopen (data_full_path("version.txt").c_str(), F_READ);
   if (!f)
     {
+      return "Unknown";
       tw_error("Unable to retrive version information");
     }
   else 
@@ -787,9 +794,10 @@
       return RunTests();
     }
   
-  // prepare the XSLT engine and XML parser
-  xslt::init init;
-  exsltTW_LIGHTRegister();
+  python::init();  
+  python::insert_path(DATAFILE_PATH"/python");
+  init_ggob();
+  python::module = python::import_module("ggob");
 
   int i;
   int auto_port = -1;
@@ -1042,6 +1050,7 @@
     if (__error_flag & 1) throw;
   }
   
+  python::cleanup();  
   tw_exit(0);
   return 0;
 }

Modified: trunk/source/util/vector2.h
===================================================================
--- trunk/source/util/vector2.h	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/source/util/vector2.h	2005-03-12 19:12:58 UTC (rev 136)
@@ -45,11 +45,11 @@
 	Vector2 rotate(double angle) const ;
 };
 
-inline Vector2 operator+ (Vector2 a, Vector2 b) { return Vector2(a.x+b.x,a.y+b.y); }
-inline Vector2 operator- (Vector2 a, Vector2 b) { return Vector2(a.x-b.x,a.y-b.y); }
-inline Vector2 operator* (Vector2 a, double b) { return Vector2(a.x*b,a.y*b); }
-inline Vector2 operator* (double b, Vector2 a) { return Vector2(a.x*b,a.y*b); }
-inline Vector2 operator/ (Vector2 a, double b) { double c = 1/b; return Vector2(a.x*c,a.y*c); }
+inline Vector2 operator+ (const Vector2& a, const Vector2& b) { return Vector2(a.x+b.x,a.y+b.y); }
+inline Vector2 operator- (const Vector2& a, const Vector2& b) { return Vector2(a.x-b.x,a.y-b.y); }
+inline Vector2 operator* (const Vector2& a, const double& b) { return Vector2(a.x*b,a.y*b); }
+inline Vector2 operator* (const double& b, const Vector2& a) { return Vector2(a.x*b,a.y*b); }
+inline Vector2 operator/ (const Vector2& a, const double& b) { double c = 1/b; return Vector2(a.x*c,a.y*c); }
 
 inline double magnitude_sqr ( Vector2 vect ) { return (vect.x*vect.x+vect.y*vect.y); }
 //returns the square of the magnitude of vect (fast)

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-03-08 14:45:30 UTC (rev 135)
+++ trunk/sources.lst	2005-03-12 19:12:58 UTC (rev 136)
@@ -98,6 +98,7 @@
 source/libraries/jpgalleg/jpgalleg.c
 source/scp.cpp
 source/doxygen.cpp
+source/generated/ggob_wrap.cpp
 source/input.cpp
 source/sc1ships/shpearcr.cpp
 source/sc1ships/shpchebr.cpp
@@ -125,4 +126,6 @@
 source/sc2ships/shpslypr.cpp
 source/sc2ships/shpzfpst.cpp
 source/gui.cpp
-source/xslt/twexslt.cpp
+source/python/game.cpp
+source/python/python_class.cpp
+source/python/fileops.cpp



From yurand at sheep.berlios.de  Sat Mar 12 20:31:09 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sat, 12 Mar 2005 20:31:09 +0100
Subject: [Tw-light-svn] r137 - trunk/source/games
Message-ID: <200503121931.j2CJV9MA029614@sheep.berlios.de>

Author: yurand
Date: 2005-03-12 20:31:08 +0100 (Sat, 12 Mar 2005)
New Revision: 137

Added:
   trunk/source/games/ggob.i
Log:
Adding missing Gob interface file


Added: trunk/source/games/ggob.i
===================================================================
--- trunk/source/games/ggob.i	2005-03-12 19:12:58 UTC (rev 136)
+++ trunk/source/games/ggob.i	2005-03-12 19:31:08 UTC (rev 137)
@@ -0,0 +1,8 @@
+%module ggob
+%{
+#include "games/ggob.h"
+%}
+%include "std_string.i"
+%include "std_pair.i"
+%include ggob.h
+



From yurand at sheep.berlios.de  Sun Mar 13 19:19:32 2005
From: yurand at sheep.berlios.de (Yura Semashko at BerliOS)
Date: Sun, 13 Mar 2005 19:19:32 +0100
Subject: [Tw-light-svn] r138 - trunk/source/other
Message-ID: <200503131819.j2DIJWUU030906@sheep.berlios.de>

Author: yurand
Date: 2005-03-13 19:19:31 +0100 (Sun, 13 Mar 2005)
New Revision: 138

Modified:
   trunk/source/other/starmap.cpp
Log:
Fixed windows name conflict


Modified: trunk/source/other/starmap.cpp
===================================================================
--- trunk/source/other/starmap.cpp	2005-03-12 19:31:08 UTC (rev 137)
+++ trunk/source/other/starmap.cpp	2005-03-13 18:19:31 UTC (rev 138)
@@ -188,10 +188,10 @@
    while(1)
      {
        poll_mouse();
-       StarSystem* near = nearStar();
-       if(  _selectedStar != near)
+       StarSystem* nearstar = nearStar();
+       if(  _selectedStar != nearstar)
 	 {
-	   _selectedStar = near;
+	   _selectedStar = nearstar;
 	   redraw();
 	 }
        
@@ -227,10 +227,11 @@
 	       redraw();
 	     }
 	 }
-     };
+     }
   
   show_mouse(NULL);
   game->unpause();
   return ret;
+return "";
 }
 



