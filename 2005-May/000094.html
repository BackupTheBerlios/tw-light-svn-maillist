<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r148 - in trunk: . gamedata/default_ini/ships gamedata/python gamedata/ships source/games source/generated source/other source/python web
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2005-May/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r148%20-%20in%20trunk%3A%20.%20gamedata/default_ini/ships%20gamedata/python%20gamedata/ships%20source/games%20source/generated%20source/other%20source/python%20web&In-Reply-To=%3C200505051942.j45JgPWV008969%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000093.html">
   <LINK REL="Next"  HREF="000095.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r148 - in trunk: . gamedata/default_ini/ships gamedata/python gamedata/ships source/games source/generated source/other source/python web</H1>
    <B>Yura Semashko at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r148%20-%20in%20trunk%3A%20.%20gamedata/default_ini/ships%20gamedata/python%20gamedata/ships%20source/games%20source/generated%20source/other%20source/python%20web&In-Reply-To=%3C200505051942.j45JgPWV008969%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r148 - in trunk: . gamedata/default_ini/ships gamedata/python gamedata/ships source/games source/generated source/other source/python web">yurand at sheep.berlios.de
       </A><BR>
    <I>Thu May  5 21:42:25 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000093.html">[Tw-light-svn] r147 - in trunk: . doc gamedata source source/python
</A></li>
        <LI>Next message: <A HREF="000095.html">[Tw-light-svn] r149 - in trunk: . doc gamedata/images gamedata/images/alien gamedata/python source/generated source/other source/python
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#94">[ date ]</a>
              <a href="thread.html#94">[ thread ]</a>
              <a href="subject.html#94">[ subject ]</a>
              <a href="author.html#94">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2005-05-05 21:42:24 +0200 (Thu, 05 May 2005)
New Revision: 148

Added:
   trunk/gamedata/ships/shpsyrpe.txt
   trunk/source/generated/tml_wrap.cpp
   trunk/source/other/gamedialog.cpp
   trunk/source/other/gamedialog.h
Removed:
   trunk/source/games/ggob.i
   trunk/source/generated/ggob_wrap.cpp
Modified:
   trunk/gamedata/default_ini/ships/shpgarty.ini
   trunk/gamedata/python/start.py
   trunk/gamedata/python/twsaveload.py
   trunk/gamedata/ships/shpandgu.txt
   trunk/gamedata/ships/shpchebr.txt
   trunk/gamedata/ships/shpchmav.txt
   trunk/gamedata/ships/shpdruma.txt
   trunk/gamedata/ships/shpearcr.txt
   trunk/gamedata/ships/shpilwav.txt
   trunk/gamedata/ships/shpkohma.txt
   trunk/gamedata/ships/shpkzedr.txt
   trunk/gamedata/ships/shpmycpo.txt
   trunk/gamedata/ships/shporzne.txt
   trunk/gamedata/ships/shppkufu.txt
   trunk/gamedata/ships/shpshosc.txt
   trunk/gamedata/ships/shpslypr.txt
   trunk/gamedata/ships/shpspael.txt
   trunk/gamedata/ships/shpsupbl.txt
   trunk/gamedata/ships/shpumgdr.txt
   trunk/gamedata/ships/shputwju.txt
   trunk/gamedata/ships/shpvuxin.txt
   trunk/makefile
   trunk/source/generated/ggob.py
   trunk/source/other/gup.h
   trunk/source/other/nullphas.h
   trunk/source/python/python_class.cpp
   trunk/sources.lst
   trunk/web/downloads.php
   trunk/web/twplot.zip
   trunk/web/update.sh
Log:
Added new UQM ship description from uqm wiki
Fixed bug in shpgarty ini that caused not finding sound file
ggob module renamend to tml (TimeWarp Markup Language?)
added basic api for dialogs
Misk site update


Modified: trunk/gamedata/default_ini/ships/shpgarty.ini
===================================================================
--- trunk/gamedata/default_ini/ships/shpgarty.ini	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/default_ini/ships/shpgarty.ini	2005-05-05 19:42:24 UTC (rev 148)
@@ -73,8 +73,8 @@
 SpecialSample0 = sound/ships/shpgarty/WAVE_B01_WAV.wav
 
 ExtraSample0 = sound/ships/shpgarty/WAVE_C01_WAV.wav
-ExtraSample0 = sound/ships/shpgarty/WAVE_C02_WAV.wav
-ExtraSample0 = sound/ships/shpgarty/WAVE_C03_WAV.wav
+ExtraSample1 = sound/ships/shpgarty/WAVE_C02_WAV.wav
+ExtraSample2 = sound/ships/shpgarty/WAVE_C03_WAV.wav
 
 [Objects]
 ShipSprites = 1r

Modified: trunk/gamedata/python/start.py
===================================================================
--- trunk/gamedata/python/start.py	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/python/start.py	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,9 +1,17 @@
-import ggob
+import tml
 
 print &quot;Gob Start script&quot;
 
-game = ggob.GobGame.get_this()
+tml.DialogApi.startDialog()
+game = tml.GobGame.get_this()
 
+
+tup = [&quot;abc&quot;, &quot;de&quot;]
+tup2 = tml.vectorString(len(tup))
+for i in range(0, len(tup)):
+            tup2[i] = tup[i]
+tml.DialogApi.askPlayer(tup2)
+
 # System Arix
 game.add_system('Arix', 50, 50)
 game.prepare()

Modified: trunk/gamedata/python/twsaveload.py
===================================================================
--- trunk/gamedata/python/twsaveload.py	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/python/twsaveload.py	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,8 +1,8 @@
 #!/usr/bin/python
-import pickle,os,sys,ggob,copy
+import pickle,os,sys,tml,copy
 
 
-gamedata = ggob.SaveGobGameInfo.getInstance()
+gamedata = tml.SaveGobGameInfo.getInstance()
 
 class Enemy:
     def __init__(self):
@@ -36,7 +36,7 @@
         gamedata.pos_x              = self.pos_x
         gamedata.pos_y              = self.pos_y
         # enemy
-        e = ggob.vectorEnemySaveData(len(self.enemy))
+        e = tml.vectorEnemySaveData(len(self.enemy))
         for i in range(0, len(self.enemy)):
             e[i].pos_x = self.enemy[i].pos_x
             e[i].pos_y = self.enemy[i].pos_y

Modified: trunk/gamedata/ships/shpandgu.txt
===================================================================
--- trunk/gamedata/ships/shpandgu.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpandgu.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,3 +1,42 @@
-The Androsynth Guardians main weapon fires acid bubbles that slowly home in on enemies using the Chaos(tm) tracking system.  
+Guardian
 
-It's special weapon transforms it into a flaming comet, which is extremely fast and maneuverable, and inflicts damage upon impact.  
\ No newline at end of file
+Overview
+
+When the Androsynth departed Earth en masse in 2085 during the Clone Revolt, no Human had ever imagined that one could take to the stars at faster-than-light speed. Clever, cunning, and imaginative, the Androsynth outwitted their human creators at every turn by keeping low-key until an opportunity presented itself. In retrospect, it should have been no surprise that the pride of their space fleet, the dumpy little blue pod known as the Guardian, would hide something a bit more sinister inside its modest packaging, the sight of one quickly becoming the ultimate fear of all mankind.
+
+Navigation
+
+In its normal configuration, the Guardian is far from the fastest ship around, but it can still beat the pants off an Intruder. With its turning rated slightly below average and its acceleration only slightly above, the &quot;wow!&quot; factor of this ship is dismal.
+
+However, in Blazer form, the &quot;wow!&quot; factor soars higher in the sky than an Ur-Quan-imposed slave starbase. Speed? Faster than God! Turning? On the edge of a dime! Acceleration to full speed? Slightly quicker than the infamous nanosecond Syreen handjob! The only problem is that its &quot;wow!&quot; leaves as quickly as it comes. Then you're back to being your normal, puny, limping blue pod self. No puns intended.
+
+Armament
+
+Primary
+
+The Guardian's main weaponry is an acidic bubble launcher. The acid bubbles themselves are specially engineered with highly-intensified surface tension cohesion in order to survive the rigors of space. pH levels of these molecular space-mines are so acidic that no substance outside a laboratory setting has been able to withstand contact with it. The acid itself seems to sense biological material as it always heads in the direction of the nearest living object! This inorganic-guidance mechanism has been dubbed &quot;Chaos&#8482; tracking&quot; by the subject's premier reseachers. On top of that, the Guardian holds a great store of this bubble-creating acid that can be released nearly instantly without destroying the launcher or the vehicle! It still baffles scientists today as to how the Androsynth were so ingenious as to not only invent this substance, but to also build a space-faring weapon with such deadly effect to others without any detriment to itself or its crew! It is unfortunate !
 that this secret may now be lost forever...
+
+Secondary
+
+There is one of two ways to defeat an enemy in a head-on battle: be stronger or be faster. The Androsynth decided both options were best when they developed Blazer technology, and did they succeed! One tug of a rope and the Guardian sheds its crusty blue cocoon and morphs into a beautiful blazing deadly comet, which just about vaporizes anything it touches! Never mind the G-forces! This puppy gets so fast it can rip an Earthling Cruiser into shreds in seconds! Get it wedged into an Orz Nemesis and watch the fireworks ensue! Even Spathi captains try to wedge themselves deeper into their nooks when the big, bad Blazer comes a-knockin'. And they were on the same team!
+
+There are a few bugs in the system though. Once the Blazer form has been initiated, it burns up all available fuel until there is none left. And once it does that, it reverts to normal form and comes to a dead stop like it was a space-anchor. And there's no better irony than when a Guardian's captain is peeling his face off the comm-screen after his Guardian ran out of gas, only to find a nuclear missle being forcibly shoved up his exhaust diffusor!
+
+Miscellaneous
+
+The Guardian as a Symbol
+
+Below is an excerpt from P. N. Hawthorne's The Rise and Fall of the Synthetic Empire, published in 2198:
+
+    When the Androsynth blasted forth into the heavens, humanity found itself in a state of shock. How? many asked dumbly. How could they desert the hand that shaped their face? Few had understood why the wretched 'Synths would have taken such drastic action after the years of abuse from their less-than-benevolent &quot;Creators.&quot; Off they went into the sky, off into a land where they could control their own destiny, and out of the hands of every human man, woman, and child... supposedly never to be seen again. It was too late for the human race to repent for its sins; the Androsynth were gone. And when their grief finally overwhelmed them, there would be no absolution. Mankind was not able to ask forgiveness because they was no one left to ask forgiveness of. 
+
+    And when war came hurtling across the bounds of space and runneth over into Earth's threshold, and when humans were forced to face an unstoppable opponent, lo! it was an Androsynth face facing back. Their eyes shone. Their teeth glistened. They wanted pain! They wanted revenge! And they wanted blood... Their hatred fueled their return, and their cunning bolstered their resolve. 
+
+    With Androsynth warships whipping in and out and out and in across the Terran skies, appearing as quick as morning dew and disappearing into the vast darkness beyond, it was too similar to the same manner in which they had left years before! The Guardian became a symbol of true Androsynth independence: the tool with which to defeat their creators! An angelic spear of cometous fury! A Human killer! And we were lost... broken by our own creations... our own tools... our own clay... 
+
+    And in the end when the Androsynth disappeared from TrueSpace altogether, did they blast off into a new realm not only beyond the Earth and beyond the Sun but also beyond all the known Universe -- like a Guardian blazing a new path into the night sky? Or did they overexert themselves into a inescapable pit of indescribable vengeance, whose hatred outmatched their own -- like a Guardian blazed out of fuel directly next to a vengeful Scout? Or could it be that they have finally transcended and achieved the godliness that we failed at administering? 
+
+    I have wondered this for decades, but in vain. Time will never tell, for the book on the Androsynth has been closed to the human race once again. And forevermore. 
+
+    Long live the Androsynth! Long live the keepers of the Guardian! 
+    
\ No newline at end of file

Modified: trunk/gamedata/ships/shpchebr.txt
===================================================================
--- trunk/gamedata/ships/shpchebr.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpchebr.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,8 +1,23 @@
-The Chenjesu Broodhome main weapon fires crystals that keep traveling until you lift the fire button, when they explode into many small fragments.  
+Broodhome
 
-It's special weapon launches DOGIs that seek the Chenjesu's target and drain their battery.  
+The Chenjesu Broodhome, like its builders, is made almost entirely of crystal. As its name implies it is notably large and somewhat cumbersome, but in a head-on battle it is unlikely to go down without inflicting serious damage to the enemy.
 
-Chenjesu are a crystaline life form.  
+Navigation
 
-In Star Control 2, the Chenjesu were imprisoned on their homeworld with the Mmrnmhrmm before the game started, slowly transforming into Chmmr.  
+To a sessile and silicon-based race, perhaps the Broodhome seems quick and agile. Most other advanced races tend to disagree. The Broodhome is slow. Slow to move and slow to turn. It can even be difficult for an inexperienced Captain to escape a planet's gravity well. More advanced warriors know to keep their distance from their enemy and plan a careful course near the planet.
 
+Armament
+
+Primary
+
+The Broodhome's main weapon is a Crystal Shard with almost infinite range. Any Captain foolish enough to be struck by the weapon deserves the vacuous grave that he is soon to find himself in. The projectile however, like the ship itself, is somewhat slow. By the time it reaches the target, it is very likely that the target has moved. This is when the Crystal Shard's true ingenuity comes into play. Even a near miss can be turned into a serious blow because the Crystal explodes at the Captain's command, damaging anything that has yet to escape its ponderous onslaught.
+
+Secondary
+
+The Chenjesu also employ DOGI attack drones. These autonomous and (can you guess it?) slow moving craft are of sufficient mass to affect an enemy ship's trajectory when they collide with it, a feat which they excel at performing. In addition to this slight change of course, which often upsets the affected Captain's careful aim at the distant Broodhome, he will find his energy reserves being drained away and often times depleted. Lucky for him the DOGIs have a limited lifespan, but their mothership has an endless supply.
+
+Tactical Overview
+
+Keep your distance. The Broodhome is not a close range fighter. If your enemy approaches, fire off a quick stream of Crystal Shards and detonate them at zero range as it is likely that he will out maneuver any attempt at a direct hit. The more bits of glass and rock that you can put in space, the better. As soon as you get a second to collect yourself, drop a DOGI and hope it distracts him while you accelerate away.
+
+

Modified: trunk/gamedata/ships/shpchmav.txt
===================================================================
--- trunk/gamedata/ships/shpchmav.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpchmav.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,9 +1,31 @@
-The ship's main weapon consists of an uberlaser.
+Avatar
 
-Three defense satellites circle the ship. Each is equipped with a short-range auto-targeting laser.
+The Chmmr Avatar is a state of the art ship with few real foes, combining the technological prowess of the Mmrnmhrm and the Chenjesu. With medium speed and a fairly good turn-rate the Avatar shouldn't be taken lightly. Its main weapon is a strong and deadly Terra-watt laser and its tractor beam would make even the bravest enemy captain sweat. It is orbited by three Zap-satellites for point defense.
 
-The special is a tractor beam with unlimited range.
+Navigation
 
-The Chmmr are a race born of two races, the Chenjesu and the Mrmnmhrm, in an attempt to save the latter from extinction.  The Chmmr are immensely powerful, hyper-intelligent, and possibly somewhat schizophenic.  
+Built specifically for the purpose of defeating Ur-Quan vessels, the Avatar is faster and has a better turn rate than both the Dreadnought and Marauder. It is, however, quite large, and appropriate care should be taken near gravity wells.
 
-The Chmmr were slave-shielded by the Ur-Quan, but when set free provided a valuable contribution to the fight for freedom.
\ No newline at end of file
+Armament
+
+Primary
+
+Improving the X-Form's deadly lasers with crystalline technology, Chmmr Designers bring in the most devastating laser in the galaxy. Capable of rending ANYTHING to pieces in few seconds, this laser turns a face-to-face battle with the Avatar into a suicide run.
+
+Secondary
+
+The Avatar is also outfitted with a powerful Tractor Beam, capable of tractoring ships towards the Avatar's laser-jaws. Only fast-and-heavy ships can hope to evade this awsome beam. Slow ships or fast but light weighted ships (Such as the Shofixti Scout and especially the Yehat Terminator) cannot evade this powerful tractoring. Light weight ships can actually be thrown into immense &quot;hyperspacing&quot; speeds. It is quite funny to see a Terminator passing through the galaxy in speeds three and four times higher than those of a Slylandro Probe. The Arilou Skiff, being unaffected by gravity, is not affected by the Tractor beam.
+
+Additional
+
+In addition to its already formidable arsenal, three AI-Controlled laser-turrets orbit around the Avatar, providing it with point-defense against most types of attacks. Each zap-sat has 12 hit-points, and when all three are functional, the Avatar is nearly immune to weapons with 3 or less hit-points.
+
+Tactical Overview
+
+Don't mess with an Avatar. There are clearly few ships that can actually match it.
+
+Strong against: Most ships
+
+Weak against: The Kohr-Ah Marauder's F.R.I.E.D Emitters rip the Zap-sats into pieces. While the Kzer-Za Dreadnought's fighters are pointless versus the zap-sats, the Dreadnought has a better range and its fusion blasts can tear down the Avatar extremely quickly. This can be countered by the powerful Tractor Beam, though, as the Dreadnought is not fast enough to fight it. The Druuge Mauler can recoil out of laser range while pummeling the Avatar with its cannon. The Chenjesu Broodhome can prove a worthy adversary as well. The Shofixti Scout's glory device and the Androsynth Guardian in comet form prove very nasty against the Avatar. Another tactic for the Guardian is to launch small groups of bubbles and comet away to safety. This is slower than ramming with the comet, but much safer. Also, the Utwig Jugger can be a real pain to an Avatar. A highly skilled Pkunk Fury pilot can achieve some measure of success, but this is quite difficult. A Yehat Terminator, if hurled into &quot;h!
 yperspacing speed&quot; can rain fire on the Avatar but this is also not an easy thing to do.
+
+The only ship that can truly fight the Avatar with impunity is the Thraddash Torch, as its plasma afterburner acts as both a means for evading the Avatar's attacks, and destroying its satellites. 
\ No newline at end of file

Modified: trunk/gamedata/ships/shpdruma.txt
===================================================================
--- trunk/gamedata/ships/shpdruma.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpdruma.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,19 +1,27 @@
- General Overview
+Mauler
 
-One of the single most troublesome ships in the game. The Mauler is slow, ungainly reactions make it a difficult ship to play with. Mastering the correct usage of the high-recoil cannon is not easy and the slow battery regeneration turns the Mauler into a vulnerable ship. To compensate for the Mauler's weak battery recharging, Druuge captains have been known to order lower-ranking crew members to be thrown into the furnace. Yet, when correctly used against certain ships, the Mauler can prove a deadly adversary. Correct usage of recoil effects would allow for great targeting and quick evasion.
+One of the single most troublesome ships in the game. The Druuge Mauler&#8217;s slow, ungainly reactions make it a difficult ship to play with. Mastering the correct usage of the weapons is not easy and its slow battery regeneration turns the Mauler into a very vulnerable ship. Yet, when correctly used against certain ships, the Mauler can prove a deadly adversary.
 
-Main Weapon: High-Recoil Cannon
+Navigation
 
-Takes four points of battery and does six points of damage. The high-recoil cannon's fast shots can pummel an unwary enemy from long distance. The recoil itself can propel the Mauler into &#8220;hyperspacing speed&#8221; which can be a double-edged sword. The recoil-effect, combined with the Furnace, nominate the Mauler as one of the few ships that are actually DANGEROUS to a Chmmr Avatar. Aiming takes a while to master but the shots are hard to evade.
+The Mauler is a slow, plodding ship with poor acceleration and a modest turning rate. It is strongly affected by gravity wells.
 
-Special System: The Furnace
+Armament
 
-At first, this appears to be the single most useless special system available. Throwing a crewman into the furnace to fill half-way of the battery. But when thinking of the possible action &#8211; The Mauler actually never runs out of battery power. This is especially useful against the Avatar where you can use the high-recoil cannon and the supply of battery power to keep out of the Avatar's Tractor-and-Laser tactic, pummeling it to dust. Other than that, it is recommended that you be as cheap as possible on throwing people into the furnace.
+Primary
 
+The Mauler is equipped with -- or more accurately, is -- a large, high-recoil cannon. Immensely powerful, it can destroy some vessels in a single shot, and those lucky enough to survive the impact are knocked off-course by it. The recoil generated from firing can also propel the Mauler backwards to incredible speeds, which can be a double-edged sword. The awesome power of this weapon is held in check by its relatively high power usage, and the dynamos on Mauler ships, which can only be described as &quot;pathetic&quot;.
+
+Secondary
+
+To compensate for the Mauler's weak battery recharging, Druuge captains have been known to order lower-ranking crew members to be thrown into the furnace, which feeds vast amounts of energy into the combat batteries. At first, this appears to be the single most useless weapons system available, depleting your own crew in order to power your primary weapons; but it can prove quite useful in a pinch. This is especially useful against the Chmmr Avatar where you can use the high-recoil cannon and the supply of battery power to keep out of the Avatar&#8217;s Tractor-and-Laser tactic, pummeling it to dust. Other than that, it is recommended that you be as frugal as possible with your crew.
+
 Tactical Overview
 
-The Mauler is a very specific ship. It has its advantages only versus specific ships. It is very vulnerable.
+The Mauler is the sniper rifle of Star Control ships -- Proper aiming and conservation of fire are required to use it effectively. It has distinct advantages versus certain ships, but overall it is very vulnerable.
 
-Strong against: Chmmr Avatar. Shofixti Scout - The high-recoil would allow the Mauler to stay out of the Glory Device&#8217;s range and it only needs one hit to send the Scout to hell. The Ilwrath Avenger will have a hard time against it too. When flown really masterfully it can also tear ships such as the Earthling (Humans) Cruiser apart.
+Strong against: Chmmr Avatar. Shofixti Scout - The high-recoil would allow the Mauler to stay out of the Glory Device&#8217;s range and it only needs one hit to send the Scout to hell. The Ilwrath Avenger will have a hard time against it too. Its projectiles will sail right through an Umgah Drone's antimatter cone, which allows you to attack them with almost complete impunity.
 
-Weak Against: Whoa. What not? The Marauder's spinning blades, the Arilou Skiff can easily lay an ambush, the VUX Limpets, The Slylandro Probe and Pkunk Fury speed. The X-form&#8217;s long-range missiles, the Kzer-za Dreadnought]&#8217;s fighters, Chenjesu Broodhome DOGIs, the Orz Nemesis marines and the Mycon Podship Can easily wear-down the crew complement. The Utwig Jugger loves meeting the Mauler in battle. 
\ No newline at end of file
+Weak Against: Just about everybody. The Kohr-Ah Marauder&#8217;s spinning blades, the Arilou Skiff can easily lay an ambush, the VUX Limpets turn the Mauler into a sitting duck in short order, the Slylandro Probe and Pkunk Fury are nigh-impossible to hit, and must be hit multiple times in order to defeat them, the X-form&#8217;s long-range missiles and Ur-Quan Dreadnought's fighters can peck you to death, Chenjesu Broodhome DOGIs are partiularly crippling, and the Orz Nemesis&#8217; marines and the Mycon Podship Can easily wear-down the crew complement. The Utwig Jugger considers the Mauler a &quot;portable refueling platform,&quot; and an Earthling Cruiser can wipe out a Mauler starship easily with its homing guided missiles.
+
+

Modified: trunk/gamedata/ships/shpearcr.txt
===================================================================
--- trunk/gamedata/ships/shpearcr.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpearcr.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,6 +1,23 @@
-The Earthling Cruiser is a slow vessel with a devastating arsenal of weapons. A Cruiser can hold its own against other ships as long as it maintains a safe distance from its opponent.
+Cruiser
 
-The Cruiser's primary weapon is a guided nuclear missile. The missile's tracking is not perfect, but it's fairly accurate and will do a good amount of damage unless the enemy can shield itself upon impact or shoot down the missile.
+The Earthling Cruiser is a vessel of happenstance. Humanity was brought into The First War with almost no preparation. It was only their long history of proliferation that allowed this vessel to be so effective in the (ultimately losing) battle against the Ur-Quan Hierarchy.
 
-The Cruiser's alternate weapon is a point-defense laser system, based on mid-1980s &quot;Star Wars&quot; missile defense technology, that fires lasers at enemy ships, projectiles, asteroids, or anything else that is close to the Earthling ship. 
+Navigation
 
+The Cruiser is a little below average in speed but has a respectable turn rate. This compliments its weaponry well when facing off against opponents prefering a medium encounter range, notably by either closing that range or expanding it rather quickly.
+
+Armament
+
+Primary
+
+The Cruiser's primary weapon earned them quick respect in the Alliance. It's not terribly advanced, but with the number that were stored in Earth's Peace Vaults during (and before and after) Humanity's wars against itself they were a pleasant surprise to their allies and a devastating blow to their enemies. The tracking Nuclear Missile is a simple concept. Put the biggest explosive that a post-industrial nuclear society has on the end of vaguely competent tracking and navigation system; repeat several million times. This weapon has long range and can correct for significant variation in original trajectory and later enemy movement. Unless the weapon can be shot down (no mean task) or cunningly evaded, the power of the atom will be unleashed on the enemy crew.
+
+Secondary
+
+The Cruiser's alternate weapon is a very short range point-defense laser system, based on mid-1980s &quot;Star Wars&quot; missile defense technology. It fires lasers at enemy ships, projectiles, asteroids, or anything else that is close to the Earthling ship. This system is proof against daughter ships like the Ur-Quan Kzer-Za Dreadnought Fighter and Orz Nemesis Space Marine, as well as some weaker projectiles.
+
+Tactical Overview
+
+The Cruiser is highly effective when used as a stand-off ship; it is capable of delivering punishing blows from great distances, and the auto-tracking aspect of its weapons makes aiming of secondary importance. Its slow speed makes this easier said than done, however.
+
+

Modified: trunk/gamedata/ships/shpilwav.txt
===================================================================
--- trunk/gamedata/ships/shpilwav.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpilwav.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,10 +1,21 @@
-The Avengers main weapon spouts short range hellfire
-in front of the ship.
+Avenger
 
-Its special weapon turns the ship invisible.  If it
-fires while invisible it becomes visible and instantly
-aims towards the enemy ship.  
+The Ilwrath Avenger is a sinister looking ship. The only thing less comforting than seeing one is not seeing one. The Ilwrath delight in torturing their enemies and this shows in their ship design.
 
-Discrepancy: cloaking in TimeWarp is much more powerfull
-than in SC1/2 because the camera position does not
-reveal their position.  
+Navigation
+
+The Avenger is about average in terms of speed and manuverability. They tend to skulk around and wait for an opportunity to strike. The best defense, the Ilwrath have found, is not to go through the effort of dodging, but to instead allow your enemy's weapons to miss entirely through the inferiority of their targeting systems and the incompetence of their Captains.
+
+Armament
+
+Primary
+
+The primary weapon for an Avenger is a short-range flamethrower known as the Hellfire Spout. The Avenger's quick recharge rate allows it to maintain a nearly constant stream of flame. Many a crew have been cooked alive (only to suffer an excruciating death immediately afterword when their ship explodes into space dust) by the sudden application of this deadly weapon.
+
+Secondary
+
+While not a weapon per se the Ilwrath Cloaking Field is the signature device associated to their race (immediately following, of course, the various implements of pain they use on their captives). Auto-tracking weapon systems (the Earthling Cruiser Point Defense, the Spathi Eluder B.U.T.T., the Arilou Lalee'lay Skiff laser) are useless against a cloaked Avenger, as are any subsidiary craft (Orz Nemesis Space Marines, Ur-Quan Kzer-Za Dreadnought Fighters), both of which will head back to their mothership immediately. However, the system is not perfect. When the Hellfire Spout is employed the ship returns to being visible. It is not clear if this is a limitation of the system or a means of psychological warfare; the starship melee equivalent of &quot;boo!&quot; One can hardly argue the impact on a crew's morale when an Avenger uncloaks on the ship's stern with Hellfire blazing.
+
+Tactical Overview
+
+One of the more remarkable aspects of this ship is that if the player fires while cloaked, the Avenger will un-cloak pointed directly at their opponent. However, the short range of its weaponry makes this of marginal usefulness. 

Modified: trunk/gamedata/ships/shpkohma.txt
===================================================================
--- trunk/gamedata/ships/shpkohma.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpkohma.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,8 +1,25 @@
-A very powerful vessel rivaling the Kzer-Za Dreadnought. Armed with spinning sawblades and a destructive F.R.I.E.D. system.
+Marauder
 
-The sawblades will travel until the fire button is released, effectively giving them unlimited range. Ideal for placing one in the line of travel of the enemy. The blades come with a short-range homing capability.
+The Kohr-Ah Marauder is a very powerful vessel rivaling the Ur-Quan Dreadnought. It is armed with spinning sawblades and a destructive F.R.I.E.D. system.
 
-The FRIED aka Fiery Ring of Inevitable, Eternal Destruction is a ring of superheated plasma that expands from the Marauder and F.R.I.E.S. anything in its path. If a FRIED shot and an enemy projectile collide, the FRIED will always win. This property makes them good for defense. Using FRIED consumes half of the maximum battery.
+Navigation
 
-Overall, the Ur-Quan Kohr-Ah Marauder is one of the most powerful ships in the Quadrant.  
+Comparable in size, speed, acceleration and turning to an Ur-Quan Dreadnought, what the Marauder lacks in grace it more than makes up for with its devastating weapons systems.
 
+Armament
+
+Primary
+
+In combat, the Marauder launches spinning metal-blade disks with a near-limitless range and a short-range homing capability. When launched, they will travel in a given direction as long as the fire button is held down, and when it is released, they will stop and hold their position. As an enemy ship approaches, the disks will slowly close in on it, causing massive damage on contact.
+
+Secondary
+
+The &quot;Fiery Ring of Inevitable and Eternal Destruction&quot;, or F.R.I.E.D., is a ring of superheated plasma that expands from the Marauder and annihilates anything in its path. If a F.R.I.E.D. shot and an enemy projectile collide, the F.R.I.E.D. will always win. This property makes them very useful for defense. Using F.R.I.E.D. consumes half of the maximum battery.
+
+Tactical Overview
+
+Overall, the Kohr-Ah Marauder is one of the most powerful ships in the Quadrant. Its weapon systems make it an effective opponent at any range, and the primary weapon is particularly useful in &quot;setting traps&quot;; surrounding an enemy ship with blades on all sides and letting them close in.
+
+Its firing rate is slower than the Dreadnought, and its weapons do less damage, but the range and homing abilities more than make up for it.
+
+

Modified: trunk/gamedata/ships/shpkzedr.txt
===================================================================
--- trunk/gamedata/ships/shpkzedr.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpkzedr.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,6 +1,19 @@
 The Ur-Quan Kzer-Za Dreadnought is the mainstay of the Hierarchy fleets. A fully-crewed Dreadnought can crush most opponents with ease.
 
-The Dreadnought's fusion cannon can destroy small ships in one or two hits. Additionally, the Ur-Quan captain can send out small, one-man fighter ships armed with lasers to harass the enemy. Each fighter has only a limited supply of air and fuel and must return to the Dreadnought after several seconds. 
+Navigation
 
+The Dreadnought is not a fast or nimble ship. It doesn't have to be. One of these ships &#8212; never mind a full fleet of them &#8212; can lumber along and expect to defeat almost any opponent. The strength of the Dreadnought lies in its enormous firepower and considerable crew size.
 
+Armament
 
+Primary
+
+The Dreadnought's fusion cannon can destroy small ships in one or two hits. The only drawbacks to this weapon are the Dreadnought's never-quite-fast-enough turn rate and the significant amount of energy required to employ it. The second factor is mostly negligable given the Dreadnought's high energy recharge rate. So powerful is this attack that defensive systems like the Chmmr Avatar's Zap-Sat array are useless against it; it is rumored however that a fully charged Melnorme Trader Energy Bolt will win in a head-on collision.
+
+Secondary
+
+The Ur-Quan captain can also send out small, one-man fighter ships armed with lasers to harass the enemy. Each fighter has only a limited supply of life support and fuel and must return to the Dreadnought after its brief sortie. These fighters are of little use against ships equipped with auto targetting weapons (such as the Earthling Cruiser) but a sufficient swarm of them can team up to puncture an enemy hull in seconds.
+
+Tactical Overview
+
+&quot;Finesse&quot; is not a word that exists in a Dreadnought captain's vocabulary. Victory is nominally achieved through the application of superior firepower in large amounts. The relatively high firing rate on the main cannon facilitates this strategy quite nicely, but the slower-than-optimal turning rate can complicate things. Against slow ships, fighters can finish the fight before it starts, but against fast ships they're mostly useless. 

Modified: trunk/gamedata/ships/shpmycpo.txt
===================================================================
--- trunk/gamedata/ships/shpmycpo.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpmycpo.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,7 +1,27 @@
-The Mycon podship is a large medium speed, slow turning ship. It's primary weapon is a slow moving long-range homing plasma burst. It's damage decreases the longer the plasma has been in flight (as the plasma disperses). At short range, damage is very high. At long range, damage is very low. Enemy fire that strikes the plasma disperses it and reduces it's damage potential.
+Podship
 
-The secondary ability of the podship is to regrow it's own crew. It is piloted by talking fungi after all!
+The Mycon Podship is, depending on who you ask, one of the best ships in the game, or one of the worst. Its weapon systems are powerful yet cumbersome, and it's ability to regenerate its crew gives it incredible staying power. On the other hand, it's fairly slow and difficult to control, which makes it an easy target for faster ships.
 
-One other notable feature of the podship is it's ability to commit suicide by ramming it's own plasma bursts. Due to the plasma'a low speed, plasma launched in the direction of travel while the ship is at speed stand a good chance of being &quot;over-run&quot; by the ship itself. Due to the high damage of the fresh plasma, this is often fatal. Take extra care when using a gravity whip manuver.
+Navigation
 
-Certain other highly manuverable ships can also cause the plasma to strike the podship that launched it. 
\ No newline at end of file
+The Podship is a bulky, medium speed, slow turning ship with moderate acceleration. It is heavily affected by gravity wells, which can be used to great advantage.
+
+Armament
+
+Primary
+
+The Podship's weapon system is a slow, long-range, semi-sentient ball of plasma, which will relentlessly seek out enemy craft. At close range, this weapon is staggeringly powerful, but as the projectile moves through space, the plasma slowly disperses, reducing its effectiveness. Enemy fire that strikes the plasma will also disperse it and reduce it's damage potential.
+
+One notable feature of the Podship is its ability to outrun its own weapons fire. Due to the plasma'a low speed, firing while the Podship is at speed stands a good chance of hitting the ship itself. Due to the high amount of damage caused by a &quot;fresh&quot; ball of plasma, this is often fatal to the firing Podship. Make sure to shoot backwards whenever possible to avoid such unpleasantness.
+
+Secondary
+
+The secondary ability of the podship is to regrow its own crew. It is piloted by talking fungi after all!
+
+Tactical Overview
+
+Against reasonably fast and maneuverable ships, there is little that you can do. Syreen Penetrators, Zoq-Fot-Pik Stingers, Pkunk Furies and Arilou Lalee'lay Skiffs all hunt Podships for sport. A common game for them is to take down a Podship without firing a shot, instead they lead the homing plasma in such a fashion that it is turned on its owner. Yehat Terminators and Utwig Juggers can, on the other hand, approach the Podship head-on, raise shields when the predictable plasmoid comes, and discharge their guns when in range.
+
+Against slower, less maneuverable ships, the common tactic is to get up to speed (a gravity whip will do nicely), fire a couple of shots at close range, then fly away and regenerate any crew lost. Lather, Rinse, and Repeat.
+
+

Modified: trunk/gamedata/ships/shporzne.txt
===================================================================
--- trunk/gamedata/ships/shporzne.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shporzne.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,21 +1,25 @@
- General Overview
+Nemesis
 
-Always a worthy adversary. Underestimating the Nemesis would likely be the last mistake anyone can ever make. Like its name suggests, the Orz ship is a goddess of revenge, coming to inflict pain and vengeance on the galaxy. The Nemesis is fairly quick and has a fair turn-rate. Never, under any circumstances, chase after the nemesis!
+Underestimating the Orz Nemesis would likely be the last mistake anyone can ever make. Like its name suggests, this ship is a goddess of revenge, coming to inflict pain and vengeance on the galaxy. Never, under any circumstances, chase after the Nemesis!
 
-Main Weapon/Special system: Rotating Howitzer
+Navigation
 
-The Howitzer inflicts deadly damage and its shots are fast and medium-ranged. The rotational turret allows usage as a strafing weapon or as a backwards utilized attacker-repellent.
+The Nemesis is fairly quick, has a fair turn-rate and good acceleration. Its relatively large footprint makes dodging incoming fire difficult, although not impossible.
 
+Armament
 
-Special Action: Marines (GoGos)
+Primary
 
-Using their armored exo-skeleton, Orzine marines exit the ship from the aft portholes and enter an enemy ship by burning a hole in the hull. They then start roaming the enemy ship&#8217;s corridors, killing every crewman in sight. Especially useful in large groups, the marines can blast a ship entirely by themselves. Warlike creatures such as Ur-Quan, Chmmr, Yehat and Shofixti usually put up a better resistance than peaceful or cowardly creatures like the Spathi, Chenjesu and Mycon. The marine tactic of using a planet wrap-around slingshot maneuver to gain speed aids them against some ships.
+The Nemesis is armed with a moderately powerful howitzer cannon which is remarkable in that it can be rotated to different firing positions during combat by holding the secondary weapon button while using the turning controls. The rotational turret allows usage as a strafing weapon or as a backwards utilized attacker-repellent. The energy costs of this weapon are rather large, however, and it can only fire volleys of two or three shots at a time.
 
+Secondary
+
+Aboard each Nemesis vessel is a squad of Space Marines, which are launched by holding down the secondary weapon button while pressing the fire button. Encased in vacuum-fitted exo-skeletons, these relentless soldiers use their jet packs to chase down enemy ships, and then burn entry holes through their hulls. Once inside the enemy ship, the Space Marines employ basic search-and-destroy tactics, wreaking havoc on the soft targets within. When an enemy ship is destroyed, any Marines onboard will jet out of the exploding hulk, and return to the Nemesis for more fuel and ammunition. Opponents would be wise to remember that Space Marines receive training in using the Leyland Gravity Whip maneuver, and are exceptionally adept using a planet's gravity to speed them toward their target.
+
 Tactical Overview
 
-A very effective ship that rarely fails.
+A very effective ship that rarely fails, although prolonged combat against multiple opponents can take a heavy toll.
 
-Strong against: Kzer-Za Dreadnought and to some degree Kohr-Ah Marauder are both in danger. The Chenjesu Broodhome is virtually helpless against the marines as is the VUX Intruder and the Mycon Podship. The marines cling on to the Yehat Terminator until the shield goes down and while they are repelled by the Utwig Jugger Shield, no fuel is gained and so they can be used to take down the Jugger&#8217;s shield. Showing the Chmmr Avatar your aft and blasting her with the howitzer is a tricky thing but the Nemesis can break through the tractor beam and as soon as the Zap-sats are down, the Avatar is marine-meat
+Strong against: Ur-Quan Dreadnought and to some degree Kohr-Ah Marauder are both in danger. The Chenjesu Broodhome is virtually helpless against the marines as is the VUX Intruder and the Mycon Podship. The marines bounce off the Yehat Terminator and Utwig Jugger's shields, but in the latter case, no energy is fed to their batteries by the impact, so they can be used to take down the Jugger&#8217;s shields quite easily. Showing the Chmmr Avatar your aft and blasting her with the howitzer is a tricky thing but the Nemesis can break through the tractor beam and as soon as the Zap-sats are down, the Avatar is marine-meat
 
-Weak against: The Pkunk Fury, Slylandro Probe and Arilou Skiff can effortlessly pull out of marine&#8217;s grasp and use hit-n-run attacks to whack the unready Nemesis. The Androsynth Guardian is a bit tricky &#8211; if she get stuck without battery she&#8217;s Marine-meat but the Comet form destroys marines on impact and the Nemesis&#8217;s aft section appears to have been designed exactly to be wedged by a wicked blazer. So long as they manage to evade the marines, The X-form and the Spathi Eluder can pose a pain in the butt to any Nemesis captain. A very hot Shofixti Scout pilot can evade the marines long enough to use a wrap-around slingshot maneuver to catch the Nemesis unaware.
-
+Weak against: The Pkunk Fury, Slylandro Probe and Arilou Skiff can effortlessly pull out of marine&#8217;s grasp and use hit-n-run attacks to whack the unready Nemesis. The Androsynth Guardian's Blazer form destroys marines on impact, and the bubbles provide an excellent defensive screen, and the Nemesis&#8217;s aft section appears to have been designed exactly to be wedged by a wicked blazer. So long as they manage to evade the marines, The X-form and the Spathi Eluder can pose a pain in the butt to any Nemesis captain. A very hot Shofixti Scout pilot can evade the marines long enough to use a wrap-around slingshot maneuver to catch the Nemesis unaware. 

Modified: trunk/gamedata/ships/shppkufu.txt
===================================================================
--- trunk/gamedata/ships/shppkufu.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shppkufu.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,26 +1,27 @@
-The Pkunk Fury is one of the original ships
-from Star Control 2.  They were allies in SC2.  
+Fury
 
-Their main weapon consists of a 3-way cannon 
-that fires molten metal.  
+The Pkunk Fury is often considered to be one of the weakest ships in the quadrant. Despite the fact that the ship isn't very powerful in terms of crew or battery capacity, the speed and turning rate can make it the best fighter in the game when in the hands of a skilled pilot. The pivotal role the Fury played in the battle of the Sa-Matra shows that it can be highly dangerous, if used properly.
 
-Their special weapon is to insult the enemy.  
-They must insult the enemy to recharge their 
-batteries.  
+Navigation
 
-An additional passive ability that they have 
-is to resurrect themselves when they die.  This 
-ability doesn't always work, but when it does 
-work it can be extremely annoying.  Imagine 
-shooting down the same enemy ship, over and 
-over and over again.  
+There are few things in space faster than a Pkunk Fury. Some special movement modes &#8212; the Thraddash Torch Afterburner and Umgah Drone Reverse Thruster &#8212; can out run it, but none of them can maneuver like the Fury at that speed. The Fury has turning radius that can almost dodge an auto targetting laser.
 
-The Pkunk, as a race, are themed heavily along 
-&quot;new age&quot; lines.  They're probably into to 
-crystal power, herbal remedies, psychics, 
-getting in touch with your inner child, etc.  
-And their psychic stuff really works... maybe...
+Armament
 
-The Pkunk are a bird-race closely related to 
-the Yehat, though they have very different 
-personalities.  
+Primary
+
+The primary weapon is a triple mounted minigun that fires forward and to both flanks. They pump out super-heated metal pellets at an incredibly fast rate. The range of the weapon is very limited, since the pellets cool off rapidly. Although their short range can be written off as a weakness, the combat effectiveness of the Fury should not be underestimated. One strategy used by Fury pilots is &quot;the ring of death&quot; (not to be confused with with the Kohr-Ah Marauder's FRIED emitter). This move is executed by firing and turning at the same time. When done properly, the dense circle of shots can tear up any ship, marine, or projectile in range. It also looks pretty.
+
+Secondary
+
+Unlike most ships, the Fury has no fuel generator. Their method of creating fuel is odd, indeed &#8212; the Pkunk can transform their psychic energy into heat and/or electricity by insulting their opponents. The Pkunk crew will insult your foe, creating fuel manually. Although you can't offend your opponent having 100% energy, it is a common tactic to shoot one pellet somewhere away and regenerate, just to provoke your enemy. Since the Fury is one of the fastest ships in the game, such provocation usually ends with the enemy being dotted with molten metal.
+
+Additional
+
+Since the Fury has minimal crew capacity, a few well-aimed shots can annihilate the Fury instantly. After a fury is destroyed, there is a small chance that the Fury will be reborn &#8212; fully crewed and with maximum energy. Due to the unpredictable nature of Fury reincarnation, a lucky Pkunk can be reborn multiple times. Having to fight the same ship over and over again can make even the most patient pilot go berserk.
+
+Tactical Overview
+
+The Fury can be a dangerous foe, mostly against slow and unmaneuverable ships. The VUX, for instance, can be ripped to shreds with proper timing and technique. However, many ships like the Utwig Jugger can stop moving and start firing in the directon of the Pkunk, in which case, the Fury has no way to attack. This tactic, known as pillboxing, works well against most short-ranged ships.
+
+

Modified: trunk/gamedata/ships/shpshosc.txt
===================================================================
--- trunk/gamedata/ships/shpshosc.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpshosc.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,19 +1,23 @@
-The Shofixti Scout is one of the original ships
-from Star Control 1.  They were on the Alliance side.
+Scout
 
-They were uplifted by the Yehat and thus joined the
-honorable side.
+The Shofixti Scout is a small, speedy ship, whose outwardly weak appearance masks a great and devastating power.
 
-Main weapon fires a short range dart.
+Navigation
 
-The special blows up your ship, the so-called Shofixty
-blaze of Glory. This does considerable damage to
-opponents in the neighbourhood.
+The Scout is a small, fast, maneuverable ship with excellent acceleration. Gravity wells do not affect it much, but collisions with asteroids can knock it wildly off-course. It is remarkably susceptible to the Chmmr Avatar's tractor beam attack.
 
-The Shofixti are a feral species.
+Armament
 
-They were nearly extinct after blowing up the outer
-layer of their sun to destroy an Ur-Quan fleet. The
-player is able to find a few survivors, whom repopulate
-the species - giving cheap crew.  (Shofixti breed VERY 
-fast)
+Primary
+
+The Scout is equipped with the Mendokusai Energy Dart, a weak, forward-firing projectile with a short-to-medium range and a fast firing rate. This is held in check by the puny combat batteries aboard the vessel.
+
+Secondary
+
+When faced with failure or defeat, each Scout vessel is equipped with a &quot;Glory Device&quot;; a powerful bomb capable of inflicting massive damage to an enemy vessel at close range. Unfortunately, detonating the &quot;glory device&quot; is fatal to everyone aboard the Scout vessel when the device is activated. To prevent accidental activation, the secondary weapon must be pressed three times. A series of switches is visible in the melee screen so that pilots may see if the bomb is ready to go, or not.
+
+Tactical Overview
+
+Against a VUX Intruder, this vessel is all but unstoppable. It can outrun the ship, it can outrun the limpets, and its weapon has a greater range than its opponent. Circle the enemy, raining fire upon it, until victory is yours.
+
+Against everybody else, the Scout is pretty much a &quot;dead man walking&quot;, but proper use of the &quot;glory device&quot; can sap the strength of the enemy ship so that others may have an easier time destroying it. 

Modified: trunk/gamedata/ships/shpslypr.txt
===================================================================
--- trunk/gamedata/ships/shpslypr.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpslypr.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,22 +1,57 @@
+Probe
 
-The Slylandro Probe is one of the original ships
-from Star Control 2.
+The Slylandro purchased their first Probe from the Melnorme for exploration purposes, with the intent to use them for making peaceful contact with other races. Since it had the ability to replicate itself, they modified its program code so that replication became its overriding first priority.
 
-The main weapon consists of a lightning strike.
+The repercussions of this foolhardy action were grave. Not only were there probes that attempted to break friendly ships into component pieces for use in replication, but they multiplied at an exponential rate, becoming a servere hazard to any hyperSpace traveler.
 
-The special can be used near asteroids - this destroys
-the asteroid and instantly fills up the battery. This
-is the only way to refuel.
+The Captain put a stop to this when he made contact with the Slylandro. When they learned what had happened, they gave The Captain a code that would cause probes to self-destruct in case he encountered one, and began reprogramming all returning probes to roam the quadrant broadcasting the self-destruct code on a HyperWave hailing frequency, which caused a swift decline in their numbers (to everyone's great relief).
 
-Robotic automated scouts.
+Navigation
 
-In star control 2 they formed an annoying threat to the
-player. The probes could pop up anywhere only to contact
-and attack a ship. They were running a program on steroids,
-which could lead to a universe dominated by probes, devouring
-everything for their reproduction. The geniuses behind
-the probes are the Slylandro, a gentle race living in a
-gas giant. Otherwise unable to enter space, they'd use the
-probes to gather knowledge about their surrounding space.
+Unlike any other ship, the probe is always in motion. Pressing the thruster immediately reverses the Probe's direction. The control scheme is tricky to learn, but the advantages of having such a nimble ship should not be overlooked.
 
+The ship has hit points, but no actual crew. This makes it impervious to the Syreen Penetrator's secondary attack.
 
+Armament
+
+Primary
+
+When attacking, the Probe discharges several bolts of lightning directed at its target. The lightning is very short-ranged, which makes for a difficult learning curve when coupled with the Probe's unorthodox controls.
+
+Secondary
+
+Unlike most vessels, the probe does not generate its own fuel. Instead, it uses its secondary armament to break down nearby asteroids into raw materials which it then feeds into its combat batteries. One asteroid contains enough raw materials to completely replenish a probe's fuel reserves.
+
+Tactical Overview
+
+Given the difficulty in mastering the controls, not a lot of players have spent the time researching good tactics for this ship. The primary fighting technique employed by pilots of this ship seems to be: close in, evade incoming fire, empty the combat batteries, then zip off to find an asteroid in order to replenish the batteries. Repeat.
+
+Miscellaneous
+
+Programming
+
+The Probe's internal set of instructions is replicated here:
+
+   SCAN (for targets, as defined in Target List).
+   IF (no current target).
+   THEN (select New target from Current Targets list, using specified priorities).
+   IF (Current Position is AT Current Target).
+   THEN (Set Current Behavior to New Behavior, based on Behavior Priority Settings).
+   PERFORM (Current Behavior).
+
+The Probe used the following datatables:
+
+   TARGET LIST (with associated Target Priority).
+       Space Vessel (5).
+       Transmission Source (4).
+       Astronomical Anomaly (3).
+       Planet Bearing Life Signature (2).
+       Raw Replication Materials (1).
+   PROBE BEHAVIORS (With assigned priorities).
+       Communicate (5).
+       Record Data (4).
+       Analyze Data (3).
+       Seek Replication Materials (999).
+       Move to Current Target (1).
+
+It was the skewed priority of the 'Seek Replication Materials' behavior that led to the Probe's unnatural hostility.

Modified: trunk/gamedata/ships/shpspael.txt
===================================================================
--- trunk/gamedata/ships/shpspael.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpspael.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,9 +1,11 @@
-Overview
+Eluder
 
-The multi-colored Spathi Eluder, formerly known as the Discriminator, remains bulk of the Spathi fleet even 20 years after the War. Its construction, though seemingly chaotic, is carefully designed to mimic its crew's natural attributes: paranoia, elusiveness, and cowardice.
+The multi-colored Spathi Eluder, formerly known as the Discriminator, remains the bulk of the Spathi fleet even 20 years after the War. Its construction, though seemingly chaotic, is carefully designed to mimic its crew's natural attributes: paranoia, elusiveness, and cowardice.
 
-Speed and Control
+From the outside, the Eluder consists of many bubble-shaped, solid-colored cabins joined together by smaller white corridors. The intention of having so many large seemingly crew-filled projections is in part to obfuscate enemy into targeting the decoy cabins and to direct enemy fire away from the main bridge. However, in practice, enemy weapons seem to incapacitate the same amount of crew no matter where the Eluder is damaged. This is most likely due to the fact that even in the safety of a large starship, the crew is bound to hide in every nook, cranny, and hole the ship has to offer in the case of direct combat. And, unfortunate for the Spathi, there are many of these crannies throughout the ship as it was Spathi engineers who designed it to begin with, making the deceptively non-crew-filled decoy cabins actually full of petrified crew members. To make matters worse, even the crew itself can be confused by the ship layout. In fact, the random cabin configuration has fool!
 ed many a green-eared Spathi captain who haven't grown used to the ship's odd design, especially as they're slinking away from the bridge during particularly nasty, or even mildly &quot;scary,&quot; dogfights.
 
+Navigation
+
 The Eluder is one of the fastest ships in the galaxy, both in top speed and acceleration, and has a turning radius an Arilou Lalee'lay would be jealous of. Though agility would be a mighty boon for most brute-force fighter ships, the Eluder is anything but brute... or a force... or even a fighter, for that matter. The fact is the thrusters primary use isn't for speeding into battle, but rather for speeding away from it! From this perspective, the Eluder performs admirably! The helm of the Eluder is quite large and is typically manned by two Spathi at once, but in times of emergency (mainly when he's the only crew member left) the captain usually whips into a adrenaline-filled panicked frenzy and finds the ability to man both halves of the helm nearly simultaneously by himself!
 
 Armament
@@ -16,13 +18,16 @@
 
 The secondary weaponry epitomizes the essence of true Spathi-ness due to its ability to do the most damage while the Eluder is in full retreat! The Backwards Utility Tracking Torpedo (B.U.T.T.) is a medium-range, low-impact conventional space torpedo with a good automated guidance system and moderate speed and manuevering. Fired from the rear of the craft, B.U.T.T. missiles do most of the dirty work in the dogfights as Eluders make their way away from the fray. Enemy captains foolish enough to think it can run down an Eluder usually end up learning a fatal lesson in space warfare.
 
-Ship Layout and Design
+Tactical Overview
 
-From the outside, the Eluder consists of many bubble-shaped, solid-colored cabins joined together by smaller white corridors. The intention of having so many large seemingly crew-filled projections is in part to obfuscate enemy into targeting the decoy cabins and to direct enemy fire away from the main bridge. However, in practice, enemy weapons seem to incapacitate the same amount of crew no matter where the Eluder is damaged. This is most likely due to the fact that even in the safety of a large starship, the crew is bound to hide in every nook, cranny, and hole the ship has to offer in the case of direct combat. And, unfortunate for the Spathi, there are many of these crannies throughout the ship as it was Spathi engineers who designed it to begin with, making the seemingly crew-filled decoy cabins actually full of petrified crew members. To make matters worse, even the crew itself can be confused by the ship layout. In fact, the random cabin configuration has fooled man!
 y a green-eared Spathi captain who haven't grown used to the ship's odd design, especially as they're slinking away from the bridge during particularly nasty dogfights.
+An Eluder is a coward&#8217;s ship, designed by a coward, built by cowards and flown by cowards. There are only two types of Eluder Captains: The Brave Dead and The Living Cowards. Never meet face-to-face with a foe. The Eluder will never be able to Hammer, Pummel, Blow or Smite an enemy. The Eluder must wear its enemy down little by little. An effective Spathi tactic is showing them your butt and then giving them your B.U.T.T.s.
 
-Miscellaneous
+Strong Against: The Eluder is capable of wearing down the Ur-Quan Dreadnought easily. When facing (or running away from) a Kohr-Ah Marauder there is the &#8220;Plibnik Maneuver&#8221; &#8212; run away in a straight course, sidestepping spinning wheels and whenever you go beyond B.U.T.T. range, make a complete circle (Turn+Acceleration) to allow her to return into range before continuing in the former course. Slylandro Probes can be tricked into chasing the Eluder in a straight path, allowing B.U.T.T.s to be used at will. Mycon Podships have a hard time handling the Eluder, especially if you can force them to swallow their own Plasmoids.
 
-A small note should be added that it may be possible that perhaps a few jet-black Eluders exist. The legends of the Black Spathi Squandron, lead by a small band of courageous, brave Spathi rebels, who attempt to lead its brethren to freedom, have been passed down for several generations. However, the credibility of this legend is dubious at best seeing as how even the most courageous Spathi in the known universe are little short of &quot;completely terrified.&quot; 
+Weak Against: Fast ships such as the Pkunk Fury and Slylandro Probe and naturally the Chmmr Avatar whose zap-sats render the the B.U.T.T.s completely useless.
 
+Miscellaneous
 
+Rumors
 
+A small note should be added that it may be possible that perhaps a few Eluders exist that are painted all black with red stripes. The legends of the Black Spathi Squadron, lead by a small band of courageous, brave Spathi rebels, who attempt to lead its brethren to freedom, have been passed down for several generations. However, the credibility of this legend is dubious at best seeing as how even the most courageous Spathi in the known universe are little short of &quot;completely terrified.&quot; 

Modified: trunk/gamedata/ships/shpsupbl.txt
===================================================================
--- trunk/gamedata/ships/shpsupbl.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpsupbl.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,19 +1,25 @@
- General review
+Blade
 
-The Blade is a largely underrated ship. It's rapid fire capability can pound an unwary enemy and the lateral thrusting, when properly used, is nearly as good as the Arilou Hyperspace shunts in evading shots. The Blade is quick and agile with a fair turn-rate, allowing it to considerably hamper enemy targeting efforts. Its slender form makes it harder to hit her.
+The Supox Blade is a largely underrated ship. Its rapid fire capability can pound an unwary enemy and the lateral thrusting, when properly used, is nearly as good as the Arilou Skiff's Hyperspace shunts in evading shots.
 
-Main Weapon: Sprout Gun
+Navigation
 
-The rapid-fire Sprout Gun may cause small damage but it sure fires fast. Even when out of battery, the gun&#8217;s firing rate remains high and it's range, equaling the Ur-Quan Kzer-Za Dreadnought and the Syreen Penetrator can prove deadly.
+The Blade is quick and agile with a fair turn-rate, allowing it to considerably hamper enemy targeting efforts. Its slender form makes it harder to hit her.
 
-Special System: Lateral Thrusting System
+Armament
 
-It takes a hell lot of practice to master the tricky Lateral Thrusting System but when correctly used, the Lateral Thrusting can be used to sidestep shots or strafe into a firing position. Especially effective against slow-firing ships such as the Dreadnought or Kohr-Ah Marauder.
+Primary
 
+The rapid-fire Sprout Gun may cause small damage but it compensates for this with a high firing rate. Even when out of battery, the gun&#8217;s firing rate remains high and it&#8217;s range, equaling the Ur-Quan Dreadnought and the Syreen Penetrator, can prove deadly.
+
+Secondary
+
+The Blade is outfitted with a Lateral Thrusting System which enables it to change course without the need to turn. It takes a lot of practice to master the tricky Lateral Thrusting System, but when correctly used, it can be used to sidestep incoming fire or strafe into a firing position. It is especially effective against slow-firing ships such as the Dreadnought or Kohr-Ah Marauder.
+
 Tactical Overview
 
-The Blade is a fair adversary that shouldn't be taken lightly.
+The Blade is a fair adversary that shouldn&#8217;t be taken lightly.
 
-Strong against: Syreen Penetrator, Kzer-Za Dreadnought, VUX Intruder, Ilwrath Avenger, Utwig Jugger.
+Strong against: Ur-Quan Dreadnought, VUX Intruder, Ilwrath Avenger, Utwig Jugger. The Chmmr Avatar can neutralize almost all incoming projectiles, but it is possible for a skilled and patient Blade captain to wear down the Zapsats, and once they are gone, the superior range of the Blade's weapons will win the day.
 
-Weak against: Chenjesu Broodhome The crystalline shards put the Lateral-Sidestepping into a real problem. Arilou Skiff, Slylandro Probe and Pkunk Fury can convey quick hit-n-run attacks on the Blade. Chmmr Avatar. 
+Weak against: Chenjesu Broodhome &#8211; The crystalline shards put the Lateral-Sidestepping into a real problem. Arilou Skiff, Slylandro Probe and Pkunk Fury can convey quick hit-n-run attacks on the Blade. 
\ No newline at end of file

Added: trunk/gamedata/ships/shpsyrpe.txt
===================================================================
--- trunk/gamedata/ships/shpsyrpe.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpsyrpe.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -0,0 +1,27 @@
+Penetrator
+
+The Syreen Penetrator is lightly crewed and not terribly powerful in terms of offensive weaponry, but it is able to use &quot;wiles&quot; strengthen itself while weakening enemy ships. It is unique in its ability to come out of battle stronger than when it went in.
+
+Navigation
+
+The Penetrator has a good turn-rate and a fair speed but suffers from a somewhat lacking acceleration. Its shape, center of gravity and turn-rate can be masterfully combined into a Wrap-Around thrust maneuver, during which the Penetrator circles a planet until it found the direction it wants to use a Gravity-whip maneuver.
+
+Armament
+
+Primary
+
+The Penetrator's primary weapon is a weak, forward-firing weapon with a fair range and acceptable firing rate. Normally used for nothing but finishing off a Psi-resistant captain.
+
+Secondary
+
+To compensate for its lack of offensive power, the Penetrator captain employs the &quot;Syreen Song&quot;, a short-range hypnosis field designed to lure enemy crew from their ships via the airlocks. If the Penetrator picks up the crew, they will willingly serve alongside the Syreen as members of the Penetrator's crew; if the enemy ship reclaims their crew, they are able to counteract the effects of the hypnosis field -- at least for a while. During the war, crews on board Syreen ships became a surreal pastiche of alien races, with Ilwrath, VUX, Spathi and others working dutifully side by side with human volunteers under the command of beautiful Syreen officers.
+
+The &quot;Syreen Song&quot; has no effect on non-sentient beings like the Slylandro Probe.
+
+Tactical Overview
+
+Against most ships, the tactic is pretty straightforward -- close in quickly, evade incoming fire, and use the &quot;Syreen Song&quot; to bolster your ranks and weaken the enemy's. Once you have made the enemy's crew your own, finish them off with a few quick shots. Slow ships are the preffereable targets for Penetrator captains. Ships with good turn rates and/or good firing rates are what Syreen captains fear
+
+Strong Against: Mycon Podship - The Penetrator can outrun a plasmoid but only if already at it's best speed. If the Mycon try to regenerate lost crew, the Penetrator should hold patiently and let the Mycon send more crewmen - or Crew-Fungi - prey for the Syreen Song. Chenjesu Broodhome ships are quite pained, trying to keep the Penetrator off their back. Earthling Cruisers may have a good turning rate but once the initial Dual missile barrage is off, the dismal recharge-rate usually forces the Cruiser captain into a &quot;Scorched Earth&quot; tactic - Point-defense Lasering his own crew rather than seeing them onboard the penetrator. The slick penetrator easily dodges the cumbersome nukes. When mastered, the art of evading the Kohr-Ah spinning blades, can launch a nasty surprise to the over-confident Marauder captain.
+
+Weak Against: Ships like the Shofixti Scout with it's glory device or fast-turning, quick firing ships such as the X-form in Laser mode, the Utwig Jugger and the Yehat Terminator 

Modified: trunk/gamedata/ships/shpumgdr.txt
===================================================================
--- trunk/gamedata/ships/shpumgdr.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpumgdr.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,22 +1,21 @@
+Drone
 
-The Umgah Drone is one of the original ships
-from Star Control 1.  They were on the Alliance side.
+The Umgah Drone has all the wit and subtlety of its makers. That is to say, even they think it's funny. The drone is a study in the unexpected. At one moment it can be slowly moving away, only to reverse direction at a speed to make even an Arilou's head spin. Its front looks like its back and when its weapon system comes on line, well, then everyone stops laughing. Usually because they've been annihilated at the molecular level.
 
-The Umgah were battle thralls of the Ur-Quan.
+Navigation
 
-The main is a powerful antimatter cone, having very
-short range, but being able to rapidly inflict damage
-to objects entering it. It forms an almost impenetrable
-forward-facing shield.
+The Drone turns slow and slowly accelerates to a slow maximum speed when using its normal propulsion system. This is generally used for delicate maneuvering and is not of much use in combat.
 
-The special allows the Drone to fly rapidly
-backwards. Very useful to intercept enemies.
+Armament
 
-The Umgah are a self-bio-engineered race of creeps.
+Primary
 
-In star control 2, the Umgah are the pranksters
-of space, playing dirty tricks on races for laughs.
-They were responsible for reviving a Dnyarri, using
-their superior bi-engineering skills.
+The front of the vessel houses a massive anti-matter vent, which controls the ship's primary weapon- the anti-matter cone. When the cone is activated, it produces a barrier that arcs in front of the vessel damaging anything it contacts. The cone is powerful enough to stop most projectiles, but it is largely ineffective as a shield due to the Drone's slow turing rate. The anti-matter cone does not consume fuel, but the Drone will not regenerate fuel while the cone is active.
 
+Secondary
 
+The Drone's retro-propulsion system allows it to move in reverse very quickly. It can be used to catch enemy ships off-guard during a dogfight and trap them in its anti-matter cone, as well as propelling the drone to safety from amidst the heat of battle. While travelling in reverse &quot;zip&quot; mode, the drone is not affected by gravity and loses all momentum when the retro-propulsion system is deactivated. The system consumes fuel rapidly, so it is most effective when used tactically (rather than casually).
+
+Tactical Overview
+
+The Drone has a unique system for regenerating fuel. Instead of gaining one unit at a time, its reserves are completely replenished after a set period of inactivity. If the drone uses its retro-propulsion system or its anti-matter cone, the timer will be re-set. The Drone is particularily vulnerable while it is waiting to reload. (Note: Use of regular thrusters will not reset the timer). 

Modified: trunk/gamedata/ships/shputwju.txt
===================================================================
--- trunk/gamedata/ships/shputwju.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shputwju.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,5 +1,25 @@
+Jugger
+
 The Utwig Jugger is one of the most dangerous ships in the quadrant, thanks to its unique weapons and shield systems.
 
-The Jugger's weapon is an array of six cannons that do not draw energy from the main batteries. With a moderate rate of fire and damage, a Jugger can obliterate most other ships with a few salvos.
+Navigation
 
-The Jugger's shields consume energy when used, but they draw energy from enemy attacks. Therefore, a skilled Jugger pilot who uses his shields only when necessary can keep his batteries fully charged and minimize damage to his ship. 
\ No newline at end of file
+The Jugger is suprisingly fast for its size, although its acceleration is weak. But it is also outfitted with a set of amazingly powerful turning jets, and is capable of coming about as quickly as a vessel less than half its size.
+
+Armament
+
+Primary
+
+The Jugger's main weapon is an array of six forward-facing cannons powered by an extremely efficient combat dynamo system. With it, the cannons have a virtually limitless supply of energy, and are able to fire without drawing any energy from the combat batteries. With a moderate rate of fire and damage, a Jugger can obliterate most other ships with a few salvos.
+
+Secondary
+
+The Jugger is equipped with a unique shielding system. It is capable of absorbing an almost limitless amount of punishment from both kinetic and energy-based attacks, and it in fact converts this energy for storage in its combat batteries! However, with the combat dynamo devoted to the primary weapons, it is not capable of replenishing energy on its own, so if the combat batteries run out, the shields are knocked offline. After a battle, the crew of the Jugger can feed energy from the main weapons systems into the batteries, but the process is imperfect, yielding roughly 50% of their capacity.
+
+Tactical Overview
+
+The Jugger's shields consume energy when used, but they absorb energy from enemy attacks. Therefore, a skilled Jugger pilot who uses his shields only when necessary can keep his batteries fully charged and minimize damage to his ship. A corollary to this is that one sould keep an eye on &quot;skirmisher&quot; weapons that require more energy to shield against than will be regained by shielding against them. Such weapons can slowly bleed the batteries dry, leaving captains in a vulnerable position.
+
+The Jugger's massive size and poor acceleration make gravity wells particularly dangerous, since at full speed they can be difficult to avoid. This, combined with the excellent turning rate of the ship and unique weapons systems, make pillboxing a wildly popular tactic.
+
+When fighting a computer-controlled Ur-Quan Dreadnought or Kohr-Ah Marauder, a most effective strategy is a full-on frontal assault. The computer makes a policy of firing as fast as it can, so on approach, absorb all the punishment they can dish out, and when their fuel tanks run dry, take a potshot or two from point-blank range. As soon as they get enough energy to fire back, they will, so keep the shields at the ready, and whittle them down to nothing with impunity. 

Modified: trunk/gamedata/ships/shpvuxin.txt
===================================================================
--- trunk/gamedata/ships/shpvuxin.txt	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/gamedata/ships/shpvuxin.txt	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,9 +1,25 @@
-The VUX Intruder is both incredibly slow and hard to turn, but it compensates for this by utilizing limpet mines to slow down enemy vessels.
+Intruder
 
+The VUX Intruder is both incredibly slow and hard to turn, but it compensates for this by utilizing limpet parasites to slow down enemy vessels.
+
+Navigation
+
+The Intruder is a painfully slow ship with a low turning rate. But it is rather massive, and is greatly accelerated by a gravity whip maneuver.
+
 The Intruder is fitted with a unique warp system that enables it to warp in fairly close to an enemy ship. With luck, an Intruder can inflict serious damage on the other ship before it manages to get away.
 
-Intruders are armed with a gigawatt laser that can slice through any ship in a matter of seconds.
+Armament
 
-The VUX's limpet mines home in on an enemy ship and stick to its hull, slowing it down. One or two mines will not greatly affect a ship's speed, but more than that will slow it down to the point where an Intruder can run circles around it.
+Primary
 
-A favorite tactic of veteran VUX pilots is to gravity whip as soon as possible, then start dropping limpets when they fly past the enemy. 
\ No newline at end of file
+Intruders are armed with a powerful gigawatt laser that can slice through any ship in a matter of seconds. Its modest range and high energy consumption demand a certain amount of skill in order for it to be used effectively, however.
+
+Secondary
+
+An additional Intruder offensive weapon is the &quot;Limpet,&quot; which launches inside a protective cocoon which automatically targets enemy vessels. Upon nearing a target, the cocoon cracks, releasing the limpet to clamp down upon the enemy vessel's hull. The combination of inflicted damage and added mass decreases a starship's maneuverability. Only after battle can a damaged ship remove the offending limpets.
+
+Tactical Overview
+
+A popular (and effective) tactic with the Intruder is to assume a standoff position and coat the enemy ship with so many limpets that it is effectively immobile, then close in from behind and finish them off. A well-timed gravity whip can assist in this strategy greatly.
+
+

Modified: trunk/makefile
===================================================================
--- trunk/makefile	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/makefile	2005-05-05 19:42:24 UTC (rev 148)
@@ -169,9 +169,9 @@
 	./$(NAME) -test
 
 
-source/generated/ggob_wrap.cpp: source/games/ggob.i source/games/ggob.h
-	swig -c++ -python -o source/generated/ggob_wrap.cpp source/games/ggob.i
-	cp source/generated/ggob.py $(DATAPATH)/python/
+source/generated/tml_wrap.cpp: source/python/game.i source/games/ggob.h
+	swig -c++ -python -o source/generated/tml_wrap.cpp source/python/game.i
+	cp source/generated/tml.py $(DATAPATH)/python/
 
 
 $(OBJDIR)/%.o: %.cpp

Deleted: trunk/source/games/ggob.i
===================================================================
--- trunk/source/games/ggob.i	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/games/ggob.i	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,13 +0,0 @@
-%module ggob
-%{
-#include &quot;games/ggob.h&quot;
-%}
-%include &quot;std_string.i&quot;
-%include &quot;std_pair.i&quot;
-%include ggob.h
-
-%include &quot;std_vector.i&quot;
-
-namespace std {
-   %template(vectorEnemySaveData) vector&lt;EnemySaveData&gt;;
-};
\ No newline at end of file

Modified: trunk/source/generated/ggob.py
===================================================================
--- trunk/source/generated/ggob.py	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/generated/ggob.py	2005-05-05 19:42:24 UTC (rev 148)
@@ -458,6 +458,48 @@
         _swig_setattr(self, RainbowRift,self.__class__,RainbowRift)
 _ggob.RainbowRift_swigregister(RainbowRiftPtr)
 
+class DialogApi(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
+    def __repr__(self):
+        return &quot;&lt;C DialogApi instance at %s&gt;&quot; % (self.this,)
+    __swig_getmethods__[&quot;startDialog&quot;] = lambda x: _ggob.DialogApi_startDialog
+    if _newclass:startDialog = staticmethod(_ggob.DialogApi_startDialog)
+    __swig_getmethods__[&quot;endDialog&quot;] = lambda x: _ggob.DialogApi_endDialog
+    if _newclass:endDialog = staticmethod(_ggob.DialogApi_endDialog)
+    __swig_getmethods__[&quot;askPlayer&quot;] = lambda x: _ggob.DialogApi_askPlayer
+    if _newclass:askPlayer = staticmethod(_ggob.DialogApi_askPlayer)
+    __swig_getmethods__[&quot;showText&quot;] = lambda x: _ggob.DialogApi_showText
+    if _newclass:showText = staticmethod(_ggob.DialogApi_showText)
+    __swig_getmethods__[&quot;showAlienPicture&quot;] = lambda x: _ggob.DialogApi_showAlienPicture
+    if _newclass:showAlienPicture = staticmethod(_ggob.DialogApi_showAlienPicture)
+    def __init__(self, *args):
+        _swig_setattr(self, DialogApi, 'this', _ggob.new_DialogApi(*args))
+        _swig_setattr(self, DialogApi, 'thisown', 1)
+    def __del__(self, destroy=_ggob.delete_DialogApi):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
+
+class DialogApiPtr(DialogApi):
+    def __init__(self, this):
+        _swig_setattr(self, DialogApi, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, DialogApi, 'thisown', 0)
+        _swig_setattr(self, DialogApi,self.__class__,DialogApi)
+_ggob.DialogApi_swigregister(DialogApiPtr)
+
+DialogApi_startDialog = _ggob.DialogApi_startDialog
+
+DialogApi_endDialog = _ggob.DialogApi_endDialog
+
+DialogApi_askPlayer = _ggob.DialogApi_askPlayer
+
+DialogApi_showText = _ggob.DialogApi_showText
+
+DialogApi_showAlienPicture = _ggob.DialogApi_showAlienPicture
+
 class vectorEnemySaveData(_object):
     __swig_setmethods__ = {}
     __setattr__ = lambda self, name, value: _swig_setattr(self, vectorEnemySaveData, name, value)
@@ -491,4 +533,37 @@
         _swig_setattr(self, vectorEnemySaveData,self.__class__,vectorEnemySaveData)
 _ggob.vectorEnemySaveData_swigregister(vectorEnemySaveDataPtr)
 
+class vectorString(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
+    def __repr__(self):
+        return &quot;&lt;C std::vector&lt;(std::string)&gt; instance at %s&gt;&quot; % (self.this,)
+    def __init__(self, *args):
+        _swig_setattr(self, vectorString, 'this', _ggob.new_vectorString(*args))
+        _swig_setattr(self, vectorString, 'thisown', 1)
+    def __len__(*args): return _ggob.vectorString___len__(*args)
+    def __nonzero__(*args): return _ggob.vectorString___nonzero__(*args)
+    def clear(*args): return _ggob.vectorString_clear(*args)
+    def append(*args): return _ggob.vectorString_append(*args)
+    def pop(*args): return _ggob.vectorString_pop(*args)
+    def __getitem__(*args): return _ggob.vectorString___getitem__(*args)
+    def __getslice__(*args): return _ggob.vectorString___getslice__(*args)
+    def __setitem__(*args): return _ggob.vectorString___setitem__(*args)
+    def __setslice__(*args): return _ggob.vectorString___setslice__(*args)
+    def __delitem__(*args): return _ggob.vectorString___delitem__(*args)
+    def __delslice__(*args): return _ggob.vectorString___delslice__(*args)
+    def __del__(self, destroy=_ggob.delete_vectorString):
+        try:
+            if self.thisown: destroy(self)
+        except: pass
 
+class vectorStringPtr(vectorString):
+    def __init__(self, this):
+        _swig_setattr(self, vectorString, 'this', this)
+        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, vectorString, 'thisown', 0)
+        _swig_setattr(self, vectorString,self.__class__,vectorString)
+_ggob.vectorString_swigregister(vectorStringPtr)
+
+

Deleted: trunk/source/generated/ggob_wrap.cpp
===================================================================
--- trunk/source/generated/ggob_wrap.cpp	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/generated/ggob_wrap.cpp	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,5025 +0,0 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
- * Version 1.3.21
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-
-#ifdef __cplusplus
-template&lt;class T&gt; class SwigValueWrapper {
-    T *tt;
-public:
-    SwigValueWrapper() : tt(0) { }
-    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
-    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
-    ~SwigValueWrapper() { delete tt; } 
-    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
-    operator T&amp;() const { return *tt; }
-    T *operator&amp;() { return tt; }
-private:
-    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
-};                                                    
-#endif
-
-
-#include &quot;Python.h&quot;
-
-/*************************************************************** -*- c -*-
- * python/precommon.swg
- *
- * Rename all exported symbols from common.swg, to avoid symbol
- * clashes if multiple interpreters are included
- *
- ************************************************************************/
-
-#define SWIG_TypeRegister    SWIG_Python_TypeRegister
-#define SWIG_TypeCheck       SWIG_Python_TypeCheck
-#define SWIG_TypeCast        SWIG_Python_TypeCast
-#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
-#define SWIG_TypeName        SWIG_Python_TypeName
-#define SWIG_TypeQuery       SWIG_Python_TypeQuery
-#define SWIG_TypeClientData  SWIG_Python_TypeClientData
-#define SWIG_PackData        SWIG_Python_PackData 
-#define SWIG_UnpackData      SWIG_Python_UnpackData 
-
-
-/***********************************************************************
- * common.swg
- *
- *     This file contains generic SWIG runtime support for pointer
- *     type checking as well as a few commonly used macros to control
- *     external linkage.
- *
- * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
- *
- * Copyright (c) 1999-2000, The University of Chicago
- * 
- * This file may be freely redistributed without license or fee provided
- * this copyright message remains intact.
- ************************************************************************/
-
-#include &lt;string.h&gt;
-
-#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#  if defined(_MSC_VER) || defined(__GNUC__)
-#    if defined(STATIC_LINKED)
-#      define SWIGEXPORT(a) a
-#      define SWIGIMPORT(a) extern a
-#    else
-#      define SWIGEXPORT(a) __declspec(dllexport) a
-#      define SWIGIMPORT(a) extern a
-#    endif
-#  else
-#    if defined(__BORLANDC__)
-#      define SWIGEXPORT(a) a _export
-#      define SWIGIMPORT(a) a _export
-#    else
-#      define SWIGEXPORT(a) a
-#      define SWIGIMPORT(a) a
-#    endif
-#  endif
-#else
-#  define SWIGEXPORT(a) a
-#  define SWIGIMPORT(a) a
-#endif
-
-#ifdef SWIG_GLOBAL
-#  define SWIGRUNTIME(a) SWIGEXPORT(a)
-#else
-#  define SWIGRUNTIME(a) static a
-#endif
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-typedef void *(*swig_converter_func)(void *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-typedef struct swig_type_info {
-  const char             *name;
-  swig_converter_func     converter;
-  const char             *str;
-  void                   *clientdata;
-  swig_dycast_func        dcast;
-  struct swig_type_info  *next;
-  struct swig_type_info  *prev;
-} swig_type_info;
-
-#ifdef SWIG_NOINCLUDE
-
-SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
-SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
-SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
-SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
-SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
-SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
-SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
-SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
-SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);
-
-#else
-
-static swig_type_info *swig_type_list = 0;
-
-/* Register a type mapping with the type-checking */
-SWIGRUNTIME(swig_type_info *)
-SWIG_TypeRegister(swig_type_info *ti) {
-  swig_type_info *tc, *head, *ret, *next;
-  /* Check to see if this type has already been registered */
-  tc = swig_type_list;
-  while (tc) {
-    if (strcmp(tc-&gt;name, ti-&gt;name) == 0) {
-      /* Already exists in the table.  Just add additional types to the list */
-      if (tc-&gt;clientdata) ti-&gt;clientdata = tc-&gt;clientdata;
-      head = tc;
-      next = tc-&gt;next;
-      goto l1;
-    }
-    tc = tc-&gt;prev;
-  }
-  head = ti;
-  next = 0;
-
-  /* Place in list */
-  ti-&gt;prev = swig_type_list;
-  swig_type_list = ti;
-
-  /* Build linked lists */
-  l1:
-  ret = head;
-  tc = ti + 1;
-  /* Patch up the rest of the links */
-  while (tc-&gt;name) {
-    head-&gt;next = tc;
-    tc-&gt;prev = head;
-    head = tc;
-    tc++;
-  }
-  if (next) next-&gt;prev = head;
-  head-&gt;next = next;
-  return ret;
-}
-
-/* Check the typename */
-SWIGRUNTIME(swig_type_info *) 
-SWIG_TypeCheck(char *c, swig_type_info *ty) {
-  swig_type_info *s;
-  if (!ty) return 0;        /* Void pointer */
-  s = ty-&gt;next;             /* First element always just a name */
-  do {
-    if (strcmp(s-&gt;name,c) == 0) {
-      if (s == ty-&gt;next) return s;
-      /* Move s to the top of the linked list */
-      s-&gt;prev-&gt;next = s-&gt;next;
-      if (s-&gt;next) {
-        s-&gt;next-&gt;prev = s-&gt;prev;
-      }
-      /* Insert s as second element in the list */
-      s-&gt;next = ty-&gt;next;
-      if (ty-&gt;next) ty-&gt;next-&gt;prev = s;
-      ty-&gt;next = s;
-      s-&gt;prev = ty;
-      return s;
-    }
-    s = s-&gt;next;
-  } while (s &amp;&amp; (s != ty-&gt;next));
-  return 0;
-}
-
-/* Cast a pointer up an inheritance hierarchy */
-SWIGRUNTIME(void *) 
-SWIG_TypeCast(swig_type_info *ty, void *ptr) {
-  if ((!ty) || (!ty-&gt;converter)) return ptr;
-  return (*ty-&gt;converter)(ptr);
-}
-
-/* Dynamic pointer casting. Down an inheritance hierarchy */
-SWIGRUNTIME(swig_type_info *) 
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty-&gt;dcast) return ty;
-  while (ty &amp;&amp; (ty-&gt;dcast)) {
-    ty = (*ty-&gt;dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/* Return the name associated with this type */
-SWIGRUNTIME(const char *)
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty-&gt;name;
-}
-
-/* Search for a swig_type_info structure */
-SWIGRUNTIME(swig_type_info *)
-SWIG_TypeQuery(const char *name) {
-  swig_type_info *ty = swig_type_list;
-  while (ty) {
-    if (ty-&gt;str &amp;&amp; (strcmp(name,ty-&gt;str) == 0)) return ty;
-    if (ty-&gt;name &amp;&amp; (strcmp(name,ty-&gt;name) == 0)) return ty;
-    ty = ty-&gt;prev;
-  }
-  return 0;
-}
-
-/* Set the clientdata field for a type */
-SWIGRUNTIME(void)
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  swig_type_info *tc, *equiv;
-  if (ti-&gt;clientdata == clientdata) return;
-  ti-&gt;clientdata = clientdata;
-  equiv = ti-&gt;next;
-  while (equiv) {
-    if (!equiv-&gt;converter) {
-      tc = swig_type_list;
-      while (tc) {
-        if ((strcmp(tc-&gt;name, equiv-&gt;name) == 0))
-          SWIG_TypeClientData(tc,clientdata);
-        tc = tc-&gt;prev;
-      }
-    }
-    equiv = equiv-&gt;next;
-  }
-}
-
-/* Pack binary data into a string */
-SWIGRUNTIME(char *)
-SWIG_PackData(char *c, void *ptr, int sz) {
-  static char hex[17] = &quot;0123456789abcdef&quot;;
-  int i;
-  unsigned char *u = (unsigned char *) ptr;
-  register unsigned char uu;
-  for (i = 0; i &lt; sz; i++,u++) {
-    uu = *u;
-    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
-    *(c++) = hex[uu &amp; 0xf];
-  }
-  return c;
-}
-
-/* Unpack binary data from a string */
-SWIGRUNTIME(char *)
-SWIG_UnpackData(char *c, void *ptr, int sz) {
-  register unsigned char uu = 0;
-  register int d;
-  unsigned char *u = (unsigned char *) ptr;
-  int i;
-  for (i = 0; i &lt; sz; i++, u++) {
-    d = *(c++);
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu = ((d - '0') &lt;&lt; 4);
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu = ((d - ('a'-10)) &lt;&lt; 4);
-    d = *(c++);
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu |= (d - '0');
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu |= (d - ('a'-10));
-    *u = uu;
-  }
-  return c;
-}
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-/***********************************************************************
- * python.swg
- *
- *     This file contains the runtime support for Python modules
- *     and includes code for managing global variables and pointer
- *     type checking.
- *
- * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
- ************************************************************************/
-
-#include &quot;Python.h&quot;
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-#define SWIG_PY_INT     1
-#define SWIG_PY_FLOAT   2
-#define SWIG_PY_STRING  3
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Flags for pointer conversion */
-
-#define SWIG_POINTER_EXCEPTION     0x1
-#define SWIG_POINTER_DISOWN        0x2
-
-/* Exception handling in wrappers */
-#define SWIG_fail   goto fail
-
-/* Constant information structure */
-typedef struct swig_const_info {
-    int type;
-    char *name;
-    long lvalue;
-    double dvalue;
-    void   *pvalue;
-    swig_type_info **ptype;
-} swig_const_info;
-
-/* Common SWIG API */
-#define SWIG_ConvertPtr(obj, pp, type, flags) \
-  SWIG_Python_ConvertPtr(obj, pp, type, flags)
-#define SWIG_NewPointerObj(p, type, flags) \
-  SWIG_Python_NewPointerObj(p, type, flags)
-#define SWIG_MustGetPtr(p, type, argnum, flags) \
-  SWIG_Python_MustGetPtr(p, type, argnum, flags)
-
-/* Python-specific SWIG API */
-#define SWIG_newvarlink() \
-  SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr) \
-  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
-  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
-#define SWIG_NewPackedObj(ptr, sz, type) \
-  SWIG_Python_NewPackedObj(ptr, sz, type)
-#define SWIG_InstallConstants(d, constants) \
-  SWIG_Python_InstallConstants(d, constants)
-
-#ifdef SWIG_NOINCLUDE
-
-SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
-SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
-SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
-SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
-SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
-SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
-SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
-SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);
-
-#else
-
-/* -----------------------------------------------------------------------------
- * global variable support code.
- * ----------------------------------------------------------------------------- */
-
-typedef struct swig_globalvar {   
-  char       *name;                  /* Name of global variable */
-  PyObject *(*get_attr)(void);       /* Return the current value */
-  int       (*set_attr)(PyObject *); /* Set the value */
-  struct swig_globalvar *next;
-} swig_globalvar;
-
-typedef struct swig_varlinkobject {
-  PyObject_HEAD
-  swig_globalvar *vars;
-} swig_varlinkobject;
-
-static PyObject *
-swig_varlink_repr(swig_varlinkobject *v) {
-  v = v;
-  return PyString_FromString(&quot;&lt;Global variables&gt;&quot;);
-}
-
-static int
-swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
-  swig_globalvar  *var;
-  flags = flags;
-  fprintf(fp,&quot;Global variables { &quot;);
-  for (var = v-&gt;vars; var; var=var-&gt;next) {
-    fprintf(fp,&quot;%s&quot;, var-&gt;name);
-    if (var-&gt;next) fprintf(fp,&quot;, &quot;);
-  }
-  fprintf(fp,&quot; }\n&quot;);
-  return 0;
-}
-
-static PyObject *
-swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-  swig_globalvar *var = v-&gt;vars;
-  while (var) {
-    if (strcmp(var-&gt;name,n) == 0) {
-      return (*var-&gt;get_attr)();
-    }
-    var = var-&gt;next;
-  }
-  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
-  return NULL;
-}
-
-static int
-swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-  swig_globalvar *var = v-&gt;vars;
-  while (var) {
-    if (strcmp(var-&gt;name,n) == 0) {
-      return (*var-&gt;set_attr)(p);
-    }
-    var = var-&gt;next;
-  }
-  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
-  return 1;
-}
-
-statichere PyTypeObject varlinktype = {
-  PyObject_HEAD_INIT(0)              
-  0,
-  (char *)&quot;swigvarlink&quot;,              /* Type name    */
-  sizeof(swig_varlinkobject),         /* Basic size   */
-  0,                                  /* Itemsize     */
-  0,                                  /* Deallocator  */ 
-  (printfunc) swig_varlink_print,     /* Print        */
-  (getattrfunc) swig_varlink_getattr, /* get attr     */
-  (setattrfunc) swig_varlink_setattr, /* Set attr     */
-  0,                                  /* tp_compare   */
-  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
-  0,                                  /* tp_as_number */
-  0,                                  /* tp_as_mapping*/
-  0,                                  /* tp_hash      */
-};
-
-/* Create a variable linking object for use later */
-SWIGRUNTIME(PyObject *)
-SWIG_Python_newvarlink(void) {
-  swig_varlinkobject *result = 0;
-  result = PyMem_NEW(swig_varlinkobject,1);
-  varlinktype.ob_type = &amp;PyType_Type;    /* Patch varlinktype into a PyType */
-  result-&gt;ob_type = &varlinktype;
-  result-&gt;vars = 0;
-  result-&gt;ob_refcnt = 0;
-  Py_XINCREF((PyObject *) result);
-  return ((PyObject*) result);
-}
-
-SWIGRUNTIME(void)
-SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-  swig_varlinkobject *v;
-  swig_globalvar *gv;
-  v= (swig_varlinkobject *) p;
-  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-  gv-&gt;name = (char *) malloc(strlen(name)+1);
-  strcpy(gv-&gt;name,name);
-  gv-&gt;get_attr = get_attr;
-  gv-&gt;set_attr = set_attr;
-  gv-&gt;next = v-&gt;vars;
-  v-&gt;vars = gv;
-}
-
-/* Convert a pointer value */
-SWIGRUNTIME(int)
-SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
-  swig_type_info *tc;
-  char  *c = 0;
-  static PyObject *SWIG_this = 0;
-  int    newref = 0;
-  PyObject  *pyobj = 0;
-
-  if (!obj) return 0;
-  if (obj == Py_None) {
-    *ptr = 0;
-    return 0;
-  }
-#ifdef SWIG_COBJECT_TYPES
-  if (!(PyCObject_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString(&quot;this&quot;);
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PyCObject_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  }  
-  *ptr = PyCObject_AsVoidPtr(obj);
-  c = (char *) PyCObject_GetDesc(obj);
-  if (newref) Py_DECREF(obj);
-  goto cobject;
-#else
-  if (!(PyString_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString(&quot;this&quot;);
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PyString_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  } 
-  c = PyString_AsString(obj);
-  /* Pointer values must start with leading underscore */
-  if (*c != '_') {
-    *ptr = (void *) 0;
-    if (strcmp(c,&quot;NULL&quot;) == 0) {
-      if (newref) { Py_DECREF(obj); }
-      return 0;
-    } else {
-      if (newref) { Py_DECREF(obj); }
-      goto type_error;
-    }
-  }
-  c++;
-  c = SWIG_UnpackData(c,ptr,sizeof(void *));
-  if (newref) { Py_DECREF(obj); }
-#endif
-
-#ifdef SWIG_COBJECT_TYPES
-cobject:
-#endif
-
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
-  }
-
-  if ((pyobj) &amp;&amp; (flags &amp; SWIG_POINTER_DISOWN)) {
-    PyObject *zero = PyInt_FromLong(0);
-    PyObject_SetAttrString(pyobj,(char*)&quot;thisown&quot;,zero);
-    Py_DECREF(zero);
-  }
-  return 0;
-
-type_error:
-  if (flags &amp; SWIG_POINTER_EXCEPTION) {
-    if (ty &amp;&amp; c) {
-      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
-      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
-      PyErr_SetString(PyExc_TypeError, temp);
-      free((char *) temp);
-    } else {
-      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
-    }
-  }
-  return -1;
-}
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME(void *)
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
-  void *result;
-  SWIG_Python_ConvertPtr(obj, &amp;result, ty, flags | SWIG_POINTER_EXCEPTION);
-  return result;
-}
-
-/* Convert a packed value value */
-SWIGRUNTIME(int)
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
-  swig_type_info *tc;
-  char  *c = 0;
-
-  if ((!obj) || (!PyString_Check(obj))) goto type_error;
-  c = PyString_AsString(obj);
-  /* Pointer values must start with leading underscore */
-  if (*c != '_') goto type_error;
-  c++;
-  c = SWIG_UnpackData(c,ptr,sz);
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-  }
-  return 0;
-
-type_error:
-
-  if (flags) {
-    if (ty &amp;&amp; c) {
-      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
-      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
-      PyErr_SetString(PyExc_TypeError, temp);
-      free((char *) temp);
-    } else {
-      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
-    }
-  }
-  return -1;
-}
-
-/* Create a new pointer object */
-SWIGRUNTIME(PyObject *)
-SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
-  PyObject *robj;
-  if (!ptr) {
-    Py_INCREF(Py_None);
-    return Py_None;
-  }
-#ifdef SWIG_COBJECT_TYPES
-  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type-&gt;name, NULL);
-#else
-  {
-    char result[1024];
-    char *r = result;
-    *(r++) = '_';
-    r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
-    strcpy(r,type-&gt;name);
-    robj = PyString_FromString(result);
-  }
-#endif
-  if (!robj || (robj == Py_None)) return robj;
-  if (type-&gt;clientdata) {
-    PyObject *inst;
-    PyObject *args = Py_BuildValue((char*)&quot;(O)&quot;, robj);
-    Py_DECREF(robj);
-    inst = PyObject_CallObject((PyObject *) type-&gt;clientdata, args);
-    Py_DECREF(args);
-    if (inst) {
-      if (own) {
-        PyObject *n = PyInt_FromLong(1);
-        PyObject_SetAttrString(inst,(char*)&quot;thisown&quot;,n);
-        Py_DECREF(n);
-      }
-      robj = inst;
-    }
-  }
-  return robj;
-}
-
-SWIGRUNTIME(PyObject *)
-SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
-  char result[1024];
-  char *r = result;
-  if ((2*sz + 1 + strlen(type-&gt;name)) &gt; 1000) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  strcpy(r,type-&gt;name);
-  return PyString_FromString(result);
-}
-
-/* Install Constants */
-SWIGRUNTIME(void)
-SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-  int i;
-  PyObject *obj;
-  for (i = 0; constants[i].type; i++) {
-    switch(constants[i].type) {
-    case SWIG_PY_INT:
-      obj = PyInt_FromLong(constants[i].lvalue);
-      break;
-    case SWIG_PY_FLOAT:
-      obj = PyFloat_FromDouble(constants[i].dvalue);
-      break;
-    case SWIG_PY_STRING:
-      obj = PyString_FromString((char *) constants[i].pvalue);
-      break;
-    case SWIG_PY_POINTER:
-      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-      break;
-    case SWIG_PY_BINARY:
-      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-      break;
-    default:
-      obj = 0;
-      break;
-    }
-    if (obj) {
-      PyDict_SetItemString(d,constants[i].name,obj);
-      Py_DECREF(obj);
-    }
-  }
-}
-
-#endif
-
-/* Contract support */
-
-#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define  SWIGTYPE_p_GobPlayer swig_types[0] 
-#define  SWIGTYPE_p_p_Upgrade swig_types[1] 
-#define  SWIGTYPE_p_SpaceLocation swig_types[2] 
-#define  SWIGTYPE_p_p_GobStation swig_types[3] 
-#define  SWIGTYPE_p_GobStation swig_types[4] 
-#define  SWIGTYPE_p_Upgrade swig_types[5] 
-#define  SWIGTYPE_p_RGB swig_types[6] 
-#define  SWIGTYPE_p_Log swig_types[7] 
-#define  SWIGTYPE_p_StarMap swig_types[8] 
-#define  SWIGTYPE_p_float swig_types[9] 
-#define  SWIGTYPE_p_std__vectorTEnemySaveData_t swig_types[10] 
-#define  SWIGTYPE_p_GobAsteroid swig_types[11] 
-#define  SWIGTYPE_p_TeamCode swig_types[12] 
-#define  SWIGTYPE_p_GobEnemy swig_types[13] 
-#define  SWIGTYPE_p_p_GobEnemy swig_types[14] 
-#define  SWIGTYPE_p_p_Planet swig_types[15] 
-#define  SWIGTYPE_p_RainbowRift swig_types[16] 
-#define  SWIGTYPE_p_GobGame swig_types[17] 
-#define  SWIGTYPE_p_EnemySaveData swig_types[18] 
-#define  SWIGTYPE_p_std__string swig_types[19] 
-#define  SWIGTYPE_p_Vector2 swig_types[20] 
-#define  SWIGTYPE_p_SaveGobGameInfo swig_types[21] 
-#define  SWIGTYPE_p_pair swig_types[22] 
-#define  SWIGTYPE_p_SpaceSprite swig_types[23] 
-#define  SWIGTYPE_p_Control swig_types[24] 
-#define  SWIGTYPE_p_SpaceObject swig_types[25] 
-#define  SWIGTYPE_p_Frame swig_types[26] 
-#define  SWIGTYPE_p_ShipPanel swig_types[27] 
-#define  SWIGTYPE_p_SAMPLE swig_types[28] 
-#define  SWIGTYPE_p_ShipType swig_types[29] 
-#define  SWIGTYPE_p_Ship swig_types[30] 
-static swig_type_info *swig_types[32];
-
-/* -------- TYPES TABLE (END) -------- */
-
-
-/*-----------------------------------------------
-              @(target):= _ggob.so
-  ------------------------------------------------*/
-#define SWIG_init    init_ggob
-
-#define SWIG_name    &quot;_ggob&quot;
-
-#include &quot;games/ggob.h&quot;
-
-
-#define  SWIG_MemoryError    1
-#define  SWIG_IOError        2
-#define  SWIG_RuntimeError   3
-#define  SWIG_IndexError     4
-#define  SWIG_TypeError      5
-#define  SWIG_DivisionByZero 6
-#define  SWIG_OverflowError  7
-#define  SWIG_SyntaxError    8
-#define  SWIG_ValueError     9
-#define  SWIG_SystemError   10
-#define  SWIG_UnknownError  99
-
-
-static void SWIG_exception_(int code, const char *msg) {
-  switch(code) {
-  case SWIG_MemoryError:
-    PyErr_SetString(PyExc_MemoryError,msg);
-    break;
-  case SWIG_IOError:
-    PyErr_SetString(PyExc_IOError,msg);
-    break;
-  case SWIG_RuntimeError:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  case SWIG_IndexError:
-    PyErr_SetString(PyExc_IndexError,msg);
-    break;
-  case SWIG_TypeError:
-    PyErr_SetString(PyExc_TypeError,msg);
-    break;
-  case SWIG_DivisionByZero:
-    PyErr_SetString(PyExc_ZeroDivisionError,msg);
-    break;
-  case SWIG_OverflowError:
-    PyErr_SetString(PyExc_OverflowError,msg);
-    break;
-  case SWIG_SyntaxError:
-    PyErr_SetString(PyExc_SyntaxError,msg);
-    break;
-  case SWIG_ValueError:
-    PyErr_SetString(PyExc_ValueError,msg);
-    break;
-  case SWIG_SystemError:
-    PyErr_SetString(PyExc_SystemError,msg);
-    break;
-  default:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  }
-}
-
-#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
-
-
-#include &lt;string&gt;
-
-
-#include &lt;string&gt;
-
-PyObject* SwigInt_FromBool(bool b) {
-    return PyInt_FromLong(b ? 1L : 0L);
-}
-double SwigNumber_Check(PyObject* o) {
-    return PyFloat_Check(o) || PyInt_Check(o) || PyLong_Check(o);
-}
-double SwigNumber_AsDouble(PyObject* o) {
-    return PyFloat_Check(o) ? PyFloat_AsDouble(o) 
-        : (PyInt_Check(o) ?   double(PyInt_AsLong(o))
-                            : double(PyLong_AsLong(o)));
-}
-PyObject* SwigString_FromString(const std::string&amp; s) {
-    return PyString_FromStringAndSize(s.data(),s.size());
-}
-std::string SwigString_AsString(PyObject* o) {
-    return std::string(PyString_AsString(o));
-}
-
-
-#include &lt;utility&gt;
-
-
-#include &lt;vector&gt;
-#include &lt;algorithm&gt;
-#include &lt;stdexcept&gt;
-
-bool std_vectorlEnemySaveData_g___nonzero_____(std::vector&lt;EnemySaveData &gt; *self){
-                return !(self-&gt;empty());
-            }
-EnemySaveData std_vectorlEnemySaveData_g_pop___(std::vector&lt;EnemySaveData &gt; *self){
-                if (self-&gt;size() == 0)
-                    throw std::out_of_range(&quot;pop from empty vector&quot;);
-                EnemySaveData x = self-&gt;back();
-                self-&gt;pop_back();
-                return x;
-            }
-EnemySaveData &amp;std_vectorlEnemySaveData_g___getitem_____(std::vector&lt;EnemySaveData &gt; *self,int i){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i += size;
-                if (i&gt;=0 &amp;&amp; i&lt;size)
-                    return (*self)[i];
-                else
-                    throw std::out_of_range(&quot;vector index out of range&quot;);
-            }
-std::vector&lt;EnemySaveData &gt; std_vectorlEnemySaveData_g___getslice_____(std::vector&lt;EnemySaveData &gt; *self,int i,int j){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i = size+i;
-                if (j&lt;0) j = size+j;
-                if (i&lt;0) i = 0;
-                if (j&gt;size) j = size;
-                std::vector&lt;EnemySaveData &gt; tmp;
-                tmp.reserve(j-i);
-                tmp.insert(tmp.begin(),self-&gt;begin()+i,self-&gt;begin()+j);
-                return tmp;
-            }
-void std_vectorlEnemySaveData_g___setitem_____(std::vector&lt;EnemySaveData &gt; *self,int i,EnemySaveData const &amp;x){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i+= size;
-                if (i&gt;=0 &amp;&amp; i&lt;size)
-                    (*self)[i] = x;
-                else
-                    throw std::out_of_range(&quot;vector index out of range&quot;);
-            }
-void std_vectorlEnemySaveData_g___setslice_____(std::vector&lt;EnemySaveData &gt; *self,int i,int j,std::vector&lt;EnemySaveData &gt; const &amp;v){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i = size+i;
-                if (j&lt;0) j = size+j;
-                if (i&lt;0) i = 0;
-                if (j&gt;size) j = size;
-                if (int(v.size()) == j-i) {
-                    std::copy(v.begin(),v.end(),self-&gt;begin()+i);
-                } else {
-                    self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
-                    if (i+1 &lt;= int(self-&gt;size())) {
-                        self-&gt;insert(self-&gt;begin()+i,v.begin(),v.end());
-                    } else {
-                        self-&gt;insert(self-&gt;end(),v.begin(),v.end());
-                    }
-                }
-            }
-void std_vectorlEnemySaveData_g___delitem_____(std::vector&lt;EnemySaveData &gt; *self,int i){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i+= size;
-                if (i&gt;=0 &amp;&amp; i&lt;size)
-                    self-&gt;erase(self-&gt;begin()+i);
-                else
-                    throw std::out_of_range(&quot;vector index out of range&quot;);
-            }
-void std_vectorlEnemySaveData_g___delslice_____(std::vector&lt;EnemySaveData &gt; *self,int i,int j){
-                int size = int(self-&gt;size());
-                if (i&lt;0) i = size+i;
-                if (j&lt;0) j = size+j;
-                if (i&lt;0) i = 0;
-                if (j&gt;size) j = size;
-                self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
-            }
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-static PyObject *_wrap_pair_id_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    pair *arg1 = (pair *) 0 ;
-    char *arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Os:pair_id_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (arg1-&gt;id) delete [] arg1-&gt;id;
-        if (arg2) {
-            arg1-&gt;id = (char *) (new char[strlen(arg2)+1]);
-            strcpy((char *) arg1-&gt;id,arg2);
-        } else {
-            arg1-&gt;id = 0;
-        }
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_pair_id_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    pair *arg1 = (pair *) 0 ;
-    char *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:pair_id_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (char *) ((arg1)-&gt;id);
-    
-    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)&quot;&quot;);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_pair_value_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    pair *arg1 = (pair *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:pair_value_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;value = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_pair_value_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    pair *arg1 = (pair *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:pair_value_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;value);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_pair(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    pair *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_pair&quot;)) goto fail;
-    result = (pair *)new pair();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_pair(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    pair *arg1 = (pair *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_pair&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * pair_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_pair, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_EnemySaveData_pos_x_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:EnemySaveData_pos_x_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;pos_x = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EnemySaveData_pos_x_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:EnemySaveData_pos_x_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;pos_x);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EnemySaveData_pos_y_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:EnemySaveData_pos_y_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;pos_y = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EnemySaveData_pos_y_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:EnemySaveData_pos_y_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;pos_y);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_EnemySaveData(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EnemySaveData *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_EnemySaveData&quot;)) goto fail;
-    result = (EnemySaveData *)new EnemySaveData();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_EnemySaveData, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_EnemySaveData(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_EnemySaveData&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * EnemySaveData_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_EnemySaveData, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_SaveGobGameInfo_getInstance(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:SaveGobGameInfo_getInstance&quot;)) goto fail;
-    result = (SaveGobGameInfo *)SaveGobGameInfo::getInstance();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SaveGobGameInfo, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_updateSave(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_updateSave&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;updateSave();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_updateGame(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_updateGame&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;updateGame();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_starbucks_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;starbucks = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_starbucks_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_starbucks_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;starbucks);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_buckazoids_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;buckazoids = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_buckazoids_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_buckazoids_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;buckazoids);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_kills_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_kills_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;kills = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_kills_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_kills_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;kills);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_pos_x_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_pos_x_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;pos_x = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_pos_x_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_pos_x_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;pos_x);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_pos_y_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_pos_y_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;pos_y = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_pos_y_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_pos_y_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;pos_y);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_system_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::string *arg2 = (std::string *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_system_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;system = *arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_system_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::string *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_system_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (std::string *)&amp; ((arg1)-&gt;system);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_getSystem(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::string result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_getSystem&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (arg1)-&gt;getSystem();
-    
-    {
-        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_setSystem(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::string *arg2 = 0 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_setSystem&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    (arg1)-&gt;setSystem((std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_tst_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::vector&lt;EnemySaveData &gt; *arg2 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_tst_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;tst = *arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_tst_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::vector&lt;EnemySaveData &gt; *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_tst_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (std::vector&lt;EnemySaveData &gt; *)&amp; ((arg1)-&gt;tst);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_getTst(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::vector&lt;EnemySaveData &gt; result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_getTst&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (arg1)-&gt;getTst();
-    
-    {
-        std::vector&lt;EnemySaveData &gt; * resultptr;
-        resultptr = new std::vector&lt;EnemySaveData &gt;((std::vector&lt;EnemySaveData &gt; &amp;) result);
-        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SaveGobGameInfo_setTst(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    std::vector&lt;EnemySaveData &gt; *arg2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_setTst&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg2 == NULL) {
-        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
-    }
-    (arg1)-&gt;setTst(*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_SaveGobGameInfo(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_SaveGobGameInfo&quot;)) goto fail;
-    result = (SaveGobGameInfo *)new SaveGobGameInfo();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SaveGobGameInfo, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_SaveGobGameInfo(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_SaveGobGameInfo&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * SaveGobGameInfo_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_SaveGobGameInfo, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_new_GobPlayer(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobPlayer&quot;)) goto fail;
-    result = (GobPlayer *)new GobPlayer();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GobPlayer(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobPlayer&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_ship_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    Ship *arg2 = (Ship *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_ship_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;ship = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_ship_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    Ship *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_ship_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (Ship *) ((arg1)-&gt;ship);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_pair_list_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    pair *arg2 = (pair *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_pair_list_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;pair_list = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_pair_list_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    pair *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_pair_list_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (pair *) ((arg1)-&gt;pair_list);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_num_pairs_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_num_pairs_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;num_pairs = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_num_pairs_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_num_pairs_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;num_pairs);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_total_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_total_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;total = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_total_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_total_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;total);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_starbucks_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;starbucks = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_starbucks_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_starbucks_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;starbucks);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_buckazoids_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;buckazoids = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_buckazoids_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_buckazoids_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;buckazoids);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_kills_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_kills_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;kills = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_kills_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_kills_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;kills);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_value_starbucks_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_value_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;value_starbucks = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_value_starbucks_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_value_starbucks_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;value_starbucks);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_value_buckazoids_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_value_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;value_buckazoids = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_value_buckazoids_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_value_buckazoids_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;value_buckazoids);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_team_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    TeamCode arg2 ;
-    TeamCode *argp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_team_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
-    arg2 = *argp2; 
-    if (arg1) (arg1)-&gt;team = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_team_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    TeamCode result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_team_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result =  ((arg1)-&gt;team);
-    
-    {
-        TeamCode * resultptr;
-        resultptr = new TeamCode((TeamCode &amp;) result);
-        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_init(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    TeamCode arg2 ;
-    TeamCode *argp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_init&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
-    arg2 = *argp2; 
-    (arg1)-&gt;init(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_died(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_died&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;died(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_new_ship(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    ShipType *arg2 = (ShipType *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_new_ship&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_ShipType,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;new_ship(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_charge(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    char *arg2 ;
-    int arg3 ;
-    int arg4 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Osii:GobPlayer_charge&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;arg4)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int)(arg1)-&gt;charge(arg2,arg3,arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer__add_pair(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    char *arg2 ;
-    int arg3 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Osi:GobPlayer__add_pair&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;_add_pair((char const *)arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer__get_pair(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    char *arg2 ;
-    pair *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Os:GobPlayer__get_pair&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (pair *)(arg1)-&gt;_get_pair((char const *)arg2);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_write_pair(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    char *arg2 ;
-    int arg3 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Osi:GobPlayer_write_pair&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;write_pair((char const *)arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_read_pair(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    char *arg2 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Os:GobPlayer_read_pair&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int)(arg1)-&gt;read_pair((char const *)arg2);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_upgrade_list_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    Upgrade **arg2 = (Upgrade **) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_upgrade_list_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;upgrade_list = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobPlayer_upgrade_list_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobPlayer *arg1 = (GobPlayer *) 0 ;
-    Upgrade **result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_upgrade_list_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (Upgrade **) ((arg1)-&gt;upgrade_list);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Upgrade, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GobPlayer_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GobPlayer, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_GobEnemy_ship_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    Ship *arg2 = (Ship *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobEnemy_ship_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;ship = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobEnemy_ship_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    Ship *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_ship_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (Ship *) ((arg1)-&gt;ship);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobEnemy_starbucks_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobEnemy_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;starbucks = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobEnemy_starbucks_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_starbucks_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;starbucks);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobEnemy_buckazoids_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobEnemy_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;buckazoids = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobEnemy_buckazoids_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_buckazoids_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;buckazoids);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobEnemy_init(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    Ship *arg2 = (Ship *) 0 ;
-    int arg3 ;
-    int arg4 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobEnemy_init&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;init(arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobEnemy_died(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobEnemy_died&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;died(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GobEnemy(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobEnemy&quot;)) goto fail;
-    result = (GobEnemy *)new GobEnemy();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobEnemy, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GobEnemy(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobEnemy *arg1 = (GobEnemy *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobEnemy&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GobEnemy_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GobEnemy, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_GobAsteroid_handle_damage(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
-    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOdd:GobAsteroid_handle_damage&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int)(arg1)-&gt;handle_damage(arg2,arg3,arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobAsteroid_death(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobAsteroid_death&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;death();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GobAsteroid(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobAsteroid *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobAsteroid&quot;)) goto fail;
-    result = (GobAsteroid *)new GobAsteroid();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobAsteroid, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GobAsteroid(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobAsteroid&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GobAsteroid_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GobAsteroid, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_GobGame__galaxy_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    StarMap arg2 ;
-    StarMap *argp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__galaxy_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_StarMap,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
-    arg2 = *argp2; 
-    if (arg1) (arg1)-&gt;_galaxy = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame__galaxy_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    StarMap result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__galaxy_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result =  ((arg1)-&gt;_galaxy);
-    
-    {
-        StarMap * resultptr;
-        resultptr = new StarMap((StarMap &amp;) result);
-        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_StarMap, 1);
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_gobplayer_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    GobPlayer *arg2 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_gobplayer_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;gobplayer = *arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_gobplayer_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    GobPlayer *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobplayer_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (GobPlayer *)&amp; ((arg1)-&gt;gobplayer);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_switch_system(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    std::string *arg2 = 0 ;
-    std::string temp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_switch_system&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    (arg1)-&gt;switch_system((std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_gobplayer__SWIG_0(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    std::string *arg2 = 0 ;
-    Vector2 arg3 ;
-    std::string temp2 ;
-    Vector2 *argp3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_add_gobplayer&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1)) {
-            temp2 = std::string(PyString_AsString(obj1),
-            PyString_Size(obj1));
-            arg2 = &amp;temp2;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;argp3, SWIGTYPE_p_Vector2,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
-    arg3 = *argp3; 
-    (arg1)-&gt;add_gobplayer((std::string const &amp;)*arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GobGame(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobGame&quot;)) goto fail;
-    result = (GobGame *)new GobGame();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_get_this(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GobGame_get_this&quot;)) goto fail;
-    result = (GobGame *)GobGame::get_this();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GobGame(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobGame&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame__player_panel_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    ShipPanel *arg2 = (ShipPanel *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__player_panel_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_ShipPanel,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;_player_panel = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame__player_panel_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    ShipPanel *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__player_panel_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (ShipPanel *) ((arg1)-&gt;_player_panel);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ShipPanel, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame__player_control_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    Control *arg2 = (Control *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__player_control_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;_player_control = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame__player_control_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    Control *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__player_control_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (Control *) ((arg1)-&gt;_player_control);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Control, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_enemy_team_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    TeamCode arg2 ;
-    TeamCode *argp2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_enemy_team_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
-    arg2 = *argp2; 
-    if (arg1) (arg1)-&gt;enemy_team = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_enemy_team_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    TeamCode result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_enemy_team_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result =  ((arg1)-&gt;enemy_team);
-    
-    {
-        TeamCode * resultptr;
-        resultptr = new TeamCode((TeamCode &amp;) result);
-        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_AddPanel(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_AddPanel&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;AddPanel();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_calculate(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_calculate&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;calculate();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_setGameDone(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_setGameDone&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;setGameDone(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_ship_died(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    Ship *arg2 = (Ship *) 0 ;
-    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_ship_died&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;ship_died(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_preinit(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_preinit&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;preinit();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_init(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    Log *arg2 = (Log *) 0 ;
-    std::string *arg3 = 0 ;
-    std::string temp3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_init&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Log,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj2)) {
-            temp3 = std::string(PyString_AsString(obj2),
-            PyString_Size(obj2));
-            arg3 = &amp;temp3;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    (arg1)-&gt;init(arg2,(std::string const &amp;)*arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_play_sound(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    SAMPLE *arg2 = (SAMPLE *) 0 ;
-    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
-    int arg4 = (int) 256 ;
-    int arg5 = (int) 1000 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO|ii:GobGame_play_sound&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;arg4,&amp;arg5)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SAMPLE,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;play_sound(arg2,arg3,arg4,arg5);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_gobplayer__SWIG_1(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    Control *arg2 = (Control *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_add_gobplayer&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;add_gobplayer(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_gobplayer(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[4];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], (void **) &amp;ptr, SWIGTYPE_p_GobGame, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            {
-                void *ptr;
-                if (SWIG_ConvertPtr(argv[1], (void **) &amp;ptr, SWIGTYPE_p_Control, 0) == -1) {
-                    _v = 0;
-                    PyErr_Clear();
-                } else {
-                    _v = 1;
-                }
-            }
-            if (_v) {
-                return _wrap_GobGame_add_gobplayer__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], (void **) &amp;ptr, SWIGTYPE_p_GobGame, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            {
-                _v = PyString_Check(argv[1]) ? 1 : 0;
-            }
-            if (_v) {
-                {
-                    void *ptr;
-                    if (SWIG_ConvertPtr(argv[2], (void **) &amp;ptr, SWIGTYPE_p_Vector2, 0) == -1) {
-                        _v = 0;
-                        PyErr_Clear();
-                    } else {
-                        _v = 1;
-                    }
-                }
-                if (_v) {
-                    return _wrap_GobGame_add_gobplayer__SWIG_0(self,args);
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'GobGame_add_gobplayer'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_get_player(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
-    GobPlayer *result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_get_player&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (GobPlayer *)(arg1)-&gt;get_player(arg2);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_gobenemies_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_gobenemies_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;gobenemies = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_gobenemies_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobenemies_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;gobenemies);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_max_enemies_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_max_enemies_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;max_enemies = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_max_enemies_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_max_enemies_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;max_enemies);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_gobenemy_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    GobEnemy **arg2 = (GobEnemy **) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_gobenemy_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;gobenemy = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_gobenemy_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    GobEnemy **result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobenemy_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (GobEnemy **) ((arg1)-&gt;gobenemy);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobEnemy, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_get_enemy_index(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_get_enemy_index&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int)(arg1)-&gt;get_enemy_index(arg2);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_prepare(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_prepare&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;prepare();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_fps(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_fps&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;fps();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_new_enemy(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_new_enemy&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;add_new_enemy();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_stars(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_stars&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;add_stars();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_asteroid(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_asteroid&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;add_asteroid();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_system(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    std::string arg2 ;
-    int arg3 ;
-    int arg4 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobGame_add_system&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1))
-        arg2 = std::string(PyString_AsString(obj1),
-        PyString_Size(obj1));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    (arg1)-&gt;add_system(arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_player(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    std::string arg2 ;
-    int arg3 ;
-    int arg4 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobGame_add_player&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj1))
-        arg2 = std::string(PyString_AsString(obj1),
-        PyString_Size(obj1));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    (arg1)-&gt;add_player(arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_next_add_new_enemy_time_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_next_add_new_enemy_time_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;next_add_new_enemy_time = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_next_add_new_enemy_time_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_next_add_new_enemy_time_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;next_add_new_enemy_time);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_defenderSprite_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    SpaceSprite *arg2 = (SpaceSprite *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_defenderSprite_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;defenderSprite = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_defenderSprite_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    SpaceSprite *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_defenderSprite_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (SpaceSprite *) ((arg1)-&gt;defenderSprite);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SpaceSprite, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_num_planets_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_num_planets_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;num_planets = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_num_planets_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_num_planets_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;num_planets);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_planet_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    Planet **arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_planet_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_Planet,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        int ii;
-        Planet * *b = (Planet * *) arg1-&gt;planet;
-        for (ii = 0; ii &lt; 16; ii++) b[ii] = *((Planet * *) arg2 + ii);
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_planet_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    Planet **result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_planet_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (Planet **)(Planet **) ((arg1)-&gt;planet);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Planet, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_station_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    GobStation **arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_station_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        int ii;
-        GobStation * *b = (GobStation * *) arg1-&gt;station;
-        for (ii = 0; ii &lt; 16; ii++) b[ii] = *((GobStation * *) arg2 + ii);
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_station_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    GobStation **result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_station_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (GobStation **)(GobStation **) ((arg1)-&gt;station);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobStation, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobGame_add_planet_and_station(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobGame *arg1 = (GobGame *) 0 ;
-    int arg2 ;
-    std::string arg3 ;
-    std::string arg4 ;
-    std::string arg5 ;
-    std::string arg6 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    PyObject * obj5 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OiOOOO:GobGame_add_planet_and_station&quot;,&amp;obj0,&amp;arg2,&amp;obj2,&amp;obj3,&amp;obj4,&amp;obj5)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj2))
-        arg3 = std::string(PyString_AsString(obj2),
-        PyString_Size(obj2));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    {
-        if (PyString_Check(obj3))
-        arg4 = std::string(PyString_AsString(obj3),
-        PyString_Size(obj3));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    {
-        if (PyString_Check(obj4))
-        arg5 = std::string(PyString_AsString(obj4),
-        PyString_Size(obj4));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    {
-        if (PyString_Check(obj5))
-        arg6 = std::string(PyString_AsString(obj5),
-        PyString_Size(obj5));
-        else
-        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-    }
-    (arg1)-&gt;add_planet_and_station(arg2,arg3,arg4,arg5,arg6);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GobGame_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GobGame, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_GobStation__build_type_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    std::string *arg2 = (std::string *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation__build_type_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;_build_type = *arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobStation__build_type_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    std::string *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobStation__build_type_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (std::string *)&amp; ((arg1)-&gt;_build_type);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobStation__background_pic_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    std::string *arg2 = (std::string *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation__background_pic_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;_background_pic = *arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobStation__background_pic_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    std::string *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobStation__background_pic_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (std::string *)&amp; ((arg1)-&gt;_background_pic);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GobStation(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    SpaceSprite *arg1 = (SpaceSprite *) 0 ;
-    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
-    std::string *arg3 = 0 ;
-    std::string *arg4 = 0 ;
-    GobStation *result;
-    std::string temp3 ;
-    std::string temp4 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:new_GobStation&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyString_Check(obj2)) {
-            temp3 = std::string(PyString_AsString(obj2),
-            PyString_Size(obj2));
-            arg3 = &amp;temp3;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    {
-        if (PyString_Check(obj3)) {
-            temp4 = std::string(PyString_AsString(obj3),
-            PyString_Size(obj3));
-            arg4 = &amp;temp4;
-        } else {
-            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
-        }
-    }
-    result = (GobStation *)new GobStation(arg1,arg2,(std::string const &amp;)*arg3,(std::string const &amp;)*arg4);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobStation, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobStation_buy_new_ship_menu(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    GobPlayer *arg2 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_buy_new_ship_menu&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;buy_new_ship_menu(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobStation_inflict_damage(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    SpaceObject *arg2 = (SpaceObject *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_inflict_damage&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceObject,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;inflict_damage(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobStation_station_screen(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    GobPlayer *arg2 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_station_screen&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;station_screen(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GobStation_upgrade_menu(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    GobStation *arg2 = (GobStation *) 0 ;
-    GobPlayer *arg3 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobStation_upgrade_menu&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;upgrade_menu(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GobStation(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    GobStation *arg1 = (GobStation *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobStation&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GobStation_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GobStation, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_Upgrade_name_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    char *arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Os:Upgrade_name_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (arg1-&gt;name) delete [] arg1-&gt;name;
-        if (arg2) {
-            arg1-&gt;name = (char *) (new char[strlen(arg2)+1]);
-            strcpy((char *) arg1-&gt;name,arg2);
-        } else {
-            arg1-&gt;name = 0;
-        }
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_name_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    char *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_name_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (char *) ((arg1)-&gt;name);
-    
-    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)&quot;&quot;);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_starbucks_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;starbucks = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_starbucks_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_starbucks_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;starbucks);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_buckazoids_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;buckazoids = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_buckazoids_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_buckazoids_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;buckazoids);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_status_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_status_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;status = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_status_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_status_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;status);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_num_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_num_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;num = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_num_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_num_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;num);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_index_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_index_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;index = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_index_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_index_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;index);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_update(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    Ship *arg2 = (Ship *) 0 ;
-    GobStation *arg3 = (GobStation *) 0 ;
-    GobPlayer *arg4 = (GobPlayer *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_update&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (bool)(arg1)-&gt;update(arg2,arg3,arg4);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_execute(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    Ship *arg2 = (Ship *) 0 ;
-    GobStation *arg3 = (GobStation *) 0 ;
-    GobPlayer *arg4 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_execute&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;execute(arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_charge(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    GobPlayer *arg2 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:Upgrade_charge&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;charge(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_clear(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    Ship *arg2 = (Ship *) 0 ;
-    Ship *arg3 = (Ship *) 0 ;
-    GobPlayer *arg4 = (GobPlayer *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_clear&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;clear(arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_Upgrade_duplicate(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    Upgrade *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_duplicate&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (Upgrade *)(arg1)-&gt;duplicate();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Upgrade, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_Upgrade(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    Upgrade *arg1 = (Upgrade *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_Upgrade&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * Upgrade_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_Upgrade, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_RainbowRift_p_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    float *arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_p_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_float,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        int ii;
-        float *b = (float *) arg1-&gt;p;
-        for (ii = 0; ii &lt; RainbowRift::n*6+2; ii++) b[ii] = *((float *) arg2 + ii);
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_p_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    float *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_p_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (float *)(float *) ((arg1)-&gt;p);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_c_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    RGB *arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_c_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_RGB,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        int ii;
-        RGB *b = (RGB *) arg1-&gt;c;
-        for (ii = 0; ii &lt; RainbowRift::n; ii++) b[ii] = *((RGB *) arg2 + ii);
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_c_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    RGB *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_c_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (RGB *)(RGB *) ((arg1)-&gt;c);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RGB, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_next_time_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:RainbowRift_next_time_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;next_time = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_next_time_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_next_time_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;next_time);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_next_time2_set(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:RainbowRift_next_time2_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg1) (arg1)-&gt;next_time2 = arg2;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_next_time2_get(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_next_time2_get&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (int) ((arg1)-&gt;next_time2);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_RainbowRift(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_RainbowRift&quot;)) goto fail;
-    result = (RainbowRift *)new RainbowRift();
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RainbowRift, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_animate(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    Frame *arg2 = (Frame *) 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_animate&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Frame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;animate(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_calculate(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_calculate&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;calculate();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_RainbowRift_squiggle(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_squiggle&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;squiggle();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_RainbowRift(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    RainbowRift *arg1 = (RainbowRift *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_RainbowRift&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * RainbowRift_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_RainbowRift, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_new_vectorEnemySaveData__SWIG_0(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    unsigned int arg1 = (unsigned int) 0 ;
-    std::vector&lt;EnemySaveData &gt; *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;|O:new_vectorEnemySaveData&quot;,&amp;obj0)) goto fail;
-    if (obj0) {
-        arg1 = (unsigned int) PyInt_AsLong(obj0);
-        if (PyErr_Occurred()) SWIG_fail;
-    }
-    result = (std::vector&lt;EnemySaveData &gt; *)new std::vector&lt;EnemySaveData &gt;(arg1);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorEnemySaveData__SWIG_1(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    unsigned int arg1 ;
-    EnemySaveData *arg2 = 0 ;
-    std::vector&lt;EnemySaveData &gt; *result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:new_vectorEnemySaveData&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    arg1 = (unsigned int) PyInt_AsLong(obj0);
-    if (PyErr_Occurred()) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg2 == NULL) {
-        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
-    }
-    result = (std::vector&lt;EnemySaveData &gt; *)new std::vector&lt;EnemySaveData &gt;(arg1,(EnemySaveData const &amp;)*arg2);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorEnemySaveData__SWIG_2(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = 0 ;
-    std::vector&lt;EnemySaveData &gt; *result;
-    std::vector&lt;EnemySaveData &gt; temp1 ;
-    std::vector&lt;EnemySaveData &gt; *v1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorEnemySaveData&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
-            unsigned int size = (PyTuple_Check(obj0) ?
-            PyTuple_Size(obj0) :
-            PyList_Size(obj0));
-            temp1.reserve(size);
-            arg1 = &amp;temp1;
-            for (unsigned int i=0; i&lt;size; i++) {
-                EnemySaveData* x;
-                PyObject* o = PySequence_GetItem(obj0,i);
-                if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                SWIGTYPE_p_EnemySaveData,0)) != -1) {
-                    temp1.push_back(*x);
-                    Py_DECREF(o);
-                } else {
-                    Py_DECREF(o);
-                    PyErr_SetString(PyExc_TypeError,
-                    &quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
-                    SWIG_fail;
-                }
-            }
-        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
-        SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1) {
-            arg1 = v1;
-        } else {
-            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
-            SWIG_fail;
-        }
-    }
-    result = (std::vector&lt;EnemySaveData &gt; *)new std::vector&lt;EnemySaveData &gt;((std::vector&lt;EnemySaveData &gt; const &amp;)*arg1);
-    
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorEnemySaveData(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[3];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if ((argc &gt;= 0) &amp;&amp; (argc &lt;= 1)) {
-        int _v;
-        if (argc &lt;= 0) {
-            return _wrap_new_vectorEnemySaveData__SWIG_0(self,args);
-        }
-        {
-            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            return _wrap_new_vectorEnemySaveData__SWIG_0(self,args);
-        }
-    }
-    if (argc == 1) {
-        int _v;
-        {
-            /* native sequence? */
-            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
-                unsigned int size = (PyTuple_Check(argv[0]) ?
-                PyTuple_Size(argv[0]) :
-                PyList_Size(argv[0]));
-                if (size == 0) {
-                    /* an empty sequence can be of any type */
-                    _v = 1;
-                } else {
-                    /* check the first element only */
-                    EnemySaveData* x;
-                    PyObject* o = PySequence_GetItem(argv[0],0);
-                    if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                    SWIGTYPE_p_EnemySaveData,0)) != -1)
-                    _v = 1;
-                    else
-                    _v = 0;
-                    Py_DECREF(o);
-                }
-            } else {
-                /* wrapped vector? */
-                std::vector&lt;EnemySaveData &gt;* v;
-                if (SWIG_ConvertPtr(argv[0],(void **) &amp;v, 
-                SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1)
-                _v = 1;
-                else
-                _v = 0;
-            }
-        }
-        if (_v) {
-            return _wrap_new_vectorEnemySaveData__SWIG_2(self,args);
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
-        }
-        if (_v) {
-            {
-                void *ptr;
-                if (SWIG_ConvertPtr(argv[1], (void **) &amp;ptr, SWIGTYPE_p_EnemySaveData, 0) == -1) {
-                    _v = 0;
-                    PyErr_Clear();
-                } else {
-                    _v = 1;
-                }
-            }
-            if (_v) {
-                return _wrap_new_vectorEnemySaveData__SWIG_1(self,args);
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'new_vectorEnemySaveData'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___len__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    unsigned int result;
-    std::vector&lt;EnemySaveData &gt; temp1 ;
-    std::vector&lt;EnemySaveData &gt; *v1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData___len__&quot;,&amp;obj0)) goto fail;
-    {
-        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
-            unsigned int size = (PyTuple_Check(obj0) ?
-            PyTuple_Size(obj0) :
-            PyList_Size(obj0));
-            temp1.reserve(size);
-            arg1 = &amp;temp1;
-            for (unsigned int i=0; i&lt;size; i++) {
-                EnemySaveData* x;
-                PyObject* o = PySequence_GetItem(obj0,i);
-                if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                SWIGTYPE_p_EnemySaveData,0)) != -1) {
-                    temp1.push_back(*x);
-                    Py_DECREF(o);
-                } else {
-                    Py_DECREF(o);
-                    PyErr_SetString(PyExc_TypeError,
-                    &quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
-                    SWIG_fail;
-                }
-            }
-        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
-        SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1) {
-            arg1 = v1;
-        } else {
-            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
-            SWIG_fail;
-        }
-    }
-    result = (unsigned int)((std::vector&lt;EnemySaveData &gt; const *)arg1)-&gt;size();
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData_clear(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData_clear&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    (arg1)-&gt;clear();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData_append(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    EnemySaveData *arg2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorEnemySaveData_append&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg2 == NULL) {
-        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
-    }
-    (arg1)-&gt;push_back((EnemySaveData const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___nonzero__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData___nonzero__&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = (bool)std_vectorlEnemySaveData_g___nonzero_____(arg1);
-    
-    resultobj = PyInt_FromLong((long)result);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData_pop(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    EnemySaveData result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData_pop&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        try {
-            result = std_vectorlEnemySaveData_g_pop___(arg1);
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    {
-        EnemySaveData * resultptr;
-        resultptr = new EnemySaveData((EnemySaveData &amp;) result);
-        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_EnemySaveData, 1);
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___getitem__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    int arg2 ;
-    EnemySaveData *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorEnemySaveData___getitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        try {
-            {
-                EnemySaveData &amp;_result_ref = std_vectorlEnemySaveData_g___getitem_____(arg1,arg2);
-                result = (EnemySaveData *) &amp;_result_ref;
-            }
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_EnemySaveData, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___getslice__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    int arg2 ;
-    int arg3 ;
-    std::vector&lt;EnemySaveData &gt; result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorEnemySaveData___getslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    result = std_vectorlEnemySaveData_g___getslice_____(arg1,arg2,arg3);
-    
-    {
-        resultobj = PyTuple_New((&amp;result)-&gt;size());
-        for (unsigned int i=0; i&lt;(&amp;result)-&gt;size(); i++) {
-            EnemySaveData* ptr = new EnemySaveData(((std::vector&lt;EnemySaveData &gt; &amp;)result)[i]);
-            PyTuple_SetItem(resultobj,i,
-            SWIG_NewPointerObj((void *) ptr, 
-            SWIGTYPE_p_EnemySaveData, 1));
-        }
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___setitem__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    int arg2 ;
-    EnemySaveData *arg3 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OiO:vectorEnemySaveData___setitem__&quot;,&amp;obj0,&amp;arg2,&amp;obj2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    if (arg3 == NULL) {
-        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
-    }
-    {
-        try {
-            std_vectorlEnemySaveData_g___setitem_____(arg1,arg2,(EnemySaveData const &amp;)*arg3);
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___setslice__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    int arg2 ;
-    int arg3 ;
-    std::vector&lt;EnemySaveData &gt; *arg4 = 0 ;
-    std::vector&lt;EnemySaveData &gt; temp4 ;
-    std::vector&lt;EnemySaveData &gt; *v4 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OiiO:vectorEnemySaveData___setslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;obj3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
-            unsigned int size = (PyTuple_Check(obj3) ?
-            PyTuple_Size(obj3) :
-            PyList_Size(obj3));
-            temp4.reserve(size);
-            arg4 = &amp;temp4;
-            for (unsigned int i=0; i&lt;size; i++) {
-                EnemySaveData* x;
-                PyObject* o = PySequence_GetItem(obj3,i);
-                if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
-                SWIGTYPE_p_EnemySaveData,0)) != -1) {
-                    temp4.push_back(*x);
-                    Py_DECREF(o);
-                } else {
-                    Py_DECREF(o);
-                    PyErr_SetString(PyExc_TypeError,
-                    &quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
-                    SWIG_fail;
-                }
-            }
-        } else if (SWIG_ConvertPtr(obj3,(void **) &amp;v4, 
-        SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1) {
-            arg4 = v4;
-        } else {
-            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
-            SWIG_fail;
-        }
-    }
-    std_vectorlEnemySaveData_g___setslice_____(arg1,arg2,arg3,(std::vector&lt;EnemySaveData &gt; const &amp;)*arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___delitem__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    int arg2 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorEnemySaveData___delitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    {
-        try {
-            std_vectorlEnemySaveData_g___delitem_____(arg1,arg2);
-            
-        } catch (std::out_of_range&amp; e) {
-            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-        }
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorEnemySaveData___delslice__(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    int arg2 ;
-    int arg3 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorEnemySaveData___delslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    std_vectorlEnemySaveData_g___delslice_____(arg1,arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_vectorEnemySaveData(PyObject *self, PyObject *args) {
-    PyObject *resultobj;
-    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_vectorEnemySaveData&quot;,&amp;obj0)) goto fail;
-    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * vectorEnemySaveData_swigregister(PyObject *self, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTEnemySaveData_t, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyMethodDef SwigMethods[] = {
-	 { (char *)&quot;pair_id_set&quot;, _wrap_pair_id_set, METH_VARARGS },
-	 { (char *)&quot;pair_id_get&quot;, _wrap_pair_id_get, METH_VARARGS },
-	 { (char *)&quot;pair_value_set&quot;, _wrap_pair_value_set, METH_VARARGS },
-	 { (char *)&quot;pair_value_get&quot;, _wrap_pair_value_get, METH_VARARGS },
-	 { (char *)&quot;new_pair&quot;, _wrap_new_pair, METH_VARARGS },
-	 { (char *)&quot;delete_pair&quot;, _wrap_delete_pair, METH_VARARGS },
-	 { (char *)&quot;pair_swigregister&quot;, pair_swigregister, METH_VARARGS },
-	 { (char *)&quot;EnemySaveData_pos_x_set&quot;, _wrap_EnemySaveData_pos_x_set, METH_VARARGS },
-	 { (char *)&quot;EnemySaveData_pos_x_get&quot;, _wrap_EnemySaveData_pos_x_get, METH_VARARGS },
-	 { (char *)&quot;EnemySaveData_pos_y_set&quot;, _wrap_EnemySaveData_pos_y_set, METH_VARARGS },
-	 { (char *)&quot;EnemySaveData_pos_y_get&quot;, _wrap_EnemySaveData_pos_y_get, METH_VARARGS },
-	 { (char *)&quot;new_EnemySaveData&quot;, _wrap_new_EnemySaveData, METH_VARARGS },
-	 { (char *)&quot;delete_EnemySaveData&quot;, _wrap_delete_EnemySaveData, METH_VARARGS },
-	 { (char *)&quot;EnemySaveData_swigregister&quot;, EnemySaveData_swigregister, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_getInstance&quot;, _wrap_SaveGobGameInfo_getInstance, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_updateSave&quot;, _wrap_SaveGobGameInfo_updateSave, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_updateGame&quot;, _wrap_SaveGobGameInfo_updateGame, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_starbucks_set&quot;, _wrap_SaveGobGameInfo_starbucks_set, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_starbucks_get&quot;, _wrap_SaveGobGameInfo_starbucks_get, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_buckazoids_set&quot;, _wrap_SaveGobGameInfo_buckazoids_set, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_buckazoids_get&quot;, _wrap_SaveGobGameInfo_buckazoids_get, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_kills_set&quot;, _wrap_SaveGobGameInfo_kills_set, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_kills_get&quot;, _wrap_SaveGobGameInfo_kills_get, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_pos_x_set&quot;, _wrap_SaveGobGameInfo_pos_x_set, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_pos_x_get&quot;, _wrap_SaveGobGameInfo_pos_x_get, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_pos_y_set&quot;, _wrap_SaveGobGameInfo_pos_y_set, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_pos_y_get&quot;, _wrap_SaveGobGameInfo_pos_y_get, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_system_set&quot;, _wrap_SaveGobGameInfo_system_set, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_system_get&quot;, _wrap_SaveGobGameInfo_system_get, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_getSystem&quot;, _wrap_SaveGobGameInfo_getSystem, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_setSystem&quot;, _wrap_SaveGobGameInfo_setSystem, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_tst_set&quot;, _wrap_SaveGobGameInfo_tst_set, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_tst_get&quot;, _wrap_SaveGobGameInfo_tst_get, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_getTst&quot;, _wrap_SaveGobGameInfo_getTst, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_setTst&quot;, _wrap_SaveGobGameInfo_setTst, METH_VARARGS },
-	 { (char *)&quot;new_SaveGobGameInfo&quot;, _wrap_new_SaveGobGameInfo, METH_VARARGS },
-	 { (char *)&quot;delete_SaveGobGameInfo&quot;, _wrap_delete_SaveGobGameInfo, METH_VARARGS },
-	 { (char *)&quot;SaveGobGameInfo_swigregister&quot;, SaveGobGameInfo_swigregister, METH_VARARGS },
-	 { (char *)&quot;new_GobPlayer&quot;, _wrap_new_GobPlayer, METH_VARARGS },
-	 { (char *)&quot;delete_GobPlayer&quot;, _wrap_delete_GobPlayer, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_ship_set&quot;, _wrap_GobPlayer_ship_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_ship_get&quot;, _wrap_GobPlayer_ship_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_pair_list_set&quot;, _wrap_GobPlayer_pair_list_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_pair_list_get&quot;, _wrap_GobPlayer_pair_list_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_num_pairs_set&quot;, _wrap_GobPlayer_num_pairs_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_num_pairs_get&quot;, _wrap_GobPlayer_num_pairs_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_total_set&quot;, _wrap_GobPlayer_total_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_total_get&quot;, _wrap_GobPlayer_total_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_starbucks_set&quot;, _wrap_GobPlayer_starbucks_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_starbucks_get&quot;, _wrap_GobPlayer_starbucks_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_buckazoids_set&quot;, _wrap_GobPlayer_buckazoids_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_buckazoids_get&quot;, _wrap_GobPlayer_buckazoids_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_kills_set&quot;, _wrap_GobPlayer_kills_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_kills_get&quot;, _wrap_GobPlayer_kills_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_value_starbucks_set&quot;, _wrap_GobPlayer_value_starbucks_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_value_starbucks_get&quot;, _wrap_GobPlayer_value_starbucks_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_value_buckazoids_set&quot;, _wrap_GobPlayer_value_buckazoids_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_value_buckazoids_get&quot;, _wrap_GobPlayer_value_buckazoids_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_team_set&quot;, _wrap_GobPlayer_team_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_team_get&quot;, _wrap_GobPlayer_team_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_init&quot;, _wrap_GobPlayer_init, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_died&quot;, _wrap_GobPlayer_died, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_new_ship&quot;, _wrap_GobPlayer_new_ship, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_charge&quot;, _wrap_GobPlayer_charge, METH_VARARGS },
-	 { (char *)&quot;GobPlayer__add_pair&quot;, _wrap_GobPlayer__add_pair, METH_VARARGS },
-	 { (char *)&quot;GobPlayer__get_pair&quot;, _wrap_GobPlayer__get_pair, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_write_pair&quot;, _wrap_GobPlayer_write_pair, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_read_pair&quot;, _wrap_GobPlayer_read_pair, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_upgrade_list_set&quot;, _wrap_GobPlayer_upgrade_list_set, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_upgrade_list_get&quot;, _wrap_GobPlayer_upgrade_list_get, METH_VARARGS },
-	 { (char *)&quot;GobPlayer_swigregister&quot;, GobPlayer_swigregister, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_ship_set&quot;, _wrap_GobEnemy_ship_set, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_ship_get&quot;, _wrap_GobEnemy_ship_get, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_starbucks_set&quot;, _wrap_GobEnemy_starbucks_set, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_starbucks_get&quot;, _wrap_GobEnemy_starbucks_get, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_buckazoids_set&quot;, _wrap_GobEnemy_buckazoids_set, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_buckazoids_get&quot;, _wrap_GobEnemy_buckazoids_get, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_init&quot;, _wrap_GobEnemy_init, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_died&quot;, _wrap_GobEnemy_died, METH_VARARGS },
-	 { (char *)&quot;new_GobEnemy&quot;, _wrap_new_GobEnemy, METH_VARARGS },
-	 { (char *)&quot;delete_GobEnemy&quot;, _wrap_delete_GobEnemy, METH_VARARGS },
-	 { (char *)&quot;GobEnemy_swigregister&quot;, GobEnemy_swigregister, METH_VARARGS },
-	 { (char *)&quot;GobAsteroid_handle_damage&quot;, _wrap_GobAsteroid_handle_damage, METH_VARARGS },
-	 { (char *)&quot;GobAsteroid_death&quot;, _wrap_GobAsteroid_death, METH_VARARGS },
-	 { (char *)&quot;new_GobAsteroid&quot;, _wrap_new_GobAsteroid, METH_VARARGS },
-	 { (char *)&quot;delete_GobAsteroid&quot;, _wrap_delete_GobAsteroid, METH_VARARGS },
-	 { (char *)&quot;GobAsteroid_swigregister&quot;, GobAsteroid_swigregister, METH_VARARGS },
-	 { (char *)&quot;GobGame__galaxy_set&quot;, _wrap_GobGame__galaxy_set, METH_VARARGS },
-	 { (char *)&quot;GobGame__galaxy_get&quot;, _wrap_GobGame__galaxy_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_gobplayer_set&quot;, _wrap_GobGame_gobplayer_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_gobplayer_get&quot;, _wrap_GobGame_gobplayer_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_switch_system&quot;, _wrap_GobGame_switch_system, METH_VARARGS },
-	 { (char *)&quot;new_GobGame&quot;, _wrap_new_GobGame, METH_VARARGS },
-	 { (char *)&quot;GobGame_get_this&quot;, _wrap_GobGame_get_this, METH_VARARGS },
-	 { (char *)&quot;delete_GobGame&quot;, _wrap_delete_GobGame, METH_VARARGS },
-	 { (char *)&quot;GobGame__player_panel_set&quot;, _wrap_GobGame__player_panel_set, METH_VARARGS },
-	 { (char *)&quot;GobGame__player_panel_get&quot;, _wrap_GobGame__player_panel_get, METH_VARARGS },
-	 { (char *)&quot;GobGame__player_control_set&quot;, _wrap_GobGame__player_control_set, METH_VARARGS },
-	 { (char *)&quot;GobGame__player_control_get&quot;, _wrap_GobGame__player_control_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_enemy_team_set&quot;, _wrap_GobGame_enemy_team_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_enemy_team_get&quot;, _wrap_GobGame_enemy_team_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_AddPanel&quot;, _wrap_GobGame_AddPanel, METH_VARARGS },
-	 { (char *)&quot;GobGame_calculate&quot;, _wrap_GobGame_calculate, METH_VARARGS },
-	 { (char *)&quot;GobGame_setGameDone&quot;, _wrap_GobGame_setGameDone, METH_VARARGS },
-	 { (char *)&quot;GobGame_ship_died&quot;, _wrap_GobGame_ship_died, METH_VARARGS },
-	 { (char *)&quot;GobGame_preinit&quot;, _wrap_GobGame_preinit, METH_VARARGS },
-	 { (char *)&quot;GobGame_init&quot;, _wrap_GobGame_init, METH_VARARGS },
-	 { (char *)&quot;GobGame_play_sound&quot;, _wrap_GobGame_play_sound, METH_VARARGS },
-	 { (char *)&quot;GobGame_add_gobplayer&quot;, _wrap_GobGame_add_gobplayer, METH_VARARGS },
-	 { (char *)&quot;GobGame_get_player&quot;, _wrap_GobGame_get_player, METH_VARARGS },
-	 { (char *)&quot;GobGame_gobenemies_set&quot;, _wrap_GobGame_gobenemies_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_gobenemies_get&quot;, _wrap_GobGame_gobenemies_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_max_enemies_set&quot;, _wrap_GobGame_max_enemies_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_max_enemies_get&quot;, _wrap_GobGame_max_enemies_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_gobenemy_set&quot;, _wrap_GobGame_gobenemy_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_gobenemy_get&quot;, _wrap_GobGame_gobenemy_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_get_enemy_index&quot;, _wrap_GobGame_get_enemy_index, METH_VARARGS },
-	 { (char *)&quot;GobGame_prepare&quot;, _wrap_GobGame_prepare, METH_VARARGS },
-	 { (char *)&quot;GobGame_fps&quot;, _wrap_GobGame_fps, METH_VARARGS },
-	 { (char *)&quot;GobGame_add_new_enemy&quot;, _wrap_GobGame_add_new_enemy, METH_VARARGS },
-	 { (char *)&quot;GobGame_add_stars&quot;, _wrap_GobGame_add_stars, METH_VARARGS },
-	 { (char *)&quot;GobGame_add_asteroid&quot;, _wrap_GobGame_add_asteroid, METH_VARARGS },
-	 { (char *)&quot;GobGame_add_system&quot;, _wrap_GobGame_add_system, METH_VARARGS },
-	 { (char *)&quot;GobGame_add_player&quot;, _wrap_GobGame_add_player, METH_VARARGS },
-	 { (char *)&quot;GobGame_next_add_new_enemy_time_set&quot;, _wrap_GobGame_next_add_new_enemy_time_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_next_add_new_enemy_time_get&quot;, _wrap_GobGame_next_add_new_enemy_time_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_defenderSprite_set&quot;, _wrap_GobGame_defenderSprite_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_defenderSprite_get&quot;, _wrap_GobGame_defenderSprite_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_num_planets_set&quot;, _wrap_GobGame_num_planets_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_num_planets_get&quot;, _wrap_GobGame_num_planets_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_planet_set&quot;, _wrap_GobGame_planet_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_planet_get&quot;, _wrap_GobGame_planet_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_station_set&quot;, _wrap_GobGame_station_set, METH_VARARGS },
-	 { (char *)&quot;GobGame_station_get&quot;, _wrap_GobGame_station_get, METH_VARARGS },
-	 { (char *)&quot;GobGame_add_planet_and_station&quot;, _wrap_GobGame_add_planet_and_station, METH_VARARGS },
-	 { (char *)&quot;GobGame_swigregister&quot;, GobGame_swigregister, METH_VARARGS },
-	 { (char *)&quot;GobStation__build_type_set&quot;, _wrap_GobStation__build_type_set, METH_VARARGS },
-	 { (char *)&quot;GobStation__build_type_get&quot;, _wrap_GobStation__build_type_get, METH_VARARGS },
-	 { (char *)&quot;GobStation__background_pic_set&quot;, _wrap_GobStation__background_pic_set, METH_VARARGS },
-	 { (char *)&quot;GobStation__background_pic_get&quot;, _wrap_GobStation__background_pic_get, METH_VARARGS },
-	 { (char *)&quot;new_GobStation&quot;, _wrap_new_GobStation, METH_VARARGS },
-	 { (char *)&quot;GobStation_buy_new_ship_menu&quot;, _wrap_GobStation_buy_new_ship_menu, METH_VARARGS },
-	 { (char *)&quot;GobStation_inflict_damage&quot;, _wrap_GobStation_inflict_damage, METH_VARARGS },
-	 { (char *)&quot;GobStation_station_screen&quot;, _wrap_GobStation_station_screen, METH_VARARGS },
-	 { (char *)&quot;GobStation_upgrade_menu&quot;, _wrap_GobStation_upgrade_menu, METH_VARARGS },
-	 { (char *)&quot;delete_GobStation&quot;, _wrap_delete_GobStation, METH_VARARGS },
-	 { (char *)&quot;GobStation_swigregister&quot;, GobStation_swigregister, METH_VARARGS },
-	 { (char *)&quot;Upgrade_name_set&quot;, _wrap_Upgrade_name_set, METH_VARARGS },
-	 { (char *)&quot;Upgrade_name_get&quot;, _wrap_Upgrade_name_get, METH_VARARGS },
-	 { (char *)&quot;Upgrade_starbucks_set&quot;, _wrap_Upgrade_starbucks_set, METH_VARARGS },
-	 { (char *)&quot;Upgrade_starbucks_get&quot;, _wrap_Upgrade_starbucks_get, METH_VARARGS },
-	 { (char *)&quot;Upgrade_buckazoids_set&quot;, _wrap_Upgrade_buckazoids_set, METH_VARARGS },
-	 { (char *)&quot;Upgrade_buckazoids_get&quot;, _wrap_Upgrade_buckazoids_get, METH_VARARGS },
-	 { (char *)&quot;Upgrade_status_set&quot;, _wrap_Upgrade_status_set, METH_VARARGS },
-	 { (char *)&quot;Upgrade_status_get&quot;, _wrap_Upgrade_status_get, METH_VARARGS },
-	 { (char *)&quot;Upgrade_num_set&quot;, _wrap_Upgrade_num_set, METH_VARARGS },
-	 { (char *)&quot;Upgrade_num_get&quot;, _wrap_Upgrade_num_get, METH_VARARGS },
-	 { (char *)&quot;Upgrade_index_set&quot;, _wrap_Upgrade_index_set, METH_VARARGS },
-	 { (char *)&quot;Upgrade_index_get&quot;, _wrap_Upgrade_index_get, METH_VARARGS },
-	 { (char *)&quot;Upgrade_update&quot;, _wrap_Upgrade_update, METH_VARARGS },
-	 { (char *)&quot;Upgrade_execute&quot;, _wrap_Upgrade_execute, METH_VARARGS },
-	 { (char *)&quot;Upgrade_charge&quot;, _wrap_Upgrade_charge, METH_VARARGS },
-	 { (char *)&quot;Upgrade_clear&quot;, _wrap_Upgrade_clear, METH_VARARGS },
-	 { (char *)&quot;Upgrade_duplicate&quot;, _wrap_Upgrade_duplicate, METH_VARARGS },
-	 { (char *)&quot;delete_Upgrade&quot;, _wrap_delete_Upgrade, METH_VARARGS },
-	 { (char *)&quot;Upgrade_swigregister&quot;, Upgrade_swigregister, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_p_set&quot;, _wrap_RainbowRift_p_set, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_p_get&quot;, _wrap_RainbowRift_p_get, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_c_set&quot;, _wrap_RainbowRift_c_set, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_c_get&quot;, _wrap_RainbowRift_c_get, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_next_time_set&quot;, _wrap_RainbowRift_next_time_set, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_next_time_get&quot;, _wrap_RainbowRift_next_time_get, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_next_time2_set&quot;, _wrap_RainbowRift_next_time2_set, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_next_time2_get&quot;, _wrap_RainbowRift_next_time2_get, METH_VARARGS },
-	 { (char *)&quot;new_RainbowRift&quot;, _wrap_new_RainbowRift, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_animate&quot;, _wrap_RainbowRift_animate, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_calculate&quot;, _wrap_RainbowRift_calculate, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_squiggle&quot;, _wrap_RainbowRift_squiggle, METH_VARARGS },
-	 { (char *)&quot;delete_RainbowRift&quot;, _wrap_delete_RainbowRift, METH_VARARGS },
-	 { (char *)&quot;RainbowRift_swigregister&quot;, RainbowRift_swigregister, METH_VARARGS },
-	 { (char *)&quot;new_vectorEnemySaveData&quot;, _wrap_new_vectorEnemySaveData, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___len__&quot;, _wrap_vectorEnemySaveData___len__, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData_clear&quot;, _wrap_vectorEnemySaveData_clear, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData_append&quot;, _wrap_vectorEnemySaveData_append, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___nonzero__&quot;, _wrap_vectorEnemySaveData___nonzero__, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData_pop&quot;, _wrap_vectorEnemySaveData_pop, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___getitem__&quot;, _wrap_vectorEnemySaveData___getitem__, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___getslice__&quot;, _wrap_vectorEnemySaveData___getslice__, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___setitem__&quot;, _wrap_vectorEnemySaveData___setitem__, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___setslice__&quot;, _wrap_vectorEnemySaveData___setslice__, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___delitem__&quot;, _wrap_vectorEnemySaveData___delitem__, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData___delslice__&quot;, _wrap_vectorEnemySaveData___delslice__, METH_VARARGS },
-	 { (char *)&quot;delete_vectorEnemySaveData&quot;, _wrap_delete_vectorEnemySaveData, METH_VARARGS },
-	 { (char *)&quot;vectorEnemySaveData_swigregister&quot;, vectorEnemySaveData_swigregister, METH_VARARGS },
-	 { NULL, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static void *_p_RainbowRiftTo_p_SpaceLocation(void *x) {
-    return (void *)((SpaceLocation *)  ((RainbowRift *) x));
-}
-static swig_type_info _swigt__p_GobPlayer[] = {{&quot;_p_GobPlayer&quot;, 0, &quot;GobPlayer *&quot;, 0},{&quot;_p_GobPlayer&quot;},{0}};
-static swig_type_info _swigt__p_p_Upgrade[] = {{&quot;_p_p_Upgrade&quot;, 0, &quot;Upgrade **&quot;, 0},{&quot;_p_p_Upgrade&quot;},{0}};
-static swig_type_info _swigt__p_SpaceLocation[] = {{&quot;_p_SpaceLocation&quot;, 0, &quot;SpaceLocation *&quot;, 0},{&quot;_p_SpaceLocation&quot;},{&quot;_p_RainbowRift&quot;, _p_RainbowRiftTo_p_SpaceLocation},{0}};
-static swig_type_info _swigt__p_p_GobStation[] = {{&quot;_p_p_GobStation&quot;, 0, &quot;GobStation **&quot;, 0},{&quot;_p_p_GobStation&quot;},{0}};
-static swig_type_info _swigt__p_GobStation[] = {{&quot;_p_GobStation&quot;, 0, &quot;GobStation *&quot;, 0},{&quot;_p_GobStation&quot;},{0}};
-static swig_type_info _swigt__p_Upgrade[] = {{&quot;_p_Upgrade&quot;, 0, &quot;Upgrade *&quot;, 0},{&quot;_p_Upgrade&quot;},{0}};
-static swig_type_info _swigt__p_RGB[] = {{&quot;_p_RGB&quot;, 0, &quot;RGB *&quot;, 0},{&quot;_p_RGB&quot;},{0}};
-static swig_type_info _swigt__p_Log[] = {{&quot;_p_Log&quot;, 0, &quot;Log *&quot;, 0},{&quot;_p_Log&quot;},{0}};
-static swig_type_info _swigt__p_StarMap[] = {{&quot;_p_StarMap&quot;, 0, &quot;StarMap *&quot;, 0},{&quot;_p_StarMap&quot;},{0}};
-static swig_type_info _swigt__p_float[] = {{&quot;_p_float&quot;, 0, &quot;float *&quot;, 0},{&quot;_p_float&quot;},{0}};
-static swig_type_info _swigt__p_std__vectorTEnemySaveData_t[] = {{&quot;_p_std__vectorTEnemySaveData_t&quot;, 0, &quot;std::vector&lt;EnemySaveData &gt; *&quot;, 0},{&quot;_p_std__vectorTEnemySaveData_t&quot;},{0}};
-static swig_type_info _swigt__p_GobAsteroid[] = {{&quot;_p_GobAsteroid&quot;, 0, &quot;GobAsteroid *&quot;, 0},{&quot;_p_GobAsteroid&quot;},{0}};
-static swig_type_info _swigt__p_TeamCode[] = {{&quot;_p_TeamCode&quot;, 0, &quot;TeamCode *&quot;, 0},{&quot;_p_TeamCode&quot;},{0}};
-static swig_type_info _swigt__p_GobEnemy[] = {{&quot;_p_GobEnemy&quot;, 0, &quot;GobEnemy *&quot;, 0},{&quot;_p_GobEnemy&quot;},{0}};
-static swig_type_info _swigt__p_p_GobEnemy[] = {{&quot;_p_p_GobEnemy&quot;, 0, &quot;GobEnemy **&quot;, 0},{&quot;_p_p_GobEnemy&quot;},{0}};
-static swig_type_info _swigt__p_p_Planet[] = {{&quot;_p_p_Planet&quot;, 0, &quot;Planet **&quot;, 0},{&quot;_p_p_Planet&quot;},{0}};
-static swig_type_info _swigt__p_RainbowRift[] = {{&quot;_p_RainbowRift&quot;, 0, &quot;RainbowRift *&quot;, 0},{&quot;_p_RainbowRift&quot;},{0}};
-static swig_type_info _swigt__p_GobGame[] = {{&quot;_p_GobGame&quot;, 0, &quot;GobGame *&quot;, 0},{&quot;_p_GobGame&quot;},{0}};
-static swig_type_info _swigt__p_EnemySaveData[] = {{&quot;_p_EnemySaveData&quot;, 0, &quot;EnemySaveData *&quot;, 0},{&quot;_p_EnemySaveData&quot;},{0}};
-static swig_type_info _swigt__p_std__string[] = {{&quot;_p_std__string&quot;, 0, &quot;std::string *&quot;, 0},{&quot;_p_std__string&quot;},{0}};
-static swig_type_info _swigt__p_Vector2[] = {{&quot;_p_Vector2&quot;, 0, &quot;Vector2 *&quot;, 0},{&quot;_p_Vector2&quot;},{0}};
-static swig_type_info _swigt__p_SaveGobGameInfo[] = {{&quot;_p_SaveGobGameInfo&quot;, 0, &quot;SaveGobGameInfo *&quot;, 0},{&quot;_p_SaveGobGameInfo&quot;},{0}};
-static swig_type_info _swigt__p_pair[] = {{&quot;_p_pair&quot;, 0, &quot;pair *&quot;, 0},{&quot;_p_pair&quot;},{0}};
-static swig_type_info _swigt__p_SpaceSprite[] = {{&quot;_p_SpaceSprite&quot;, 0, &quot;SpaceSprite *&quot;, 0},{&quot;_p_SpaceSprite&quot;},{0}};
-static swig_type_info _swigt__p_Control[] = {{&quot;_p_Control&quot;, 0, &quot;Control *&quot;, 0},{&quot;_p_Control&quot;},{0}};
-static swig_type_info _swigt__p_SpaceObject[] = {{&quot;_p_SpaceObject&quot;, 0, &quot;SpaceObject *&quot;, 0},{&quot;_p_SpaceObject&quot;},{0}};
-static swig_type_info _swigt__p_Frame[] = {{&quot;_p_Frame&quot;, 0, &quot;Frame *&quot;, 0},{&quot;_p_Frame&quot;},{0}};
-static swig_type_info _swigt__p_ShipPanel[] = {{&quot;_p_ShipPanel&quot;, 0, &quot;ShipPanel *&quot;, 0},{&quot;_p_ShipPanel&quot;},{0}};
-static swig_type_info _swigt__p_SAMPLE[] = {{&quot;_p_SAMPLE&quot;, 0, &quot;SAMPLE *&quot;, 0},{&quot;_p_SAMPLE&quot;},{0}};
-static swig_type_info _swigt__p_ShipType[] = {{&quot;_p_ShipType&quot;, 0, &quot;ShipType *&quot;, 0},{&quot;_p_ShipType&quot;},{0}};
-static swig_type_info _swigt__p_Ship[] = {{&quot;_p_Ship&quot;, 0, &quot;Ship *&quot;, 0},{&quot;_p_Ship&quot;},{0}};
-
-static swig_type_info *swig_types_initial[] = {
-_swigt__p_GobPlayer, 
-_swigt__p_p_Upgrade, 
-_swigt__p_SpaceLocation, 
-_swigt__p_p_GobStation, 
-_swigt__p_GobStation, 
-_swigt__p_Upgrade, 
-_swigt__p_RGB, 
-_swigt__p_Log, 
-_swigt__p_StarMap, 
-_swigt__p_float, 
-_swigt__p_std__vectorTEnemySaveData_t, 
-_swigt__p_GobAsteroid, 
-_swigt__p_TeamCode, 
-_swigt__p_GobEnemy, 
-_swigt__p_p_GobEnemy, 
-_swigt__p_p_Planet, 
-_swigt__p_RainbowRift, 
-_swigt__p_GobGame, 
-_swigt__p_EnemySaveData, 
-_swigt__p_std__string, 
-_swigt__p_Vector2, 
-_swigt__p_SaveGobGameInfo, 
-_swigt__p_pair, 
-_swigt__p_SpaceSprite, 
-_swigt__p_Control, 
-_swigt__p_SpaceObject, 
-_swigt__p_Frame, 
-_swigt__p_ShipPanel, 
-_swigt__p_SAMPLE, 
-_swigt__p_ShipType, 
-_swigt__p_Ship, 
-0
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{ SWIG_PY_INT,     (char *)&quot;Upgrade_active&quot;, (long) Upgrade::active, 0, 0, 0},
-{ SWIG_PY_INT,     (char *)&quot;Upgrade_inactive&quot;, (long) Upgrade::inactive, 0, 0, 0},
-{ SWIG_PY_INT,     (char *)&quot;RainbowRift_n&quot;, (long) RainbowRift::n, 0, 0, 0},
-{0}};
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-#endif
-SWIGEXPORT(void) SWIG_init(void) {
-    static PyObject *SWIG_globals = 0; 
-    static int       typeinit = 0;
-    PyObject *m, *d;
-    int       i;
-    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
-    m = Py_InitModule((char *) SWIG_name, SwigMethods);
-    d = PyModule_GetDict(m);
-    
-    if (!typeinit) {
-        for (i = 0; swig_types_initial[i]; i++) {
-            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
-        }
-        typeinit = 1;
-    }
-    SWIG_InstallConstants(d,swig_const_table);
-    
-}
-

Copied: trunk/source/generated/tml_wrap.cpp (from rev 147, trunk/source/generated/ggob_wrap.cpp)
===================================================================
--- trunk/source/generated/ggob_wrap.cpp	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/generated/tml_wrap.cpp	2005-05-05 19:42:24 UTC (rev 148)
@@ -0,0 +1,5773 @@
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
+ * Version 1.3.21
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGPYTHON
+
+#ifdef __cplusplus
+template&lt;class T&gt; class SwigValueWrapper {
+    T *tt;
+public:
+    SwigValueWrapper() : tt(0) { }
+    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
+    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
+    ~SwigValueWrapper() { delete tt; } 
+    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
+    operator T&amp;() const { return *tt; }
+    T *operator&amp;() { return tt; }
+private:
+    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
+};                                                    
+#endif
+
+
+#include &quot;Python.h&quot;
+
+/*************************************************************** -*- c -*-
+ * python/precommon.swg
+ *
+ * Rename all exported symbols from common.swg, to avoid symbol
+ * clashes if multiple interpreters are included
+ *
+ ************************************************************************/
+
+#define SWIG_TypeRegister    SWIG_Python_TypeRegister
+#define SWIG_TypeCheck       SWIG_Python_TypeCheck
+#define SWIG_TypeCast        SWIG_Python_TypeCast
+#define SWIG_TypeDynamicCast SWIG_Python_TypeDynamicCast
+#define SWIG_TypeName        SWIG_Python_TypeName
+#define SWIG_TypeQuery       SWIG_Python_TypeQuery
+#define SWIG_TypeClientData  SWIG_Python_TypeClientData
+#define SWIG_PackData        SWIG_Python_PackData 
+#define SWIG_UnpackData      SWIG_Python_UnpackData 
+
+
+/***********************************************************************
+ * common.swg
+ *
+ *     This file contains generic SWIG runtime support for pointer
+ *     type checking as well as a few commonly used macros to control
+ *     external linkage.
+ *
+ * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
+ *
+ * Copyright (c) 1999-2000, The University of Chicago
+ * 
+ * This file may be freely redistributed without license or fee provided
+ * this copyright message remains intact.
+ ************************************************************************/
+
+#include &lt;string.h&gt;
+
+#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#  if defined(_MSC_VER) || defined(__GNUC__)
+#    if defined(STATIC_LINKED)
+#      define SWIGEXPORT(a) a
+#      define SWIGIMPORT(a) extern a
+#    else
+#      define SWIGEXPORT(a) __declspec(dllexport) a
+#      define SWIGIMPORT(a) extern a
+#    endif
+#  else
+#    if defined(__BORLANDC__)
+#      define SWIGEXPORT(a) a _export
+#      define SWIGIMPORT(a) a _export
+#    else
+#      define SWIGEXPORT(a) a
+#      define SWIGIMPORT(a) a
+#    endif
+#  endif
+#else
+#  define SWIGEXPORT(a) a
+#  define SWIGIMPORT(a) a
+#endif
+
+#ifdef SWIG_GLOBAL
+#  define SWIGRUNTIME(a) SWIGEXPORT(a)
+#else
+#  define SWIGRUNTIME(a) static a
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef void *(*swig_converter_func)(void *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+typedef struct swig_type_info {
+  const char             *name;
+  swig_converter_func     converter;
+  const char             *str;
+  void                   *clientdata;
+  swig_dycast_func        dcast;
+  struct swig_type_info  *next;
+  struct swig_type_info  *prev;
+} swig_type_info;
+
+#ifdef SWIG_NOINCLUDE
+
+SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
+SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
+SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
+SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
+SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
+SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
+SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);
+
+#else
+
+static swig_type_info *swig_type_list = 0;
+
+/* Register a type mapping with the type-checking */
+SWIGRUNTIME(swig_type_info *)
+SWIG_TypeRegister(swig_type_info *ti) {
+  swig_type_info *tc, *head, *ret, *next;
+  /* Check to see if this type has already been registered */
+  tc = swig_type_list;
+  while (tc) {
+    if (strcmp(tc-&gt;name, ti-&gt;name) == 0) {
+      /* Already exists in the table.  Just add additional types to the list */
+      if (tc-&gt;clientdata) ti-&gt;clientdata = tc-&gt;clientdata;
+      head = tc;
+      next = tc-&gt;next;
+      goto l1;
+    }
+    tc = tc-&gt;prev;
+  }
+  head = ti;
+  next = 0;
+
+  /* Place in list */
+  ti-&gt;prev = swig_type_list;
+  swig_type_list = ti;
+
+  /* Build linked lists */
+  l1:
+  ret = head;
+  tc = ti + 1;
+  /* Patch up the rest of the links */
+  while (tc-&gt;name) {
+    head-&gt;next = tc;
+    tc-&gt;prev = head;
+    head = tc;
+    tc++;
+  }
+  if (next) next-&gt;prev = head;
+  head-&gt;next = next;
+  return ret;
+}
+
+/* Check the typename */
+SWIGRUNTIME(swig_type_info *) 
+SWIG_TypeCheck(char *c, swig_type_info *ty) {
+  swig_type_info *s;
+  if (!ty) return 0;        /* Void pointer */
+  s = ty-&gt;next;             /* First element always just a name */
+  do {
+    if (strcmp(s-&gt;name,c) == 0) {
+      if (s == ty-&gt;next) return s;
+      /* Move s to the top of the linked list */
+      s-&gt;prev-&gt;next = s-&gt;next;
+      if (s-&gt;next) {
+        s-&gt;next-&gt;prev = s-&gt;prev;
+      }
+      /* Insert s as second element in the list */
+      s-&gt;next = ty-&gt;next;
+      if (ty-&gt;next) ty-&gt;next-&gt;prev = s;
+      ty-&gt;next = s;
+      s-&gt;prev = ty;
+      return s;
+    }
+    s = s-&gt;next;
+  } while (s &amp;&amp; (s != ty-&gt;next));
+  return 0;
+}
+
+/* Cast a pointer up an inheritance hierarchy */
+SWIGRUNTIME(void *) 
+SWIG_TypeCast(swig_type_info *ty, void *ptr) {
+  if ((!ty) || (!ty-&gt;converter)) return ptr;
+  return (*ty-&gt;converter)(ptr);
+}
+
+/* Dynamic pointer casting. Down an inheritance hierarchy */
+SWIGRUNTIME(swig_type_info *) 
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty-&gt;dcast) return ty;
+  while (ty &amp;&amp; (ty-&gt;dcast)) {
+    ty = (*ty-&gt;dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/* Return the name associated with this type */
+SWIGRUNTIME(const char *)
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty-&gt;name;
+}
+
+/* Search for a swig_type_info structure */
+SWIGRUNTIME(swig_type_info *)
+SWIG_TypeQuery(const char *name) {
+  swig_type_info *ty = swig_type_list;
+  while (ty) {
+    if (ty-&gt;str &amp;&amp; (strcmp(name,ty-&gt;str) == 0)) return ty;
+    if (ty-&gt;name &amp;&amp; (strcmp(name,ty-&gt;name) == 0)) return ty;
+    ty = ty-&gt;prev;
+  }
+  return 0;
+}
+
+/* Set the clientdata field for a type */
+SWIGRUNTIME(void)
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_type_info *tc, *equiv;
+  if (ti-&gt;clientdata == clientdata) return;
+  ti-&gt;clientdata = clientdata;
+  equiv = ti-&gt;next;
+  while (equiv) {
+    if (!equiv-&gt;converter) {
+      tc = swig_type_list;
+      while (tc) {
+        if ((strcmp(tc-&gt;name, equiv-&gt;name) == 0))
+          SWIG_TypeClientData(tc,clientdata);
+        tc = tc-&gt;prev;
+      }
+    }
+    equiv = equiv-&gt;next;
+  }
+}
+
+/* Pack binary data into a string */
+SWIGRUNTIME(char *)
+SWIG_PackData(char *c, void *ptr, int sz) {
+  static char hex[17] = &quot;0123456789abcdef&quot;;
+  int i;
+  unsigned char *u = (unsigned char *) ptr;
+  register unsigned char uu;
+  for (i = 0; i &lt; sz; i++,u++) {
+    uu = *u;
+    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
+    *(c++) = hex[uu &amp; 0xf];
+  }
+  return c;
+}
+
+/* Unpack binary data from a string */
+SWIGRUNTIME(char *)
+SWIG_UnpackData(char *c, void *ptr, int sz) {
+  register unsigned char uu = 0;
+  register int d;
+  unsigned char *u = (unsigned char *) ptr;
+  int i;
+  for (i = 0; i &lt; sz; i++, u++) {
+    d = *(c++);
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu = ((d - '0') &lt;&lt; 4);
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu = ((d - ('a'-10)) &lt;&lt; 4);
+    d = *(c++);
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu |= (d - '0');
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu |= (d - ('a'-10));
+    *u = uu;
+  }
+  return c;
+}
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+/***********************************************************************
+ * python.swg
+ *
+ *     This file contains the runtime support for Python modules
+ *     and includes code for managing global variables and pointer
+ *     type checking.
+ *
+ * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
+ ************************************************************************/
+
+#include &quot;Python.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define SWIG_PY_INT     1
+#define SWIG_PY_FLOAT   2
+#define SWIG_PY_STRING  3
+#define SWIG_PY_POINTER 4
+#define SWIG_PY_BINARY  5
+
+/* Flags for pointer conversion */
+
+#define SWIG_POINTER_EXCEPTION     0x1
+#define SWIG_POINTER_DISOWN        0x2
+
+/* Exception handling in wrappers */
+#define SWIG_fail   goto fail
+
+/* Constant information structure */
+typedef struct swig_const_info {
+    int type;
+    char *name;
+    long lvalue;
+    double dvalue;
+    void   *pvalue;
+    swig_type_info **ptype;
+} swig_const_info;
+
+/* Common SWIG API */
+#define SWIG_ConvertPtr(obj, pp, type, flags) \
+  SWIG_Python_ConvertPtr(obj, pp, type, flags)
+#define SWIG_NewPointerObj(p, type, flags) \
+  SWIG_Python_NewPointerObj(p, type, flags)
+#define SWIG_MustGetPtr(p, type, argnum, flags) \
+  SWIG_Python_MustGetPtr(p, type, argnum, flags)
+
+/* Python-specific SWIG API */
+#define SWIG_newvarlink() \
+  SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr) \
+  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
+  SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
+#define SWIG_NewPackedObj(ptr, sz, type) \
+  SWIG_Python_NewPackedObj(ptr, sz, type)
+#define SWIG_InstallConstants(d, constants) \
+  SWIG_Python_InstallConstants(d, constants)
+
+#ifdef SWIG_NOINCLUDE
+
+SWIGIMPORT(int)               SWIG_Python_ConvertPtr(PyObject *, void **, swig_type_info *, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_NewPointerObj(void *, swig_type_info *,int own);
+SWIGIMPORT(void *)            SWIG_Python_MustGetPtr(PyObject *, swig_type_info *, int, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_newvarlink(void);
+SWIGIMPORT(void)              SWIG_Python_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
+SWIGIMPORT(int)               SWIG_Python_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
+SWIGIMPORT(PyObject *)        SWIG_Python_NewPackedObj(void *, int sz, swig_type_info *);
+SWIGIMPORT(void)              SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]);
+
+#else
+
+/* -----------------------------------------------------------------------------
+ * global variable support code.
+ * ----------------------------------------------------------------------------- */
+
+typedef struct swig_globalvar {   
+  char       *name;                  /* Name of global variable */
+  PyObject *(*get_attr)(void);       /* Return the current value */
+  int       (*set_attr)(PyObject *); /* Set the value */
+  struct swig_globalvar *next;
+} swig_globalvar;
+
+typedef struct swig_varlinkobject {
+  PyObject_HEAD
+  swig_globalvar *vars;
+} swig_varlinkobject;
+
+static PyObject *
+swig_varlink_repr(swig_varlinkobject *v) {
+  v = v;
+  return PyString_FromString(&quot;&lt;Global variables&gt;&quot;);
+}
+
+static int
+swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
+  swig_globalvar  *var;
+  flags = flags;
+  fprintf(fp,&quot;Global variables { &quot;);
+  for (var = v-&gt;vars; var; var=var-&gt;next) {
+    fprintf(fp,&quot;%s&quot;, var-&gt;name);
+    if (var-&gt;next) fprintf(fp,&quot;, &quot;);
+  }
+  fprintf(fp,&quot; }\n&quot;);
+  return 0;
+}
+
+static PyObject *
+swig_varlink_getattr(swig_varlinkobject *v, char *n) {
+  swig_globalvar *var = v-&gt;vars;
+  while (var) {
+    if (strcmp(var-&gt;name,n) == 0) {
+      return (*var-&gt;get_attr)();
+    }
+    var = var-&gt;next;
+  }
+  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+  return NULL;
+}
+
+static int
+swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
+  swig_globalvar *var = v-&gt;vars;
+  while (var) {
+    if (strcmp(var-&gt;name,n) == 0) {
+      return (*var-&gt;set_attr)(p);
+    }
+    var = var-&gt;next;
+  }
+  PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+  return 1;
+}
+
+statichere PyTypeObject varlinktype = {
+  PyObject_HEAD_INIT(0)              
+  0,
+  (char *)&quot;swigvarlink&quot;,              /* Type name    */
+  sizeof(swig_varlinkobject),         /* Basic size   */
+  0,                                  /* Itemsize     */
+  0,                                  /* Deallocator  */ 
+  (printfunc) swig_varlink_print,     /* Print        */
+  (getattrfunc) swig_varlink_getattr, /* get attr     */
+  (setattrfunc) swig_varlink_setattr, /* Set attr     */
+  0,                                  /* tp_compare   */
+  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
+  0,                                  /* tp_as_number */
+  0,                                  /* tp_as_mapping*/
+  0,                                  /* tp_hash      */
+};
+
+/* Create a variable linking object for use later */
+SWIGRUNTIME(PyObject *)
+SWIG_Python_newvarlink(void) {
+  swig_varlinkobject *result = 0;
+  result = PyMem_NEW(swig_varlinkobject,1);
+  varlinktype.ob_type = &amp;PyType_Type;    /* Patch varlinktype into a PyType */
+  result-&gt;ob_type = &varlinktype;
+  result-&gt;vars = 0;
+  result-&gt;ob_refcnt = 0;
+  Py_XINCREF((PyObject *) result);
+  return ((PyObject*) result);
+}
+
+SWIGRUNTIME(void)
+SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+  swig_varlinkobject *v;
+  swig_globalvar *gv;
+  v= (swig_varlinkobject *) p;
+  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+  gv-&gt;name = (char *) malloc(strlen(name)+1);
+  strcpy(gv-&gt;name,name);
+  gv-&gt;get_attr = get_attr;
+  gv-&gt;set_attr = set_attr;
+  gv-&gt;next = v-&gt;vars;
+  v-&gt;vars = gv;
+}
+
+/* Convert a pointer value */
+SWIGRUNTIME(int)
+SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  char  *c = 0;
+  static PyObject *SWIG_this = 0;
+  int    newref = 0;
+  PyObject  *pyobj = 0;
+
+  if (!obj) return 0;
+  if (obj == Py_None) {
+    *ptr = 0;
+    return 0;
+  }
+#ifdef SWIG_COBJECT_TYPES
+  if (!(PyCObject_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString(&quot;this&quot;);
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PyCObject_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  }  
+  *ptr = PyCObject_AsVoidPtr(obj);
+  c = (char *) PyCObject_GetDesc(obj);
+  if (newref) Py_DECREF(obj);
+  goto cobject;
+#else
+  if (!(PyString_Check(obj))) {
+    if (!SWIG_this)
+      SWIG_this = PyString_FromString(&quot;this&quot;);
+    pyobj = obj;
+    obj = PyObject_GetAttr(obj,SWIG_this);
+    newref = 1;
+    if (!obj) goto type_error;
+    if (!PyString_Check(obj)) {
+      Py_DECREF(obj);
+      goto type_error;
+    }
+  } 
+  c = PyString_AsString(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') {
+    *ptr = (void *) 0;
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      if (newref) { Py_DECREF(obj); }
+      return 0;
+    } else {
+      if (newref) { Py_DECREF(obj); }
+      goto type_error;
+    }
+  }
+  c++;
+  c = SWIG_UnpackData(c,ptr,sizeof(void *));
+  if (newref) { Py_DECREF(obj); }
+#endif
+
+#ifdef SWIG_COBJECT_TYPES
+cobject:
+#endif
+
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
+  }
+
+  if ((pyobj) &amp;&amp; (flags &amp; SWIG_POINTER_DISOWN)) {
+    PyObject *zero = PyInt_FromLong(0);
+    PyObject_SetAttrString(pyobj,(char*)&quot;thisown&quot;,zero);
+    Py_DECREF(zero);
+  }
+  return 0;
+
+type_error:
+  if (flags &amp; SWIG_POINTER_EXCEPTION) {
+    if (ty &amp;&amp; c) {
+      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
+      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
+      PyErr_SetString(PyExc_TypeError, temp);
+      free((char *) temp);
+    } else {
+      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
+    }
+  }
+  return -1;
+}
+
+/* Convert a pointer value, signal an exception on a type mismatch */
+SWIGRUNTIME(void *)
+SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
+  void *result;
+  SWIG_Python_ConvertPtr(obj, &amp;result, ty, flags | SWIG_POINTER_EXCEPTION);
+  return result;
+}
+
+/* Convert a packed value value */
+SWIGRUNTIME(int)
+SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
+  swig_type_info *tc;
+  char  *c = 0;
+
+  if ((!obj) || (!PyString_Check(obj))) goto type_error;
+  c = PyString_AsString(obj);
+  /* Pointer values must start with leading underscore */
+  if (*c != '_') goto type_error;
+  c++;
+  c = SWIG_UnpackData(c,ptr,sz);
+  if (ty) {
+    tc = SWIG_TypeCheck(c,ty);
+    if (!tc) goto type_error;
+  }
+  return 0;
+
+type_error:
+
+  if (flags) {
+    if (ty &amp;&amp; c) {
+      char *temp = (char *) malloc(64+strlen(ty-&gt;name)+strlen(c));
+      sprintf(temp,&quot;Type error. Got %s, expected %s&quot;, c, ty-&gt;name);
+      PyErr_SetString(PyExc_TypeError, temp);
+      free((char *) temp);
+    } else {
+      PyErr_SetString(PyExc_TypeError,&quot;Expected a pointer&quot;);
+    }
+  }
+  return -1;
+}
+
+/* Create a new pointer object */
+SWIGRUNTIME(PyObject *)
+SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
+  PyObject *robj;
+  if (!ptr) {
+    Py_INCREF(Py_None);
+    return Py_None;
+  }
+#ifdef SWIG_COBJECT_TYPES
+  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type-&gt;name, NULL);
+#else
+  {
+    char result[1024];
+    char *r = result;
+    *(r++) = '_';
+    r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
+    strcpy(r,type-&gt;name);
+    robj = PyString_FromString(result);
+  }
+#endif
+  if (!robj || (robj == Py_None)) return robj;
+  if (type-&gt;clientdata) {
+    PyObject *inst;
+    PyObject *args = Py_BuildValue((char*)&quot;(O)&quot;, robj);
+    Py_DECREF(robj);
+    inst = PyObject_CallObject((PyObject *) type-&gt;clientdata, args);
+    Py_DECREF(args);
+    if (inst) {
+      if (own) {
+        PyObject *n = PyInt_FromLong(1);
+        PyObject_SetAttrString(inst,(char*)&quot;thisown&quot;,n);
+        Py_DECREF(n);
+      }
+      robj = inst;
+    }
+  }
+  return robj;
+}
+
+SWIGRUNTIME(PyObject *)
+SWIG_Python_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
+  char result[1024];
+  char *r = result;
+  if ((2*sz + 1 + strlen(type-&gt;name)) &gt; 1000) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  strcpy(r,type-&gt;name);
+  return PyString_FromString(result);
+}
+
+/* Install Constants */
+SWIGRUNTIME(void)
+SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
+  int i;
+  PyObject *obj;
+  for (i = 0; constants[i].type; i++) {
+    switch(constants[i].type) {
+    case SWIG_PY_INT:
+      obj = PyInt_FromLong(constants[i].lvalue);
+      break;
+    case SWIG_PY_FLOAT:
+      obj = PyFloat_FromDouble(constants[i].dvalue);
+      break;
+    case SWIG_PY_STRING:
+      obj = PyString_FromString((char *) constants[i].pvalue);
+      break;
+    case SWIG_PY_POINTER:
+      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+      break;
+    case SWIG_PY_BINARY:
+      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+      break;
+    default:
+      obj = 0;
+      break;
+    }
+    if (obj) {
+      PyDict_SetItemString(d,constants[i].name,obj);
+      Py_DECREF(obj);
+    }
+  }
+}
+
+#endif
+
+/* Contract support */
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define  SWIGTYPE_p_GobPlayer swig_types[0] 
+#define  SWIGTYPE_p_p_Upgrade swig_types[1] 
+#define  SWIGTYPE_p_SpaceLocation swig_types[2] 
+#define  SWIGTYPE_p_p_GobStation swig_types[3] 
+#define  SWIGTYPE_p_GobStation swig_types[4] 
+#define  SWIGTYPE_p_Upgrade swig_types[5] 
+#define  SWIGTYPE_p_RGB swig_types[6] 
+#define  SWIGTYPE_p_Log swig_types[7] 
+#define  SWIGTYPE_p_StarMap swig_types[8] 
+#define  SWIGTYPE_p_float swig_types[9] 
+#define  SWIGTYPE_p_std__vectorTEnemySaveData_t swig_types[10] 
+#define  SWIGTYPE_p_GobAsteroid swig_types[11] 
+#define  SWIGTYPE_p_TeamCode swig_types[12] 
+#define  SWIGTYPE_p_GobEnemy swig_types[13] 
+#define  SWIGTYPE_p_p_GobEnemy swig_types[14] 
+#define  SWIGTYPE_p_p_Planet swig_types[15] 
+#define  SWIGTYPE_p_RainbowRift swig_types[16] 
+#define  SWIGTYPE_p_GobGame swig_types[17] 
+#define  SWIGTYPE_p_EnemySaveData swig_types[18] 
+#define  SWIGTYPE_p_std__string swig_types[19] 
+#define  SWIGTYPE_p_Vector2 swig_types[20] 
+#define  SWIGTYPE_p_SaveGobGameInfo swig_types[21] 
+#define  SWIGTYPE_p_DialogApi swig_types[22] 
+#define  SWIGTYPE_p_pair swig_types[23] 
+#define  SWIGTYPE_p_SpaceSprite swig_types[24] 
+#define  SWIGTYPE_p_Control swig_types[25] 
+#define  SWIGTYPE_p_SpaceObject swig_types[26] 
+#define  SWIGTYPE_p_Frame swig_types[27] 
+#define  SWIGTYPE_p_std__vectorTstd__string_t swig_types[28] 
+#define  SWIGTYPE_p_ShipPanel swig_types[29] 
+#define  SWIGTYPE_p_SAMPLE swig_types[30] 
+#define  SWIGTYPE_p_ShipType swig_types[31] 
+#define  SWIGTYPE_p_Ship swig_types[32] 
+static swig_type_info *swig_types[34];
+
+/* -------- TYPES TABLE (END) -------- */
+
+
+/*-----------------------------------------------
+              @(target):= _tml.so
+  ------------------------------------------------*/
+#define SWIG_init    init_tml
+
+#define SWIG_name    &quot;_tml&quot;
+
+#include &quot;games/ggob.h&quot;
+#include &quot;other/gamedialog.h&quot;
+
+
+#define  SWIG_MemoryError    1
+#define  SWIG_IOError        2
+#define  SWIG_RuntimeError   3
+#define  SWIG_IndexError     4
+#define  SWIG_TypeError      5
+#define  SWIG_DivisionByZero 6
+#define  SWIG_OverflowError  7
+#define  SWIG_SyntaxError    8
+#define  SWIG_ValueError     9
+#define  SWIG_SystemError   10
+#define  SWIG_UnknownError  99
+
+
+static void SWIG_exception_(int code, const char *msg) {
+  switch(code) {
+  case SWIG_MemoryError:
+    PyErr_SetString(PyExc_MemoryError,msg);
+    break;
+  case SWIG_IOError:
+    PyErr_SetString(PyExc_IOError,msg);
+    break;
+  case SWIG_RuntimeError:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  case SWIG_IndexError:
+    PyErr_SetString(PyExc_IndexError,msg);
+    break;
+  case SWIG_TypeError:
+    PyErr_SetString(PyExc_TypeError,msg);
+    break;
+  case SWIG_DivisionByZero:
+    PyErr_SetString(PyExc_ZeroDivisionError,msg);
+    break;
+  case SWIG_OverflowError:
+    PyErr_SetString(PyExc_OverflowError,msg);
+    break;
+  case SWIG_SyntaxError:
+    PyErr_SetString(PyExc_SyntaxError,msg);
+    break;
+  case SWIG_ValueError:
+    PyErr_SetString(PyExc_ValueError,msg);
+    break;
+  case SWIG_SystemError:
+    PyErr_SetString(PyExc_SystemError,msg);
+    break;
+  default:
+    PyErr_SetString(PyExc_RuntimeError,msg);
+    break;
+  }
+}
+
+#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
+
+
+#include &lt;string&gt;
+
+
+#include &lt;string&gt;
+
+PyObject* SwigInt_FromBool(bool b) {
+    return PyInt_FromLong(b ? 1L : 0L);
+}
+double SwigNumber_Check(PyObject* o) {
+    return PyFloat_Check(o) || PyInt_Check(o) || PyLong_Check(o);
+}
+double SwigNumber_AsDouble(PyObject* o) {
+    return PyFloat_Check(o) ? PyFloat_AsDouble(o) 
+        : (PyInt_Check(o) ?   double(PyInt_AsLong(o))
+                            : double(PyLong_AsLong(o)));
+}
+PyObject* SwigString_FromString(const std::string&amp; s) {
+    return PyString_FromStringAndSize(s.data(),s.size());
+}
+std::string SwigString_AsString(PyObject* o) {
+    return std::string(PyString_AsString(o));
+}
+
+
+#include &lt;utility&gt;
+
+
+#include &lt;vector&gt;
+#include &lt;algorithm&gt;
+#include &lt;stdexcept&gt;
+
+bool std_vectorlEnemySaveData_g___nonzero_____(std::vector&lt;EnemySaveData &gt; *self){
+                return !(self-&gt;empty());
+            }
+EnemySaveData std_vectorlEnemySaveData_g_pop___(std::vector&lt;EnemySaveData &gt; *self){
+                if (self-&gt;size() == 0)
+                    throw std::out_of_range(&quot;pop from empty vector&quot;);
+                EnemySaveData x = self-&gt;back();
+                self-&gt;pop_back();
+                return x;
+            }
+EnemySaveData &amp;std_vectorlEnemySaveData_g___getitem_____(std::vector&lt;EnemySaveData &gt; *self,int i){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i += size;
+                if (i&gt;=0 &amp;&amp; i&lt;size)
+                    return (*self)[i];
+                else
+                    throw std::out_of_range(&quot;vector index out of range&quot;);
+            }
+std::vector&lt;EnemySaveData &gt; std_vectorlEnemySaveData_g___getslice_____(std::vector&lt;EnemySaveData &gt; *self,int i,int j){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i = size+i;
+                if (j&lt;0) j = size+j;
+                if (i&lt;0) i = 0;
+                if (j&gt;size) j = size;
+                std::vector&lt;EnemySaveData &gt; tmp;
+                tmp.reserve(j-i);
+                tmp.insert(tmp.begin(),self-&gt;begin()+i,self-&gt;begin()+j);
+                return tmp;
+            }
+void std_vectorlEnemySaveData_g___setitem_____(std::vector&lt;EnemySaveData &gt; *self,int i,EnemySaveData const &amp;x){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i+= size;
+                if (i&gt;=0 &amp;&amp; i&lt;size)
+                    (*self)[i] = x;
+                else
+                    throw std::out_of_range(&quot;vector index out of range&quot;);
+            }
+void std_vectorlEnemySaveData_g___setslice_____(std::vector&lt;EnemySaveData &gt; *self,int i,int j,std::vector&lt;EnemySaveData &gt; const &amp;v){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i = size+i;
+                if (j&lt;0) j = size+j;
+                if (i&lt;0) i = 0;
+                if (j&gt;size) j = size;
+                if (int(v.size()) == j-i) {
+                    std::copy(v.begin(),v.end(),self-&gt;begin()+i);
+                } else {
+                    self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
+                    if (i+1 &lt;= int(self-&gt;size())) {
+                        self-&gt;insert(self-&gt;begin()+i,v.begin(),v.end());
+                    } else {
+                        self-&gt;insert(self-&gt;end(),v.begin(),v.end());
+                    }
+                }
+            }
+void std_vectorlEnemySaveData_g___delitem_____(std::vector&lt;EnemySaveData &gt; *self,int i){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i+= size;
+                if (i&gt;=0 &amp;&amp; i&lt;size)
+                    self-&gt;erase(self-&gt;begin()+i);
+                else
+                    throw std::out_of_range(&quot;vector index out of range&quot;);
+            }
+void std_vectorlEnemySaveData_g___delslice_____(std::vector&lt;EnemySaveData &gt; *self,int i,int j){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i = size+i;
+                if (j&lt;0) j = size+j;
+                if (i&lt;0) i = 0;
+                if (j&gt;size) j = size;
+                self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
+            }
+std::string std_vectorlstd_string_g_pop___(std::vector&lt;std::string &gt; *self){
+                if (self-&gt;size() == 0)
+                    throw std::out_of_range(&quot;pop from empty vector&quot;);
+                std::string x = self-&gt;back();
+                self-&gt;pop_back();
+                return x;
+            }
+std::string std_vectorlstd_string_g___getitem_____(std::vector&lt;std::string &gt; *self,int i){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i += size;
+                if (i&gt;=0 &amp;&amp; i&lt;size)
+                    return (*self)[i];
+                else
+                    throw std::out_of_range(&quot;vector index out of range&quot;);
+            }
+std::vector&lt;std::string &gt; std_vectorlstd_string_g___getslice_____(std::vector&lt;std::string &gt; *self,int i,int j){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i = size+i;
+                if (j&lt;0) j = size+j;
+                if (i&lt;0) i = 0;
+                if (j&gt;size) j = size;
+                std::vector&lt;std::string &gt; tmp(j-i);
+                std::copy(self-&gt;begin()+i,self-&gt;begin()+j,tmp.begin());
+                return tmp;
+            }
+void std_vectorlstd_string_g___setitem_____(std::vector&lt;std::string &gt; *self,int i,std::string x){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i+= size;
+                if (i&gt;=0 &amp;&amp; i&lt;size)
+                    (*self)[i] = x;
+                else
+                    throw std::out_of_range(&quot;vector index out of range&quot;);
+            }
+void std_vectorlstd_string_g___setslice_____(std::vector&lt;std::string &gt; *self,int i,int j,std::vector&lt;std::string &gt; const &amp;v){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i = size+i;
+                if (j&lt;0) j = size+j;
+                if (i&lt;0) i = 0;
+                if (j&gt;size) j = size;
+                if (int(v.size()) == j-i) {
+                    std::copy(v.begin(),v.end(),self-&gt;begin()+i);
+                } else {
+                    self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
+                    if (i+1 &lt;= int(self-&gt;size()))
+                        self-&gt;insert(self-&gt;begin()+i,v.begin(),v.end());
+                    else
+                        self-&gt;insert(self-&gt;end(),v.begin(),v.end());
+                }
+            }
+void std_vectorlstd_string_g___delitem_____(std::vector&lt;std::string &gt; *self,int i){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i+= size;
+                if (i&gt;=0 &amp;&amp; i&lt;size)
+                    self-&gt;erase(self-&gt;begin()+i);
+                else
+                    throw std::out_of_range(&quot;vector index out of range&quot;);
+            }
+void std_vectorlstd_string_g___delslice_____(std::vector&lt;std::string &gt; *self,int i,int j){
+                int size = int(self-&gt;size());
+                if (i&lt;0) i = size+i;
+                if (j&lt;0) j = size+j;
+                if (i&lt;0) i = 0;
+                if (j&gt;size) j = size;
+                self-&gt;erase(self-&gt;begin()+i,self-&gt;begin()+j);
+            }
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+static PyObject *_wrap_pair_id_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    char *arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:pair_id_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (arg1-&gt;id) delete [] arg1-&gt;id;
+        if (arg2) {
+            arg1-&gt;id = (char *) (new char[strlen(arg2)+1]);
+            strcpy((char *) arg1-&gt;id,arg2);
+        } else {
+            arg1-&gt;id = 0;
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_id_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    char *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:pair_id_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (char *) ((arg1)-&gt;id);
+    
+    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)&quot;&quot;);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_value_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:pair_value_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;value = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_pair_value_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:pair_value_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;value);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_pair&quot;)) goto fail;
+    result = (pair *)new pair();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    pair *arg1 = (pair *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_pair&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * pair_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_pair, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_EnemySaveData_pos_x_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:EnemySaveData_pos_x_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;pos_x = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_EnemySaveData_pos_x_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:EnemySaveData_pos_x_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;pos_x);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_EnemySaveData_pos_y_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:EnemySaveData_pos_y_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;pos_y = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_EnemySaveData_pos_y_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:EnemySaveData_pos_y_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;pos_y);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_EnemySaveData(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    EnemySaveData *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_EnemySaveData&quot;)) goto fail;
+    result = (EnemySaveData *)new EnemySaveData();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_EnemySaveData, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_EnemySaveData(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    EnemySaveData *arg1 = (EnemySaveData *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_EnemySaveData&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * EnemySaveData_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_EnemySaveData, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_SaveGobGameInfo_getInstance(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:SaveGobGameInfo_getInstance&quot;)) goto fail;
+    result = (SaveGobGameInfo *)SaveGobGameInfo::getInstance();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SaveGobGameInfo, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_updateSave(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_updateSave&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;updateSave();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_updateGame(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_updateGame&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;updateGame();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_kills_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_kills_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;kills = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_kills_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_kills_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;kills);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_pos_x_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_pos_x_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;pos_x = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_pos_x_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_pos_x_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;pos_x);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_pos_y_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:SaveGobGameInfo_pos_y_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;pos_y = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_pos_y_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_pos_y_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;pos_y);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_system_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::string *arg2 = (std::string *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_system_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;system = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_system_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::string *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_system_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::string *)&amp; ((arg1)-&gt;system);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_getSystem(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::string result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_getSystem&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (arg1)-&gt;getSystem();
+    
+    {
+        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_setSystem(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::string *arg2 = 0 ;
+    std::string temp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_setSystem&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &amp;temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    (arg1)-&gt;setSystem((std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_tst_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::vector&lt;EnemySaveData &gt; *arg2 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_tst_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;tst = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_tst_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::vector&lt;EnemySaveData &gt; *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_tst_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::vector&lt;EnemySaveData &gt; *)&amp; ((arg1)-&gt;tst);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_getTst(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::vector&lt;EnemySaveData &gt; result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:SaveGobGameInfo_getTst&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (arg1)-&gt;getTst();
+    
+    {
+        std::vector&lt;EnemySaveData &gt; * resultptr;
+        resultptr = new std::vector&lt;EnemySaveData &gt;((std::vector&lt;EnemySaveData &gt; &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_SaveGobGameInfo_setTst(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    std::vector&lt;EnemySaveData &gt; *arg2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SaveGobGameInfo_setTst&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg2 == NULL) {
+        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
+    }
+    (arg1)-&gt;setTst(*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_SaveGobGameInfo(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_SaveGobGameInfo&quot;)) goto fail;
+    result = (SaveGobGameInfo *)new SaveGobGameInfo();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SaveGobGameInfo, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_SaveGobGameInfo(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SaveGobGameInfo *arg1 = (SaveGobGameInfo *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_SaveGobGameInfo&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SaveGobGameInfo,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * SaveGobGameInfo_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_SaveGobGameInfo, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_new_GobPlayer(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobPlayer&quot;)) goto fail;
+    result = (GobPlayer *)new GobPlayer();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobPlayer(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobPlayer&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_ship_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_ship_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;ship = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_ship_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Ship *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_ship_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Ship *) ((arg1)-&gt;ship);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_pair_list_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    pair *arg2 = (pair *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_pair_list_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_pair,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;pair_list = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_pair_list_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    pair *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_pair_list_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (pair *) ((arg1)-&gt;pair_list);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_num_pairs_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_num_pairs_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;num_pairs = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_num_pairs_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_num_pairs_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;num_pairs);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_total_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_total_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;total = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_total_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_total_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;total);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_kills_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_kills_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;kills = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_kills_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_kills_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;kills);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_value_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;value_starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_value_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;value_starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobPlayer_value_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;value_buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_value_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_value_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;value_buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_team_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_team_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)-&gt;team = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_team_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_team_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)-&gt;team);
+    
+    {
+        TeamCode * resultptr;
+        resultptr = new TeamCode((TeamCode &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_init&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    (arg1)-&gt;init(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_died&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;died(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_new_ship(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    ShipType *arg2 = (ShipType *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_new_ship&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_ShipType,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;new_ship(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_charge(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    int arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Osii:GobPlayer_charge&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;charge(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer__add_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Osi:GobPlayer__add_pair&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;_add_pair((char const *)arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer__get_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    pair *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:GobPlayer__get_pair&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (pair *)(arg1)-&gt;_get_pair((char const *)arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_pair, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_write_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Osi:GobPlayer_write_pair&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;write_pair((char const *)arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_read_pair(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    char *arg2 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:GobPlayer_read_pair&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;read_pair((char const *)arg2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_upgrade_list_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Upgrade **arg2 = (Upgrade **) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobPlayer_upgrade_list_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;upgrade_list = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobPlayer_upgrade_list_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobPlayer *arg1 = (GobPlayer *) 0 ;
+    Upgrade **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobPlayer_upgrade_list_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Upgrade **) ((arg1)-&gt;upgrade_list);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Upgrade, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobPlayer_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobPlayer, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobEnemy_ship_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobEnemy_ship_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;ship = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_ship_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_ship_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Ship *) ((arg1)-&gt;ship);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Ship, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobEnemy_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobEnemy_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobEnemy_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobEnemy_init&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;init(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobEnemy_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobEnemy_died&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;died(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobEnemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobEnemy&quot;)) goto fail;
+    result = (GobEnemy *)new GobEnemy();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobEnemy, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobEnemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobEnemy *arg1 = (GobEnemy *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobEnemy&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobEnemy_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobEnemy, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobAsteroid_handle_damage(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    double arg3 ;
+    double arg4 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOdd:GobAsteroid_handle_damage&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;handle_damage(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobAsteroid_death(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobAsteroid_death&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;death();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobAsteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobAsteroid&quot;)) goto fail;
+    result = (GobAsteroid *)new GobAsteroid();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobAsteroid, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobAsteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobAsteroid *arg1 = (GobAsteroid *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobAsteroid&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobAsteroid,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobAsteroid_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobAsteroid, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobGame__galaxy_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    StarMap arg2 ;
+    StarMap *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__galaxy_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_StarMap,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)-&gt;_galaxy = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__galaxy_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    StarMap result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__galaxy_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)-&gt;_galaxy);
+    
+    {
+        StarMap * resultptr;
+        resultptr = new StarMap((StarMap &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_StarMap, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobplayer_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_gobplayer_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;gobplayer = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobplayer_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobPlayer *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobplayer_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobPlayer *)&amp; ((arg1)-&gt;gobplayer);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_switch_system(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string *arg2 = 0 ;
+    std::string temp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_switch_system&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &amp;temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    (arg1)-&gt;switch_system((std::string const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer__SWIG_0(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string *arg2 = 0 ;
+    Vector2 arg3 ;
+    std::string temp2 ;
+    Vector2 *argp3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_add_gobplayer&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &amp;temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;argp3, SWIGTYPE_p_Vector2,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg3 = *argp3; 
+    (arg1)-&gt;add_gobplayer((std::string const &amp;)*arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobGame(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GobGame&quot;)) goto fail;
+    result = (GobGame *)new GobGame();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_this(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:GobGame_get_this&quot;)) goto fail;
+    result = (GobGame *)GobGame::get_this();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobGame, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobGame(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobGame&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_panel_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    ShipPanel *arg2 = (ShipPanel *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__player_panel_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_ShipPanel,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_player_panel = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_panel_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    ShipPanel *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__player_panel_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (ShipPanel *) ((arg1)-&gt;_player_panel);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ShipPanel, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_control_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *arg2 = (Control *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame__player_control_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_player_control = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame__player_control_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame__player_control_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Control *) ((arg1)-&gt;_player_control);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Control, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_enemy_team_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    TeamCode arg2 ;
+    TeamCode *argp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_enemy_team_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;argp2, SWIGTYPE_p_TeamCode,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg2 = *argp2; 
+    if (arg1) (arg1)-&gt;enemy_team = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_enemy_team_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    TeamCode result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_enemy_team_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result =  ((arg1)-&gt;enemy_team);
+    
+    {
+        TeamCode * resultptr;
+        resultptr = new TeamCode((TeamCode &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_TeamCode, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_AddPanel(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_AddPanel&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;AddPanel();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_calculate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_calculate&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;calculate();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_setGameDone(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_setGameDone&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;setGameDone(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_ship_died(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_ship_died&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;ship_died(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_preinit(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_preinit&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;preinit();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_init(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Log *arg2 = (Log *) 0 ;
+    std::string *arg3 = 0 ;
+    std::string temp3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobGame_init&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Log,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2)) {
+            temp3 = std::string(PyString_AsString(obj2),
+            PyString_Size(obj2));
+            arg3 = &amp;temp3;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    (arg1)-&gt;init(arg2,(std::string const &amp;)*arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_play_sound(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SAMPLE *arg2 = (SAMPLE *) 0 ;
+    SpaceLocation *arg3 = (SpaceLocation *) 0 ;
+    int arg4 = (int) 256 ;
+    int arg5 = (int) 1000 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO|ii:GobGame_play_sound&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;arg4,&amp;arg5)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SAMPLE,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;play_sound(arg2,arg3,arg4,arg5);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer__SWIG_1(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Control *arg2 = (Control *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_add_gobplayer&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Control,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_gobplayer(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_gobplayer(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[4];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], (void **) &amp;ptr, SWIGTYPE_p_GobGame, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            {
+                void *ptr;
+                if (SWIG_ConvertPtr(argv[1], (void **) &amp;ptr, SWIGTYPE_p_Control, 0) == -1) {
+                    _v = 0;
+                    PyErr_Clear();
+                } else {
+                    _v = 1;
+                }
+            }
+            if (_v) {
+                return _wrap_GobGame_add_gobplayer__SWIG_1(self,args);
+            }
+        }
+    }
+    if (argc == 3) {
+        int _v;
+        {
+            void *ptr;
+            if (SWIG_ConvertPtr(argv[0], (void **) &amp;ptr, SWIGTYPE_p_GobGame, 0) == -1) {
+                _v = 0;
+                PyErr_Clear();
+            } else {
+                _v = 1;
+            }
+        }
+        if (_v) {
+            {
+                _v = PyString_Check(argv[1]) ? 1 : 0;
+            }
+            if (_v) {
+                {
+                    void *ptr;
+                    if (SWIG_ConvertPtr(argv[2], (void **) &amp;ptr, SWIGTYPE_p_Vector2, 0) == -1) {
+                        _v = 0;
+                        PyErr_Clear();
+                    } else {
+                        _v = 1;
+                    }
+                }
+                if (_v) {
+                    return _wrap_GobGame_add_gobplayer__SWIG_0(self,args);
+                }
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'GobGame_add_gobplayer'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_player(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    GobPlayer *result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_get_player&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobPlayer *)(arg1)-&gt;get_player(arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobPlayer, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemies_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_gobenemies_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;gobenemies = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemies_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobenemies_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;gobenemies);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_max_enemies_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_max_enemies_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;max_enemies = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_max_enemies_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_max_enemies_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;max_enemies);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemy_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobEnemy **arg2 = (GobEnemy **) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_gobenemy_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_GobEnemy,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;gobenemy = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_gobenemy_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobEnemy **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_gobenemy_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobEnemy **) ((arg1)-&gt;gobenemy);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobEnemy, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_get_enemy_index(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_get_enemy_index&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int)(arg1)-&gt;get_enemy_index(arg2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_prepare(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_prepare&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;prepare();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_fps(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_fps&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;fps();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_new_enemy(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_new_enemy&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_new_enemy();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_stars(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_stars&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_stars();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_asteroid(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_add_asteroid&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;add_asteroid();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_system(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string arg2 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobGame_add_system&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1))
+        arg2 = std::string(PyString_AsString(obj1),
+        PyString_Size(obj1));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    (arg1)-&gt;add_system(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_player(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    std::string arg2 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOii:GobGame_add_player&quot;,&amp;obj0,&amp;obj1,&amp;arg3,&amp;arg4)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1))
+        arg2 = std::string(PyString_AsString(obj1),
+        PyString_Size(obj1));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    (arg1)-&gt;add_player(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_next_add_new_enemy_time_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_next_add_new_enemy_time_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;next_add_new_enemy_time = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_next_add_new_enemy_time_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_next_add_new_enemy_time_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;next_add_new_enemy_time);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_defenderSprite_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceSprite *arg2 = (SpaceSprite *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_defenderSprite_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;defenderSprite = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_defenderSprite_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    SpaceSprite *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_defenderSprite_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (SpaceSprite *) ((arg1)-&gt;defenderSprite);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_SpaceSprite, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_num_planets_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:GobGame_num_planets_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;num_planets = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_num_planets_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_num_planets_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;num_planets);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_planet_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Planet **arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_planet_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_Planet,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        Planet * *b = (Planet * *) arg1-&gt;planet;
+        for (ii = 0; ii &lt; 16; ii++) b[ii] = *((Planet * *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_planet_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    Planet **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_planet_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Planet **)(Planet **) ((arg1)-&gt;planet);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_Planet, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_station_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobStation **arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobGame_station_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        GobStation * *b = (GobStation * *) arg1-&gt;station;
+        for (ii = 0; ii &lt; 16; ii++) b[ii] = *((GobStation * *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_station_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    GobStation **result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobGame_station_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (GobStation **)(GobStation **) ((arg1)-&gt;station);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_p_GobStation, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobGame_add_planet_and_station(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobGame *arg1 = (GobGame *) 0 ;
+    int arg2 ;
+    std::string arg3 ;
+    std::string arg4 ;
+    std::string arg5 ;
+    std::string arg6 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    PyObject * obj4 = 0 ;
+    PyObject * obj5 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OiOOOO:GobGame_add_planet_and_station&quot;,&amp;obj0,&amp;arg2,&amp;obj2,&amp;obj3,&amp;obj4,&amp;obj5)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobGame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2))
+        arg3 = std::string(PyString_AsString(obj2),
+        PyString_Size(obj2));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    {
+        if (PyString_Check(obj3))
+        arg4 = std::string(PyString_AsString(obj3),
+        PyString_Size(obj3));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    {
+        if (PyString_Check(obj4))
+        arg5 = std::string(PyString_AsString(obj4),
+        PyString_Size(obj4));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    {
+        if (PyString_Check(obj5))
+        arg6 = std::string(PyString_AsString(obj5),
+        PyString_Size(obj5));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    (arg1)-&gt;add_planet_and_station(arg2,arg3,arg4,arg5,arg6);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobGame_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobGame, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_GobStation__build_type_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *arg2 = (std::string *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation__build_type_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_build_type = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__build_type_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobStation__build_type_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::string *)&amp; ((arg1)-&gt;_build_type);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__background_pic_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *arg2 = (std::string *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation__background_pic_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_std__string,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;_background_pic = *arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation__background_pic_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    std::string *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:GobStation__background_pic_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (std::string *)&amp; ((arg1)-&gt;_background_pic);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__string, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_GobStation(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    SpaceSprite *arg1 = (SpaceSprite *) 0 ;
+    SpaceLocation *arg2 = (SpaceLocation *) 0 ;
+    std::string *arg3 = 0 ;
+    std::string *arg4 = 0 ;
+    GobStation *result;
+    std::string temp3 ;
+    std::string temp4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:new_GobStation&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_SpaceSprite,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceLocation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2)) {
+            temp3 = std::string(PyString_AsString(obj2),
+            PyString_Size(obj2));
+            arg3 = &amp;temp3;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    {
+        if (PyString_Check(obj3)) {
+            temp4 = std::string(PyString_AsString(obj3),
+            PyString_Size(obj3));
+            arg4 = &amp;temp4;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    result = (GobStation *)new GobStation(arg1,arg2,(std::string const &amp;)*arg3,(std::string const &amp;)*arg4);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_GobStation, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_buy_new_ship_menu(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_buy_new_ship_menu&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;buy_new_ship_menu(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_inflict_damage(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    SpaceObject *arg2 = (SpaceObject *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_inflict_damage&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_SpaceObject,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;inflict_damage(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_station_screen(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GobStation_station_screen&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;station_screen(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_GobStation_upgrade_menu(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    GobStation *arg2 = (GobStation *) 0 ;
+    GobPlayer *arg3 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GobStation_upgrade_menu&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;upgrade_menu(arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_GobStation(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    GobStation *arg1 = (GobStation *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GobStation&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * GobStation_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_GobStation, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_Upgrade_name_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    char *arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Os:Upgrade_name_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (arg1-&gt;name) delete [] arg1-&gt;name;
+        if (arg2) {
+            arg1-&gt;name = (char *) (new char[strlen(arg2)+1]);
+            strcpy((char *) arg1-&gt;name,arg2);
+        } else {
+            arg1-&gt;name = 0;
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_name_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    char *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_name_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (char *) ((arg1)-&gt;name);
+    
+    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)&quot;&quot;);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_starbucks_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_starbucks_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;starbucks = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_starbucks_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_starbucks_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;starbucks);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_buckazoids_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_buckazoids_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;buckazoids = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_buckazoids_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_buckazoids_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;buckazoids);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_status_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_status_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;status = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_status_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_status_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;status);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_num_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_num_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;num = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_num_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_num_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;num);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_index_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:Upgrade_index_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;index = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_index_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_index_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;index);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_update(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    GobStation *arg3 = (GobStation *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    bool result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_update&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (bool)(arg1)-&gt;update(arg2,arg3,arg4);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_execute(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    GobStation *arg3 = (GobStation *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_execute&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_GobStation,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;execute(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_charge(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    GobPlayer *arg2 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:Upgrade_charge&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;charge(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_clear(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Ship *arg2 = (Ship *) 0 ;
+    Ship *arg3 = (Ship *) 0 ;
+    GobPlayer *arg4 = (GobPlayer *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    PyObject * obj2 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:Upgrade_clear&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_Ship,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj3,(void **) &amp;arg4, SWIGTYPE_p_GobPlayer,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;clear(arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_Upgrade_duplicate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    Upgrade *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:Upgrade_duplicate&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (Upgrade *)(arg1)-&gt;duplicate();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Upgrade, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_Upgrade(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    Upgrade *arg1 = (Upgrade *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_Upgrade&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_Upgrade,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * Upgrade_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_Upgrade, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_RainbowRift_p_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    float *arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_p_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_float,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        float *b = (float *) arg1-&gt;p;
+        for (ii = 0; ii &lt; RainbowRift::n*6+2; ii++) b[ii] = *((float *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_p_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    float *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_p_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (float *)(float *) ((arg1)-&gt;p);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_float, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_c_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    RGB *arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_c_set&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_RGB,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        int ii;
+        RGB *b = (RGB *) arg1-&gt;c;
+        for (ii = 0; ii &lt; RainbowRift::n; ii++) b[ii] = *((RGB *) arg2 + ii);
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_c_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    RGB *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_c_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (RGB *)(RGB *) ((arg1)-&gt;c);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RGB, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:RainbowRift_next_time_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;next_time = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_next_time_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;next_time);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time2_set(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:RainbowRift_next_time2_set&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg1) (arg1)-&gt;next_time2 = arg2;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_next_time2_get(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    int result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_next_time2_get&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (int) ((arg1)-&gt;next_time2);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_RainbowRift(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_RainbowRift&quot;)) goto fail;
+    result = (RainbowRift *)new RainbowRift();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_RainbowRift, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_animate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    Frame *arg2 = (Frame *) 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:RainbowRift_animate&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_Frame,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;animate(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_calculate(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_calculate&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;calculate();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_RainbowRift_squiggle(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:RainbowRift_squiggle&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;squiggle();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_RainbowRift(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    RainbowRift *arg1 = (RainbowRift *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_RainbowRift&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_RainbowRift,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * RainbowRift_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_RainbowRift, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_DialogApi_startDialog(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_startDialog&quot;)) goto fail;
+    DialogApi::startDialog();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_endDialog(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_endDialog&quot;)) goto fail;
+    DialogApi::endDialog();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_askPlayer(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; arg1 ;
+    int result;
+    std::vector&lt;std::string &gt; *argp1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_askPlayer&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;argp1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION) == -1)) SWIG_fail;
+    arg1 = *argp1; 
+    result = (int)DialogApi::askPlayer(arg1);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_showText(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::string arg1 ;
+    int arg2 ;
+    int arg3 ;
+    int arg4 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oiii:DialogApi_showText&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;arg4)) goto fail;
+    {
+        if (PyString_Check(obj0))
+        arg1 = std::string(PyString_AsString(obj0),
+        PyString_Size(obj0));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    DialogApi::showText(arg1,arg2,arg3,arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_DialogApi_showAlienPicture(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::string arg1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_showAlienPicture&quot;,&amp;obj0)) goto fail;
+    {
+        if (PyString_Check(obj0))
+        arg1 = std::string(PyString_AsString(obj0),
+        PyString_Size(obj0));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    DialogApi::showAlienPicture(arg1);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_DialogApi(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    DialogApi *result;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;:new_DialogApi&quot;)) goto fail;
+    result = (DialogApi *)new DialogApi();
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_DialogApi, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_DialogApi(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    DialogApi *arg1 = (DialogApi *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_DialogApi&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_DialogApi,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * DialogApi_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_DialogApi, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_new_vectorEnemySaveData__SWIG_0(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    unsigned int arg1 = (unsigned int) 0 ;
+    std::vector&lt;EnemySaveData &gt; *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;|O:new_vectorEnemySaveData&quot;,&amp;obj0)) goto fail;
+    if (obj0) {
+        arg1 = (unsigned int) PyInt_AsLong(obj0);
+        if (PyErr_Occurred()) SWIG_fail;
+    }
+    result = (std::vector&lt;EnemySaveData &gt; *)new std::vector&lt;EnemySaveData &gt;(arg1);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorEnemySaveData__SWIG_1(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    unsigned int arg1 ;
+    EnemySaveData *arg2 = 0 ;
+    std::vector&lt;EnemySaveData &gt; *result;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:new_vectorEnemySaveData&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    arg1 = (unsigned int) PyInt_AsLong(obj0);
+    if (PyErr_Occurred()) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg2 == NULL) {
+        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
+    }
+    result = (std::vector&lt;EnemySaveData &gt; *)new std::vector&lt;EnemySaveData &gt;(arg1,(EnemySaveData const &amp;)*arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorEnemySaveData__SWIG_2(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = 0 ;
+    std::vector&lt;EnemySaveData &gt; *result;
+    std::vector&lt;EnemySaveData &gt; temp1 ;
+    std::vector&lt;EnemySaveData &gt; *v1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorEnemySaveData&quot;,&amp;obj0)) goto fail;
+    {
+        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
+            unsigned int size = (PyTuple_Check(obj0) ?
+            PyTuple_Size(obj0) :
+            PyList_Size(obj0));
+            temp1.reserve(size);
+            arg1 = &amp;temp1;
+            for (unsigned int i=0; i&lt;size; i++) {
+                EnemySaveData* x;
+                PyObject* o = PySequence_GetItem(obj0,i);
+                if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
+                SWIGTYPE_p_EnemySaveData,0)) != -1) {
+                    temp1.push_back(*x);
+                    Py_DECREF(o);
+                } else {
+                    Py_DECREF(o);
+                    PyErr_SetString(PyExc_TypeError,
+                    &quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
+                    SWIG_fail;
+                }
+            }
+        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
+        SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1) {
+            arg1 = v1;
+        } else {
+            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
+            SWIG_fail;
+        }
+    }
+    result = (std::vector&lt;EnemySaveData &gt; *)new std::vector&lt;EnemySaveData &gt;((std::vector&lt;EnemySaveData &gt; const &amp;)*arg1);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTEnemySaveData_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorEnemySaveData(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[3];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if ((argc &gt;= 0) &amp;&amp; (argc &lt;= 1)) {
+        int _v;
+        if (argc &lt;= 0) {
+            return _wrap_new_vectorEnemySaveData__SWIG_0(self,args);
+        }
+        {
+            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
+        }
+        if (_v) {
+            return _wrap_new_vectorEnemySaveData__SWIG_0(self,args);
+        }
+    }
+    if (argc == 1) {
+        int _v;
+        {
+            /* native sequence? */
+            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
+                unsigned int size = (PyTuple_Check(argv[0]) ?
+                PyTuple_Size(argv[0]) :
+                PyList_Size(argv[0]));
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    _v = 1;
+                } else {
+                    /* check the first element only */
+                    EnemySaveData* x;
+                    PyObject* o = PySequence_GetItem(argv[0],0);
+                    if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
+                    SWIGTYPE_p_EnemySaveData,0)) != -1)
+                    _v = 1;
+                    else
+                    _v = 0;
+                    Py_DECREF(o);
+                }
+            } else {
+                /* wrapped vector? */
+                std::vector&lt;EnemySaveData &gt;* v;
+                if (SWIG_ConvertPtr(argv[0],(void **) &amp;v, 
+                SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1)
+                _v = 1;
+                else
+                _v = 0;
+            }
+        }
+        if (_v) {
+            return _wrap_new_vectorEnemySaveData__SWIG_2(self,args);
+        }
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
+        }
+        if (_v) {
+            {
+                void *ptr;
+                if (SWIG_ConvertPtr(argv[1], (void **) &amp;ptr, SWIGTYPE_p_EnemySaveData, 0) == -1) {
+                    _v = 0;
+                    PyErr_Clear();
+                } else {
+                    _v = 1;
+                }
+            }
+            if (_v) {
+                return _wrap_new_vectorEnemySaveData__SWIG_1(self,args);
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'new_vectorEnemySaveData'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___len__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    unsigned int result;
+    std::vector&lt;EnemySaveData &gt; temp1 ;
+    std::vector&lt;EnemySaveData &gt; *v1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData___len__&quot;,&amp;obj0)) goto fail;
+    {
+        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
+            unsigned int size = (PyTuple_Check(obj0) ?
+            PyTuple_Size(obj0) :
+            PyList_Size(obj0));
+            temp1.reserve(size);
+            arg1 = &amp;temp1;
+            for (unsigned int i=0; i&lt;size; i++) {
+                EnemySaveData* x;
+                PyObject* o = PySequence_GetItem(obj0,i);
+                if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
+                SWIGTYPE_p_EnemySaveData,0)) != -1) {
+                    temp1.push_back(*x);
+                    Py_DECREF(o);
+                } else {
+                    Py_DECREF(o);
+                    PyErr_SetString(PyExc_TypeError,
+                    &quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
+                    SWIG_fail;
+                }
+            }
+        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
+        SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1) {
+            arg1 = v1;
+        } else {
+            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
+            SWIG_fail;
+        }
+    }
+    result = (unsigned int)((std::vector&lt;EnemySaveData &gt; const *)arg1)-&gt;size();
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData_clear(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData_clear&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;clear();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData_append(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    EnemySaveData *arg2 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorEnemySaveData_append&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj1,(void **) &amp;arg2, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg2 == NULL) {
+        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
+    }
+    (arg1)-&gt;push_back((EnemySaveData const &amp;)*arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___nonzero__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    bool result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData___nonzero__&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = (bool)std_vectorlEnemySaveData_g___nonzero_____(arg1);
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData_pop(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    EnemySaveData result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorEnemySaveData_pop&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        try {
+            result = std_vectorlEnemySaveData_g_pop___(arg1);
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    {
+        EnemySaveData * resultptr;
+        resultptr = new EnemySaveData((EnemySaveData &amp;) result);
+        resultobj = SWIG_NewPointerObj((void *) resultptr, SWIGTYPE_p_EnemySaveData, 1);
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___getitem__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    int arg2 ;
+    EnemySaveData *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorEnemySaveData___getitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        try {
+            {
+                EnemySaveData &amp;_result_ref = std_vectorlEnemySaveData_g___getitem_____(arg1,arg2);
+                result = (EnemySaveData *) &amp;_result_ref;
+            }
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_EnemySaveData, 0);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___getslice__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    int arg2 ;
+    int arg3 ;
+    std::vector&lt;EnemySaveData &gt; result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorEnemySaveData___getslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = std_vectorlEnemySaveData_g___getslice_____(arg1,arg2,arg3);
+    
+    {
+        resultobj = PyTuple_New((&amp;result)-&gt;size());
+        for (unsigned int i=0; i&lt;(&amp;result)-&gt;size(); i++) {
+            EnemySaveData* ptr = new EnemySaveData(((std::vector&lt;EnemySaveData &gt; &amp;)result)[i]);
+            PyTuple_SetItem(resultobj,i,
+            SWIG_NewPointerObj((void *) ptr, 
+            SWIGTYPE_p_EnemySaveData, 1));
+        }
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___setitem__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    int arg2 ;
+    EnemySaveData *arg3 = 0 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OiO:vectorEnemySaveData___setitem__&quot;,&amp;obj0,&amp;arg2,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if ((SWIG_ConvertPtr(obj2,(void **) &amp;arg3, SWIGTYPE_p_EnemySaveData,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    if (arg3 == NULL) {
+        PyErr_SetString(PyExc_TypeError,&quot;null reference&quot;); SWIG_fail; 
+    }
+    {
+        try {
+            std_vectorlEnemySaveData_g___setitem_____(arg1,arg2,(EnemySaveData const &amp;)*arg3);
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___setslice__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    int arg2 ;
+    int arg3 ;
+    std::vector&lt;EnemySaveData &gt; *arg4 = 0 ;
+    std::vector&lt;EnemySaveData &gt; temp4 ;
+    std::vector&lt;EnemySaveData &gt; *v4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OiiO:vectorEnemySaveData___setslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
+            unsigned int size = (PyTuple_Check(obj3) ?
+            PyTuple_Size(obj3) :
+            PyList_Size(obj3));
+            temp4.reserve(size);
+            arg4 = &amp;temp4;
+            for (unsigned int i=0; i&lt;size; i++) {
+                EnemySaveData* x;
+                PyObject* o = PySequence_GetItem(obj3,i);
+                if ((SWIG_ConvertPtr(o,(void **) &amp;x, 
+                SWIGTYPE_p_EnemySaveData,0)) != -1) {
+                    temp4.push_back(*x);
+                    Py_DECREF(o);
+                } else {
+                    Py_DECREF(o);
+                    PyErr_SetString(PyExc_TypeError,
+                    &quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
+                    SWIG_fail;
+                }
+            }
+        } else if (SWIG_ConvertPtr(obj3,(void **) &amp;v4, 
+        SWIGTYPE_p_std__vectorTEnemySaveData_t,0) != -1) {
+            arg4 = v4;
+        } else {
+            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot; &quot;EnemySaveData&quot; &quot;&gt; expected&quot;);
+            SWIG_fail;
+        }
+    }
+    std_vectorlEnemySaveData_g___setslice_____(arg1,arg2,arg3,(std::vector&lt;EnemySaveData &gt; const &amp;)*arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___delitem__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorEnemySaveData___delitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        try {
+            std_vectorlEnemySaveData_g___delitem_____(arg1,arg2);
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorEnemySaveData___delslice__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    int arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorEnemySaveData___delslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    std_vectorlEnemySaveData_g___delslice_____(arg1,arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_vectorEnemySaveData(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;EnemySaveData &gt; *arg1 = (std::vector&lt;EnemySaveData &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_vectorEnemySaveData&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTEnemySaveData_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * vectorEnemySaveData_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTEnemySaveData_t, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyObject *_wrap_new_vectorString__SWIG_0(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    unsigned int arg1 = (unsigned int) 0 ;
+    std::vector&lt;std::string &gt; *result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;|O:new_vectorString&quot;,&amp;obj0)) goto fail;
+    if (obj0) {
+        arg1 = (unsigned int) PyInt_AsLong(obj0);
+        if (PyErr_Occurred()) SWIG_fail;
+    }
+    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstd__string_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString__SWIG_1(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    unsigned int arg1 ;
+    std::string *arg2 = 0 ;
+    std::vector&lt;std::string &gt; *result;
+    std::string temp2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:new_vectorString&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    arg1 = (unsigned int) PyInt_AsLong(obj0);
+    if (PyErr_Occurred()) SWIG_fail;
+    {
+        if (PyString_Check(obj1)) {
+            temp2 = std::string(PyString_AsString(obj1),
+            PyString_Size(obj1));
+            arg2 = &amp;temp2;
+        } else {
+            SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+        }
+    }
+    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1,(std::string const &amp;)*arg2);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstd__string_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString__SWIG_2(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = 0 ;
+    std::vector&lt;std::string &gt; *result;
+    std::vector&lt;std::string &gt; temp1 ;
+    std::vector&lt;std::string &gt; *v1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) goto fail;
+    {
+        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
+            unsigned int size = (PyTuple_Check(obj0) ?
+            PyTuple_Size(obj0) :
+            PyList_Size(obj0));
+            temp1 = std::vector&lt;std::string &gt;(size);
+            arg1 = &amp;temp1;
+            for (unsigned int i=0; i&lt;size; i++) {
+                PyObject* o = PySequence_GetItem(obj0,i);
+                if (PyString_Check(o)) {
+                    temp1[i] = (std::string)(\
+                    SwigString_AsString(o));
+                    Py_DECREF(o);
+                } else {
+                    Py_DECREF(o);
+                    PyErr_SetString(PyExc_TypeError,
+                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+                    SWIG_fail;
+                }
+            }
+        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
+        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
+            arg1 = v1;
+        } else {
+            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+            SWIG_fail;
+        }
+    }
+    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;((std::vector&lt;std::string &gt; const &amp;)*arg1);
+    
+    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_std__vectorTstd__string_t, 1);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_new_vectorString(PyObject *self, PyObject *args) {
+    int argc;
+    PyObject *argv[3];
+    int ii;
+    
+    argc = PyObject_Length(args);
+    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+        argv[ii] = PyTuple_GetItem(args,ii);
+    }
+    if ((argc &gt;= 0) &amp;&amp; (argc &lt;= 1)) {
+        int _v;
+        if (argc &lt;= 0) {
+            return _wrap_new_vectorString__SWIG_0(self,args);
+        }
+        {
+            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
+        }
+        if (_v) {
+            return _wrap_new_vectorString__SWIG_0(self,args);
+        }
+    }
+    if (argc == 1) {
+        int _v;
+        {
+            /* native sequence? */
+            if (PyTuple_Check(argv[0]) || PyList_Check(argv[0])) {
+                unsigned int size = (PyTuple_Check(argv[0]) ?
+                PyTuple_Size(argv[0]) :
+                PyList_Size(argv[0]));
+                if (size == 0) {
+                    /* an empty sequence can be of any type */
+                    _v = 1;
+                } else {
+                    /* check the first element only */
+                    PyObject* o = PySequence_GetItem(argv[0],0);
+                    if (PyString_Check(o))
+                    _v = 1;
+                    else
+                    _v = 0;
+                    Py_DECREF(o);
+                }
+            } else {
+                /* wrapped vector? */
+                std::vector&lt;std::string &gt;* v;
+                if (SWIG_ConvertPtr(argv[0],(void **) &amp;v, 
+                SWIGTYPE_p_std__vectorTstd__string_t,0) != -1)
+                _v = 1;
+                else
+                _v = 0;
+            }
+        }
+        if (_v) {
+            return _wrap_new_vectorString__SWIG_2(self,args);
+        }
+    }
+    if (argc == 2) {
+        int _v;
+        {
+            _v = (PyInt_Check(argv[0]) || PyLong_Check(argv[0])) ? 1 : 0;
+        }
+        if (_v) {
+            {
+                _v = PyString_Check(argv[1]) ? 1 : 0;
+            }
+            if (_v) {
+                return _wrap_new_vectorString__SWIG_1(self,args);
+            }
+        }
+    }
+    
+    PyErr_SetString(PyExc_TypeError,&quot;No matching function for overloaded 'new_vectorString'&quot;);
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___len__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    unsigned int result;
+    std::vector&lt;std::string &gt; temp1 ;
+    std::vector&lt;std::string &gt; *v1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___len__&quot;,&amp;obj0)) goto fail;
+    {
+        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
+            unsigned int size = (PyTuple_Check(obj0) ?
+            PyTuple_Size(obj0) :
+            PyList_Size(obj0));
+            temp1 = std::vector&lt;std::string &gt;(size);
+            arg1 = &amp;temp1;
+            for (unsigned int i=0; i&lt;size; i++) {
+                PyObject* o = PySequence_GetItem(obj0,i);
+                if (PyString_Check(o)) {
+                    temp1[i] = (std::string)(\
+                    SwigString_AsString(o));
+                    Py_DECREF(o);
+                } else {
+                    Py_DECREF(o);
+                    PyErr_SetString(PyExc_TypeError,
+                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+                    SWIG_fail;
+                }
+            }
+        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
+        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
+            arg1 = v1;
+        } else {
+            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+            SWIG_fail;
+        }
+    }
+    result = (unsigned int)((std::vector&lt;std::string &gt; const *)arg1)-&gt;size();
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___nonzero__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    bool result;
+    std::vector&lt;std::string &gt; temp1 ;
+    std::vector&lt;std::string &gt; *v1 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___nonzero__&quot;,&amp;obj0)) goto fail;
+    {
+        if (PyTuple_Check(obj0) || PyList_Check(obj0)) {
+            unsigned int size = (PyTuple_Check(obj0) ?
+            PyTuple_Size(obj0) :
+            PyList_Size(obj0));
+            temp1 = std::vector&lt;std::string &gt;(size);
+            arg1 = &amp;temp1;
+            for (unsigned int i=0; i&lt;size; i++) {
+                PyObject* o = PySequence_GetItem(obj0,i);
+                if (PyString_Check(o)) {
+                    temp1[i] = (std::string)(\
+                    SwigString_AsString(o));
+                    Py_DECREF(o);
+                } else {
+                    Py_DECREF(o);
+                    PyErr_SetString(PyExc_TypeError,
+                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+                    SWIG_fail;
+                }
+            }
+        } else if (SWIG_ConvertPtr(obj0,(void **) &amp;v1, 
+        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
+            arg1 = v1;
+        } else {
+            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+            SWIG_fail;
+        }
+    }
+    result = (bool)((std::vector&lt;std::string &gt; const *)arg1)-&gt;empty();
+    
+    resultobj = PyInt_FromLong((long)result);
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_clear(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_clear&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    (arg1)-&gt;clear();
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_append(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::string arg2 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj1 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_append&quot;,&amp;obj0,&amp;obj1)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj1))
+        arg2 = std::string(PyString_AsString(obj1),
+        PyString_Size(obj1));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    (arg1)-&gt;push_back(arg2);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString_pop(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    std::string result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        try {
+            result = std_vectorlstd_string_g_pop___(arg1);
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    {
+        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___getitem__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    int arg2 ;
+    std::string result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorString___getitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        try {
+            result = std_vectorlstd_string_g___getitem_____(arg1,arg2);
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    {
+        resultobj = PyString_FromStringAndSize((&amp;result)-&gt;data(),(&amp;result)-&gt;size());
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___getslice__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    int arg2 ;
+    int arg3 ;
+    std::vector&lt;std::string &gt; result;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorString___getslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    result = std_vectorlstd_string_g___getslice_____(arg1,arg2,arg3);
+    
+    {
+        resultobj = PyTuple_New((&amp;result)-&gt;size());
+        for (unsigned int i=0; i&lt;(&amp;result)-&gt;size(); i++)
+        PyTuple_SetItem(resultobj,i,
+        SwigString_FromString(((std::vector&lt;std::string &gt; &amp;)result)[i]));
+    }
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___setitem__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    int arg2 ;
+    std::string arg3 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj2 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OiO:vectorString___setitem__&quot;,&amp;obj0,&amp;arg2,&amp;obj2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyString_Check(obj2))
+        arg3 = std::string(PyString_AsString(obj2),
+        PyString_Size(obj2));
+        else
+        SWIG_exception(SWIG_TypeError, &quot;string expected&quot;);
+    }
+    {
+        try {
+            std_vectorlstd_string_g___setitem_____(arg1,arg2,arg3);
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___setslice__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    int arg2 ;
+    int arg3 ;
+    std::vector&lt;std::string &gt; *arg4 = 0 ;
+    std::vector&lt;std::string &gt; temp4 ;
+    std::vector&lt;std::string &gt; *v4 ;
+    PyObject * obj0 = 0 ;
+    PyObject * obj3 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;OiiO:vectorString___setslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3,&amp;obj3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        if (PyTuple_Check(obj3) || PyList_Check(obj3)) {
+            unsigned int size = (PyTuple_Check(obj3) ?
+            PyTuple_Size(obj3) :
+            PyList_Size(obj3));
+            temp4 = std::vector&lt;std::string &gt;(size);
+            arg4 = &amp;temp4;
+            for (unsigned int i=0; i&lt;size; i++) {
+                PyObject* o = PySequence_GetItem(obj3,i);
+                if (PyString_Check(o)) {
+                    temp4[i] = (std::string)(\
+                    SwigString_AsString(o));
+                    Py_DECREF(o);
+                } else {
+                    Py_DECREF(o);
+                    PyErr_SetString(PyExc_TypeError,
+                    &quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+                    SWIG_fail;
+                }
+            }
+        } else if (SWIG_ConvertPtr(obj3,(void **) &amp;v4, 
+        SWIGTYPE_p_std__vectorTstd__string_t,1) != -1){
+            arg4 = v4;
+        } else {
+            PyErr_SetString(PyExc_TypeError,&quot;vector&lt;&quot;&quot;std::string&quot; &quot;&gt; expected&quot;);
+            SWIG_fail;
+        }
+    }
+    std_vectorlstd_string_g___setslice_____(arg1,arg2,arg3,(std::vector&lt;std::string &gt; const &amp;)*arg4);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___delitem__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    int arg2 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oi:vectorString___delitem__&quot;,&amp;obj0,&amp;arg2)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    {
+        try {
+            std_vectorlstd_string_g___delitem_____(arg1,arg2);
+            
+        } catch (std::out_of_range&amp; e) {
+            SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
+        }
+    }
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_vectorString___delslice__(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    int arg2 ;
+    int arg3 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;Oii:vectorString___delslice__&quot;,&amp;obj0,&amp;arg2,&amp;arg3)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    std_vectorlstd_string_g___delslice_____(arg1,arg2,arg3);
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject *_wrap_delete_vectorString(PyObject *self, PyObject *args) {
+    PyObject *resultobj;
+    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+    PyObject * obj0 = 0 ;
+    
+    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_vectorString&quot;,&amp;obj0)) goto fail;
+    if ((SWIG_ConvertPtr(obj0,(void **) &amp;arg1, SWIGTYPE_p_std__vectorTstd__string_t,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
+    delete arg1;
+    
+    Py_INCREF(Py_None); resultobj = Py_None;
+    return resultobj;
+    fail:
+    return NULL;
+}
+
+
+static PyObject * vectorString_swigregister(PyObject *self, PyObject *args) {
+    PyObject *obj;
+    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
+    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_t, obj);
+    Py_INCREF(obj);
+    return Py_BuildValue((char *)&quot;&quot;);
+}
+static PyMethodDef SwigMethods[] = {
+	 { (char *)&quot;pair_id_set&quot;, _wrap_pair_id_set, METH_VARARGS },
+	 { (char *)&quot;pair_id_get&quot;, _wrap_pair_id_get, METH_VARARGS },
+	 { (char *)&quot;pair_value_set&quot;, _wrap_pair_value_set, METH_VARARGS },
+	 { (char *)&quot;pair_value_get&quot;, _wrap_pair_value_get, METH_VARARGS },
+	 { (char *)&quot;new_pair&quot;, _wrap_new_pair, METH_VARARGS },
+	 { (char *)&quot;delete_pair&quot;, _wrap_delete_pair, METH_VARARGS },
+	 { (char *)&quot;pair_swigregister&quot;, pair_swigregister, METH_VARARGS },
+	 { (char *)&quot;EnemySaveData_pos_x_set&quot;, _wrap_EnemySaveData_pos_x_set, METH_VARARGS },
+	 { (char *)&quot;EnemySaveData_pos_x_get&quot;, _wrap_EnemySaveData_pos_x_get, METH_VARARGS },
+	 { (char *)&quot;EnemySaveData_pos_y_set&quot;, _wrap_EnemySaveData_pos_y_set, METH_VARARGS },
+	 { (char *)&quot;EnemySaveData_pos_y_get&quot;, _wrap_EnemySaveData_pos_y_get, METH_VARARGS },
+	 { (char *)&quot;new_EnemySaveData&quot;, _wrap_new_EnemySaveData, METH_VARARGS },
+	 { (char *)&quot;delete_EnemySaveData&quot;, _wrap_delete_EnemySaveData, METH_VARARGS },
+	 { (char *)&quot;EnemySaveData_swigregister&quot;, EnemySaveData_swigregister, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_getInstance&quot;, _wrap_SaveGobGameInfo_getInstance, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_updateSave&quot;, _wrap_SaveGobGameInfo_updateSave, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_updateGame&quot;, _wrap_SaveGobGameInfo_updateGame, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_starbucks_set&quot;, _wrap_SaveGobGameInfo_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_starbucks_get&quot;, _wrap_SaveGobGameInfo_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_buckazoids_set&quot;, _wrap_SaveGobGameInfo_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_buckazoids_get&quot;, _wrap_SaveGobGameInfo_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_kills_set&quot;, _wrap_SaveGobGameInfo_kills_set, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_kills_get&quot;, _wrap_SaveGobGameInfo_kills_get, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_pos_x_set&quot;, _wrap_SaveGobGameInfo_pos_x_set, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_pos_x_get&quot;, _wrap_SaveGobGameInfo_pos_x_get, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_pos_y_set&quot;, _wrap_SaveGobGameInfo_pos_y_set, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_pos_y_get&quot;, _wrap_SaveGobGameInfo_pos_y_get, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_system_set&quot;, _wrap_SaveGobGameInfo_system_set, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_system_get&quot;, _wrap_SaveGobGameInfo_system_get, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_getSystem&quot;, _wrap_SaveGobGameInfo_getSystem, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_setSystem&quot;, _wrap_SaveGobGameInfo_setSystem, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_tst_set&quot;, _wrap_SaveGobGameInfo_tst_set, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_tst_get&quot;, _wrap_SaveGobGameInfo_tst_get, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_getTst&quot;, _wrap_SaveGobGameInfo_getTst, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_setTst&quot;, _wrap_SaveGobGameInfo_setTst, METH_VARARGS },
+	 { (char *)&quot;new_SaveGobGameInfo&quot;, _wrap_new_SaveGobGameInfo, METH_VARARGS },
+	 { (char *)&quot;delete_SaveGobGameInfo&quot;, _wrap_delete_SaveGobGameInfo, METH_VARARGS },
+	 { (char *)&quot;SaveGobGameInfo_swigregister&quot;, SaveGobGameInfo_swigregister, METH_VARARGS },
+	 { (char *)&quot;new_GobPlayer&quot;, _wrap_new_GobPlayer, METH_VARARGS },
+	 { (char *)&quot;delete_GobPlayer&quot;, _wrap_delete_GobPlayer, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_ship_set&quot;, _wrap_GobPlayer_ship_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_ship_get&quot;, _wrap_GobPlayer_ship_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_pair_list_set&quot;, _wrap_GobPlayer_pair_list_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_pair_list_get&quot;, _wrap_GobPlayer_pair_list_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_num_pairs_set&quot;, _wrap_GobPlayer_num_pairs_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_num_pairs_get&quot;, _wrap_GobPlayer_num_pairs_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_total_set&quot;, _wrap_GobPlayer_total_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_total_get&quot;, _wrap_GobPlayer_total_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_starbucks_set&quot;, _wrap_GobPlayer_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_starbucks_get&quot;, _wrap_GobPlayer_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_buckazoids_set&quot;, _wrap_GobPlayer_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_buckazoids_get&quot;, _wrap_GobPlayer_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_kills_set&quot;, _wrap_GobPlayer_kills_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_kills_get&quot;, _wrap_GobPlayer_kills_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_starbucks_set&quot;, _wrap_GobPlayer_value_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_starbucks_get&quot;, _wrap_GobPlayer_value_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_buckazoids_set&quot;, _wrap_GobPlayer_value_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_value_buckazoids_get&quot;, _wrap_GobPlayer_value_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_team_set&quot;, _wrap_GobPlayer_team_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_team_get&quot;, _wrap_GobPlayer_team_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_init&quot;, _wrap_GobPlayer_init, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_died&quot;, _wrap_GobPlayer_died, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_new_ship&quot;, _wrap_GobPlayer_new_ship, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_charge&quot;, _wrap_GobPlayer_charge, METH_VARARGS },
+	 { (char *)&quot;GobPlayer__add_pair&quot;, _wrap_GobPlayer__add_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer__get_pair&quot;, _wrap_GobPlayer__get_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_write_pair&quot;, _wrap_GobPlayer_write_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_read_pair&quot;, _wrap_GobPlayer_read_pair, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_upgrade_list_set&quot;, _wrap_GobPlayer_upgrade_list_set, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_upgrade_list_get&quot;, _wrap_GobPlayer_upgrade_list_get, METH_VARARGS },
+	 { (char *)&quot;GobPlayer_swigregister&quot;, GobPlayer_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_ship_set&quot;, _wrap_GobEnemy_ship_set, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_ship_get&quot;, _wrap_GobEnemy_ship_get, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_starbucks_set&quot;, _wrap_GobEnemy_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_starbucks_get&quot;, _wrap_GobEnemy_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_buckazoids_set&quot;, _wrap_GobEnemy_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_buckazoids_get&quot;, _wrap_GobEnemy_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_init&quot;, _wrap_GobEnemy_init, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_died&quot;, _wrap_GobEnemy_died, METH_VARARGS },
+	 { (char *)&quot;new_GobEnemy&quot;, _wrap_new_GobEnemy, METH_VARARGS },
+	 { (char *)&quot;delete_GobEnemy&quot;, _wrap_delete_GobEnemy, METH_VARARGS },
+	 { (char *)&quot;GobEnemy_swigregister&quot;, GobEnemy_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobAsteroid_handle_damage&quot;, _wrap_GobAsteroid_handle_damage, METH_VARARGS },
+	 { (char *)&quot;GobAsteroid_death&quot;, _wrap_GobAsteroid_death, METH_VARARGS },
+	 { (char *)&quot;new_GobAsteroid&quot;, _wrap_new_GobAsteroid, METH_VARARGS },
+	 { (char *)&quot;delete_GobAsteroid&quot;, _wrap_delete_GobAsteroid, METH_VARARGS },
+	 { (char *)&quot;GobAsteroid_swigregister&quot;, GobAsteroid_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobGame__galaxy_set&quot;, _wrap_GobGame__galaxy_set, METH_VARARGS },
+	 { (char *)&quot;GobGame__galaxy_get&quot;, _wrap_GobGame__galaxy_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobplayer_set&quot;, _wrap_GobGame_gobplayer_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobplayer_get&quot;, _wrap_GobGame_gobplayer_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_switch_system&quot;, _wrap_GobGame_switch_system, METH_VARARGS },
+	 { (char *)&quot;new_GobGame&quot;, _wrap_new_GobGame, METH_VARARGS },
+	 { (char *)&quot;GobGame_get_this&quot;, _wrap_GobGame_get_this, METH_VARARGS },
+	 { (char *)&quot;delete_GobGame&quot;, _wrap_delete_GobGame, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_panel_set&quot;, _wrap_GobGame__player_panel_set, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_panel_get&quot;, _wrap_GobGame__player_panel_get, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_control_set&quot;, _wrap_GobGame__player_control_set, METH_VARARGS },
+	 { (char *)&quot;GobGame__player_control_get&quot;, _wrap_GobGame__player_control_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_enemy_team_set&quot;, _wrap_GobGame_enemy_team_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_enemy_team_get&quot;, _wrap_GobGame_enemy_team_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_AddPanel&quot;, _wrap_GobGame_AddPanel, METH_VARARGS },
+	 { (char *)&quot;GobGame_calculate&quot;, _wrap_GobGame_calculate, METH_VARARGS },
+	 { (char *)&quot;GobGame_setGameDone&quot;, _wrap_GobGame_setGameDone, METH_VARARGS },
+	 { (char *)&quot;GobGame_ship_died&quot;, _wrap_GobGame_ship_died, METH_VARARGS },
+	 { (char *)&quot;GobGame_preinit&quot;, _wrap_GobGame_preinit, METH_VARARGS },
+	 { (char *)&quot;GobGame_init&quot;, _wrap_GobGame_init, METH_VARARGS },
+	 { (char *)&quot;GobGame_play_sound&quot;, _wrap_GobGame_play_sound, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_gobplayer&quot;, _wrap_GobGame_add_gobplayer, METH_VARARGS },
+	 { (char *)&quot;GobGame_get_player&quot;, _wrap_GobGame_get_player, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemies_set&quot;, _wrap_GobGame_gobenemies_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemies_get&quot;, _wrap_GobGame_gobenemies_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_max_enemies_set&quot;, _wrap_GobGame_max_enemies_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_max_enemies_get&quot;, _wrap_GobGame_max_enemies_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemy_set&quot;, _wrap_GobGame_gobenemy_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_gobenemy_get&quot;, _wrap_GobGame_gobenemy_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_get_enemy_index&quot;, _wrap_GobGame_get_enemy_index, METH_VARARGS },
+	 { (char *)&quot;GobGame_prepare&quot;, _wrap_GobGame_prepare, METH_VARARGS },
+	 { (char *)&quot;GobGame_fps&quot;, _wrap_GobGame_fps, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_new_enemy&quot;, _wrap_GobGame_add_new_enemy, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_stars&quot;, _wrap_GobGame_add_stars, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_asteroid&quot;, _wrap_GobGame_add_asteroid, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_system&quot;, _wrap_GobGame_add_system, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_player&quot;, _wrap_GobGame_add_player, METH_VARARGS },
+	 { (char *)&quot;GobGame_next_add_new_enemy_time_set&quot;, _wrap_GobGame_next_add_new_enemy_time_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_next_add_new_enemy_time_get&quot;, _wrap_GobGame_next_add_new_enemy_time_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_defenderSprite_set&quot;, _wrap_GobGame_defenderSprite_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_defenderSprite_get&quot;, _wrap_GobGame_defenderSprite_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_num_planets_set&quot;, _wrap_GobGame_num_planets_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_num_planets_get&quot;, _wrap_GobGame_num_planets_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_planet_set&quot;, _wrap_GobGame_planet_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_planet_get&quot;, _wrap_GobGame_planet_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_station_set&quot;, _wrap_GobGame_station_set, METH_VARARGS },
+	 { (char *)&quot;GobGame_station_get&quot;, _wrap_GobGame_station_get, METH_VARARGS },
+	 { (char *)&quot;GobGame_add_planet_and_station&quot;, _wrap_GobGame_add_planet_and_station, METH_VARARGS },
+	 { (char *)&quot;GobGame_swigregister&quot;, GobGame_swigregister, METH_VARARGS },
+	 { (char *)&quot;GobStation__build_type_set&quot;, _wrap_GobStation__build_type_set, METH_VARARGS },
+	 { (char *)&quot;GobStation__build_type_get&quot;, _wrap_GobStation__build_type_get, METH_VARARGS },
+	 { (char *)&quot;GobStation__background_pic_set&quot;, _wrap_GobStation__background_pic_set, METH_VARARGS },
+	 { (char *)&quot;GobStation__background_pic_get&quot;, _wrap_GobStation__background_pic_get, METH_VARARGS },
+	 { (char *)&quot;new_GobStation&quot;, _wrap_new_GobStation, METH_VARARGS },
+	 { (char *)&quot;GobStation_buy_new_ship_menu&quot;, _wrap_GobStation_buy_new_ship_menu, METH_VARARGS },
+	 { (char *)&quot;GobStation_inflict_damage&quot;, _wrap_GobStation_inflict_damage, METH_VARARGS },
+	 { (char *)&quot;GobStation_station_screen&quot;, _wrap_GobStation_station_screen, METH_VARARGS },
+	 { (char *)&quot;GobStation_upgrade_menu&quot;, _wrap_GobStation_upgrade_menu, METH_VARARGS },
+	 { (char *)&quot;delete_GobStation&quot;, _wrap_delete_GobStation, METH_VARARGS },
+	 { (char *)&quot;GobStation_swigregister&quot;, GobStation_swigregister, METH_VARARGS },
+	 { (char *)&quot;Upgrade_name_set&quot;, _wrap_Upgrade_name_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_name_get&quot;, _wrap_Upgrade_name_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_starbucks_set&quot;, _wrap_Upgrade_starbucks_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_starbucks_get&quot;, _wrap_Upgrade_starbucks_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_buckazoids_set&quot;, _wrap_Upgrade_buckazoids_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_buckazoids_get&quot;, _wrap_Upgrade_buckazoids_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_status_set&quot;, _wrap_Upgrade_status_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_status_get&quot;, _wrap_Upgrade_status_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_num_set&quot;, _wrap_Upgrade_num_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_num_get&quot;, _wrap_Upgrade_num_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_index_set&quot;, _wrap_Upgrade_index_set, METH_VARARGS },
+	 { (char *)&quot;Upgrade_index_get&quot;, _wrap_Upgrade_index_get, METH_VARARGS },
+	 { (char *)&quot;Upgrade_update&quot;, _wrap_Upgrade_update, METH_VARARGS },
+	 { (char *)&quot;Upgrade_execute&quot;, _wrap_Upgrade_execute, METH_VARARGS },
+	 { (char *)&quot;Upgrade_charge&quot;, _wrap_Upgrade_charge, METH_VARARGS },
+	 { (char *)&quot;Upgrade_clear&quot;, _wrap_Upgrade_clear, METH_VARARGS },
+	 { (char *)&quot;Upgrade_duplicate&quot;, _wrap_Upgrade_duplicate, METH_VARARGS },
+	 { (char *)&quot;delete_Upgrade&quot;, _wrap_delete_Upgrade, METH_VARARGS },
+	 { (char *)&quot;Upgrade_swigregister&quot;, Upgrade_swigregister, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_p_set&quot;, _wrap_RainbowRift_p_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_p_get&quot;, _wrap_RainbowRift_p_get, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_c_set&quot;, _wrap_RainbowRift_c_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_c_get&quot;, _wrap_RainbowRift_c_get, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time_set&quot;, _wrap_RainbowRift_next_time_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time_get&quot;, _wrap_RainbowRift_next_time_get, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time2_set&quot;, _wrap_RainbowRift_next_time2_set, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_next_time2_get&quot;, _wrap_RainbowRift_next_time2_get, METH_VARARGS },
+	 { (char *)&quot;new_RainbowRift&quot;, _wrap_new_RainbowRift, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_animate&quot;, _wrap_RainbowRift_animate, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_calculate&quot;, _wrap_RainbowRift_calculate, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_squiggle&quot;, _wrap_RainbowRift_squiggle, METH_VARARGS },
+	 { (char *)&quot;delete_RainbowRift&quot;, _wrap_delete_RainbowRift, METH_VARARGS },
+	 { (char *)&quot;RainbowRift_swigregister&quot;, RainbowRift_swigregister, METH_VARARGS },
+	 { (char *)&quot;DialogApi_startDialog&quot;, _wrap_DialogApi_startDialog, METH_VARARGS },
+	 { (char *)&quot;DialogApi_endDialog&quot;, _wrap_DialogApi_endDialog, METH_VARARGS },
+	 { (char *)&quot;DialogApi_askPlayer&quot;, _wrap_DialogApi_askPlayer, METH_VARARGS },
+	 { (char *)&quot;DialogApi_showText&quot;, _wrap_DialogApi_showText, METH_VARARGS },
+	 { (char *)&quot;DialogApi_showAlienPicture&quot;, _wrap_DialogApi_showAlienPicture, METH_VARARGS },
+	 { (char *)&quot;new_DialogApi&quot;, _wrap_new_DialogApi, METH_VARARGS },
+	 { (char *)&quot;delete_DialogApi&quot;, _wrap_delete_DialogApi, METH_VARARGS },
+	 { (char *)&quot;DialogApi_swigregister&quot;, DialogApi_swigregister, METH_VARARGS },
+	 { (char *)&quot;new_vectorEnemySaveData&quot;, _wrap_new_vectorEnemySaveData, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___len__&quot;, _wrap_vectorEnemySaveData___len__, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData_clear&quot;, _wrap_vectorEnemySaveData_clear, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData_append&quot;, _wrap_vectorEnemySaveData_append, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___nonzero__&quot;, _wrap_vectorEnemySaveData___nonzero__, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData_pop&quot;, _wrap_vectorEnemySaveData_pop, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___getitem__&quot;, _wrap_vectorEnemySaveData___getitem__, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___getslice__&quot;, _wrap_vectorEnemySaveData___getslice__, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___setitem__&quot;, _wrap_vectorEnemySaveData___setitem__, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___setslice__&quot;, _wrap_vectorEnemySaveData___setslice__, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___delitem__&quot;, _wrap_vectorEnemySaveData___delitem__, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData___delslice__&quot;, _wrap_vectorEnemySaveData___delslice__, METH_VARARGS },
+	 { (char *)&quot;delete_vectorEnemySaveData&quot;, _wrap_delete_vectorEnemySaveData, METH_VARARGS },
+	 { (char *)&quot;vectorEnemySaveData_swigregister&quot;, vectorEnemySaveData_swigregister, METH_VARARGS },
+	 { (char *)&quot;new_vectorString&quot;, _wrap_new_vectorString, METH_VARARGS },
+	 { (char *)&quot;vectorString___len__&quot;, _wrap_vectorString___len__, METH_VARARGS },
+	 { (char *)&quot;vectorString___nonzero__&quot;, _wrap_vectorString___nonzero__, METH_VARARGS },
+	 { (char *)&quot;vectorString_clear&quot;, _wrap_vectorString_clear, METH_VARARGS },
+	 { (char *)&quot;vectorString_append&quot;, _wrap_vectorString_append, METH_VARARGS },
+	 { (char *)&quot;vectorString_pop&quot;, _wrap_vectorString_pop, METH_VARARGS },
+	 { (char *)&quot;vectorString___getitem__&quot;, _wrap_vectorString___getitem__, METH_VARARGS },
+	 { (char *)&quot;vectorString___getslice__&quot;, _wrap_vectorString___getslice__, METH_VARARGS },
+	 { (char *)&quot;vectorString___setitem__&quot;, _wrap_vectorString___setitem__, METH_VARARGS },
+	 { (char *)&quot;vectorString___setslice__&quot;, _wrap_vectorString___setslice__, METH_VARARGS },
+	 { (char *)&quot;vectorString___delitem__&quot;, _wrap_vectorString___delitem__, METH_VARARGS },
+	 { (char *)&quot;vectorString___delslice__&quot;, _wrap_vectorString___delslice__, METH_VARARGS },
+	 { (char *)&quot;delete_vectorString&quot;, _wrap_delete_vectorString, METH_VARARGS },
+	 { (char *)&quot;vectorString_swigregister&quot;, vectorString_swigregister, METH_VARARGS },
+	 { NULL, NULL }
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static void *_p_RainbowRiftTo_p_SpaceLocation(void *x) {
+    return (void *)((SpaceLocation *)  ((RainbowRift *) x));
+}
+static swig_type_info _swigt__p_GobPlayer[] = {{&quot;_p_GobPlayer&quot;, 0, &quot;GobPlayer *&quot;, 0},{&quot;_p_GobPlayer&quot;},{0}};
+static swig_type_info _swigt__p_p_Upgrade[] = {{&quot;_p_p_Upgrade&quot;, 0, &quot;Upgrade **&quot;, 0},{&quot;_p_p_Upgrade&quot;},{0}};
+static swig_type_info _swigt__p_SpaceLocation[] = {{&quot;_p_SpaceLocation&quot;, 0, &quot;SpaceLocation *&quot;, 0},{&quot;_p_SpaceLocation&quot;},{&quot;_p_RainbowRift&quot;, _p_RainbowRiftTo_p_SpaceLocation},{0}};
+static swig_type_info _swigt__p_p_GobStation[] = {{&quot;_p_p_GobStation&quot;, 0, &quot;GobStation **&quot;, 0},{&quot;_p_p_GobStation&quot;},{0}};
+static swig_type_info _swigt__p_GobStation[] = {{&quot;_p_GobStation&quot;, 0, &quot;GobStation *&quot;, 0},{&quot;_p_GobStation&quot;},{0}};
+static swig_type_info _swigt__p_Upgrade[] = {{&quot;_p_Upgrade&quot;, 0, &quot;Upgrade *&quot;, 0},{&quot;_p_Upgrade&quot;},{0}};
+static swig_type_info _swigt__p_RGB[] = {{&quot;_p_RGB&quot;, 0, &quot;RGB *&quot;, 0},{&quot;_p_RGB&quot;},{0}};
+static swig_type_info _swigt__p_Log[] = {{&quot;_p_Log&quot;, 0, &quot;Log *&quot;, 0},{&quot;_p_Log&quot;},{0}};
+static swig_type_info _swigt__p_StarMap[] = {{&quot;_p_StarMap&quot;, 0, &quot;StarMap *&quot;, 0},{&quot;_p_StarMap&quot;},{0}};
+static swig_type_info _swigt__p_float[] = {{&quot;_p_float&quot;, 0, &quot;float *&quot;, 0},{&quot;_p_float&quot;},{0}};
+static swig_type_info _swigt__p_std__vectorTEnemySaveData_t[] = {{&quot;_p_std__vectorTEnemySaveData_t&quot;, 0, &quot;std::vector&lt;EnemySaveData &gt; *&quot;, 0},{&quot;_p_std__vectorTEnemySaveData_t&quot;},{0}};
+static swig_type_info _swigt__p_GobAsteroid[] = {{&quot;_p_GobAsteroid&quot;, 0, &quot;GobAsteroid *&quot;, 0},{&quot;_p_GobAsteroid&quot;},{0}};
+static swig_type_info _swigt__p_TeamCode[] = {{&quot;_p_TeamCode&quot;, 0, &quot;TeamCode *&quot;, 0},{&quot;_p_TeamCode&quot;},{0}};
+static swig_type_info _swigt__p_GobEnemy[] = {{&quot;_p_GobEnemy&quot;, 0, &quot;GobEnemy *&quot;, 0},{&quot;_p_GobEnemy&quot;},{0}};
+static swig_type_info _swigt__p_p_GobEnemy[] = {{&quot;_p_p_GobEnemy&quot;, 0, &quot;GobEnemy **&quot;, 0},{&quot;_p_p_GobEnemy&quot;},{0}};
+static swig_type_info _swigt__p_p_Planet[] = {{&quot;_p_p_Planet&quot;, 0, &quot;Planet **&quot;, 0},{&quot;_p_p_Planet&quot;},{0}};
+static swig_type_info _swigt__p_RainbowRift[] = {{&quot;_p_RainbowRift&quot;, 0, &quot;RainbowRift *&quot;, 0},{&quot;_p_RainbowRift&quot;},{0}};
+static swig_type_info _swigt__p_GobGame[] = {{&quot;_p_GobGame&quot;, 0, &quot;GobGame *&quot;, 0},{&quot;_p_GobGame&quot;},{0}};
+static swig_type_info _swigt__p_EnemySaveData[] = {{&quot;_p_EnemySaveData&quot;, 0, &quot;EnemySaveData *&quot;, 0},{&quot;_p_EnemySaveData&quot;},{0}};
+static swig_type_info _swigt__p_std__string[] = {{&quot;_p_std__string&quot;, 0, &quot;std::string *&quot;, 0},{&quot;_p_std__string&quot;},{0}};
+static swig_type_info _swigt__p_Vector2[] = {{&quot;_p_Vector2&quot;, 0, &quot;Vector2 *&quot;, 0},{&quot;_p_Vector2&quot;},{0}};
+static swig_type_info _swigt__p_SaveGobGameInfo[] = {{&quot;_p_SaveGobGameInfo&quot;, 0, &quot;SaveGobGameInfo *&quot;, 0},{&quot;_p_SaveGobGameInfo&quot;},{0}};
+static swig_type_info _swigt__p_DialogApi[] = {{&quot;_p_DialogApi&quot;, 0, &quot;DialogApi *&quot;, 0},{&quot;_p_DialogApi&quot;},{0}};
+static swig_type_info _swigt__p_pair[] = {{&quot;_p_pair&quot;, 0, &quot;pair *&quot;, 0},{&quot;_p_pair&quot;},{0}};
+static swig_type_info _swigt__p_SpaceSprite[] = {{&quot;_p_SpaceSprite&quot;, 0, &quot;SpaceSprite *&quot;, 0},{&quot;_p_SpaceSprite&quot;},{0}};
+static swig_type_info _swigt__p_Control[] = {{&quot;_p_Control&quot;, 0, &quot;Control *&quot;, 0},{&quot;_p_Control&quot;},{0}};
+static swig_type_info _swigt__p_SpaceObject[] = {{&quot;_p_SpaceObject&quot;, 0, &quot;SpaceObject *&quot;, 0},{&quot;_p_SpaceObject&quot;},{0}};
+static swig_type_info _swigt__p_Frame[] = {{&quot;_p_Frame&quot;, 0, &quot;Frame *&quot;, 0},{&quot;_p_Frame&quot;},{0}};
+static swig_type_info _swigt__p_std__vectorTstd__string_t[] = {{&quot;_p_std__vectorTstd__string_t&quot;, 0, &quot;std::vector&lt;std::string &gt; *&quot;, 0},{&quot;_p_std__vectorTstd__string_t&quot;},{0}};
+static swig_type_info _swigt__p_ShipPanel[] = {{&quot;_p_ShipPanel&quot;, 0, &quot;ShipPanel *&quot;, 0},{&quot;_p_ShipPanel&quot;},{0}};
+static swig_type_info _swigt__p_SAMPLE[] = {{&quot;_p_SAMPLE&quot;, 0, &quot;SAMPLE *&quot;, 0},{&quot;_p_SAMPLE&quot;},{0}};
+static swig_type_info _swigt__p_ShipType[] = {{&quot;_p_ShipType&quot;, 0, &quot;ShipType *&quot;, 0},{&quot;_p_ShipType&quot;},{0}};
+static swig_type_info _swigt__p_Ship[] = {{&quot;_p_Ship&quot;, 0, &quot;Ship *&quot;, 0},{&quot;_p_Ship&quot;},{0}};
+
+static swig_type_info *swig_types_initial[] = {
+_swigt__p_GobPlayer, 
+_swigt__p_p_Upgrade, 
+_swigt__p_SpaceLocation, 
+_swigt__p_p_GobStation, 
+_swigt__p_GobStation, 
+_swigt__p_Upgrade, 
+_swigt__p_RGB, 
+_swigt__p_Log, 
+_swigt__p_StarMap, 
+_swigt__p_float, 
+_swigt__p_std__vectorTEnemySaveData_t, 
+_swigt__p_GobAsteroid, 
+_swigt__p_TeamCode, 
+_swigt__p_GobEnemy, 
+_swigt__p_p_GobEnemy, 
+_swigt__p_p_Planet, 
+_swigt__p_RainbowRift, 
+_swigt__p_GobGame, 
+_swigt__p_EnemySaveData, 
+_swigt__p_std__string, 
+_swigt__p_Vector2, 
+_swigt__p_SaveGobGameInfo, 
+_swigt__p_DialogApi, 
+_swigt__p_pair, 
+_swigt__p_SpaceSprite, 
+_swigt__p_Control, 
+_swigt__p_SpaceObject, 
+_swigt__p_Frame, 
+_swigt__p_std__vectorTstd__string_t, 
+_swigt__p_ShipPanel, 
+_swigt__p_SAMPLE, 
+_swigt__p_ShipType, 
+_swigt__p_Ship, 
+0
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+static swig_const_info swig_const_table[] = {
+{ SWIG_PY_INT,     (char *)&quot;Upgrade_active&quot;, (long) Upgrade::active, 0, 0, 0},
+{ SWIG_PY_INT,     (char *)&quot;Upgrade_inactive&quot;, (long) Upgrade::inactive, 0, 0, 0},
+{ SWIG_PY_INT,     (char *)&quot;RainbowRift_n&quot;, (long) RainbowRift::n, 0, 0, 0},
+{0}};
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+SWIGEXPORT(void) SWIG_init(void) {
+    static PyObject *SWIG_globals = 0; 
+    static int       typeinit = 0;
+    PyObject *m, *d;
+    int       i;
+    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
+    m = Py_InitModule((char *) SWIG_name, SwigMethods);
+    d = PyModule_GetDict(m);
+    
+    if (!typeinit) {
+        for (i = 0; swig_types_initial[i]; i++) {
+            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
+        }
+        typeinit = 1;
+    }
+    SWIG_InstallConstants(d,swig_const_table);
+    
+}
+

Added: trunk/source/other/gamedialog.cpp
===================================================================
--- trunk/source/other/gamedialog.cpp	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/other/gamedialog.cpp	2005-05-05 19:42:24 UTC (rev 148)
@@ -0,0 +1,48 @@
+/* $Id: nullphas.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
+/*
+This file is part of &quot;TW-Light&quot; 
+                    <A HREF="http://tw-light.berlios.de/">http://tw-light.berlios.de/</A>
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include &lt;iostream&gt;
+
+#include &quot;gamedialog.h&quot;
+
+void DialogApi::startDialog()
+{
+  std::cerr&lt;&lt;&quot;Start Dialog&quot;;
+}
+
+void DialogApi::endDialog()
+{
+  std::cerr&lt;&lt;&quot;End Dialog&quot;;
+}
+
+int DialogApi::askPlayer(std::vector&lt;std::string&gt; answers)
+{
+  for(std::vector&lt;std::string&gt;::iterator i = answers.begin(); i != answers.end(); i++)
+    {
+      std::cerr&lt;&lt;*i;
+    }
+
+  return 0;
+}
+  
+void DialogApi::showText(std::string text, int delay, int x, int y)
+{
+}
+  
+void DialogApi::showAlienPicture(std::string path)
+{
+};

Added: trunk/source/other/gamedialog.h
===================================================================
--- trunk/source/other/gamedialog.h	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/other/gamedialog.h	2005-05-05 19:42:24 UTC (rev 148)
@@ -0,0 +1,47 @@
+/* $Id: nullphas.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
+/*
+This file is part of &quot;TW-Light&quot; 
+                    <A HREF="http://tw-light.berlios.de/">http://tw-light.berlios.de/</A>
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+/// Provide dialog api 
+class DialogApi
+{
+ public:
+  /// Save game state, pause game, init stuff to show dialog
+  static void startDialog();
+  /// Return to predialog game state
+  static void endDialog();
+  
+  /// player should select from answer variants
+  ///
+  /// \return player answer position
+  static int askPlayer(std::vector&lt;std::string&gt; answers);
+  
+  /// show alien text
+  ///
+  /// @param text alien text
+  /// @param delay how long to display msec
+  /// @param x center text position (from 0 to 100)
+  /// @param y center text position (from 0 to 100)
+  static void showText(std::string text, int delay, int x, int y);
+  
+  /// show that ugly alien face
+  ///
+  /// @param file path from game directory
+  static void showAlienPicture(std::string path);
+};

Modified: trunk/source/other/gup.h
===================================================================
--- trunk/source/other/gup.h	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/other/gup.h	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,3 +1,20 @@
+/* $Id: nullphas.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
+/*
+This file is part of &quot;TW-Light&quot; 
+                    <A HREF="http://tw-light.berlios.de/">http://tw-light.berlios.de/</A>
+Copyright (C) 2001-2004  TimeWarp development team
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+*/
+
 class Upgrade;
 extern Upgrade **upgrade_list;
 

Modified: trunk/source/other/nullphas.h
===================================================================
--- trunk/source/other/nullphas.h	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/other/nullphas.h	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,7 +1,7 @@
 /* $Id: nullphas.h,v 1.1.1.1 2004/08/01 10:21:24 Yura Exp $ */ 
 /*
 This file is part of &quot;TW-Light&quot; 
-                    <A HREF="http://timewarp.sourceforge.net/">http://timewarp.sourceforge.net/</A>
+                    <A HREF="http://tw-light.berlios.de/">http://tw-light.berlios.de/</A>
 Copyright (C) 2001-2004  TimeWarp development team
 
 This program is free software; you can redistribute it and/or modify

Modified: trunk/source/python/python_class.cpp
===================================================================
--- trunk/source/python/python_class.cpp	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/source/python/python_class.cpp	2005-05-05 19:42:24 UTC (rev 148)
@@ -34,7 +34,7 @@
 
 extern &quot;C&quot;
 {
-  void init_ggob(void);
+  void init_tml(void);
 }
 
 
@@ -50,7 +50,7 @@
     // For windows we should include part of standart library we use
     insert_path( (char*)(datafile_path + &quot;/python/lib&quot;).c_str());
 #endif
-    init_ggob();
+    init_tml();
 }
 
 void python::cleanup () 

Modified: trunk/sources.lst
===================================================================
--- trunk/sources.lst	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/sources.lst	2005-05-05 19:42:24 UTC (rev 148)
@@ -56,6 +56,7 @@
 source/other/radar.cpp
 source/other/dialogs.cpp
 source/other/starmap.cpp
+source/other/gamedialog.cpp
 source/ships/shptauar.cpp
 source/ships/shpbogce.cpp
 source/ships/shpaktgu.cpp
@@ -98,7 +99,7 @@
 source/libraries/jpgalleg/jpgalleg.c
 source/scp.cpp
 source/doxygen.cpp
-source/generated/ggob_wrap.cpp
+source/generated/tml_wrap.cpp
 source/input.cpp
 source/sc1ships/shpearcr.cpp
 source/sc1ships/shpchebr.cpp

Modified: trunk/web/downloads.php
===================================================================
--- trunk/web/downloads.php	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/web/downloads.php	2005-05-05 19:42:24 UTC (rev 148)
@@ -2,7 +2,7 @@
 &lt;h2&gt;Downloads&lt;/h2&gt;
   
 &lt;p class=&quot;indented&quot;&gt;
-The latest version is &lt;b&gt;0.3r69&lt;/b&gt;. You can download it &lt;a href=&quot;<A HREF="http://developer.berlios.de/project/showfiles.php?group_id=2082&amp;release_id=3480">http://developer.berlios.de/project/showfiles.php?group_id=2082&amp;release_id=3480</A>&quot;&gt;here.&lt;/a&gt;
+The latest version is &lt;b&gt;0.3r147&lt;/b&gt;. You can download it &lt;a href=&quot;<A HREF="http://developer.berlios.de/project/showfiles.php?group_id=2082&amp;release_id=5647">http://developer.berlios.de/project/showfiles.php?group_id=2082&amp;release_id=5647</A>&quot;&gt;here.&lt;/a&gt;
 
 &lt;p class=&quot;indented&quot;&gt;
 To successfully compile the sources and play the game on Linux/Unix you first need 
@@ -18,7 +18,7 @@
 &lt;p class=&quot;indented&quot;&gt;
 If you want to contribute TW-Light by writting good dialogs, download and use 
 our dialog editor. The latest version is &lt;b&gt;73&lt;/b&gt;. You can download Windows binaries 
-&lt;a href=&quot;./dialog-editor-win32-73.zip&quot;&gt;here&lt;/a&gt;. This 
+&lt;a href=&quot;./dialog-editor.zip&quot;&gt;here&lt;/a&gt;. This 
 &lt;a href=&quot;./tutorial.zip&quot;&gt;tutorial&lt;/a&gt; contains few instruction about how to use it.
 &lt;/p&gt;
 &lt;p class=&quot;indented&quot;&gt;

Modified: trunk/web/twplot.zip
===================================================================
(Binary files differ)

Modified: trunk/web/update.sh
===================================================================
--- trunk/web/update.sh	2005-05-02 20:41:50 UTC (rev 147)
+++ trunk/web/update.sh	2005-05-05 19:42:24 UTC (rev 148)
@@ -1,2 +1,2 @@
 #!/bin/bash
-scp downloads.php <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">yurand at shell.berlios.de</A>:/home/groups/tw-light/htdocs
\ No newline at end of file
+scp downloads.php <A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">yurand at shell.berlios.de</A>:/home/groups/tw-light/htdocs


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000093.html">[Tw-light-svn] r147 - in trunk: . doc gamedata source source/python
</A></li>
	<LI>Next message: <A HREF="000095.html">[Tw-light-svn] r149 - in trunk: . doc gamedata/images gamedata/images/alien gamedata/python source/generated source/other source/python
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#94">[ date ]</a>
              <a href="thread.html#94">[ thread ]</a>
              <a href="subject.html#94">[ subject ]</a>
              <a href="author.html#94">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
