<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Tw-light-svn] r208 - in trunk: gamedata gamedata/images/stars gamedata/python source/generated source/melee
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tw-light-svn/2006-May/index.html" >
   <LINK REL="made" HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r208%20-%20in%20trunk%3A%20gamedata%20gamedata/images/stars%20gamedata/python%20source/generated%20source/melee&In-Reply-To=%3C200605081133.k48BX8l8022053%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000155.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tw-light-svn] r208 - in trunk: gamedata gamedata/images/stars gamedata/python source/generated source/melee</H1>
    <B>yurand at BerliOS</B> 
    <A HREF="mailto:tw-light-svn%40lists.berlios.de?Subject=Re%3A%20%5BTw-light-svn%5D%20r208%20-%20in%20trunk%3A%20gamedata%20gamedata/images/stars%20gamedata/python%20source/generated%20source/melee&In-Reply-To=%3C200605081133.k48BX8l8022053%40sheep.berlios.de%3E"
       TITLE="[Tw-light-svn] r208 - in trunk: gamedata gamedata/images/stars gamedata/python source/generated source/melee">yurand at berlios.de
       </A><BR>
    <I>Mon May  8 13:33:08 CEST 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000155.html">[Tw-light-svn] r209 - in trunk: gamedata gamedata/games/test_game/scripts/systems gamedata/images gamedata/images/stations source source/games source/generated source/melee source/tml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#154">[ date ]</a>
              <a href="thread.html#154">[ thread ]</a>
              <a href="subject.html#154">[ subject ]</a>
              <a href="author.html#154">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: yurand
Date: 2006-05-08 13:32:42 +0200 (Mon, 08 May 2006)
New Revision: 208

Added:
   trunk/gamedata/images/stars/star001.bmp
   trunk/gamedata/images/stars/star002.bmp
   trunk/gamedata/images/stars/star003.bmp
   trunk/gamedata/images/stars/star004.bmp
   trunk/gamedata/images/stars/star005.bmp
   trunk/gamedata/images/stars/star006.bmp
   trunk/gamedata/images/stars/star007.bmp
   trunk/gamedata/images/stars/star008.bmp
   trunk/gamedata/images/stars/star009.bmp
   trunk/gamedata/images/stars/star010.bmp
   trunk/gamedata/images/stars/star011.bmp
   trunk/gamedata/images/stars/star012.bmp
   trunk/gamedata/images/stars/star013.bmp
   trunk/gamedata/images/stars/star014.bmp
   trunk/gamedata/images/stars/star015.bmp
   trunk/gamedata/images/stars/star016.bmp
   trunk/gamedata/images/stars/star017.bmp
   trunk/gamedata/images/stars/star018.bmp
   trunk/gamedata/images/stars/star019.bmp
Removed:
   trunk/gamedata/images/stars/STAR_S01_PCX.bmp
   trunk/gamedata/images/stars/STAR_S02_PCX.bmp
   trunk/gamedata/images/stars/STAR_S03_PCX.bmp
   trunk/gamedata/images/stars/star_00.bmp
   trunk/gamedata/images/stars/star_01.bmp
   trunk/gamedata/images/stars/star_02.bmp
   trunk/gamedata/images/stars/star_03.bmp
   trunk/gamedata/images/stars/star_04.bmp
   trunk/gamedata/images/stars/star_05.bmp
   trunk/gamedata/images/stars/star_06.bmp
   trunk/gamedata/images/stars/star_07.bmp
   trunk/gamedata/images/stars/star_08.bmp
   trunk/gamedata/images/stars/star_09.bmp
   trunk/gamedata/images/stars/star_10.bmp
   trunk/gamedata/images/stars/star_11.bmp
   trunk/gamedata/images/stars/star_12.bmp
   trunk/gamedata/images/stars/star_13.bmp
   trunk/gamedata/images/stars/star_14.bmp
   trunk/gamedata/images/stars/star_15.bmp
   trunk/gamedata/stars.dat
Modified:
   trunk/gamedata/python/tml.py
   trunk/source/generated/tml.py
   trunk/source/generated/tml_wrap.cpp
   trunk/source/melee/mcbodies.cpp
Log:
Removing duplicated images


Deleted: trunk/gamedata/images/stars/STAR_S01_PCX.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/STAR_S02_PCX.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/STAR_S03_PCX.bmp
===================================================================
(Binary files differ)

Added: trunk/gamedata/images/stars/star001.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star001.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star002.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star002.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star003.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star003.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star004.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star004.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star005.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star005.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star006.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star006.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star007.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star007.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star008.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star008.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star009.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star009.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star010.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star010.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star011.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star011.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star012.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star012.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star013.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star013.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star014.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star014.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star015.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star015.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star016.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star016.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star017.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star017.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star018.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star018.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/gamedata/images/stars/star019.bmp
===================================================================
(Binary files differ)


Property changes on: trunk/gamedata/images/stars/star019.bmp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: trunk/gamedata/images/stars/star_00.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_01.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_02.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_03.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_04.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_05.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_06.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_07.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_08.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_09.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_10.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_11.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_12.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_13.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_14.bmp
===================================================================
(Binary files differ)

Deleted: trunk/gamedata/images/stars/star_15.bmp
===================================================================
(Binary files differ)

Modified: trunk/gamedata/python/tml.py
===================================================================
--- trunk/gamedata/python/tml.py	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/gamedata/python/tml.py	2006-05-08 11:32:42 UTC (rev 208)
@@ -1,408 +1,353 @@
-# This file was created automatically by SWIG.
-# Don't modify this file, modify the SWIG interface instead.
-# This file is compatible with both classic and new-style classes.
-
-import _tml
-
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == &quot;this&quot;):
-        if isinstance(value, class_type):
-            self.__dict__[name] = value.this
-            if hasattr(value,&quot;thisown&quot;): self.__dict__[&quot;thisown&quot;] = value.thisown
-            del value.thisown
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static) or hasattr(self,name) or (name == &quot;thisown&quot;):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError(&quot;You cannot add attributes to %s&quot; % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError,name
-
-import types
-try:
-    _object = types.ObjectType
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-del types
-
-
-class GameAction(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ GameAction instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.GameAction_clean
-    if _newclass:clean = staticmethod(_tml.GameAction_clean)
-    __swig_getmethods__[&quot;add_system&quot;] = lambda x: _tml.GameAction_add_system
-    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
-    __swig_getmethods__[&quot;add_planet&quot;] = lambda x: _tml.GameAction_add_planet
-    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
-    __swig_getmethods__[&quot;add_orbiter_station&quot;] = lambda x: _tml.GameAction_add_orbiter_station
-    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
-    __swig_getmethods__[&quot;add_asteroid&quot;] = lambda x: _tml.GameAction_add_asteroid
-    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
-    __swig_getmethods__[&quot;add_player&quot;] = lambda x: _tml.GameAction_add_player
-    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
-    __swig_getmethods__[&quot;add_ship&quot;] = lambda x: _tml.GameAction_add_ship
-    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
-    __swig_getmethods__[&quot;get_string_flag&quot;] = lambda x: _tml.GameAction_get_string_flag
-    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
-    __swig_getmethods__[&quot;save_flag&quot;] = lambda x: _tml.GameAction_save_flag
-    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
-    __swig_getmethods__[&quot;get_double_flag&quot;] = lambda x: _tml.GameAction_get_double_flag
-    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
-    __swig_getmethods__[&quot;get_player_ship_id&quot;] = lambda x: _tml.GameAction_get_player_ship_id
-    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
-    __swig_getmethods__[&quot;get_player_star_system&quot;] = lambda x: _tml.GameAction_get_player_star_system
-    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
-    __swig_getmethods__[&quot;set_target&quot;] = lambda x: _tml.GameAction_set_target
-    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
-    __swig_getmethods__[&quot;disable_weapon&quot;] = lambda x: _tml.GameAction_disable_weapon
-    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
-    __swig_getmethods__[&quot;enable_weapon&quot;] = lambda x: _tml.GameAction_enable_weapon
-    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
-    __swig_getmethods__[&quot;go_to_point&quot;] = lambda x: _tml.GameAction_go_to_point
-    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
-    __swig_getmethods__[&quot;go_to_location&quot;] = lambda x: _tml.GameAction_go_to_location
-    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
-    __swig_getmethods__[&quot;guard_location&quot;] = lambda x: _tml.GameAction_guard_location
-    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
-    __swig_getmethods__[&quot;guard_point&quot;] = lambda x: _tml.GameAction_guard_point
-    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
-    __swig_getmethods__[&quot;set_ship_team&quot;] = lambda x: _tml.GameAction_set_ship_team
-    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
-    __swig_getmethods__[&quot;get_enemy_team&quot;] = lambda x: _tml.GameAction_get_enemy_team
-    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
-    __swig_getmethods__[&quot;get_player_team&quot;] = lambda x: _tml.GameAction_get_player_team
-    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
-    __swig_getmethods__[&quot;remove_location&quot;] = lambda x: _tml.GameAction_remove_location
-    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
-    __swig_getmethods__[&quot;set_crew&quot;] = lambda x: _tml.GameAction_set_crew
-    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
-    __swig_getmethods__[&quot;get_location_pos_x&quot;] = lambda x: _tml.GameAction_get_location_pos_x
-    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
-    __swig_getmethods__[&quot;get_location_pos_y&quot;] = lambda x: _tml.GameAction_get_location_pos_y
-    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
-    __swig_getmethods__[&quot;exist&quot;] = lambda x: _tml.GameAction_exist
-    if _newclass:exist = staticmethod(_tml.GameAction_exist)
-    __swig_getmethods__[&quot;end_game&quot;] = lambda x: _tml.GameAction_end_game
-    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
-    __swig_getmethods__[&quot;scroll_text&quot;] = lambda x: _tml.GameAction_scroll_text
-    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
-    __swig_getmethods__[&quot;print_message&quot;] = lambda x: _tml.GameAction_print_message
-    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
-    __swig_getmethods__[&quot;set_camera_mode&quot;] = lambda x: _tml.GameAction_set_camera_mode
-    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
-    def __init__(self, *args):
-        _swig_setattr(self, GameAction, 'this', _tml.new_GameAction(*args))
-        _swig_setattr(self, GameAction, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameAction):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameActionPtr(GameAction):
-    def __init__(self, this):
-        _swig_setattr(self, GameAction, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GameAction, 'thisown', 0)
-        _swig_setattr(self, GameAction,self.__class__,GameAction)
-_tml.GameAction_swigregister(GameActionPtr)
-
-GameAction_clean = _tml.GameAction_clean
-
-GameAction_add_system = _tml.GameAction_add_system
-
-GameAction_add_planet = _tml.GameAction_add_planet
-
-GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
-
-GameAction_add_asteroid = _tml.GameAction_add_asteroid
-
-GameAction_add_player = _tml.GameAction_add_player
-
-GameAction_add_ship = _tml.GameAction_add_ship
-
-GameAction_get_string_flag = _tml.GameAction_get_string_flag
-
-GameAction_save_flag = _tml.GameAction_save_flag
-
-GameAction_get_double_flag = _tml.GameAction_get_double_flag
-
-GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
-
-GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
-
-GameAction_set_target = _tml.GameAction_set_target
-
-GameAction_disable_weapon = _tml.GameAction_disable_weapon
-
-GameAction_enable_weapon = _tml.GameAction_enable_weapon
-
-GameAction_go_to_point = _tml.GameAction_go_to_point
-
-GameAction_go_to_location = _tml.GameAction_go_to_location
-
-GameAction_guard_location = _tml.GameAction_guard_location
-
-GameAction_guard_point = _tml.GameAction_guard_point
-
-GameAction_set_ship_team = _tml.GameAction_set_ship_team
-
-GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
-
-GameAction_get_player_team = _tml.GameAction_get_player_team
-
-GameAction_remove_location = _tml.GameAction_remove_location
-
-GameAction_set_crew = _tml.GameAction_set_crew
-
-GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
-
-GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
-
-GameAction_exist = _tml.GameAction_exist
-
-GameAction_end_game = _tml.GameAction_end_game
-
-GameAction_scroll_text = _tml.GameAction_scroll_text
-
-GameAction_print_message = _tml.GameAction_print_message
-
-GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
-
-class DialogApi(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ DialogApi instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;startDialog&quot;] = lambda x: _tml.DialogApi_startDialog
-    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
-    __swig_getmethods__[&quot;endDialog&quot;] = lambda x: _tml.DialogApi_endDialog
-    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
-    __swig_getmethods__[&quot;askPlayer&quot;] = lambda x: _tml.DialogApi_askPlayer
-    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
-    __swig_getmethods__[&quot;showText&quot;] = lambda x: _tml.DialogApi_showText
-    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
-    __swig_getmethods__[&quot;showAlienPicture&quot;] = lambda x: _tml.DialogApi_showAlienPicture
-    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
-    def __init__(self, *args):
-        _swig_setattr(self, DialogApi, 'this', _tml.new_DialogApi(*args))
-        _swig_setattr(self, DialogApi, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_DialogApi):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class DialogApiPtr(DialogApi):
-    def __init__(self, this):
-        _swig_setattr(self, DialogApi, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, DialogApi, 'thisown', 0)
-        _swig_setattr(self, DialogApi,self.__class__,DialogApi)
-_tml.DialogApi_swigregister(DialogApiPtr)
-
-DialogApi_startDialog = _tml.DialogApi_startDialog
-
-DialogApi_endDialog = _tml.DialogApi_endDialog
-
-DialogApi_askPlayer = _tml.DialogApi_askPlayer
-
-DialogApi_showText = _tml.DialogApi_showText
-
-DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
-
-class GameConfig(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ GameConfig instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;SetGameDirectory&quot;] = lambda x: _tml.GameConfig_SetGameDirectory
-    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
-    __swig_getmethods__[&quot;GetGameDirectory&quot;] = lambda x: _tml.GameConfig_GetGameDirectory
-    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
-    __swig_getmethods__[&quot;GetAbsolutePath&quot;] = lambda x: _tml.GameConfig_GetAbsolutePath
-    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
-    def __init__(self, *args):
-        _swig_setattr(self, GameConfig, 'this', _tml.new_GameConfig(*args))
-        _swig_setattr(self, GameConfig, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameConfig):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameConfigPtr(GameConfig):
-    def __init__(self, this):
-        _swig_setattr(self, GameConfig, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GameConfig, 'thisown', 0)
-        _swig_setattr(self, GameConfig,self.__class__,GameConfig)
-_tml.GameConfig_swigregister(GameConfigPtr)
-
-GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
-
-GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
-
-GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
-
-class EventManager(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ EventManager instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.EventManager_clean
-    if _newclass:clean = staticmethod(_tml.EventManager_clean)
-    __swig_getmethods__[&quot;setSingleTimeEvent&quot;] = lambda x: _tml.EventManager_setSingleTimeEvent
-    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
-    __swig_getmethods__[&quot;setRepeatableTimeEvent&quot;] = lambda x: _tml.EventManager_setRepeatableTimeEvent
-    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
-    __swig_getmethods__[&quot;disableEvent&quot;] = lambda x: _tml.EventManager_disableEvent
-    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
-    __swig_getmethods__[&quot;shipDeathById&quot;] = lambda x: _tml.EventManager_shipDeathById
-    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
-    __swig_getmethods__[&quot;shipDeathByType&quot;] = lambda x: _tml.EventManager_shipDeathByType
-    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
-    __swig_getmethods__[&quot;distanceMoreThen&quot;] = lambda x: _tml.EventManager_distanceMoreThen
-    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
-    __swig_getmethods__[&quot;distanceLessThen&quot;] = lambda x: _tml.EventManager_distanceLessThen
-    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
-    __swig_getmethods__[&quot;jumpToSystem&quot;] = lambda x: _tml.EventManager_jumpToSystem
-    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
-    __swig_getmethods__[&quot;AddEventCondition&quot;] = lambda x: _tml.EventManager_AddEventCondition
-    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
-    def __init__(self, *args):
-        _swig_setattr(self, EventManager, 'this', _tml.new_EventManager(*args))
-        _swig_setattr(self, EventManager, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_EventManager):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class EventManagerPtr(EventManager):
-    def __init__(self, this):
-        _swig_setattr(self, EventManager, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, EventManager, 'thisown', 0)
-        _swig_setattr(self, EventManager,self.__class__,EventManager)
-_tml.EventManager_swigregister(EventManagerPtr)
-
-EventManager_clean = _tml.EventManager_clean
-
-EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
-
-EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
-
-EventManager_disableEvent = _tml.EventManager_disableEvent
-
-EventManager_shipDeathById = _tml.EventManager_shipDeathById
-
-EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
-
-EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
-
-EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
-
-EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
-
-EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
-
-class SoundSystem(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ SoundSystem instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def __init__(self, *args):
-        _swig_setattr(self, SoundSystem, 'this', _tml.new_SoundSystem(*args))
-        _swig_setattr(self, SoundSystem, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_SoundSystem):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-    def play_music(*args): return _tml.SoundSystem_play_music(*args)
-    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
-    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
-    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
-    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
-    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
-    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
-    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
-    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
-
-class SoundSystemPtr(SoundSystem):
-    def __init__(self, this):
-        _swig_setattr(self, SoundSystem, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, SoundSystem, 'thisown', 0)
-        _swig_setattr(self, SoundSystem,self.__class__,SoundSystem)
-_tml.SoundSystem_swigregister(SoundSystemPtr)
-
-
-GetSoundSystem = _tml.GetSoundSystem
-class vectorString(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ std::vector&lt;std::string &gt; instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def empty(*args): return _tml.vectorString_empty(*args)
-    def size(*args): return _tml.vectorString_size(*args)
-    def clear(*args): return _tml.vectorString_clear(*args)
-    def swap(*args): return _tml.vectorString_swap(*args)
-    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
-    def pop_back(*args): return _tml.vectorString_pop_back(*args)
-    def __init__(self, *args):
-        _swig_setattr(self, vectorString, 'this', _tml.new_vectorString(*args))
-        _swig_setattr(self, vectorString, 'thisown', 1)
-    def push_back(*args): return _tml.vectorString_push_back(*args)
-    def front(*args): return _tml.vectorString_front(*args)
-    def back(*args): return _tml.vectorString_back(*args)
-    def assign(*args): return _tml.vectorString_assign(*args)
-    def resize(*args): return _tml.vectorString_resize(*args)
-    def reserve(*args): return _tml.vectorString_reserve(*args)
-    def capacity(*args): return _tml.vectorString_capacity(*args)
-    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
-    def __len__(*args): return _tml.vectorString___len__(*args)
-    def pop(*args): return _tml.vectorString_pop(*args)
-    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
-    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
-    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
-    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
-    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
-    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
-    def append(*args): return _tml.vectorString_append(*args)
-    def __del__(self, destroy=_tml.delete_vectorString):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class vectorStringPtr(vectorString):
-    def __init__(self, this):
-        _swig_setattr(self, vectorString, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, vectorString, 'thisown', 0)
-        _swig_setattr(self, vectorString,self.__class__,vectorString)
-_tml.vectorString_swigregister(vectorStringPtr)
-cvar = _tml.cvar
-
-
+# This file was created automatically by SWIG 1.3.29.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _tml
+import new
+new_instancemethod = new.instancemethod
+def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
+    if (name == &quot;thisown&quot;): return self.this.own(value)
+    if (name == &quot;this&quot;):
+        if type(value).__name__ == 'PySwigObject':
+            self.__dict__[name] = value
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    if (not static) or hasattr(self,name):
+        self.__dict__[name] = value
+    else:
+        raise AttributeError(&quot;You cannot add attributes to %s&quot; % self)
+
+def _swig_setattr(self,class_type,name,value):
+    return _swig_setattr_nondynamic(self,class_type,name,value,0)
+
+def _swig_getattr(self,class_type,name):
+    if (name == &quot;thisown&quot;): return self.this.own()
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+def _swig_repr(self):
+    try: strthis = &quot;proxy of &quot; + self.this.__repr__()
+    except: strthis = &quot;&quot;
+    return &quot;&lt;%s.%s; %s &gt;&quot; % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class GameAction(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.GameAction_clean
+    if _newclass:clean = staticmethod(_tml.GameAction_clean)
+    __swig_getmethods__[&quot;add_system&quot;] = lambda x: _tml.GameAction_add_system
+    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
+    __swig_getmethods__[&quot;add_planet&quot;] = lambda x: _tml.GameAction_add_planet
+    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
+    __swig_getmethods__[&quot;add_orbiter_station&quot;] = lambda x: _tml.GameAction_add_orbiter_station
+    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
+    __swig_getmethods__[&quot;add_asteroid&quot;] = lambda x: _tml.GameAction_add_asteroid
+    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
+    __swig_getmethods__[&quot;add_player&quot;] = lambda x: _tml.GameAction_add_player
+    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
+    __swig_getmethods__[&quot;add_ship&quot;] = lambda x: _tml.GameAction_add_ship
+    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
+    __swig_getmethods__[&quot;get_string_flag&quot;] = lambda x: _tml.GameAction_get_string_flag
+    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
+    __swig_getmethods__[&quot;save_flag&quot;] = lambda x: _tml.GameAction_save_flag
+    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
+    __swig_getmethods__[&quot;get_double_flag&quot;] = lambda x: _tml.GameAction_get_double_flag
+    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
+    __swig_getmethods__[&quot;get_player_ship_id&quot;] = lambda x: _tml.GameAction_get_player_ship_id
+    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
+    __swig_getmethods__[&quot;get_player_star_system&quot;] = lambda x: _tml.GameAction_get_player_star_system
+    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
+    __swig_getmethods__[&quot;set_target&quot;] = lambda x: _tml.GameAction_set_target
+    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
+    __swig_getmethods__[&quot;disable_weapon&quot;] = lambda x: _tml.GameAction_disable_weapon
+    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
+    __swig_getmethods__[&quot;enable_weapon&quot;] = lambda x: _tml.GameAction_enable_weapon
+    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
+    __swig_getmethods__[&quot;go_to_point&quot;] = lambda x: _tml.GameAction_go_to_point
+    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
+    __swig_getmethods__[&quot;go_to_location&quot;] = lambda x: _tml.GameAction_go_to_location
+    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
+    __swig_getmethods__[&quot;guard_location&quot;] = lambda x: _tml.GameAction_guard_location
+    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
+    __swig_getmethods__[&quot;guard_point&quot;] = lambda x: _tml.GameAction_guard_point
+    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
+    __swig_getmethods__[&quot;set_ship_team&quot;] = lambda x: _tml.GameAction_set_ship_team
+    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
+    __swig_getmethods__[&quot;get_enemy_team&quot;] = lambda x: _tml.GameAction_get_enemy_team
+    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
+    __swig_getmethods__[&quot;get_player_team&quot;] = lambda x: _tml.GameAction_get_player_team
+    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
+    __swig_getmethods__[&quot;remove_location&quot;] = lambda x: _tml.GameAction_remove_location
+    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
+    __swig_getmethods__[&quot;set_crew&quot;] = lambda x: _tml.GameAction_set_crew
+    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
+    __swig_getmethods__[&quot;get_location_pos_x&quot;] = lambda x: _tml.GameAction_get_location_pos_x
+    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
+    __swig_getmethods__[&quot;get_location_pos_y&quot;] = lambda x: _tml.GameAction_get_location_pos_y
+    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
+    __swig_getmethods__[&quot;exist&quot;] = lambda x: _tml.GameAction_exist
+    if _newclass:exist = staticmethod(_tml.GameAction_exist)
+    __swig_getmethods__[&quot;end_game&quot;] = lambda x: _tml.GameAction_end_game
+    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
+    __swig_getmethods__[&quot;scroll_text&quot;] = lambda x: _tml.GameAction_scroll_text
+    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
+    __swig_getmethods__[&quot;print_message&quot;] = lambda x: _tml.GameAction_print_message
+    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
+    __swig_getmethods__[&quot;set_camera_mode&quot;] = lambda x: _tml.GameAction_set_camera_mode
+    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
+    def __init__(self, *args): 
+        this = _tml.new_GameAction(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameAction
+    __del__ = lambda self : None;
+GameAction_swigregister = _tml.GameAction_swigregister
+GameAction_swigregister(GameAction)
+GameAction_clean = _tml.GameAction_clean
+GameAction_add_system = _tml.GameAction_add_system
+GameAction_add_planet = _tml.GameAction_add_planet
+GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
+GameAction_add_asteroid = _tml.GameAction_add_asteroid
+GameAction_add_player = _tml.GameAction_add_player
+GameAction_add_ship = _tml.GameAction_add_ship
+GameAction_get_string_flag = _tml.GameAction_get_string_flag
+GameAction_save_flag = _tml.GameAction_save_flag
+GameAction_get_double_flag = _tml.GameAction_get_double_flag
+GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
+GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
+GameAction_set_target = _tml.GameAction_set_target
+GameAction_disable_weapon = _tml.GameAction_disable_weapon
+GameAction_enable_weapon = _tml.GameAction_enable_weapon
+GameAction_go_to_point = _tml.GameAction_go_to_point
+GameAction_go_to_location = _tml.GameAction_go_to_location
+GameAction_guard_location = _tml.GameAction_guard_location
+GameAction_guard_point = _tml.GameAction_guard_point
+GameAction_set_ship_team = _tml.GameAction_set_ship_team
+GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
+GameAction_get_player_team = _tml.GameAction_get_player_team
+GameAction_remove_location = _tml.GameAction_remove_location
+GameAction_set_crew = _tml.GameAction_set_crew
+GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
+GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
+GameAction_exist = _tml.GameAction_exist
+GameAction_end_game = _tml.GameAction_end_game
+GameAction_scroll_text = _tml.GameAction_scroll_text
+GameAction_print_message = _tml.GameAction_print_message
+GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
+
+class DialogApi(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;startDialog&quot;] = lambda x: _tml.DialogApi_startDialog
+    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
+    __swig_getmethods__[&quot;endDialog&quot;] = lambda x: _tml.DialogApi_endDialog
+    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
+    __swig_getmethods__[&quot;askPlayer&quot;] = lambda x: _tml.DialogApi_askPlayer
+    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
+    __swig_getmethods__[&quot;showText&quot;] = lambda x: _tml.DialogApi_showText
+    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
+    __swig_getmethods__[&quot;showAlienPicture&quot;] = lambda x: _tml.DialogApi_showAlienPicture
+    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
+    def __init__(self, *args): 
+        this = _tml.new_DialogApi(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_DialogApi
+    __del__ = lambda self : None;
+DialogApi_swigregister = _tml.DialogApi_swigregister
+DialogApi_swigregister(DialogApi)
+DialogApi_startDialog = _tml.DialogApi_startDialog
+DialogApi_endDialog = _tml.DialogApi_endDialog
+DialogApi_askPlayer = _tml.DialogApi_askPlayer
+DialogApi_showText = _tml.DialogApi_showText
+DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
+
+class GameConfig(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;SetGameDirectory&quot;] = lambda x: _tml.GameConfig_SetGameDirectory
+    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
+    __swig_getmethods__[&quot;GetGameDirectory&quot;] = lambda x: _tml.GameConfig_GetGameDirectory
+    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
+    __swig_getmethods__[&quot;GetAbsolutePath&quot;] = lambda x: _tml.GameConfig_GetAbsolutePath
+    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
+    def __init__(self, *args): 
+        this = _tml.new_GameConfig(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameConfig
+    __del__ = lambda self : None;
+GameConfig_swigregister = _tml.GameConfig_swigregister
+GameConfig_swigregister(GameConfig)
+GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
+GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
+GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
+
+class EventManager(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.EventManager_clean
+    if _newclass:clean = staticmethod(_tml.EventManager_clean)
+    __swig_getmethods__[&quot;setSingleTimeEvent&quot;] = lambda x: _tml.EventManager_setSingleTimeEvent
+    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
+    __swig_getmethods__[&quot;setRepeatableTimeEvent&quot;] = lambda x: _tml.EventManager_setRepeatableTimeEvent
+    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
+    __swig_getmethods__[&quot;disableEvent&quot;] = lambda x: _tml.EventManager_disableEvent
+    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
+    __swig_getmethods__[&quot;shipDeathById&quot;] = lambda x: _tml.EventManager_shipDeathById
+    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
+    __swig_getmethods__[&quot;shipDeathByType&quot;] = lambda x: _tml.EventManager_shipDeathByType
+    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
+    __swig_getmethods__[&quot;distanceMoreThen&quot;] = lambda x: _tml.EventManager_distanceMoreThen
+    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
+    __swig_getmethods__[&quot;distanceLessThen&quot;] = lambda x: _tml.EventManager_distanceLessThen
+    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
+    __swig_getmethods__[&quot;jumpToSystem&quot;] = lambda x: _tml.EventManager_jumpToSystem
+    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
+    __swig_getmethods__[&quot;AddEventCondition&quot;] = lambda x: _tml.EventManager_AddEventCondition
+    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
+    def __init__(self, *args): 
+        this = _tml.new_EventManager(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_EventManager
+    __del__ = lambda self : None;
+EventManager_swigregister = _tml.EventManager_swigregister
+EventManager_swigregister(EventManager)
+EventManager_clean = _tml.EventManager_clean
+EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
+EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
+EventManager_disableEvent = _tml.EventManager_disableEvent
+EventManager_shipDeathById = _tml.EventManager_shipDeathById
+EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
+EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
+EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
+EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
+EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
+
+class SoundSystem(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
+    __repr__ = _swig_repr
+    def __init__(self, *args): 
+        this = _tml.new_SoundSystem(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_SoundSystem
+    __del__ = lambda self : None;
+    def play_music(*args): return _tml.SoundSystem_play_music(*args)
+    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
+    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
+    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
+    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
+    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
+    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
+    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
+    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
+SoundSystem_swigregister = _tml.SoundSystem_swigregister
+SoundSystem_swigregister(SoundSystem)
+
+GetSoundSystem = _tml.GetSoundSystem
+class PySwigIterator(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
+    def __init__(self): raise AttributeError, &quot;No constructor defined&quot;
+    __repr__ = _swig_repr
+    __swig_destroy__ = _tml.delete_PySwigIterator
+    __del__ = lambda self : None;
+    def value(*args): return _tml.PySwigIterator_value(*args)
+    def incr(*args): return _tml.PySwigIterator_incr(*args)
+    def decr(*args): return _tml.PySwigIterator_decr(*args)
+    def distance(*args): return _tml.PySwigIterator_distance(*args)
+    def equal(*args): return _tml.PySwigIterator_equal(*args)
+    def copy(*args): return _tml.PySwigIterator_copy(*args)
+    def next(*args): return _tml.PySwigIterator_next(*args)
+    def previous(*args): return _tml.PySwigIterator_previous(*args)
+    def advance(*args): return _tml.PySwigIterator_advance(*args)
+    def __eq__(*args): return _tml.PySwigIterator___eq__(*args)
+    def __ne__(*args): return _tml.PySwigIterator___ne__(*args)
+    def __iadd__(*args): return _tml.PySwigIterator___iadd__(*args)
+    def __isub__(*args): return _tml.PySwigIterator___isub__(*args)
+    def __add__(*args): return _tml.PySwigIterator___add__(*args)
+    def __sub__(*args): return _tml.PySwigIterator___sub__(*args)
+    def __iter__(self): return self
+PySwigIterator_swigregister = _tml.PySwigIterator_swigregister
+PySwigIterator_swigregister(PySwigIterator)
+cvar = _tml.cvar
+
+class vectorString(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
+    __repr__ = _swig_repr
+    def iterator(*args): return _tml.vectorString_iterator(*args)
+    def __iter__(self): return self.iterator()
+    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
+    def __len__(*args): return _tml.vectorString___len__(*args)
+    def pop(*args): return _tml.vectorString_pop(*args)
+    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
+    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
+    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
+    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
+    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
+    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
+    def append(*args): return _tml.vectorString_append(*args)
+    def empty(*args): return _tml.vectorString_empty(*args)
+    def size(*args): return _tml.vectorString_size(*args)
+    def clear(*args): return _tml.vectorString_clear(*args)
+    def swap(*args): return _tml.vectorString_swap(*args)
+    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
+    def begin(*args): return _tml.vectorString_begin(*args)
+    def end(*args): return _tml.vectorString_end(*args)
+    def rbegin(*args): return _tml.vectorString_rbegin(*args)
+    def rend(*args): return _tml.vectorString_rend(*args)
+    def pop_back(*args): return _tml.vectorString_pop_back(*args)
+    def erase(*args): return _tml.vectorString_erase(*args)
+    def __init__(self, *args): 
+        this = _tml.new_vectorString(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    def push_back(*args): return _tml.vectorString_push_back(*args)
+    def front(*args): return _tml.vectorString_front(*args)
+    def back(*args): return _tml.vectorString_back(*args)
+    def assign(*args): return _tml.vectorString_assign(*args)
+    def resize(*args): return _tml.vectorString_resize(*args)
+    def insert(*args): return _tml.vectorString_insert(*args)
+    def reserve(*args): return _tml.vectorString_reserve(*args)
+    def capacity(*args): return _tml.vectorString_capacity(*args)
+    __swig_destroy__ = _tml.delete_vectorString
+    __del__ = lambda self : None;
+vectorString_swigregister = _tml.vectorString_swigregister
+vectorString_swigregister(vectorString)
+
+
+

Deleted: trunk/gamedata/stars.dat
===================================================================
(Binary files differ)

Modified: trunk/source/generated/tml.py
===================================================================
--- trunk/source/generated/tml.py	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/source/generated/tml.py	2006-05-08 11:32:42 UTC (rev 208)
@@ -1,408 +1,353 @@
-# This file was created automatically by SWIG.
-# Don't modify this file, modify the SWIG interface instead.
-# This file is compatible with both classic and new-style classes.
-
-import _tml
-
-def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
-    if (name == &quot;this&quot;):
-        if isinstance(value, class_type):
-            self.__dict__[name] = value.this
-            if hasattr(value,&quot;thisown&quot;): self.__dict__[&quot;thisown&quot;] = value.thisown
-            del value.thisown
-            return
-    method = class_type.__swig_setmethods__.get(name,None)
-    if method: return method(self,value)
-    if (not static) or hasattr(self,name) or (name == &quot;thisown&quot;):
-        self.__dict__[name] = value
-    else:
-        raise AttributeError(&quot;You cannot add attributes to %s&quot; % self)
-
-def _swig_setattr(self,class_type,name,value):
-    return _swig_setattr_nondynamic(self,class_type,name,value,0)
-
-def _swig_getattr(self,class_type,name):
-    method = class_type.__swig_getmethods__.get(name,None)
-    if method: return method(self)
-    raise AttributeError,name
-
-import types
-try:
-    _object = types.ObjectType
-    _newclass = 1
-except AttributeError:
-    class _object : pass
-    _newclass = 0
-del types
-
-
-class GameAction(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ GameAction instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.GameAction_clean
-    if _newclass:clean = staticmethod(_tml.GameAction_clean)
-    __swig_getmethods__[&quot;add_system&quot;] = lambda x: _tml.GameAction_add_system
-    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
-    __swig_getmethods__[&quot;add_planet&quot;] = lambda x: _tml.GameAction_add_planet
-    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
-    __swig_getmethods__[&quot;add_orbiter_station&quot;] = lambda x: _tml.GameAction_add_orbiter_station
-    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
-    __swig_getmethods__[&quot;add_asteroid&quot;] = lambda x: _tml.GameAction_add_asteroid
-    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
-    __swig_getmethods__[&quot;add_player&quot;] = lambda x: _tml.GameAction_add_player
-    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
-    __swig_getmethods__[&quot;add_ship&quot;] = lambda x: _tml.GameAction_add_ship
-    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
-    __swig_getmethods__[&quot;get_string_flag&quot;] = lambda x: _tml.GameAction_get_string_flag
-    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
-    __swig_getmethods__[&quot;save_flag&quot;] = lambda x: _tml.GameAction_save_flag
-    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
-    __swig_getmethods__[&quot;get_double_flag&quot;] = lambda x: _tml.GameAction_get_double_flag
-    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
-    __swig_getmethods__[&quot;get_player_ship_id&quot;] = lambda x: _tml.GameAction_get_player_ship_id
-    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
-    __swig_getmethods__[&quot;get_player_star_system&quot;] = lambda x: _tml.GameAction_get_player_star_system
-    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
-    __swig_getmethods__[&quot;set_target&quot;] = lambda x: _tml.GameAction_set_target
-    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
-    __swig_getmethods__[&quot;disable_weapon&quot;] = lambda x: _tml.GameAction_disable_weapon
-    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
-    __swig_getmethods__[&quot;enable_weapon&quot;] = lambda x: _tml.GameAction_enable_weapon
-    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
-    __swig_getmethods__[&quot;go_to_point&quot;] = lambda x: _tml.GameAction_go_to_point
-    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
-    __swig_getmethods__[&quot;go_to_location&quot;] = lambda x: _tml.GameAction_go_to_location
-    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
-    __swig_getmethods__[&quot;guard_location&quot;] = lambda x: _tml.GameAction_guard_location
-    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
-    __swig_getmethods__[&quot;guard_point&quot;] = lambda x: _tml.GameAction_guard_point
-    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
-    __swig_getmethods__[&quot;set_ship_team&quot;] = lambda x: _tml.GameAction_set_ship_team
-    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
-    __swig_getmethods__[&quot;get_enemy_team&quot;] = lambda x: _tml.GameAction_get_enemy_team
-    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
-    __swig_getmethods__[&quot;get_player_team&quot;] = lambda x: _tml.GameAction_get_player_team
-    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
-    __swig_getmethods__[&quot;remove_location&quot;] = lambda x: _tml.GameAction_remove_location
-    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
-    __swig_getmethods__[&quot;set_crew&quot;] = lambda x: _tml.GameAction_set_crew
-    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
-    __swig_getmethods__[&quot;get_location_pos_x&quot;] = lambda x: _tml.GameAction_get_location_pos_x
-    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
-    __swig_getmethods__[&quot;get_location_pos_y&quot;] = lambda x: _tml.GameAction_get_location_pos_y
-    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
-    __swig_getmethods__[&quot;exist&quot;] = lambda x: _tml.GameAction_exist
-    if _newclass:exist = staticmethod(_tml.GameAction_exist)
-    __swig_getmethods__[&quot;end_game&quot;] = lambda x: _tml.GameAction_end_game
-    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
-    __swig_getmethods__[&quot;scroll_text&quot;] = lambda x: _tml.GameAction_scroll_text
-    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
-    __swig_getmethods__[&quot;print_message&quot;] = lambda x: _tml.GameAction_print_message
-    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
-    __swig_getmethods__[&quot;set_camera_mode&quot;] = lambda x: _tml.GameAction_set_camera_mode
-    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
-    def __init__(self, *args):
-        _swig_setattr(self, GameAction, 'this', _tml.new_GameAction(*args))
-        _swig_setattr(self, GameAction, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameAction):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameActionPtr(GameAction):
-    def __init__(self, this):
-        _swig_setattr(self, GameAction, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GameAction, 'thisown', 0)
-        _swig_setattr(self, GameAction,self.__class__,GameAction)
-_tml.GameAction_swigregister(GameActionPtr)
-
-GameAction_clean = _tml.GameAction_clean
-
-GameAction_add_system = _tml.GameAction_add_system
-
-GameAction_add_planet = _tml.GameAction_add_planet
-
-GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
-
-GameAction_add_asteroid = _tml.GameAction_add_asteroid
-
-GameAction_add_player = _tml.GameAction_add_player
-
-GameAction_add_ship = _tml.GameAction_add_ship
-
-GameAction_get_string_flag = _tml.GameAction_get_string_flag
-
-GameAction_save_flag = _tml.GameAction_save_flag
-
-GameAction_get_double_flag = _tml.GameAction_get_double_flag
-
-GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
-
-GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
-
-GameAction_set_target = _tml.GameAction_set_target
-
-GameAction_disable_weapon = _tml.GameAction_disable_weapon
-
-GameAction_enable_weapon = _tml.GameAction_enable_weapon
-
-GameAction_go_to_point = _tml.GameAction_go_to_point
-
-GameAction_go_to_location = _tml.GameAction_go_to_location
-
-GameAction_guard_location = _tml.GameAction_guard_location
-
-GameAction_guard_point = _tml.GameAction_guard_point
-
-GameAction_set_ship_team = _tml.GameAction_set_ship_team
-
-GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
-
-GameAction_get_player_team = _tml.GameAction_get_player_team
-
-GameAction_remove_location = _tml.GameAction_remove_location
-
-GameAction_set_crew = _tml.GameAction_set_crew
-
-GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
-
-GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
-
-GameAction_exist = _tml.GameAction_exist
-
-GameAction_end_game = _tml.GameAction_end_game
-
-GameAction_scroll_text = _tml.GameAction_scroll_text
-
-GameAction_print_message = _tml.GameAction_print_message
-
-GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
-
-class DialogApi(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ DialogApi instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;startDialog&quot;] = lambda x: _tml.DialogApi_startDialog
-    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
-    __swig_getmethods__[&quot;endDialog&quot;] = lambda x: _tml.DialogApi_endDialog
-    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
-    __swig_getmethods__[&quot;askPlayer&quot;] = lambda x: _tml.DialogApi_askPlayer
-    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
-    __swig_getmethods__[&quot;showText&quot;] = lambda x: _tml.DialogApi_showText
-    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
-    __swig_getmethods__[&quot;showAlienPicture&quot;] = lambda x: _tml.DialogApi_showAlienPicture
-    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
-    def __init__(self, *args):
-        _swig_setattr(self, DialogApi, 'this', _tml.new_DialogApi(*args))
-        _swig_setattr(self, DialogApi, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_DialogApi):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class DialogApiPtr(DialogApi):
-    def __init__(self, this):
-        _swig_setattr(self, DialogApi, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, DialogApi, 'thisown', 0)
-        _swig_setattr(self, DialogApi,self.__class__,DialogApi)
-_tml.DialogApi_swigregister(DialogApiPtr)
-
-DialogApi_startDialog = _tml.DialogApi_startDialog
-
-DialogApi_endDialog = _tml.DialogApi_endDialog
-
-DialogApi_askPlayer = _tml.DialogApi_askPlayer
-
-DialogApi_showText = _tml.DialogApi_showText
-
-DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
-
-class GameConfig(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ GameConfig instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;SetGameDirectory&quot;] = lambda x: _tml.GameConfig_SetGameDirectory
-    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
-    __swig_getmethods__[&quot;GetGameDirectory&quot;] = lambda x: _tml.GameConfig_GetGameDirectory
-    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
-    __swig_getmethods__[&quot;GetAbsolutePath&quot;] = lambda x: _tml.GameConfig_GetAbsolutePath
-    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
-    def __init__(self, *args):
-        _swig_setattr(self, GameConfig, 'this', _tml.new_GameConfig(*args))
-        _swig_setattr(self, GameConfig, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_GameConfig):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class GameConfigPtr(GameConfig):
-    def __init__(self, this):
-        _swig_setattr(self, GameConfig, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, GameConfig, 'thisown', 0)
-        _swig_setattr(self, GameConfig,self.__class__,GameConfig)
-_tml.GameConfig_swigregister(GameConfigPtr)
-
-GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
-
-GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
-
-GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
-
-class EventManager(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ EventManager instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.EventManager_clean
-    if _newclass:clean = staticmethod(_tml.EventManager_clean)
-    __swig_getmethods__[&quot;setSingleTimeEvent&quot;] = lambda x: _tml.EventManager_setSingleTimeEvent
-    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
-    __swig_getmethods__[&quot;setRepeatableTimeEvent&quot;] = lambda x: _tml.EventManager_setRepeatableTimeEvent
-    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
-    __swig_getmethods__[&quot;disableEvent&quot;] = lambda x: _tml.EventManager_disableEvent
-    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
-    __swig_getmethods__[&quot;shipDeathById&quot;] = lambda x: _tml.EventManager_shipDeathById
-    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
-    __swig_getmethods__[&quot;shipDeathByType&quot;] = lambda x: _tml.EventManager_shipDeathByType
-    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
-    __swig_getmethods__[&quot;distanceMoreThen&quot;] = lambda x: _tml.EventManager_distanceMoreThen
-    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
-    __swig_getmethods__[&quot;distanceLessThen&quot;] = lambda x: _tml.EventManager_distanceLessThen
-    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
-    __swig_getmethods__[&quot;jumpToSystem&quot;] = lambda x: _tml.EventManager_jumpToSystem
-    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
-    __swig_getmethods__[&quot;AddEventCondition&quot;] = lambda x: _tml.EventManager_AddEventCondition
-    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
-    def __init__(self, *args):
-        _swig_setattr(self, EventManager, 'this', _tml.new_EventManager(*args))
-        _swig_setattr(self, EventManager, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_EventManager):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class EventManagerPtr(EventManager):
-    def __init__(self, this):
-        _swig_setattr(self, EventManager, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, EventManager, 'thisown', 0)
-        _swig_setattr(self, EventManager,self.__class__,EventManager)
-_tml.EventManager_swigregister(EventManagerPtr)
-
-EventManager_clean = _tml.EventManager_clean
-
-EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
-
-EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
-
-EventManager_disableEvent = _tml.EventManager_disableEvent
-
-EventManager_shipDeathById = _tml.EventManager_shipDeathById
-
-EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
-
-EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
-
-EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
-
-EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
-
-EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
-
-class SoundSystem(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ SoundSystem instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def __init__(self, *args):
-        _swig_setattr(self, SoundSystem, 'this', _tml.new_SoundSystem(*args))
-        _swig_setattr(self, SoundSystem, 'thisown', 1)
-    def __del__(self, destroy=_tml.delete_SoundSystem):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-    def play_music(*args): return _tml.SoundSystem_play_music(*args)
-    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
-    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
-    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
-    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
-    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
-    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
-    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
-    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
-
-class SoundSystemPtr(SoundSystem):
-    def __init__(self, this):
-        _swig_setattr(self, SoundSystem, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, SoundSystem, 'thisown', 0)
-        _swig_setattr(self, SoundSystem,self.__class__,SoundSystem)
-_tml.SoundSystem_swigregister(SoundSystemPtr)
-
-
-GetSoundSystem = _tml.GetSoundSystem
-class vectorString(_object):
-    __swig_setmethods__ = {}
-    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
-    __swig_getmethods__ = {}
-    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
-    def __repr__(self):
-        return &quot;&lt;%s.%s; proxy of C++ std::vector&lt;std::string &gt; instance at %s&gt;&quot; % (self.__class__.__module__, self.__class__.__name__, self.this,)
-    def empty(*args): return _tml.vectorString_empty(*args)
-    def size(*args): return _tml.vectorString_size(*args)
-    def clear(*args): return _tml.vectorString_clear(*args)
-    def swap(*args): return _tml.vectorString_swap(*args)
-    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
-    def pop_back(*args): return _tml.vectorString_pop_back(*args)
-    def __init__(self, *args):
-        _swig_setattr(self, vectorString, 'this', _tml.new_vectorString(*args))
-        _swig_setattr(self, vectorString, 'thisown', 1)
-    def push_back(*args): return _tml.vectorString_push_back(*args)
-    def front(*args): return _tml.vectorString_front(*args)
-    def back(*args): return _tml.vectorString_back(*args)
-    def assign(*args): return _tml.vectorString_assign(*args)
-    def resize(*args): return _tml.vectorString_resize(*args)
-    def reserve(*args): return _tml.vectorString_reserve(*args)
-    def capacity(*args): return _tml.vectorString_capacity(*args)
-    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
-    def __len__(*args): return _tml.vectorString___len__(*args)
-    def pop(*args): return _tml.vectorString_pop(*args)
-    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
-    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
-    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
-    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
-    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
-    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
-    def append(*args): return _tml.vectorString_append(*args)
-    def __del__(self, destroy=_tml.delete_vectorString):
-        try:
-            if self.thisown: destroy(self)
-        except: pass
-
-
-class vectorStringPtr(vectorString):
-    def __init__(self, this):
-        _swig_setattr(self, vectorString, 'this', this)
-        if not hasattr(self,&quot;thisown&quot;): _swig_setattr(self, vectorString, 'thisown', 0)
-        _swig_setattr(self, vectorString,self.__class__,vectorString)
-_tml.vectorString_swigregister(vectorStringPtr)
-cvar = _tml.cvar
-
-
+# This file was created automatically by SWIG 1.3.29.
+# Don't modify this file, modify the SWIG interface instead.
+# This file is compatible with both classic and new-style classes.
+
+import _tml
+import new
+new_instancemethod = new.instancemethod
+def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
+    if (name == &quot;thisown&quot;): return self.this.own(value)
+    if (name == &quot;this&quot;):
+        if type(value).__name__ == 'PySwigObject':
+            self.__dict__[name] = value
+            return
+    method = class_type.__swig_setmethods__.get(name,None)
+    if method: return method(self,value)
+    if (not static) or hasattr(self,name):
+        self.__dict__[name] = value
+    else:
+        raise AttributeError(&quot;You cannot add attributes to %s&quot; % self)
+
+def _swig_setattr(self,class_type,name,value):
+    return _swig_setattr_nondynamic(self,class_type,name,value,0)
+
+def _swig_getattr(self,class_type,name):
+    if (name == &quot;thisown&quot;): return self.this.own()
+    method = class_type.__swig_getmethods__.get(name,None)
+    if method: return method(self)
+    raise AttributeError,name
+
+def _swig_repr(self):
+    try: strthis = &quot;proxy of &quot; + self.this.__repr__()
+    except: strthis = &quot;&quot;
+    return &quot;&lt;%s.%s; %s &gt;&quot; % (self.__class__.__module__, self.__class__.__name__, strthis,)
+
+import types
+try:
+    _object = types.ObjectType
+    _newclass = 1
+except AttributeError:
+    class _object : pass
+    _newclass = 0
+del types
+
+
+class GameAction(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameAction, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameAction, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.GameAction_clean
+    if _newclass:clean = staticmethod(_tml.GameAction_clean)
+    __swig_getmethods__[&quot;add_system&quot;] = lambda x: _tml.GameAction_add_system
+    if _newclass:add_system = staticmethod(_tml.GameAction_add_system)
+    __swig_getmethods__[&quot;add_planet&quot;] = lambda x: _tml.GameAction_add_planet
+    if _newclass:add_planet = staticmethod(_tml.GameAction_add_planet)
+    __swig_getmethods__[&quot;add_orbiter_station&quot;] = lambda x: _tml.GameAction_add_orbiter_station
+    if _newclass:add_orbiter_station = staticmethod(_tml.GameAction_add_orbiter_station)
+    __swig_getmethods__[&quot;add_asteroid&quot;] = lambda x: _tml.GameAction_add_asteroid
+    if _newclass:add_asteroid = staticmethod(_tml.GameAction_add_asteroid)
+    __swig_getmethods__[&quot;add_player&quot;] = lambda x: _tml.GameAction_add_player
+    if _newclass:add_player = staticmethod(_tml.GameAction_add_player)
+    __swig_getmethods__[&quot;add_ship&quot;] = lambda x: _tml.GameAction_add_ship
+    if _newclass:add_ship = staticmethod(_tml.GameAction_add_ship)
+    __swig_getmethods__[&quot;get_string_flag&quot;] = lambda x: _tml.GameAction_get_string_flag
+    if _newclass:get_string_flag = staticmethod(_tml.GameAction_get_string_flag)
+    __swig_getmethods__[&quot;save_flag&quot;] = lambda x: _tml.GameAction_save_flag
+    if _newclass:save_flag = staticmethod(_tml.GameAction_save_flag)
+    __swig_getmethods__[&quot;get_double_flag&quot;] = lambda x: _tml.GameAction_get_double_flag
+    if _newclass:get_double_flag = staticmethod(_tml.GameAction_get_double_flag)
+    __swig_getmethods__[&quot;get_player_ship_id&quot;] = lambda x: _tml.GameAction_get_player_ship_id
+    if _newclass:get_player_ship_id = staticmethod(_tml.GameAction_get_player_ship_id)
+    __swig_getmethods__[&quot;get_player_star_system&quot;] = lambda x: _tml.GameAction_get_player_star_system
+    if _newclass:get_player_star_system = staticmethod(_tml.GameAction_get_player_star_system)
+    __swig_getmethods__[&quot;set_target&quot;] = lambda x: _tml.GameAction_set_target
+    if _newclass:set_target = staticmethod(_tml.GameAction_set_target)
+    __swig_getmethods__[&quot;disable_weapon&quot;] = lambda x: _tml.GameAction_disable_weapon
+    if _newclass:disable_weapon = staticmethod(_tml.GameAction_disable_weapon)
+    __swig_getmethods__[&quot;enable_weapon&quot;] = lambda x: _tml.GameAction_enable_weapon
+    if _newclass:enable_weapon = staticmethod(_tml.GameAction_enable_weapon)
+    __swig_getmethods__[&quot;go_to_point&quot;] = lambda x: _tml.GameAction_go_to_point
+    if _newclass:go_to_point = staticmethod(_tml.GameAction_go_to_point)
+    __swig_getmethods__[&quot;go_to_location&quot;] = lambda x: _tml.GameAction_go_to_location
+    if _newclass:go_to_location = staticmethod(_tml.GameAction_go_to_location)
+    __swig_getmethods__[&quot;guard_location&quot;] = lambda x: _tml.GameAction_guard_location
+    if _newclass:guard_location = staticmethod(_tml.GameAction_guard_location)
+    __swig_getmethods__[&quot;guard_point&quot;] = lambda x: _tml.GameAction_guard_point
+    if _newclass:guard_point = staticmethod(_tml.GameAction_guard_point)
+    __swig_getmethods__[&quot;set_ship_team&quot;] = lambda x: _tml.GameAction_set_ship_team
+    if _newclass:set_ship_team = staticmethod(_tml.GameAction_set_ship_team)
+    __swig_getmethods__[&quot;get_enemy_team&quot;] = lambda x: _tml.GameAction_get_enemy_team
+    if _newclass:get_enemy_team = staticmethod(_tml.GameAction_get_enemy_team)
+    __swig_getmethods__[&quot;get_player_team&quot;] = lambda x: _tml.GameAction_get_player_team
+    if _newclass:get_player_team = staticmethod(_tml.GameAction_get_player_team)
+    __swig_getmethods__[&quot;remove_location&quot;] = lambda x: _tml.GameAction_remove_location
+    if _newclass:remove_location = staticmethod(_tml.GameAction_remove_location)
+    __swig_getmethods__[&quot;set_crew&quot;] = lambda x: _tml.GameAction_set_crew
+    if _newclass:set_crew = staticmethod(_tml.GameAction_set_crew)
+    __swig_getmethods__[&quot;get_location_pos_x&quot;] = lambda x: _tml.GameAction_get_location_pos_x
+    if _newclass:get_location_pos_x = staticmethod(_tml.GameAction_get_location_pos_x)
+    __swig_getmethods__[&quot;get_location_pos_y&quot;] = lambda x: _tml.GameAction_get_location_pos_y
+    if _newclass:get_location_pos_y = staticmethod(_tml.GameAction_get_location_pos_y)
+    __swig_getmethods__[&quot;exist&quot;] = lambda x: _tml.GameAction_exist
+    if _newclass:exist = staticmethod(_tml.GameAction_exist)
+    __swig_getmethods__[&quot;end_game&quot;] = lambda x: _tml.GameAction_end_game
+    if _newclass:end_game = staticmethod(_tml.GameAction_end_game)
+    __swig_getmethods__[&quot;scroll_text&quot;] = lambda x: _tml.GameAction_scroll_text
+    if _newclass:scroll_text = staticmethod(_tml.GameAction_scroll_text)
+    __swig_getmethods__[&quot;print_message&quot;] = lambda x: _tml.GameAction_print_message
+    if _newclass:print_message = staticmethod(_tml.GameAction_print_message)
+    __swig_getmethods__[&quot;set_camera_mode&quot;] = lambda x: _tml.GameAction_set_camera_mode
+    if _newclass:set_camera_mode = staticmethod(_tml.GameAction_set_camera_mode)
+    def __init__(self, *args): 
+        this = _tml.new_GameAction(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameAction
+    __del__ = lambda self : None;
+GameAction_swigregister = _tml.GameAction_swigregister
+GameAction_swigregister(GameAction)
+GameAction_clean = _tml.GameAction_clean
+GameAction_add_system = _tml.GameAction_add_system
+GameAction_add_planet = _tml.GameAction_add_planet
+GameAction_add_orbiter_station = _tml.GameAction_add_orbiter_station
+GameAction_add_asteroid = _tml.GameAction_add_asteroid
+GameAction_add_player = _tml.GameAction_add_player
+GameAction_add_ship = _tml.GameAction_add_ship
+GameAction_get_string_flag = _tml.GameAction_get_string_flag
+GameAction_save_flag = _tml.GameAction_save_flag
+GameAction_get_double_flag = _tml.GameAction_get_double_flag
+GameAction_get_player_ship_id = _tml.GameAction_get_player_ship_id
+GameAction_get_player_star_system = _tml.GameAction_get_player_star_system
+GameAction_set_target = _tml.GameAction_set_target
+GameAction_disable_weapon = _tml.GameAction_disable_weapon
+GameAction_enable_weapon = _tml.GameAction_enable_weapon
+GameAction_go_to_point = _tml.GameAction_go_to_point
+GameAction_go_to_location = _tml.GameAction_go_to_location
+GameAction_guard_location = _tml.GameAction_guard_location
+GameAction_guard_point = _tml.GameAction_guard_point
+GameAction_set_ship_team = _tml.GameAction_set_ship_team
+GameAction_get_enemy_team = _tml.GameAction_get_enemy_team
+GameAction_get_player_team = _tml.GameAction_get_player_team
+GameAction_remove_location = _tml.GameAction_remove_location
+GameAction_set_crew = _tml.GameAction_set_crew
+GameAction_get_location_pos_x = _tml.GameAction_get_location_pos_x
+GameAction_get_location_pos_y = _tml.GameAction_get_location_pos_y
+GameAction_exist = _tml.GameAction_exist
+GameAction_end_game = _tml.GameAction_end_game
+GameAction_scroll_text = _tml.GameAction_scroll_text
+GameAction_print_message = _tml.GameAction_print_message
+GameAction_set_camera_mode = _tml.GameAction_set_camera_mode
+
+class DialogApi(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, DialogApi, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, DialogApi, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;startDialog&quot;] = lambda x: _tml.DialogApi_startDialog
+    if _newclass:startDialog = staticmethod(_tml.DialogApi_startDialog)
+    __swig_getmethods__[&quot;endDialog&quot;] = lambda x: _tml.DialogApi_endDialog
+    if _newclass:endDialog = staticmethod(_tml.DialogApi_endDialog)
+    __swig_getmethods__[&quot;askPlayer&quot;] = lambda x: _tml.DialogApi_askPlayer
+    if _newclass:askPlayer = staticmethod(_tml.DialogApi_askPlayer)
+    __swig_getmethods__[&quot;showText&quot;] = lambda x: _tml.DialogApi_showText
+    if _newclass:showText = staticmethod(_tml.DialogApi_showText)
+    __swig_getmethods__[&quot;showAlienPicture&quot;] = lambda x: _tml.DialogApi_showAlienPicture
+    if _newclass:showAlienPicture = staticmethod(_tml.DialogApi_showAlienPicture)
+    def __init__(self, *args): 
+        this = _tml.new_DialogApi(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_DialogApi
+    __del__ = lambda self : None;
+DialogApi_swigregister = _tml.DialogApi_swigregister
+DialogApi_swigregister(DialogApi)
+DialogApi_startDialog = _tml.DialogApi_startDialog
+DialogApi_endDialog = _tml.DialogApi_endDialog
+DialogApi_askPlayer = _tml.DialogApi_askPlayer
+DialogApi_showText = _tml.DialogApi_showText
+DialogApi_showAlienPicture = _tml.DialogApi_showAlienPicture
+
+class GameConfig(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, GameConfig, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, GameConfig, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;SetGameDirectory&quot;] = lambda x: _tml.GameConfig_SetGameDirectory
+    if _newclass:SetGameDirectory = staticmethod(_tml.GameConfig_SetGameDirectory)
+    __swig_getmethods__[&quot;GetGameDirectory&quot;] = lambda x: _tml.GameConfig_GetGameDirectory
+    if _newclass:GetGameDirectory = staticmethod(_tml.GameConfig_GetGameDirectory)
+    __swig_getmethods__[&quot;GetAbsolutePath&quot;] = lambda x: _tml.GameConfig_GetAbsolutePath
+    if _newclass:GetAbsolutePath = staticmethod(_tml.GameConfig_GetAbsolutePath)
+    def __init__(self, *args): 
+        this = _tml.new_GameConfig(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_GameConfig
+    __del__ = lambda self : None;
+GameConfig_swigregister = _tml.GameConfig_swigregister
+GameConfig_swigregister(GameConfig)
+GameConfig_SetGameDirectory = _tml.GameConfig_SetGameDirectory
+GameConfig_GetGameDirectory = _tml.GameConfig_GetGameDirectory
+GameConfig_GetAbsolutePath = _tml.GameConfig_GetAbsolutePath
+
+class EventManager(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, EventManager, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, EventManager, name)
+    __repr__ = _swig_repr
+    __swig_getmethods__[&quot;clean&quot;] = lambda x: _tml.EventManager_clean
+    if _newclass:clean = staticmethod(_tml.EventManager_clean)
+    __swig_getmethods__[&quot;setSingleTimeEvent&quot;] = lambda x: _tml.EventManager_setSingleTimeEvent
+    if _newclass:setSingleTimeEvent = staticmethod(_tml.EventManager_setSingleTimeEvent)
+    __swig_getmethods__[&quot;setRepeatableTimeEvent&quot;] = lambda x: _tml.EventManager_setRepeatableTimeEvent
+    if _newclass:setRepeatableTimeEvent = staticmethod(_tml.EventManager_setRepeatableTimeEvent)
+    __swig_getmethods__[&quot;disableEvent&quot;] = lambda x: _tml.EventManager_disableEvent
+    if _newclass:disableEvent = staticmethod(_tml.EventManager_disableEvent)
+    __swig_getmethods__[&quot;shipDeathById&quot;] = lambda x: _tml.EventManager_shipDeathById
+    if _newclass:shipDeathById = staticmethod(_tml.EventManager_shipDeathById)
+    __swig_getmethods__[&quot;shipDeathByType&quot;] = lambda x: _tml.EventManager_shipDeathByType
+    if _newclass:shipDeathByType = staticmethod(_tml.EventManager_shipDeathByType)
+    __swig_getmethods__[&quot;distanceMoreThen&quot;] = lambda x: _tml.EventManager_distanceMoreThen
+    if _newclass:distanceMoreThen = staticmethod(_tml.EventManager_distanceMoreThen)
+    __swig_getmethods__[&quot;distanceLessThen&quot;] = lambda x: _tml.EventManager_distanceLessThen
+    if _newclass:distanceLessThen = staticmethod(_tml.EventManager_distanceLessThen)
+    __swig_getmethods__[&quot;jumpToSystem&quot;] = lambda x: _tml.EventManager_jumpToSystem
+    if _newclass:jumpToSystem = staticmethod(_tml.EventManager_jumpToSystem)
+    __swig_getmethods__[&quot;AddEventCondition&quot;] = lambda x: _tml.EventManager_AddEventCondition
+    if _newclass:AddEventCondition = staticmethod(_tml.EventManager_AddEventCondition)
+    def __init__(self, *args): 
+        this = _tml.new_EventManager(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_EventManager
+    __del__ = lambda self : None;
+EventManager_swigregister = _tml.EventManager_swigregister
+EventManager_swigregister(EventManager)
+EventManager_clean = _tml.EventManager_clean
+EventManager_setSingleTimeEvent = _tml.EventManager_setSingleTimeEvent
+EventManager_setRepeatableTimeEvent = _tml.EventManager_setRepeatableTimeEvent
+EventManager_disableEvent = _tml.EventManager_disableEvent
+EventManager_shipDeathById = _tml.EventManager_shipDeathById
+EventManager_shipDeathByType = _tml.EventManager_shipDeathByType
+EventManager_distanceMoreThen = _tml.EventManager_distanceMoreThen
+EventManager_distanceLessThen = _tml.EventManager_distanceLessThen
+EventManager_jumpToSystem = _tml.EventManager_jumpToSystem
+EventManager_AddEventCondition = _tml.EventManager_AddEventCondition
+
+class SoundSystem(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, SoundSystem, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, SoundSystem, name)
+    __repr__ = _swig_repr
+    def __init__(self, *args): 
+        this = _tml.new_SoundSystem(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    __swig_destroy__ = _tml.delete_SoundSystem
+    __del__ = lambda self : None;
+    def play_music(*args): return _tml.SoundSystem_play_music(*args)
+    def play_sound(*args): return _tml.SoundSystem_play_sound(*args)
+    def stop_sound(*args): return _tml.SoundSystem_stop_sound(*args)
+    def set_music_volume(*args): return _tml.SoundSystem_set_music_volume(*args)
+    def set_sound_volume(*args): return _tml.SoundSystem_set_sound_volume(*args)
+    def load_music_volume(*args): return _tml.SoundSystem_load_music_volume(*args)
+    def load_sound_volume(*args): return _tml.SoundSystem_load_sound_volume(*args)
+    def playing_music(*args): return _tml.SoundSystem_playing_music(*args)
+    def playing_music_file(*args): return _tml.SoundSystem_playing_music_file(*args)
+SoundSystem_swigregister = _tml.SoundSystem_swigregister
+SoundSystem_swigregister(SoundSystem)
+
+GetSoundSystem = _tml.GetSoundSystem
+class PySwigIterator(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
+    def __init__(self): raise AttributeError, &quot;No constructor defined&quot;
+    __repr__ = _swig_repr
+    __swig_destroy__ = _tml.delete_PySwigIterator
+    __del__ = lambda self : None;
+    def value(*args): return _tml.PySwigIterator_value(*args)
+    def incr(*args): return _tml.PySwigIterator_incr(*args)
+    def decr(*args): return _tml.PySwigIterator_decr(*args)
+    def distance(*args): return _tml.PySwigIterator_distance(*args)
+    def equal(*args): return _tml.PySwigIterator_equal(*args)
+    def copy(*args): return _tml.PySwigIterator_copy(*args)
+    def next(*args): return _tml.PySwigIterator_next(*args)
+    def previous(*args): return _tml.PySwigIterator_previous(*args)
+    def advance(*args): return _tml.PySwigIterator_advance(*args)
+    def __eq__(*args): return _tml.PySwigIterator___eq__(*args)
+    def __ne__(*args): return _tml.PySwigIterator___ne__(*args)
+    def __iadd__(*args): return _tml.PySwigIterator___iadd__(*args)
+    def __isub__(*args): return _tml.PySwigIterator___isub__(*args)
+    def __add__(*args): return _tml.PySwigIterator___add__(*args)
+    def __sub__(*args): return _tml.PySwigIterator___sub__(*args)
+    def __iter__(self): return self
+PySwigIterator_swigregister = _tml.PySwigIterator_swigregister
+PySwigIterator_swigregister(PySwigIterator)
+cvar = _tml.cvar
+
+class vectorString(_object):
+    __swig_setmethods__ = {}
+    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorString, name, value)
+    __swig_getmethods__ = {}
+    __getattr__ = lambda self, name: _swig_getattr(self, vectorString, name)
+    __repr__ = _swig_repr
+    def iterator(*args): return _tml.vectorString_iterator(*args)
+    def __iter__(self): return self.iterator()
+    def __nonzero__(*args): return _tml.vectorString___nonzero__(*args)
+    def __len__(*args): return _tml.vectorString___len__(*args)
+    def pop(*args): return _tml.vectorString_pop(*args)
+    def __getslice__(*args): return _tml.vectorString___getslice__(*args)
+    def __setslice__(*args): return _tml.vectorString___setslice__(*args)
+    def __delslice__(*args): return _tml.vectorString___delslice__(*args)
+    def __delitem__(*args): return _tml.vectorString___delitem__(*args)
+    def __getitem__(*args): return _tml.vectorString___getitem__(*args)
+    def __setitem__(*args): return _tml.vectorString___setitem__(*args)
+    def append(*args): return _tml.vectorString_append(*args)
+    def empty(*args): return _tml.vectorString_empty(*args)
+    def size(*args): return _tml.vectorString_size(*args)
+    def clear(*args): return _tml.vectorString_clear(*args)
+    def swap(*args): return _tml.vectorString_swap(*args)
+    def get_allocator(*args): return _tml.vectorString_get_allocator(*args)
+    def begin(*args): return _tml.vectorString_begin(*args)
+    def end(*args): return _tml.vectorString_end(*args)
+    def rbegin(*args): return _tml.vectorString_rbegin(*args)
+    def rend(*args): return _tml.vectorString_rend(*args)
+    def pop_back(*args): return _tml.vectorString_pop_back(*args)
+    def erase(*args): return _tml.vectorString_erase(*args)
+    def __init__(self, *args): 
+        this = _tml.new_vectorString(*args)
+        try: self.this.append(this)
+        except: self.this = this
+    def push_back(*args): return _tml.vectorString_push_back(*args)
+    def front(*args): return _tml.vectorString_front(*args)
+    def back(*args): return _tml.vectorString_back(*args)
+    def assign(*args): return _tml.vectorString_assign(*args)
+    def resize(*args): return _tml.vectorString_resize(*args)
+    def insert(*args): return _tml.vectorString_insert(*args)
+    def reserve(*args): return _tml.vectorString_reserve(*args)
+    def capacity(*args): return _tml.vectorString_capacity(*args)
+    __swig_destroy__ = _tml.delete_vectorString
+    __del__ = lambda self : None;
+vectorString_swigregister = _tml.vectorString_swigregister
+vectorString_swigregister(vectorString)
+
+
+

Modified: trunk/source/generated/tml_wrap.cpp
===================================================================
--- trunk/source/generated/tml_wrap.cpp	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/source/generated/tml_wrap.cpp	2006-05-08 11:32:42 UTC (rev 208)
@@ -1,7178 +1,10449 @@
-/* ----------------------------------------------------------------------------
- * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
- * Version 1.3.25
- * 
- * This file is not intended to be easily readable and contains a number of 
- * coding conventions designed to improve portability and efficiency. Do not make
- * changes to this file unless you know what you are doing--modify the SWIG 
- * interface file instead. 
- * ----------------------------------------------------------------------------- */
-
-#define SWIGPYTHON
-
-#ifdef __cplusplus
-template&lt;class T&gt; class SwigValueWrapper {
-    T *tt;
-public:
-    SwigValueWrapper() : tt(0) { }
-    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
-    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
-    ~SwigValueWrapper() { delete tt; } 
-    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
-    operator T&amp;() const { return *tt; }
-    T *operator&amp;() { return tt; }
-private:
-    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
-};
-#endif
-
-/***********************************************************************
- *
- *  This section contains generic SWIG labels for method/variable
- *  declarations/attributes, and other compiler dependent labels.
- *
- ************************************************************************/
-
-/* template workaround for compilers that cannot correctly implement the C++ standard */
-#ifndef SWIGTEMPLATEDISAMBIGUATOR
-#  if defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &lt;= 0x560)
-#    define SWIGTEMPLATEDISAMBIGUATOR template
-#  else
-#    define SWIGTEMPLATEDISAMBIGUATOR 
-#  endif
-#endif
-
-/* inline attribute */
-#ifndef SWIGINLINE
-# if defined(__cplusplus) || (defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__))
-#   define SWIGINLINE inline
-# else
-#   define SWIGINLINE
-# endif
-#endif
-
-/* attribute recognised by some compilers to avoid 'unused' warnings */
-#ifndef SWIGUNUSED
-# if defined(__GNUC__) || defined(__ICC)
-#   define SWIGUNUSED __attribute__ ((unused)) 
-# else
-#   define SWIGUNUSED 
-# endif
-#endif
-
-/* internal SWIG method */
-#ifndef SWIGINTERN
-# define SWIGINTERN static SWIGUNUSED
-#endif
-
-/* internal inline SWIG method */
-#ifndef SWIGINTERNINLINE
-# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/* exporting methods for Windows DLLs */
-#ifndef SWIGEXPORT
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   if defined(STATIC_LINKED)
-#     define SWIGEXPORT
-#   else
-#     define SWIGEXPORT __declspec(dllexport)
-#   endif
-# else
-#   define SWIGEXPORT
-# endif
-#endif
-
-/* calling conventions for Windows */
-#ifndef SWIGSTDCALL
-# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
-#   define SWIGSTDCALL __stdcall
-# else
-#   define SWIGSTDCALL
-# endif 
-#endif
-
-
-
-#include &lt;Python.h&gt;
-
-/***********************************************************************
- * swigrun.swg
- *
- *     This file contains generic CAPI SWIG runtime support for pointer
- *     type checking.
- *
- ************************************************************************/
-
-/* This should only be incremented when either the layout of swig_type_info changes,
-   or for whatever reason, the runtime changes incompatibly */
-#define SWIG_RUNTIME_VERSION &quot;2&quot;
-
-/* define SWIG_TYPE_TABLE_NAME as &quot;SWIG_TYPE_TABLE&quot; */
-#ifdef SWIG_TYPE_TABLE
-# define SWIG_QUOTE_STRING(x) #x
-# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
-# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
-#else
-# define SWIG_TYPE_TABLE_NAME
-#endif
-
-/*
-  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
-  creating a static or dynamic library from the swig runtime code.
-  In 99.9% of the cases, swig just needs to declare them as 'static'.
-  
-  But only do this if is strictly necessary, ie, if you have problems
-  with your compiler or so.
-*/
-
-#ifndef SWIGRUNTIME
-# define SWIGRUNTIME SWIGINTERN
-#endif
-
-#ifndef SWIGRUNTIMEINLINE
-# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
-#endif
-
-#include &lt;string.h&gt;
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-typedef void *(*swig_converter_func)(void *);
-typedef struct swig_type_info *(*swig_dycast_func)(void **);
-
-/* Structure to store inforomation on one type */
-typedef struct swig_type_info {
-  const char             *name;			/* mangled name of this type */
-  const char             *str;			/* human readable name of this type */
-  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
-  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
-  void                   *clientdata;		/* language specific type data */
-} swig_type_info;
-
-/* Structure to store a type and conversion function used for casting */
-typedef struct swig_cast_info {
-  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
-  swig_converter_func     converter;		/* function to cast the void pointers */
-  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
-  struct swig_cast_info  *prev;			/* pointer to the previous cast */
-} swig_cast_info;
-
-/* Structure used to store module information
- * Each module generates one structure like this, and the runtime collects
- * all of these structures and stores them in a circularly linked list.*/
-typedef struct swig_module_info {
-  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
-  size_t                 size;		        /* Number of types in this module */
-  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
-  swig_type_info         **type_initial;	/* Array of initially generated type structures */
-  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
-  void                    *clientdata;		/* Language specific module data */
-} swig_module_info;
-
-
-/* 
-  Compare two type names skipping the space characters, therefore
-  &quot;char*&quot; == &quot;char *&quot; and &quot;Class&lt;int&gt;&quot; == &quot;Class&lt;int &gt;&quot;, etc.
-
-  Return 0 when the two name types are equivalent, as in
-  strncmp, but skipping ' '.
-*/
-SWIGRUNTIME int
-SWIG_TypeNameComp(const char *f1, const char *l1,
-		  const char *f2, const char *l2) {
-  for (;(f1 != l1) &amp;&amp; (f2 != l2); ++f1, ++f2) {
-    while ((*f1 == ' ') &amp;&amp; (f1 != l1)) ++f1;
-    while ((*f2 == ' ') &amp;&amp; (f2 != l2)) ++f2;
-    if (*f1 != *f2) return (int)(*f1 - *f2);
-  }
-  return (l1 - f1) - (l2 - f2);
-}
-
-/*
-  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
-  Return 0 if not equal, 1 if equal
-*/
-SWIGRUNTIME int
-SWIG_TypeEquiv(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv &amp;&amp; *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-/*
-  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
-  Return 0 if equal, -1 if nb &lt; tb, 1 if nb &gt; tb
-*/
-SWIGRUNTIME int
-SWIG_TypeCompare(const char *nb, const char *tb) {
-  int equiv = 0;
-  const char* te = tb + strlen(tb);
-  const char* ne = nb;
-  while (!equiv &amp;&amp; *ne) {
-    for (nb = ne; *ne; ++ne) {
-      if (*ne == '|') break;
-    }
-    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
-    if (*ne) ++ne;
-  }
-  return equiv;
-}
-
-
-/* think of this as a c++ template&lt;&gt; or a scheme macro */
-#define SWIG_TypeCheck_Template(comparison, ty)         \
-  if (ty) {                                             \
-    swig_cast_info *iter = ty-&gt;cast;                    \
-    while (iter) {                                      \
-      if (comparison) {                                 \
-        if (iter == ty-&gt;cast) return iter;              \
-        /* Move iter to the top of the linked list */   \
-        iter-&gt;prev-&gt;next = iter-&gt;next;                  \
-        if (iter-&gt;next)                                 \
-          iter-&gt;next-&gt;prev = iter-&gt;prev;                \
-        iter-&gt;next = ty-&gt;cast;                          \
-        iter-&gt;prev = 0;                                 \
-        if (ty-&gt;cast) ty-&gt;cast-&gt;prev = iter;            \
-        ty-&gt;cast = iter;                                \
-        return iter;                                    \
-      }                                                 \
-      iter = iter-&gt;next;                                \
-    }                                                   \
-  }                                                     \
-  return 0
-
-/*
-  Check the typename
-*/
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheck(const char *c, swig_type_info *ty) {
-  SWIG_TypeCheck_Template(strcmp(iter-&gt;type-&gt;name, c) == 0, ty);
-}
-
-/* Same as previous function, except strcmp is replaced with a pointer comparison */
-SWIGRUNTIME swig_cast_info *
-SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
-  SWIG_TypeCheck_Template(iter-&gt;type == from, into);
-}
-
-/*
-  Cast a pointer up an inheritance hierarchy
-*/
-SWIGRUNTIMEINLINE void *
-SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
-  return ((!ty) || (!ty-&gt;converter)) ? ptr : (*ty-&gt;converter)(ptr);
-}
-
-/* 
-   Dynamic pointer casting. Down an inheritance hierarchy
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
-  swig_type_info *lastty = ty;
-  if (!ty || !ty-&gt;dcast) return ty;
-  while (ty &amp;&amp; (ty-&gt;dcast)) {
-    ty = (*ty-&gt;dcast)(ptr);
-    if (ty) lastty = ty;
-  }
-  return lastty;
-}
-
-/*
-  Return the name associated with this type
-*/
-SWIGRUNTIMEINLINE const char *
-SWIG_TypeName(const swig_type_info *ty) {
-  return ty-&gt;name;
-}
-
-/*
-  Return the pretty name associated with this type,
-  that is an unmangled type name in a form presentable to the user.
-*/
-SWIGRUNTIME const char *
-SWIG_TypePrettyName(const swig_type_info *type) {
-  /* The &quot;str&quot; field contains the equivalent pretty names of the
-     type, separated by vertical-bar characters.  We choose
-     to print the last name, as it is often (?) the most
-     specific. */
-  if (type-&gt;str != NULL) {
-    const char *last_name = type-&gt;str;
-    const char *s;
-    for (s = type-&gt;str; *s; s++)
-      if (*s == '|') last_name = s+1;
-    return last_name;
-  }
-  else
-    return type-&gt;name;
-}
-
-/* 
-   Set the clientdata field for a type
-*/
-SWIGRUNTIME void
-SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
-  if (!ti-&gt;clientdata) {
-    swig_cast_info *cast = ti-&gt;cast;
-    /* if (ti-&gt;clientdata == clientdata) return; */
-    ti-&gt;clientdata = clientdata;
-    
-    while (cast) {
-      if (!cast-&gt;converter)
-	SWIG_TypeClientData(cast-&gt;type, clientdata);
-      cast = cast-&gt;next;
-    }
-  }
-}
-
-/*
-  Search for a swig_type_info structure only by mangled name
-  Search is a O(log #types)
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_MangledTypeQueryModule(swig_module_info *start, 
-                            swig_module_info *end, 
-		            const char *name) {
-  swig_module_info *iter = start;
-  do {
-    if (iter-&gt;size) {
-      register size_t l = 0;
-      register size_t r = iter-&gt;size - 1;
-      do {
-	/* since l+r &gt;= 0, we can (&gt;&gt; 1) instead (/ 2) */
-	register size_t i = (l + r) &gt;&gt; 1; 
-	const char *iname = iter-&gt;types[i]-&gt;name;
-	if (iname) {
-	  register int compare = strcmp(name, iname);
-	  if (compare == 0) {	    
-	    return iter-&gt;types[i];
-	  } else if (compare &lt; 0) {
-	    if (i) {
-	      r = i - 1;
-	    } else {
-	      break;
-	    }
-	  } else if (compare &gt; 0) {
-	    l = i + 1;
-	  }
-	} else {
-	  break; /* should never happen */
-	}
-      } while (l &lt;= r);
-    }
-    iter = iter-&gt;next;
-  } while (iter != end);
-  return 0;
-}
-
-/*
-  Search for a swig_type_info structure for either a mangled name or a human readable name.
-  It first searches the mangled names of the types, which is a O(log #types)
-  If a type is not found it then searches the human readable names, which is O(#types).
-  
-  We start searching at module start, and finish searching when start == end.  
-  Note: if start == end at the beginning of the function, we go all the way around
-  the circular list.
-*/
-SWIGRUNTIME swig_type_info *
-SWIG_TypeQueryModule(swig_module_info *start, 
-                     swig_module_info *end, 
-		     const char *name) {
-  /* STEP 1: Search the name field using binary search */
-  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
-  if (ret) {
-    return ret;
-  } else {
-    /* STEP 2: If the type hasn't been found, do a complete search
-       of the str field (the human readable name) */
-    swig_module_info *iter = start;
-    do {
-      register size_t i = 0;
-      for (; i &lt; iter-&gt;size; ++i) {
-	if (iter-&gt;types[i]-&gt;str &amp;&amp; (SWIG_TypeEquiv(iter-&gt;types[i]-&gt;str, name)))
-	  return iter-&gt;types[i];
-      }
-      iter = iter-&gt;next;
-    } while (iter != end);
-  }
-  
-  /* neither found a match */
-  return 0;
-}
-
-
-/* 
-   Pack binary data into a string
-*/
-SWIGRUNTIME char *
-SWIG_PackData(char *c, void *ptr, size_t sz) {
-  static const char hex[17] = &quot;0123456789abcdef&quot;;
-  register const unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu =  u + sz;
-  for (; u != eu; ++u) {
-    register unsigned char uu = *u;
-    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
-    *(c++) = hex[uu &amp; 0xf];
-  }
-  return c;
-}
-
-/* 
-   Unpack binary data from a string
-*/
-SWIGRUNTIME const char *
-SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
-  register unsigned char *u = (unsigned char *) ptr;
-  register const unsigned char *eu = u + sz;
-  for (; u != eu; ++u) {
-    register char d = *(c++);
-    register unsigned char uu = 0;
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu = ((d - '0') &lt;&lt; 4);
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu = ((d - ('a'-10)) &lt;&lt; 4);
-    else 
-      return (char *) 0;
-    d = *(c++);
-    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
-      uu |= (d - '0');
-    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
-      uu |= (d - ('a'-10));
-    else 
-      return (char *) 0;
-    *u = uu;
-  }
-  return c;
-}
-
-/* 
-   Pack 'void *' into a string buffer.
-*/
-SWIGRUNTIME char *
-SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
-  char *r = buff;
-  if ((2*sizeof(void *) + 2) &gt; bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
-  if (strlen(name) + 1 &gt; (bsz - (r - buff))) return 0;
-  strcpy(r,name);
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,&quot;NULL&quot;) == 0) {
-      *ptr = (void *) 0;
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sizeof(void *));
-}
-
-SWIGRUNTIME char *
-SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
-  char *r = buff;
-  size_t lname = (name ? strlen(name) : 0);
-  if ((2*sz + 2 + lname) &gt; bsz) return 0;
-  *(r++) = '_';
-  r = SWIG_PackData(r,ptr,sz);
-  if (lname) {
-    strncpy(r,name,lname+1);
-  } else {
-    *r = 0;
-  }
-  return buff;
-}
-
-SWIGRUNTIME const char *
-SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
-  if (*c != '_') {
-    if (strcmp(c,&quot;NULL&quot;) == 0) {
-      memset(ptr,0,sz);
-      return name;
-    } else {
-      return 0;
-    }
-  }
-  return SWIG_UnpackData(++c,ptr,sz);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------
- * SWIG API. Portion that goes into the runtime
- * ----------------------------------------------------------------------------- */
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* -----------------------------------------------------------------------------
- * for internal method declarations
- * ----------------------------------------------------------------------------- */
-
-#ifndef SWIGINTERN
-#  define SWIGINTERN static SWIGUNUSED
-#endif
-
-#ifndef SWIGINTERNINLINE
-#  define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
-#endif
-
-/*
-  Exception handling in wrappers
-*/
-#define SWIG_fail                goto fail
-#define SWIG_arg_fail(arg)       SWIG_Python_ArgFail(arg)
-#define SWIG_append_errmsg(msg)   SWIG_Python_AddErrMesg(msg,0)
-#define SWIG_preppend_errmsg(msg) SWIG_Python_AddErrMesg(msg,1)
-#define SWIG_type_error(type,obj) SWIG_Python_TypeError(type,obj)
-#define SWIG_null_ref(type)       SWIG_Python_NullRef(type)
-
-/*
-  Contract support
-*/
-#define SWIG_contract_assert(expr, msg) \
- if (!(expr)) { PyErr_SetString(PyExc_RuntimeError, (char *) msg ); goto fail; } else
-
-/* -----------------------------------------------------------------------------
- * Constant declarations
- * ----------------------------------------------------------------------------- */
-
-/* Constant Types */
-#define SWIG_PY_INT     1
-#define SWIG_PY_FLOAT   2
-#define SWIG_PY_STRING  3
-#define SWIG_PY_POINTER 4
-#define SWIG_PY_BINARY  5
-
-/* Constant information structure */
-typedef struct swig_const_info {
-    int type;
-    char *name;
-    long lvalue;
-    double dvalue;
-    void   *pvalue;
-    swig_type_info **ptype;
-} swig_const_info;
-
-
-/* -----------------------------------------------------------------------------
- * Alloc. memory flags
- * ----------------------------------------------------------------------------- */
-#define SWIG_OLDOBJ  1
-#define SWIG_NEWOBJ  SWIG_OLDOBJ + 1
-#define SWIG_PYSTR   SWIG_NEWOBJ + 1
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/***********************************************************************
- * pyrun.swg
- *
- *     This file contains the runtime support for Python modules
- *     and includes code for managing global variables and pointer
- *     type checking.
- *
- * Author : David Beazley (<A HREF="https://lists.berlios.de/mailman/listinfo/tw-light-svn">beazley at cs.uchicago.edu</A>)
- ************************************************************************/
-
-/* Common SWIG API */
-#define SWIG_ConvertPtr(obj, pp, type, flags)    SWIG_Python_ConvertPtr(obj, pp, type, flags)
-#define SWIG_NewPointerObj(p, type, flags)       SWIG_Python_NewPointerObj(p, type, flags)
-#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
- 
-
-/* Python-specific SWIG API */
-#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags)   SWIG_Python_ConvertPacked(obj, ptr, sz, ty, flags)
-#define SWIG_NewPackedObj(ptr, sz, type)              SWIG_Python_NewPackedObj(ptr, sz, type)
-
-/* Runtime API */
-#define SWIG_GetModule(clientdata) SWIG_Python_GetModule()
-#define SWIG_SetModule(clientdata, pointer) SWIG_Python_SetModule(pointer)
-
-/* -----------------------------------------------------------------------------
- * Pointer declarations
- * ----------------------------------------------------------------------------- */
-/*
-  Use SWIG_NO_COBJECT_TYPES to force the use of strings to represent
-  C/C++ pointers in the python side. Very useful for debugging, but
-  not always safe.
-*/
-#if !defined(SWIG_NO_COBJECT_TYPES) &amp;&amp; !defined(SWIG_COBJECT_TYPES)
-#  define SWIG_COBJECT_TYPES
-#endif
-
-/* Flags for pointer conversion */
-#define SWIG_POINTER_EXCEPTION     0x1
-#define SWIG_POINTER_DISOWN        0x2
-
-
-/* Add PyOS_snprintf for old Pythons */
-#if PY_VERSION_HEX &lt; 0x02020000
-#define PyOS_snprintf snprintf
-#endif
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* -----------------------------------------------------------------------------
- * Create a new pointer string 
- * ----------------------------------------------------------------------------- */
-#ifndef SWIG_BUFFER_SIZE
-#define SWIG_BUFFER_SIZE 1024
-#endif
-
-#if defined(SWIG_COBJECT_TYPES)
-#if !defined(SWIG_COBJECT_PYTHON)
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Object type, and use it instead of PyCObject
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *ptr;
-  const char *desc;
-} PySwigObject;
-
-/* Declarations for objects of type PySwigObject */
-
-SWIGRUNTIME int
-PySwigObject_print(PySwigObject *v, FILE *fp, int flags)
-{
-  char result[SWIG_BUFFER_SIZE];
-  flags = flags;
-  if (SWIG_PackVoidPtr(result, v-&gt;ptr, v-&gt;desc, sizeof(result))) {
-    fputs(&quot;&lt;Swig Object at &quot;, fp); fputs(result, fp); fputs(&quot;&gt;&quot;, fp);
-    return 0; 
-  } else {
-    return 1; 
-  }
-}
-  
-SWIGRUNTIME PyObject *
-PySwigObject_repr(PySwigObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v-&gt;ptr, v-&gt;desc, sizeof(result)) ?
-    PyString_FromFormat(&quot;&lt;Swig Object at %s&gt;&quot;, result) : 0;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_str(PySwigObject *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  return SWIG_PackVoidPtr(result, v-&gt;ptr, v-&gt;desc, sizeof(result)) ?
-    PyString_FromString(result) : 0;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_long(PySwigObject *v)
-{
-  return PyLong_FromVoidPtr(v-&gt;ptr);
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_format(const char* fmt, PySwigObject *v)
-{
-  PyObject *res = NULL;
-  PyObject *args = PyTuple_New(1);
-  if (args &amp;&amp; (PyTuple_SetItem(args, 0, PySwigObject_long(v)) == 0)) {
-    PyObject *ofmt = PyString_FromString(fmt);
-    if (ofmt) {
-      res = PyString_Format(ofmt,args);
-      Py_DECREF(ofmt);
-    }
-    Py_DECREF(args);
-  }  
-  return res;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_oct(PySwigObject *v)
-{
-  return PySwigObject_format(&quot;%o&quot;,v);
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_hex(PySwigObject *v)
-{
-  return PySwigObject_format(&quot;%x&quot;,v);
-}
-
-SWIGRUNTIME int
-PySwigObject_compare(PySwigObject *v, PySwigObject *w)
-{
-  int c = strcmp(v-&gt;desc, w-&gt;desc);
-  if (c) {
-    return (c &gt; 0) ? 1 : -1;
-  } else {
-    void *i = v-&gt;ptr;
-    void *j = w-&gt;ptr;
-    return (i &lt; j) ? -1 : ((i &gt; j) ? 1 : 0);
-  }
-}
-
-SWIGRUNTIME void
-PySwigObject_dealloc(PySwigObject *self)
-{
-  PyObject_DEL(self);
-}
-
-SWIGRUNTIME PyTypeObject*
-PySwigObject_type(void) {
-  static char pyswigobject_type__doc__[] = 
-    &quot;Swig object carries a C/C++ instance pointer&quot;;
-  
-  static PyNumberMethods PySwigObject_as_number = {
-    (binaryfunc)0, /*nb_add*/
-    (binaryfunc)0, /*nb_subtract*/
-    (binaryfunc)0, /*nb_multiply*/
-    (binaryfunc)0, /*nb_divide*/
-    (binaryfunc)0, /*nb_remainder*/
-    (binaryfunc)0, /*nb_divmod*/
-    (ternaryfunc)0,/*nb_power*/
-    (unaryfunc)0,  /*nb_negative*/
-    (unaryfunc)0,  /*nb_positive*/
-    (unaryfunc)0,  /*nb_absolute*/
-    (inquiry)0,    /*nb_nonzero*/
-    0,		   /*nb_invert*/
-    0,		   /*nb_lshift*/
-    0,		   /*nb_rshift*/
-    0,		   /*nb_and*/
-    0,		   /*nb_xor*/
-    0,		   /*nb_or*/
-    (coercion)0,   /*nb_coerce*/
-    (unaryfunc)PySwigObject_long, /*nb_int*/
-    (unaryfunc)PySwigObject_long, /*nb_long*/
-    (unaryfunc)0,                 /*nb_float*/
-    (unaryfunc)PySwigObject_oct,  /*nb_oct*/
-    (unaryfunc)PySwigObject_hex,  /*nb_hex*/
-#if PY_VERSION_HEX &gt;= 0x02000000
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -&gt; nb_inplace_true_divide */ 
-#endif
-  };
-
-  static PyTypeObject pyswigobject_type
-#if !defined(__cplusplus)
-  ;  
-  static int type_init = 0;
-  if (!type_init) {
-    PyTypeObject tmp
-#endif
-    = {
-    PyObject_HEAD_INIT(&amp;PyType_Type)
-    0,					/*ob_size*/
-    (char *)&quot;PySwigObject&quot;,		/*tp_name*/
-    sizeof(PySwigObject),		/*tp_basicsize*/
-    0,					/*tp_itemsize*/
-    /* methods */
-    (destructor)PySwigObject_dealloc,	/*tp_dealloc*/
-    (printfunc)PySwigObject_print,	/*tp_print*/
-    (getattrfunc)0,			/*tp_getattr*/
-    (setattrfunc)0,			/*tp_setattr*/
-    (cmpfunc)PySwigObject_compare,	/*tp_compare*/
-    (reprfunc)PySwigObject_repr,	/*tp_repr*/
-    &amp;PySwigObject_as_number,	        /*tp_as_number*/
-    0,					/*tp_as_sequence*/
-    0,					/*tp_as_mapping*/
-    (hashfunc)0,			/*tp_hash*/
-    (ternaryfunc)0,			/*tp_call*/
-    (reprfunc)PySwigObject_str,		/*tp_str*/
-    /* Space for future expansion */
-    0,0,0,0,
-    pyswigobject_type__doc__, 	        /* Documentation string */
-#if PY_VERSION_HEX &gt;= 0x02000000
-    0,                                  /* tp_traverse */
-    0,                                  /* tp_clear */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02010000
-    0,                                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02020000
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -&gt; tp_weaklist */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02030000
-    0,                                  /* tp_del */
-#endif
-#ifdef COUNT_ALLOCS
-    0,0,0,0                             /* tp_alloc -&gt; tp_next */
-#endif
-    };
-#if !defined(__cplusplus)
-    pyswigobject_type = tmp;
-    type_init = 1;
-  }
-#endif
-  return &amp;pyswigobject_type;
-}
-
-SWIGRUNTIME PyObject *
-PySwigObject_FromVoidPtrAndDesc(void *ptr, const char *desc)
-{
-  PySwigObject *self = PyObject_NEW(PySwigObject, PySwigObject_type());
-  if (self) {
-    self-&gt;ptr = ptr;
-    self-&gt;desc = desc;
-  }
-  return (PyObject *)self;
-}
-
-SWIGRUNTIMEINLINE void *
-PySwigObject_AsVoidPtr(PyObject *self)
-{
-  return ((PySwigObject *)self)-&gt;ptr;
-}
-
-SWIGRUNTIMEINLINE const char *
-PySwigObject_GetDesc(PyObject *self)
-{
-  return ((PySwigObject *)self)-&gt;desc;
-}
-
-SWIGRUNTIMEINLINE int
-PySwigObject_Check(PyObject *op) {
-  return ((op)-&gt;ob_type == PySwigObject_type()) 
-    || (strcmp((op)-&gt;ob_type-&gt;tp_name,&quot;PySwigObject&quot;) == 0);
-}
-
-/* -----------------------------------------------------------------------------
- * Implements a simple Swig Packed type, and use it instead of string
- * ----------------------------------------------------------------------------- */
-
-typedef struct {
-  PyObject_HEAD
-  void *pack;
-  const char *desc;
-  size_t size;
-} PySwigPacked;
-
-SWIGRUNTIME int
-PySwigPacked_print(PySwigPacked *v, FILE *fp, int flags)
-{
-  char result[SWIG_BUFFER_SIZE];
-  flags = flags;
-  fputs(&quot;&lt;Swig Packed &quot;, fp); 
-  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))) {
-    fputs(&quot;at &quot;, fp); 
-    fputs(result, fp); 
-  }
-  fputs(v-&gt;desc,fp); 
-  fputs(&quot;&gt;&quot;, fp);
-  return 0; 
-}
-  
-SWIGRUNTIME PyObject *
-PySwigPacked_repr(PySwigPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))) {
-    return PyString_FromFormat(&quot;&lt;Swig Packed at %s%s&gt;&quot;, result, v-&gt;desc);
-  } else {
-    return PyString_FromFormat(&quot;&lt;Swig Packed %s&gt;&quot;, v-&gt;desc);
-  }  
-}
-
-SWIGRUNTIME PyObject *
-PySwigPacked_str(PySwigPacked *v)
-{
-  char result[SWIG_BUFFER_SIZE];
-  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))){
-    return PyString_FromFormat(&quot;%s%s&quot;, result, v-&gt;desc);
-  } else {
-    return PyString_FromFormat(&quot;%s&quot;, v-&gt;desc);
-  }  
-}
-
-SWIGRUNTIME int
-PySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)
-{
-  int c = strcmp(v-&gt;desc, w-&gt;desc);
-  if (c) {
-    return (c &gt; 0) ? 1 : -1;
-  } else {
-    size_t i = v-&gt;size;
-    size_t j = w-&gt;size;
-    int s = (i &lt; j) ? -1 : ((i &gt; j) ? 1 : 0);
-    return s ? s : strncmp((char *)v-&gt;pack, (char *)w-&gt;pack, 2*v-&gt;size);
-  }
-}
-
-SWIGRUNTIME void
-PySwigPacked_dealloc(PySwigPacked *self)
-{
-  free(self-&gt;pack);
-  PyObject_DEL(self);
-}
-
-SWIGRUNTIME PyTypeObject*
-PySwigPacked_type(void) {
-  static char pyswigpacked_type__doc__[] = 
-    &quot;Swig object carries a C/C++ instance pointer&quot;;
-  static PyTypeObject pyswigpacked_type
-#if !defined(__cplusplus)
-  ;
-  static int type_init = 0;  
-  if (!type_init) {
-    PyTypeObject tmp
-#endif
-    = {
-    PyObject_HEAD_INIT(&amp;PyType_Type)
-    0,					/*ob_size*/
-    (char *)&quot;PySwigPacked&quot;,		/*tp_name*/
-    sizeof(PySwigPacked),		/*tp_basicsize*/
-    0,					/*tp_itemsize*/
-    /* methods */
-    (destructor)PySwigPacked_dealloc,	/*tp_dealloc*/
-    (printfunc)PySwigPacked_print,	/*tp_print*/
-    (getattrfunc)0,			/*tp_getattr*/
-    (setattrfunc)0,			/*tp_setattr*/
-    (cmpfunc)PySwigPacked_compare,	/*tp_compare*/
-    (reprfunc)PySwigPacked_repr,	/*tp_repr*/
-    0,	                                /*tp_as_number*/
-    0,					/*tp_as_sequence*/
-    0,					/*tp_as_mapping*/
-    (hashfunc)0,			/*tp_hash*/
-    (ternaryfunc)0,			/*tp_call*/
-    (reprfunc)PySwigPacked_str,		/*tp_str*/
-    /* Space for future expansion */
-    0,0,0,0,
-    pyswigpacked_type__doc__, 	        /* Documentation string */
-#if PY_VERSION_HEX &gt;= 0x02000000
-    0,                                  /* tp_traverse */
-    0,                                  /* tp_clear */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02010000
-    0,                                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02020000         
-    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -&gt; tp_weaklist */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02030000
-    0,                                  /* tp_del */
-#endif
-#ifdef COUNT_ALLOCS
-    0,0,0,0                             /* tp_alloc -&gt; tp_next */
-#endif
-    };
-#if !defined(__cplusplus)
-    pyswigpacked_type = tmp;
-    type_init = 1;
-  }
-#endif
-  return &amp;pyswigpacked_type;
-}
-
-SWIGRUNTIME PyObject *
-PySwigPacked_FromDataAndDesc(void *ptr, size_t size, const char *desc)
-{
-  PySwigPacked *self = PyObject_NEW(PySwigPacked, PySwigPacked_type());
-  if (self == NULL) {
-    return NULL;
-  } else {
-    void *pack = malloc(size);
-    if (pack) {
-      memcpy(pack, ptr, size);
-      self-&gt;pack = pack;
-      self-&gt;desc = desc;
-      self-&gt;size = size;
-      return (PyObject *) self;
-    }
-    return NULL;
-  }
-}
-
-SWIGRUNTIMEINLINE const char *
-PySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
-{
-  PySwigPacked *self = (PySwigPacked *)obj;
-  if (self-&gt;size != size) return 0;
-  memcpy(ptr, self-&gt;pack, size);
-  return self-&gt;desc;
-}
-
-SWIGRUNTIMEINLINE const char *
-PySwigPacked_GetDesc(PyObject *self)
-{
-  return ((PySwigPacked *)self)-&gt;desc;
-}
-
-SWIGRUNTIMEINLINE int
-PySwigPacked_Check(PyObject *op) {
-  return ((op)-&gt;ob_type == PySwigPacked_type()) 
-    || (strcmp((op)-&gt;ob_type-&gt;tp_name,&quot;PySwigPacked&quot;) == 0);
-}
-
-#else
-/* -----------------------------------------------------------------------------
- * Use the old Python PyCObject instead of PySwigObject
- * ----------------------------------------------------------------------------- */
-
-#define PySwigObject_GetDesc(obj)	           PyCObject_GetDesc(obj)
-#define PySwigObject_Check(obj)	           PyCObject_Check(obj)
-#define PySwigObject_AsVoidPtr(obj)	   PyCObject_AsVoidPtr(obj)
-#define PySwigObject_FromVoidPtrAndDesc(p, d)  PyCObject_FromVoidPtrAndDesc(p, d, NULL)
-
-#endif
-
-#endif
-
-/* -----------------------------------------------------------------------------
- * errors manipulation
- * ----------------------------------------------------------------------------- */
-
-SWIGRUNTIME void
-SWIG_Python_TypeError(const char *type, PyObject *obj)
-{
-  if (type) {
-#if defined(SWIG_COBJECT_TYPES)
-    if (obj &amp;&amp; PySwigObject_Check(obj)) {
-      const char *otype = (const char *) PySwigObject_GetDesc(obj);
-      if (otype) {
-	PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, 'PySwigObject(%s)' is received&quot;,
-		     type, otype);
-	return;
-      }
-    } else 
-#endif      
-    {
-      const char *otype = (obj ? obj-&gt;ob_type-&gt;tp_name : 0); 
-      if (otype) {
-	PyObject *str = PyObject_Str(obj);
-	const char *cstr = str ? PyString_AsString(str) : 0;
-	if (cstr) {
-	  PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, '%s(%s)' is received&quot;,
-		       type, otype, cstr);
-	} else {
-	  PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, '%s' is received&quot;,
-		       type, otype);
-	}
-	Py_XDECREF(str);
-	return;
-      }
-    }   
-    PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected&quot;, type);
-  } else {
-    PyErr_Format(PyExc_TypeError, &quot;unexpected type is received&quot;);
-  }
-}
-
-SWIGRUNTIMEINLINE void
-SWIG_Python_NullRef(const char *type)
-{
-  if (type) {
-    PyErr_Format(PyExc_TypeError, &quot;null reference of type '%s' was received&quot;,type);
-  } else {
-    PyErr_Format(PyExc_TypeError, &quot;null reference was received&quot;);
-  }
-}
-
-SWIGRUNTIME int
-SWIG_Python_AddErrMesg(const char* mesg, int infront)
-{
-  if (PyErr_Occurred()) {
-    PyObject *type = 0;
-    PyObject *value = 0;
-    PyObject *traceback = 0;
-    PyErr_Fetch(&amp;type, &amp;value, &amp;traceback);
-    if (value) {
-      PyObject *old_str = PyObject_Str(value);
-      Py_XINCREF(type);
-      PyErr_Clear();
-      if (infront) {
-	PyErr_Format(type, &quot;%s %s&quot;, mesg, PyString_AsString(old_str));
-      } else {
-	PyErr_Format(type, &quot;%s %s&quot;, PyString_AsString(old_str), mesg);
-      }
-      Py_DECREF(old_str);
-    }
-    return 1;
-  } else {
-    return 0;
-  }
-}
-
-SWIGRUNTIME int
-SWIG_Python_ArgFail(int argnum)
-{
-  if (PyErr_Occurred()) {
-    /* add information about failing argument */
-    char mesg[256];
-    PyOS_snprintf(mesg, sizeof(mesg), &quot;argument number %d:&quot;, argnum);
-    return SWIG_Python_AddErrMesg(mesg, 1);
-  } else {
-    return 0;
-  }
-}
-
-
-/* -----------------------------------------------------------------------------
- * pointers/data manipulation
- * ----------------------------------------------------------------------------- */
-
-/* Convert a pointer value */
-SWIGRUNTIME int
-SWIG_Python_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
-  swig_cast_info *tc;
-  const char *c = 0;
-  static PyObject *SWIG_this = 0;
-  int    newref = 0;
-  PyObject  *pyobj = 0;
-  void *vptr;
-  
-  if (!obj) return 0;
-  if (obj == Py_None) {
-    *ptr = 0;
-    return 0;
-  }
-
-#ifdef SWIG_COBJECT_TYPES
-  if (!(PySwigObject_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString(&quot;this&quot;);
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PySwigObject_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  }  
-  vptr = PySwigObject_AsVoidPtr(obj);
-  c = (const char *) PySwigObject_GetDesc(obj);
-  if (newref) { Py_DECREF(obj); }
-  goto type_check;
-#else
-  if (!(PyString_Check(obj))) {
-    if (!SWIG_this)
-      SWIG_this = PyString_FromString(&quot;this&quot;);
-    pyobj = obj;
-    obj = PyObject_GetAttr(obj,SWIG_this);
-    newref = 1;
-    if (!obj) goto type_error;
-    if (!PyString_Check(obj)) {
-      Py_DECREF(obj);
-      goto type_error;
-    }
-  } 
-  c = PyString_AS_STRING(obj);
-  /* Pointer values must start with leading underscore */
-  c = SWIG_UnpackVoidPtr(c, &amp;vptr, ty-&gt;name);
-  if (newref) { Py_DECREF(obj); }
-  if (!c) goto type_error;
-#endif
-
-type_check:
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-    *ptr = SWIG_TypeCast(tc,vptr);
-  } else {
-    *ptr = vptr;
-  }
-  if ((pyobj) &amp;&amp; (flags &amp; SWIG_POINTER_DISOWN)) {
-    PyObject_SetAttrString(pyobj,(char*)&quot;thisown&quot;,Py_False);
-  }
-  return 0;
-
-type_error:
-  PyErr_Clear();
-  if (pyobj &amp;&amp; !obj) {    
-    obj = pyobj;
-    if (PyCFunction_Check(obj)) {
-      /* here we get the method pointer for callbacks */
-      char *doc = (((PyCFunctionObject *)obj) -&gt; m_ml -&gt; ml_doc);
-      c = doc ? strstr(doc, &quot;swig_ptr: &quot;) : 0;
-      if (c) {
-	c = ty ? SWIG_UnpackVoidPtr(c + 10, &amp;vptr, ty-&gt;name) : 0;
-	if (!c) goto type_error;
-	goto type_check;
-      }
-    }
-  }
-  if (flags &amp; SWIG_POINTER_EXCEPTION) {
-    if (ty) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-    } else {
-      SWIG_Python_TypeError(&quot;C/C++ pointer&quot;, obj);
-    }
-  }
-  return -1;
-}
-
-/* Convert a pointer value, signal an exception on a type mismatch */
-SWIGRUNTIME void *
-SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
-  void *result;
-  if (SWIG_Python_ConvertPtr(obj, &amp;result, ty, flags) == -1) {
-    PyErr_Clear();
-    if (flags &amp; SWIG_POINTER_EXCEPTION) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-      SWIG_Python_ArgFail(argnum);
-    }
-  }
-  return result;
-}
-
-/* Convert a packed value value */
-SWIGRUNTIME int
-SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty, int flags) {
-  swig_cast_info *tc;
-  const char *c = 0;
-
-#if defined(SWIG_COBJECT_TYPES) &amp;&amp; !defined(SWIG_COBJECT_PYTHON)
-  c = PySwigPacked_UnpackData(obj, ptr, sz);
-#else
-  if ((!obj) || (!PyString_Check(obj))) goto type_error;
-  c = PyString_AS_STRING(obj);
-  /* Pointer values must start with leading underscore */
-  c = SWIG_UnpackDataName(c, ptr, sz, ty-&gt;name);
-#endif
-  if (!c) goto type_error;
-  if (ty) {
-    tc = SWIG_TypeCheck(c,ty);
-    if (!tc) goto type_error;
-  }
-  return 0;
-
-type_error:
-  PyErr_Clear();
-  if (flags &amp; SWIG_POINTER_EXCEPTION) {
-    if (ty) {
-      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
-    } else {
-      SWIG_Python_TypeError(&quot;C/C++ packed data&quot;, obj);
-    }
-  }
-  return -1;
-}  
-
-/* Create a new array object */
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int own) {
-  PyObject *robj = 0;
-  if (!type) {
-    if (!PyErr_Occurred()) {
-      PyErr_Format(PyExc_TypeError, &quot;Swig: null type passed to NewPointerObj&quot;);
-    }
-    return robj;
-  }
-  if (!ptr) {
-    Py_INCREF(Py_None);
-    return Py_None;
-  }
-#ifdef SWIG_COBJECT_TYPES
-  robj = PySwigObject_FromVoidPtrAndDesc((void *) ptr, (char *)type-&gt;name);
-#else
-  {
-    char result[SWIG_BUFFER_SIZE];
-    robj = SWIG_PackVoidPtr(result, ptr, type-&gt;name, sizeof(result)) ?
-      PyString_FromString(result) : 0;
-  }
-#endif
-  if (!robj || (robj == Py_None)) return robj;
-  if (type-&gt;clientdata) {
-    PyObject *inst;
-    PyObject *args = Py_BuildValue((char*)&quot;(O)&quot;, robj);
-    Py_DECREF(robj);
-    inst = PyObject_CallObject((PyObject *) type-&gt;clientdata, args);
-    Py_DECREF(args);
-    if (inst) {
-      if (own) {
-        PyObject_SetAttrString(inst,(char*)&quot;thisown&quot;,Py_True);
-      }
-      robj = inst;
-    }
-  }
-  return robj;
-}
-
-SWIGRUNTIME PyObject *
-SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
-  PyObject *robj = 0;
-  if (!ptr) {
-    Py_INCREF(Py_None);
-    return Py_None;
-  }
-#if defined(SWIG_COBJECT_TYPES) &amp;&amp; !defined(SWIG_COBJECT_PYTHON)
-  robj = PySwigPacked_FromDataAndDesc((void *) ptr, sz, (char *)type-&gt;name);
-#else
-  {
-    char result[SWIG_BUFFER_SIZE];
-    robj = SWIG_PackDataName(result, ptr, sz, type-&gt;name, sizeof(result)) ?
-      PyString_FromString(result) : 0;
-  }
-#endif
-  return robj;
-}
-
-/* -----------------------------------------------------------------------------*
- *  Get type list 
- * -----------------------------------------------------------------------------*/
-
-#ifdef SWIG_LINK_RUNTIME
-void *SWIG_ReturnGlobalTypeList(void *);
-#endif
-
-SWIGRUNTIME swig_module_info *
-SWIG_Python_GetModule(void) {
-  static void *type_pointer = (void *)0;
-  /* first check if module already created */
-  if (!type_pointer) {
-#ifdef SWIG_LINK_RUNTIME
-    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
-#else
-    type_pointer = PyCObject_Import((char*)&quot;swig_runtime_data&quot; SWIG_RUNTIME_VERSION,
-				    (char*)&quot;type_pointer&quot; SWIG_TYPE_TABLE_NAME);
-    if (PyErr_Occurred()) {
-      PyErr_Clear();
-      type_pointer = (void *)0;
-    }
-  }
-#endif
-  return (swig_module_info *) type_pointer;
-}
-
-SWIGRUNTIME void
-SWIG_Python_SetModule(swig_module_info *swig_module) {
-  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */
-
-  PyObject *module = Py_InitModule((char*)&quot;swig_runtime_data&quot; SWIG_RUNTIME_VERSION,
-				   swig_empty_runtime_method_table);
-  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, NULL);
-  if (pointer &amp;&amp; module) {
-    PyModule_AddObject(module, (char*)&quot;type_pointer&quot; SWIG_TYPE_TABLE_NAME, pointer);
-  }
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-
-/* -------- TYPES TABLE (BEGIN) -------- */
-
-#define SWIGTYPE_p_DialogApi swig_types[0]
-#define SWIGTYPE_p_EventManager swig_types[1]
-#define SWIGTYPE_p_GameAction swig_types[2]
-#define SWIGTYPE_p_GameConfig swig_types[3]
-#define SWIGTYPE_p_SoundSystem swig_types[4]
-#define SWIGTYPE_p_allocator_type swig_types[5]
-#define SWIGTYPE_p_boost__shared_ptrTSpaceLocation_t swig_types[6]
-#define SWIGTYPE_p_boost__shared_ptrTTGameEvent_t swig_types[7]
-#define SWIGTYPE_p_char swig_types[8]
-#define SWIGTYPE_p_difference_type swig_types[9]
-#define SWIGTYPE_p_size_type swig_types[10]
-#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t swig_types[11]
-#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type swig_types[12]
-#define SWIGTYPE_p_value_type swig_types[13]
-#define SWIGTYPE_ptrdiff_t swig_types[14]
-#define SWIGTYPE_size_t swig_types[15]
-#define SWIGTYPE_std__ptrdiff_t swig_types[16]
-#define SWIGTYPE_std__size_t swig_types[17]
-static swig_type_info *swig_types[18];
-static swig_module_info swig_module = {swig_types, 18, 0, 0, 0, 0};
-#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&amp;swig_module, &amp;swig_module, name)
-#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&amp;swig_module, &amp;swig_module, name)
-
-/* -------- TYPES TABLE (END) -------- */
-
-
-/*-----------------------------------------------
-              @(target):= _tml.so
-  ------------------------------------------------*/
-#define SWIG_init    init_tml
-
-#define SWIG_name    &quot;_tml&quot;
-
-#include &quot;tml/gameaction.h&quot;
-#include &quot;tml/gamedialog.h&quot;
-#include &quot;tml/gameconfig.h&quot;
-#include &quot;tml/eventmanager.h&quot;
-#include &quot;util/sound.h&quot;
-
-
-#include &lt;string&gt;
-
-
-  
-#if defined(__SUNPRO_CC) 
-#define SWIG_STD_NOASSIGN_STL
-#define SWIG_STD_NOINSERT_TEMPLATE_STL
-#endif
-
-
-
-#include &lt;string&gt;
-#include &lt;stdexcept&gt;
-
-
-#include &lt;utility&gt;
-
-
-/* returns SWIG_OLDOBJ if the input is a raw char*, SWIG_PYSTR if is a PyString */
-SWIGINTERN int
-SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize)
-{
-  static swig_type_info* pchar_info = 0;
-  char* vptr = 0;
-  if (!pchar_info) pchar_info = SWIG_TypeQuery(&quot;char *&quot;);
-  if (SWIG_ConvertPtr(obj, (void**)&amp;vptr, pchar_info, 0) != -1) {
-    if (cptr) *cptr = vptr;
-    if (psize) *psize = vptr ? (strlen(vptr) + 1) : 0;
-    return SWIG_OLDOBJ;
-  } else {
-    PyErr_Clear();
-    if (PyString_Check(obj)) {
-      if (cptr) {
-	*cptr = PyString_AS_STRING(obj);
-	if (psize) {
-	  *psize = PyString_GET_SIZE(obj) + 1;
-	}
-      }
-      return SWIG_PYSTR;
-    }
-  }
-  if (cptr) {
-    SWIG_type_error(&quot;char *&quot;, obj);
-  }
-  return 0;
-}
-
-
-  SWIGINTERN int
-    SWIG_AsPtr_std_string(PyObject* obj, std::string **val)
-    {
-      static swig_type_info* string_info = SWIG_TypeQuery(&quot;std::string *&quot;);
-      std::string *vptr;    
-      if (SWIG_ConvertPtr(obj, (void**)&amp;vptr, string_info, 0) != -1) {
-	if (val) *val = vptr;
-	return SWIG_OLDOBJ;
-      } else {
-	PyErr_Clear();
-	char* buf = 0 ; size_t size = 0;
-	if (SWIG_AsCharPtrAndSize(obj, &amp;buf, &amp;size)) {
-	  if (buf) {
-	    if (val) *val = new std::string(buf, size - 1);
-	    return SWIG_NEWOBJ;
-	  }
-	} else {
-	  PyErr_Clear();
-	}  
-	if (val) {
-	  PyErr_SetString(PyExc_TypeError,&quot;a string is expected&quot;);
-	}
-	return 0;
-      }
-    }
-
-
-SWIGINTERN int
-  SWIG_AsVal_double(PyObject *obj, double *val)
-{
-  if (PyFloat_Check(obj)) {
-    if (val) *val = PyFloat_AS_DOUBLE(obj);
-    return 1;
-  }  
-  if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AS_LONG(obj);
-    return 1;
-  }
-  if (PyLong_Check(obj)) {
-    double v = PyLong_AsDouble(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return 1;
-    } else {
-      if (!val) PyErr_Clear();
-      return 0;
-    }
-  }
-  if (val) {
-    SWIG_type_error(&quot;double&quot;, obj);
-  }
-  return 0;
-}
-
-
-SWIGINTERNINLINE double
-SWIG_As_double(PyObject* obj)
-{
-  double v;
-  if (!SWIG_AsVal_double(obj, &amp;v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&amp;v, 0, sizeof(double));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_double(PyObject* obj)
-{
-  return SWIG_AsVal_double(obj, (double*)0);
-}
-
-
-  /*@c:\\swig\\Lib\\python\\pymacros.swg,66,SWIG_define@*/
-#define SWIG_From_int PyInt_FromLong
-/*@@*/
-
-
-SWIGINTERNINLINE PyObject *
-SWIG_FromCharArray(const char* carray, size_t size)
-{
-  if (size &gt; INT_MAX) {
-    return SWIG_NewPointerObj((char *)(carray), 
-			      SWIG_TypeQuery(&quot;char *&quot;), 0);
-  } else {
-    return PyString_FromStringAndSize(carray, (int)(size));
-  }
-}
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_std_string(const std::string&amp; s)
-  {
-    return SWIG_FromCharArray(s.data(), s.size());
-  }
-
-
-  /*@c:\\swig\\Lib\\python\\pymacros.swg,66,SWIG_define@*/
-#define SWIG_From_double PyFloat_FromDouble
-/*@@*/
-
-
-SWIGINTERNINLINE PyObject*
-  SWIG_From_bool(bool value)
-{
-  PyObject *obj = value ? Py_True : Py_False;
-  Py_INCREF(obj);
-  return obj;
-}
-
-
-#include &lt;limits.h&gt;
-
-
-SWIGINTERN int
-  SWIG_CheckLongInRange(long value, long min_value, long max_value,
-			const char *errmsg)
-{
-  if (value &lt; min_value) {
-    if (errmsg) {
-      PyErr_Format(PyExc_OverflowError, 
-		   &quot;value %ld is less than '%s' minimum %ld&quot;, 
-		   value, errmsg, min_value);
-    }
-    return 0;    
-  } else if (value &gt; max_value) {
-    if (errmsg) {
-      PyErr_Format(PyExc_OverflowError,
-		   &quot;value %ld is greater than '%s' maximum %ld&quot;, 
-		   value, errmsg, max_value);
-    }
-    return 0;
-  }
-  return 1;
-}
-
-
-SWIGINTERN int
-  SWIG_AsVal_long(PyObject * obj, long* val)
-{
-  if (PyInt_Check(obj)) {
-    if (val) *val = PyInt_AS_LONG(obj);
-    return 1;
-  }
-  if (PyLong_Check(obj)) {
-    long v = PyLong_AsLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return 1;
-    } else {
-      if (!val) PyErr_Clear();
-      return 0;
-    }
-  }
-  if (val) {
-    SWIG_type_error(&quot;long&quot;, obj);
-  }
-  return 0;
- }
-
-
-#if INT_MAX != LONG_MAX
-SWIGINTERN int
-  SWIG_AsVal_int(PyObject *obj, int *val)
-{ 
-  const char* errmsg = val ? &quot;int&quot; : (char*)0;
-  long v;
-  if (SWIG_AsVal_long(obj, &amp;v)) {
-    if (SWIG_CheckLongInRange(v, INT_MIN,INT_MAX, errmsg)) {
-      if (val) *val = (int)(v);
-      return 1;
-    } else {
-      return 0;
-    }
-  } else {
-    PyErr_Clear();
-  }
-  if (val) {
-    SWIG_type_error(errmsg, obj);
-  }
-  return 0;    
-}
-#else
-SWIGINTERNINLINE int
-  SWIG_AsVal_int(PyObject *obj, int *val)
-{
-  return SWIG_AsVal_long(obj,(long*)val);
-}
-#endif
-
-
-SWIGINTERNINLINE int
-SWIG_As_int(PyObject* obj)
-{
-  int v;
-  if (!SWIG_AsVal_int(obj, &amp;v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&amp;v, 0, sizeof(int));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_int(PyObject* obj)
-{
-  return SWIG_AsVal_int(obj, (int*)0);
-}
-
-
-SWIGINTERN int
-  SWIG_AsVal_bool(PyObject *obj, bool *val)
-{
-  if (obj == Py_True) {
-    if (val) *val = true;
-    return 1;
-  }
-  if (obj == Py_False) {
-    if (val) *val = false;
-    return 1;
-  }
-  int res = 0;
-  if (SWIG_AsVal_int(obj, &amp;res)) {    
-    if (val) *val = res ? true : false;
-    return 1;
-  } else {
-    PyErr_Clear();
-  }  
-  if (val) {
-    SWIG_type_error(&quot;bool&quot;, obj);
-  }
-  return 0;
-}
-
-
-SWIGINTERNINLINE bool
-SWIG_As_bool(PyObject* obj)
-{
-  bool v;
-  if (!SWIG_AsVal_bool(obj, &amp;v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&amp;v, 0, sizeof(bool));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_bool(PyObject* obj)
-{
-  return SWIG_AsVal_bool(obj, (bool*)0);
-}
-
-extern SoundSystem *tw_sound;
-SoundSystem *GetSoundSystem();
-
-#include &lt;iostream&gt;  
-
-
-#if PY_VERSION_HEX &lt; 0x02000000
-#define PySequence_Size PySequence_Length
-#endif
-#include &lt;stdexcept&gt;
-
-
-#define  SWIG_MemoryError    1
-#define  SWIG_IOError        2
-#define  SWIG_RuntimeError   3
-#define  SWIG_IndexError     4
-#define  SWIG_TypeError      5
-#define  SWIG_DivisionByZero 6
-#define  SWIG_OverflowError  7
-#define  SWIG_SyntaxError    8
-#define  SWIG_ValueError     9
-#define  SWIG_SystemError   10
-#define  SWIG_UnknownError  99
-
-
-SWIGINTERN void SWIG_exception_(int code, const char *msg) {
-  switch(code) {
-  case SWIG_MemoryError:
-    PyErr_SetString(PyExc_MemoryError,msg);
-    break;
-  case SWIG_IOError:
-    PyErr_SetString(PyExc_IOError,msg);
-    break;
-  case SWIG_RuntimeError:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  case SWIG_IndexError:
-    PyErr_SetString(PyExc_IndexError,msg);
-    break;
-  case SWIG_TypeError:
-    PyErr_SetString(PyExc_TypeError,msg);
-    break;
-  case SWIG_DivisionByZero:
-    PyErr_SetString(PyExc_ZeroDivisionError,msg);
-    break;
-  case SWIG_OverflowError:
-    PyErr_SetString(PyExc_OverflowError,msg);
-    break;
-  case SWIG_SyntaxError:
-    PyErr_SetString(PyExc_SyntaxError,msg);
-    break;
-  case SWIG_ValueError:
-    PyErr_SetString(PyExc_ValueError,msg);
-    break;
-  case SWIG_SystemError:
-    PyErr_SetString(PyExc_SystemError,msg);
-    break;
-  default:
-    PyErr_SetString(PyExc_RuntimeError,msg);
-    break;
-  }
-}
-
-#define SWIG_exception(a,b) { SWIG_exception_(a,b); SWIG_fail; }
-
-
-#include &lt;stdexcept&gt;
-
-
-#include &lt;algorithm&gt;
-
-
-#include &lt;vector&gt;
-
-
-SWIGINTERN int
-  SWIG_AsVal_std_string(PyObject* obj, std::string *val)
-  {
-    std::string* s;
-    int res = SWIG_AsPtr_std_string(obj, &amp;s);
-    if ((res != 0) &amp;&amp; s) {
-      if (val) *val = *s;
-      if (res == SWIG_NEWOBJ) delete s;
-      return res;
-    }
-    if (val) {
-      PyErr_SetString(PyExc_TypeError,&quot;a string is expected&quot;);
-    }
-    return 0;
-  }
-
-
-namespace swig {  
-  template &lt;class Type&gt;
-  struct noconst_traits {
-    typedef Type noconst_type;
-  };
-
-  template &lt;class Type&gt;
-  struct noconst_traits&lt;const Type&gt; {
-    typedef Type noconst_type;
-  };
-
-  /*
-    type categories
-  */
-  struct pointer_category { };  
-  struct value_category { };
-
-  /*
-    General traits that provides type_name and type_info
-  */
-  template &lt;class Type&gt; struct traits { };
-
-  template &lt;class Type&gt;
-  inline const char* type_name() {
-    return traits&lt;typename noconst_traits&lt;Type &gt;::noconst_type &gt;::type_name();
-  }
-
-  template &lt;class Type&gt; 
-  struct traits_info {
-    static swig_type_info *type_query(std::string name) {
-      name += &quot; *&quot;;
-      return SWIG_TypeQuery(name.c_str());
-    }    
-    static swig_type_info *type_info() {
-      static swig_type_info *info = type_query(type_name&lt;Type&gt;());
-      return info;
-    }
-  };
-
-  template &lt;class Type&gt;
-  inline swig_type_info *type_info() {
-    return traits_info&lt;Type&gt;::type_info();
-  }
-
-  /*
-    Partial specialization for pointers
-  */
-  template &lt;class Type&gt; struct traits &lt;Type *&gt; {
-    typedef pointer_category category;
-    static std::string make_ptr_name(const char* name) {
-      std::string ptrname = name;
-      ptrname += &quot; *&quot;;
-      return ptrname;
-    }    
-    static const char* type_name() {
-      static std::string name = make_ptr_name(swig::type_name&lt;Type&gt;());
-      return name.c_str();
-    }
-  };
-
-  template &lt;class Type, class Category&gt; 
-  struct traits_as { };
- 
-  template &lt;class Type, class Category&gt; 
-  struct traits_check { };
-
-}
-
-
-namespace swig {  
-  /*
-    Traits that provides the from method
-  */
-  template &lt;class Type&gt; struct traits_from_ptr {
-    static PyObject *from(Type *val, int owner = 0) {
-      return SWIG_NewPointerObj(val, type_info&lt;Type&gt;(), owner);
-    }
-  };
-
-  template &lt;class Type&gt; struct traits_from {
-    static PyObject *from(const Type&amp; val) {
-      return traits_from_ptr&lt;Type&gt;::from(new Type(val), 1);
-    }
-  };
-
-  template &lt;class Type&gt; struct traits_from&lt;Type *&gt; {
-    static PyObject *from(Type* val) {
-      return traits_from_ptr&lt;Type&gt;::from(val, 0);
-    }
-  };
-
-  template &lt;class Type&gt;
-  inline PyObject *from(const Type&amp; val) {
-    return traits_from&lt;Type&gt;::from(val);
-  }
-
-  template &lt;class Type&gt;
-  inline PyObject *from_ptr(Type* val, int owner) {
-    return traits_from_ptr&lt;Type&gt;::from(val, owner);
-  }
-
-  /*
-    Traits that provides the asval/as/check method
-  */
-  template &lt;class Type&gt;
-  struct traits_asptr {   
-    static int asptr(PyObject *obj, Type **val) {
-      Type *p;
-      int res = (SWIG_ConvertPtr(obj, (void**)&amp;p, type_info&lt;Type&gt;(), 0) != -1) 
-	? SWIG_OLDOBJ : 0;
-      if (res) {
-	if (val) {
-	  *val = p;
-	}
-      } else {
-	SWIG_type_error(type_name&lt;Type&gt;(), obj);
-      }
-      return res;
-    }
-  }; 
-
-  template &lt;class Type&gt;
-  inline int asptr(PyObject *obj, Type **vptr) {
-    return traits_asptr&lt;Type&gt;::asptr(obj, vptr);
-  }
-
-  template &lt;class Type&gt; 
-  struct traits_asval {
-    static bool asval(PyObject *obj, Type *val) {
-      if (val) {
-	Type *p = 0;
-	int res = traits_asptr&lt;Type&gt;::asptr(obj, &amp;p);
-	if ((res != 0) &amp;&amp; p) {
-	  typedef typename noconst_traits&lt;Type&gt;::noconst_type noconst_type;
-	  *(const_cast&lt;noconst_type*&gt;(val)) = *p;
-	  if (res == SWIG_NEWOBJ) delete p;
-	  return true;
-	} else {
-	  return false;
-	}
-      } else {
-	return traits_asptr&lt;Type&gt;::asptr(obj, (Type **)(0)) ? true : false;
-      }
-    }
-  };
-
-  template &lt;class Type&gt; struct traits_asval&lt;Type*&gt; {
-    static bool asval(PyObject *obj, Type **val) {
-      if (val) {
-        typedef typename noconst_traits&lt;Type&gt;::noconst_type noconst_type;
-        noconst_type *p = 0;
-        int res = traits_asptr&lt;noconst_type&gt;::asptr(obj, &amp;p);
-        if (res) {
-          *(const_cast&lt;noconst_type**&gt;(val)) = p;
-     	  return true;
-	} else {
-	  return false;
-	}
-      } else {
-	return traits_asptr&lt;Type&gt;::asptr(obj, (Type **)(0)) ? true : false;
-      }
-    }
-  };
-  
-  template &lt;class Type&gt;
-  inline bool asval(PyObject *obj, Type *val) {
-    return traits_asval&lt;Type&gt;::asval(obj, val) ? true : false;
-  }
-
-  template &lt;class Type&gt; 
-  struct traits_as&lt;Type, value_category&gt; {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type v;
-      if (!obj || !asval(obj, &amp;v)) {
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name&lt;Type&gt;(), obj);
-	}
-	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
-      }
-      return v;
-    }
-  };
-
-  template &lt;class Type&gt; 
-  struct traits_as&lt;Type, pointer_category&gt; {
-    static Type as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr&lt;Type&gt;::asptr(obj, &amp;v) : 0);
-      if (res &amp;&amp; v) {
-	if (res == SWIG_NEWOBJ) {
-	  Type r(*v);
-	  delete v;
-	  return r;
-	} else {
-	  return *v;
-	}
-      } else {
-	// Uninitialized return value, no Type() constructor required.
-	static Type *v_def = (Type*) malloc(sizeof(Type));
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name&lt;Type&gt;(), obj);
-	}
-	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
-	memset(v_def,0,sizeof(Type));
-	return *v_def;
-      }
-    }
-  };
-
-  template &lt;class Type&gt; 
-  struct traits_as&lt;Type*, pointer_category&gt; {
-    static Type* as(PyObject *obj, bool throw_error) {
-      Type *v = 0;      
-      int res = (obj ? traits_asptr&lt;Type&gt;::asptr(obj, &amp;v) : 0);
-      if (res) {
-	return v;
-      } else {
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name&lt;Type&gt;(), obj);
-	}
-	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
-	return 0;
-      }
-    }
-  };
-    
-  template &lt;class Type&gt;
-  inline Type as(PyObject *obj, bool te = false) {
-    return traits_as&lt;Type, typename traits&lt;Type&gt;::category&gt;::as(obj, te);
-  }
-
-  template &lt;class Type&gt; 
-  struct traits_check&lt;Type, value_category&gt; {
-    static bool check(PyObject *obj) {
-      return obj &amp;&amp; asval(obj, (Type *)(0));
-    }
-  };
-
-  template &lt;class Type&gt; 
-  struct traits_check&lt;Type, pointer_category&gt; {
-    static bool check(PyObject *obj) {
-      return obj &amp;&amp; asptr(obj, (Type **)(0));
-    }
-  };
-
-  template &lt;class Type&gt;
-  inline bool check(PyObject *obj) {
-    return traits_check&lt;Type, typename traits&lt;Type&gt;::category&gt;::check(obj);
-  }
-}
-
-
-namespace swig {
-  template &lt;&gt; struct traits&lt;std::string &gt; {
-    typedef value_category category;
-    static const char* type_name() { return&quot;std::string&quot;; }
-  };  
-  template &lt;&gt;  struct traits_asval&lt;std::string &gt; {   
-    typedef std::string value_type;
-    static int asval(PyObject *obj, value_type *val) { 
-      return SWIG_AsVal_std_string(obj, val);
-    }
-  };
-  template &lt;&gt;  struct traits_from&lt;std::string &gt; {
-    typedef std::string value_type;
-    static PyObject *from(const value_type&amp; val) {
-      return SWIG_From_std_string(val);
-    }
-  };
-}
-
-
-  namespace swig {
-    struct PyObject_var {
-      PyObject* ptr;
-      PyObject_var(PyObject* obj = 0) : ptr(obj) { }      
-      ~PyObject_var() { if (ptr) Py_DECREF(ptr); }      
-      operator PyObject*() { return ptr; }
-      PyObject* operator-&gt;() const { return ptr; }
-    };
-  }
-
-
-namespace swig {
-  inline size_t
-  check_index(ptrdiff_t i, size_t size, bool insert = false) {
-    if ( i &lt; 0 ) {
-      if ((size_t) (-i) &lt;= size) 
-	return (size_t) (i + size);
-    } else if ( (size_t) i &lt; size ) {
-      return (size_t) i;
-    } else if (insert &amp;&amp; ((size_t) i == size)) {
-      return size;
-    }
-    
-    throw std::out_of_range(&quot;index out of range&quot;);
-  }
-
-  inline size_t
-  slice_index(ptrdiff_t i, size_t size) {
-    if ( i &lt; 0 ) {
-      if ((size_t) (-i) &lt;= size) {
-	return (size_t) (i + size);
-      } else {
-	throw std::out_of_range(&quot;index out of range&quot;);
-      }
-    } else {
-      return ( (size_t) i &lt; size ) ? ((size_t) i) : size;
-    }
-  }
-
-  template &lt;class Sequence, class Difference&gt;
-  inline typename Sequence::iterator 
-  getpos(Sequence* self, Difference i)  {
-    typename Sequence::iterator pos = self-&gt;begin(); 
-    std::advance(pos, check_index(i,self-&gt;size()));
-    return pos;
-  }
-
-  template &lt;class Sequence, class Difference&gt;
-  inline typename Sequence::const_iterator 
-  cgetpos(const Sequence* self, Difference i)  {
-    typename Sequence::const_iterator pos = self-&gt;begin(); 
-    std::advance(pos, check_index(i,self-&gt;size()));
-    return pos;
-  }
-
-  template &lt;class Sequence, class Difference&gt;
-  inline Sequence*
-  getslice(const Sequence* self, Difference i, Difference j) { 
-    typename Sequence::size_type size = self-&gt;size();
-    typename Sequence::size_type ii = swig::check_index(i, size);
-    typename Sequence::size_type jj = swig::slice_index(j, size);
-    
-    if (jj &gt; ii) {
-      typename Sequence::const_iterator vb = self-&gt;begin();
-      typename Sequence::const_iterator ve = self-&gt;begin();
-      std::advance(vb,ii);
-      std::advance(ve,jj);
-      return new Sequence(vb, ve);
-    } else {
-      return new Sequence();
-    }
-  }
-
-  template &lt;class Sequence, class Difference, class InputSeq&gt;
-  inline void
-  setslice(Sequence* self, Difference i, Difference j, const InputSeq&amp; v) {
-    typename Sequence::size_type size = self-&gt;size();
-    typename Sequence::size_type ii = swig::check_index(i, size, true);
-    typename Sequence::size_type jj = swig::slice_index(j, size);
-    if (jj &lt; ii) jj = ii;
-    typename Sequence::iterator sb = self-&gt;begin();
-    typename InputSeq::const_iterator vmid = v.begin();
-    std::advance(sb,ii);
-    std::advance(vmid, jj - ii);
-    self-&gt;insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
-  }
- 
-  template &lt;class Sequence, class Difference&gt;
-  inline void
-  delslice(Sequence* self, Difference i, Difference j) {
-    typename Sequence::size_type size = self-&gt;size();
-    typename Sequence::size_type ii = swig::check_index(i, size, true);
-    typename Sequence::size_type jj = swig::slice_index(j, size);
-    if (jj &gt; ii) {
-      typename Sequence::iterator sb = self-&gt;begin();
-      typename Sequence::iterator se = self-&gt;begin();
-      std::advance(sb,ii);
-      std::advance(se,jj);
-      self-&gt;erase(sb,se);
-    }
-  }
-}
-
-
-#include &lt;iterator&gt;
-namespace swig
-{
-  template &lt;class T&gt; 
-  struct PySequence_Ref
-  {
-    PySequence_Ref(PyObject* seq, int index) 
-      : _seq(seq), _index(index)
-    {
-    }
-
-    operator T () const 
-    {
-      swig::PyObject_var item = PySequence_GetItem(_seq, _index);
-      try {
-	return swig::as&lt;T&gt;(item, true);
-      } catch (std::exception&amp; e) {
-	char msg[1024];
-	PyOS_snprintf(msg, sizeof(msg), &quot;in sequence element %d &quot;, _index);
-	if (!PyErr_Occurred()) {
-	  SWIG_type_error(swig::type_name&lt;T&gt;(), item);
-	}
-	SWIG_append_errmsg(msg);
-	SWIG_append_errmsg(e.what());
-	throw;
-      }
-    }
-    
-    PySequence_Ref&amp; operator=(const T&amp; v) 
-    {
-      PySequence_SetItem(_seq, _index, swig::from&lt;T&gt;(v));
-      return *this;
-    }
-    
-  private:
-    PyObject* _seq;
-    int _index;
-  };
-
-  template &lt;class T&gt; 
-  struct PySequence_ArrowProxy 
-  {
-    PySequence_ArrowProxy(const T&amp; x): m_value(x) {}
-    const T* operator-&gt;() const { return &amp;m_value; }
-    operator const T*() const { return &amp;m_value; }
-    T m_value;
-  };    
-
-  template &lt;class T, class Reference &gt; 
-  struct PySequence_Iter
-  {
-    typedef PySequence_Iter&lt;T, Reference &gt; self;
-
-    typedef std::random_access_iterator_tag iterator_category;
-    typedef Reference reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-
-    PySequence_Iter()
-    {
-    }
-
-    PySequence_Iter(PyObject* seq, int index)
-      : _seq(seq), _index(index)
-    {
-    }
-
-    reference operator*() const
-    { 
-      return reference(_seq, _index);
-    }
-
-    PySequence_ArrowProxy&lt;T&gt;
-    operator-&gt;() const {
-      return PySequence_ArrowProxy&lt;T&gt;(operator*());
-    }
-
-    bool operator==(const self&amp; ri) const 
-    { 
-      return (_index == ri._index) &amp;&amp; (_seq == ri._seq);
-    }
-
-    bool operator!=(const self&amp; ri) const 
-    {
-      return !(operator==(ri));
-    }    
-
-    self&amp; operator ++ ()
-    {
-      ++_index;      
-      return *this;
-    }
-
-    self&amp; operator -- ()
-    {
-      --_index;
-      return *this;
-    }
-
-    self&amp; operator += (difference_type n) 
-    {
-      _index += n;
-      return *this;
-    }
-
-    self operator +(difference_type n) const
-    {
-      return self(_seq, _index + n);
-    }
-
-    self&amp; operator -= (difference_type n) 
-    {
-      _index -= n;
-      return *this;
-    }
-
-    self operator -(difference_type n) const
-    {
-      return self(_seq, _index - n);
-    }    
-
-    difference_type operator - (const self&amp; ri) const
-    {
-      return _index - ri._index;
-    }
-
-    reference 
-    operator[](difference_type n) const 
-    { 
-      return reference(_seq, _index + n);
-    }
-
-  private:
-    PyObject* _seq;
-    int _index;
-  }; 
-
-  template &lt;class T&gt; 
-  struct PySequence_Cont
-  {
-    typedef PySequence_Ref&lt;T&gt; reference;
-    typedef const PySequence_Ref&lt;T&gt; const_reference;
-    typedef T value_type;
-    typedef T* pointer;
-    typedef int difference_type;
-    typedef int size_type;
-    typedef const pointer const_pointer;
-    typedef PySequence_Iter&lt;T, reference&gt; iterator;
-    typedef PySequence_Iter&lt;T, const_reference&gt; const_iterator;
-
-    PySequence_Cont(PyObject* seq) : _seq(0)
-    {
-      if (!PySequence_Check(seq)) {
-	throw std::invalid_argument(&quot;a sequence is expected&quot;);
-      }
-      _seq = seq;
-      Py_INCREF(_seq);
-    }
-
-    ~PySequence_Cont() 
-    {
-      if (_seq) Py_DECREF(_seq);
-    }
-
-    size_type size() const
-    {
-      return PySequence_Size(_seq);
-    }
-
-    bool empty() const
-    {
-      return size() == 0;
-    }    
-
-    iterator begin()
-    {
-      return iterator(_seq, 0);
-    }
-
-    const_iterator begin() const
-    {
-      return const_iterator(_seq, 0);
-    }
-    
-    iterator end()
-    {
-      return iterator(_seq, size());
-    }
-    
-    const_iterator end() const
-    {
-      return const_iterator(_seq, size());
-    }    
-
-    reference operator[](difference_type n) 
-    { 
-      return reference(_seq, n);
-    }
-
-    const_reference operator[](difference_type n)  const
-    { 
-      return const_reference(_seq, n);
-    }
-
-    bool check(bool set_err = true) const
-    {
-      int s = size();
-      for (int i = 0; i &lt; s; ++i) {
-	swig::PyObject_var item = PySequence_GetItem(_seq, i);
-	if (!swig::check&lt;value_type&gt;(item)) {
-	  if (set_err) {
-	    char msg[1024];
-	    PyOS_snprintf(msg, sizeof(msg), &quot;in sequence element %d&quot;, i);
-	    SWIG_type_error(swig::type_name&lt;value_type&gt;(), item);
-	    SWIG_append_errmsg(msg);
-	  }
-	  return 0;
-	}
-      }
-      return 1;  
-    }
-
-  private:
-    PyObject* _seq;
-  };
-
-}
-
-
-  namespace swig {
-    template &lt;class PySeq, class Seq&gt; 
-    inline void
-    assign(const PySeq&amp; pyseq, Seq* seq) {
-#ifdef SWIG_STD_NOASSIGN_STL
-      typedef typename PySeq::value_type value_type;
-      typename PySeq::const_iterator it = pyseq.begin();
-      for (;it != pyseq.end(); ++it) {
-	seq-&gt;insert(seq-&gt;end(),(value_type)(*it));
-      }
-#else
-      seq-&gt;assign(pyseq.begin(), pyseq.end());
-#endif
-    }
-
-    template &lt;class Seq, class T = typename Seq::value_type &gt;
-    struct traits_asptr_stdseq {
-      typedef Seq sequence;
-      typedef T value_type;
-		    
-      static int asptr(PyObject *obj, sequence **seq) {
-	if (PySequence_Check(obj)) {
-	  try {
-	    PySequence_Cont&lt;value_type&gt; pyseq(obj);
-	    if (seq) {
-	      sequence *pseq = new sequence();
-	      assign(pyseq, pseq);
-	      *seq = pseq;
-	      return SWIG_NEWOBJ;
-	    } else {
-	      return pyseq.check();
-	    }
-	  } catch (std::exception&amp; e) {
-	    if (seq) {
-	      if (!PyErr_Occurred())
-		PyErr_SetString(PyExc_TypeError, e.what());
-	    }
-	    return 0;
-	  }
-	} else {
-	  sequence *p;
-	  if (SWIG_ConvertPtr(obj,(void**)&amp;p,
-			      swig::type_info&lt;sequence&gt;(),0) != -1) {
-	    if (seq) *seq = p;
-	    return 1;
-	  }
-	}
-	if (seq) {
-	  PyErr_Format(PyExc_TypeError, &quot;a %s is expected&quot;, 
-		       swig::type_name&lt;sequence&gt;());
-	}
-	return 0;	  
-      }
-    };
-
-    template &lt;class Seq, class T = typename Seq::value_type &gt;
-    struct traits_from_stdseq {
-      typedef Seq sequence;
-      typedef T value_type;
-      typedef typename Seq::size_type size_type;
-      typedef typename sequence::const_iterator const_iterator;
-
-      static PyObject *from(const sequence&amp; seq) {
-	size_type size = seq.size();
-	if (size &lt;= (size_type)INT_MAX) {
-	  PyObject *obj = PyTuple_New((int)size);
-	  int i = 0;
-	  for (const_iterator it = seq.begin();
-	       it != seq.end(); ++it, ++i) {
-	    PyTuple_SetItem(obj,i,swig::from&lt;value_type&gt;(*it));
-	  }
-	  return obj;
-	} else {
-	  PyErr_SetString(PyExc_OverflowError,
-			  &quot;sequence size not valid in python&quot;);
-	  return NULL;
-	}
-      }
-    };
-  }
-
-
-  namespace swig {
-    template &lt;class T&gt;
-    struct traits_asptr&lt;std::vector&lt;T&gt; &gt;  {
-      static int asptr(PyObject *obj, std::vector&lt;T&gt; **vec) {
-	return traits_asptr_stdseq&lt;std::vector&lt;T&gt; &gt;::asptr(obj, vec);
-      }
-    };
-    
-    template &lt;class T&gt;
-    struct traits_from&lt;std::vector&lt;T&gt; &gt; {
-      static PyObject *from(const std::vector&lt;T&gt;&amp; vec) {
-	return traits_from_stdseq&lt;std::vector&lt;T&gt; &gt;::from(vec);
-      }
-    };
-  }
-
-
-      namespace swig {
-	template &lt;&gt;  struct traits&lt;std::vector&lt;std::string, std::allocator&lt;std::string &gt; &gt; &gt; {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return &quot;std::vector&lt;&quot; &quot;std::string&quot; &quot;,&quot; &quot;std::allocator&lt;std::string &gt;&quot; &quot; &gt;&quot;;
-	  }
-	};
-      }
-    
-
-SWIGINTERNINLINE PyObject* 
-  SWIG_From_unsigned_SS_long(unsigned long value)
-{
-  return (value &gt; LONG_MAX) ?
-    PyLong_FromUnsignedLong(value) 
-    : PyInt_FromLong((long)(value)); 
-}
-
-
-SWIGINTERN int
-  SWIG_AsVal_unsigned_SS_long(PyObject *obj, unsigned long *val) 
-{
-  if (PyInt_Check(obj)) {
-    long v = PyInt_AS_LONG(obj);
-    if (v &gt;= 0) {
-      if (val) *val = v;
-      return 1;
-    }   
-  }
-  if (PyLong_Check(obj)) {
-    unsigned long v = PyLong_AsUnsignedLong(obj);
-    if (!PyErr_Occurred()) {
-      if (val) *val = v;
-      return 1;
-    } else {
-      if (!val) PyErr_Clear();
-      return 0;
-    }
-  } 
-  if (val) {
-    SWIG_type_error(&quot;unsigned long&quot;, obj);
-  }
-  return 0;
-}
-
-
-SWIGINTERNINLINE unsigned long
-SWIG_As_unsigned_SS_long(PyObject* obj)
-{
-  unsigned long v;
-  if (!SWIG_AsVal_unsigned_SS_long(obj, &amp;v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&amp;v, 0, sizeof(unsigned long));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_unsigned_SS_long(PyObject* obj)
-{
-  return SWIG_AsVal_unsigned_SS_long(obj, (unsigned long*)0);
-}
-
-static bool std_vector_Sl_std_string_Sg____nonzero__(std::vector&lt;std::string &gt; const *self){
-      return !(self-&gt;empty());
-    }
-static std::vector&lt;std::string &gt;::size_type std_vector_Sl_std_string_Sg____len__(std::vector&lt;std::string &gt; const *self){
-      return self-&gt;size();
-    }
-static std::vector&lt;std::string &gt;::value_type std_vector_Sl_std_string_Sg__pop(std::vector&lt;std::string &gt; *self){
-      if (self-&gt;size() == 0)
-	throw std::out_of_range(&quot;pop from empty container&quot;);
-      std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;::value_type x = self-&gt;back();
-      self-&gt;pop_back();
-      return x;
-    }
-
-SWIGINTERNINLINE long
-SWIG_As_long(PyObject* obj)
-{
-  long v;
-  if (!SWIG_AsVal_long(obj, &amp;v)) {
-    /*
-      this is needed to make valgrind/purify happier. 
-     */
-    memset((void*)&amp;v, 0, sizeof(long));
-  }
-  return v;
-}
-
-  
-SWIGINTERNINLINE int
-SWIG_Check_long(PyObject* obj)
-{
-  return SWIG_AsVal_long(obj, (long*)0);
-}
-
-static std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *std_vector_Sl_std_string_Sg____getslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j){
-      return swig::getslice(self, i, j);
-    }
-static void std_vector_Sl_std_string_Sg____setslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j,std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;v){
-      swig::setslice(self, i, j, v);
-    }
-static void std_vector_Sl_std_string_Sg____delslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j){
-      swig::delslice(self, i, j);
-    }
-static void std_vector_Sl_std_string_Sg____delitem__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i){
-      self-&gt;erase(swig::getpos(self,i));
-    }
-static std::vector&lt;std::string &gt;::value_type const &amp;std_vector_Sl_std_string_Sg____getitem__(std::vector&lt;std::string &gt; const *self,std::vector&lt;std::string &gt;::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-static void std_vector_Sl_std_string_Sg____setitem__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::value_type const &amp;x){
-      *(swig::getpos(self,i)) = x;
-    }
-static void std_vector_Sl_std_string_Sg__append(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::value_type const &amp;x){
-      self-&gt;push_back(x);
-    }
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-static PyObject *_wrap_GameAction_clean(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_clean&quot;)) goto fail;
-    GameAction::clean();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_system(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_add_system&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    GameAction::add_system((std::string const &amp;)*arg1,arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_planet(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_planet&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::add_planet((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_orbiter_station(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    std::string *arg3 = 0 ;
-    std::string *arg4 = 0 ;
-    std::string *arg5 = 0 ;
-    std::string *arg6 = 0 ;
-    std::string *arg7 = 0 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    int res3 = 0 ;
-    int res4 = 0 ;
-    int res5 = 0 ;
-    int res6 = 0 ;
-    int res7 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    PyObject * obj5 = 0 ;
-    PyObject * obj6 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOOOO:GameAction_add_orbiter_station&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4,&amp;obj5,&amp;obj6)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj2);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj3);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
-        if (!res5) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj4);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(5)) SWIG_fail;
-        arg5 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res6 = SWIG_AsPtr_std_string(obj5, &amp;ptr);
-        if (!res6) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj5);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(6)) SWIG_fail;
-        arg6 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res7 = SWIG_AsPtr_std_string(obj6, &amp;ptr);
-        if (!res7) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj6);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(7)) SWIG_fail;
-        arg7 = ptr;
-    }
-    result = (int)GameAction::add_orbiter_station((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,(std::string const &amp;)*arg3,(std::string const &amp;)*arg4,(std::string const &amp;)*arg5,(std::string const &amp;)*arg6,(std::string const &amp;)*arg7);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    if (res6 == SWIG_NEWOBJ) delete arg6;
-    if (res7 == SWIG_NEWOBJ) delete arg7;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    if (res6 == SWIG_NEWOBJ) delete arg6;
-    if (res7 == SWIG_NEWOBJ) delete arg7;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    double arg5 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        arg5 = (double)(SWIG_As_double(obj4)); 
-        if (SWIG_arg_fail(5)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3,arg4,arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_2(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_3(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid__SWIG_4(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_add_asteroid&quot;,&amp;obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_asteroid(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 1) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            return _wrap_GameAction_add_asteroid__SWIG_4(self,args);
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                return _wrap_GameAction_add_asteroid__SWIG_3(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    return _wrap_GameAction_add_asteroid__SWIG_2(self,args);
-                }
-            }
-        }
-    }
-    if (argc == 4) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        return _wrap_GameAction_add_asteroid__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        _v = SWIG_Check_double(argv[4]);
-                        if (_v) {
-                            return _wrap_GameAction_add_asteroid__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'GameAction_add_asteroid'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_player(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_player&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::add_player((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_add_ship(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    double arg3 ;
-    double arg4 ;
-    double arg5 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:GameAction_add_ship&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        arg5 = (double)(SWIG_As_double(obj4)); 
-        if (SWIG_arg_fail(5)) SWIG_fail;
-    }
-    result = (int)GameAction::add_ship((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4,arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_save_flag&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    GameAction::save_flag((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_string_flag(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_string_flag&quot;,&amp;obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = GameAction::get_string_flag((std::string const &amp;)*arg1);
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double arg2 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_save_flag&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::save_flag((std::string const &amp;)*arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_save_flag(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[3];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                return _wrap_GameAction_save_flag__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_GameAction_save_flag__SWIG_0(self,args);
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'GameAction_save_flag'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_double_flag(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    double result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_double_flag&quot;,&amp;obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = (double)GameAction::get_double_flag((std::string const &amp;)*arg1);
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_ship_id(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_ship_id&quot;)) goto fail;
-    result = (double)GameAction::get_player_ship_id();
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_star_system(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_star_system&quot;)) goto fail;
-    result = GameAction::get_player_star_system();
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_target(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_target&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::set_target(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_disable_weapon(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_disable_weapon&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    GameAction::disable_weapon(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_enable_weapon(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_enable_weapon&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    GameAction::enable_weapon(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_go_to_point(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_go_to_point&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::go_to_point(arg1,arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_go_to_location(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_go_to_location&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    result = (int)GameAction::go_to_location(arg1,arg2,arg3);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_guard_location(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_guard_location&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    result = (int)GameAction::guard_location(arg1,arg2,arg3);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_guard_point(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_guard_point&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    result = (int)GameAction::guard_point(arg1,arg2,arg3,arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_ship_team(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_ship_team&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::set_ship_team(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_enemy_team(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_enemy_team&quot;)) goto fail;
-    result = (int)GameAction::get_enemy_team();
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_player_team(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    int result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_team&quot;)) goto fail;
-    result = (int)GameAction::get_player_team();
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_remove_location(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_remove_location&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    GameAction::remove_location(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_crew(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_crew&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::set_crew(arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_location_pos_x(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_location_pos_x&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (int)GameAction::get_location_pos_x(arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_get_location_pos_y(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_location_pos_y&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (int)GameAction::get_location_pos_y(arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_exist(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_exist&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (bool)GameAction::exist(arg1);
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_end_game(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameAction_end_game&quot;)) goto fail;
-    GameAction::end_game();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_scroll_text(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_scroll_text&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        if (arg1 == NULL) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    GameAction::scroll_text((std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_print_message(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int arg2 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_print_message&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (int)(SWIG_As_int(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    GameAction::print_message((std::string const &amp;)*arg1,arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameAction_set_camera_mode(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_set_camera_mode&quot;,&amp;obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    GameAction::set_camera_mode((std::string const &amp;)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GameAction(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameAction *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GameAction&quot;)) goto fail;
-    result = (GameAction *)new GameAction();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_GameAction, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GameAction(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameAction *arg1 = (GameAction *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameAction&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_GameAction, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GameAction_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GameAction, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_DialogApi_startDialog(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_startDialog&quot;)) goto fail;
-    DialogApi::startDialog();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_endDialog(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_endDialog&quot;)) goto fail;
-    DialogApi::endDialog();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_askPlayer(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *arg1 = 0 ;
-    int result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_askPlayer&quot;,&amp;obj0)) goto fail;
-    {
-        SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        if (arg1 == NULL) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (int)DialogApi::askPlayer((std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;)*arg1);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_showText(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int arg2 ;
-    int arg3 ;
-    int arg4 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:DialogApi_showText&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        arg2 = (int)(SWIG_As_int(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (int)(SWIG_As_int(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (int)(SWIG_As_int(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    DialogApi::showText((std::string const &amp;)*arg1,arg2,arg3,arg4);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_DialogApi_showAlienPicture(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_showAlienPicture&quot;,&amp;obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    DialogApi::showAlienPicture((std::string const &amp;)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_DialogApi(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    DialogApi *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_DialogApi&quot;)) goto fail;
-    result = (DialogApi *)new DialogApi();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_DialogApi, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_DialogApi(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    DialogApi *arg1 = (DialogApi *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_DialogApi&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_DialogApi, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * DialogApi_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_DialogApi, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_GameConfig_SetGameDirectory(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_SetGameDirectory&quot;,&amp;obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    GameConfig::SetGameDirectory((std::string const &amp;)*arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameConfig_GetGameDirectory(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GameConfig_GetGameDirectory&quot;)) goto fail;
-    result = GameConfig::GetGameDirectory();
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_GameConfig_GetAbsolutePath(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_GetAbsolutePath&quot;,&amp;obj0)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = GameConfig::GetAbsolutePath((std::string const &amp;)*arg1);
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_GameConfig(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameConfig *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_GameConfig&quot;)) goto fail;
-    result = (GameConfig *)new GameConfig();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_GameConfig, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_GameConfig(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    GameConfig *arg1 = (GameConfig *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameConfig&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_GameConfig, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * GameConfig_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_GameConfig, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_EventManager_clean(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:EventManager_clean&quot;)) goto fail;
-    EventManager::clean();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_setSingleTimeEvent(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_setSingleTimeEvent&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::setSingleTimeEvent(arg1,(std::string const &amp;)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_setRepeatableTimeEvent(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_setRepeatableTimeEvent&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::setRepeatableTimeEvent(arg1,(std::string const &amp;)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_disableEvent(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:EventManager_disableEvent&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    EventManager::disableEvent(arg1);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_shipDeathById(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathById&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::shipDeathById(arg1,(std::string const &amp;)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_shipDeathByType(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathByType&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::shipDeathByType((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    std::string *arg5 = 0 ;
-    int result;
-    int res5 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:EventManager_distanceMoreThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
-        if (!res5) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj4);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(5)) SWIG_fail;
-        arg5 = ptr;
-    }
-    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return resultobj;
-    fail:
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    double arg4 ;
-    std::string *arg5 = 0 ;
-    int result;
-    int res5 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    PyObject * obj4 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOOO:EventManager_distanceLessThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        arg4 = (double)(SWIG_As_double(obj3)); 
-        if (SWIG_arg_fail(4)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
-        if (!res5) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj4);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(5)) SWIG_fail;
-        arg5 = ptr;
-    }
-    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return resultobj;
-    fail:
-    if (res5 == SWIG_NEWOBJ) delete arg5;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    std::string *arg4 = 0 ;
-    int result;
-    int res4 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:EventManager_distanceMoreThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj3);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return resultobj;
-    fail:
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceMoreThen(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 4) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
-                    if (_v) {
-                        return _wrap_EventManager_distanceMoreThen__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        _v = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
-                        if (_v) {
-                            return _wrap_EventManager_distanceMoreThen__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'EventManager_distanceMoreThen'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    double arg2 ;
-    double arg3 ;
-    std::string *arg4 = 0 ;
-    int result;
-    int res4 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:EventManager_distanceLessThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj3);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return resultobj;
-    fail:
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_distanceLessThen(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[6];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 4) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
-                    if (_v) {
-                        return _wrap_EventManager_distanceLessThen__SWIG_1(self,args);
-                    }
-                }
-            }
-        }
-    }
-    if (argc == 5) {
-        int _v;
-        _v = SWIG_Check_double(argv[0]);
-        if (_v) {
-            _v = SWIG_Check_double(argv[1]);
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    _v = SWIG_Check_double(argv[3]);
-                    if (_v) {
-                        _v = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
-                        if (_v) {
-                            return _wrap_EventManager_distanceLessThen__SWIG_0(self,args);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'EventManager_distanceLessThen'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_jumpToSystem(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::string *arg1 = 0 ;
-    std::string *arg2 = 0 ;
-    int result;
-    int res1 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_jumpToSystem&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (int)EventManager::jumpToSystem((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
-    
-    {
-        resultobj = SWIG_From_int((int)(result)); 
-    }
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_EventManager_AddEventCondition(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    double arg1 ;
-    std::string *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_AddEventCondition&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (double)(SWIG_As_double(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    EventManager::AddEventCondition(arg1,(std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_EventManager(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    EventManager *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_EventManager&quot;)) goto fail;
-    result = (EventManager *)new EventManager();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_EventManager, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_EventManager(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    EventManager *arg1 = (EventManager *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_EventManager&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_EventManager, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * EventManager_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_EventManager, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyObject *_wrap_new_SoundSystem__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    bool arg1 ;
-    SoundSystem *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_SoundSystem&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (bool)(SWIG_As_bool(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (SoundSystem *)new SoundSystem(arg1);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_SoundSystem__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_SoundSystem&quot;)) goto fail;
-    result = (SoundSystem *)new SoundSystem();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_SoundSystem(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[2];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 1); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 0) {
-        return _wrap_new_SoundSystem__SWIG_1(self,args);
-    }
-    if (argc == 1) {
-        int _v;
-        _v = SWIG_Check_bool(argv[0]);
-        if (_v) {
-            return _wrap_new_SoundSystem__SWIG_0(self,args);
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'new_SoundSystem'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_SoundSystem(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_SoundSystem&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_music__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    int arg3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:SoundSystem_play_music&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    {
-        arg3 = (int)(SWIG_As_int(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    (arg1)-&gt;play_music(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_music__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_play_music&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    (arg1)-&gt;play_music(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_music(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[4];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_SoundSystem_play_music__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                _v = SWIG_Check_int(argv[2]);
-                if (_v) {
-                    return _wrap_SoundSystem_play_music__SWIG_0(self,args);
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'SoundSystem_play_music'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_sound__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    double arg3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:SoundSystem_play_sound&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    {
-        arg3 = (double)(SWIG_As_double(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    (arg1)-&gt;play_sound(arg2,arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_sound__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_play_sound&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    (arg1)-&gt;play_sound(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_play_sound(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[4];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_SoundSystem_play_sound__SWIG_1(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_SoundSystem, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                _v = SWIG_Check_double(argv[2]);
-                if (_v) {
-                    return _wrap_SoundSystem_play_sound__SWIG_0(self,args);
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'SoundSystem_play_sound'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_stop_sound(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_stop_sound&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::string&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::string&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = *ptr;
-        if (res == SWIG_NEWOBJ) delete ptr;
-    }
-    (arg1)-&gt;stop_sound(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_set_music_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_set_music_volume&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)-&gt;set_music_volume(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_set_sound_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_set_sound_volume&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (double)(SWIG_As_double(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)-&gt;set_sound_volume(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_load_music_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_music_volume&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (double)(arg1)-&gt;load_music_volume();
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_load_sound_volume(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    double result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_sound_volume&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (double)(arg1)-&gt;load_sound_volume();
-    
-    {
-        resultobj = SWIG_From_double((double)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_playing_music(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (bool)(arg1)-&gt;playing_music();
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_SoundSystem_playing_music_file(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *arg1 = (SoundSystem *) 0 ;
-    std::string result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music_file&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (arg1)-&gt;playing_music_file();
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * SoundSystem_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_SoundSystem, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static int _wrap_tw_sound_set(PyObject *_val) {
-    {
-        void *temp;
-        if ((SWIG_ConvertPtr(_val, &amp;temp, SWIGTYPE_p_SoundSystem, SWIG_POINTER_EXCEPTION | SWIG_POINTER_DISOWN)) == -1) {
-            SWIG_append_errmsg(&quot;C/C++ variable 'tw_sound'&quot;);
-            return 1;
-        }
-        tw_sound = (SoundSystem *) temp;
-    }
-    return 0;
-}
-
-
-static PyObject *_wrap_tw_sound_get(void) {
-    PyObject *pyobj = NULL;
-    
-    pyobj = SWIG_NewPointerObj((void *)(tw_sound), SWIGTYPE_p_SoundSystem, 0);
-    return pyobj;
-}
-
-
-static PyObject *_wrap_GetSoundSystem(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    SoundSystem *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:GetSoundSystem&quot;)) goto fail;
-    result = (SoundSystem *)GetSoundSystem();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_SoundSystem, 0);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *result;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;:new_vectorString&quot;)) goto fail;
-    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;();
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = 0 ;
-    std::vector&lt;std::string &gt; *result;
-    int res1 = 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) goto fail;
-    {
-        std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *ptr = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)0;
-        res1 = swig::asptr(obj0, &amp;ptr);
-        if (!res1) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string &gt;&quot;, obj0);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;&quot;);
-        }
-        if (SWIG_arg_fail(1)) SWIG_fail;
-        arg1 = ptr;
-    }
-    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;((std::vector&lt;std::string &gt; const &amp;)*arg1);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return resultobj;
-    fail:
-    if (res1 == SWIG_NEWOBJ) delete arg1;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_empty(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_empty&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (bool)((std::vector&lt;std::string &gt; const *)arg1)-&gt;empty();
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_size(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::size_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_size&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;size();
-    
-    {
-        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_clear(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_clear&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    (arg1)-&gt;clear();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_swap(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt; *arg2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_swap&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        SWIG_Python_ConvertPtr(obj1, (void **)&amp;arg2, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        if (arg2 == NULL) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)-&gt;swap(*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_get_allocator(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    SwigValueWrapper&lt;std::allocator&lt;std::string &gt; &gt; result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_get_allocator&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;get_allocator();
-    
-    {
-        std::vector&lt;std::string &gt;::allocator_type * resultptr;
-        resultptr = new std::vector&lt;std::string &gt;::allocator_type((std::vector&lt;std::string &gt;::allocator_type &amp;)(result));
-        resultobj = SWIG_NewPointerObj((void *)(resultptr), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, 1);
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_2(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt;::size_type arg1 ;
-    std::vector&lt;std::string &gt; *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) goto fail;
-    {
-        arg1 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_pop_back(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop_back&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    (arg1)-&gt;pop_back();
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_resize__SWIG_0(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::size_type arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_resize&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)-&gt;resize(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString__SWIG_3(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt;::size_type arg1 ;
-    std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
-    std::vector&lt;std::string &gt; *result;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:new_vectorString&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    {
-        arg1 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj0)); 
-        if (SWIG_arg_fail(1)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1,(std::string const &amp;)*arg2);
-    
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_new_vectorString(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[3];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 0) {
-        return _wrap_new_vectorString__SWIG_0(self,args);
-    }
-    if (argc == 1) {
-        int _v;
-        _v = SWIG_Check_unsigned_SS_long(argv[0]);
-        if (_v) {
-            return _wrap_new_vectorString__SWIG_2(self,args);
-        }
-    }
-    if (argc == 1) {
-        int _v;
-        _v = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
-        if (_v) {
-            return _wrap_new_vectorString__SWIG_1(self,args);
-        }
-    }
-    if (argc == 2) {
-        int _v;
-        _v = SWIG_Check_unsigned_SS_long(argv[0]);
-        if (_v) {
-            _v = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-            if (_v) {
-                return _wrap_new_vectorString__SWIG_3(self,args);
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'new_vectorString'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_push_back(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_push_back&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    (arg1)-&gt;push_back((std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_front(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::value_type *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_front&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;front();
-        result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
-    }
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(*result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_back(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::value_type *result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_back&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;back();
-        result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
-    }
-    
-    {
-        resultobj = SWIG_From_std_string((std::string)(*result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_assign(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::size_type arg2 ;
-    std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
-    int res3 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_assign&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj2);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    (arg1)-&gt;assign(arg2,(std::string const &amp;)*arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return resultobj;
-    fail:
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_resize__SWIG_1(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::size_type arg2 ;
-    std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
-    int res3 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_resize&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj2);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    (arg1)-&gt;resize(arg2,(std::string const &amp;)*arg3);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return resultobj;
-    fail:
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_resize(PyObject *self, PyObject *args) {
-    int argc;
-    PyObject *argv[4];
-    int ii;
-    
-    argc = PyObject_Length(args);
-    for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
-        argv[ii] = PyTuple_GetItem(args,ii);
-    }
-    if (argc == 2) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_Check_unsigned_SS_long(argv[1]);
-            if (_v) {
-                return _wrap_vectorString_resize__SWIG_0(self,args);
-            }
-        }
-    }
-    if (argc == 3) {
-        int _v;
-        {
-            void *ptr;
-            if (SWIG_ConvertPtr(argv[0], &amp;ptr, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0) == -1) {
-                _v = 0;
-                PyErr_Clear();
-            } else {
-                _v = 1;
-            }
-        }
-        if (_v) {
-            _v = SWIG_Check_unsigned_SS_long(argv[1]);
-            if (_v) {
-                _v = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-                if (_v) {
-                    return _wrap_vectorString_resize__SWIG_1(self,args);
-                }
-            }
-        }
-    }
-    
-    PyErr_SetString(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_resize'&quot;);
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_reserve(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::size_type arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_reserve&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::size_type)(SWIG_As_unsigned_SS_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    (arg1)-&gt;reserve(arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_capacity(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::size_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_capacity&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;capacity();
-    
-    {
-        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___nonzero__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    bool result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___nonzero__&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = (bool)std_vector_Sl_std_string_Sg____nonzero__((std::vector&lt;std::string &gt; const *)arg1);
-    
-    {
-        resultobj = SWIG_From_bool((bool)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___len__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::size_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___len__&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    result = std_vector_Sl_std_string_Sg____len__((std::vector&lt;std::string &gt; const *)arg1);
-    
-    {
-        resultobj = SWIG_From_unsigned_SS_long((unsigned long)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_pop(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::value_type result;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        try {
-            result = std_vector_Sl_std_string_Sg__pop(arg1);
-        }
-        catch (std::out_of_range&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
-        }
-        /*@@*/
-    }
-    {
-        resultobj = SWIG_From_std_string((std::string)(result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___getslice__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::difference_type arg2 ;
-    std::vector&lt;std::string &gt;::difference_type arg3 ;
-    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___getslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        try {
-            result = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)std_vector_Sl_std_string_Sg____getslice__(arg1,arg2,arg3);
-        }
-        catch (std::out_of_range&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
-        }
-        /*@@*/
-    }
-    resultobj = SWIG_NewPointerObj((void*)(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 1);
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___setslice__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::difference_type arg2 ;
-    std::vector&lt;std::string &gt;::difference_type arg3 ;
-    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *arg4 = 0 ;
-    int res4 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    PyObject * obj3 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOOO:vectorString___setslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *ptr = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)0;
-        res4 = swig::asptr(obj3, &amp;ptr);
-        if (!res4) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;&quot;, obj3);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;&quot;);
-        }
-        if (SWIG_arg_fail(4)) SWIG_fail;
-        arg4 = ptr;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____setslice__(arg1,arg2,arg3,(std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;)*arg4);
-        }
-        catch (std::out_of_range&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        catch (std::invalid_argument&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_TypeError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }      
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return resultobj;
-    fail:
-    if (res4 == SWIG_NEWOBJ) delete arg4;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___delslice__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::difference_type arg2 ;
-    std::vector&lt;std::string &gt;::difference_type arg3 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___delslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        arg3 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj2)); 
-        if (SWIG_arg_fail(3)) SWIG_fail;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____delslice__(arg1,arg2,arg3);
-        }
-        catch (std::out_of_range&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___delitem__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::difference_type arg2 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString___delitem__&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____delitem__(arg1,arg2);
-        }
-        catch (std::out_of_range&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___getitem__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::difference_type arg2 ;
-    std::vector&lt;std::string &gt;::value_type *result;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString___getitem__&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        try {
-            {
-                std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = std_vector_Sl_std_string_Sg____getitem__((std::vector&lt;std::string &gt; const *)arg1,arg2);
-                result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
-            }
-        }
-        catch (std::out_of_range&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
-        }
-        /*@@*/
-    }
-    {
-        resultobj = SWIG_From_std_string((std::string)(*result)); 
-    }
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString___setitem__(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::difference_type arg2 ;
-    std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
-    int res3 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    PyObject * obj2 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___setitem__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        arg2 = (std::vector&lt;std::string &gt;::difference_type)(SWIG_As_long(obj1)); 
-        if (SWIG_arg_fail(2)) SWIG_fail;
-    }
-    {
-        std::string *ptr = (std::string *)0;
-        res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
-        if (!res3) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj2);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
-        }
-        if (SWIG_arg_fail(3)) SWIG_fail;
-        arg3 = ptr;
-    }
-    {
-        try {
-            std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,(std::string const &amp;)*arg3);
-        }
-        catch (std::out_of_range&amp; e) {
-            if (!PyErr_Occurred()) {
-                SWIG_exception(SWIG_IndexError,const_cast&lt;char*&gt;(e.what()));
-            } else {
-                SWIG_fail;
-            }
-        }
-        /*@c:\\swig\\Lib\\exception.i,341,SWIG_CATCH_UNKNOWN@*/  catch (std::exception&amp; e) {
-            SWIG_exception(SWIG_SystemError, e.what() );
-        }
-        catch (...) {
-            SWIG_exception(SWIG_UnknownError, &quot;unknown exception&quot;);
-        }
-        /*@@*/
-    }
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return resultobj;
-    fail:
-    if (res3 == SWIG_NEWOBJ) delete arg3;
-    return NULL;
-}
-
-
-static PyObject *_wrap_vectorString_append(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
-    int res2 = 0 ;
-    PyObject * obj0 = 0 ;
-    PyObject * obj1 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_append&quot;,&amp;obj0,&amp;obj1)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    {
-        std::string *ptr = (std::string *)0;
-        res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
-        if (!res2) {
-            if (!PyErr_Occurred())
-            SWIG_type_error(&quot;std::vector&lt;std::string &gt;::value_type&quot;, obj1);
-        } else if (!ptr) {
-            SWIG_null_ref(&quot;std::vector&lt;std::string &gt;::value_type&quot;);
-        }
-        if (SWIG_arg_fail(2)) SWIG_fail;
-        arg2 = ptr;
-    }
-    std_vector_Sl_std_string_Sg__append(arg1,(std::string const &amp;)*arg2);
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return resultobj;
-    fail:
-    if (res2 == SWIG_NEWOBJ) delete arg2;
-    return NULL;
-}
-
-
-static PyObject *_wrap_delete_vectorString(PyObject *, PyObject *args) {
-    PyObject *resultobj = NULL;
-    std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
-    PyObject * obj0 = 0 ;
-    
-    if(!PyArg_ParseTuple(args,(char *)&quot;O:delete_vectorString&quot;,&amp;obj0)) goto fail;
-    SWIG_Python_ConvertPtr(obj0, (void **)&amp;arg1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_EXCEPTION | 0);
-    if (SWIG_arg_fail(1)) SWIG_fail;
-    delete arg1;
-    
-    Py_INCREF(Py_None); resultobj = Py_None;
-    return resultobj;
-    fail:
-    return NULL;
-}
-
-
-static PyObject * vectorString_swigregister(PyObject *, PyObject *args) {
-    PyObject *obj;
-    if (!PyArg_ParseTuple(args,(char*)&quot;O&quot;, &amp;obj)) return NULL;
-    SWIG_TypeClientData(SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, obj);
-    Py_INCREF(obj);
-    return Py_BuildValue((char *)&quot;&quot;);
-}
-static PyMethodDef SwigMethods[] = {
-	 { (char *)&quot;GameAction_clean&quot;, _wrap_GameAction_clean, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_add_system&quot;, _wrap_GameAction_add_system, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_add_planet&quot;, _wrap_GameAction_add_planet, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_add_orbiter_station&quot;, _wrap_GameAction_add_orbiter_station, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_add_asteroid&quot;, _wrap_GameAction_add_asteroid, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_add_player&quot;, _wrap_GameAction_add_player, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_add_ship&quot;, _wrap_GameAction_add_ship, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_string_flag&quot;, _wrap_GameAction_get_string_flag, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_save_flag&quot;, _wrap_GameAction_save_flag, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_double_flag&quot;, _wrap_GameAction_get_double_flag, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_player_ship_id&quot;, _wrap_GameAction_get_player_ship_id, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_player_star_system&quot;, _wrap_GameAction_get_player_star_system, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_set_target&quot;, _wrap_GameAction_set_target, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_disable_weapon&quot;, _wrap_GameAction_disable_weapon, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_enable_weapon&quot;, _wrap_GameAction_enable_weapon, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_go_to_point&quot;, _wrap_GameAction_go_to_point, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_go_to_location&quot;, _wrap_GameAction_go_to_location, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_guard_location&quot;, _wrap_GameAction_guard_location, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_guard_point&quot;, _wrap_GameAction_guard_point, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_set_ship_team&quot;, _wrap_GameAction_set_ship_team, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_enemy_team&quot;, _wrap_GameAction_get_enemy_team, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_player_team&quot;, _wrap_GameAction_get_player_team, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_remove_location&quot;, _wrap_GameAction_remove_location, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_set_crew&quot;, _wrap_GameAction_set_crew, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_location_pos_x&quot;, _wrap_GameAction_get_location_pos_x, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_get_location_pos_y&quot;, _wrap_GameAction_get_location_pos_y, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_exist&quot;, _wrap_GameAction_exist, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_end_game&quot;, _wrap_GameAction_end_game, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_scroll_text&quot;, _wrap_GameAction_scroll_text, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_print_message&quot;, _wrap_GameAction_print_message, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_set_camera_mode&quot;, _wrap_GameAction_set_camera_mode, METH_VARARGS, NULL},
-	 { (char *)&quot;new_GameAction&quot;, _wrap_new_GameAction, METH_VARARGS, NULL},
-	 { (char *)&quot;delete_GameAction&quot;, _wrap_delete_GameAction, METH_VARARGS, NULL},
-	 { (char *)&quot;GameAction_swigregister&quot;, GameAction_swigregister, METH_VARARGS, NULL},
-	 { (char *)&quot;DialogApi_startDialog&quot;, _wrap_DialogApi_startDialog, METH_VARARGS, NULL},
-	 { (char *)&quot;DialogApi_endDialog&quot;, _wrap_DialogApi_endDialog, METH_VARARGS, NULL},
-	 { (char *)&quot;DialogApi_askPlayer&quot;, _wrap_DialogApi_askPlayer, METH_VARARGS, NULL},
-	 { (char *)&quot;DialogApi_showText&quot;, _wrap_DialogApi_showText, METH_VARARGS, NULL},
-	 { (char *)&quot;DialogApi_showAlienPicture&quot;, _wrap_DialogApi_showAlienPicture, METH_VARARGS, NULL},
-	 { (char *)&quot;new_DialogApi&quot;, _wrap_new_DialogApi, METH_VARARGS, NULL},
-	 { (char *)&quot;delete_DialogApi&quot;, _wrap_delete_DialogApi, METH_VARARGS, NULL},
-	 { (char *)&quot;DialogApi_swigregister&quot;, DialogApi_swigregister, METH_VARARGS, NULL},
-	 { (char *)&quot;GameConfig_SetGameDirectory&quot;, _wrap_GameConfig_SetGameDirectory, METH_VARARGS, NULL},
-	 { (char *)&quot;GameConfig_GetGameDirectory&quot;, _wrap_GameConfig_GetGameDirectory, METH_VARARGS, NULL},
-	 { (char *)&quot;GameConfig_GetAbsolutePath&quot;, _wrap_GameConfig_GetAbsolutePath, METH_VARARGS, NULL},
-	 { (char *)&quot;new_GameConfig&quot;, _wrap_new_GameConfig, METH_VARARGS, NULL},
-	 { (char *)&quot;delete_GameConfig&quot;, _wrap_delete_GameConfig, METH_VARARGS, NULL},
-	 { (char *)&quot;GameConfig_swigregister&quot;, GameConfig_swigregister, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_clean&quot;, _wrap_EventManager_clean, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_setSingleTimeEvent&quot;, _wrap_EventManager_setSingleTimeEvent, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_setRepeatableTimeEvent&quot;, _wrap_EventManager_setRepeatableTimeEvent, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_disableEvent&quot;, _wrap_EventManager_disableEvent, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_shipDeathById&quot;, _wrap_EventManager_shipDeathById, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_shipDeathByType&quot;, _wrap_EventManager_shipDeathByType, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_distanceMoreThen&quot;, _wrap_EventManager_distanceMoreThen, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_distanceLessThen&quot;, _wrap_EventManager_distanceLessThen, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_jumpToSystem&quot;, _wrap_EventManager_jumpToSystem, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_AddEventCondition&quot;, _wrap_EventManager_AddEventCondition, METH_VARARGS, NULL},
-	 { (char *)&quot;new_EventManager&quot;, _wrap_new_EventManager, METH_VARARGS, NULL},
-	 { (char *)&quot;delete_EventManager&quot;, _wrap_delete_EventManager, METH_VARARGS, NULL},
-	 { (char *)&quot;EventManager_swigregister&quot;, EventManager_swigregister, METH_VARARGS, NULL},
-	 { (char *)&quot;new_SoundSystem&quot;, _wrap_new_SoundSystem, METH_VARARGS, NULL},
-	 { (char *)&quot;delete_SoundSystem&quot;, _wrap_delete_SoundSystem, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_play_music&quot;, _wrap_SoundSystem_play_music, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_play_sound&quot;, _wrap_SoundSystem_play_sound, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_stop_sound&quot;, _wrap_SoundSystem_stop_sound, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_set_music_volume&quot;, _wrap_SoundSystem_set_music_volume, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_set_sound_volume&quot;, _wrap_SoundSystem_set_sound_volume, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_load_music_volume&quot;, _wrap_SoundSystem_load_music_volume, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_load_sound_volume&quot;, _wrap_SoundSystem_load_sound_volume, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_playing_music&quot;, _wrap_SoundSystem_playing_music, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_playing_music_file&quot;, _wrap_SoundSystem_playing_music_file, METH_VARARGS, NULL},
-	 { (char *)&quot;SoundSystem_swigregister&quot;, SoundSystem_swigregister, METH_VARARGS, NULL},
-	 { (char *)&quot;GetSoundSystem&quot;, _wrap_GetSoundSystem, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_empty&quot;, _wrap_vectorString_empty, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_size&quot;, _wrap_vectorString_size, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_clear&quot;, _wrap_vectorString_clear, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_swap&quot;, _wrap_vectorString_swap, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_get_allocator&quot;, _wrap_vectorString_get_allocator, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_pop_back&quot;, _wrap_vectorString_pop_back, METH_VARARGS, NULL},
-	 { (char *)&quot;new_vectorString&quot;, _wrap_new_vectorString, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_push_back&quot;, _wrap_vectorString_push_back, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_front&quot;, _wrap_vectorString_front, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_back&quot;, _wrap_vectorString_back, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_assign&quot;, _wrap_vectorString_assign, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_resize&quot;, _wrap_vectorString_resize, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_reserve&quot;, _wrap_vectorString_reserve, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_capacity&quot;, _wrap_vectorString_capacity, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___nonzero__&quot;, _wrap_vectorString___nonzero__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___len__&quot;, _wrap_vectorString___len__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_pop&quot;, _wrap_vectorString_pop, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___getslice__&quot;, _wrap_vectorString___getslice__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___setslice__&quot;, _wrap_vectorString___setslice__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___delslice__&quot;, _wrap_vectorString___delslice__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___delitem__&quot;, _wrap_vectorString___delitem__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___getitem__&quot;, _wrap_vectorString___getitem__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString___setitem__&quot;, _wrap_vectorString___setitem__, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_append&quot;, _wrap_vectorString_append, METH_VARARGS, NULL},
-	 { (char *)&quot;delete_vectorString&quot;, _wrap_delete_vectorString, METH_VARARGS, NULL},
-	 { (char *)&quot;vectorString_swigregister&quot;, vectorString_swigregister, METH_VARARGS, NULL},
-	 { NULL, NULL, 0, NULL }
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
-
-static swig_type_info _swigt__p_DialogApi = {&quot;_p_DialogApi&quot;, &quot;DialogApi *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_EventManager = {&quot;_p_EventManager&quot;, &quot;EventManager *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_GameAction = {&quot;_p_GameAction&quot;, &quot;GameAction *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_GameConfig = {&quot;_p_GameConfig&quot;, &quot;GameConfig *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_SoundSystem = {&quot;_p_SoundSystem&quot;, &quot;SoundSystem *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_allocator_type = {&quot;_p_allocator_type&quot;, &quot;allocator_type *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_boost__shared_ptrTSpaceLocation_t = {&quot;_p_boost__shared_ptrTSpaceLocation_t&quot;, &quot;boost::shared_ptr&lt;SpaceLocation &gt; *|SpaceLocationPtr *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_boost__shared_ptrTTGameEvent_t = {&quot;_p_boost__shared_ptrTTGameEvent_t&quot;, &quot;boost::shared_ptr&lt;TGameEvent &gt; *|TGameEventPtr *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_char = {&quot;_p_char&quot;, &quot;char *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_difference_type = {&quot;_p_difference_type&quot;, &quot;difference_type *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_size_type = {&quot;_p_size_type&quot;, &quot;size_type *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t = {&quot;_p_std__vectorTstd__string_std__allocatorTstd__string_t_t&quot;, &quot;std::vector&lt;std::string &gt; *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type = {&quot;_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type&quot;, &quot;std::allocator&lt;std::string &gt; *|std::vector&lt;std::string &gt;::allocator_type *&quot;, 0, 0, 0};
-static swig_type_info _swigt__p_value_type = {&quot;_p_value_type&quot;, &quot;value_type *&quot;, 0, 0, 0};
-static swig_type_info _swigt__ptrdiff_t = {&quot;_ptrdiff_t&quot;, &quot;ptrdiff_t&quot;, 0, 0, 0};
-static swig_type_info _swigt__size_t = {&quot;_size_t&quot;, &quot;size_t&quot;, 0, 0, 0};
-static swig_type_info _swigt__std__ptrdiff_t = {&quot;_std__ptrdiff_t&quot;, &quot;std::ptrdiff_t&quot;, 0, 0, 0};
-static swig_type_info _swigt__std__size_t = {&quot;_std__size_t&quot;, &quot;std::size_t&quot;, 0, 0, 0};
-
-static swig_type_info *swig_type_initial[] = {
-  &amp;_swigt__p_DialogApi,
-  &amp;_swigt__p_EventManager,
-  &amp;_swigt__p_GameAction,
-  &amp;_swigt__p_GameConfig,
-  &amp;_swigt__p_SoundSystem,
-  &amp;_swigt__p_allocator_type,
-  &amp;_swigt__p_boost__shared_ptrTSpaceLocation_t,
-  &amp;_swigt__p_boost__shared_ptrTTGameEvent_t,
-  &amp;_swigt__p_char,
-  &amp;_swigt__p_difference_type,
-  &amp;_swigt__p_size_type,
-  &amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
-  &amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
-  &amp;_swigt__p_value_type,
-  &amp;_swigt__ptrdiff_t,
-  &amp;_swigt__size_t,
-  &amp;_swigt__std__ptrdiff_t,
-  &amp;_swigt__std__size_t,
-};
-
-static swig_cast_info _swigc__p_DialogApi[] = {  {&amp;_swigt__p_DialogApi, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_EventManager[] = {  {&amp;_swigt__p_EventManager, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_GameAction[] = {  {&amp;_swigt__p_GameAction, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_GameConfig[] = {  {&amp;_swigt__p_GameConfig, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_SoundSystem[] = {  {&amp;_swigt__p_SoundSystem, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_allocator_type[] = {  {&amp;_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_boost__shared_ptrTSpaceLocation_t[] = {  {&amp;_swigt__p_boost__shared_ptrTSpaceLocation_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_boost__shared_ptrTTGameEvent_t[] = {  {&amp;_swigt__p_boost__shared_ptrTTGameEvent_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_char[] = {  {&amp;_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_difference_type[] = {  {&amp;_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_size_type[] = {  {&amp;_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t[] = {  {&amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type[] = {  {&amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_value_type[] = {  {&amp;_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__ptrdiff_t[] = {  {&amp;_swigt__ptrdiff_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__size_t[] = {  {&amp;_swigt__size_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__std__ptrdiff_t[] = {  {&amp;_swigt__std__ptrdiff_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__std__size_t[] = {  {&amp;_swigt__std__size_t, 0, 0, 0},{0, 0, 0, 0}};
-
-static swig_cast_info *swig_cast_initial[] = {
-  _swigc__p_DialogApi,
-  _swigc__p_EventManager,
-  _swigc__p_GameAction,
-  _swigc__p_GameConfig,
-  _swigc__p_SoundSystem,
-  _swigc__p_allocator_type,
-  _swigc__p_boost__shared_ptrTSpaceLocation_t,
-  _swigc__p_boost__shared_ptrTTGameEvent_t,
-  _swigc__p_char,
-  _swigc__p_difference_type,
-  _swigc__p_size_type,
-  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
-  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
-  _swigc__p_value_type,
-  _swigc__ptrdiff_t,
-  _swigc__size_t,
-  _swigc__std__ptrdiff_t,
-  _swigc__std__size_t,
-};
-
-
-/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
-
-static swig_const_info swig_const_table[] = {
-{0, 0, 0, 0.0, 0, 0}};
-
-#ifdef __cplusplus
-}
-#endif
-/*************************************************************************
- * Type initialization:
- * This problem is tough by the requirement that no dynamic 
- * memory is used. Also, since swig_type_info structures store pointers to 
- * swig_cast_info structures and swig_cast_info structures store pointers back
- * to swig_type_info structures, we need some lookup code at initialization. 
- * The idea is that swig generates all the structures that are needed. 
- * The runtime then collects these partially filled structures. 
- * The SWIG_InitializeModule function takes these initial arrays out of 
- * swig_module, and does all the lookup, filling in the swig_module.types
- * array with the correct data and linking the correct swig_cast_info
- * structures together.
-
- * The generated swig_type_info structures are assigned staticly to an initial 
- * array. We just loop though that array, and handle each type individually.
- * First we lookup if this type has been already loaded, and if so, use the
- * loaded structure instead of the generated one. Then we have to fill in the
- * cast linked list. The cast data is initially stored in something like a
- * two-dimensional array. Each row corresponds to a type (there are the same
- * number of rows as there are in the swig_type_initial array). Each entry in
- * a column is one of the swig_cast_info structures for that type.
- * The cast_initial array is actually an array of arrays, because each row has
- * a variable number of columns. So to actually build the cast linked list,
- * we find the array of casts associated with the type, and loop through it 
- * adding the casts to the list. The one last trick we need to do is making
- * sure the type pointer in the swig_cast_info struct is correct.
-
- * First off, we lookup the cast-&gt;type name to see if it is already loaded. 
- * There are three cases to handle:
- *  1) If the cast-&gt;type has already been loaded AND the type we are adding
- *     casting info to has not been loaded (it is in this module), THEN we
- *     replace the cast-&gt;type pointer with the type pointer that has already
- *     been loaded.
- *  2) If BOTH types (the one we are adding casting info to, and the 
- *     cast-&gt;type) are loaded, THEN the cast info has already been loaded by
- *     the previous module so we just ignore it.
- *  3) Finally, if cast-&gt;type has not already been loaded, then we add that
- *     swig_cast_info to the linked list (because the cast-&gt;type) pointer will
- *     be correct.
-**/
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-    
-    SWIGRUNTIME void
-    SWIG_InitializeModule(void *clientdata) {
-        swig_type_info *type, *ret;
-        swig_cast_info *cast;
-        size_t i;
-        swig_module_info *module_head;
-        static int init_run = 0;
-        
-        clientdata = clientdata;
-        
-        if (init_run) return;
-        init_run = 1;
-        
-        /* Initialize the swig_module */
-        swig_module.type_initial = swig_type_initial;
-        swig_module.cast_initial = swig_cast_initial;
-        
-        /* Try and load any already created modules */
-        module_head = SWIG_GetModule(clientdata);
-        if (module_head) {
-            swig_module.next = module_head-&gt;next;
-            module_head-&gt;next = &amp;swig_module;
-        } else {
-            /* This is the first module loaded */
-            swig_module.next = &amp;swig_module;
-            SWIG_SetModule(clientdata, &amp;swig_module);
-        }
-        
-        /* Now work on filling in swig_module.types */
-        for (i = 0; i &lt; swig_module.size; ++i) {
-            type = 0;
-            
-            /* if there is another module already loaded */
-            if (swig_module.next != &amp;swig_module) {
-                type = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, swig_module.type_initial[i]-&gt;name);
-            }
-            if (type) {
-                /* Overwrite clientdata field */
-                if (swig_module.type_initial[i]-&gt;clientdata) type-&gt;clientdata = swig_module.type_initial[i]-&gt;clientdata;
-            } else {
-                type = swig_module.type_initial[i];
-            }
-            
-            /* Insert casting types */
-            cast = swig_module.cast_initial[i];
-            while (cast-&gt;type) {
-                /* Don't need to add information already in the list */
-                ret = 0;
-                if (swig_module.next != &amp;swig_module) {
-                    ret = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, cast-&gt;type-&gt;name);
-                }
-                if (ret &amp;&amp; type == swig_module.type_initial[i]) {
-                    cast-&gt;type = ret;
-                    ret = 0;
-                }
-                
-                if (!ret) {
-                    if (type-&gt;cast) {
-                        type-&gt;cast-&gt;prev = cast;
-                        cast-&gt;next = type-&gt;cast;
-                    }
-                    type-&gt;cast = cast;
-                }
-                
-                cast++;
-            }
-            
-            /* Set entry in modules-&gt;types array equal to the type */
-            swig_module.types[i] = type;
-        }
-    }
-    
-    /* This function will propagate the clientdata field of type to
-    * any new swig_type_info structures that have been added into the list
-    * of equivalent types.  It is like calling
-    * SWIG_TypeClientData(type, clientdata) a second time.
-    */
-    SWIGRUNTIME void
-    SWIG_PropagateClientData(void) {
-        size_t i;
-        swig_cast_info *equiv;
-        static int init_run = 0;
-        
-        if (init_run) return;
-        init_run = 1;
-        
-        for (i = 0; i &lt; swig_module.size; i++) {
-            if (swig_module.types[i]-&gt;clientdata) {
-                equiv = swig_module.types[i]-&gt;cast;
-                while (equiv) {
-                    if (!equiv-&gt;converter) {
-                        if (equiv-&gt;type &amp;&amp; !equiv-&gt;type-&gt;clientdata)
-                        SWIG_TypeClientData(equiv-&gt;type, swig_module.types[i]-&gt;clientdata);
-                    }
-                    equiv = equiv-&gt;next;
-                }
-            }
-        }
-    }
-    
-#ifdef __cplusplus
-}
-#endif
-
-
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-    
-    /* Python-specific SWIG API */
-#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
-#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
-#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
-    
-    /* -----------------------------------------------------------------------------
-     * global variable support code.
-     * ----------------------------------------------------------------------------- */
-    
-    typedef struct swig_globalvar {
-        char       *name;                  /* Name of global variable */
-        PyObject *(*get_attr)(void);       /* Return the current value */
-        int       (*set_attr)(PyObject *); /* Set the value */
-        struct swig_globalvar *next;
-    } swig_globalvar;
-    
-    typedef struct swig_varlinkobject {
-        PyObject_HEAD
-        swig_globalvar *vars;
-    } swig_varlinkobject;
-    
-    SWIGINTERN PyObject *
-    swig_varlink_repr(swig_varlinkobject *v) {
-        v = v;
-        return PyString_FromString(&quot;&lt;Swig global variables&gt;&quot;);
-    }
-    
-    SWIGINTERN int
-    swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
-        swig_globalvar  *var;
-        flags = flags;
-        fprintf(fp,&quot;Swig global variables { &quot;);
-        for (var = v-&gt;vars; var; var=var-&gt;next) {
-            fprintf(fp,&quot;%s&quot;, var-&gt;name);
-            if (var-&gt;next) fprintf(fp,&quot;, &quot;);
-        }
-        fprintf(fp,&quot; }\n&quot;);
-        return 0;
-    }
-    
-    SWIGINTERN PyObject *
-    swig_varlink_getattr(swig_varlinkobject *v, char *n) {
-        swig_globalvar *var = v-&gt;vars;
-        while (var) {
-            if (strcmp(var-&gt;name,n) == 0) {
-                return (*var-&gt;get_attr)();
-            }
-            var = var-&gt;next;
-        }
-        PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
-        return NULL;
-    }
-    
-    SWIGINTERN int
-    swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
-        swig_globalvar *var = v-&gt;vars;
-        while (var) {
-            if (strcmp(var-&gt;name,n) == 0) {
-                return (*var-&gt;set_attr)(p);
-            }
-            var = var-&gt;next;
-        }
-        PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
-        return 1;
-    }
-    
-    SWIGINTERN PyTypeObject*
-    swig_varlink_type(void) {
-        static char varlink__doc__[] = &quot;Swig var link object&quot;;
-        static PyTypeObject varlink_type
-#if !defined(__cplusplus)
-        ;
-        static int type_init = 0;  
-        if (!type_init) {
-            PyTypeObject tmp
-#endif
-            = {
-                PyObject_HEAD_INIT(&amp;PyType_Type)
-                0,                                  /* Number of items in variable part (ob_size) */
-                (char *)&quot;swigvarlink&quot;,              /* Type name (tp_name) */
-                sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
-                0,                                  /* Itemsize (tp_itemsize) */
-                0,                                  /* Deallocator (tp_dealloc) */ 
-                (printfunc) swig_varlink_print,     /* Print (tp_print) */
-                (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
-                (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
-                0,                                  /* tp_compare */
-                (reprfunc) swig_varlink_repr,       /* tp_repr */
-                0,                                  /* tp_as_number */
-                0,                                  /* tp_as_sequence */
-                0,                                  /* tp_as_mapping */
-                0,                                  /* tp_hash */
-                0,                                  /* tp_call */
-                0,                                  /* tp_str */
-                0,                                  /* tp_getattro */
-                0,                                  /* tp_setattro */
-                0,                                  /* tp_as_buffer */
-                0,                                  /* tp_flags */
-                varlink__doc__,                     /* tp_doc */
-#if PY_VERSION_HEX &gt;= 0x02000000
-                0,                                  /* tp_traverse */
-                0,                                  /* tp_clear */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02010000
-                0,                                  /* tp_richcompare */
-                0,                                  /* tp_weaklistoffset */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02020000
-                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -&gt; tp_weaklist */
-#endif
-#if PY_VERSION_HEX &gt;= 0x02030000
-                0,                                  /* tp_del */
-#endif
-#ifdef COUNT_ALLOCS
-                0,0,0,0                             /* tp_alloc -&gt; tp_next */
-#endif
-            };
-#if !defined(__cplusplus)
-            varlink_type = tmp;
-            type_init = 1;
-        }
-#endif
-        return &amp;varlink_type;
-    }
-    
-    /* Create a variable linking object for use later */
-    SWIGINTERN PyObject *
-    SWIG_Python_newvarlink(void) {
-        swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
-        if (result) {
-            result-&gt;vars = 0;
-        }
-        return ((PyObject*) result);
-    }
-    
-    SWIGINTERN void 
-    SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
-        swig_varlinkobject *v = (swig_varlinkobject *) p;
-        swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
-        if (gv) {
-            size_t size = strlen(name)+1;
-            gv-&gt;name = (char *)malloc(size);
-            if (gv-&gt;name) {
-                strncpy(gv-&gt;name,name,size);
-                gv-&gt;get_attr = get_attr;
-                gv-&gt;set_attr = set_attr;
-                gv-&gt;next = v-&gt;vars;
-            }
-        }
-        v-&gt;vars = gv;
-    }
-    
-    /* -----------------------------------------------------------------------------
-     * constants/methods manipulation
-     * ----------------------------------------------------------------------------- */
-    
-    /* Install Constants */
-    SWIGINTERN void
-    SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
-        PyObject *obj = 0;
-        size_t i;
-        for (i = 0; constants[i].type; ++i) {
-            switch(constants[i].type) {
-                case SWIG_PY_INT:
-                obj = PyInt_FromLong(constants[i].lvalue);
-                break;
-                case SWIG_PY_FLOAT:
-                obj = PyFloat_FromDouble(constants[i].dvalue);
-                break;
-                case SWIG_PY_STRING:
-                if (constants[i].pvalue) {
-                    obj = PyString_FromString((char *) constants[i].pvalue);
-                } else {
-                    Py_INCREF(Py_None);
-                    obj = Py_None;
-                }
-                break;
-                case SWIG_PY_POINTER:
-                obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
-                break;
-                case SWIG_PY_BINARY:
-                obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
-                break;
-                default:
-                obj = 0;
-                break;
-            }
-            if (obj) {
-                PyDict_SetItemString(d,constants[i].name,obj);
-                Py_DECREF(obj);
-            }
-        }
-    }
-    
-    /* -----------------------------------------------------------------------------*/
-    /* Fix SwigMethods to carry the callback ptrs when needed */
-    /* -----------------------------------------------------------------------------*/
-    
-    SWIGINTERN void
-    SWIG_Python_FixMethods(PyMethodDef *methods,
-    swig_const_info *const_table,
-    swig_type_info **types,
-    swig_type_info **types_initial) {
-        size_t i;
-        for (i = 0; methods[i].ml_name; ++i) {
-            char *c = methods[i].ml_doc;
-            if (c &amp;&amp; (c = strstr(c, &quot;swig_ptr: &quot;))) {
-                int j;
-                swig_const_info *ci = 0;
-                char *name = c + 10;
-                for (j = 0; const_table[j].type; ++j) {
-                    if (strncmp(const_table[j].name, name, 
-                    strlen(const_table[j].name)) == 0) {
-                        ci = &amp;(const_table[j]);
-                        break;
-                    }
-                }
-                if (ci) {
-                    size_t shift = (ci-&gt;ptype) - types;
-                    swig_type_info *ty = types_initial[shift];
-                    size_t ldoc = (c - methods[i].ml_doc);
-                    size_t lptr = strlen(ty-&gt;name)+2*sizeof(void*)+2;
-                    char *ndoc = (char*)malloc(ldoc + lptr + 10);
-                    if (ndoc) {
-                        char *buff = ndoc;
-                        void *ptr = (ci-&gt;type == SWIG_PY_POINTER) ? ci-&gt;pvalue : 0;
-                        if (ptr) {
-                            strncpy(buff, methods[i].ml_doc, ldoc);
-                            buff += ldoc;
-                            strncpy(buff, &quot;swig_ptr: &quot;, 10);
-                            buff += 10;
-                            SWIG_PackVoidPtr(buff, ptr, ty-&gt;name, lptr);
-                            methods[i].ml_doc = ndoc;
-                        }
-                    }
-                }
-            }
-        }
-    }
-    
-    /* -----------------------------------------------------------------------------*
-     *  Initialize type list
-     * -----------------------------------------------------------------------------*/
-    
-#if PY_MAJOR_VERSION &lt; 2
-    /* PyModule_AddObject function was introduced in Python 2.0.  The following function
-    is copied out of Python/modsupport.c in python version 2.3.4 */
-    SWIGINTERN int
-    PyModule_AddObject(PyObject *m, char *name, PyObject *o)
-    {
-        PyObject *dict;
-        if (!PyModule_Check(m)) {
-            PyErr_SetString(PyExc_TypeError,
-            &quot;PyModule_AddObject() needs module as first arg&quot;);
-            return -1;
-        }
-        if (!o) {
-            PyErr_SetString(PyExc_TypeError,
-            &quot;PyModule_AddObject() needs non-NULL value&quot;);
-            return -1;
-        }
-        
-        dict = PyModule_GetDict(m);
-        if (dict == NULL) {
-            /* Internal error -- modules must have a dict! */
-            PyErr_Format(PyExc_SystemError, &quot;module '%s' has no __dict__&quot;,
-            PyModule_GetName(m));
-            return -1;
-        }
-        if (PyDict_SetItemString(dict, name, o))
-        return -1;
-        Py_DECREF(o);
-        return 0;
-    }
-#endif
-    
-#ifdef __cplusplus
-}
-#endif
-
-/* -----------------------------------------------------------------------------*
- *  Partial Init method
- * -----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-#endif
-SWIGEXPORT void SWIG_init(void) {
-    static PyObject *SWIG_globals = 0; 
-    PyObject *m, *d;
-    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
-    
-    /* Fix SwigMethods to carry the callback ptrs when needed */
-    SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
-    
-    m = Py_InitModule((char *) SWIG_name, SwigMethods);
-    d = PyModule_GetDict(m);
-    
-    SWIG_InitializeModule(0);
-    SWIG_InstallConstants(d,swig_const_table);
-    
-    PyDict_SetItemString(d,(char*)&quot;cvar&quot;, SWIG_globals);
-    SWIG_addvarlink(SWIG_globals,(char*)&quot;tw_sound&quot;,_wrap_tw_sound_get, _wrap_tw_sound_set);
-}
-
+/* ----------------------------------------------------------------------------
+ * This file was automatically generated by SWIG (<A HREF="http://www.swig.org">http://www.swig.org</A>).
+ * Version 1.3.29
+ * 
+ * This file is not intended to be easily readable and contains a number of 
+ * coding conventions designed to improve portability and efficiency. Do not make
+ * changes to this file unless you know what you are doing--modify the SWIG 
+ * interface file instead. 
+ * ----------------------------------------------------------------------------- */
+
+#define SWIGPYTHON
+#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
+
+#ifdef __cplusplus
+template&lt;class T&gt; class SwigValueWrapper {
+    T *tt;
+public:
+    SwigValueWrapper() : tt(0) { }
+    SwigValueWrapper(const SwigValueWrapper&lt;T&gt;&amp; rhs) : tt(new T(*rhs.tt)) { }
+    SwigValueWrapper(const T&amp; t) : tt(new T(t)) { }
+    ~SwigValueWrapper() { delete tt; } 
+    SwigValueWrapper&amp; operator=(const T&amp; t) { delete tt; tt = new T(t); return *this; }
+    operator T&amp;() const { return *tt; }
+    T *operator&amp;() { return tt; }
+private:
+    SwigValueWrapper&amp; operator=(const SwigValueWrapper&lt;T&gt;&amp; rhs);
+};
+#endif
+
+/* -----------------------------------------------------------------------------
+ *  This section contains generic SWIG labels for method/variable
+ *  declarations/attributes, and other compiler dependent labels.
+ * ----------------------------------------------------------------------------- */
+
+/* template workaround for compilers that cannot correctly implement the C++ standard */
+#ifndef SWIGTEMPLATEDISAMBIGUATOR
+# if defined(__SUNPRO_CC)
+#   if (__SUNPRO_CC &lt;= 0x560)
+#     define SWIGTEMPLATEDISAMBIGUATOR template
+#   else
+#     define SWIGTEMPLATEDISAMBIGUATOR 
+#   endif
+# else
+#   define SWIGTEMPLATEDISAMBIGUATOR 
+# endif
+#endif
+
+/* inline attribute */
+#ifndef SWIGINLINE
+# if defined(__cplusplus) || (defined(__GNUC__) &amp;&amp; !defined(__STRICT_ANSI__))
+#   define SWIGINLINE inline
+# else
+#   define SWIGINLINE
+# endif
+#endif
+
+/* attribute recognised by some compilers to avoid 'unused' warnings */
+#ifndef SWIGUNUSED
+# if defined(__GNUC__)
+#   if !(defined(__cplusplus)) || (__GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4))
+#     define SWIGUNUSED __attribute__ ((__unused__)) 
+#   else
+#     define SWIGUNUSED
+#   endif
+# elif defined(__ICC)
+#   define SWIGUNUSED __attribute__ ((__unused__)) 
+# else
+#   define SWIGUNUSED 
+# endif
+#endif
+
+#ifndef SWIGUNUSEDPARM
+# ifdef __cplusplus
+#   define SWIGUNUSEDPARM(p)
+# else
+#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
+# endif
+#endif
+
+/* internal SWIG method */
+#ifndef SWIGINTERN
+# define SWIGINTERN static SWIGUNUSED
+#endif
+
+/* internal inline SWIG method */
+#ifndef SWIGINTERNINLINE
+# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
+#endif
+
+/* exporting methods */
+#if (__GNUC__ &gt;= 4) || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4)
+#  ifndef GCC_HASCLASSVISIBILITY
+#    define GCC_HASCLASSVISIBILITY
+#  endif
+#endif
+
+#ifndef SWIGEXPORT
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   if defined(STATIC_LINKED)
+#     define SWIGEXPORT
+#   else
+#     define SWIGEXPORT __declspec(dllexport)
+#   endif
+# else
+#   if defined(__GNUC__) &amp;&amp; defined(GCC_HASCLASSVISIBILITY)
+#     define SWIGEXPORT __attribute__ ((visibility(&quot;default&quot;)))
+#   else
+#     define SWIGEXPORT
+#   endif
+# endif
+#endif
+
+/* calling conventions for Windows */
+#ifndef SWIGSTDCALL
+# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#   define SWIGSTDCALL __stdcall
+# else
+#   define SWIGSTDCALL
+# endif 
+#endif
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) &amp;&amp; defined(_MSC_VER)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
+
+
+/* Python.h has to appear first */
+#include &lt;Python.h&gt;
+
+/* -----------------------------------------------------------------------------
+ * swigrun.swg
+ *
+ * This file contains generic CAPI SWIG runtime support for pointer
+ * type checking.
+ * ----------------------------------------------------------------------------- */
+
+/* This should only be incremented when either the layout of swig_type_info changes,
+   or for whatever reason, the runtime changes incompatibly */
+#define SWIG_RUNTIME_VERSION &quot;2&quot;
+
+/* define SWIG_TYPE_TABLE_NAME as &quot;SWIG_TYPE_TABLE&quot; */
+#ifdef SWIG_TYPE_TABLE
+# define SWIG_QUOTE_STRING(x) #x
+# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
+# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
+#else
+# define SWIG_TYPE_TABLE_NAME
+#endif
+
+/*
+  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
+  creating a static or dynamic library from the swig runtime code.
+  In 99.9% of the cases, swig just needs to declare them as 'static'.
+  
+  But only do this if is strictly necessary, ie, if you have problems
+  with your compiler or so.
+*/
+
+#ifndef SWIGRUNTIME
+# define SWIGRUNTIME SWIGINTERN
+#endif
+
+#ifndef SWIGRUNTIMEINLINE
+# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
+#endif
+
+/*  Generic buffer size */
+#ifndef SWIG_BUFFER_SIZE
+# define SWIG_BUFFER_SIZE 1024
+#endif
+
+/* Flags for pointer conversions */
+#define SWIG_POINTER_DISOWN        0x1
+
+/* Flags for new pointer objects */
+#define SWIG_POINTER_OWN           0x1
+
+
+/* 
+   Flags/methods for returning states.
+   
+   The swig conversion methods, as ConvertPtr, return and integer 
+   that tells if the conversion was successful or not. And if not,
+   an error code can be returned (see swigerrors.swg for the codes).
+   
+   Use the following macros/flags to set or process the returning
+   states.
+   
+   In old swig versions, you usually write code as:
+
+     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
+       // success code
+     } else {
+       //fail code
+     }
+
+   Now you can be more explicit as:
+
+    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+    } else {
+      // fail code
+    }
+
+   that seems to be the same, but now you can also do
+
+    Type *ptr;
+    int res = SWIG_ConvertPtr(obj,(void **)(&amp;ptr),ty.flags);
+    if (SWIG_IsOK(res)) {
+      // success code
+      if (SWIG_IsNewObj(res) {
+        ...
+	delete *ptr;
+      } else {
+        ...
+      }
+    } else {
+      // fail code
+    }
+    
+   I.e., now SWIG_ConvertPtr can return new objects and you can
+   identify the case and take care of the deallocation. Of course that
+   requires also to SWIG_ConvertPtr to return new result values, as
+
+      int SWIG_ConvertPtr(obj, ptr,...) {         
+        if (&lt;obj is ok&gt;) {			       
+          if (&lt;need new object&gt;) {		       
+            *ptr = &lt;ptr to new allocated object&gt;; 
+            return SWIG_NEWOBJ;		       
+          } else {				       
+            *ptr = &lt;ptr to old object&gt;;	       
+            return SWIG_OLDOBJ;		       
+          } 				       
+        } else {				       
+          return SWIG_BADOBJ;		       
+        }					       
+      }
+
+   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
+   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
+   swig errors code.
+
+   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
+   allows to return the 'cast rank', for example, if you have this
+
+       int food(double)
+       int fooi(int);
+
+   and you call
+ 
+      food(1)   // cast rank '1'  (1 -&gt; 1.0)
+      fooi(1)   // cast rank '0'
+
+   just use the SWIG_AddCast()/SWIG_CheckState()
+
+
+ */
+#define SWIG_OK                    (0) 
+#define SWIG_ERROR                 (-1)
+#define SWIG_IsOK(r)               (r &gt;= 0)
+#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  
+
+/* The CastRankLimit says how many bits are used for the cast rank */
+#define SWIG_CASTRANKLIMIT         (1 &lt;&lt; 8)
+/* The NewMask denotes the object was created (using new/malloc) */
+#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  &lt;&lt; 1)
+/* The TmpMask is for in/out typemaps that use temporal objects */
+#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK &lt;&lt; 1)
+/* Simple returning values */
+#define SWIG_BADOBJ                (SWIG_ERROR)
+#define SWIG_OLDOBJ                (SWIG_OK)
+#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
+#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
+/* Check, add and del mask methods */
+#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
+#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r &amp; ~SWIG_NEWOBJMASK) : r)
+#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) &amp;&amp; (r &amp; SWIG_NEWOBJMASK))
+#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
+#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r &amp; ~SWIG_TMPOBJMASK) : r)
+#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) &amp;&amp; (r &amp; SWIG_TMPOBJMASK))
+
+
+/* Cast-Rank Mode */
+#if defined(SWIG_CASTRANK_MODE)
+#  ifndef SWIG_TypeRank
+#    define SWIG_TypeRank             unsigned long
+#  endif
+#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
+#    define SWIG_MAXCASTRANK          (2)
+#  endif
+#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
+#  define SWIG_CastRank(r)           (r &amp; SWIG_CASTRANKMASK)
+SWIGINTERNINLINE int SWIG_AddCast(int r) { 
+  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) &lt; SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
+}
+SWIGINTERNINLINE int SWIG_CheckState(int r) { 
+  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
+}
+#else /* no cast-rank mode */
+#  define SWIG_AddCast
+#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
+#endif
+
+
+
+
+#include &lt;string.h&gt;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+typedef void *(*swig_converter_func)(void *);
+typedef struct swig_type_info *(*swig_dycast_func)(void **);
+
+/* Structure to store inforomation on one type */
+typedef struct swig_type_info {
+  const char             *name;			/* mangled name of this type */
+  const char             *str;			/* human readable name of this type */
+  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
+  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
+  void                   *clientdata;		/* language specific type data */
+  int                    owndata;		/* flag if the structure owns the clientdata */
+} swig_type_info;
+
+/* Structure to store a type and conversion function used for casting */
+typedef struct swig_cast_info {
+  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
+  swig_converter_func     converter;		/* function to cast the void pointers */
+  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
+  struct swig_cast_info  *prev;			/* pointer to the previous cast */
+} swig_cast_info;
+
+/* Structure used to store module information
+ * Each module generates one structure like this, and the runtime collects
+ * all of these structures and stores them in a circularly linked list.*/
+typedef struct swig_module_info {
+  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
+  size_t                 size;		        /* Number of types in this module */
+  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
+  swig_type_info         **type_initial;	/* Array of initially generated type structures */
+  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
+  void                    *clientdata;		/* Language specific module data */
+} swig_module_info;
+
+/* 
+  Compare two type names skipping the space characters, therefore
+  &quot;char*&quot; == &quot;char *&quot; and &quot;Class&lt;int&gt;&quot; == &quot;Class&lt;int &gt;&quot;, etc.
+
+  Return 0 when the two name types are equivalent, as in
+  strncmp, but skipping ' '.
+*/
+SWIGRUNTIME int
+SWIG_TypeNameComp(const char *f1, const char *l1,
+		  const char *f2, const char *l2) {
+  for (;(f1 != l1) &amp;&amp; (f2 != l2); ++f1, ++f2) {
+    while ((*f1 == ' ') &amp;&amp; (f1 != l1)) ++f1;
+    while ((*f2 == ' ') &amp;&amp; (f2 != l2)) ++f2;
+    if (*f1 != *f2) return (*f1 &gt; *f2) ? 1 : -1;
+  }
+  return (l1 - f1) - (l2 - f2);
+}
+
+/*
+  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
+  Return 0 if not equal, 1 if equal
+*/
+SWIGRUNTIME int
+SWIG_TypeEquiv(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv &amp;&amp; *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+/*
+  Check type equivalence in a name list like &lt;name1&gt;|&lt;name2&gt;|...
+  Return 0 if equal, -1 if nb &lt; tb, 1 if nb &gt; tb
+*/
+SWIGRUNTIME int
+SWIG_TypeCompare(const char *nb, const char *tb) {
+  int equiv = 0;
+  const char* te = tb + strlen(tb);
+  const char* ne = nb;
+  while (!equiv &amp;&amp; *ne) {
+    for (nb = ne; *ne; ++ne) {
+      if (*ne == '|') break;
+    }
+    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
+    if (*ne) ++ne;
+  }
+  return equiv;
+}
+
+
+/* think of this as a c++ template&lt;&gt; or a scheme macro */
+#define SWIG_TypeCheck_Template(comparison, ty)         \
+  if (ty) {                                             \
+    swig_cast_info *iter = ty-&gt;cast;                    \
+    while (iter) {                                      \
+      if (comparison) {                                 \
+        if (iter == ty-&gt;cast) return iter;              \
+        /* Move iter to the top of the linked list */   \
+        iter-&gt;prev-&gt;next = iter-&gt;next;                  \
+        if (iter-&gt;next)                                 \
+          iter-&gt;next-&gt;prev = iter-&gt;prev;                \
+        iter-&gt;next = ty-&gt;cast;                          \
+        iter-&gt;prev = 0;                                 \
+        if (ty-&gt;cast) ty-&gt;cast-&gt;prev = iter;            \
+        ty-&gt;cast = iter;                                \
+        return iter;                                    \
+      }                                                 \
+      iter = iter-&gt;next;                                \
+    }                                                   \
+  }                                                     \
+  return 0
+
+/*
+  Check the typename
+*/
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheck(const char *c, swig_type_info *ty) {
+  SWIG_TypeCheck_Template(strcmp(iter-&gt;type-&gt;name, c) == 0, ty);
+}
+
+/* Same as previous function, except strcmp is replaced with a pointer comparison */
+SWIGRUNTIME swig_cast_info *
+SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *into) {
+  SWIG_TypeCheck_Template(iter-&gt;type == from, into);
+}
+
+/*
+  Cast a pointer up an inheritance hierarchy
+*/
+SWIGRUNTIMEINLINE void *
+SWIG_TypeCast(swig_cast_info *ty, void *ptr) {
+  return ((!ty) || (!ty-&gt;converter)) ? ptr : (*ty-&gt;converter)(ptr);
+}
+
+/* 
+   Dynamic pointer casting. Down an inheritance hierarchy
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
+  swig_type_info *lastty = ty;
+  if (!ty || !ty-&gt;dcast) return ty;
+  while (ty &amp;&amp; (ty-&gt;dcast)) {
+    ty = (*ty-&gt;dcast)(ptr);
+    if (ty) lastty = ty;
+  }
+  return lastty;
+}
+
+/*
+  Return the name associated with this type
+*/
+SWIGRUNTIMEINLINE const char *
+SWIG_TypeName(const swig_type_info *ty) {
+  return ty-&gt;name;
+}
+
+/*
+  Return the pretty name associated with this type,
+  that is an unmangled type name in a form presentable to the user.
+*/
+SWIGRUNTIME const char *
+SWIG_TypePrettyName(const swig_type_info *type) {
+  /* The &quot;str&quot; field contains the equivalent pretty names of the
+     type, separated by vertical-bar characters.  We choose
+     to print the last name, as it is often (?) the most
+     specific. */
+  if (!type) return NULL;
+  if (type-&gt;str != NULL) {
+    const char *last_name = type-&gt;str;
+    const char *s;
+    for (s = type-&gt;str; *s; s++)
+      if (*s == '|') last_name = s+1;
+    return last_name;
+  }
+  else
+    return type-&gt;name;
+}
+
+/* 
+   Set the clientdata field for a type
+*/
+SWIGRUNTIME void
+SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
+  swig_cast_info *cast = ti-&gt;cast;
+  /* if (ti-&gt;clientdata == clientdata) return; */
+  ti-&gt;clientdata = clientdata;
+  
+  while (cast) {
+    if (!cast-&gt;converter) {
+      swig_type_info *tc = cast-&gt;type;
+      if (!tc-&gt;clientdata) {
+	SWIG_TypeClientData(tc, clientdata);
+      }
+    }    
+    cast = cast-&gt;next;
+  }
+}
+SWIGRUNTIME void
+SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
+  SWIG_TypeClientData(ti, clientdata);
+  ti-&gt;owndata = 1;
+}
+  
+/*
+  Search for a swig_type_info structure only by mangled name
+  Search is a O(log #types)
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_MangledTypeQueryModule(swig_module_info *start, 
+                            swig_module_info *end, 
+		            const char *name) {
+  swig_module_info *iter = start;
+  do {
+    if (iter-&gt;size) {
+      register size_t l = 0;
+      register size_t r = iter-&gt;size - 1;
+      do {
+	/* since l+r &gt;= 0, we can (&gt;&gt; 1) instead (/ 2) */
+	register size_t i = (l + r) &gt;&gt; 1; 
+	const char *iname = iter-&gt;types[i]-&gt;name;
+	if (iname) {
+	  register int compare = strcmp(name, iname);
+	  if (compare == 0) {	    
+	    return iter-&gt;types[i];
+	  } else if (compare &lt; 0) {
+	    if (i) {
+	      r = i - 1;
+	    } else {
+	      break;
+	    }
+	  } else if (compare &gt; 0) {
+	    l = i + 1;
+	  }
+	} else {
+	  break; /* should never happen */
+	}
+      } while (l &lt;= r);
+    }
+    iter = iter-&gt;next;
+  } while (iter != end);
+  return 0;
+}
+
+/*
+  Search for a swig_type_info structure for either a mangled name or a human readable name.
+  It first searches the mangled names of the types, which is a O(log #types)
+  If a type is not found it then searches the human readable names, which is O(#types).
+  
+  We start searching at module start, and finish searching when start == end.  
+  Note: if start == end at the beginning of the function, we go all the way around
+  the circular list.
+*/
+SWIGRUNTIME swig_type_info *
+SWIG_TypeQueryModule(swig_module_info *start, 
+                     swig_module_info *end, 
+		     const char *name) {
+  /* STEP 1: Search the name field using binary search */
+  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
+  if (ret) {
+    return ret;
+  } else {
+    /* STEP 2: If the type hasn't been found, do a complete search
+       of the str field (the human readable name) */
+    swig_module_info *iter = start;
+    do {
+      register size_t i = 0;
+      for (; i &lt; iter-&gt;size; ++i) {
+	if (iter-&gt;types[i]-&gt;str &amp;&amp; (SWIG_TypeEquiv(iter-&gt;types[i]-&gt;str, name)))
+	  return iter-&gt;types[i];
+      }
+      iter = iter-&gt;next;
+    } while (iter != end);
+  }
+  
+  /* neither found a match */
+  return 0;
+}
+
+/* 
+   Pack binary data into a string
+*/
+SWIGRUNTIME char *
+SWIG_PackData(char *c, void *ptr, size_t sz) {
+  static const char hex[17] = &quot;0123456789abcdef&quot;;
+  register const unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu =  u + sz;
+  for (; u != eu; ++u) {
+    register unsigned char uu = *u;
+    *(c++) = hex[(uu &amp; 0xf0) &gt;&gt; 4];
+    *(c++) = hex[uu &amp; 0xf];
+  }
+  return c;
+}
+
+/* 
+   Unpack binary data from a string
+*/
+SWIGRUNTIME const char *
+SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
+  register unsigned char *u = (unsigned char *) ptr;
+  register const unsigned char *eu = u + sz;
+  for (; u != eu; ++u) {
+    register char d = *(c++);
+    register unsigned char uu;
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu = ((d - '0') &lt;&lt; 4);
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu = ((d - ('a'-10)) &lt;&lt; 4);
+    else 
+      return (char *) 0;
+    d = *(c++);
+    if ((d &gt;= '0') &amp;&amp; (d &lt;= '9'))
+      uu |= (d - '0');
+    else if ((d &gt;= 'a') &amp;&amp; (d &lt;= 'f'))
+      uu |= (d - ('a'-10));
+    else 
+      return (char *) 0;
+    *u = uu;
+  }
+  return c;
+}
+
+/* 
+   Pack 'void *' into a string buffer.
+*/
+SWIGRUNTIME char *
+SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
+  char *r = buff;
+  if ((2*sizeof(void *) + 2) &gt; bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,&amp;ptr,sizeof(void *));
+  if (strlen(name) + 1 &gt; (bsz - (r - buff))) return 0;
+  strcpy(r,name);
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      *ptr = (void *) 0;
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sizeof(void *));
+}
+
+SWIGRUNTIME char *
+SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
+  char *r = buff;
+  size_t lname = (name ? strlen(name) : 0);
+  if ((2*sz + 2 + lname) &gt; bsz) return 0;
+  *(r++) = '_';
+  r = SWIG_PackData(r,ptr,sz);
+  if (lname) {
+    strncpy(r,name,lname+1);
+  } else {
+    *r = 0;
+  }
+  return buff;
+}
+
+SWIGRUNTIME const char *
+SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
+  if (*c != '_') {
+    if (strcmp(c,&quot;NULL&quot;) == 0) {
+      memset(ptr,0,sz);
+      return name;
+    } else {
+      return 0;
+    }
+  }
+  return SWIG_UnpackData(++c,ptr,sz);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+/*  Errors in SWIG */
+#define  SWIG_UnknownError    	   -1 
+#define  SWIG_IOError        	   -2 
+#define  SWIG_RuntimeError   	   -3 
+#define  SWIG_IndexError     	   -4 
+#define  SWIG_TypeError      	   -5 
+#define  SWIG_DivisionByZero 	   -6 
+#define  SWIG_OverflowError  	   -7 
+#define  SWIG_SyntaxError    	   -8 
+#define  SWIG_ValueError     	   -9 
+#define  SWIG_SystemError    	   -10
+#define  SWIG_AttributeError 	   -11
+#define  SWIG_MemoryError    	   -12 
+#define  SWIG_NullReferenceError   -13
+
+
+
+/* Python.h has to appear first */
+#include &lt;Python.h&gt;
+
+/* Add PyOS_snprintf for old Pythons */
+#if PY_VERSION_HEX &lt; 0x02020000
+# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
+#  define PyOS_snprintf _snprintf
+# else
+#  define PyOS_snprintf snprintf
+# endif
+#endif
+
+/* A crude PyString_FromFormat implementation for old Pythons */
+#if PY_VERSION_HEX &lt; 0x02020000
+
+#ifndef SWIG_PYBUFFER_SIZE
+# define SWIG_PYBUFFER_SIZE 1024
+#endif
+
+static PyObject *
+PyString_FromFormat(const char *fmt, ...) {
+  va_list ap;
+  char buf[SWIG_PYBUFFER_SIZE * 2];
+  int res;
+  va_start(ap, fmt);
+  res = vsnprintf(buf, sizeof(buf), fmt, ap);
+  va_end(ap);
+  return (res &lt; 0 || res &gt;= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
+}
+#endif
+
+/* Add PyObject_Del for old Pythons */
+#if PY_VERSION_HEX &lt; 0x01060000
+# define PyObject_Del(op) PyMem_DEL((op))
+#endif
+#ifndef PyObject_DEL
+# define PyObject_DEL PyObject_Del
+#endif
+
+/* A crude PyExc_StopIteration exception for old Pythons */
+#if PY_VERSION_HEX &lt; 0x02020000
+# ifndef PyExc_StopIteration
+#  define PyExc_StopIteration PyExc_RuntimeError
+# endif
+# ifndef PyObject_GenericGetAttr
+#  define PyObject_GenericGetAttr 0
+# endif
+#endif
+/* Py_NotImplemented is defined in 2.1 and up. */
+#if PY_VERSION_HEX &lt; 0x02010000
+# ifndef Py_NotImplemented
+#  define Py_NotImplemented PyExc_RuntimeError
+# endif
+#endif
+
+
+/* A crude PyString_AsStringAndSize implementation for old Pythons */
+#if PY_VERSION_HEX &lt; 0x02010000
+# ifndef PyString_AsStringAndSize
+#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
+# endif
+#endif
+
+/* PySequence_Size for old Pythons */
+#if PY_VERSION_HEX &lt; 0x02000000
+# ifndef PySequence_Size
+#  define PySequence_Size PySequence_Length
+# endif
+#endif
+
+
+/* PyBool_FromLong for old Pythons */
+#if PY_VERSION_HEX &lt; 0x02030000
+static
+PyObject *PyBool_FromLong(long ok)
+{
+  PyObject *result = ok ? Py_True : Py_False;
+  Py_INCREF(result);
+  return result;
+}
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * error manipulation
+ * ----------------------------------------------------------------------------- */
+
+SWIGRUNTIME PyObject*
+SWIG_Python_ErrorType(int code) {
+  PyObject* type = 0;
+  switch(code) {
+  case SWIG_MemoryError:
+    type = PyExc_MemoryError;
+    break;
+  case SWIG_IOError:
+    type = PyExc_IOError;
+    break;
+  case SWIG_RuntimeError:
+    type = PyExc_RuntimeError;
+    break;
+  case SWIG_IndexError:
+    type = PyExc_IndexError;
+    break;
+  case SWIG_TypeError:
+    type = PyExc_TypeError;
+    break;
+  case SWIG_DivisionByZero:
+    type = PyExc_ZeroDivisionError;
+    break;
+  case SWIG_OverflowError:
+    type = PyExc_OverflowError;
+    break;
+  case SWIG_SyntaxError:
+    type = PyExc_SyntaxError;
+    break;
+  case SWIG_ValueError:
+    type = PyExc_ValueError;
+    break;
+  case SWIG_SystemError:
+    type = PyExc_SystemError;
+    break;
+  case SWIG_AttributeError:
+    type = PyExc_AttributeError;
+    break;
+  default:
+    type = PyExc_RuntimeError;
+  }
+  return type;
+}
+
+
+SWIGRUNTIME void
+SWIG_Python_AddErrorMsg(const char* mesg)
+{
+  PyObject *type = 0;
+  PyObject *value = 0;
+  PyObject *traceback = 0;
+
+  if (PyErr_Occurred()) PyErr_Fetch(&amp;type, &amp;value, &amp;traceback);
+  if (value) {
+    PyObject *old_str = PyObject_Str(value);
+    PyErr_Clear();
+    Py_XINCREF(type);
+    PyErr_Format(type, &quot;%s %s&quot;, PyString_AsString(old_str), mesg);
+    Py_DECREF(old_str);
+    Py_DECREF(value);
+  } else {
+    PyErr_Format(PyExc_RuntimeError, mesg);
+  }
+}
+
+
+
+#if defined(SWIG_PYTHON_NO_THREADS)
+#  if defined(SWIG_PYTHON_THREADS)
+#    undef SWIG_PYTHON_THREADS
+#  endif
+#endif
+#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
+#  if !defined(SWIG_PYTHON_USE_GIL) &amp;&amp; !defined(SWIG_PYTHON_NO_USE_GIL)
+#    if (PY_VERSION_HEX &gt;= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
+#      define SWIG_PYTHON_USE_GIL
+#    endif
+#  endif
+#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
+#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
+#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
+#    endif
+#    ifdef __cplusplus /* C++ code */
+       class SWIG_Python_Thread_Block {
+         bool status;
+         PyGILState_STATE state;
+       public:
+         void end() { if (status) { PyGILState_Release(state); status = false;} }
+         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
+         ~SWIG_Python_Thread_Block() { end(); }
+       };
+       class SWIG_Python_Thread_Allow {
+         bool status;
+         PyThreadState *save;
+       public:
+         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
+         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
+         ~SWIG_Python_Thread_Allow() { end(); }
+       };
+#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
+#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
+#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
+#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
+#    else /* C code */
+#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
+#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
+#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
+#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
+#    endif
+#  else /* Old thread way, not implemented, user must provide it */
+#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
+#      define SWIG_PYTHON_INITIALIZE_THREADS
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
+#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
+#      define SWIG_PYTHON_THREAD_END_BLOCK
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
+#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
+#    endif
+#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
+#      define SWIG_PYTHON_THREAD_END_ALLOW
+#    endif
+#  endif
+#else /* No thread support */
+#  define SWIG_PYTHON_INITIALIZE_THREADS
+#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
+#  define SWIG_PYTHON_THREAD_END_BLOCK
+#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
+#  define SWIG_PYTHON_THREAD_END_ALLOW
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Python API portion that goes into the runtime
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#if 0
+} /* cc-mode */
+#endif
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Constant declarations
+ * ----------------------------------------------------------------------------- */
+
+/* Constant Types */
+#define SWIG_PY_POINTER 4
+#define SWIG_PY_BINARY  5
+
+/* Constant information structure */
+typedef struct swig_const_info {
+  int type;
+  char *name;
+  long lvalue;
+  double dvalue;
+  void   *pvalue;
+  swig_type_info **ptype;
+} swig_const_info;
+
+#ifdef __cplusplus
+#if 0
+{ /* cc-mode */
+#endif
+}
+#endif
+
+
+/* -----------------------------------------------------------------------------
+ * See the LICENSE file for information on copyright, usage and redistribution
+ * of SWIG, and the README file for authors - <A HREF="http://www.swig.org/release.html.">http://www.swig.org/release.html.</A>
+ *
+ * pyrun.swg
+ *
+ * This file contains the runtime support for Python modules
+ * and includes code for managing global variables and pointer
+ * type checking.
+ *
+ * ----------------------------------------------------------------------------- */
+
+/* Common SWIG API */
+
+/* for raw pointers */
+#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
+#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
+#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
+#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(ptr, type, flags)
+#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
+#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
+#define swig_owntype                                    int
+
+/* for raw packed data */
+#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
+#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
+
+/* for class or struct pointers */
+#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
+#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)
+
+/* for C or C++ function pointers */
+#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
+#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(ptr, type, 0)
+
+/* for C++ member pointers, ie, member methods */
+#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
+#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)
+
+
+/* Runtime API */
+
+#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule()
+#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
+#define SWIG_NewClientData(obj)                         PySwigClientData_New(obj)
+
+#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
+#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
+#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
+#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
+#define SWIG_fail                        		goto fail					   
+
+
+/* Runtime API implementation */
+
+/* Error manipulation */
+
+SWIGINTERN void 
+SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
+  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
+  PyErr_SetObject(errtype, obj);
+  Py_DECREF(obj);
+  SWIG_PYTHON_THREAD_END_BLOCK;
+}
+
+SWIGINTERN void 
+SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
+  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
+  PyErr_SetString(errtype, (char *) msg);
+  SWIG_PYTHON_THREAD_END_BLOCK;
+}
+
+#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)
+
+/* Set a constant value */
+
+SWIGINTERN void
+SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
+  PyDict_SetItemString(d, (char*) name, obj);
+  Py_DECREF(obj);                            
+}
+
+/* Append a value to the result obj */
+
+SWIGINTERN PyObject*
+SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
+#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
+  if (!result) {
+    result = obj;
+  } else if (result == Py_None) {
+    Py_DECREF(result);
+    result = obj;
+  } else {
+    if (!PyList_Check(result)) {
+      PyObject *o2 = result;
+      result = PyList_New(1);
+      PyList_SetItem(result, 0, o2);
+    }
+    PyList_Append(result,obj);
+    Py_DECREF(obj);
+  }
+  return result;
+#else
+  PyObject*   o2;
+  PyObject*   o3;
+  if (!result) {
+    result = obj;
+  } else if (result == Py_None) {
+    Py_DECREF(result);
+    result = obj;
+  } else {
+    if (!PyTuple_Check(result)) {
+      o2 = result;
+      result = PyTuple_New(1);
+      PyTuple_SET_ITEM(result, 0, o2);
+    }
+    o3 = PyTuple_New(1);
+    PyTuple_SET_ITEM(o3, 0, obj);
+    o2 = result;
+    result = PySequence_Concat(o2, o3);
+    Py_DECREF(o2);
+    Py_DECREF(o3);
+  }
+  return result;
+#endif
+}
+
+/* Unpack the argument tuple */
+
+SWIGINTERN int
+SWIG_Python_UnpackTuple(PyObject *args, const char *name, int min, int max, PyObject **objs)
+{
+  if (!args) {
+    if (!min &amp;&amp; !max) {
+      return 1;
+    } else {
+      PyErr_Format(PyExc_TypeError, &quot;%s expected %s%d arguments, got none&quot;, 
+		   name, (min == max ? &quot;&quot; : &quot;at least &quot;), min);
+      return 0;
+    }
+  }  
+  if (!PyTuple_Check(args)) {
+    PyErr_SetString(PyExc_SystemError, &quot;UnpackTuple() argument list is not a tuple&quot;);
+    return 0;
+  } else {
+    register int l = PyTuple_GET_SIZE(args);
+    if (l &lt; min) {
+      PyErr_Format(PyExc_TypeError, &quot;%s expected %s%d arguments, got %d&quot;, 
+		   name, (min == max ? &quot;&quot; : &quot;at least &quot;), min, l);
+      return 0;
+    } else if (l &gt; max) {
+      PyErr_Format(PyExc_TypeError, &quot;%s expected %s%d arguments, got %d&quot;, 
+		   name, (min == max ? &quot;&quot; : &quot;at most &quot;), max, l);
+      return 0;
+    } else {
+      register int i;
+      for (i = 0; i &lt; l; ++i) {
+	objs[i] = PyTuple_GET_ITEM(args, i);
+      }
+      for (; l &lt; max; ++l) {
+	objs[l] = 0;
+      }
+      return i + 1;
+    }    
+  }
+}
+
+/* A functor is a function object with one single object argument */
+#if PY_VERSION_HEX &gt;= 0x02020000
+#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
+#else
+#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, &quot;O&quot;, obj);
+#endif
+
+/*
+  Helper for static pointer initialization for both C and C++ code, for example
+  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
+*/
+#ifdef __cplusplus
+#define SWIG_STATIC_POINTER(var)  var
+#else
+#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
+#endif
+
+/* -----------------------------------------------------------------------------
+ * Pointer declarations
+ * ----------------------------------------------------------------------------- */
+
+/* Flags for new pointer objects */
+#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      &lt;&lt; 1)
+#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)
+
+#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   &lt;&lt; 1)
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#if 0
+} /* cc-mode */
+#endif
+#endif
+
+/*  How to access Py_None */
+#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+#  ifndef SWIG_PYTHON_NO_BUILD_NONE
+#    ifndef SWIG_PYTHON_BUILD_NONE
+#      define SWIG_PYTHON_BUILD_NONE
+#    endif
+#  endif
+#endif
+
+#ifdef SWIG_PYTHON_BUILD_NONE
+#  ifdef Py_None
+#   undef Py_None
+#   define Py_None SWIG_Py_None()
+#  endif
+SWIGRUNTIMEINLINE PyObject * 
+_SWIG_Py_None(void)
+{
+  PyObject *none = Py_BuildValue(&quot;&quot;);
+  Py_DECREF(none);
+  return none;
+}
+SWIGRUNTIME PyObject * 
+SWIG_Py_None(void)
+{
+  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
+  return none;
+}
+#endif
+
+/* The python void return value */
+
+SWIGRUNTIMEINLINE PyObject * 
+SWIG_Py_Void(void)
+{
+  PyObject *none = Py_None;
+  Py_INCREF(none);
+  return none;
+}
+
+/* PySwigClientData */
+
+typedef struct {
+  PyObject *klass;
+  PyObject *newraw;
+  PyObject *newargs;
+  PyObject *destroy;
+  int delargs;
+  int implicitconv;
+} PySwigClientData;
+
+SWIGRUNTIMEINLINE int 
+SWIG_Python_CheckImplicit(swig_type_info *ty)
+{
+  PySwigClientData *data = (PySwigClientData *)ty-&gt;clientdata;
+  return data ? data-&gt;implicitconv : 0;
+}
+
+SWIGRUNTIMEINLINE PyObject *
+SWIG_Python_ExceptionType(swig_type_info *desc) {
+  PySwigClientData *data = desc ? (PySwigClientData *) desc-&gt;clientdata : 0;
+  PyObject *klass = data ? data-&gt;klass : 0;
+  return (klass ? klass : PyExc_RuntimeError);
+}
+
+
+SWIGRUNTIME PySwigClientData * 
+PySwigClientData_New(PyObject* obj)
+{
+  if (!obj) {
+    return 0;
+  } else {
+    PySwigClientData *data = (PySwigClientData *)malloc(sizeof(PySwigClientData));
+    /* the klass element */
+    data-&gt;klass = obj;
+    Py_INCREF(data-&gt;klass);
+    /* the newraw method and newargs arguments used to create a new raw instance */
+    if (PyClass_Check(obj)) {
+      data-&gt;newraw = 0;
+      data-&gt;newargs = obj;
+      Py_INCREF(obj);
+    } else {
+#if (PY_VERSION_HEX &lt; 0x02020000)
+      data-&gt;newraw = 0;
+#else
+      data-&gt;newraw = PyObject_GetAttrString(data-&gt;klass, (char *)&quot;__new__&quot;);
+#endif
+      if (data-&gt;newraw) {
+	Py_INCREF(data-&gt;newraw);
+	data-&gt;newargs = PyTuple_New(1);
+	PyTuple_SetItem(data-&gt;newargs, 0, obj);
+      } else {
+	data-&gt;newargs = obj;
+      }
+      Py_INCREF(data-&gt;newargs);
+    }
+    /* the destroy method, aka as the C++ delete method */
+    data-&gt;destroy = PyObject_GetAttrString(data-&gt;klass, (char *)&quot;__swig_destroy__&quot;);
+    if (PyErr_Occurred()) {
+      PyErr_Clear();
+      data-&gt;destroy = 0;
+    }
+    if (data-&gt;destroy) {
+      int flags;
+      Py_INCREF(data-&gt;destroy);
+      flags = PyCFunction_GET_FLAGS(data-&gt;destroy);
+#ifdef METH_O
+      data-&gt;delargs = !(flags &amp; (METH_O));
+#else
+      data-&gt;delargs = 0;
+#endif
+    } else {
+      data-&gt;delargs = 0;
+    }
+    data-&gt;implicitconv = 0;
+    return data;
+  }
+}
+
+SWIGRUNTIME void 
+PySwigClientData_Del(PySwigClientData* data)
+{
+  Py_XDECREF(data-&gt;newraw);
+  Py_XDECREF(data-&gt;newargs);
+  Py_XDECREF(data-&gt;destroy);
+}
+
+/* =============== PySwigObject =====================*/
+
+typedef struct {
+  PyObject_HEAD
+  void *ptr;
+  swig_type_info *ty;
+  int own;
+  PyObject *next;
+} PySwigObject;
+
+SWIGRUNTIME PyObject *
+PySwigObject_long(PySwigObject *v)
+{
+  return PyLong_FromVoidPtr(v-&gt;ptr);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_format(const char* fmt, PySwigObject *v)
+{
+  PyObject *res = NULL;
+  PyObject *args = PyTuple_New(1);
+  if (args) {
+    if (PyTuple_SetItem(args, 0, PySwigObject_long(v)) == 0) {
+      PyObject *ofmt = PyString_FromString(fmt);
+      if (ofmt) {
+	res = PyString_Format(ofmt,args);
+	Py_DECREF(ofmt);
+      }
+      Py_DECREF(args);
+    }
+  }
+  return res;
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_oct(PySwigObject *v)
+{
+  return PySwigObject_format(&quot;%o&quot;,v);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_hex(PySwigObject *v)
+{
+  return PySwigObject_format(&quot;%x&quot;,v);
+}
+
+SWIGRUNTIME PyObject *
+#ifdef METH_NOARGS
+PySwigObject_repr(PySwigObject *v)
+#else
+PySwigObject_repr(PySwigObject *v, PyObject *args)
+#endif
+{
+  const char *name = SWIG_TypePrettyName(v-&gt;ty);
+  PyObject *hex = PySwigObject_hex(v);    
+  PyObject *repr = PyString_FromFormat(&quot;&lt;Swig Object of type '%s' at 0x%s&gt;&quot;, name, PyString_AsString(hex));
+  Py_DECREF(hex);
+  if (v-&gt;next) {
+#ifdef METH_NOARGS
+    PyObject *nrep = PySwigObject_repr((PySwigObject *)v-&gt;next);
+#else
+    PyObject *nrep = PySwigObject_repr((PySwigObject *)v-&gt;next, args);
+#endif
+    PyString_ConcatAndDel(&amp;repr,nrep);
+  }
+  return repr;  
+}
+
+SWIGRUNTIME int
+PySwigObject_print(PySwigObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
+{
+#ifdef METH_NOARGS
+  PyObject *repr = PySwigObject_repr(v);
+#else
+  PyObject *repr = PySwigObject_repr(v, NULL);
+#endif
+  if (repr) {
+    fputs(PyString_AsString(repr), fp);
+    Py_DECREF(repr);
+    return 0; 
+  } else {
+    return 1; 
+  }
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_str(PySwigObject *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  return SWIG_PackVoidPtr(result, v-&gt;ptr, v-&gt;ty-&gt;name, sizeof(result)) ?
+    PyString_FromString(result) : 0;
+}
+
+SWIGRUNTIME int
+PySwigObject_compare(PySwigObject *v, PySwigObject *w)
+{
+  void *i = v-&gt;ptr;
+  void *j = w-&gt;ptr;
+  return (i &lt; j) ? -1 : ((i &gt; j) ? 1 : 0);
+}
+
+SWIGRUNTIME PyTypeObject* _PySwigObject_type(void);
+
+SWIGRUNTIME PyTypeObject*
+PySwigObject_type(void) {
+  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigObject_type();
+  return type;
+}
+
+SWIGRUNTIMEINLINE int
+PySwigObject_Check(PyObject *op) {
+  return ((op)-&gt;ob_type == PySwigObject_type())
+    || (strcmp((op)-&gt;ob_type-&gt;tp_name,&quot;PySwigObject&quot;) == 0);
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_New(void *ptr, swig_type_info *ty, int own);
+
+SWIGRUNTIME void
+PySwigObject_dealloc(PyObject *v)
+{
+  PySwigObject *sobj = (PySwigObject *) v;
+  PyObject *next = sobj-&gt;next;
+  if (sobj-&gt;own) {
+    swig_type_info *ty = sobj-&gt;ty;
+    PySwigClientData *data = ty ? (PySwigClientData *) ty-&gt;clientdata : 0;
+    PyObject *destroy = data ? data-&gt;destroy : 0;
+    if (destroy) {
+      /* destroy is always a VARARGS method */
+      PyObject *res;
+      if (data-&gt;delargs) {
+	/* we need to create a temporal object to carry the destroy operation */
+	PyObject *tmp = PySwigObject_New(sobj-&gt;ptr, ty, 0);
+	res = SWIG_Python_CallFunctor(destroy, tmp);
+	Py_DECREF(tmp);
+      } else {
+	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
+	PyObject *mself = PyCFunction_GET_SELF(destroy);
+	res = ((*meth)(mself, v));
+      }
+      Py_XDECREF(res);
+    } else {
+      const char *name = SWIG_TypePrettyName(ty);
+#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
+      printf(&quot;swig/python detected a memory leak of type '%s', no destructor found.\n&quot;, name);
+#endif
+    }
+  } 
+  Py_XDECREF(next);
+  PyObject_DEL(v);
+}
+
+SWIGRUNTIME PyObject* 
+PySwigObject_append(PyObject* v, PyObject* next)
+{
+  PySwigObject *sobj = (PySwigObject *) v;
+#ifndef METH_O
+  PyObject *tmp = 0;
+  if (!PyArg_ParseTuple(next,(char *)&quot;O:append&quot;, &amp;tmp)) return NULL;
+  next = tmp;
+#endif
+  if (!PySwigObject_Check(next)) {
+    return NULL;
+  }
+  sobj-&gt;next = next;
+  Py_INCREF(next);
+  return SWIG_Py_Void();
+}
+
+SWIGRUNTIME PyObject* 
+#ifdef METH_NOARGS
+PySwigObject_next(PyObject* v)
+#else
+PySwigObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
+#endif
+{
+  PySwigObject *sobj = (PySwigObject *) v;
+  if (sobj-&gt;next) {    
+    Py_INCREF(sobj-&gt;next);
+    return sobj-&gt;next;
+  } else {
+    return SWIG_Py_Void();
+  }
+}
+
+SWIGINTERN PyObject*
+#ifdef METH_NOARGS
+PySwigObject_disown(PyObject *v)
+#else
+PySwigObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
+#endif
+{
+  PySwigObject *sobj = (PySwigObject *)v;
+  sobj-&gt;own = 0;
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject*
+#ifdef METH_NOARGS
+PySwigObject_acquire(PyObject *v)
+#else
+PySwigObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
+#endif
+{
+  PySwigObject *sobj = (PySwigObject *)v;
+  sobj-&gt;own = SWIG_POINTER_OWN;
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject*
+PySwigObject_own(PyObject *v, PyObject *args)
+{
+  PyObject *val = 0;
+#if (PY_VERSION_HEX &lt; 0x02020000)
+  if (!PyArg_ParseTuple(args,(char *)&quot;|O:own&quot;,&amp;val))
+#else
+  if (!PyArg_UnpackTuple(args, (char *)&quot;own&quot;, 0, 1, &amp;val)) 
+#endif
+    {
+      return NULL;
+    } 
+  else
+    {
+      PySwigObject *sobj = (PySwigObject *)v;
+      PyObject *obj = PyBool_FromLong(sobj-&gt;own);
+      if (val) {
+#ifdef METH_NOARGS
+	if (PyObject_IsTrue(val)) {
+	  PySwigObject_acquire(v);
+	} else {
+	  PySwigObject_disown(v);
+	}
+#else
+	if (PyObject_IsTrue(val)) {
+	  PySwigObject_acquire(v,args);
+	} else {
+	  PySwigObject_disown(v,args);
+	}
+#endif
+      } 
+      return obj;
+    }
+}
+
+#ifdef METH_O
+static PyMethodDef
+swigobject_methods[] = {
+  {(char *)&quot;disown&quot;,  (PyCFunction)PySwigObject_disown,  METH_NOARGS,  (char *)&quot;releases ownership of the pointer&quot;},
+  {(char *)&quot;acquire&quot;, (PyCFunction)PySwigObject_acquire, METH_NOARGS,  (char *)&quot;aquires ownership of the pointer&quot;},
+  {(char *)&quot;own&quot;,     (PyCFunction)PySwigObject_own,     METH_VARARGS, (char *)&quot;returns/sets ownership of the pointer&quot;},
+  {(char *)&quot;append&quot;,  (PyCFunction)PySwigObject_append,  METH_O,       (char *)&quot;appends another 'this' object&quot;},
+  {(char *)&quot;next&quot;,    (PyCFunction)PySwigObject_next,    METH_NOARGS,  (char *)&quot;returns the next 'this' object&quot;},
+  {(char *)&quot;__repr__&quot;,(PyCFunction)PySwigObject_repr,    METH_NOARGS,  (char *)&quot;returns object representation&quot;},
+  {0, 0, 0, 0}  
+};
+#else
+static PyMethodDef
+swigobject_methods[] = {
+  {(char *)&quot;disown&quot;,  (PyCFunction)PySwigObject_disown,  METH_VARARGS,  (char *)&quot;releases ownership of the pointer&quot;},
+  {(char *)&quot;acquire&quot;, (PyCFunction)PySwigObject_acquire, METH_VARARGS,  (char *)&quot;aquires ownership of the pointer&quot;},
+  {(char *)&quot;own&quot;,     (PyCFunction)PySwigObject_own,     METH_VARARGS,  (char *)&quot;returns/sets ownership of the pointer&quot;},
+  {(char *)&quot;append&quot;,  (PyCFunction)PySwigObject_append,  METH_VARARGS,  (char *)&quot;appends another 'this' object&quot;},
+  {(char *)&quot;next&quot;,    (PyCFunction)PySwigObject_next,    METH_VARARGS,  (char *)&quot;returns the next 'this' object&quot;},
+  {(char *)&quot;__repr__&quot;,(PyCFunction)PySwigObject_repr,   METH_VARARGS,  (char *)&quot;returns object representation&quot;},
+  {0, 0, 0, 0}  
+};
+#endif
+
+#if PY_VERSION_HEX &lt; 0x02020000
+SWIGINTERN PyObject *
+PySwigObject_getattr(PySwigObject *sobj,char *name)
+{
+  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
+}
+#endif
+
+SWIGRUNTIME PyTypeObject*
+_PySwigObject_type(void) {
+  static char swigobject_doc[] = &quot;Swig object carries a C/C++ instance pointer&quot;;
+  
+  static PyNumberMethods PySwigObject_as_number = {
+    (binaryfunc)0, /*nb_add*/
+    (binaryfunc)0, /*nb_subtract*/
+    (binaryfunc)0, /*nb_multiply*/
+    (binaryfunc)0, /*nb_divide*/
+    (binaryfunc)0, /*nb_remainder*/
+    (binaryfunc)0, /*nb_divmod*/
+    (ternaryfunc)0,/*nb_power*/
+    (unaryfunc)0,  /*nb_negative*/
+    (unaryfunc)0,  /*nb_positive*/
+    (unaryfunc)0,  /*nb_absolute*/
+    (inquiry)0,    /*nb_nonzero*/
+    0,		   /*nb_invert*/
+    0,		   /*nb_lshift*/
+    0,		   /*nb_rshift*/
+    0,		   /*nb_and*/
+    0,		   /*nb_xor*/
+    0,		   /*nb_or*/
+    (coercion)0,   /*nb_coerce*/
+    (unaryfunc)PySwigObject_long, /*nb_int*/
+    (unaryfunc)PySwigObject_long, /*nb_long*/
+    (unaryfunc)0,                 /*nb_float*/
+    (unaryfunc)PySwigObject_oct,  /*nb_oct*/
+    (unaryfunc)PySwigObject_hex,  /*nb_hex*/
+#if PY_VERSION_HEX &gt;= 0x02020000
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -&gt; nb_inplace_true_divide */ 
+#elif PY_VERSION_HEX &gt;= 0x02000000
+    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -&gt; nb_inplace_or */
+#endif
+  };
+
+  static PyTypeObject pyswigobject_type;  
+  static int type_init = 0;
+  if (!type_init) {
+    const PyTypeObject tmp
+      = {
+	PyObject_HEAD_INIT(NULL)
+	0,				    /* ob_size */
+	(char *)&quot;PySwigObject&quot;,		    /* tp_name */
+	sizeof(PySwigObject),		    /* tp_basicsize */
+	0,			            /* tp_itemsize */
+	(destructor)PySwigObject_dealloc,   /* tp_dealloc */
+	(printfunc)PySwigObject_print,	    /* tp_print */
+#if PY_VERSION_HEX &lt; 0x02020000
+	(getattrfunc)PySwigObject_getattr,  /* tp_getattr */ 
+#else
+	(getattrfunc)0,			    /* tp_getattr */ 
+#endif
+	(setattrfunc)0,			    /* tp_setattr */ 
+	(cmpfunc)PySwigObject_compare,	    /* tp_compare */ 
+	(reprfunc)PySwigObject_repr,	    /* tp_repr */    
+	&amp;PySwigObject_as_number,	    /* tp_as_number */
+	0,				    /* tp_as_sequence */
+	0,				    /* tp_as_mapping */
+	(hashfunc)0,			    /* tp_hash */
+	(ternaryfunc)0,			    /* tp_call */
+	(reprfunc)PySwigObject_str,	    /* tp_str */
+	PyObject_GenericGetAttr,            /* tp_getattro */
+	0,				    /* tp_setattro */
+	0,		                    /* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
+	swigobject_doc, 	            /* tp_doc */        
+	0,                                  /* tp_traverse */
+	0,                                  /* tp_clear */
+	0,                                  /* tp_richcompare */
+	0,                                  /* tp_weaklistoffset */
+#if PY_VERSION_HEX &gt;= 0x02020000
+	0,                                  /* tp_iter */
+	0,                                  /* tp_iternext */
+	swigobject_methods,		    /* tp_methods */ 
+	0,			            /* tp_members */
+	0,				    /* tp_getset */	    	
+	0,			            /* tp_base */	        
+	0,				    /* tp_dict */	    	
+	0,				    /* tp_descr_get */  	
+	0,				    /* tp_descr_set */  	
+	0,				    /* tp_dictoffset */ 	
+	0,				    /* tp_init */	    	
+	0,				    /* tp_alloc */	    	
+	0,			            /* tp_new */	    	
+	0,	                            /* tp_free */	   
+        0,                                  /* tp_is_gc */  
+	0,				    /* tp_bases */   
+	0,				    /* tp_mro */
+	0,				    /* tp_cache */   
+ 	0,				    /* tp_subclasses */
+	0,				    /* tp_weaklist */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02030000
+	0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+	0,0,0,0                             /* tp_alloc -&gt; tp_next */
+#endif
+      };
+    pyswigobject_type = tmp;
+    pyswigobject_type.ob_type = &amp;PyType_Type;
+    type_init = 1;
+  }
+  return &amp;pyswigobject_type;
+}
+
+SWIGRUNTIME PyObject *
+PySwigObject_New(void *ptr, swig_type_info *ty, int own)
+{
+  PySwigObject *sobj = PyObject_NEW(PySwigObject, PySwigObject_type());
+  if (sobj) {
+    sobj-&gt;ptr  = ptr;
+    sobj-&gt;ty   = ty;
+    sobj-&gt;own  = own;
+    sobj-&gt;next = 0;
+  }
+  return (PyObject *)sobj;
+}
+
+/* -----------------------------------------------------------------------------
+ * Implements a simple Swig Packed type, and use it instead of string
+ * ----------------------------------------------------------------------------- */
+
+typedef struct {
+  PyObject_HEAD
+  void *pack;
+  swig_type_info *ty;
+  size_t size;
+} PySwigPacked;
+
+SWIGRUNTIME int
+PySwigPacked_print(PySwigPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
+{
+  char result[SWIG_BUFFER_SIZE];
+  fputs(&quot;&lt;Swig Packed &quot;, fp); 
+  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))) {
+    fputs(&quot;at &quot;, fp); 
+    fputs(result, fp); 
+  }
+  fputs(v-&gt;ty-&gt;name,fp); 
+  fputs(&quot;&gt;&quot;, fp);
+  return 0; 
+}
+  
+SWIGRUNTIME PyObject *
+PySwigPacked_repr(PySwigPacked *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))) {
+    return PyString_FromFormat(&quot;&lt;Swig Packed at %s%s&gt;&quot;, result, v-&gt;ty-&gt;name);
+  } else {
+    return PyString_FromFormat(&quot;&lt;Swig Packed %s&gt;&quot;, v-&gt;ty-&gt;name);
+  }  
+}
+
+SWIGRUNTIME PyObject *
+PySwigPacked_str(PySwigPacked *v)
+{
+  char result[SWIG_BUFFER_SIZE];
+  if (SWIG_PackDataName(result, v-&gt;pack, v-&gt;size, 0, sizeof(result))){
+    return PyString_FromFormat(&quot;%s%s&quot;, result, v-&gt;ty-&gt;name);
+  } else {
+    return PyString_FromString(v-&gt;ty-&gt;name);
+  }  
+}
+
+SWIGRUNTIME int
+PySwigPacked_compare(PySwigPacked *v, PySwigPacked *w)
+{
+  size_t i = v-&gt;size;
+  size_t j = w-&gt;size;
+  int s = (i &lt; j) ? -1 : ((i &gt; j) ? 1 : 0);
+  return s ? s : strncmp((char *)v-&gt;pack, (char *)w-&gt;pack, 2*v-&gt;size);
+}
+
+SWIGRUNTIME PyTypeObject* _PySwigPacked_type(void);
+
+SWIGRUNTIME PyTypeObject*
+PySwigPacked_type(void) {
+  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigPacked_type();
+  return type;
+}
+
+SWIGRUNTIMEINLINE int
+PySwigPacked_Check(PyObject *op) {
+  return ((op)-&gt;ob_type == _PySwigPacked_type()) 
+    || (strcmp((op)-&gt;ob_type-&gt;tp_name,&quot;PySwigPacked&quot;) == 0);
+}
+
+SWIGRUNTIME void
+PySwigPacked_dealloc(PyObject *v)
+{
+  if (PySwigPacked_Check(v)) {
+    PySwigPacked *sobj = (PySwigPacked *) v;
+    free(sobj-&gt;pack);
+  }
+  PyObject_DEL(v);
+}
+
+SWIGRUNTIME PyTypeObject*
+_PySwigPacked_type(void) {
+  static char swigpacked_doc[] = &quot;Swig object carries a C/C++ instance pointer&quot;;
+  static PyTypeObject pyswigpacked_type;
+  static int type_init = 0;  
+  if (!type_init) {
+    const PyTypeObject tmp
+      = {
+	PyObject_HEAD_INIT(NULL)
+	0,				    /* ob_size */	
+	(char *)&quot;PySwigPacked&quot;,		    /* tp_name */	
+	sizeof(PySwigPacked),		    /* tp_basicsize */	
+	0,				    /* tp_itemsize */	
+	(destructor)PySwigPacked_dealloc,   /* tp_dealloc */	
+	(printfunc)PySwigPacked_print,	    /* tp_print */   	
+	(getattrfunc)0,			    /* tp_getattr */ 	
+	(setattrfunc)0,			    /* tp_setattr */ 	
+	(cmpfunc)PySwigPacked_compare,	    /* tp_compare */ 	
+	(reprfunc)PySwigPacked_repr,	    /* tp_repr */    	
+	0,	                            /* tp_as_number */	
+	0,				    /* tp_as_sequence */
+	0,				    /* tp_as_mapping */	
+	(hashfunc)0,			    /* tp_hash */	
+	(ternaryfunc)0,			    /* tp_call */	
+	(reprfunc)PySwigPacked_str,	    /* tp_str */	
+	PyObject_GenericGetAttr,            /* tp_getattro */
+	0,				    /* tp_setattro */
+	0,		                    /* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
+	swigpacked_doc, 	            /* tp_doc */
+	0,                                  /* tp_traverse */
+	0,                                  /* tp_clear */
+	0,                                  /* tp_richcompare */
+	0,                                  /* tp_weaklistoffset */
+#if PY_VERSION_HEX &gt;= 0x02020000
+	0,                                  /* tp_iter */
+	0,                                  /* tp_iternext */
+	0,		                    /* tp_methods */ 
+	0,			            /* tp_members */
+	0,				    /* tp_getset */	    	
+	0,			            /* tp_base */	        
+	0,				    /* tp_dict */	    	
+	0,				    /* tp_descr_get */  	
+	0,				    /* tp_descr_set */  	
+	0,				    /* tp_dictoffset */ 	
+	0,				    /* tp_init */	    	
+	0,				    /* tp_alloc */	    	
+	0,			            /* tp_new */	    	
+	0, 	                            /* tp_free */	   
+        0,                                  /* tp_is_gc */  
+	0,				    /* tp_bases */   
+	0,				    /* tp_mro */
+	0,				    /* tp_cache */   
+ 	0,				    /* tp_subclasses */
+	0,				    /* tp_weaklist */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02030000
+	0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+	0,0,0,0                             /* tp_alloc -&gt; tp_next */
+#endif
+      };
+    pyswigpacked_type = tmp;
+    pyswigpacked_type.ob_type = &amp;PyType_Type;
+    type_init = 1;
+  }
+  return &amp;pyswigpacked_type;
+}
+
+SWIGRUNTIME PyObject *
+PySwigPacked_New(void *ptr, size_t size, swig_type_info *ty)
+{
+  PySwigPacked *sobj = PyObject_NEW(PySwigPacked, PySwigPacked_type());
+  if (sobj) {
+    void *pack = malloc(size);
+    if (pack) {
+      memcpy(pack, ptr, size);
+      sobj-&gt;pack = pack;
+      sobj-&gt;ty   = ty;
+      sobj-&gt;size = size;
+    } else {
+      PyObject_DEL((PyObject *) sobj);
+      sobj = 0;
+    }
+  }
+  return (PyObject *) sobj;
+}
+
+SWIGRUNTIME swig_type_info *
+PySwigPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
+{
+  if (PySwigPacked_Check(obj)) {
+    PySwigPacked *sobj = (PySwigPacked *)obj;
+    if (sobj-&gt;size != size) return 0;
+    memcpy(ptr, sobj-&gt;pack, size);
+    return sobj-&gt;ty;
+  } else {
+    return 0;
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * pointers/data manipulation
+ * ----------------------------------------------------------------------------- */
+
+SWIGRUNTIMEINLINE PyObject *
+_SWIG_This(void)
+{
+  return PyString_FromString(&quot;this&quot;);
+}
+
+SWIGRUNTIME PyObject *
+SWIG_This(void)
+{
+  static PyObject *SWIG_STATIC_POINTER(swig_this) = _SWIG_This();
+  return swig_this;
+}
+
+/* #define SWIG_PYTHON_SLOW_GETSET_THIS */
+
+SWIGRUNTIME PySwigObject *
+SWIG_Python_GetSwigThis(PyObject *pyobj) 
+{
+  if (PySwigObject_Check(pyobj)) {
+    return (PySwigObject *) pyobj;
+  } else {
+    PyObject *obj = 0;
+#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) &amp;&amp; (PY_VERSION_HEX &gt;= 0x02030000))
+    if (PyInstance_Check(pyobj)) {
+      obj = _PyInstance_Lookup(pyobj, SWIG_This());      
+    } else {
+      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
+      if (dictptr != NULL) {
+	PyObject *dict = *dictptr;
+	obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
+      } else {
+#ifdef PyWeakref_CheckProxy
+	if (PyWeakref_CheckProxy(pyobj)) {
+	  PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
+	  return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
+	}
+#endif
+	obj = PyObject_GetAttr(pyobj,SWIG_This());
+	if (obj) {
+	  Py_DECREF(obj);
+	} else {
+	  if (PyErr_Occurred()) PyErr_Clear();
+	  return 0;
+	}
+      }
+    }
+#else
+    obj = PyObject_GetAttr(pyobj,SWIG_This());
+    if (obj) {
+      Py_DECREF(obj);
+    } else {
+      if (PyErr_Occurred()) PyErr_Clear();
+      return 0;
+    }
+#endif
+    if (obj &amp;&amp; !PySwigObject_Check(obj)) {
+      /* a PyObject is called 'this', try to get the 'real this'
+	 PySwigObject from it */ 
+      return SWIG_Python_GetSwigThis(obj);
+    }
+    return (PySwigObject *)obj;
+  }
+}
+
+/* Acquire a pointer value */
+
+SWIGRUNTIME int
+SWIG_Python_AcquirePtr(PyObject *obj, int own) {
+  if (own) {
+    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);
+    if (sobj) {
+      int oldown = sobj-&gt;own;
+      sobj-&gt;own = own;
+      return oldown;
+    }
+  }
+  return 0;
+}
+
+/* Convert a pointer value */
+
+SWIGRUNTIME int
+SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
+  if (!obj) return SWIG_ERROR;
+  if (obj == Py_None) {
+    if (ptr) *ptr = 0;
+    return SWIG_OK;
+  } else {
+    PySwigObject *sobj = SWIG_Python_GetSwigThis(obj);
+    while (sobj) {
+      void *vptr = sobj-&gt;ptr;
+      if (ty) {
+	swig_type_info *to = sobj-&gt;ty;
+	if (to == ty) {
+	  /* no type cast needed */
+	  if (ptr) *ptr = vptr;
+	  break;
+	} else {
+	  swig_cast_info *tc = SWIG_TypeCheck(to-&gt;name,ty);
+	  if (!tc) {
+	    sobj = (PySwigObject *)sobj-&gt;next;
+	  } else {
+	    if (ptr) *ptr = SWIG_TypeCast(tc,vptr);
+	    break;
+	  }
+	}
+      } else {
+	if (ptr) *ptr = vptr;
+	break;
+      }
+    }
+    if (sobj) {
+      if (own) *own = sobj-&gt;own;
+      if (flags &amp; SWIG_POINTER_DISOWN) {
+	sobj-&gt;own = 0;
+      }
+      return SWIG_OK;
+    } else {
+      int res = SWIG_ERROR;
+      if (flags &amp; SWIG_POINTER_IMPLICIT_CONV) {
+	PySwigClientData *data = ty ? (PySwigClientData *) ty-&gt;clientdata : 0;
+	if (data &amp;&amp; !data-&gt;implicitconv) {
+	  PyObject *klass = data-&gt;klass;
+	  if (klass) {
+	    PyObject *impconv;
+	    data-&gt;implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
+	    impconv = SWIG_Python_CallFunctor(klass, obj);
+	    data-&gt;implicitconv = 0;
+	    if (PyErr_Occurred()) {
+	      PyErr_Clear();
+	      impconv = 0;
+	    }
+	    if (impconv) {
+	      PySwigObject *iobj = SWIG_Python_GetSwigThis(impconv);
+	      if (iobj) {
+		void *vptr;
+		res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &amp;vptr, ty, 0, 0);
+		if (SWIG_IsOK(res)) {
+		  if (ptr) {
+		    *ptr = vptr;
+		    /* transfer the ownership to 'ptr' */
+		    iobj-&gt;own = 0;
+		    res = SWIG_AddCast(res);
+		    res = SWIG_AddNewMask(res);
+		  } else {
+		    res = SWIG_AddCast(res);		    
+		  }
+		}
+	      }
+	      Py_DECREF(impconv);
+	    }
+	  }
+	}
+      }
+      return res;
+    }
+  }
+}
+
+/* Convert a function ptr value */
+
+SWIGRUNTIME int
+SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
+  if (!PyCFunction_Check(obj)) {
+    return SWIG_ConvertPtr(obj, ptr, ty, 0);
+  } else {
+    void *vptr = 0;
+    
+    /* here we get the method pointer for callbacks */
+    char *doc = (((PyCFunctionObject *)obj) -&gt; m_ml -&gt; ml_doc);
+    const char *desc = doc ? strstr(doc, &quot;swig_ptr: &quot;) : 0;
+    if (desc) {
+      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &amp;vptr, ty-&gt;name) : 0;
+      if (!desc) return SWIG_ERROR;
+    }
+    if (ty) {
+      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
+      if (!tc) return SWIG_ERROR;
+      *ptr = SWIG_TypeCast(tc,vptr);
+    } else {
+      *ptr = vptr;
+    }
+    return SWIG_OK;
+  }
+}
+
+/* Convert a packed value value */
+
+SWIGRUNTIME int
+SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
+  swig_type_info *to = PySwigPacked_UnpackData(obj, ptr, sz);
+  if (!to) return SWIG_ERROR;
+  if (ty) {
+    if (to != ty) {
+      /* check type cast? */
+      swig_cast_info *tc = SWIG_TypeCheck(to-&gt;name,ty);
+      if (!tc) return SWIG_ERROR;
+    }
+  }
+  return SWIG_OK;
+}  
+
+/* -----------------------------------------------------------------------------
+ * Create a new pointer object
+ * ----------------------------------------------------------------------------- */
+
+/*
+  Create a new instance object, whitout calling __init__, and set the
+  'this' attribute.
+*/
+
+SWIGRUNTIME PyObject* 
+SWIG_Python_NewShadowInstance(PySwigClientData *data, PyObject *swig_this)
+{
+#if (PY_VERSION_HEX &gt;= 0x02020000)
+  PyObject *inst = 0;
+  PyObject *newraw = data-&gt;newraw;
+  if (newraw) {
+    inst = PyObject_Call(newraw, data-&gt;newargs, NULL);
+    if (inst) {
+#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
+      PyObject **dictptr = _PyObject_GetDictPtr(inst);
+      if (dictptr != NULL) {
+	PyObject *dict = *dictptr;
+	if (dict == NULL) {
+	  dict = PyDict_New();
+	  *dictptr = dict;
+	  PyDict_SetItem(dict, SWIG_This(), swig_this);
+	}
+      }
+#else
+      PyObject *key = SWIG_This();
+      PyObject_SetAttr(inst, key, swig_this);
+#endif
+    }
+  } else {
+    PyObject *dict = PyDict_New();
+    PyDict_SetItem(dict, SWIG_This(), swig_this);
+    inst = PyInstance_NewRaw(data-&gt;newargs, dict);
+    Py_DECREF(dict);
+  }
+  return inst;
+#else
+#if (PY_VERSION_HEX &gt;= 0x02010000)
+  PyObject *inst;
+  PyObject *dict = PyDict_New();
+  PyDict_SetItem(dict, SWIG_This(), swig_this);
+  inst = PyInstance_NewRaw(data-&gt;newargs, dict);
+  Py_DECREF(dict);
+  return (PyObject *) inst;
+#else
+  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &amp;PyInstance_Type);
+  if (inst == NULL) {
+    return NULL;
+  }
+  inst-&gt;in_class = (PyClassObject *)data-&gt;newargs;
+  Py_INCREF(inst-&gt;in_class);
+  inst-&gt;in_dict = PyDict_New();
+  if (inst-&gt;in_dict == NULL) {
+    Py_DECREF(inst);
+    return NULL;
+  }
+#ifdef Py_TPFLAGS_HAVE_WEAKREFS
+  inst-&gt;in_weakreflist = NULL;
+#endif
+#ifdef Py_TPFLAGS_GC
+  PyObject_GC_Init(inst);
+#endif
+  PyDict_SetItem(inst-&gt;in_dict, SWIG_This(), swig_this);
+  return (PyObject *) inst;
+#endif
+#endif
+}
+
+SWIGRUNTIME void
+SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
+{
+ PyObject *dict;
+#if (PY_VERSION_HEX &gt;= 0x02020000) &amp;&amp; !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
+ PyObject **dictptr = _PyObject_GetDictPtr(inst);
+ if (dictptr != NULL) {
+   dict = *dictptr;
+   if (dict == NULL) {
+     dict = PyDict_New();
+     *dictptr = dict;
+   }
+   PyDict_SetItem(dict, SWIG_This(), swig_this);
+   return;
+ }
+#endif
+ dict = PyObject_GetAttrString(inst, &quot;__dict__&quot;);
+ PyDict_SetItem(dict, SWIG_This(), swig_this);
+ Py_DECREF(dict);
+} 
+
+
+SWIGINTERN PyObject *
+SWIG_Python_InitShadowInstance(PyObject *args) {
+  PyObject *obj[2];
+  if (!SWIG_Python_UnpackTuple(args,(char*)&quot;swiginit&quot;, 2, 2, obj)) {
+    return NULL;
+  } else {
+    PySwigObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
+    if (sthis) {
+      PySwigObject_append((PyObject*) sthis, obj[1]);
+    } else {
+      SWIG_Python_SetSwigThis(obj[0], obj[1]);
+    }
+    return SWIG_Py_Void();
+  }
+}
+
+/* Create a new pointer object */
+
+SWIGRUNTIME PyObject *
+SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
+  if (!ptr) {
+    return SWIG_Py_Void();
+  } else {
+    int own = (flags &amp; SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
+    PyObject *robj = PySwigObject_New(ptr, type, own);
+    PySwigClientData *clientdata = type ? (PySwigClientData *)(type-&gt;clientdata) : 0;
+    if (clientdata &amp;&amp; !(flags &amp; SWIG_POINTER_NOSHADOW)) {
+      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
+      if (inst) {
+	Py_DECREF(robj);
+	robj = inst;
+      }
+    }
+    return robj;
+  }
+}
+
+/* Create a new packed object */
+
+SWIGRUNTIMEINLINE PyObject *
+SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
+  return ptr ? PySwigPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
+}
+
+/* -----------------------------------------------------------------------------*
+ *  Get type list 
+ * -----------------------------------------------------------------------------*/
+
+#ifdef SWIG_LINK_RUNTIME
+void *SWIG_ReturnGlobalTypeList(void *);
+#endif
+
+SWIGRUNTIME swig_module_info *
+SWIG_Python_GetModule(void) {
+  static void *type_pointer = (void *)0;
+  /* first check if module already created */
+  if (!type_pointer) {
+#ifdef SWIG_LINK_RUNTIME
+    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
+#else
+    type_pointer = PyCObject_Import((char*)&quot;swig_runtime_data&quot; SWIG_RUNTIME_VERSION,
+				    (char*)&quot;type_pointer&quot; SWIG_TYPE_TABLE_NAME);
+    if (PyErr_Occurred()) {
+      PyErr_Clear();
+      type_pointer = (void *)0;
+    }
+#endif
+  }
+  return (swig_module_info *) type_pointer;
+}
+
+#if PY_MAJOR_VERSION &lt; 2
+/* PyModule_AddObject function was introduced in Python 2.0.  The following function
+   is copied out of Python/modsupport.c in python version 2.3.4 */
+SWIGINTERN int
+PyModule_AddObject(PyObject *m, char *name, PyObject *o)
+{
+  PyObject *dict;
+  if (!PyModule_Check(m)) {
+    PyErr_SetString(PyExc_TypeError,
+		    &quot;PyModule_AddObject() needs module as first arg&quot;);
+    return SWIG_ERROR;
+  }
+  if (!o) {
+    PyErr_SetString(PyExc_TypeError,
+		    &quot;PyModule_AddObject() needs non-NULL value&quot;);
+    return SWIG_ERROR;
+  }
+  
+  dict = PyModule_GetDict(m);
+  if (dict == NULL) {
+    /* Internal error -- modules must have a dict! */
+    PyErr_Format(PyExc_SystemError, &quot;module '%s' has no __dict__&quot;,
+		 PyModule_GetName(m));
+    return SWIG_ERROR;
+  }
+  if (PyDict_SetItemString(dict, name, o))
+    return SWIG_ERROR;
+  Py_DECREF(o);
+  return SWIG_OK;
+}
+#endif
+
+SWIGRUNTIME void
+SWIG_Python_DestroyModule(void *vptr)
+{
+  swig_module_info *swig_module = (swig_module_info *) vptr;
+  swig_type_info **types = swig_module-&gt;types;
+  size_t i;
+  for (i =0; i &lt; swig_module-&gt;size; ++i) {
+    swig_type_info *ty = types[i];
+    if (ty-&gt;owndata) {
+      PySwigClientData *data = (PySwigClientData *) ty-&gt;clientdata;
+      if (data) PySwigClientData_Del(data);
+    }
+  }
+  Py_DECREF(SWIG_This());
+}
+
+SWIGRUNTIME void
+SWIG_Python_SetModule(swig_module_info *swig_module) {
+  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */
+
+  PyObject *module = Py_InitModule((char*)&quot;swig_runtime_data&quot; SWIG_RUNTIME_VERSION,
+				   swig_empty_runtime_method_table);
+  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
+  if (pointer &amp;&amp; module) {
+    PyModule_AddObject(module, (char*)&quot;type_pointer&quot; SWIG_TYPE_TABLE_NAME, pointer);
+  } else {
+    Py_XDECREF(pointer);
+  }
+}
+
+/* The python cached type query */
+SWIGRUNTIME PyObject *
+SWIG_Python_TypeCache() {
+  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
+  return cache;
+}
+
+SWIGRUNTIME swig_type_info *
+SWIG_Python_TypeQuery(const char *type)
+{
+  PyObject *cache = SWIG_Python_TypeCache();
+  PyObject *key = PyString_FromString(type); 
+  PyObject *obj = PyDict_GetItem(cache, key);
+  swig_type_info *descriptor;
+  if (obj) {
+    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
+  } else {
+    swig_module_info *swig_module = SWIG_Python_GetModule();
+    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
+    if (descriptor) {
+      obj = PyCObject_FromVoidPtr(descriptor, NULL);
+      PyDict_SetItem(cache, key, obj);
+      Py_DECREF(obj);
+    }
+  }
+  Py_DECREF(key);
+  return descriptor;
+}
+
+/* 
+   For backward compatibility only
+*/
+#define SWIG_POINTER_EXCEPTION  0
+#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
+#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)
+
+SWIGRUNTIME int
+SWIG_Python_AddErrMesg(const char* mesg, int infront)
+{
+  if (PyErr_Occurred()) {
+    PyObject *type = 0;
+    PyObject *value = 0;
+    PyObject *traceback = 0;
+    PyErr_Fetch(&amp;type, &amp;value, &amp;traceback);
+    if (value) {
+      PyObject *old_str = PyObject_Str(value);
+      Py_XINCREF(type);
+      PyErr_Clear();
+      if (infront) {
+	PyErr_Format(type, &quot;%s %s&quot;, mesg, PyString_AsString(old_str));
+      } else {
+	PyErr_Format(type, &quot;%s %s&quot;, PyString_AsString(old_str), mesg);
+      }
+      Py_DECREF(old_str);
+    }
+    return 1;
+  } else {
+    return 0;
+  }
+}
+  
+SWIGRUNTIME int
+SWIG_Python_ArgFail(int argnum)
+{
+  if (PyErr_Occurred()) {
+    /* add information about failing argument */
+    char mesg[256];
+    PyOS_snprintf(mesg, sizeof(mesg), &quot;argument number %d:&quot;, argnum);
+    return SWIG_Python_AddErrMesg(mesg, 1);
+  } else {
+    return 0;
+  }
+}
+
+SWIGRUNTIMEINLINE const char *
+PySwigObject_GetDesc(PyObject *self)
+{
+  PySwigObject *v = (PySwigObject *)self;
+  swig_type_info *ty = v ? v-&gt;ty : 0;
+  return ty ? ty-&gt;str : (char*)&quot;&quot;;
+}
+
+SWIGRUNTIME void
+SWIG_Python_TypeError(const char *type, PyObject *obj)
+{
+  if (type) {
+#if defined(SWIG_COBJECT_TYPES)
+    if (obj &amp;&amp; PySwigObject_Check(obj)) {
+      const char *otype = (const char *) PySwigObject_GetDesc(obj);
+      if (otype) {
+	PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, 'PySwigObject(%s)' is received&quot;,
+		     type, otype);
+	return;
+      }
+    } else 
+#endif      
+    {
+      const char *otype = (obj ? obj-&gt;ob_type-&gt;tp_name : 0); 
+      if (otype) {
+	PyObject *str = PyObject_Str(obj);
+	const char *cstr = str ? PyString_AsString(str) : 0;
+	if (cstr) {
+	  PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, '%s(%s)' is received&quot;,
+		       type, otype, cstr);
+	} else {
+	  PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected, '%s' is received&quot;,
+		       type, otype);
+	}
+	Py_XDECREF(str);
+	return;
+      }
+    }   
+    PyErr_Format(PyExc_TypeError, &quot;a '%s' is expected&quot;, type);
+  } else {
+    PyErr_Format(PyExc_TypeError, &quot;unexpected type is received&quot;);
+  }
+}
+
+
+/* Convert a pointer value, signal an exception on a type mismatch */
+SWIGRUNTIME void *
+SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
+  void *result;
+  if (SWIG_Python_ConvertPtr(obj, &amp;result, ty, flags) == -1) {
+    PyErr_Clear();
+    if (flags &amp; SWIG_POINTER_EXCEPTION) {
+      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
+      SWIG_Python_ArgFail(argnum);
+    }
+  }
+  return result;
+}
+
+
+#ifdef __cplusplus
+#if 0
+{ /* cc-mode */
+#endif
+}
+#endif
+
+
+
+#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 
+
+#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 
+
+
+
+  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 
+
+
+/* -------- TYPES TABLE (BEGIN) -------- */
+
+#define SWIGTYPE_p_DialogApi swig_types[0]
+#define SWIGTYPE_p_EventManager swig_types[1]
+#define SWIGTYPE_p_GameAction swig_types[2]
+#define SWIGTYPE_p_GameConfig swig_types[3]
+#define SWIGTYPE_p_SoundSystem swig_types[4]
+#define SWIGTYPE_p_allocator_type swig_types[5]
+#define SWIGTYPE_p_boost__shared_ptrTSpaceLocation_t swig_types[6]
+#define SWIGTYPE_p_boost__shared_ptrTTGameEvent_t swig_types[7]
+#define SWIGTYPE_p_char swig_types[8]
+#define SWIGTYPE_p_difference_type swig_types[9]
+#define SWIGTYPE_p_p_PyObject swig_types[10]
+#define SWIGTYPE_p_size_type swig_types[11]
+#define SWIGTYPE_p_std__invalid_argument swig_types[12]
+#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t swig_types[13]
+#define SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type swig_types[14]
+#define SWIGTYPE_p_swig__PySwigIterator swig_types[15]
+#define SWIGTYPE_p_value_type swig_types[16]
+static swig_type_info *swig_types[18];
+static swig_module_info swig_module = {swig_types, 17, 0, 0, 0, 0};
+#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&amp;swig_module, &amp;swig_module, name)
+#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&amp;swig_module, &amp;swig_module, name)
+
+/* -------- TYPES TABLE (END) -------- */
+
+#if (PY_VERSION_HEX &lt;= 0x02000000)
+# if !defined(SWIG_PYTHON_CLASSIC)
+#  error &quot;This python version requires to use swig with the '-classic' option&quot;
+# endif
+#endif
+
+/*-----------------------------------------------
+              @(target):= _tml.so
+  ------------------------------------------------*/
+#define SWIG_init    init_tml
+
+#define SWIG_name    &quot;_tml&quot;
+
+#define SWIGVERSION 0x010329 
+
+
+#define SWIG_as_voidptr(a) const_cast&lt; void * &gt;(static_cast&lt; const void * &gt;(a)) 
+#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast&lt; void** &gt;(a)) 
+
+
+#include &lt;stdexcept&gt;
+
+
+namespace swig {
+  class PyObject_ptr {
+  protected:
+    PyObject *_obj;
+
+  public:
+    PyObject_ptr() :_obj(0)
+    {
+    }
+
+    PyObject_ptr(const PyObject_ptr&amp; item) : _obj(item._obj)
+    {
+      Py_XINCREF(_obj);      
+    }
+    
+    PyObject_ptr(PyObject *obj, bool initial_ref = true) :_obj(obj)
+    {
+      if (initial_ref) Py_XINCREF(_obj);
+    }
+    
+    PyObject_ptr &amp; operator=(const PyObject_ptr&amp; item) 
+    {
+      Py_XINCREF(item._obj);
+      Py_XDECREF(_obj);
+      _obj = item._obj;
+      return *this;      
+    }
+    
+    ~PyObject_ptr() 
+    {
+      Py_XDECREF(_obj);
+    }
+    
+    operator PyObject *() const
+    {
+      return _obj;
+    }
+
+    PyObject *operator-&gt;() const
+    {
+      return _obj;
+    }
+  };
+}
+
+
+namespace swig {
+  struct PyObject_var : PyObject_ptr {
+    PyObject_var(PyObject* obj = 0) : PyObject_ptr(obj, false) { }
+    
+    PyObject_var &amp; operator = (PyObject* obj)
+    {
+      Py_XDECREF(_obj);
+      _obj = obj;
+      return *this;      
+    }
+  };
+}
+
+
+#include &quot;tml/gameaction.h&quot;
+#include &quot;tml/gamedialog.h&quot;
+#include &quot;tml/gameconfig.h&quot;
+#include &quot;tml/eventmanager.h&quot;
+#include &quot;util/sound.h&quot;
+
+
+#include &lt;string&gt;
+
+
+#include &lt;stdexcept&gt;
+
+
+  
+#if defined(__SUNPRO_CC) &amp;&amp; defined(_RWSTD_VER)
+#  define SWIG_STD_NOASSIGN_STL
+#  define SWIG_STD_NOINSERT_TEMPLATE_STL
+#  define SWIG_STD_NOITERATOR_TRAITS_STL
+#endif
+
+#if defined(__GNUC__)
+#  if __GNUC__ == 2 &amp;&amp; __GNUC_MINOR &lt;= 96
+#     define SWIG_STD_NOMODERN_STL
+#  endif
+#endif
+
+
+
+
+#include &lt;string&gt;
+#include &lt;stdexcept&gt;
+
+
+#include &lt;utility&gt;
+
+
+SWIGINTERN swig_type_info*
+SWIG_pchar_descriptor()
+{
+  static int init = 0;
+  static swig_type_info* info = 0;
+  if (!init) {
+    info = SWIG_TypeQuery(&quot;_p_char&quot;);
+    init = 1;
+  }
+  return info;
+}
+
+
+SWIGINTERN int
+SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
+{
+  if (PyString_Check(obj)) {
+    char *cstr; int len;
+    PyString_AsStringAndSize(obj, &amp;cstr, &amp;len);
+    if (cptr)  {
+      if (alloc) {
+	/* 
+	   In python the user should not be able to modify the inner
+	   string representation. To warranty that, if you define
+	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
+	   buffer is always returned.
+
+	   The default behavior is just to return the pointer value,
+	   so, be careful.
+	*/ 
+#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
+	if (*alloc != SWIG_OLDOBJ) 
+#else
+	if (*alloc == SWIG_NEWOBJ) 
+#endif
+	  {
+	    *cptr = reinterpret_cast&lt; char* &gt;(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
+	    *alloc = SWIG_NEWOBJ;
+	  }
+	else {
+	  *cptr = cstr;
+	  *alloc = SWIG_OLDOBJ;
+	}
+      } else {
+	*cptr = PyString_AsString(obj);
+      }
+    }
+    if (psize) *psize = len + 1;
+    return SWIG_OK;
+  } else {
+    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
+    if (pchar_descriptor) {
+      void* vptr = 0;
+      if (SWIG_ConvertPtr(obj, &amp;vptr, pchar_descriptor, 0) == SWIG_OK) {
+	if (cptr) *cptr = (char *) vptr;
+	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
+	if (alloc) *alloc = SWIG_OLDOBJ;
+	return SWIG_OK;
+      }
+    }
+  }
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERN int
+SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
+{
+  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
+  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &amp;buf, &amp;size, &amp;alloc)))) {
+    if (buf) {
+      if (val) *val = new std::string(buf, size - 1);
+      if (alloc == SWIG_NEWOBJ) delete[] buf;
+      return SWIG_NEWOBJ;
+    } else {
+      if (val) *val = 0;
+      return SWIG_OLDOBJ;
+    }
+  } else {
+    static int init = 0;
+    static swig_type_info* descriptor = 0;
+    if (!init) {
+      descriptor = SWIG_TypeQuery(&quot;std::string&quot; &quot; *&quot;);
+      init = 1;
+    }
+    if (descriptor) {
+      std::string *vptr;
+      int res = SWIG_ConvertPtr(obj, (void**)&amp;vptr, descriptor, 0);
+      if (SWIG_IsOK(res) &amp;&amp; val) *val = vptr;
+      return res;
+    }
+  }
+  return SWIG_ERROR;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_double (PyObject *obj, double *val)
+{
+  int res = SWIG_TypeError;
+  if (PyFloat_Check(obj)) {
+    if (val) *val = PyFloat_AsDouble(obj);
+    return SWIG_OK;
+  } else if (PyInt_Check(obj)) {
+    if (val) *val = PyInt_AsLong(obj);
+    return SWIG_OK;
+  } else if (PyLong_Check(obj)) {
+    double v = PyLong_AsDouble(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      PyErr_Clear();
+    }
+  }
+#ifdef SWIG_PYTHON_CAST_MODE
+  {
+    int dispatch = 0;
+    double d = PyFloat_AsDouble(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = d;
+      return SWIG_AddCast(SWIG_OK);
+    } else {
+      PyErr_Clear();
+    }
+    if (!dispatch) {
+      long v = PyLong_AsLong(obj);
+      if (!PyErr_Occurred()) {
+	if (val) *val = v;
+	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
+      } else {
+	PyErr_Clear();
+      }
+    }
+  }
+#endif
+  return res;
+}
+
+
+  #define SWIG_From_long   PyInt_FromLong 
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_int  (int value)
+{    
+  return SWIG_From_long  (value);
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_FromCharPtrAndSize(const char* carray, size_t size)
+{
+  if (carray) {
+    if (size &gt; INT_MAX) {
+      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
+      return pchar_descriptor ? 
+	SWIG_NewPointerObj(const_cast&lt; char * &gt;(carray), pchar_descriptor, 0) : SWIG_Py_Void();
+    } else {
+      return PyString_FromStringAndSize(carray, static_cast&lt; int &gt;(size));
+    }
+  } else {
+    return SWIG_Py_Void();
+  }
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_std_string  (const std::string&amp; s)
+{
+  return SWIG_FromCharPtrAndSize(s.data(), s.size());
+}
+
+
+  #define SWIG_From_double   PyFloat_FromDouble 
+
+
+SWIGINTERNINLINE PyObject*
+  SWIG_From_bool  (bool value)
+{
+  return PyBool_FromLong(value ? 1 : 0);
+}
+
+
+#include &lt;limits.h&gt;
+#ifndef LLONG_MIN
+# define LLONG_MIN	LONG_LONG_MIN
+#endif
+#ifndef LLONG_MAX
+# define LLONG_MAX	LONG_LONG_MAX
+#endif
+#ifndef ULLONG_MAX
+# define ULLONG_MAX	ULONG_LONG_MAX
+#endif
+
+
+#include &lt;float.h&gt;
+
+
+#include &lt;math.h&gt;
+
+
+SWIGINTERNINLINE int
+SWIG_CanCastAsInteger(double *d, double min, double max) {
+  double x = *d;
+  if ((min &lt;= x &amp;&amp; x &lt;= max)) {
+   double fx = floor(x);
+   double cx = ceil(x);
+   double rd =  ((x - fx) &lt; 0.5) ? fx : cx; /* simple rint */
+   if ((errno == EDOM) || (errno == ERANGE)) {
+     errno = 0;
+   } else {
+     double summ, reps, diff;
+     if (rd &lt; x) {
+       diff = x - rd;
+     } else if (rd &gt; x) {
+       diff = rd - x;
+     } else {
+       return 1;
+     }
+     summ = rd + x;
+     reps = diff/summ;
+     if (reps &lt; 8*DBL_EPSILON) {
+       *d = rd;
+       return 1;
+     }
+   }
+  }
+  return 0;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_long (PyObject *obj, long* val)
+{
+  if (PyInt_Check(obj)) {
+    if (val) *val = PyInt_AsLong(obj);
+    return SWIG_OK;
+  } else if (PyLong_Check(obj)) {
+    long v = PyLong_AsLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      PyErr_Clear();
+    }
+  }
+#ifdef SWIG_PYTHON_CAST_MODE
+  {
+    int dispatch = 0;
+    long v = PyInt_AsLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_AddCast(SWIG_OK);
+    } else {
+      PyErr_Clear();
+    }
+    if (!dispatch) {
+      double d;
+      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&amp;d));
+      if (SWIG_IsOK(res) &amp;&amp; SWIG_CanCastAsInteger(&amp;d, LONG_MIN, LONG_MAX)) {
+	if (val) *val = (long)(d);
+	return res;
+      }
+    }
+  }
+#endif
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_int (PyObject * obj, int *val)
+{
+  long v;
+  int res = SWIG_AsVal_long (obj, &amp;v);
+  if (SWIG_IsOK(res)) {
+    if ((v &lt; INT_MIN || v &gt; INT_MAX)) {
+      return SWIG_OverflowError;
+    } else {
+      if (val) *val = static_cast&lt; int &gt;(v);
+    }
+  }  
+  return res;
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_bool (PyObject *obj, bool *val)
+{
+  if (obj == Py_True) {
+    if (val) *val = true;
+    return SWIG_OK;
+  } else if (obj == Py_False) {
+    if (val) *val = false;
+    return SWIG_OK;
+  } else {
+    long v = 0;
+    int res = SWIG_AddCast(SWIG_AsVal_long (obj, val ? &amp;v : 0));
+    if (SWIG_IsOK(res) &amp;&amp; val) *val = v ? true : false;
+    return res;
+  }
+}
+
+
+#include &lt;iostream&gt;
+
+  
+namespace swig {
+  struct stop_iteration {
+  };
+
+  struct PySwigIterator {
+  private:
+    PyObject_ptr _seq;
+
+  protected:
+    PySwigIterator(PyObject *seq) : _seq(seq)
+    {
+    }
+      
+  public:
+    virtual ~PySwigIterator() {}
+
+    // Access iterator method, required by Python
+    virtual PyObject *value() const = 0;
+
+    // Forward iterator method, required by Python
+    virtual PySwigIterator *incr(size_t n = 1) = 0;
+    
+    // Backward iterator method, very common in C++, but not required in Python
+    virtual PySwigIterator *decr(size_t n = 1)
+    {
+      throw stop_iteration();
+    }
+
+    // Random access iterator methods, but not required in Python
+    virtual ptrdiff_t distance(const PySwigIterator &amp;x) const
+    {
+      throw std::invalid_argument(&quot;operation not supported&quot;);
+    }
+
+    virtual bool equal (const PySwigIterator &amp;x) const
+    {
+      throw std::invalid_argument(&quot;operation not supported&quot;);
+    }
+    
+    // C++ common/needed methods
+    virtual PySwigIterator *copy() const = 0;
+
+    PyObject *next()
+    {
+      PyObject *obj = value();
+      incr();
+      return obj;
+    }
+
+    PyObject *previous()
+    {
+      decr();
+      return value();
+    }
+
+    PySwigIterator *advance(ptrdiff_t n)
+    {
+      return  (n &gt; 0) ?  incr(n) : decr(-n);
+    }
+      
+    bool operator == (const PySwigIterator&amp; x)  const
+    {
+      return equal(x);
+    }
+      
+    bool operator != (const PySwigIterator&amp; x) const
+    {
+      return ! operator==(x);
+    }
+      
+    PySwigIterator&amp; operator += (ptrdiff_t n)
+    {
+      return *advance(n);
+    }
+
+    PySwigIterator&amp; operator -= (ptrdiff_t n)
+    {
+      return *advance(-n);
+    }
+      
+    PySwigIterator* operator + (ptrdiff_t n) const
+    {
+      return copy()-&gt;advance(n);
+    }
+
+    PySwigIterator* operator - (ptrdiff_t n) const
+    {
+      return copy()-&gt;advance(-n);
+    }
+      
+    ptrdiff_t operator - (const PySwigIterator&amp; x) const
+    {
+      return x.distance(*this);
+    }
+      
+    static swig_type_info* descriptor() {
+      static int init = 0;
+      static swig_type_info* desc = 0;
+      if (!init) {
+	desc = SWIG_TypeQuery(&quot;swig::PySwigIterator *&quot;);
+	init = 1;
+      }	
+      return desc;
+    }    
+  };
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
+{
+  if (PyInt_Check(obj)) {
+    long v = PyInt_AsLong(obj);
+    if (v &gt;= 0) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      return SWIG_OverflowError;
+    }
+  } else if (PyLong_Check(obj)) {
+    unsigned long v = PyLong_AsUnsignedLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_OK;
+    } else {
+      PyErr_Clear();
+    }
+  }
+#ifdef SWIG_PYTHON_CAST_MODE
+  {
+    int dispatch = 0;
+    unsigned long v = PyLong_AsUnsignedLong(obj);
+    if (!PyErr_Occurred()) {
+      if (val) *val = v;
+      return SWIG_AddCast(SWIG_OK);
+    } else {
+      PyErr_Clear();
+    }
+    if (!dispatch) {
+      double d;
+      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&amp;d));
+      if (SWIG_IsOK(res) &amp;&amp; SWIG_CanCastAsInteger(&amp;d, 0, ULONG_MAX)) {
+	if (val) *val = (unsigned long)(d);
+	return res;
+      }
+    }
+  }
+#endif
+  return SWIG_TypeError;
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_size_t (PyObject * obj, size_t *val)
+{
+  unsigned long v;
+  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &amp;v : 0);
+  if (SWIG_IsOK(res) &amp;&amp; val) *val = static_cast&lt; size_t &gt;(v);
+  return res;
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_ptrdiff_t  (ptrdiff_t value)
+{    
+  return SWIG_From_long  (static_cast&lt; long &gt;(value));
+}
+
+
+SWIGINTERNINLINE int
+SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
+{
+  long v;
+  int res = SWIG_AsVal_long (obj, val ? &amp;v : 0);
+  if (SWIG_IsOK(res) &amp;&amp; val) *val = static_cast&lt; ptrdiff_t &gt;(v);
+  return res;
+}
+
+
+#include &lt;stdexcept&gt;
+
+
+#include &lt;algorithm&gt;
+
+
+#include &lt;vector&gt;
+
+
+namespace swig {  
+  template &lt;class Type&gt;
+  struct noconst_traits {
+    typedef Type noconst_type;
+  };
+
+  template &lt;class Type&gt;
+  struct noconst_traits&lt;const Type&gt; {
+    typedef Type noconst_type;
+  };
+
+  /*
+    type categories
+  */
+  struct pointer_category { };  
+  struct value_category { };
+
+  /*
+    General traits that provides type_name and type_info
+  */
+  template &lt;class Type&gt; struct traits { };
+
+  template &lt;class Type&gt;
+  inline const char* type_name() {
+    return traits&lt;typename noconst_traits&lt;Type &gt;::noconst_type &gt;::type_name();
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_info {
+    static swig_type_info *type_query(std::string name) {
+      name += &quot; *&quot;;
+      return SWIG_TypeQuery(name.c_str());
+    }    
+    static swig_type_info *type_info() {
+      static swig_type_info *info = type_query(type_name&lt;Type&gt;());
+      return info;
+    }
+  };
+
+  template &lt;class Type&gt;
+  inline swig_type_info *type_info() {
+    return traits_info&lt;Type&gt;::type_info();
+  }
+
+  /*
+    Partial specialization for pointers
+  */
+  template &lt;class Type&gt; struct traits &lt;Type *&gt; {
+    typedef pointer_category category;
+    static std::string make_ptr_name(const char* name) {
+      std::string ptrname = name;
+      ptrname += &quot; *&quot;;
+      return ptrname;
+    }    
+    static const char* type_name() {
+      static std::string name = make_ptr_name(swig::type_name&lt;Type&gt;());
+      return name.c_str();
+    }
+  };
+
+  template &lt;class Type, class Category&gt; 
+  struct traits_as { };
+ 
+  template &lt;class Type, class Category&gt; 
+  struct traits_check { };
+
+}
+
+
+namespace swig {  
+  /*
+    Traits that provides the from method
+  */
+  template &lt;class Type&gt; struct traits_from_ptr {
+    static PyObject *from(Type *val, int owner = 0) {
+      return SWIG_NewPointerObj(val, type_info&lt;Type&gt;(), owner);
+    }
+  };
+
+  template &lt;class Type&gt; struct traits_from {
+    static PyObject *from(const Type&amp; val) {
+      return traits_from_ptr&lt;Type&gt;::from(new Type(val), 1);
+    }
+  };
+
+  template &lt;class Type&gt; struct traits_from&lt;Type *&gt; {
+    static PyObject *from(Type* val) {
+      return traits_from_ptr&lt;Type&gt;::from(val, 0);
+    }
+  };
+
+  template &lt;class Type&gt;
+  inline PyObject *from(const Type&amp; val) {
+    return traits_from&lt;Type&gt;::from(val);
+  }
+
+  template &lt;class Type&gt;
+  inline PyObject *from_ptr(Type* val, int owner) {
+    return traits_from_ptr&lt;Type&gt;::from(val, owner);
+  }
+
+  /*
+    Traits that provides the asval/as/check method
+  */
+  template &lt;class Type&gt;
+  struct traits_asptr {   
+    static int asptr(PyObject *obj, Type **val) {
+      Type *p;
+      int res = (SWIG_ConvertPtr(obj, (void**)&amp;p, type_info&lt;Type&gt;(), 0) == SWIG_OK) ? SWIG_OLDOBJ : 0;
+      if (SWIG_IsOK(res)) {
+	if (val) *val = p;
+      }
+      return res;
+    }
+  }; 
+
+  template &lt;class Type&gt;
+  inline int asptr(PyObject *obj, Type **vptr) {
+    return traits_asptr&lt;Type&gt;::asptr(obj, vptr);
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_asval {
+    static int asval(PyObject *obj, Type *val) {
+      if (val) {
+	Type *p = 0;
+	int res = traits_asptr&lt;Type&gt;::asptr(obj, &amp;p);
+	if (!SWIG_IsOK(res)) return res;	
+	if (p) {
+	  typedef typename noconst_traits&lt;Type&gt;::noconst_type noconst_type;
+	  *(const_cast&lt;noconst_type*&gt;(val)) = *p;
+	  if (SWIG_IsNewObj(res)){
+	    delete p;
+	    res = SWIG_DelNewMask(res);
+	  }
+	  return res;
+	} else {
+	  return SWIG_ERROR;
+	}
+      } else {
+	return traits_asptr&lt;Type&gt;::asptr(obj, (Type **)(0));
+      }
+    }
+  };
+
+  template &lt;class Type&gt; struct traits_asval&lt;Type*&gt; {
+    static int asval(PyObject *obj, Type **val) {
+      if (val) {
+        typedef typename noconst_traits&lt;Type&gt;::noconst_type noconst_type;
+        noconst_type *p = 0;
+        int res = traits_asptr&lt;noconst_type&gt;::asptr(obj,  &amp;p);
+        if (SWIG_IsOK(res)) {
+          *(const_cast&lt;noconst_type**&gt;(val)) = p;
+	}
+	return res;
+      } else {
+	return traits_asptr&lt;Type&gt;::asptr(obj, (Type **)(0));
+      }
+    }
+  };
+  
+  template &lt;class Type&gt;
+  inline int asval(PyObject *obj, Type *val) {
+    return traits_asval&lt;Type&gt;::asval(obj, val);
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_as&lt;Type, value_category&gt; {
+    static Type as(PyObject *obj, bool throw_error) {
+      Type v;
+      int res = asval(obj, &amp;v);
+      if (!obj || !SWIG_IsOK(res)) {
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name&lt;Type&gt;());
+	}
+	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
+      }
+      return v;
+    }
+  };
+
+  template &lt;class Type&gt; 
+  struct traits_as&lt;Type, pointer_category&gt; {
+    static Type as(PyObject *obj, bool throw_error) {
+      Type *v = 0;      
+      int res = (obj ? traits_asptr&lt;Type&gt;::asptr(obj, &amp;v) : SWIG_ERROR);
+      if (SWIG_IsOK(res) &amp;&amp; v) {
+	if (SWIG_IsNewObj(res)) {
+	  Type r(*v);
+	  delete v;
+	  return r;
+	} else {
+	  return *v;
+	}
+      } else {
+	// Uninitialized return value, no Type() constructor required.
+	static Type *v_def = (Type*) malloc(sizeof(Type));
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name&lt;Type&gt;());
+	}
+	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
+	memset(v_def,0,sizeof(Type));
+	return *v_def;
+      }
+    }
+  };
+
+  template &lt;class Type&gt; 
+  struct traits_as&lt;Type*, pointer_category&gt; {
+    static Type* as(PyObject *obj, bool throw_error) {
+      Type *v = 0;      
+      int res = (obj ? traits_asptr&lt;Type&gt;::asptr(obj, &amp;v) : SWIG_ERROR);
+      if (SWIG_IsOK(res)) {
+	return v;
+      } else {
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name&lt;Type&gt;());
+	}
+	if (throw_error) throw std::invalid_argument(&quot;bad type&quot;);
+	return 0;
+      }
+    }
+  };
+    
+  template &lt;class Type&gt;
+  inline Type as(PyObject *obj, bool te = false) {
+    return traits_as&lt;Type, typename traits&lt;Type&gt;::category&gt;::as(obj, te);
+  }
+
+  template &lt;class Type&gt; 
+  struct traits_check&lt;Type, value_category&gt; {
+    static bool check(PyObject *obj) {
+      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
+      return SWIG_IsOK(res) ? true : false;
+    }
+  };
+
+  template &lt;class Type&gt; 
+  struct traits_check&lt;Type, pointer_category&gt; {
+    static bool check(PyObject *obj) {
+      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
+      return SWIG_IsOK(res) ? true : false;
+    }
+  };
+
+  template &lt;class Type&gt;
+  inline bool check(PyObject *obj) {
+    return traits_check&lt;Type, typename traits&lt;Type&gt;::category&gt;::check(obj);
+  }
+}
+
+
+#include &lt;functional&gt;
+
+namespace std {
+  template &lt;&gt;
+  struct less &lt;PyObject *&gt;: public binary_function&lt;PyObject *, PyObject *, bool&gt;
+  {
+    bool
+    operator()(PyObject * v, PyObject *w) const
+    { 
+      bool res;
+      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
+      res = PyObject_Compare(v, w) &lt; 0;
+      SWIG_PYTHON_THREAD_END_BLOCK;
+      return res;
+    }
+  };
+
+  template &lt;&gt;
+  struct less &lt;swig::PyObject_ptr&gt;: public binary_function&lt;swig::PyObject_ptr, swig::PyObject_ptr, bool&gt;
+  {
+    bool
+    operator()(const swig::PyObject_ptr&amp; v, const swig::PyObject_ptr&amp; w) const
+    {
+      return std::less&lt;PyObject *&gt;()(v, w);
+    }
+  };
+
+  template &lt;&gt;
+  struct less &lt;swig::PyObject_var&gt;: public binary_function&lt;swig::PyObject_var, swig::PyObject_var, bool&gt;
+  {
+    bool
+    operator()(const swig::PyObject_var&amp; v, const swig::PyObject_var&amp; w) const
+    {
+      return std::less&lt;PyObject *&gt;()(v, w);
+    }
+  };
+
+}
+
+namespace swig {
+  template &lt;&gt; struct traits&lt;PyObject *&gt; {
+    typedef value_category category;
+    static const char* type_name() { return &quot;PyObject *&quot;; }
+  };  
+
+  template &lt;&gt;  struct traits_asval&lt;PyObject * &gt; {   
+    typedef PyObject * value_type;
+    static int asval(PyObject *obj, value_type *val) {
+      if (val) *val = obj;
+      return SWIG_OK;
+    }
+  };
+
+  template &lt;&gt; 
+  struct traits_check&lt;PyObject *, value_category&gt; {
+    static bool check(PyObject *) {
+      return true;
+    }
+  };
+
+  template &lt;&gt;  struct traits_from&lt;PyObject *&gt; {
+    typedef PyObject * value_type;
+    static PyObject *from(const value_type&amp; val) {
+      Py_XINCREF(val);
+      return val;
+    }
+  };
+  
+}
+
+namespace swig {
+  inline size_t
+  check_index(ptrdiff_t i, size_t size, bool insert = false) {
+    if ( i &lt; 0 ) {
+      if ((size_t) (-i) &lt;= size)
+	return (size_t) (i + size);
+    } else if ( (size_t) i &lt; size ) {
+      return (size_t) i;
+    } else if (insert &amp;&amp; ((size_t) i == size)) {
+      return size;
+    }
+    
+    throw std::out_of_range(&quot;index out of range&quot;);
+  }
+
+  inline size_t
+  slice_index(ptrdiff_t i, size_t size) {
+    if ( i &lt; 0 ) {
+      if ((size_t) (-i) &lt;= size) {
+	return (size_t) (i + size);
+      } else {
+	throw std::out_of_range(&quot;index out of range&quot;);
+      }
+    } else {
+      return ( (size_t) i &lt; size ) ? ((size_t) i) : size;
+    }
+  }
+
+  template &lt;class Sequence, class Difference&gt;
+  inline typename Sequence::iterator
+  getpos(Sequence* self, Difference i)  {
+    typename Sequence::iterator pos = self-&gt;begin();
+    std::advance(pos, check_index(i,self-&gt;size()));
+    return pos;
+  }
+
+  template &lt;class Sequence, class Difference&gt;
+  inline typename Sequence::const_iterator
+  cgetpos(const Sequence* self, Difference i)  {
+    typename Sequence::const_iterator pos = self-&gt;begin();
+    std::advance(pos, check_index(i,self-&gt;size()));
+    return pos;
+  }
+
+  template &lt;class Sequence, class Difference&gt;
+  inline Sequence*
+  getslice(const Sequence* self, Difference i, Difference j) {
+    typename Sequence::size_type size = self-&gt;size();
+    typename Sequence::size_type ii = swig::check_index(i, size);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+
+    if (jj &gt; ii) {
+      typename Sequence::const_iterator vb = self-&gt;begin();
+      typename Sequence::const_iterator ve = self-&gt;begin();
+      std::advance(vb,ii);
+      std::advance(ve,jj);
+      return new Sequence(vb, ve);
+    } else {
+      return new Sequence();
+    }
+  }
+
+  template &lt;class Sequence, class Difference, class InputSeq&gt;
+  inline void
+  setslice(Sequence* self, Difference i, Difference j, const InputSeq&amp; v) {
+    typename Sequence::size_type size = self-&gt;size();
+    typename Sequence::size_type ii = swig::check_index(i, size, true);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+    if (jj &lt; ii) jj = ii;
+    size_t ssize = jj - ii;
+    if (ssize &lt;= v.size()) {
+      typename Sequence::iterator sb = self-&gt;begin();
+      typename InputSeq::const_iterator vmid = v.begin();
+      std::advance(sb,ii);
+      std::advance(vmid, jj - ii);
+      self-&gt;insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
+    } else {
+      typename Sequence::iterator sb = self-&gt;begin();
+      typename Sequence::iterator se = self-&gt;begin();
+      std::advance(sb,ii);
+      std::advance(se,jj);
+      self-&gt;erase(sb,se);
+      self-&gt;insert(sb, v.begin(), v.end());
+    }
+  }
+
+  template &lt;class Sequence, class Difference&gt;
+  inline void
+  delslice(Sequence* self, Difference i, Difference j) {
+    typename Sequence::size_type size = self-&gt;size();
+    typename Sequence::size_type ii = swig::check_index(i, size, true);
+    typename Sequence::size_type jj = swig::slice_index(j, size);
+    if (jj &gt; ii) {
+      typename Sequence::iterator sb = self-&gt;begin();
+      typename Sequence::iterator se = self-&gt;begin();
+      std::advance(sb,ii);
+      std::advance(se,jj);
+      self-&gt;erase(sb,se);
+    }
+  }
+}
+
+
+#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
+#include &lt;iterator&gt;
+#else
+namespace std  {
+  template &lt;class Iterator&gt;
+  struct iterator_traits {
+    typedef ptrdiff_t difference_type;
+    typedef typename Iterator::value_type value_type;
+  };
+
+#if defined(__SUNPRO_CC) &amp;&amp; defined(_RWSTD_VER)
+  template &lt;class Iterator, class Category,class T, class Reference, class Pointer, class Distance&gt;
+  struct iterator_traits&lt;__reverse_bi_iterator&lt;Iterator,Category,T,Reference,Pointer,Distance&gt; &gt; {
+    typedef Distance difference_type;
+    typedef T value_type;
+  };
+#endif  
+
+  template &lt;class T&gt;
+  struct iterator_traits&lt;T*&gt; {
+    typedef T value_type;
+    typedef ptrdiff_t difference_type;
+  };
+
+  template&lt;typename _InputIterator&gt;
+  inline typename iterator_traits&lt;_InputIterator&gt;::difference_type
+  distance(_InputIterator __first, _InputIterator __last)
+  {
+    typename iterator_traits&lt;_InputIterator&gt;::difference_type __n = 0;
+    while (__first != __last) {
+      ++__first; ++__n;
+    }
+    return __n;
+  }
+
+} 
+#endif
+
+
+namespace swig {
+  template&lt;typename OutIterator&gt;
+  class PySwigIterator_T :  public PySwigIterator
+  {
+  public:
+    typedef OutIterator out_iterator;
+    typedef typename std::iterator_traits&lt;out_iterator&gt;::value_type value_type;    
+    typedef PySwigIterator_T&lt;out_iterator&gt; self_type;
+
+    PySwigIterator_T(out_iterator curr, PyObject *seq)
+      : PySwigIterator(seq), current(curr)
+    {
+    }
+
+    const out_iterator&amp; get_current() const
+    {
+      return current;
+    }
+
+    
+    bool equal (const PySwigIterator &amp;iter) const
+    {
+      const self_type *iters = dynamic_cast&lt;const self_type *&gt;(&amp;iter);
+      if (iters) {
+	return (current == iters-&gt;get_current());
+      } else {
+	throw std::invalid_argument(&quot;bad iterator type&quot;);
+      }
+    }
+    
+    ptrdiff_t distance(const PySwigIterator &amp;iter) const
+    {
+      const self_type *iters = dynamic_cast&lt;const self_type *&gt;(&amp;iter);
+      if (iters) {
+	return std::distance(current, iters-&gt;get_current());
+      } else {
+	throw std::invalid_argument(&quot;bad iterator type&quot;);
+      }
+    }    
+    
+  protected:
+    out_iterator current;
+  };
+  
+  template &lt;class ValueType&gt;
+  struct from_oper 
+  {
+    typedef const ValueType&amp; argument_type;
+    typedef PyObject *result_type;
+    result_type operator()(argument_type v) const
+    {
+      return swig::from(v);
+    }
+  };
+
+  template&lt;typename OutIterator, 
+	   typename ValueType = typename std::iterator_traits&lt;OutIterator&gt;::value_type,
+	   typename FromOper = from_oper&lt;ValueType&gt; &gt;
+  class PySwigIteratorOpen_T :  public PySwigIterator_T&lt;OutIterator&gt;
+  {
+  public:
+    FromOper from;
+    typedef OutIterator out_iterator;
+    typedef ValueType value_type;
+    typedef PySwigIterator_T&lt;out_iterator&gt;  base;
+    typedef PySwigIteratorOpen_T&lt;OutIterator, ValueType, FromOper&gt; self_type;
+    
+    PySwigIteratorOpen_T(out_iterator curr, PyObject *seq)
+      : PySwigIterator_T&lt;OutIterator&gt;(curr, seq)
+    {
+    }
+    
+    PyObject *value() const {
+      return from(static_cast&lt;const value_type&amp;&gt;(*(base::current)));
+    }
+    
+    PySwigIterator *copy() const
+    {
+      return new self_type(*this);
+    }
+
+    PySwigIterator *incr(size_t n = 1)
+    {
+      while (n--) {
+	++base::current;
+      }
+      return this;
+    }
+
+    PySwigIterator *decr(size_t n = 1)
+    {
+      while (n--) {
+	--base::current;
+      }
+      return this;
+    }
+  };
+
+  template&lt;typename OutIterator, 
+	   typename ValueType = typename std::iterator_traits&lt;OutIterator&gt;::value_type,
+	   typename FromOper = from_oper&lt;ValueType&gt; &gt;
+  class PySwigIteratorClosed_T :  public PySwigIterator_T&lt;OutIterator&gt;
+  {
+  public:
+    FromOper from;
+    typedef OutIterator out_iterator;
+    typedef ValueType value_type;
+    typedef PySwigIterator_T&lt;out_iterator&gt;  base;    
+    typedef PySwigIteratorClosed_T&lt;OutIterator, ValueType, FromOper&gt; self_type;
+    
+    PySwigIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
+      : PySwigIterator_T&lt;OutIterator&gt;(curr, seq), begin(first), end(last)
+    {
+    }
+    
+    PyObject *value() const {
+      if (base::current == end) {
+	throw stop_iteration();
+      } else {
+	return from(static_cast&lt;const value_type&amp;&gt;(*(base::current)));
+      }
+    }
+    
+    PySwigIterator *copy() const
+    {
+      return new self_type(*this);
+    }
+
+    PySwigIterator *incr(size_t n = 1)
+    {
+      while (n--) {
+	if (base::current == end) {
+	  throw stop_iteration();
+	} else {
+	  ++base::current;
+	}
+      }
+      return this;
+    }
+
+    PySwigIterator *decr(size_t n = 1)
+    {
+      while (n--) {
+	if (base::current == begin) {
+	  throw stop_iteration();
+	} else {
+	  --base::current;
+	}
+      }
+      return this;
+    }
+
+  private:
+    out_iterator begin;
+    out_iterator end;
+  };
+
+  template&lt;typename OutIter&gt;
+  inline PySwigIterator*
+  make_output_iterator(const OutIter&amp; current, const OutIter&amp; begin,const OutIter&amp; end, PyObject *seq = 0)
+  {
+    return new PySwigIteratorClosed_T&lt;OutIter&gt;(current, begin, end, seq);
+  }
+
+  template&lt;typename OutIter&gt;
+  inline PySwigIterator*
+  make_output_iterator(const OutIter&amp; current, PyObject *seq = 0)
+  {
+    return new PySwigIteratorOpen_T&lt;OutIter&gt;(current, seq);
+  }
+}
+
+
+namespace swig
+{
+  template &lt;class T&gt;
+  struct PySequence_Ref
+  {
+    PySequence_Ref(PyObject* seq, int index)
+      : _seq(seq), _index(index)
+    {
+    }
+    
+    operator T () const
+    {
+      swig::PyObject_var item = PySequence_GetItem(_seq, _index);
+      try {
+	return swig::as&lt;T&gt;(item, true);
+      } catch (std::exception&amp; e) {
+	char msg[1024];
+	sprintf(msg, &quot;in sequence element %d &quot;, _index);
+	if (!PyErr_Occurred()) {
+	  SWIG_Error(SWIG_TypeError,  swig::type_name&lt;T&gt;());
+	}
+	SWIG_Python_AddErrorMsg(msg);
+	SWIG_Python_AddErrorMsg(e.what());
+	throw;
+      }
+    }
+
+    PySequence_Ref&amp; operator=(const T&amp; v)
+    {
+      PySequence_SetItem(_seq, _index, swig::from&lt;T&gt;(v));
+      return *this;
+    }
+
+  private:
+    PyObject* _seq;
+    int _index;
+  };
+
+  template &lt;class T&gt;
+  struct PySequence_ArrowProxy
+  {
+    PySequence_ArrowProxy(const T&amp; x): m_value(x) {}
+    const T* operator-&gt;() const { return &amp;m_value; }
+    operator const T*() const { return &amp;m_value; }
+    T m_value;
+  };
+
+  template &lt;class T, class Reference &gt;
+  struct PySequence_InputIterator
+  {
+    typedef PySequence_InputIterator&lt;T, Reference &gt; self;
+
+    typedef std::random_access_iterator_tag iterator_category;
+    typedef Reference reference;
+    typedef T value_type;
+    typedef T* pointer;
+    typedef int difference_type;
+
+    PySequence_InputIterator()
+    {
+    }
+
+    PySequence_InputIterator(PyObject* seq, int index)
+      : _seq(seq), _index(index)
+    {
+    }
+
+    reference operator*() const
+    {
+      return reference(_seq, _index);
+    }
+
+    PySequence_ArrowProxy&lt;T&gt;
+    operator-&gt;() const {
+      return PySequence_ArrowProxy&lt;T&gt;(operator*());
+    }
+
+    bool operator==(const self&amp; ri) const
+    {
+      return (_index == ri._index) &amp;&amp; (_seq == ri._seq);
+    }
+
+    bool operator!=(const self&amp; ri) const
+    {
+      return !(operator==(ri));
+    }
+
+    self&amp; operator ++ ()
+    {
+      ++_index;
+      return *this;
+    }
+
+    self&amp; operator -- ()
+    {
+      --_index;
+      return *this;
+    }
+
+    self&amp; operator += (difference_type n)
+    {
+      _index += n;
+      return *this;
+    }
+
+    self operator +(difference_type n) const
+    {
+      return self(_seq, _index + n);
+    }
+
+    self&amp; operator -= (difference_type n)
+    {
+      _index -= n;
+      return *this;
+    }
+
+    self operator -(difference_type n) const
+    {
+      return self(_seq, _index - n);
+    }
+
+    difference_type operator - (const self&amp; ri) const
+    {
+      return _index - ri._index;
+    }
+
+    bool operator &lt; (const self&amp; ri) const
+    {
+      return _index &lt; ri._index;
+    }
+
+    reference
+    operator[](difference_type n) const
+    {
+      return reference(_seq, _index + n);
+    }
+
+  private:
+    PyObject* _seq;
+    difference_type _index;
+  };
+
+  template &lt;class T&gt;
+  struct PySequence_Cont
+  {
+    typedef PySequence_Ref&lt;T&gt; reference;
+    typedef const PySequence_Ref&lt;T&gt; const_reference;
+    typedef T value_type;
+    typedef T* pointer;
+    typedef int difference_type;
+    typedef int size_type;
+    typedef const pointer const_pointer;
+    typedef PySequence_InputIterator&lt;T, reference&gt; iterator;
+    typedef PySequence_InputIterator&lt;T, const_reference&gt; const_iterator;
+
+    PySequence_Cont(PyObject* seq) : _seq(0)
+    {
+      if (!PySequence_Check(seq)) {
+	throw std::invalid_argument(&quot;a sequence is expected&quot;);
+      }
+      _seq = seq;
+      Py_INCREF(_seq);
+    }
+
+    ~PySequence_Cont()
+    {
+      if (_seq) Py_DECREF(_seq);
+    }
+
+    size_type size() const
+    {
+      return PySequence_Size(_seq);
+    }
+
+    bool empty() const
+    {
+      return size() == 0;
+    }
+
+    iterator begin()
+    {
+      return iterator(_seq, 0);
+    }
+
+    const_iterator begin() const
+    {
+      return const_iterator(_seq, 0);
+    }
+
+    iterator end()
+    {
+      return iterator(_seq, size());
+    }
+
+    const_iterator end() const
+    {
+      return const_iterator(_seq, size());
+    }
+
+    reference operator[](difference_type n)
+    {
+      return reference(_seq, n);
+    }
+
+    const_reference operator[](difference_type n)  const
+    {
+      return const_reference(_seq, n);
+    }
+
+    bool check(bool set_err = true) const
+    {
+      int s = size();
+      for (int i = 0; i &lt; s; ++i) {
+	swig::PyObject_var item = PySequence_GetItem(_seq, i);
+	if (!swig::check&lt;value_type&gt;(item)) {
+	  if (set_err) {
+	    char msg[1024];
+	    sprintf(msg, &quot;in sequence element %d&quot;, i);
+	    SWIG_Error(SWIG_RuntimeError, msg);
+	  }
+	  return false;
+	}
+      }
+      return true;
+    }
+
+  private:
+    PyObject* _seq;
+  };
+
+}
+
+
+SWIGINTERN int
+SWIG_AsVal_std_string (PyObject * obj, std::string *val)
+{
+  std::string* v = (std::string *) 0;
+  int res = SWIG_AsPtr_std_string (obj, &amp;v);
+  if (!SWIG_IsOK(res)) return res;
+  if (v) {
+    if (val) *val = *v;
+    if (SWIG_IsNewObj(res)) {
+      delete v;
+      res = SWIG_DelNewMask(res);
+    }
+    return res;
+  }
+  return SWIG_ERROR;
+}
+
+
+namespace swig {
+  template &lt;&gt; struct traits&lt;std::string &gt; {
+    typedef value_category category;
+    static const char* type_name() { return&quot;std::string&quot;; }
+  };  
+  template &lt;&gt;  struct traits_asval&lt;std::string &gt; {   
+    typedef std::string value_type;
+    static int asval(PyObject *obj, value_type *val) { 
+      return SWIG_AsVal_std_string (obj, val);
+    }
+  };
+  template &lt;&gt;  struct traits_from&lt;std::string &gt; {
+    typedef std::string value_type;
+    static PyObject *from(const value_type&amp; val) {
+      return SWIG_From_std_string  (val);
+    }
+  };
+}
+
+
+namespace swig {
+  template &lt;class PySeq, class Seq&gt;
+  inline void
+  assign(const PySeq&amp; pyseq, Seq* seq) {
+#ifdef SWIG_STD_NOASSIGN_STL
+    typedef typename PySeq::value_type value_type;
+    typename PySeq::const_iterator it = pyseq.begin();
+    for (;it != pyseq.end(); ++it) {
+      seq-&gt;insert(seq-&gt;end(),(value_type)(*it));
+    }
+#else
+    seq-&gt;assign(pyseq.begin(), pyseq.end());
+#endif
+  }
+
+  template &lt;class Seq, class T = typename Seq::value_type &gt;
+  struct traits_asptr_stdseq {
+    typedef Seq sequence;
+    typedef T value_type;
+
+    static int asptr(PyObject *obj, sequence **seq) {
+      if (PySequence_Check(obj)) {
+	try {
+	  PySequence_Cont&lt;value_type&gt; pyseq(obj);
+	  if (seq) {
+	    sequence *pseq = new sequence();
+	    assign(pyseq, pseq);
+	    *seq = pseq;
+	    return SWIG_NEWOBJ;
+	  } else {
+	    return pyseq.check() ? SWIG_OK : SWIG_ERROR;
+	  }
+	} catch (std::exception&amp; e) {
+	  if (seq) {
+	    if (!PyErr_Occurred()) {
+	      PyErr_SetString(PyExc_TypeError, e.what());
+	    }
+	  }
+	  return SWIG_ERROR;
+	}
+      } else {
+	sequence *p;
+	if (SWIG_ConvertPtr(obj,(void**)&amp;p,
+			    swig::type_info&lt;sequence&gt;(),0) == SWIG_OK) {
+	  if (seq) *seq = p;
+	  return SWIG_OLDOBJ;
+	}
+      }
+      return SWIG_ERROR;
+    }
+  };
+
+  template &lt;class Seq, class T = typename Seq::value_type &gt;
+  struct traits_from_stdseq {
+    typedef Seq sequence;
+    typedef T value_type;
+    typedef typename Seq::size_type size_type;
+    typedef typename sequence::const_iterator const_iterator;
+
+    static PyObject *from(const sequence&amp; seq) {
+
+
+
+
+
+
+      size_type size = seq.size();
+      if (size &lt;= (size_type)INT_MAX) {
+	PyObject *obj = PyTuple_New((int)size);
+	int i = 0;
+	for (const_iterator it = seq.begin();
+	     it != seq.end(); ++it, ++i) {
+	  PyTuple_SetItem(obj,i,swig::from&lt;value_type&gt;(*it));
+	}
+	return obj;
+      } else {
+	PyErr_SetString(PyExc_OverflowError,&quot;sequence size not valid in python&quot;);
+	return NULL;
+      }
+    }
+  };
+}
+
+
+  namespace swig {
+    template &lt;class T&gt;
+    struct traits_asptr&lt;std::vector&lt;T&gt; &gt;  {
+      static int asptr(PyObject *obj, std::vector&lt;T&gt; **vec) {
+	return traits_asptr_stdseq&lt;std::vector&lt;T&gt; &gt;::asptr(obj, vec);
+      }
+    };
+    
+    template &lt;class T&gt;
+    struct traits_from&lt;std::vector&lt;T&gt; &gt; {
+      static PyObject *from(const std::vector&lt;T&gt;&amp; vec) {
+	return traits_from_stdseq&lt;std::vector&lt;T&gt; &gt;::from(vec);
+      }
+    };
+  }
+
+
+      namespace swig {
+	template &lt;&gt;  struct traits&lt;std::vector&lt;std::string, std::allocator&lt;std::string &gt; &gt; &gt; {
+	  typedef pointer_category category;
+	  static const char* type_name() {
+	    return &quot;std::vector&lt;&quot; &quot;std::string&quot; &quot;,&quot; &quot;std::allocator&lt;std::string &gt;&quot; &quot; &gt;&quot;;
+	  }
+	};
+      }
+    
+SWIGINTERN swig::PySwigIterator *std_vector_Sl_std_string_Sg__iterator(std::vector&lt;std::string &gt; *self,PyObject **PYTHON_SELF){
+      return swig::make_output_iterator(self-&gt;begin(), self-&gt;begin(), self-&gt;end(), *PYTHON_SELF);
+    }
+SWIGINTERN bool std_vector_Sl_std_string_Sg____nonzero__(std::vector&lt;std::string &gt; const *self){
+      return !(self-&gt;empty());
+    }
+SWIGINTERN std::vector&lt;std::string &gt;::size_type std_vector_Sl_std_string_Sg____len__(std::vector&lt;std::string &gt; const *self){
+      return self-&gt;size();
+    }
+
+SWIGINTERNINLINE PyObject* 
+SWIG_From_unsigned_SS_long  (unsigned long value)
+{
+  return (value &gt; LONG_MAX) ?
+    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast&lt; long &gt;(value)); 
+}
+
+
+SWIGINTERNINLINE PyObject *
+SWIG_From_size_t  (size_t value)
+{    
+  return SWIG_From_unsigned_SS_long  (static_cast&lt; unsigned long &gt;(value));
+}
+
+SWIGINTERN std::vector&lt;std::string &gt;::value_type std_vector_Sl_std_string_Sg__pop(std::vector&lt;std::string &gt; *self){
+      if (self-&gt;size() == 0)
+	throw std::out_of_range(&quot;pop from empty container&quot;);
+      std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;::value_type x = self-&gt;back();
+      self-&gt;pop_back();
+      return x;
+    }
+SWIGINTERN std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *std_vector_Sl_std_string_Sg____getslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j){
+      return swig::getslice(self, i, j);
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____setslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j,std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;v){
+      swig::setslice(self, i, j, v);
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____delslice__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::difference_type j){
+      swig::delslice(self, i, j);
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____delitem__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i){
+      self-&gt;erase(swig::getpos(self,i));
+    }
+SWIGINTERN std::vector&lt;std::string &gt;::value_type const &amp;std_vector_Sl_std_string_Sg____getitem__(std::vector&lt;std::string &gt; const *self,std::vector&lt;std::string &gt;::difference_type i){
+      return *(swig::cgetpos(self, i));
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg____setitem__(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::difference_type i,std::vector&lt;std::string &gt;::value_type const &amp;x){
+      *(swig::getpos(self,i)) = x;
+    }
+SWIGINTERN void std_vector_Sl_std_string_Sg__append(std::vector&lt;std::string &gt; *self,std::vector&lt;std::string &gt;::value_type const &amp;x){
+      self-&gt;push_back(x);
+    }
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+SWIGINTERN PyObject *_wrap_GameAction_clean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GameAction_clean&quot;)) SWIG_fail;
+  GameAction::clean();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_system(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_add_system&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_system&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_system&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_add_system&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_add_system&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  GameAction::add_system((std::string const &amp;)*arg1,arg2,arg3);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_planet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_planet&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_planet&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_planet&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;GameAction_add_planet&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_planet&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_add_planet&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;GameAction_add_planet&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  result = (int)GameAction::add_planet((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_orbiter_station(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  std::string *arg3 = 0 ;
+  std::string *arg4 = 0 ;
+  std::string *arg5 = 0 ;
+  std::string *arg6 = 0 ;
+  std::string *arg7 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  int res3 = SWIG_OLDOBJ ;
+  int res4 = SWIG_OLDOBJ ;
+  int res5 = SWIG_OLDOBJ ;
+  int res6 = SWIG_OLDOBJ ;
+  int res7 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  PyObject * obj5 = 0 ;
+  PyObject * obj6 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOOOOO:GameAction_add_orbiter_station&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4,&amp;obj5,&amp;obj6)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg3 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg4 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
+    if (!SWIG_IsOK(res5)) {
+      SWIG_exception_fail(SWIG_ArgError(res5), &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg5 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res6 = SWIG_AsPtr_std_string(obj5, &amp;ptr);
+    if (!SWIG_IsOK(res6)) {
+      SWIG_exception_fail(SWIG_ArgError(res6), &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;6&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;6&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg6 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res7 = SWIG_AsPtr_std_string(obj6, &amp;ptr);
+    if (!SWIG_IsOK(res7)) {
+      SWIG_exception_fail(SWIG_ArgError(res7), &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;7&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_orbiter_station&quot; &quot;', argument &quot; &quot;7&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg7 = ptr;
+  }
+  result = (int)GameAction::add_orbiter_station((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,(std::string const &amp;)*arg3,(std::string const &amp;)*arg4,(std::string const &amp;)*arg5,(std::string const &amp;)*arg6,(std::string const &amp;)*arg7);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  if (SWIG_IsNewObj(res6)) delete arg6;
+  if (SWIG_IsNewObj(res7)) delete arg7;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  if (SWIG_IsNewObj(res6)) delete arg6;
+  if (SWIG_IsNewObj(res7)) delete arg7;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  double arg5 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  double val5 ;
+  int ecode5 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  ecode5 = SWIG_AsVal_double(obj4, &amp;val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg5 = static_cast&lt; double &gt;(val5);
+  result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3,arg4,arg5);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  double arg3 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_add_asteroid&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1,arg2);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_add_asteroid&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_asteroid&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  result = (int)GameAction::add_asteroid((std::string const &amp;)*arg1);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_asteroid(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[6];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_GameAction_add_asteroid__SWIG_4(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_GameAction_add_asteroid__SWIG_3(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_GameAction_add_asteroid__SWIG_2(self, args);
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            return _wrap_GameAction_add_asteroid__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 5) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            {
+              int res = SWIG_AsVal_double(argv[4], NULL);
+              _v = SWIG_CheckState(res);
+            }
+            if (_v) {
+              return _wrap_GameAction_add_asteroid__SWIG_0(self, args);
+            }
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'GameAction_add_asteroid'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_player(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_add_player&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_player&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_player&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;GameAction_add_player&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_player&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_add_player&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;GameAction_add_player&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  result = (int)GameAction::add_player((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_add_ship(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  double arg3 ;
+  double arg4 ;
+  double arg5 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  double val5 ;
+  int ecode5 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOOO:GameAction_add_ship&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_add_ship&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_ship&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;GameAction_add_ship&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_add_ship&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_add_ship&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;GameAction_add_ship&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  ecode5 = SWIG_AsVal_double(obj4, &amp;val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), &quot;in method '&quot; &quot;GameAction_add_ship&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg5 = static_cast&lt; double &gt;(val5);
+  result = (int)GameAction::add_ship((std::string const &amp;)*arg1,(std::string const &amp;)*arg2,arg3,arg4,arg5);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_save_flag__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_save_flag&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_save_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_save_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;GameAction_save_flag&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_save_flag&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  GameAction::save_flag((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_string_flag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_string_flag&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_get_string_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_get_string_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  result = GameAction::get_string_flag((std::string const &amp;)*arg1);
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_save_flag__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double arg2 ;
+  int res1 = SWIG_OLDOBJ ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_save_flag&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_save_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_save_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_save_flag&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  GameAction::save_flag((std::string const &amp;)*arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_save_flag(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_GameAction_save_flag__SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_GameAction_save_flag__SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'GameAction_save_flag'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_double_flag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  double result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_double_flag&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_get_double_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_get_double_flag&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  result = (double)GameAction::get_double_flag((std::string const &amp;)*arg1);
+  resultobj = SWIG_From_double(static_cast&lt; double &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_player_ship_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double result;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_ship_id&quot;)) SWIG_fail;
+  result = (double)GameAction::get_player_ship_id();
+  resultobj = SWIG_From_double(static_cast&lt; double &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_player_star_system(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string result;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_star_system&quot;)) SWIG_fail;
+  result = GameAction::get_player_star_system();
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_target(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_target&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_set_target&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_set_target&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  GameAction::set_target(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_disable_weapon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_disable_weapon&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_disable_weapon&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  GameAction::disable_weapon(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_enable_weapon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_enable_weapon&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_enable_weapon&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  GameAction::enable_weapon(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_go_to_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_go_to_point&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_go_to_point&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_go_to_point&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_go_to_point&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;GameAction_go_to_point&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  result = (int)GameAction::go_to_point(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_go_to_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_go_to_location&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_go_to_location&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_go_to_location&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_go_to_location&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  result = (int)GameAction::go_to_location(arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_guard_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:GameAction_guard_location&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_guard_location&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_guard_location&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_guard_location&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  result = (int)GameAction::guard_location(arg1,arg2,arg3);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_guard_point(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:GameAction_guard_point&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_guard_point&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_guard_point&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;GameAction_guard_point&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;GameAction_guard_point&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  result = (int)GameAction::guard_point(arg1,arg2,arg3,arg4);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_ship_team(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_ship_team&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_set_ship_team&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_set_ship_team&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  GameAction::set_ship_team(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_enemy_team(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_enemy_team&quot;)) SWIG_fail;
+  result = (int)GameAction::get_enemy_team();
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_player_team(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  int result;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GameAction_get_player_team&quot;)) SWIG_fail;
+  result = (int)GameAction::get_player_team();
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_remove_location(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_remove_location&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_remove_location&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  GameAction::remove_location(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_crew(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_set_crew&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_set_crew&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_set_crew&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  GameAction::set_crew(arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_location_pos_x(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_location_pos_x&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_get_location_pos_x&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  result = (int)GameAction::get_location_pos_x(arg1);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_get_location_pos_y(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_get_location_pos_y&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_get_location_pos_y&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  result = (int)GameAction::get_location_pos_y(arg1);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_exist(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  bool result;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_exist&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;GameAction_exist&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  result = (bool)GameAction::exist(arg1);
+  resultobj = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_end_game(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GameAction_end_game&quot;)) SWIG_fail;
+  GameAction::end_game();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_scroll_text(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_scroll_text&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t,  0  | 0);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_scroll_text&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_scroll_text&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;GameAction_scroll_text&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_scroll_text&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  GameAction::scroll_text((std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;)*arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_print_message(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int arg2 ;
+  int res1 = SWIG_OLDOBJ ;
+  int val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:GameAction_print_message&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_print_message&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_print_message&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_int(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;GameAction_print_message&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;int&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; int &gt;(val2);
+  GameAction::print_message((std::string const &amp;)*arg1,arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameAction_set_camera_mode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameAction_set_camera_mode&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameAction_set_camera_mode&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameAction_set_camera_mode&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  GameAction::set_camera_mode((std::string const &amp;)*arg1);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_GameAction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameAction *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:new_GameAction&quot;)) SWIG_fail;
+  result = (GameAction *)new GameAction();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GameAction, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_GameAction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameAction *arg1 = (GameAction *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameAction&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_GameAction, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;delete_GameAction&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;GameAction *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; GameAction * &gt;(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *GameAction_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)&quot;O|swigregister&quot;, &amp;obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_GameAction, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_DialogApi_startDialog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_startDialog&quot;)) SWIG_fail;
+  DialogApi::startDialog();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_endDialog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:DialogApi_endDialog&quot;)) SWIG_fail;
+  DialogApi::endDialog();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_askPlayer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *arg1 = 0 ;
+  int result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_askPlayer&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t,  0  | 0);
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;DialogApi_askPlayer&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;DialogApi_askPlayer&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; * &gt;(argp1);
+  result = (int)DialogApi::askPlayer((std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;)*arg1);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_showText(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int arg2 ;
+  int arg3 ;
+  int arg4 ;
+  int res1 = SWIG_OLDOBJ ;
+  int val2 ;
+  int ecode2 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  int val4 ;
+  int ecode4 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:DialogApi_showText&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;DialogApi_showText&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;DialogApi_showText&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  ecode2 = SWIG_AsVal_int(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;DialogApi_showText&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;int&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; int &gt;(val2);
+  ecode3 = SWIG_AsVal_int(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;DialogApi_showText&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;int&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; int &gt;(val3);
+  ecode4 = SWIG_AsVal_int(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;DialogApi_showText&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;int&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; int &gt;(val4);
+  DialogApi::showText((std::string const &amp;)*arg1,arg2,arg3,arg4);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_DialogApi_showAlienPicture(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:DialogApi_showAlienPicture&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;DialogApi_showAlienPicture&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;DialogApi_showAlienPicture&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  DialogApi::showAlienPicture((std::string const &amp;)*arg1);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_DialogApi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  DialogApi *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:new_DialogApi&quot;)) SWIG_fail;
+  result = (DialogApi *)new DialogApi();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DialogApi, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_DialogApi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  DialogApi *arg1 = (DialogApi *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:delete_DialogApi&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_DialogApi, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;delete_DialogApi&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;DialogApi *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; DialogApi * &gt;(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *DialogApi_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)&quot;O|swigregister&quot;, &amp;obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_DialogApi, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_GameConfig_SetGameDirectory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_SetGameDirectory&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameConfig_SetGameDirectory&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameConfig_SetGameDirectory&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  GameConfig::SetGameDirectory((std::string const &amp;)*arg1);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameConfig_GetGameDirectory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string result;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GameConfig_GetGameDirectory&quot;)) SWIG_fail;
+  result = GameConfig::GetGameDirectory();
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_GameConfig_GetAbsolutePath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string result;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:GameConfig_GetAbsolutePath&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;GameConfig_GetAbsolutePath&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;GameConfig_GetAbsolutePath&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  result = GameConfig::GetAbsolutePath((std::string const &amp;)*arg1);
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_GameConfig(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameConfig *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:new_GameConfig&quot;)) SWIG_fail;
+  result = (GameConfig *)new GameConfig();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GameConfig, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_GameConfig(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  GameConfig *arg1 = (GameConfig *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:delete_GameConfig&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_GameConfig, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;delete_GameConfig&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;GameConfig *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; GameConfig * &gt;(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *GameConfig_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)&quot;O|swigregister&quot;, &amp;obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_GameConfig, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_EventManager_clean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:EventManager_clean&quot;)) SWIG_fail;
+  EventManager::clean();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_setSingleTimeEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_setSingleTimeEvent&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_setSingleTimeEvent&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;EventManager_setSingleTimeEvent&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_setSingleTimeEvent&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::setSingleTimeEvent(arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_setRepeatableTimeEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_setRepeatableTimeEvent&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_setRepeatableTimeEvent&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;EventManager_setRepeatableTimeEvent&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_setRepeatableTimeEvent&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::setRepeatableTimeEvent(arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_disableEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:EventManager_disableEvent&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_disableEvent&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  EventManager::disableEvent(arg1);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_shipDeathById(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathById&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_shipDeathById&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;EventManager_shipDeathById&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_shipDeathById&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::shipDeathById(arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_shipDeathByType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_shipDeathByType&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;EventManager_shipDeathByType&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_shipDeathByType&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;EventManager_shipDeathByType&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_shipDeathByType&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::shipDeathByType((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceMoreThen__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  std::string *arg5 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  int res5 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOOO:EventManager_distanceMoreThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  {
+    std::string *ptr = (std::string *)0;
+    res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
+    if (!SWIG_IsOK(res5)) {
+      SWIG_exception_fail(SWIG_ArgError(res5), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg5 = ptr;
+  }
+  result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceLessThen__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  std::string *arg5 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  int res5 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  PyObject * obj4 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOOO:EventManager_distanceLessThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3,&amp;obj4)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  ecode4 = SWIG_AsVal_double(obj3, &amp;val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg4 = static_cast&lt; double &gt;(val4);
+  {
+    std::string *ptr = (std::string *)0;
+    res5 = SWIG_AsPtr_std_string(obj4, &amp;ptr);
+    if (!SWIG_IsOK(res5)) {
+      SWIG_exception_fail(SWIG_ArgError(res5), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;5&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg5 = ptr;
+  }
+  result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,arg4,(std::string const &amp;)*arg5);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res5)) delete arg5;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceMoreThen__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  std::string *arg4 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:EventManager_distanceMoreThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_distanceMoreThen&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg4 = ptr;
+  }
+  result = (int)EventManager::distanceMoreThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceMoreThen(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[6];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 4) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_EventManager_distanceMoreThen__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 5) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
+            _v = SWIG_CheckState(res);
+            if (_v) {
+              return _wrap_EventManager_distanceMoreThen__SWIG_0(self, args);
+            }
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'EventManager_distanceMoreThen'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceLessThen__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  std::string *arg4 = 0 ;
+  int result;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:EventManager_distanceLessThen&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_distanceLessThen&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg4 = ptr;
+  }
+  result = (int)EventManager::distanceLessThen(arg1,arg2,arg3,(std::string const &amp;)*arg4);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_distanceLessThen(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[6];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 5); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 4) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_EventManager_distanceLessThen__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 5) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            int res = SWIG_AsPtr_std_string(argv[4], (std::string**)(0));
+            _v = SWIG_CheckState(res);
+            if (_v) {
+              return _wrap_EventManager_distanceLessThen__SWIG_0(self, args);
+            }
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'EventManager_distanceLessThen'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_jumpToSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::string *arg1 = 0 ;
+  std::string *arg2 = 0 ;
+  int result;
+  int res1 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_jumpToSystem&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  {
+    std::string *ptr = (std::string *)0;
+    res1 = SWIG_AsPtr_std_string(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;EventManager_jumpToSystem&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_jumpToSystem&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;EventManager_jumpToSystem&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_jumpToSystem&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  result = (int)EventManager::jumpToSystem((std::string const &amp;)*arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_From_int(static_cast&lt; int &gt;(result));
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_EventManager_AddEventCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  double arg1 ;
+  std::string *arg2 = 0 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:EventManager_AddEventCondition&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_double(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;EventManager_AddEventCondition&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; double &gt;(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;EventManager_AddEventCondition&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;EventManager_AddEventCondition&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  EventManager::AddEventCondition(arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_EventManager(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  EventManager *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:new_EventManager&quot;)) SWIG_fail;
+  result = (EventManager *)new EventManager();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventManager, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_EventManager(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  EventManager *arg1 = (EventManager *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:delete_EventManager&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_EventManager, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;delete_EventManager&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;EventManager *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; EventManager * &gt;(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *EventManager_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)&quot;O|swigregister&quot;, &amp;obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_EventManager, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_new_SoundSystem__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  bool arg1 ;
+  SoundSystem *result = 0 ;
+  bool val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:new_SoundSystem&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_bool(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;new_SoundSystem&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;bool&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; bool &gt;(val1);
+  result = (SoundSystem *)new SoundSystem(arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SoundSystem, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_SoundSystem__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:new_SoundSystem&quot;)) SWIG_fail;
+  result = (SoundSystem *)new SoundSystem();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SoundSystem, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_SoundSystem(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 0) {
+    return _wrap_new_SoundSystem__SWIG_1(self, args);
+  }
+  if (argc == 1) {
+    int _v;
+    {
+      int res = SWIG_AsVal_bool(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      return _wrap_new_SoundSystem__SWIG_0(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'new_SoundSystem'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_SoundSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:delete_SoundSystem&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;delete_SoundSystem&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_music__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  int arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:SoundSystem_play_music&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_play_music&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), &quot;in method '&quot; &quot;SoundSystem_play_music&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const&quot;&quot;'&quot;); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  ecode3 = SWIG_AsVal_int(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;SoundSystem_play_music&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;int&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; int &gt;(val3);
+  (arg1)-&gt;play_music(arg2,arg3);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_music__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_play_music&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_play_music&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), &quot;in method '&quot; &quot;SoundSystem_play_music&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const&quot;&quot;'&quot;); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  (arg1)-&gt;play_music(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_music(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_SoundSystem_play_music__SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        {
+          int res = SWIG_AsVal_int(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_SoundSystem_play_music__SWIG_0(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'SoundSystem_play_music'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_sound__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  double arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:SoundSystem_play_sound&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_play_sound&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), &quot;in method '&quot; &quot;SoundSystem_play_sound&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const&quot;&quot;'&quot;); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  ecode3 = SWIG_AsVal_double(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;SoundSystem_play_sound&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; double &gt;(val3);
+  (arg1)-&gt;play_sound(arg2,arg3);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_sound__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_play_sound&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_play_sound&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), &quot;in method '&quot; &quot;SoundSystem_play_sound&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const&quot;&quot;'&quot;); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  (arg1)-&gt;play_sound(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_play_sound(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_SoundSystem_play_sound__SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_SoundSystem, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_SoundSystem_play_sound__SWIG_0(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'SoundSystem_play_sound'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_stop_sound(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_stop_sound&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_stop_sound&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), &quot;in method '&quot; &quot;SoundSystem_stop_sound&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::string const&quot;&quot;'&quot;); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  (arg1)-&gt;stop_sound(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_set_music_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_set_music_volume&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_set_music_volume&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;SoundSystem_set_music_volume&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  (arg1)-&gt;set_music_volume(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_set_sound_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:SoundSystem_set_sound_volume&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_set_sound_volume&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  ecode2 = SWIG_AsVal_double(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;SoundSystem_set_sound_volume&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;double&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; double &gt;(val2);
+  (arg1)-&gt;set_sound_volume(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_load_music_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_music_volume&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_load_music_volume&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  result = (double)(arg1)-&gt;load_music_volume();
+  resultobj = SWIG_From_double(static_cast&lt; double &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_load_sound_volume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  double result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_load_sound_volume&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_load_sound_volume&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  result = (double)(arg1)-&gt;load_sound_volume();
+  resultobj = SWIG_From_double(static_cast&lt; double &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_playing_music(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_playing_music&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  result = (bool)(arg1)-&gt;playing_music();
+  resultobj = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_SoundSystem_playing_music_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *arg1 = (SoundSystem *) 0 ;
+  std::string result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:SoundSystem_playing_music_file&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_SoundSystem, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;SoundSystem_playing_music_file&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;SoundSystem *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; SoundSystem * &gt;(argp1);
+  result = (arg1)-&gt;playing_music_file();
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *SoundSystem_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)&quot;O|swigregister&quot;, &amp;obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_SoundSystem, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN int tw_sound_set(PyObject *_val) {
+  {
+    void *argp = 0;
+    int res = SWIG_ConvertPtr(_val, &amp;argp, SWIGTYPE_p_SoundSystem,  0 );  
+    if (!SWIG_IsOK(res)) {
+      SWIG_exception_fail(SWIG_ArgError(res), &quot;in variable '&quot;&quot;tw_sound&quot;&quot;' of type '&quot;&quot;SoundSystem *&quot;&quot;'&quot;);
+    }
+    tw_sound = reinterpret_cast&lt; SoundSystem * &gt;(argp);
+  }
+  return 0;
+fail:
+  return 1;
+}
+
+
+SWIGINTERN PyObject *tw_sound_get(void) {
+  PyObject *pyobj = 0;
+  
+  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(tw_sound), SWIGTYPE_p_SoundSystem,  0 );
+  return pyobj;
+}
+
+
+SWIGINTERN PyObject *_wrap_GetSoundSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  SoundSystem *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:GetSoundSystem&quot;)) SWIG_fail;
+  result = (SoundSystem *)GetSoundSystem();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SoundSystem, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_PySwigIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:delete_PySwigIterator&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;delete_PySwigIterator&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  PyObject *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:PySwigIterator_value&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_value&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  try {
+    result = (PyObject *)((swig::PySwigIterator const *)arg1)-&gt;value();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_incr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  size_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator_incr&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_incr&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;PySwigIterator_incr&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;size_t&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; size_t &gt;(val2);
+  try {
+    result = (swig::PySwigIterator *)(arg1)-&gt;incr(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_incr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:PySwigIterator_incr&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_incr&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  try {
+    result = (swig::PySwigIterator *)(arg1)-&gt;incr();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_incr(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_PySwigIterator_incr__SWIG_1(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_PySwigIterator_incr__SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'PySwigIterator_incr'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_decr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  size_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator_decr&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_decr&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;PySwigIterator_decr&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;size_t&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; size_t &gt;(val2);
+  try {
+    result = (swig::PySwigIterator *)(arg1)-&gt;decr(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_decr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:PySwigIterator_decr&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_decr&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  try {
+    result = (swig::PySwigIterator *)(arg1)-&gt;decr();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_decr(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_PySwigIterator_decr__SWIG_1(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_PySwigIterator_decr__SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'PySwigIterator_decr'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  ptrdiff_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator_distance&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_distance&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &amp;argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;PySwigIterator_distance&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;PySwigIterator_distance&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  arg2 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp2);
+  try {
+    result = ((swig::PySwigIterator const *)arg1)-&gt;distance((swig::PySwigIterator const &amp;)*arg2);
+  }
+  catch(std::invalid_argument &amp;_e) {
+    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast&lt; const std::invalid_argument&amp; &gt;(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), &quot;std::invalid_argument&quot;, SWIGTYPE_p_std__invalid_argument); SWIG_fail;
+  }
+  
+  resultobj = SWIG_From_ptrdiff_t(static_cast&lt; ptrdiff_t &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator_equal&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_equal&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &amp;argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;PySwigIterator_equal&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;PySwigIterator_equal&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  arg2 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp2);
+  try {
+    result = (bool)((swig::PySwigIterator const *)arg1)-&gt;equal((swig::PySwigIterator const &amp;)*arg2);
+  }
+  catch(std::invalid_argument &amp;_e) {
+    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast&lt; const std::invalid_argument&amp; &gt;(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), &quot;std::invalid_argument&quot;, SWIGTYPE_p_std__invalid_argument); SWIG_fail;
+  }
+  
+  resultobj = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:PySwigIterator_copy&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_copy&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  result = (swig::PySwigIterator *)((swig::PySwigIterator const *)arg1)-&gt;copy();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  PyObject *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:PySwigIterator_next&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_next&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  try {
+    result = (PyObject *)(arg1)-&gt;next();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_previous(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  PyObject *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:PySwigIterator_previous&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_previous&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  try {
+    result = (PyObject *)(arg1)-&gt;previous();
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = result;
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator_advance&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator_advance&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;PySwigIterator_advance&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;ptrdiff_t&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    result = (swig::PySwigIterator *)(arg1)-&gt;advance(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator___eq__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator___eq__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &amp;argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;PySwigIterator___eq__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;PySwigIterator___eq__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  arg2 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp2);
+  result = (bool)((swig::PySwigIterator const *)arg1)-&gt;operator ==((swig::PySwigIterator const &amp;)*arg2);
+  resultobj = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator___ne__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator___ne__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &amp;argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;PySwigIterator___ne__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;PySwigIterator___ne__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  arg2 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp2);
+  result = (bool)((swig::PySwigIterator const *)arg1)-&gt;operator !=((swig::PySwigIterator const &amp;)*arg2);
+  resultobj = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator___iadd__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator___iadd__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;PySwigIterator___iadd__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;ptrdiff_t&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    {
+      swig::PySwigIterator &amp;_result_ref = (arg1)-&gt;operator +=(arg2);
+      result = (swig::PySwigIterator *) &amp;_result_ref;
+    }
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___isub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator___isub__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator___isub__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;PySwigIterator___isub__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;ptrdiff_t&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    {
+      swig::PySwigIterator &amp;_result_ref = (arg1)-&gt;operator -=(arg2);
+      result = (swig::PySwigIterator *) &amp;_result_ref;
+    }
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator___add__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator___add__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;PySwigIterator___add__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;ptrdiff_t&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    result = (swig::PySwigIterator *)((swig::PySwigIterator const *)arg1)-&gt;operator +(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___sub____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  ptrdiff_t arg2 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator___sub__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator___sub__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;PySwigIterator___sub__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;ptrdiff_t&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; ptrdiff_t &gt;(val2);
+  try {
+    result = (swig::PySwigIterator *)((swig::PySwigIterator const *)arg1)-&gt;operator -(arg2);
+  }
+  catch(swig::stop_iteration &amp;_e) {
+    {
+      (void)_e;
+      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
+      SWIG_fail;
+    }
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___sub____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  swig::PySwigIterator *arg1 = (swig::PySwigIterator *) 0 ;
+  swig::PySwigIterator *arg2 = 0 ;
+  ptrdiff_t result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:PySwigIterator___sub__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_swig__PySwigIterator, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;PySwigIterator___sub__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &amp;argp2, SWIGTYPE_p_swig__PySwigIterator,  0  | 0);
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;PySwigIterator___sub__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;PySwigIterator___sub__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;swig::PySwigIterator const &amp;&quot;&quot;'&quot;); 
+  }
+  arg2 = reinterpret_cast&lt; swig::PySwigIterator * &gt;(argp2);
+  result = ((swig::PySwigIterator const *)arg1)-&gt;operator -((swig::PySwigIterator const &amp;)*arg2);
+  resultobj = SWIG_From_ptrdiff_t(static_cast&lt; ptrdiff_t &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_PySwigIterator___sub__(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__PySwigIterator, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_PySwigIterator___sub____SWIG_1(self, args);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &amp;vptr, SWIGTYPE_p_swig__PySwigIterator, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_PySwigIterator___sub____SWIG_0(self, args);
+      }
+    }
+  }
+  
+fail:
+  Py_INCREF(Py_NotImplemented);
+  return Py_NotImplemented;
+}
+
+
+SWIGINTERN PyObject *PySwigIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)&quot;O|swigregister&quot;, &amp;obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_swig__PySwigIterator, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+SWIGINTERN PyObject *_wrap_vectorString_iterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  PyObject **arg2 = (PyObject **) 0 ;
+  swig::PySwigIterator *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  arg2 = &amp;obj0;
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_iterator&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_iterator&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = (swig::PySwigIterator *)std_vector_Sl_std_string_Sg__iterator(arg1,arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__PySwigIterator, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___nonzero__&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___nonzero__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = (bool)std_vector_Sl_std_string_Sg____nonzero__((std::vector&lt;std::string &gt; const *)arg1);
+  resultobj = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::size_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString___len__&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___len__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = std_vector_Sl_std_string_Sg____len__((std::vector&lt;std::string &gt; const *)arg1);
+  resultobj = SWIG_From_size_t(static_cast&lt; size_t &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_pop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::value_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_pop&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  try {
+    result = std_vector_Sl_std_string_Sg__pop(arg1);
+  }
+  catch(std::out_of_range &amp;_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&amp;_e)-&gt;what());
+  }
+  
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___getslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::difference_type arg2 ;
+  std::vector&lt;std::string &gt;::difference_type arg3 ;
+  std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___getslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___getslice__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString___getslice__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val2);
+  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;vectorString___getslice__&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val3);
+  try {
+    result = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)std_vector_Sl_std_string_Sg____getslice__(arg1,arg2,arg3);
+  }
+  catch(std::out_of_range &amp;_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&amp;_e)-&gt;what());
+  }
+  
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___setslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::difference_type arg2 ;
+  std::vector&lt;std::string &gt;::difference_type arg3 ;
+  std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *arg4 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:vectorString___setslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___setslice__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString___setslice__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val2);
+  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;vectorString___setslice__&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val3);
+  {
+    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *ptr = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)0;
+    res4 = swig::asptr(obj3, &amp;ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), &quot;in method '&quot; &quot;vectorString___setslice__&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString___setslice__&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;&quot;&quot;'&quot;); 
+    }
+    arg4 = ptr;
+  }
+  try {
+    std_vector_Sl_std_string_Sg____setslice__(arg1,arg2,arg3,(std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; const &amp;)*arg4);
+  }
+  catch(std::out_of_range &amp;_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&amp;_e)-&gt;what());
+  }
+  catch(std::invalid_argument &amp;_e) {
+    SWIG_exception_fail(SWIG_ValueError, (&amp;_e)-&gt;what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___delslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::difference_type arg2 ;
+  std::vector&lt;std::string &gt;::difference_type arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___delslice__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___delslice__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString___delslice__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val2);
+  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;vectorString___delslice__&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val3);
+  try {
+    std_vector_Sl_std_string_Sg____delslice__(arg1,arg2,arg3);
+  }
+  catch(std::out_of_range &amp;_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&amp;_e)-&gt;what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___delitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::difference_type arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString___delitem__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___delitem__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString___delitem__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val2);
+  try {
+    std_vector_Sl_std_string_Sg____delitem__(arg1,arg2);
+  }
+  catch(std::out_of_range &amp;_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&amp;_e)-&gt;what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___getitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::difference_type arg2 ;
+  std::vector&lt;std::string &gt;::value_type *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString___getitem__&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___getitem__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString___getitem__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val2);
+  try {
+    {
+      std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = std_vector_Sl_std_string_Sg____getitem__((std::vector&lt;std::string &gt; const *)arg1,arg2);
+      result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
+    }
+  }
+  catch(std::out_of_range &amp;_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&amp;_e)-&gt;what());
+  }
+  
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(*result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString___setitem__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::difference_type arg2 ;
+  std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString___setitem__&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString___setitem__&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString___setitem__&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::difference_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::difference_type &gt;(val2);
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), &quot;in method '&quot; &quot;vectorString___setitem__&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString___setitem__&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg3 = ptr;
+  }
+  try {
+    std_vector_Sl_std_string_Sg____setitem__(arg1,arg2,(std::string const &amp;)*arg3);
+  }
+  catch(std::out_of_range &amp;_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&amp;_e)-&gt;what());
+  }
+  
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_append&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_append&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;vectorString_append&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString_append&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  std_vector_Sl_std_string_Sg__append(arg1,(std::string const &amp;)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *result = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;:new_vectorString&quot;)) SWIG_fail;
+  result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;();
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = 0 ;
+  std::vector&lt;std::string &gt; *result = 0 ;
+  int res1 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) SWIG_fail;
+  {
+    std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *ptr = (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *)0;
+    res1 = swig::asptr(obj0, &amp;ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;new_vectorString&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;new_vectorString&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const &amp;&quot;&quot;'&quot;); 
+    }
+    arg1 = ptr;
+  }
+  result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;((std::vector&lt;std::string &gt; const &amp;)*arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  bool result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_empty&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_empty&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = (bool)((std::vector&lt;std::string &gt; const *)arg1)-&gt;empty();
+  resultobj = SWIG_From_bool(static_cast&lt; bool &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::size_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_size&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_size&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;size();
+  resultobj = SWIG_From_size_t(static_cast&lt; size_t &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_clear&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_clear&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  (arg1)-&gt;clear();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt; *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_swap&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_swap&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, &amp;argp2, SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;vectorString_swap&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; &amp;&quot;&quot;'&quot;); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString_swap&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; &amp;&quot;&quot;'&quot;); 
+  }
+  arg2 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp2);
+  (arg1)-&gt;swap(*arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_get_allocator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  SwigValueWrapper&lt;std::allocator&lt;std::string &gt; &gt; result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_get_allocator&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_get_allocator&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;get_allocator();
+  resultobj = SWIG_NewPointerObj((new std::vector&lt;std::string &gt;::allocator_type(static_cast&lt; const std::vector&lt;std::string &gt;::allocator_type&amp; &gt;(result))), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_begin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_begin&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_begin&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = (arg1)-&gt;begin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_begin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::const_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_begin&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_begin&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;begin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::const_iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_begin(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_begin__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_begin__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_begin'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_end__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_end&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_end&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = (arg1)-&gt;end();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_end__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::const_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_end&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_end&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;end();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::const_iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_end(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_end__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_end__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_end'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rbegin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_rbegin&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_rbegin&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = (arg1)-&gt;rbegin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::reverse_iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rbegin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::const_reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_rbegin&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_rbegin&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;rbegin();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::const_reverse_iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rbegin(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rbegin__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rbegin__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_rbegin'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rend__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_rend&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_rend&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = (arg1)-&gt;rend();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::reverse_iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rend__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::const_reverse_iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_rend&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_rend&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;rend();
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::const_reverse_iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_rend(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[2];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 1); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rend__SWIG_0(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_vectorString_rend__SWIG_1(self, args);
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_rend'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt;::size_type arg1 ;
+  std::vector&lt;std::string &gt; *result = 0 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:new_vectorString&quot;,&amp;obj0)) SWIG_fail;
+  ecode1 = SWIG_AsVal_size_t(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;new_vectorString&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::size_type&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; std::vector&lt;std::string &gt;::size_type &gt;(val1);
+  result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_pop_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_pop_back&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_pop_back&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  (arg1)-&gt;pop_back();
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_resize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::size_type arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_resize&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_resize&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString_resize&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::size_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::size_type &gt;(val2);
+  (arg1)-&gt;resize(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::iterator arg2 ;
+  std::vector&lt;std::string &gt;::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_erase&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&amp;iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+  } else {
+    swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *iter_t = dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter2);
+    if (iter_t) {
+      arg2 = iter_t-&gt;get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+    }
+  }
+  result = (arg1)-&gt;erase(arg2);
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::iterator arg2 ;
+  std::vector&lt;std::string &gt;::iterator arg3 ;
+  std::vector&lt;std::string &gt;::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  swig::PySwigIterator *iter3 = 0 ;
+  int res3 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_erase&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&amp;iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+  } else {
+    swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *iter_t = dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter2);
+    if (iter_t) {
+      arg2 = iter_t-&gt;get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+    }
+  }
+  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&amp;iter3), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res3) || !iter3) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+  } else {
+    swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *iter_t = dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter3);
+    if (iter_t) {
+      arg3 = iter_t-&gt;get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_erase&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+    }
+  }
+  result = (arg1)-&gt;erase(arg2,arg3);
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_erase(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&amp;iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) &amp;&amp; iter &amp;&amp; (dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter) != 0));
+      if (_v) {
+        return _wrap_vectorString_erase__SWIG_0(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&amp;iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) &amp;&amp; iter &amp;&amp; (dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter) != 0));
+      if (_v) {
+        swig::PySwigIterator *iter = 0;
+        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&amp;iter), swig::PySwigIterator::descriptor(), 0);
+        _v = (SWIG_IsOK(res) &amp;&amp; iter &amp;&amp; (dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter) != 0));
+        if (_v) {
+          return _wrap_vectorString_erase__SWIG_1(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_erase'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt;::size_type arg1 ;
+  std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
+  std::vector&lt;std::string &gt; *result = 0 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:new_vectorString&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  ecode1 = SWIG_AsVal_size_t(obj0, &amp;val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), &quot;in method '&quot; &quot;new_vectorString&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::size_type&quot;&quot;'&quot;);
+  } 
+  arg1 = static_cast&lt; std::vector&lt;std::string &gt;::size_type &gt;(val1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;new_vectorString&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;new_vectorString&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  result = (std::vector&lt;std::string &gt; *)new std::vector&lt;std::string &gt;(arg1,(std::vector&lt;std::string &gt;::value_type const &amp;)*arg2);
+  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_NEW |  0 );
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_new_vectorString(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[3];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 2); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 0) {
+    return _wrap_new_vectorString__SWIG_0(self, args);
+  }
+  if (argc == 1) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      return _wrap_new_vectorString__SWIG_2(self, args);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_vectorString__SWIG_1(self, args);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_new_vectorString__SWIG_3(self, args);
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'new_vectorString'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_push_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::value_type *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_push_back&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_push_back&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(obj1, &amp;ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), &quot;in method '&quot; &quot;vectorString_push_back&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString_push_back&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg2 = ptr;
+  }
+  (arg1)-&gt;push_back((std::vector&lt;std::string &gt;::value_type const &amp;)*arg2);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_front(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::value_type *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_front&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_front&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  {
+    std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;front();
+    result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
+  }
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(*result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::value_type *result = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_back&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_back&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  {
+    std::vector&lt;std::string &gt;::value_type const &amp;_result_ref = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;back();
+    result = (std::vector&lt;std::string &gt;::value_type *) &amp;_result_ref;
+  }
+  resultobj = SWIG_From_std_string(static_cast&lt; std::string &gt;(*result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_assign(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::size_type arg2 ;
+  std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_assign&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_assign&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString_assign&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::size_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::size_type &gt;(val2);
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), &quot;in method '&quot; &quot;vectorString_assign&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString_assign&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg3 = ptr;
+  }
+  (arg1)-&gt;assign(arg2,(std::vector&lt;std::string &gt;::value_type const &amp;)*arg3);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_resize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::size_type arg2 ;
+  std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_resize&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_resize&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString_resize&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::size_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::size_type &gt;(val2);
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), &quot;in method '&quot; &quot;vectorString_resize&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString_resize&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg3 = ptr;
+  }
+  (arg1)-&gt;resize(arg2,(std::vector&lt;std::string &gt;::value_type const &amp;)*arg3);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_resize(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[4];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 3); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_vectorString_resize__SWIG_0(self, args);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_vectorString_resize__SWIG_1(self, args);
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_resize'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::iterator arg2 ;
+  std::vector&lt;std::string &gt;::value_type *arg3 = 0 ;
+  std::vector&lt;std::string &gt;::iterator result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  int res3 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOO:vectorString_insert&quot;,&amp;obj0,&amp;obj1,&amp;obj2)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&amp;iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+  } else {
+    swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *iter_t = dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter2);
+    if (iter_t) {
+      arg2 = iter_t-&gt;get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+    }
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(obj2, &amp;ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg3 = ptr;
+  }
+  result = (arg1)-&gt;insert(arg2,(std::vector&lt;std::string &gt;::value_type const &amp;)*arg3);
+  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast&lt; const std::vector&lt;std::string &gt;::iterator &amp; &gt;(result)),
+    swig::PySwigIterator::descriptor(),SWIG_POINTER_OWN);
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::iterator arg2 ;
+  std::vector&lt;std::string &gt;::size_type arg3 ;
+  std::vector&lt;std::string &gt;::value_type *arg4 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::PySwigIterator *iter2 = 0 ;
+  int res2 ;
+  size_t val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  PyObject * obj2 = 0 ;
+  PyObject * obj3 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OOOO:vectorString_insert&quot;,&amp;obj0,&amp;obj1,&amp;obj2,&amp;obj3)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&amp;iter2), swig::PySwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+  } else {
+    swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *iter_t = dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter2);
+    if (iter_t) {
+      arg2 = iter_t-&gt;get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::iterator&quot;&quot;'&quot;);
+    }
+  }
+  ecode3 = SWIG_AsVal_size_t(obj2, &amp;val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;3&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::size_type&quot;&quot;'&quot;);
+  } 
+  arg3 = static_cast&lt; std::vector&lt;std::string &gt;::size_type &gt;(val3);
+  {
+    std::string *ptr = (std::string *)0;
+    res4 = SWIG_AsPtr_std_string(obj3, &amp;ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, &quot;invalid null reference &quot; &quot;in method '&quot; &quot;vectorString_insert&quot; &quot;', argument &quot; &quot;4&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::value_type const &amp;&quot;&quot;'&quot;); 
+    }
+    arg4 = ptr;
+  }
+  (arg1)-&gt;insert(arg2,arg3,(std::vector&lt;std::string &gt;::value_type const &amp;)*arg4);
+  resultobj = SWIG_Py_Void();
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return resultobj;
+fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_insert(PyObject *self, PyObject *args) {
+  int argc;
+  PyObject *argv[5];
+  int ii;
+  
+  if (!PyTuple_Check(args)) SWIG_fail;
+  argc = PyObject_Length(args);
+  for (ii = 0; (ii &lt; argc) &amp;&amp; (ii &lt; 4); ii++) {
+    argv[ii] = PyTuple_GET_ITEM(args,ii);
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&amp;iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) &amp;&amp; iter &amp;&amp; (dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter) != 0));
+      if (_v) {
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_vectorString_insert__SWIG_0(self, args);
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt;**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::PySwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&amp;iter), swig::PySwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) &amp;&amp; iter &amp;&amp; (dynamic_cast&lt;swig::PySwigIterator_T&lt;std::vector&lt;std::string &gt;::iterator &gt; *&gt;(iter) != 0));
+      if (_v) {
+        {
+          int res = SWIG_AsVal_size_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_vectorString_insert__SWIG_1(self, args);
+          }
+        }
+      }
+    }
+  }
+  
+fail:
+  SWIG_SetErrorMsg(PyExc_NotImplementedError,&quot;No matching function for overloaded 'vectorString_insert'&quot;);
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_reserve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::size_type arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  PyObject * obj0 = 0 ;
+  PyObject * obj1 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;OO:vectorString_reserve&quot;,&amp;obj0,&amp;obj1)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_reserve&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  ecode2 = SWIG_AsVal_size_t(obj1, &amp;val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), &quot;in method '&quot; &quot;vectorString_reserve&quot; &quot;', argument &quot; &quot;2&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt;::size_type&quot;&quot;'&quot;);
+  } 
+  arg2 = static_cast&lt; std::vector&lt;std::string &gt;::size_type &gt;(val2);
+  (arg1)-&gt;reserve(arg2);
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_vectorString_capacity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  std::vector&lt;std::string &gt;::size_type result;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:vectorString_capacity&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;vectorString_capacity&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; const *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  result = ((std::vector&lt;std::string &gt; const *)arg1)-&gt;capacity();
+  resultobj = SWIG_From_size_t(static_cast&lt; size_t &gt;(result));
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *_wrap_delete_vectorString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *resultobj = 0;
+  std::vector&lt;std::string &gt; *arg1 = (std::vector&lt;std::string &gt; *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  PyObject * obj0 = 0 ;
+  
+  if (!PyArg_ParseTuple(args,(char *)&quot;O:delete_vectorString&quot;,&amp;obj0)) SWIG_fail;
+  res1 = SWIG_ConvertPtr(obj0, &amp;argp1,SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), &quot;in method '&quot; &quot;delete_vectorString&quot; &quot;', argument &quot; &quot;1&quot;&quot; of type '&quot; &quot;std::vector&lt;std::string &gt; *&quot;&quot;'&quot;); 
+  }
+  arg1 = reinterpret_cast&lt; std::vector&lt;std::string &gt; * &gt;(argp1);
+  delete arg1;
+  
+  resultobj = SWIG_Py_Void();
+  return resultobj;
+fail:
+  return NULL;
+}
+
+
+SWIGINTERN PyObject *vectorString_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
+  PyObject *obj;
+  if (!PyArg_ParseTuple(args,(char*)&quot;O|swigregister&quot;, &amp;obj)) return NULL;
+  SWIG_TypeNewClientData(SWIGTYPE_p_std__vectorTstd__string_std__allocatorTstd__string_t_t, SWIG_NewClientData(obj));
+  return SWIG_Py_Void();
+}
+
+static PyMethodDef SwigMethods[] = {
+	 { (char *)&quot;GameAction_clean&quot;, _wrap_GameAction_clean, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_system&quot;, _wrap_GameAction_add_system, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_planet&quot;, _wrap_GameAction_add_planet, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_orbiter_station&quot;, _wrap_GameAction_add_orbiter_station, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_asteroid&quot;, _wrap_GameAction_add_asteroid, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_player&quot;, _wrap_GameAction_add_player, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_add_ship&quot;, _wrap_GameAction_add_ship, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_string_flag&quot;, _wrap_GameAction_get_string_flag, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_save_flag&quot;, _wrap_GameAction_save_flag, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_double_flag&quot;, _wrap_GameAction_get_double_flag, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_player_ship_id&quot;, _wrap_GameAction_get_player_ship_id, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_player_star_system&quot;, _wrap_GameAction_get_player_star_system, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_set_target&quot;, _wrap_GameAction_set_target, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_disable_weapon&quot;, _wrap_GameAction_disable_weapon, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_enable_weapon&quot;, _wrap_GameAction_enable_weapon, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_go_to_point&quot;, _wrap_GameAction_go_to_point, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_go_to_location&quot;, _wrap_GameAction_go_to_location, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_guard_location&quot;, _wrap_GameAction_guard_location, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_guard_point&quot;, _wrap_GameAction_guard_point, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_set_ship_team&quot;, _wrap_GameAction_set_ship_team, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_enemy_team&quot;, _wrap_GameAction_get_enemy_team, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_player_team&quot;, _wrap_GameAction_get_player_team, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_remove_location&quot;, _wrap_GameAction_remove_location, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_set_crew&quot;, _wrap_GameAction_set_crew, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_location_pos_x&quot;, _wrap_GameAction_get_location_pos_x, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_get_location_pos_y&quot;, _wrap_GameAction_get_location_pos_y, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_exist&quot;, _wrap_GameAction_exist, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_end_game&quot;, _wrap_GameAction_end_game, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_scroll_text&quot;, _wrap_GameAction_scroll_text, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_print_message&quot;, _wrap_GameAction_print_message, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_set_camera_mode&quot;, _wrap_GameAction_set_camera_mode, METH_VARARGS, NULL},
+	 { (char *)&quot;new_GameAction&quot;, _wrap_new_GameAction, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_GameAction&quot;, _wrap_delete_GameAction, METH_VARARGS, NULL},
+	 { (char *)&quot;GameAction_swigregister&quot;, GameAction_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_startDialog&quot;, _wrap_DialogApi_startDialog, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_endDialog&quot;, _wrap_DialogApi_endDialog, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_askPlayer&quot;, _wrap_DialogApi_askPlayer, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_showText&quot;, _wrap_DialogApi_showText, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_showAlienPicture&quot;, _wrap_DialogApi_showAlienPicture, METH_VARARGS, NULL},
+	 { (char *)&quot;new_DialogApi&quot;, _wrap_new_DialogApi, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_DialogApi&quot;, _wrap_delete_DialogApi, METH_VARARGS, NULL},
+	 { (char *)&quot;DialogApi_swigregister&quot;, DialogApi_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_SetGameDirectory&quot;, _wrap_GameConfig_SetGameDirectory, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_GetGameDirectory&quot;, _wrap_GameConfig_GetGameDirectory, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_GetAbsolutePath&quot;, _wrap_GameConfig_GetAbsolutePath, METH_VARARGS, NULL},
+	 { (char *)&quot;new_GameConfig&quot;, _wrap_new_GameConfig, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_GameConfig&quot;, _wrap_delete_GameConfig, METH_VARARGS, NULL},
+	 { (char *)&quot;GameConfig_swigregister&quot;, GameConfig_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_clean&quot;, _wrap_EventManager_clean, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_setSingleTimeEvent&quot;, _wrap_EventManager_setSingleTimeEvent, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_setRepeatableTimeEvent&quot;, _wrap_EventManager_setRepeatableTimeEvent, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_disableEvent&quot;, _wrap_EventManager_disableEvent, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_shipDeathById&quot;, _wrap_EventManager_shipDeathById, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_shipDeathByType&quot;, _wrap_EventManager_shipDeathByType, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_distanceMoreThen&quot;, _wrap_EventManager_distanceMoreThen, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_distanceLessThen&quot;, _wrap_EventManager_distanceLessThen, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_jumpToSystem&quot;, _wrap_EventManager_jumpToSystem, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_AddEventCondition&quot;, _wrap_EventManager_AddEventCondition, METH_VARARGS, NULL},
+	 { (char *)&quot;new_EventManager&quot;, _wrap_new_EventManager, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_EventManager&quot;, _wrap_delete_EventManager, METH_VARARGS, NULL},
+	 { (char *)&quot;EventManager_swigregister&quot;, EventManager_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;new_SoundSystem&quot;, _wrap_new_SoundSystem, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_SoundSystem&quot;, _wrap_delete_SoundSystem, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_play_music&quot;, _wrap_SoundSystem_play_music, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_play_sound&quot;, _wrap_SoundSystem_play_sound, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_stop_sound&quot;, _wrap_SoundSystem_stop_sound, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_set_music_volume&quot;, _wrap_SoundSystem_set_music_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_set_sound_volume&quot;, _wrap_SoundSystem_set_sound_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_load_music_volume&quot;, _wrap_SoundSystem_load_music_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_load_sound_volume&quot;, _wrap_SoundSystem_load_sound_volume, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_playing_music&quot;, _wrap_SoundSystem_playing_music, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_playing_music_file&quot;, _wrap_SoundSystem_playing_music_file, METH_VARARGS, NULL},
+	 { (char *)&quot;SoundSystem_swigregister&quot;, SoundSystem_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;GetSoundSystem&quot;, _wrap_GetSoundSystem, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_PySwigIterator&quot;, _wrap_delete_PySwigIterator, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_value&quot;, _wrap_PySwigIterator_value, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_incr&quot;, _wrap_PySwigIterator_incr, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_decr&quot;, _wrap_PySwigIterator_decr, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_distance&quot;, _wrap_PySwigIterator_distance, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_equal&quot;, _wrap_PySwigIterator_equal, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_copy&quot;, _wrap_PySwigIterator_copy, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_next&quot;, _wrap_PySwigIterator_next, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_previous&quot;, _wrap_PySwigIterator_previous, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_advance&quot;, _wrap_PySwigIterator_advance, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator___eq__&quot;, _wrap_PySwigIterator___eq__, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator___ne__&quot;, _wrap_PySwigIterator___ne__, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator___iadd__&quot;, _wrap_PySwigIterator___iadd__, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator___isub__&quot;, _wrap_PySwigIterator___isub__, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator___add__&quot;, _wrap_PySwigIterator___add__, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator___sub__&quot;, _wrap_PySwigIterator___sub__, METH_VARARGS, NULL},
+	 { (char *)&quot;PySwigIterator_swigregister&quot;, PySwigIterator_swigregister, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_iterator&quot;, _wrap_vectorString_iterator, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___nonzero__&quot;, _wrap_vectorString___nonzero__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___len__&quot;, _wrap_vectorString___len__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_pop&quot;, _wrap_vectorString_pop, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___getslice__&quot;, _wrap_vectorString___getslice__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___setslice__&quot;, _wrap_vectorString___setslice__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___delslice__&quot;, _wrap_vectorString___delslice__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___delitem__&quot;, _wrap_vectorString___delitem__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___getitem__&quot;, _wrap_vectorString___getitem__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString___setitem__&quot;, _wrap_vectorString___setitem__, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_append&quot;, _wrap_vectorString_append, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_empty&quot;, _wrap_vectorString_empty, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_size&quot;, _wrap_vectorString_size, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_clear&quot;, _wrap_vectorString_clear, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_swap&quot;, _wrap_vectorString_swap, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_get_allocator&quot;, _wrap_vectorString_get_allocator, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_begin&quot;, _wrap_vectorString_begin, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_end&quot;, _wrap_vectorString_end, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_rbegin&quot;, _wrap_vectorString_rbegin, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_rend&quot;, _wrap_vectorString_rend, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_pop_back&quot;, _wrap_vectorString_pop_back, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_erase&quot;, _wrap_vectorString_erase, METH_VARARGS, NULL},
+	 { (char *)&quot;new_vectorString&quot;, _wrap_new_vectorString, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_push_back&quot;, _wrap_vectorString_push_back, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_front&quot;, _wrap_vectorString_front, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_back&quot;, _wrap_vectorString_back, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_assign&quot;, _wrap_vectorString_assign, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_resize&quot;, _wrap_vectorString_resize, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_insert&quot;, _wrap_vectorString_insert, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_reserve&quot;, _wrap_vectorString_reserve, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_capacity&quot;, _wrap_vectorString_capacity, METH_VARARGS, NULL},
+	 { (char *)&quot;delete_vectorString&quot;, _wrap_delete_vectorString, METH_VARARGS, NULL},
+	 { (char *)&quot;vectorString_swigregister&quot;, vectorString_swigregister, METH_VARARGS, NULL},
+	 { NULL, NULL, 0, NULL }
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */
+
+static swig_type_info _swigt__p_DialogApi = {&quot;_p_DialogApi&quot;, &quot;DialogApi *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_EventManager = {&quot;_p_EventManager&quot;, &quot;EventManager *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GameAction = {&quot;_p_GameAction&quot;, &quot;GameAction *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_GameConfig = {&quot;_p_GameConfig&quot;, &quot;GameConfig *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_SoundSystem = {&quot;_p_SoundSystem&quot;, &quot;SoundSystem *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_allocator_type = {&quot;_p_allocator_type&quot;, &quot;allocator_type *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_boost__shared_ptrTSpaceLocation_t = {&quot;_p_boost__shared_ptrTSpaceLocation_t&quot;, &quot;boost::shared_ptr&lt;SpaceLocation &gt; *|SpaceLocationPtr *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_boost__shared_ptrTTGameEvent_t = {&quot;_p_boost__shared_ptrTTGameEvent_t&quot;, &quot;boost::shared_ptr&lt;TGameEvent &gt; *|TGameEventPtr *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_char = {&quot;_p_char&quot;, &quot;char *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_difference_type = {&quot;_p_difference_type&quot;, &quot;difference_type *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_p_PyObject = {&quot;_p_p_PyObject&quot;, &quot;PyObject **&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_size_type = {&quot;_p_size_type&quot;, &quot;size_type *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_std__invalid_argument = {&quot;_p_std__invalid_argument&quot;, &quot;std::invalid_argument *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t = {&quot;_p_std__vectorTstd__string_std__allocatorTstd__string_t_t&quot;, &quot;std::vector&lt;std::string &gt; *|std::vector&lt;std::string,std::allocator&lt;std::string &gt; &gt; *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type = {&quot;_p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type&quot;, &quot;std::allocator&lt;std::string &gt; *|std::vector&lt;std::string &gt;::allocator_type *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_swig__PySwigIterator = {&quot;_p_swig__PySwigIterator&quot;, &quot;swig::PySwigIterator *&quot;, 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_value_type = {&quot;_p_value_type&quot;, &quot;value_type *&quot;, 0, 0, (void*)0, 0};
+
+static swig_type_info *swig_type_initial[] = {
+  &amp;_swigt__p_DialogApi,
+  &amp;_swigt__p_EventManager,
+  &amp;_swigt__p_GameAction,
+  &amp;_swigt__p_GameConfig,
+  &amp;_swigt__p_SoundSystem,
+  &amp;_swigt__p_allocator_type,
+  &amp;_swigt__p_boost__shared_ptrTSpaceLocation_t,
+  &amp;_swigt__p_boost__shared_ptrTTGameEvent_t,
+  &amp;_swigt__p_char,
+  &amp;_swigt__p_difference_type,
+  &amp;_swigt__p_p_PyObject,
+  &amp;_swigt__p_size_type,
+  &amp;_swigt__p_std__invalid_argument,
+  &amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
+  &amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
+  &amp;_swigt__p_swig__PySwigIterator,
+  &amp;_swigt__p_value_type,
+};
+
+static swig_cast_info _swigc__p_DialogApi[] = {  {&amp;_swigt__p_DialogApi, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_EventManager[] = {  {&amp;_swigt__p_EventManager, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GameAction[] = {  {&amp;_swigt__p_GameAction, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_GameConfig[] = {  {&amp;_swigt__p_GameConfig, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_SoundSystem[] = {  {&amp;_swigt__p_SoundSystem, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_allocator_type[] = {  {&amp;_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_boost__shared_ptrTSpaceLocation_t[] = {  {&amp;_swigt__p_boost__shared_ptrTSpaceLocation_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_boost__shared_ptrTTGameEvent_t[] = {  {&amp;_swigt__p_boost__shared_ptrTTGameEvent_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_char[] = {  {&amp;_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_difference_type[] = {  {&amp;_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_p_PyObject[] = {  {&amp;_swigt__p_p_PyObject, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_size_type[] = {  {&amp;_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&amp;_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t[] = {  {&amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type[] = {  {&amp;_swigt__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_swig__PySwigIterator[] = {  {&amp;_swigt__p_swig__PySwigIterator, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_value_type[] = {  {&amp;_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
+
+static swig_cast_info *swig_cast_initial[] = {
+  _swigc__p_DialogApi,
+  _swigc__p_EventManager,
+  _swigc__p_GameAction,
+  _swigc__p_GameConfig,
+  _swigc__p_SoundSystem,
+  _swigc__p_allocator_type,
+  _swigc__p_boost__shared_ptrTSpaceLocation_t,
+  _swigc__p_boost__shared_ptrTTGameEvent_t,
+  _swigc__p_char,
+  _swigc__p_difference_type,
+  _swigc__p_p_PyObject,
+  _swigc__p_size_type,
+  _swigc__p_std__invalid_argument,
+  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t,
+  _swigc__p_std__vectorTstd__string_std__allocatorTstd__string_t_t__allocator_type,
+  _swigc__p_swig__PySwigIterator,
+  _swigc__p_value_type,
+};
+
+
+/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */
+
+static swig_const_info swig_const_table[] = {
+{0, 0, 0, 0.0, 0, 0}};
+
+#ifdef __cplusplus
+}
+#endif
+/* -----------------------------------------------------------------------------
+ * Type initialization:
+ * This problem is tough by the requirement that no dynamic 
+ * memory is used. Also, since swig_type_info structures store pointers to 
+ * swig_cast_info structures and swig_cast_info structures store pointers back
+ * to swig_type_info structures, we need some lookup code at initialization. 
+ * The idea is that swig generates all the structures that are needed. 
+ * The runtime then collects these partially filled structures. 
+ * The SWIG_InitializeModule function takes these initial arrays out of 
+ * swig_module, and does all the lookup, filling in the swig_module.types
+ * array with the correct data and linking the correct swig_cast_info
+ * structures together.
+ *
+ * The generated swig_type_info structures are assigned staticly to an initial 
+ * array. We just loop though that array, and handle each type individually.
+ * First we lookup if this type has been already loaded, and if so, use the
+ * loaded structure instead of the generated one. Then we have to fill in the
+ * cast linked list. The cast data is initially stored in something like a
+ * two-dimensional array. Each row corresponds to a type (there are the same
+ * number of rows as there are in the swig_type_initial array). Each entry in
+ * a column is one of the swig_cast_info structures for that type.
+ * The cast_initial array is actually an array of arrays, because each row has
+ * a variable number of columns. So to actually build the cast linked list,
+ * we find the array of casts associated with the type, and loop through it 
+ * adding the casts to the list. The one last trick we need to do is making
+ * sure the type pointer in the swig_cast_info struct is correct.
+ *
+ * First off, we lookup the cast-&gt;type name to see if it is already loaded. 
+ * There are three cases to handle:
+ *  1) If the cast-&gt;type has already been loaded AND the type we are adding
+ *     casting info to has not been loaded (it is in this module), THEN we
+ *     replace the cast-&gt;type pointer with the type pointer that has already
+ *     been loaded.
+ *  2) If BOTH types (the one we are adding casting info to, and the 
+ *     cast-&gt;type) are loaded, THEN the cast info has already been loaded by
+ *     the previous module so we just ignore it.
+ *  3) Finally, if cast-&gt;type has not already been loaded, then we add that
+ *     swig_cast_info to the linked list (because the cast-&gt;type) pointer will
+ *     be correct.
+ * ----------------------------------------------------------------------------- */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#if 0
+} /* c-mode */
+#endif
+#endif
+
+#if 0
+#define SWIGRUNTIME_DEBUG
+#endif
+
+SWIGRUNTIME void
+SWIG_InitializeModule(void *clientdata) {
+  size_t i;
+  swig_module_info *module_head;
+  static int init_run = 0;
+  
+  clientdata = clientdata;
+  
+  if (init_run) return;
+  init_run = 1;
+  
+  /* Initialize the swig_module */
+  swig_module.type_initial = swig_type_initial;
+  swig_module.cast_initial = swig_cast_initial;
+  
+  /* Try and load any already created modules */
+  module_head = SWIG_GetModule(clientdata);
+  if (module_head) {
+    swig_module.next = module_head-&gt;next;
+    module_head-&gt;next = &amp;swig_module;
+  } else {
+    /* This is the first module loaded */
+    swig_module.next = &amp;swig_module;
+    SWIG_SetModule(clientdata, &amp;swig_module);
+  }
+  
+  /* Now work on filling in swig_module.types */
+#ifdef SWIGRUNTIME_DEBUG
+  printf(&quot;SWIG_InitializeModule: size %d\n&quot;, swig_module.size);
+#endif
+  for (i = 0; i &lt; swig_module.size; ++i) {
+    swig_type_info *type = 0;
+    swig_type_info *ret;
+    swig_cast_info *cast;
+    
+#ifdef SWIGRUNTIME_DEBUG
+    printf(&quot;SWIG_InitializeModule: type %d %s\n&quot;, i, swig_module.type_initial[i]-&gt;name);
+#endif
+    
+    /* if there is another module already loaded */
+    if (swig_module.next != &amp;swig_module) {
+      type = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, swig_module.type_initial[i]-&gt;name);
+    }
+    if (type) {
+      /* Overwrite clientdata field */
+#ifdef SWIGRUNTIME_DEBUG
+      printf(&quot;SWIG_InitializeModule: found type %s\n&quot;, type-&gt;name);
+#endif
+      if (swig_module.type_initial[i]-&gt;clientdata) {
+        type-&gt;clientdata = swig_module.type_initial[i]-&gt;clientdata;
+#ifdef SWIGRUNTIME_DEBUG
+        printf(&quot;SWIG_InitializeModule: found and overwrite type %s \n&quot;, type-&gt;name);
+#endif
+      }
+    } else {
+      type = swig_module.type_initial[i];
+    }
+    
+    /* Insert casting types */
+    cast = swig_module.cast_initial[i];
+    while (cast-&gt;type) {
+      /* Don't need to add information already in the list */
+      ret = 0;
+#ifdef SWIGRUNTIME_DEBUG
+      printf(&quot;SWIG_InitializeModule: look cast %s\n&quot;, cast-&gt;type-&gt;name);
+#endif
+      if (swig_module.next != &amp;swig_module) {
+        ret = SWIG_MangledTypeQueryModule(swig_module.next, &amp;swig_module, cast-&gt;type-&gt;name);
+#ifdef SWIGRUNTIME_DEBUG
+        if (ret) printf(&quot;SWIG_InitializeModule: found cast %s\n&quot;, ret-&gt;name);
+#endif
+      }
+      if (ret) {
+        if (type == swig_module.type_initial[i]) {
+#ifdef SWIGRUNTIME_DEBUG
+          printf(&quot;SWIG_InitializeModule: skip old type %s\n&quot;, ret-&gt;name);
+#endif
+          cast-&gt;type = ret;
+          ret = 0;
+        } else {
+          /* Check for casting already in the list */
+          swig_cast_info *ocast = SWIG_TypeCheck(ret-&gt;name, type);
+#ifdef SWIGRUNTIME_DEBUG
+          if (ocast) printf(&quot;SWIG_InitializeModule: skip old cast %s\n&quot;, ret-&gt;name);
+#endif
+          if (!ocast) ret = 0;
+        }
+      }
+      
+      if (!ret) {
+#ifdef SWIGRUNTIME_DEBUG
+        printf(&quot;SWIG_InitializeModule: adding cast %s\n&quot;, cast-&gt;type-&gt;name);
+#endif
+        if (type-&gt;cast) {
+          type-&gt;cast-&gt;prev = cast;
+          cast-&gt;next = type-&gt;cast;
+        }
+        type-&gt;cast = cast;
+      }
+      cast++;
+    }
+    /* Set entry in modules-&gt;types array equal to the type */
+    swig_module.types[i] = type;
+  }
+  swig_module.types[i] = 0;
+  
+#ifdef SWIGRUNTIME_DEBUG
+  printf(&quot;**** SWIG_InitializeModule: Cast List ******\n&quot;);
+  for (i = 0; i &lt; swig_module.size; ++i) {
+    int j = 0;
+    swig_cast_info *cast = swig_module.cast_initial[i];
+    printf(&quot;SWIG_InitializeModule: type %d %s\n&quot;, i, swig_module.type_initial[i]-&gt;name);
+    while (cast-&gt;type) {
+      printf(&quot;SWIG_InitializeModule: cast type %s\n&quot;, cast-&gt;type-&gt;name);
+      cast++;
+      ++j;
+    }
+    printf(&quot;---- Total casts: %d\n&quot;,j);
+  }
+  printf(&quot;**** SWIG_InitializeModule: Cast List ******\n&quot;);
+#endif
+}
+
+/* This function will propagate the clientdata field of type to
+* any new swig_type_info structures that have been added into the list
+* of equivalent types.  It is like calling
+* SWIG_TypeClientData(type, clientdata) a second time.
+*/
+SWIGRUNTIME void
+SWIG_PropagateClientData(void) {
+  size_t i;
+  swig_cast_info *equiv;
+  static int init_run = 0;
+  
+  if (init_run) return;
+  init_run = 1;
+  
+  for (i = 0; i &lt; swig_module.size; i++) {
+    if (swig_module.types[i]-&gt;clientdata) {
+      equiv = swig_module.types[i]-&gt;cast;
+      while (equiv) {
+        if (!equiv-&gt;converter) {
+          if (equiv-&gt;type &amp;&amp; !equiv-&gt;type-&gt;clientdata)
+          SWIG_TypeClientData(equiv-&gt;type, swig_module.types[i]-&gt;clientdata);
+        }
+        equiv = equiv-&gt;next;
+      }
+    }
+  }
+}
+
+#ifdef __cplusplus
+#if 0
+{
+  /* c-mode */
+#endif
+}
+#endif
+
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+  
+  /* Python-specific SWIG API */
+#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
+#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
+#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
+  
+  /* -----------------------------------------------------------------------------
+   * global variable support code.
+   * ----------------------------------------------------------------------------- */
+  
+  typedef struct swig_globalvar {
+    char       *name;                  /* Name of global variable */
+    PyObject *(*get_attr)(void);       /* Return the current value */
+    int       (*set_attr)(PyObject *); /* Set the value */
+    struct swig_globalvar *next;
+  } swig_globalvar;
+  
+  typedef struct swig_varlinkobject {
+    PyObject_HEAD
+    swig_globalvar *vars;
+  } swig_varlinkobject;
+  
+  SWIGINTERN PyObject *
+  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
+    return PyString_FromString(&quot;&lt;Swig global variables&gt;&quot;);
+  }
+  
+  SWIGINTERN PyObject *
+  swig_varlink_str(swig_varlinkobject *v) {
+    PyObject *str = PyString_FromString(&quot;(&quot;);
+    swig_globalvar  *var;
+    for (var = v-&gt;vars; var; var=var-&gt;next) {
+      PyString_ConcatAndDel(&amp;str,PyString_FromString(var-&gt;name));
+      if (var-&gt;next) PyString_ConcatAndDel(&amp;str,PyString_FromString(&quot;, &quot;));
+    }
+    PyString_ConcatAndDel(&amp;str,PyString_FromString(&quot;)&quot;));
+    return str;
+  }
+  
+  SWIGINTERN int
+  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
+    PyObject *str = swig_varlink_str(v);
+    fprintf(fp,&quot;Swig global variables &quot;);
+    fprintf(fp,&quot;%s\n&quot;, PyString_AsString(str));
+    Py_DECREF(str);
+    return 0;
+  }
+  
+  SWIGINTERN void
+  swig_varlink_dealloc(swig_varlinkobject *v) {
+    swig_globalvar *var = v-&gt;vars;
+    while (var) {
+      swig_globalvar *n = var-&gt;next;
+      free(var-&gt;name);
+      free(var);
+      var = n;
+    }
+  }
+  
+  SWIGINTERN PyObject *
+  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
+    PyObject *res = NULL;
+    swig_globalvar *var = v-&gt;vars;
+    while (var) {
+      if (strcmp(var-&gt;name,n) == 0) {
+        res = (*var-&gt;get_attr)();
+        break;
+      }
+      var = var-&gt;next;
+    }
+    if (res == NULL &amp;&amp; !PyErr_Occurred()) {
+      PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+    }
+    return res;
+  }
+  
+  SWIGINTERN int
+  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
+    int res = 1;
+    swig_globalvar *var = v-&gt;vars;
+    while (var) {
+      if (strcmp(var-&gt;name,n) == 0) {
+        res = (*var-&gt;set_attr)(p);
+        break;
+      }
+      var = var-&gt;next;
+    }
+    if (res == 1 &amp;&amp; !PyErr_Occurred()) {
+      PyErr_SetString(PyExc_NameError,&quot;Unknown C global variable&quot;);
+    }
+    return res;
+  }
+  
+  SWIGINTERN PyTypeObject*
+  swig_varlink_type(void) {
+    static char varlink__doc__[] = &quot;Swig var link object&quot;;
+    static PyTypeObject varlink_type;
+    static int type_init = 0;  
+    if (!type_init) {
+      const PyTypeObject tmp
+      = {
+        PyObject_HEAD_INIT(NULL)
+        0,                                  /* Number of items in variable part (ob_size) */
+        (char *)&quot;swigvarlink&quot;,              /* Type name (tp_name) */
+        sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
+        0,                                  /* Itemsize (tp_itemsize) */
+        (destructor) swig_varlink_dealloc,   /* Deallocator (tp_dealloc) */ 
+        (printfunc) swig_varlink_print,     /* Print (tp_print) */
+        (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
+        (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
+        0,                                  /* tp_compare */
+        (reprfunc) swig_varlink_repr,       /* tp_repr */
+        0,                                  /* tp_as_number */
+        0,                                  /* tp_as_sequence */
+        0,                                  /* tp_as_mapping */
+        0,                                  /* tp_hash */
+        0,                                  /* tp_call */
+        (reprfunc)swig_varlink_str,        /* tp_str */
+        0,                                  /* tp_getattro */
+        0,                                  /* tp_setattro */
+        0,                                  /* tp_as_buffer */
+        0,                                  /* tp_flags */
+        varlink__doc__,                     /* tp_doc */
+        0,                                  /* tp_traverse */
+        0,                                  /* tp_clear */
+        0,                                  /* tp_richcompare */
+        0,                                  /* tp_weaklistoffset */
+#if PY_VERSION_HEX &gt;= 0x02020000
+        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -&gt; tp_weaklist */
+#endif
+#if PY_VERSION_HEX &gt;= 0x02030000
+        0,                                  /* tp_del */
+#endif
+#ifdef COUNT_ALLOCS
+        0,0,0,0                             /* tp_alloc -&gt; tp_next */
+#endif
+      };
+      varlink_type = tmp;
+      varlink_type.ob_type = &amp;PyType_Type;
+      type_init = 1;
+    }
+    return &amp;varlink_type;
+  }
+  
+  /* Create a variable linking object for use later */
+  SWIGINTERN PyObject *
+  SWIG_Python_newvarlink(void) {
+    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
+    if (result) {
+      result-&gt;vars = 0;
+    }
+    return ((PyObject*) result);
+  }
+  
+  SWIGINTERN void 
+  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
+    swig_varlinkobject *v = (swig_varlinkobject *) p;
+    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
+    if (gv) {
+      size_t size = strlen(name)+1;
+      gv-&gt;name = (char *)malloc(size);
+      if (gv-&gt;name) {
+        strncpy(gv-&gt;name,name,size);
+        gv-&gt;get_attr = get_attr;
+        gv-&gt;set_attr = set_attr;
+        gv-&gt;next = v-&gt;vars;
+      }
+    }
+    v-&gt;vars = gv;
+  }
+  
+  SWIGINTERN PyObject *
+  SWIG_globals() {
+    static PyObject *_SWIG_globals = 0; 
+    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
+    return _SWIG_globals;
+  }
+  
+  /* -----------------------------------------------------------------------------
+   * constants/methods manipulation
+   * ----------------------------------------------------------------------------- */
+  
+  /* Install Constants */
+  SWIGINTERN void
+  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
+    PyObject *obj = 0;
+    size_t i;
+    for (i = 0; constants[i].type; ++i) {
+      switch(constants[i].type) {
+      case SWIG_PY_POINTER:
+        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
+        break;
+      case SWIG_PY_BINARY:
+        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
+        break;
+      default:
+        obj = 0;
+        break;
+      }
+      if (obj) {
+        PyDict_SetItemString(d, constants[i].name, obj);
+        Py_DECREF(obj);
+      }
+    }
+  }
+  
+  /* -----------------------------------------------------------------------------*/
+  /* Fix SwigMethods to carry the callback ptrs when needed */
+  /* -----------------------------------------------------------------------------*/
+  
+  SWIGINTERN void
+  SWIG_Python_FixMethods(PyMethodDef *methods,
+    swig_const_info *const_table,
+    swig_type_info **types,
+    swig_type_info **types_initial) {
+    size_t i;
+    for (i = 0; methods[i].ml_name; ++i) {
+      char *c = methods[i].ml_doc;
+      if (c &amp;&amp; (c = strstr(c, &quot;swig_ptr: &quot;))) {
+        int j;
+        swig_const_info *ci = 0;
+        char *name = c + 10;
+        for (j = 0; const_table[j].type; ++j) {
+          if (strncmp(const_table[j].name, name, 
+              strlen(const_table[j].name)) == 0) {
+            ci = &amp;(const_table[j]);
+            break;
+          }
+        }
+        if (ci) {
+          size_t shift = (ci-&gt;ptype) - types;
+          swig_type_info *ty = types_initial[shift];
+          size_t ldoc = (c - methods[i].ml_doc);
+          size_t lptr = strlen(ty-&gt;name)+2*sizeof(void*)+2;
+          char *ndoc = (char*)malloc(ldoc + lptr + 10);
+          if (ndoc) {
+            char *buff = ndoc;
+            void *ptr = (ci-&gt;type == SWIG_PY_POINTER) ? ci-&gt;pvalue : 0;
+            if (ptr) {
+              strncpy(buff, methods[i].ml_doc, ldoc);
+              buff += ldoc;
+              strncpy(buff, &quot;swig_ptr: &quot;, 10);
+              buff += 10;
+              SWIG_PackVoidPtr(buff, ptr, ty-&gt;name, lptr);
+              methods[i].ml_doc = ndoc;
+            }
+          }
+        }
+      }
+    }
+  } 
+  
+#ifdef __cplusplus
+}
+#endif
+
+/* -----------------------------------------------------------------------------*
+ *  Partial Init method
+ * -----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern &quot;C&quot;
+#endif
+SWIGEXPORT void SWIG_init(void) {
+  PyObject *m, *d;
+  
+  /* Fix SwigMethods to carry the callback ptrs when needed */
+  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
+  
+  m = Py_InitModule((char *) SWIG_name, SwigMethods);
+  d = PyModule_GetDict(m);
+  
+  SWIG_InitializeModule(0);
+  SWIG_InstallConstants(d,swig_const_table);
+  
+  
+  PyDict_SetItemString(d,(char*)&quot;cvar&quot;, SWIG_globals());
+  SWIG_addvarlink(SWIG_globals(),(char*)&quot;tw_sound&quot;,tw_sound_get, tw_sound_set);
+}
+

Modified: trunk/source/melee/mcbodies.cpp
===================================================================
--- trunk/source/melee/mcbodies.cpp	2006-01-18 05:03:58 UTC (rev 207)
+++ trunk/source/melee/mcbodies.cpp	2006-05-08 11:32:42 UTC (rev 208)
@@ -31,6 +31,7 @@
 #include &quot;mgame.h&quot;
 #include &quot;other/twconfig.h&quot;
 
+
 Asteroid::Asteroid() 
 :	SpaceObject(NULL, random(map_size), random(PI2), game-&gt;meleedata.asteroidSprite), explosion(game-&gt;meleedata.asteroidExplosionSprite)
 {
@@ -380,23 +381,25 @@
   int i;
   v = NULL;
   set_depth(DEPTH_STARS);
-  DATAFILE *stardat = load_datafile(data_full_path(&quot;stars.dat&quot;).c_str());
-  if (!stardat) 
-    {
-      tw_error(&quot;stars.dat not found!&quot;);
-      num_pics = 0;
-      pic = NULL;
-      num_stars = 0;
-      num_layers = 0;
-      return;
-    }
-  for (i = 0; (stardat[i].type == DAT_RLE_SPRITE) || (stardat[i].type == DAT_BITMAP); i += 1) ;
-  num_pics = i;
+
+  num_pics = 19;
   pic = new SpaceSprite*[num_pics];
   seed = rng.raw64();
   for(i = 0; i &lt; num_pics; i++) 
     {
-      pic[i] = new SpaceSprite(&amp;stardat[i], 1, 
+      char tmp[256];
+      char* ptmp = tmp;
+      sprintf(tmp, &quot;images/stars/star%3d.bmp&quot;, i+1);
+      while(*ptmp)
+        {
+	  if(*ptmp == ' ')
+	    *ptmp = '0';
+	  ptmp++;
+        }
+      std::vector&lt;std::string&gt; star;
+      star.push_back(tmp);
+      
+      pic[i] = new SpaceSprite(star, 1, 
 			       SpaceSprite::ALPHA | 
 			       SpaceSprite::MASKED | 
 			       SpaceSprite::IRREGULAR | 
@@ -411,7 +414,6 @@
   field_depth = get_config_int(&quot;Stars&quot;, &quot;Depth&quot;, 192);
   tw_set_config_file(&quot;client.ini&quot;);
   aa_mode = get_config_int(&quot;Stars&quot;, &quot;Quality&quot;, 5);
-  unload_datafile(stardat);
 }
 Stars::~Stars() 
 {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000155.html">[Tw-light-svn] r209 - in trunk: gamedata gamedata/games/test_game/scripts/systems gamedata/images gamedata/images/stations source source/games source/generated source/melee source/tml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#154">[ date ]</a>
              <a href="thread.html#154">[ thread ]</a>
              <a href="subject.html#154">[ subject ]</a>
              <a href="author.html#154">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tw-light-svn">More information about the Tw-light-svn
mailing list</a><br>
</body></html>
